<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>uidev-css</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://uidev-css.github.io///posts/15" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="uidev-css" data-gatsby-head="true"/><meta property="og:title" content="uidev-css" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://uidev-css.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://uidev-css.github.io///posts/15" data-gatsby-head="true"/><meta name="twitter:title" content="uidev-css" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | uidev-css" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/873-1e1f6fb6fd3c8994.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-498da29379dd58dc.js" defer=""></script><script src="/_next/static/Is-d56jDFXkc1ZfN4DhBP/_buildManifest.js" defer=""></script><script src="/_next/static/Is-d56jDFXkc1ZfN4DhBP/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UIDEV CSS</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="2023년 AI 개발자로서의 여정 생성 모델 AI 웹 앱 개발 과정에서 얻은 교훈" href="/post/2024-06-19-FromDataScientisttoAIDeveloperLessonsBuildingaGenerativeAIWebAppin2023"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="2023년 AI 개발자로서의 여정 생성 모델 AI 웹 앱 개발 과정에서 얻은 교훈" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-FromDataScientisttoAIDeveloperLessonsBuildingaGenerativeAIWebAppin2023_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="2023년 AI 개발자로서의 여정 생성 모델 AI 웹 앱 개발 과정에서 얻은 교훈" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">2023년 AI 개발자로서의 여정 생성 모델 AI 웹 앱 개발 과정에서 얻은 교훈</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Azure CosmosDB, 중복 검증 스트레로이드 버전" href="/post/2024-06-19-AzureCosmosDBZodDataValidationonSteroids"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Azure CosmosDB, 중복 검증 스트레로이드 버전" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-AzureCosmosDBZodDataValidationonSteroids_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Azure CosmosDB, 중복 검증 스트레로이드 버전" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Azure CosmosDB, 중복 검증 스트레로이드 버전</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="엘로퀀트 깊숙한 학습 라라벨 개발자가 반드시 알아야 할 40가지 잘 사용되지 않는 엘로퀀트 ORM 메서드" href="/post/2024-06-19-DeepDiveintoEloquent40RarelyUsedEloquentORMMethodsEveryLaravelDeveloperMUSTKnow"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="엘로퀀트 깊숙한 학습 라라벨 개발자가 반드시 알아야 할 40가지 잘 사용되지 않는 엘로퀀트 ORM 메서드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-DeepDiveintoEloquent40RarelyUsedEloquentORMMethodsEveryLaravelDeveloperMUSTKnow_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="엘로퀀트 깊숙한 학습 라라벨 개발자가 반드시 알아야 할 40가지 잘 사용되지 않는 엘로퀀트 ORM 메서드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">엘로퀀트 깊숙한 학습 라라벨 개발자가 반드시 알아야 할 40가지 잘 사용되지 않는 엘로퀀트 ORM 메서드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">16<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="인터넷의 종말" href="/post/2024-06-19-Theendoftheinternet"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="인터넷의 종말" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-Theendoftheinternet_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="인터넷의 종말" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">인터넷의 종말</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="간단한 Snake 게임 만들기 HTML, CSS 및 JavaScript를 활용하여 함께 해봐요" href="/post/2024-06-19-BuildingaSimpleSnakeGamewithHTMLCSSandJavaScript"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="간단한 Snake 게임 만들기 HTML, CSS 및 JavaScript를 활용하여 함께 해봐요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-BuildingaSimpleSnakeGamewithHTMLCSSandJavaScript_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="간단한 Snake 게임 만들기 HTML, CSS 및 JavaScript를 활용하여 함께 해봐요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">간단한 Snake 게임 만들기 HTML, CSS 및 JavaScript를 활용하여 함께 해봐요</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="C Net에서의 멀티스레딩 소개 및 모범 사례" href="/post/2024-06-19-MultithreadinginCNetIntroductionandBestpractices"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="C Net에서의 멀티스레딩 소개 및 모범 사례" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="C Net에서의 멀티스레딩 소개 및 모범 사례" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">C Net에서의 멀티스레딩 소개 및 모범 사례</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">21<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="프론트엔드 주간 요약 367 2024년 6월 10일 - 6월 16일" href="/post/2024-06-19-FrontendWeeklyDigest3671016Jun2024"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="프론트엔드 주간 요약 367 2024년 6월 10일 - 6월 16일" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-FrontendWeeklyDigest3671016Jun2024_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="프론트엔드 주간 요약 367 2024년 6월 10일 - 6월 16일" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">프론트엔드 주간 요약 367 2024년 6월 10일 - 6월 16일</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="슈퍼 빠른 http 서버 만들기 with Rust  htmx 파트 1" href="/post/2024-06-19-SuperfasthttpserverwithRusthtmxpart1"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="슈퍼 빠른 http 서버 만들기 with Rust  htmx 파트 1" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-SuperfasthttpserverwithRusthtmxpart1_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="슈퍼 빠른 http 서버 만들기 with Rust  htmx 파트 1" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">슈퍼 빠른 http 서버 만들기 with Rust  htmx 파트 1</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="플러터 앱 라이프사이클 이해하기 단계별 안내" href="/post/2024-06-19-UnderstandingFlutterAppLifecycleAStep-by-StepGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="플러터 앱 라이프사이클 이해하기 단계별 안내" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-UnderstandingFlutterAppLifecycleAStep-by-StepGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="플러터 앱 라이프사이클 이해하기 단계별 안내" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">플러터 앱 라이프사이클 이해하기 단계별 안내</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="플러터에서 ORM으로 Drift 사용하기" href="/post/2024-06-19-UseDriftforORMinFlutter"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="플러터에서 ORM으로 Drift 사용하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-UseDriftforORMinFlutter_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="플러터에서 ORM으로 Drift 사용하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">플러터에서 ORM으로 Drift 사용하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link posts_-active__YVJEi" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"2023년 AI 개발자로서의 여정 생성 모델 AI 웹 앱 개발 과정에서 얻은 교훈","description":"","date":"2024-06-19 14:46","slug":"2024-06-19-FromDataScientisttoAIDeveloperLessonsBuildingaGenerativeAIWebAppin2023","content":"\n\n## 수천 명의 사용자를 대상으로 하는 AI 웹 앱을 구축하고자 하는 데이터 과학 열정가를 위한 기술 팁 안내서\n\n![이미지](/assets/img/2024-06-19-FromDataScientisttoAIDeveloperLessonsBuildingaGenerativeAIWebAppin2023_0.png)\n\n만약 대학교나 온라인 강좌 중 하나를 통해 데이터 과학의 세계로 모험을 떴다면, 아마도 ML/AI 소프트웨어 제품을 만들어 사람들이 사용할 수 있는 꿈을 품어 보았을 것입니다. 우리 CS 친구들이 쉽게 코딩하는 것처럼 말이죠.\n\n하지만 풀 스택 웹 개발에 손을 대보면 구성, 배포, 터미널 명령 및 서버 등과 같이 굉장히 어렵게 느껴질 수 있는 장벽에 봉착하게 될 겁니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![2024-06-19-FromDataScientisttoAIDeveloperLessonsBuildingaGenerativeAIWebAppin2023_1.png](/assets/img/2024-06-19-FromDataScientisttoAIDeveloperLessonsBuildingaGenerativeAIWebAppin2023_1.png)\n\n이런 것은 아주 잘 알아요. 도움을 받을 수 없이 시간을 보내다 보니, 저에게 기능이 있는 소프트웨어 앱을 만들어낼 수 없을 거라는 나의 열등감만 깊어졌어요.\n\n그런데 정확히 1년 전인 1월 21일, 여권 문제와 취소된 여행으로 예상치 못하게 여는 주말이 생겼고, AI 앱을 만드는 여행에 나섰어요. 이 여행은 예상치 못한 곳으로 나를 이끌었죠 — 세계 반대편에 있는 공동 창업자와 팀을 이루고, 샌프란시스코 스타트업 가속기에 참가하게 되어, 결국 수천 명의 사용자를 확보하고 상당한 연간 수익을 창출했어요 (우리 앱 'Podsmart!'을 확인해보세요. 우리는 팟캐스트를 요약해요).\n\n![2024-06-19-FromDataScientisttoAIDeveloperLessonsBuildingaGenerativeAIWebAppin2023_2.png](/assets/img/2024-06-19-FromDataScientisttoAIDeveloperLessonsBuildingaGenerativeAIWebAppin2023_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 무엇보다 중요한 것은, 그것은 당혹스러운 소프트웨어 개발 세계를 형식적인 컴퓨터 과학/소프트웨어 엔지니어링 배경 없이 탐험하며 고통스러운 여정이었습니다.\n\n따라서 내 첫 번째 소프트웨어 제품을 만들며 지난 일년을 돌아보면, 수천 명의 사용자를 위해 기능적인 웹 앱을 구축하려는 데이터 과학 애호가를 위한 일부 기술적 팁을 모았습니다.\n\n이 가이드는 내가 일 년 동안 겪은 고난과 배움에서 탄생했으며, 1년 전의 나에게 전하고 싶었던 조언을 대변합니다.\n\n참고: 이 팁은 내 개별적인 경험을 바탕으로 한 것이며, 다른 사람들에게는 다르게 작용할 수 있습니다. 또한 여기서 권장된 도구들과는 어떠한 관계나 제휴도 없음을 밝힙니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 목차\n\n- 원하는 것을 만들고 싶다면\n- YouTube 웹 개발 튜토리얼의 위험성\n  - 팁 #1: React 대신 Next.js 사용\n  - 팁 #2: 스타일링을 위해 Bootstrap 대신 Tailwind CSS 선택\n- 데이터 과학 마인드셋의 함정\n  - 팁 #3: 백엔드로 Flask 대신 FastAPI 선택하고 응답 모델을 엄밀히 정의\n  - 팁 #4: JavaScript 대신 TypeScript 사용\n- 배포에 대해\n  - 팁 #5: 백엔드에 GPU 백엔드로 모델 사용\n  - 팁 #6: 백엔드 배포에 AWS Lambda, 프론트엔드에 Vercel 사용\n- 삶을 편하게 만들기\n  - 팁 #7: React를 사용하여 직접 랜딩 페이지를 만들지 말기\n  - 팁 #8: 사용자 인증 및 결제를 위해 Firebase + Stripe 사용\n  - 팁 #9: 에러 모니터링을 위해 Sentry 구현\n- 결론\n\n# 원하는 것을 만들고 싶을 때\n\n해당 기능을 갖춘 웹 앱을 만들려면 사용자가 상호 작용할 수 있는 웹 인터페이스(프론트엔드 또는 클라이언트)와 데이터 처리, 데이터 저장, ML/AI 모델 호출을 담당하는 서버(백엔드)가 필요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n(스트림릿에 대해 들어본 적이 있을 수 있어요. 가장 간단한 데모에 적합하지만, 실제로 사용할 수 있는 제품 앱을 만들기에는 사용자 정의 가능성이 부족합니다)\n\n# 유튜브 웹 개발 튜토리얼의 위험성\n\n데이터 과학자로서 소프트웨어 개발의 여러 측면이 나를 불안하게 만듭니다. 망가진 구성에 몇 일을 소비할 위험을 맞이하는 것과 같은 것들이 그 중 하나에요. 무언가가 고장났는데 왜 고장났는지 알 수 없고 어떻게 고칠지 모르는 것보다 더 답답한 것은 없죠.\n\n결과적으로, React 프로젝트 설정, 백엔드 또는 웹사이트 배포 등 전체 프로세스를 세밀하게 보여주는 유튜브 같은 튜토리얼에 절박하게 의존하게 되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n돌아봤을 때, 두 가지 주요 단점이 있었어요:\n\n첫째, 여러 개의 상반된하고 잠재적으로 오래된 튜토리얼로 인한 혼란(예를 들어, 새로운 React 버전이 출시될 때). 이로 인해 종종 더 이상 동작하지 않음을 깨달을 때까지 튜토리얼을 따라가게 되었어요.\n\n둘째, 대부분의 튜토리얼은 초보자를 위한 멋진 수업 데모를 만드는 데 중점을 두고 있어요. 그래서 성능 상한선이 낮은 프레임워크를 사용하며 생산 및 확장성에 부족한 코딩 패턴을 강화하게 되죠. 고개를 돌아보니, YouTube 튜토리얼에서 나쁜 코딩 습관을 많이 털어놓는 모습을 보았어요. 그 습관들은 이제 앱을 수천 명의 사용자에게 제공하는 실제 제품으로 발전하는 데 방해가 되고 있죠.\n\n실패로부터 최고의 교훈을 얻는다고 생각해요. 이러한 프로세스는 짜증 나지만 전해 동안 저에게는 막대한 학습 경험이 되었어요. 아마 나의 실패로부터 배울 때 많은 시간을 절약하실 수 있을 거예요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 팁 #1: React 대신에 Next.js를 사용하세요\n\n![이미지](/assets/img/2024-06-19-FromDataScientisttoAIDeveloperLessonsBuildingaGenerativeAIWebAppin2023_3.png)\n\n많은 YouTube 튜토리얼들이 React를 선호하며, 처음에는 그에 따랐습니다.\n\n그러나 결국 사이트의 SEO(검색 엔진 최적화) 성능을 향상시키고 싶어졌습니다 — 이는 더 많은 사용자 획득에 매우 중요합니다. React의 한계인 메타 태그를 동적으로 변경할 수 없고 서버 측 렌더링이 없는 등의 제약은 귀찮은 작업을 요구하며, Next.js로 변경해야 했습니다. 변경 후에는 성능 차이가 확연히 날밤과 같았습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![image](/assets/img/2024-06-19-FromDataScientisttoAIDeveloperLessonsBuildingaGenerativeAIWebAppin2023_4.png)\n\n어떤 사람들은 React가 초보자에게 더 친숙하다고 말하지만, Vercel(Next.js 개발자)의 예들을 들 수 있는 등 온라인에는 다양한 Next.js 템플릿이 많습니다. 특히 AI 애플리케이션에 대한 것이죠. Next.js는 실제로 거의 모든 AI 애플리케이션에서 사용되는 현대적인 웹 프레임워크입니다.\n\n## 팁 #2: 스타일링을 위해 부트스트랩 대신 Tailwind CSS를 선택하세요.\n\n프론트엔드 UI 여정을 시작할 때, 처음에는 다른 사람들의 튜토리얼을 따라 부트스트랩으로 향했습니다. 왜냐하면 드롭다운이나 아코디언 같은 준비된 컴포넌트로 쉽게 작업할 수 있다는 유혹이 있었기 때문이죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-19-FromDataScientisttoAIDeveloperLessonsBuildingaGenerativeAIWebAppin2023_5.png)\n\n하지만 잠시 후, 웹사이트가 매우 추려지고 현대적인 AI 데모 페이지와 비교했을 때 정말 추악해 보인다는 것을 깨달았어요. 그 부트스트랩 답은 느낌이 덜어져 있었는데, 그것은 수정이 어려운 일종의 미적 고집이었고, 혼동스럽게 명명된 CSS 클래스들에 뒤얽혀 있었어요. 그래서 결국, 다시 한번 용감을 내어 내 프론트 엔드 전체를 Tailwind CSS로 새롭게 만들기로 했죠. 3일이 걸렸어요.\n\n![이미지](/assets/img/2024-06-19-FromDataScientisttoAIDeveloperLessonsBuildingaGenerativeAIWebAppin2023_6.png)\n\n현대적이고 깔끔한 UI를 가진 AI 데모 페이지를 본 적이 있다면, 그들이 Tailwind CSS를 사용한 것일 확률이 매우 높아요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![2024-06-19-FromDataScientisttoAIDeveloperLessonsBuildingaGenerativeAIWebAppin2023_7.png](/assets/img/2024-06-19-FromDataScientisttoAIDeveloperLessonsBuildingaGenerativeAIWebAppin2023_7.png)\n\n처음에는 Tailwind에 겁을 먹었어요. 그 긴 구성 요소 정의는 암호처럼 보이는 유틸리티 클래스들로 넘쳐나 초보자 친화적이지 않아 보였거든요. Tailwind에는 미리 구성된 구성 요소가 부족하고 유틸리티 클래스를 기억하는 것이 어려울 것으로 생각했어요. 그런데 이는 전혀 사실이 아니었어요! Tailwind CSS로 만들어진 많은 훌륭한 UI 컴포넌트 라이브러리가 있어요. 저는 Flowbite React를 사용했어요(필요한 모든 컴포넌트가 다 들어있어요!)\n\n# 데이터 과학 마인드셋의 함정\n\n데이터 과학을 공부하다 보니, 파이썬을 정말 좋아하게 되었어요. 파이썬의 간결하고 강력한 코드 구문이 매력적이었어요. 파이썬의 타입 추론 덕분에 모든 변수에 대해 타입을 정의하는 일에서 벗어날 수 있었어요(이 작업은 특히 자바 같은 기초 컴퓨터 과학 수업에서 만난 언어에서 어려운 작업이었어요).\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그래서 프론트엔드에는 JavaScript를 사용하고 백엔드에는 Python을 사용하여 API 엔드포인트의 유형을 필수적인 경우가 아닌 한 정의하지 않았어요.\n\n그러나 어플리케이션이 복잡해지면서 프론트엔드와 백엔드 간 예상치 못한 다양한 유형 오류로 코딩 생산성이 떨어졌어요. CS 친구들이 명시적 유형의 중요성을 강조하는 이유를 이제야 이해하게 되었어요. 유형 정의에서의 세심함은 까다롭다는 것뿐만 아니라 필수적이라는 것을 깨달았답니다.\n\n## 꿀팁 #3: 백엔드로 Flask 대신 FastAPI를 선택하고 응답 모델을 엄격하게 정의하세요\n\nYouTube에서 파이썬 백엔드 튜토리얼을 검색하면 대부분의 비디오가 Flask를 지목할 것입니다. 하지만 망가진 시계가 하루에 두 번 맞는 것처럼, 나는 우연히도 FastAPI를 Python 백엔드로 선택했는데, 이는 분명히 올바른 결정이었던 것 같아요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웃기게도, 나는 FastAPI의 혜택을 완전히 무시했었어요. 얼마 전까지만 해도 POST 요청을 위한 Pydantic 클래스를 정의하는 필요성을 이해하지 못하고 그것을 도움보다는 번거로운 일로 생각했었죠.\n\nFastAPI에는 몇 가지 혁신적인 장점이 있어요:\n\n- 자동 생성된 API 문서 — 이것은 향후 온보딩할 엔지니어들 (또는 미래의 여러분)이 백엔드 구조를 이해하는 데 매우 유용할 거예요!\n- 코드 작성이 쉬워짐 — FastAPI는 Json 스키마 위에 구축되어 있기 때문에 라우트를 정의하는 것이 Flask보다 훨씬 쉽고 간결해요 — 결과적으로, 저와 같은 초보자들에게도 학습 곡선이 더 낮아요\n- 성능이 더 좋음 — FastAPI는 Flask보다 훨씬 빠르다고 하며 더 적은 메모리를 소비한다고 해요 — 제 앱은 대량의 페이로드를 보내기 때문에 이는 멋진 거에요\n\n![이미지](/assets/img/2024-06-19-FromDataScientisttoAIDeveloperLessonsBuildingaGenerativeAIWebAppin2023_8.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 가장 중요한 것은 FastAPI의 타입 어노테이션이에요!\n\n- FastAPI는 데이터 유효성 검사 라이브러리인 Pydantic 위에 구축되었어요. 이 라이브러리를 사용하면 속성이 있는 클래스로 데이터의 '형태'를 정의할 수 있어요.\n- FastAPI를 사용하면 각 API 경로의 입력 및 출력 타입을 Python 타입 힌트와 Pydantic으로 정의된 클래스를 사용하여 주석으로 달 수 있어요.\n\n이것은 각 경로의 출력이 일관된 데이터 구조를 갖도록 확인해줘요. 하지만 이 기능을 최대한 활용하려면...\n\n## 팁 #4: 자바스크립트 대신 TypeScript를 사용하세요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n오랜 시간동안 저는 프론트엔드 페처 메소드를 수동으로 작성해 왔어요(또한 풀 스택 튜토리얼을 참고하여 배웠죠). 그래서 앱에 새로운 루트를 추가하는 것이 오랫동안 오류가 발생하기 쉬운 과정이었어요.\n\n그래서 저의 대규모 기술 업계 소프트웨어 엔지니어 친구가 API 사양을 사용하여 Typescript 클라이언트 코드를 자동 생성할 수 있다고 말할 때, 제가 깜짝 놀랐던 것을 상상할 수 있죠. (더 많은 FastAPI 문서는 여기를 참조하고, 이 중 하나인 openapi-typescript-codegen을 확인해보세요)\n\n한 순간에 이를 깨달았을 때, 이것이 두 가지 중요한 동시에 해결할 것을 알았어요: 수동 및 오류가 발생하기 쉬운 클라이언트 페처 코드 작성을 제거하고, 백엔드와 프론트엔드 간의 유형 일관성을 보장하기. 이렇게 함으로써 앱의 신뢰성을 저해하던 지속적인 유형 오류를 크게 줄였어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n물론 백엔드 라우트에 대한 유형 제약 조건을 설정하는 것은 프론트엔드에서 해당 유형 제약 조건을 강제하는 것만큼 중요합니다. 이는 당연히 TypeScript를 필요로 합니다.\n\n그래서 저는 현재 FastAPI 백엔드에 대한 응답 모델을 정의하고 프론트엔드를 JavaScript에서 TypeScript로 변환하는 힘든 과정을 겪고 있어요. 시작부터 FastAPI와 TypeScript로 작업을 시작한다면 이런 과정을 피할 수 있어요!\n\n# 배포 관련...\n\n나의 데이터 과학 / 머신러닝 수업을 통해 구글 Colab를 사용하고 코드를 실행하는 것에 익숙해졌어요. 그래서 배포라는 생각만으로도 공포를 느끼게 되는건 이상하지 않아요. 그러나 Buildspace 가속기의 창립자가 말한 대로, 소프트웨어 앱을 전 세계에 액세스 가능하게 만들려면 “GTFOL” (Get The F Off Localhost)해야 합니다. 그래서 배포 과정이 가능한 쾌적하도록 하고 싶었죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 팁 #5: GPU 백엔드에 모달 사용하기\n\n만약 여러분이 직접 모델 (예: 머신 러닝 모델, 이미지 인식, Whisper를 위한 필기 인식, 또는 최근에는 오픈 소스 LLMs인 Llama와 같은)을 배포하고 싶다면, 모델을 호스팅할 GPU 클라우드 제공업체가 필요할 것입니다.\n\n내 조언은 Modal을 선택하고 다시 뒤를 돌아보지 말라는 것입니다.\n\nModal은 최신 애플리케이션용 샘플 코드를 비롯한 최고의 문서 및 학습 자료가 갖춰져 있어요. 오픈 소스 LLMs를 세밀하게 조정해서 사용하거나, LLM 챗봇을 제공하는 것과 같은 다양한 응용 프로그램에 대한 최신 코드가 준비되어 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n전체 팟캐스트 전사 앱을 시작했을 때 Modal의 샘플 오디오 전사 코드를 포크하여 시작했어요. 그래서 Modal 없이는 내 앱을 만들지 못했다고 할 수 없을 정도로 중요한 역할을 했어요.\n\n![이미지](/assets/img/2024-06-19-FromDataScientisttoAIDeveloperLessonsBuildingaGenerativeAIWebAppin2023_10.png)\n\nModal은 사용자 친화성에서 빛을 발해요 (특히 배포를 싫어하는 사람으로서 그렇게 말하고 싶어요). 로컬 코드 편집기에서 클라우드 함수를 작성하고, 한 줄의 터미널 명령으로 배포할 수 있어요. 그 대시보드는 AWS와 비교했을 때 사용자 친화적이어서 앱 사용량을 추적하고 성능을 분석하고 오류를 쉽게 추적할 수 있어요.\n\n마지막으로 Modal은 Lambda가 갖고 있지 않거나 구현하기 귀찮은 기능에 대한 탈출구로 작용해요. 예를 들어 파일 저장 (다음 포인트에서 유용할 것…)과 스케줄링 함수 등에 대한 기능에 사용될 때 특히 유용해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 팁 #6: 백엔드 배포에는 AWS Lambda, 프론트엔드에는 Vercel 사용하기\n\nPython 백엔드를 호스팅할 때, Amazon EC2 또는 AWS Lambda를 사용해야 하는지 헷갈렸어요. 제 앱은 오디오 파일을 저장해야 하는데 파일이 커질 수 있어서, Lambda의 서버리스 아키텍처는 파일을 저장할 목적으로 디자인되지 않았습니다(2GB의 일시적 저장소가 있지만 무지성이었고 지속적이지 않았습니다). 그래서 Amazon EC2를 사용해야 할 것이라고 생각했죠. 그러나 EC2는 설정이 더 복잡하고 항상 켜져 있는 전용 인스턴스이기 때문에 더 비실측하고 확장하기 어려웠어요.\n\n그런데 Modal의 무료 파일 저장소가 구조를 구성하기에 큰 도움이 되었고, Lambda와 호환되도록 백엔드를 구성하고 필요할 때 파일을 Modal에다 다운로드하고 저장할 수 있게 되었어요.\n\n다행히도, 이 영상은 정말 도움이 되었고, 그들의 지침을 딱 따라하면 백엔드를 성공적으로 배포할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n내 프론트엔드 작업에는 Vercel만으로도 충분했어요. 과정이 쉽고, 도메인 비용을 제외하고는 완전히 무료였어요.\n\n# 삶이 더 쉬워지는 방법\n\n개발 과정에서 막 애를 먹는 시간을 크게 절약할 수 있는 잡학지식 3가지 팁...\n\n## 팁 #7: React를 사용하여 자체 랜딩 페이지를 구축하지 마세요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nFull-stack 튜토리얼들 때문에 내가 한 또 다른 실수를 해 버렸어. 리액트로 내 랜딩 페이지를 코드로 작성해야 한다고 속아서. 가능하긴 해 (그리고 나도 해 봤지만), 성능과 디자인 측면에서 한계가 있어. 정확히 성공적인 랜딩 페이지를 만들기 위해 필요한 중요한 특징들이야.\n\n릭트는 실제 AI 앱 인터페이스 같은 사용자 정의 기능에만 더 나아. 랜딩 페이지에는 정적 콘텐츠만 있는데, 대신 Webflow나 Framer 같은 노코드 사이트 빌더를 사용해 랜딩 페이지를 신속하게 만들어야 해 (그리고 랜딩 페이지 제작은 디자이너에게 아웃소싱해서 다른 작업에 집중할 수 있게 해야해!)\n\n## 팁 8: Firebase + Stripe로 사용자 인증과 결제 처리하기\n\n사용자 인증에 관해서는 다시 한 번 선택할 수 있는 옵션이 많아서 혼란스러울 수 있어. 나는 사용자 인증을 처리할 뿐만 아니라 사용자 가입 상태에 따라 액세스를 제어하기 위해 결제 시스템과 통합하는 솔루션이 필요했어.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n수 일 동안 다양한 인증 솔루션을 시도하고 실패한 후에 auth0 등을 찾아 사용해보기도 했지만, Stripe + Firebase가 잘 작동한다는 것을 알게 되었습니다. Firebase에는 Stripe 통합이 있어 결제가 성공하면 사용자의 구독 상태를 업데이트하고, Firebase의 React 클라이언트는 클라이언트 측 인증, Python 클라이언트는 서버 액세스 제어를 잘 처리합니다. 두 개의 동영상(여기와 여기)을 따라하면 이를 앱에 성공적으로 구현할 수 있습니다.\n\n## Tip #9: 에러 모니터링을 위해 Sentry 구현하기\n\n몇 달 동안 제 앱을 사용하는 사용자가 만난 버그에 대해 전혀 모르고 있었습니다. 버그를 발견한 후에나 AWS Cloudwatch 인터페이스를 통해 백엔드 버그를 찾으려고 노력합니다.\n\n![이미지](/assets/img/2024-06-19-FromDataScientisttoAIDeveloperLessonsBuildingaGenerativeAIWebAppin2023_11.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n내 공동 창업자가 클라우드 앱의 성능 모니터링과 오류 추적을 위한 도구인 Sentry를 소개해 줄 때까지 계속되었습니다. 프론트엔드와 백엔드를 위해 초기화하기 정말 쉽고, Slack과 통합하여 즉시 오류 알림을 받을 수도 있어요. 그저 인증 시간 초과와 같은 사소하지만 빈번한 오류로 무료 플랜의 월별 오류 예산을 소진하지 않도록 주의하세요. 그것이 제게 일어난 일이었죠 — 그래서 중요한 버그에 대한 로그를 찾고 싶어졌을 때 유료 플랜을 구독해야 했습니다.\n\n보너스 팁 #10: Spotify의 API를 사용하여 웹 앱을 만들려고 시도하지 마세요! Spotify의 API를 통합하여 사용자가 저장된 팟캐스트를 로드할 수 있다고 가정하고 2개월 동안 제 앱을 낭비했어요. 하지만 이를 제품화하려면 할당량 확장 요청을 신청해야 하는데, Spotify가 검토하는 데 한 달 이상 소요됩니다. 그리고 당신의 앱이 AI/ML 모델을 포함하고 있다면 신청이 거의 거부될 가능성이 높아요 (제 앱이 실제로 Spotify 데이터를 활용하여 어떠한 모델을 훈련시키지 않았음에도 불구하고, 그러한 용어가 개발자 정책에서 금지되어 있기 때문입니다).\n\n# 결론\n\n이 기술 가이드가 데이터과학 애호가들을 위한 웹 앱 개발의 일부 측면을 명확하게 해주길 바랍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 이 게시물이 도움이 된다면:\n\n- 다른 제 미디엄 기사도 확인해보세요: AI를 사용해 긴 텍스트를 요약하는 방법, 딥 러닝을 사용해 음악을 생성하는 방법\n- 제 어플을 사용해보세요 — Podsmart은 팟캐스트와 유튜브 영상의 필기본문과 요약을 제공하여 바쁜 지식인들에게 듣기 시간을 절약해줍니다\n- LinkedIn이나 Twitter/X로 제 팔로우를 하고, 메시지나 댓글로 연락해주세요! 데이터 과학과 AI에 관한 모든 아이디어를 공유해보고 싶어합니다\n\n읽어주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-06-19-FromDataScientisttoAIDeveloperLessonsBuildingaGenerativeAIWebAppin2023_0.png"},"coverImage":"/assets/img/2024-06-19-FromDataScientisttoAIDeveloperLessonsBuildingaGenerativeAIWebAppin2023_0.png","tag":["Tech"],"readingTime":12},{"title":"Azure CosmosDB, 중복 검증 스트레로이드 버전","description":"","date":"2024-06-19 14:45","slug":"2024-06-19-AzureCosmosDBZodDataValidationonSteroids","content":"\n\n\n![Azure CosmosDB](/assets/img/2024-06-19-AzureCosmosDBZodDataValidationonSteroids_0.png)\n\n데이터베이스 보호 및 Azure 요금 절감\n\nAzure CosmosDB는 다른 NoSQL 데이터베이스들처럼 훌륭합니다. 빠르고 신뢰할 수 있으며 매우 유연합니다.\n\n그러나 자유는 언제나 대가가 따릅니다. 완전히 스키마 없는 데이터베이스의 경우, 데이터베이스에 들어가는 내용과 데이터를 검색하는 방법에 대해 계산된 결정을 내리게 됩니다. 개발자인 우리에게 책임이 떨어집니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가장 흔한 사용 사례 중 하나는 ID별로 레코드/항목을 찾는 것입니다.\n\n이게 얼마나 중요한가요?\n\n그냥 SELECT * FROM c WHERE c.id = \"some-id\" 를 사용하면 될 일이 아닙니까?\n\n또는 Azure CosmosDB SDK를 사용하여 간단히 이렇게 할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nawait container.item(\"some-id\", \"some-id\").read();\n```\n\n둘 다 맞아요.\n\n하지만 처음부터 데이터베이스와 통신할 필요가 없는 경우도 있습니다. 예를 들어:\n\n- ID 입력이 정의되지 않은 경우\n- ID 입력이 null 인 경우\n- ID 입력이 빈 문자열인 경우: \"\"\n- ID 입력에 공백 문자가 포함된 경우: \" some-id\", \"some -id\", 또는 \"some-id\"는 모두 CosmosDB가 허용하지 않는 잘못된 ID입니다.\n- 특별한 사용 사례: ID 입력이 이미 데이터베이스에 적용한 사용자 지정 ID 형식을 준수하지 않는 경우. 예: 모든 ID는 USER-xxx-xxxx-xxxx 등의 형식을 따라야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 문제를 해결하기 위해 2가지 방법이 있습니다:\n\n- 사용자 정의 함수 작성\n- 스키마 유효성 검사 도구 사용 (예: zod, yup, valibot, typia 등)\n\n두 가지 모두 API로 들어오는 데이터를 어떤 형식으로든 수동으로 유효성을 검사해야 합니다.\n\n방법 1: 사용자 정의 함수 작성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { ResultAsync, err, ok } from 'neverthrow';\nimport { CosmosClient } from '@azure/cosmos';\n\n// CosmosDB 연결 초기화\nconst endpoint = `데이터베이스_엔드포인트`;\nconst key = `데이터베이스_키`;\nconst client = new CosmosClient({ endpoint, key });\n\n// 작업을 수행할 \"컨테이너\" 설정\nconst container = client.database(`데이터베이스_이름`).container(`컨테이너_이름`);\n\nexport type Post = {\n  id: string;\n  // 다른 속성들\n};\n\nexport const findOnePost = async (\n  id: string,\n): Promise\u003cResultAsync\u003cPost, Error\u003e\u003e =\u003e {\n  // 입력 유효성 검사 - 매우 수동적\n  if (id === undefined || id === null) {\n    return err(new Error(`ID는 정의되거나 null일 수 없습니다`));\n  }\n  if (id === ``) {\n    return err(new Error(`ID는 빈 문자열일 수 없습니다`));\n  }\n  if (id.includes(` `)) {\n    return err(new Error(`ID에는 공백 문자가 포함될 수 없습니다`));\n  }\n  // ... ID가 규격을 준수해야하는 다른 규칙들\n\n  // 데이터베이스 호출\n  const result = await fromPromise(\n    await container.item\u003cPost\u003e(id, id).read(),\n    (e) =\u003e e,\n  );\n  if (result.isErr()) {\n    return err(new Error(`데이터베이스에서 항목을 검색하는 데 실패했습니다. 오류 코드: ${result.error['code']}`));\n  }\n\n  // 선택 사항: 데이터베이스에서 검색된 데이터 유효성 검사\n\n  // 게시물 데이터 반환\n  return ok\u003cPost\u003e(result.value.resource);\n};\n```\n\n접근 방법 2: 스키마 유효성 검사 도구(Zod) 사용\n\n```js\nimport { z } from 'zod';\nimport { fromError } from 'zod-validation-error';\nimport { ResultAsync, err, ok } from 'neverthrow';\nimport { CosmosClient } from '@azure/cosmos';\n\n// CosmosDB 연결 초기화\nconst endpoint = `데이터베이스_엔드포인트`;\nconst key = `데이터베이스_키`;\nconst client = new CosmosClient({ endpoint, key });\n\n// 작업을 수행할 \"컨테이너\" 설정\nconst container = client.database(`데이터베이스_이름`).container(`컨테이너_이름`);\n\n// ID 스키마\nconst IdSchema = z\n  .string()\n  .min(8)\n  .refine((value) =\u003e {\n    return !value.includes(` `);\n  }, `ID에 공백 문자를 포함할 수 없습니다`)\n  .describe(\n    `입력을 문자열로, 적어도 8자 이상이어야하며 공백 문자를 포함해서는 안됩니다`,\n  );\n\nexport type Post = {\n  id: string;\n  // 다른 속성들\n};\n\nexport const findOnePost = async (\n  id: string,\n): Promise\u003cResultAsync\u003cPost, Error\u003e\u003e =\u003e {\n  // 입력 유효성 검사 - zod 사용\n  const validateInput = IdSchema.safeParse(id);\n  if (!validateInput.success) {\n    const { message } = fromError(validateInput.error);\n    return err(new Error(message));\n  }\n\n  // 데이터베이스 호출\n  const result = await fromPromise(\n    await container.item\u003cPost\u003e(id, id).read(),\n    (e) =\u003e e,\n  );\n  if (result.isErr()) {\n    return err(new Error(`데이터베이스에서 항목을 검색하는 데 실패했습니다. 오류 코드: ${result.error['code']}`));\n  }\n\n  // 선택 사항: 데이터베이스에서 검색된 데이터 유효성 검사\n\n  // 게시물 데이터 반환\n  return ok\u003cPost\u003e(result.value.resource);\n};\n```\n\n두 가지 접근 방법이 모두 작동함을 확인할 수 있습니다. 둘 다 Azure CosmosDB 호출 전에 ID 입력의 유효성을 검사합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 더 많은 코드를 작성하거나 앱이 매우 작다거나 새로운 npm 패키지를 추가하고 싶지 않다면 첫 번째 방법을 사용하세요.\n\n더 적은 코드를 작성하고 코드베이스의 여러 곳에 동일한 유효성을 적용하려면 두 번째 방법을 사용하세요.\n\n그러나 주요 아이디어는 데이터베이스에 여행을 하기 전에 ID가 유효한지 확인해야 한다는 것입니다.\n\n아래 다이어그램에서는 주황색으로 둘러싸인 부분을 추가하는 중입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Azure CosmosDB Zod Data Validation on Steroids](/assets/img/2024-06-19-AzureCosmosDBZodDataValidationonSteroids_1.png)\n\n데이터베이스를 요청하지 않으면 매우 사소한 것처럼 보일 수 있지만, 모든 달러가 중요합니다. Azure CosmosDB를 쿼리하는 시기, 방법 및 빈도를 신중히 다루면 큰 Azure 송장에서 자신을 보호할 수 있습니다.\n\n생각을 공유하고 댓글을 달아주세요!\n","ogImage":{"url":"/assets/img/2024-06-19-AzureCosmosDBZodDataValidationonSteroids_0.png"},"coverImage":"/assets/img/2024-06-19-AzureCosmosDBZodDataValidationonSteroids_0.png","tag":["Tech"],"readingTime":5},{"title":"엘로퀀트 깊숙한 학습 라라벨 개발자가 반드시 알아야 할 40가지 잘 사용되지 않는 엘로퀀트 ORM 메서드","description":"","date":"2024-06-19 14:42","slug":"2024-06-19-DeepDiveintoEloquent40RarelyUsedEloquentORMMethodsEveryLaravelDeveloperMUSTKnow","content":"\n\n\u003cimg src=\"/assets/img/2024-06-19-DeepDiveintoEloquent40RarelyUsedEloquentORMMethodsEveryLaravelDeveloperMUSTKnow_0.png\" /\u003e\n\n안녕하세요! 엘로퀀트에 대해 얼마나 잘 아시나요?\n\n라라벨의 엘로퀀트 ORM은 매우 강력한 도구로, 표현력이 풍부하고 우아한 구문을 사용하여 데이터베이스와 상호 작용할 수 있는 기능을 제공합니다. 많은 개발자들이 find(), where(), first(), get(), save()와 같은 일반적인 메서드를 잘 알고 있지만, 워크플로우를 크게 향상시킬 수 있는 몇 가지 잘 알려지지 않은 메서드들이 있습니다. 이 글에서는 이러한 잘 알려지지 않지만 매우 유용한 엘로퀀트 ORM 메서드 중 일부를 살펴보겠습니다.\n\n일반적인 메서드부터 시작해서 가장 좋은 메서드로 이동해보겠습니다. 여러분은 응용 프로그램의 속도와 효율성을 실제로 향상시킬 수 있는 많은 아름다운 메서드를 보게 될 것입니다. 함께 알아보도록 하죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 1. tap()\n\n왜: 모델에 변경사항을 적용하고 메서드 체이닝을 위해 모델 자체를 반환합니다.\n\n언제: 객체를 수정하고 즉시 다른 작업에 사용하고 싶을 때 사용하세요.\n\n```js\nUser::find(1)-\u003etap(function ($user) {\n    $user-\u003ename = 'Updated Name';\n})-\u003esave();\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 2. firstOrFail()\n\n왜: 유효한 결과를 얻거나 결과가 없는 경우를 처리하기 위해 사용합니다.\n\n언제: 특정 레코드를 가져 와서 존재하지 않는 경우에 오류를 throw하고 싶을 때 사용합니다.\n\n```js\n$user = User::where('email', 'example@example.com')-\u003efirstOrFail();\n// 사용자 세부 정보 처리\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 3. updateOrCreate()\n\n왜: 기존 레코드를 업데이트하거나 새로운 레코드를 생성하여 중복 항목을 방지하기 위해서입니다.\n\n언제: 레코드가 존재하지 않으면 생성되고, 존재한다면 업데이트되도록 하고 싶을 때 사용합니다.\n\n```js\nUser::updateOrCreate(\n    ['email' =\u003e 'example@example.com'],\n    ['name' =\u003e 'John Doe']\n);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 4. increment() / decrement()\n\n이 부분을 정말 좋아해요. 직관적이고 아름다워요. 언제 사용하나요?\n언제 사용: 숫자 열을 하나 이상 증가시키거나 감소시킬 때 사용합니다.\n\n왜 사용하나요: 숫자 열의 값을 효율적으로 업데이트하기 위해.\n\n```js\nUser::where('id', 1)-\u003eincrement('points'); // 만약 points가 7이면 이제 8이 될 것입니다\nUser::where('id', 1)-\u003edecrement('points', 5); // 만약 7이면 2가 될 것입니다\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 5. withTrashed() / onlyTrashed() / restore()\n\n이 그룹의 메소드들은 라라벨에서 Soft Deletes 기능을 관리하는 데 사용됩니다.\n나는 Soft Deletes에 관한 모든 것을 다룬 매우 상세한 기사를 썼어.\n\n왜: Soft 삭제된 레코드를 관리하기 위해.\n언제: 이러한 메소드를 사용하여 Soft 삭제된 레코드를 포함하거나 오직 포함하거나 되찾을 때.\n\n\n```js\n$users = User::withTrashed()-\u003eget();\n$trashedUsers = User::onlyTrashed()-\u003eget();\nUser::withTrashed()-\u003ewhere('id', 1)-\u003erestore();\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 6. withoutEvents()\n\n왜: 이벤트 리스너가 작동하는 것을 방지합니다.\n언제: 일괄 가져오기와 같이 이벤트를 발생시키지 않아야 하는 작업을 수행할 때 사용합니다.\n\n외부 시스템에서 대량의 사용자를 가져오고 각 가져온 사용자에 대해 UserCreated 이벤트를 트리거하고 싶지 않아서 환영 이메일을 보내거나 생성마다 로깅하는 것을 피하려고 한다고 상상해보세요.\n\n```js\nUser::withoutEvents(function () {\n    User::create([\n      'name' =\u003e 'John Doe', \n      'email' =\u003e 'john@example.com'\n    ]);\n    User::create([\n      'name' =\u003e 'Jane Doe', \n      'email' =\u003e 'jane@example.com'\n    ]);\n});\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 7. withoutGlobalScopes()\n\n**왜 사용하나요:** 전역 쿼리 제약을 우회하기 위해 사용합니다.\n**언제 사용하나요:** is_published와 같은 전역 스코프를 무시하고 모든 레코드를 가져와야 할 때 사용합니다.\n\n당신의 애플리케이션에는 발행된 게시물만 포함하는 전역 스코프를 가진 Post 모델이 있는 상황을 상상해보세요. 관리자는 컨텐츠를 효율적으로 관리하기 위해 초안 및 미게시된 게시물을 포함한 모든 게시물을 볼 수도 있어야 할 것입니다.\n\n전역 스코프를 무시하고 모든 게시물을 가져오기:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n$allPosts = Post::withoutGlobalScopes()-\u003eget();\nforeach ($allPosts as $post) {\n    echo $post-\u003etitle . ($post-\u003eis_published ? ' (Published)' : ' (Draft)') . \"\\n\";\n}\n```\n\n위 예시에서 withoutGlobalScopes()를 사용하면 관리자가 미게시된 포스트를 필터링하는 전역 범위를 우회하여 모든 포스트를 볼 수 있습니다.\n\nwithoutGlobalScopes()를 사용하는 것은 데이터에 대한 종합적인 액세스가 필요한 관리 작업이나 글로벌 제약 조건이 쿼리에 영향을 미치지 않도록 디버깅 및 테스트 중에 특히 유용합니다.\n\n# 10. is() / isNot()\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이것도 좋아요. 비교와 조건을 확인할 때 매우 간편하고 유용합니다.\n\n왜 필요한가: 두 모델 인스턴스를 비교하기 위해.\n언제 사용하는가: 두 모델이 동일한 인스턴스인지 확인할 때 사용합니다.\n\n```js\n$user1 = User::find(1);\n$user2 = User::find(2);\n\nif ($user1-\u003eis($user2)) {\n    // 동일한 사용자\n}\n\nif ($user1-\u003eisNot($user2)) {\n    // 동일한 사용자가 아님\n}\n```\n\n# 11. loadMissing()\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예시: User 모델이 있는데 그 모델은 게시물(posts) 관계를 갖고 있습니다. 사용자와 그들의 게시물을 함께 로드하고 싶지만, 게시물 관계가 이미 로드되었는지 확실하지 않을 때가 있습니다.\n\n왜: 이미 로드되지 않은 관계를 조건부로 eager load하여 데이터베이스 쿼리를 최적화하고 N+1 쿼리 문제를 피하기 위해서입니다.\n\n언제: loadMissing()을 사용할 때는 모델 인스턴스에 관계를 로드하고 싶지만 이미 로드되어 있지 않은 경우에만 사용합니다. 특히 특정 조건에 따라 동적으로 로드하고 싶은 조건부 관계 또는 이미 로드된 것들이 섞인 루프에서 관계를 로드할 때 유용합니다.\n\n```js\n$user = User::find(1);\n\n// 'posts' 관계가 이미 로드되었는지 확인\nif (!$user-\u003erelationLoaded('posts')) {\n    // 'posts' 관계는 이미 로드되어 있지 않다면 로드\n    $user-\u003eloadMissing('posts');\n}\n\n// 이제 중복 쿼리 걱정 없이 'posts' 관계에 접근할 수 있습니다\nforeach ($user-\u003eposts as $post) {\n    echo $post-\u003etitle . \"\\n\";\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 12. makeHidden() / makeVisible()\n\n왜: 모델 속성의 가시성을 제어하기 위해서입니다.\n언제: 임시로 속성을 숨기거나 보여줄 때 사용합니다. 예를 들어 API 응답에서 사용합니다.\n\n```js\n$user = User::find(1);\n$user-\u003emakeHidden('email');\n$user-\u003emakeVisible('email');\n```\n\n# 13. touch()\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n왜: updated_at 타임스탬프를 업데이트하려고.\n언제: 다른 속성을 변경하지 않고 레코드를 업데이트된 것으로 표시하려면 사용하세요.\n\n```js\n$user = User::find(1);\n$user-\u003etouch();\n```\n\n# 14. append()\n\n왜: 모델의 배열이나 JSON 형식에 사용자 정의 속성을 추가하려고.\n언제: 모델의 표현에 추가적인 계산된 속성을 포함하고 싶을 때 사용하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```php\n$user = User::find(1);\n$user-\u003eappend('custom_attribute');\n```\n\n안녕하세요! Laravel에서 Json 데이터를 관리하는 방법에 대한 매우 포괄적이고 단계별 자습서를 작성했습니다.\n\n# 15. replicate()\n\n왜: 모델 인스턴스를 복제하기 위함.\n언제: 템플릿을 복제하는 것과 같이 동일한 속성을 가진 새 인스턴스를 생성할 때 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```php\n$user = User::find(1);\n$newUser = $user-\u003ereplicate(); // $newUser is matches to $user\n$newUser-\u003esave();\n```\n\n## 16. chunkById()\n\n테이블에 20,000,000개의 레코드가 있는 상황을 상상해보세요. 각 레코드에 대해 작업을 수행해야합니다. 이를 어떻게 해야 할까요?\n\n왜: 대규모 데이터 세트를 효율적으로 처리하는 데 사용합니다.\n언제: 대규모 데이터 세트를 처리하여 메모리를 효율적으로 처리하고 대형 테이블에서 더 나은 성능을 얻을 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n특정 작업을 수행해야 하는 20,000,000개 레코드가 있는 데이터베이스 테이블이 있다고 가정해보세요.\n\n```js\nuse App\\Models\\YourModel;\n\nYourModel::orderBy('id')-\u003echunkById(1000, function ($records) {\n    foreach ($records as $record) {\n        // 각 레코드 처리\n    }\n});\n```\n\n참고: chunk()라는 유사한 메소드가 있습니다. 이러한 두 메소드는 유사한 작업을 수행하지만 차이점이 있습니다. 두 가지 모두 대규모 데이터셋을 효율적으로 일괄 처리하여 메모리 과부하를 방지하고 성능을 최적화합니다. 두 메소드는 한 번에 전체 데이터셋을 한꺼번에 메모리로 로드하지 않고 대규모 데이터셋을 이터레이션할 수 있도록 허용합니다. 그러나 데이터 배치를 결정하는 방식에서 차이가 있습니다:\n\nchunk():\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- chunk()은 첫 번째 매개변수로 지정된 청크 당 레코드 수에 따라 데이터 세트를 청크로 나눕니다.\n- 특정한 순서를 고려하지 않고 데이터베이스 테이블에서 레코드를 순차적으로 검색합니다.\n- 각 청크의 레코드는 데이터베이스에서 검색된 순서에 기반하여 가져오며, 주로 기본 키 순서에 따라 순서가 지정되지 않을 수 있습니다.\n- 처리 순서가 중요하지 않거나 데이터를 작은 관리 가능한 청크로 처리해야 할 때이 유용한 방법입니다.\n\nchunkById():\n\n- chunkById()는 레코드의 기본 키(일반적으로 id) 순서를 기반으로 데이터 세트를 청크로 나눕니다.\n- 데이터베이스 테이블에서 레코드를 기본 키 순서에 따라 순차적으로 검색합니다.\n- 각 청크에는 지정된 범위 내의 기본 키를 갖고 있는 레코드가 포함되어, 레코드가 기본 키 순서로 처리되도록 보장합니다.\n- 데이터 마이그레이션이나 기본 키 순서를 기반으로 순차 처리가 필요한 데이터 업데이트와 같은 작업을 수행할 때 유용한 방법입니다.\n\n# 17. existsOr()\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n**왜**: 모델이 존재하는 경우 콜백을 실행하거나 기본값을 반환합니다.  \n**언제**: 사용자 정의 로직으로 존재 여부를 처리해야 할 때 사용합니다.\n\n```js\n$exists = User::where('email', 'example@example.com')-\u003eexistsOr(function () {\n    return 'User does not exist';\n});\n```\n\n# 18. firstOrCreate()\n\n**왜**: 단계를 한 번에 기록을 검색하거나 생성하기 위해 사용합니다.  \n**언제**: 필요한 경우 레코드를 업데이트하거나 생성하여 중복된 항목을 피하기 위해 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n$user = User::firstOrCreate(['email' =\u003e 'example@example.com'], ['name' =\u003e 'John Doe']);\n```\n\n# 19. firstOrNew()\n\n왜: 저장하지 않고 기존 레코드를 검색하거나 새 레코드를 만들기 위해 사용합니다.\n언제: 기존 레코드를 가져 오거나 영구적으로 저장하지 않고 새 인스턴스를 만들기 위해 사용합니다.\n\n```js\n$user = User::firstOrNew(['email' =\u003e 'example@example.com'], ['name' =\u003e 'John Doe']);\n```  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 20. `sole()`\n\n왜: 하나의 레코드만 가져오거나 예외를 발생시키기 위해 사용합니다.\n언제 사용: 단일하고 고유한 결과를 예상하고 중복을 오류로 처리하고 싶은 경우에 사용합니다.\n\n```js\n$user = User::where('email', 'example@example.com')-\u003esole();\n```\n\n# 21. `findMany()`\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 Markdown 형식으로 변경하세요.\n\n\nWhy: 여러 개의 기본 키로 레코드를 검색하기 위해 사용합니다. \nWhen: 여러 개의 ID가 포함된 배열을 사용하여 한 번에 여러 레코드를 가져오는 데 사용합니다.\n\n```js\n$users = User::findMany([1, 2, 3]);\n```\n\n## 22. update()\n\nWhy: 한 번에 여러 레코드를 업데이트하기 위해 사용합니다.\nWhen: 대량 업데이트를 효율적으로 수행하기 위해 사용합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nUser::where('status', 'active')-\u003eupdate(['status' =\u003e 'inactive']);\n```\n\n# 23. forceDelete()\n\nWhy: 소프트 삭제된 모델을 영구적으로 삭제하려면 사용하세요.\nWhen: 레코드를 완전히 제거하여 소프트 삭제를 우회할 때 사용하세요.\n\n```js\n$user = User::withTrashed()-\u003efind(1);\n$user-\u003eforceDelete();\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 24. getDirty()\n\n이 함수 정말 좋아요. 이 함수를 사용하면 데이터베이스에 저장되기 전 모델에서 변경된 모든 내용을 알 수 있어요.\n\n왜: 변경된 속성들을 확인하려고요.\n언제: 저장하기 전에 수정된 속성들을 확인할 때 사용하세요.\n\n```js\n$user = User::find(1);\n$user-\u003ename = '새로운 이름';\n$dirty = $user-\u003egetDirty();\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 25. getOriginal()\n\n왜: 모델 속성의 원래 값 가져오기 위해 사용합니다.\n언제: 변경 전 현재 값과 원래 값 비교할 때 사용합니다.\n\n```js\n$user = User::find(1);\n$original = $user-\u003egetOriginal('name');\n```\n\n# 26. setRelation()\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n왜: 모델에 특정 관계를 설정하기 위해 사용합니다.\n언제: 모델 인스턴스에 수동으로 관계를 정의할 때 사용합니다.\n\n```js\n$user = User::find(1);\n$user-\u003esetRelation('posts', $posts);\n```\n\n# 27. without()\n\n왜: 쿼리에서 특정 관계를 제외하기 위해 사용합니다.\n언제: 불필요한 관계를 제외하여 쿼리를 최적화할 때 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```javascript\n$user = User::with('posts', 'comments')-\u003ewithout('comments')-\u003efind(1);\n```\n\n## 28. preventLazyLoading()\n\n왜: 관계의 게으른 로딩을 방지합니다.\n언제: 개발 중에 의도하지 않은 게으른 로딩을 방지하려면 사용하세요.\n\n```javascript\nModel::preventLazyLoading(!app()-\u003eisProduction());\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 29. withoutTimestamps()\n\n왜: created_at 및 updated_at 타임스탬프의 업데이트를 비활성화합니다.\n언제: 가져오기와 같이 타임스탬프 업데이트를 트리거해서는 안 되는 작업에 사용합니다.\n\n```js\nUser::withoutTimestamps(function () {\n    User::create(['name' =\u003e 'John Doe']);\n});\n```\n\n# 30. withCasts()\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n라라벨은 모델 속성에 동적으로 캐스팅 규칙을 적용할 수 있습니다. 특정 조건이나 런타임 시나리오에 따라 속성을 어떻게 캐스팅할지 실시간으로 변경할 필요가 있을 때 유용합니다. 예를 들어 사용자 입력이나 데이터베이스 값에 따라 속성을 다른 유형으로 캐스팅할 수 있어 데이터 일관성과 애플리케이션의 유연성을 보장할 수 있습니다.\n\n왜: 캐스팅 규칙을 동적으로 적용하기 위해.\n언제: 속성을 실시간으로 어떻게 캐스팅할지 변경할 때.\n\n```js\n$user = User::withCasts(['is_admin' =\u003e 'boolean'])-\u003efind(1);\n```\n\n# 31. upsert()\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n왜: 일치하는 기준에 따라 레코드를 삽입하거나 업데이트하기 위해서입니다.\n언제: 대량 삽입 또는 업데이트를 수행하여 중복 항목을 피하기 위해 사용합니다.\n\n고유 식별자로 이메일 열을 갖는 사용자 테이블이 있다고 가정해보세요. 해당 테이블에 이메일이 이미 존재하지 않는 경우 새 사용자를 삽입하거나 이미 존재하는 경우 이메일에 해당하는 이름을 업데이트하려고 합니다.\n\n```js\nuse App\\Models\\User;\n\nUser::upsert([\n    ['email' =\u003e 'john@example.com', 'name' =\u003e 'John Doe'],\n    ['email' =\u003e 'jane@example.com', 'name' =\u003e 'Jane Doe']\n], ['email'], ['name']);\n```\n\n# 32. 스코프\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n왜: 재사용 가능한 쿼리 스코프를 정의하는 데 사용합니다.\n언제: 여러 쿼리에 일반적인 쿼리 제약을 적용하는 데 사용합니다.\n\n```js\n// 사용자 모델에서\npublic function scopeActive($query)\n{\n    return $query-\u003ewhere('status', 'active');\n}\n\n// 사용 방법\n$activeUsers = User::active()-\u003eget();\n```\n\n# 33. macro()\n\n이 메소드를 너무 좋아합니다. 원하는대로 사용자 정의한 고유한 메소드를 생성하는 데 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n왜: Eloquent 쿼리 빌더에 사용자 정의 메서드를 정의하기 위해.\n언제: 쿼리 빌더를 확장하여 자체 메서드를 추가하는 데 사용됩니다.\n\n당신의 응용 프로그램에서 사용자의 역할에 따라 사용자를 필터링해야 하는 경우가 자주 있습니다. 이 작업을 간단히 하기 위해 쿼리 빌더에 role()이라는 사용자 지정 매크로를 정의할 수 있습니다.\n\n```js\nuse Illuminate\\Database\\Eloquent\\Builder;\n\n// 'role' 매크로 정의\nBuilder::macro('role', function ($role) {\n    return $this-\u003ewhere('role', $role);\n});\n\n// 사용 예\n$admins = User::role('admin')-\u003eget();\n$customers = User::role('customer')-\u003eget();\n```\n\n# 34. filter()\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n**왜**: 동적 쿼리 필터를 적용하기 위해 사용합니다.\n**언제**: 요청 매개변수를 기반으로 여러 필터를 적용하기 위해 사용하세요.\n\n```js\n// 사용자 모델 내부에서\npublic function scopeFilter($query, $filters)\n{\n    return $filters-\u003eapply($query);\n}\n\n// 사용법\n$filters = new UserFilters(['status' =\u003e 'active']);\n$filteredUsers = User::filter($filters)-\u003eget();\n```\n\n이 예제에서는 User 모델에 filter() scope를 정의하여 필터 세트를 전달 받습니다. 이러한 필터는 UserFilters 객체의 apply() 메서드를 사용하여 쿼리에 적용될 수 있습니다. 이를 통해 $filters 변수에 지정된 다양한 기준에 따라 사용자를 동적으로 필터링할 수 있습니다.\n\nfilter()를 사용하면 데이터베이스 쿼리를 변화하는 요구 사항과 사용자 입력에 더 적응 가능하게 만들어 Laravel 애플리케이션에서 더 유연하고 동적인 데이터 검색이 가능해집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 35. whereJsonContains()\n\n왜: 특정 값을 가진 JSON 열을 조회하기 위해 사용합니다.\n언제: 배열 또는 객체를 포함하는 JSON 열을 조회할 때 사용합니다.\n\n```js\n$users = User::whereJsonContains('options-\u003elanguages', 'en')-\u003eget();\n```\n\n라라벨에서 JSON에 관한 모든 것에 대한 문서가 있습니다. 이 곳을 확인해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 36. findOr()\n\n왜: 모델을 검색하거나 찾을 수 없을 때 콜백을 실행하는 데 사용합니다.\n언제: 레코드가 없을 때 사용자 정의 로직을 처리할 때 사용하세요.\n\n```js\n$user = User::findOr(1, function () {\n    return '사용자를 찾을 수 없습니다';\n});\n```\n\n# 37. lockForUpdate()\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nLaravel의 Eloquent ORM에 있는 lockForUpdate() 메서드는 트랜잭션 내에서 데이터베이스 행을 업데이트하기 위해 잠그는 데 사용됩니다. 이 메서드를 쿼리에 적용하면 현재 트랜잭션이 완료될 때까지 선택된 행을 수정하는 다른 데이터베이스 트랜잭션이 방지됩니다. 이를 통해 데이터 일관성을 유지하고 여러 트랜잭션이 동시에 같은 행을 업데이트하려고 할 때 충돌을 방지합니다.\n\n왜: 쿼리에 \"for update\" 잠금을 적용합니다.\n언제: 여러 트랜잭션이 귀하의 트랜잭션 중에 행을 수정하는 것을 방지할 때 사용합니다.\n\n```js\n$user = User::where('email', 'example@example.com')-\u003elockForUpdate()-\u003efirst();\n```\n\n# 38. sharedLock()\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n왜: 쿼리에 \"공유 락\"을 적용하려면\n언제: 트랜잭션 기간 동안 선택한 행을 잠그는 데 사용합니다.\n\n금융 애플리케이션이 있다고 가정해보겠습니다. 사용자가 계정 잔액을 볼 수 있는 애플리케이션입니다. 사용자가 잔액을 확인할 때, 다른 트랜잭션이 동시에 계정 잔액을 업데이트하더라도 표시된 금액이 일관되게 유지되도록 보장하고 싶습니다. 이러한 경우에는 트랜잭션 중 사용자 계정에 해당하는 행을 잠글 때 sharedLock()을 사용할 수 있습니다. \n\n```js\nuse App\\Models\\Account;\n\nDB::transaction(function () use ($userId) {\n    $account = Account::where('user_id', $userId)-\u003esharedLock()-\u003efirst();\n    // 사용자의 계정 잔액 표시\n});\n```\n\n# 39. withSum()\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n왜: 관련 모델 속성의 합계를 결과에 추가하려고 합니다.\n언제: 주문 총액을 합산하는 등 관련 모델에서 데이터를 집계해야 할 때 사용합니다.\n\n```js\n$users = User::withSum('posts', 'views')-\u003eget(); // 총 게시물\n```\n\n예를 들어 User 모델이 있고 각 사용자가 여러 주문을 가질 수 있다고 가정합니다. 사용자 목록과 주문 금액의 총 합을 함께 검색하려면 withSum()을 사용할 수 있습니다.\n\n```js\nuse App\\Models\\User;\n\n$usersWithTotalOrderAmount = User::withSum('orders', 'amount')-\u003eget();\n\nforeach ($usersWithTotalOrderAmount as $user) {\n    echo \"User: {$user-\u003ename}, Total Order Amount: {$user-\u003eorders_sum_amount}\\n\";\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예제에서는 `orders` 관계에서 각 사용자의 금액 열의 총 합계를 검색하기 위해 withSum(`orders`, `amount`)이 사용됩니다. 집계된 합계는 각 사용자 객체의 동적으로 생성된 속성 (orders_sum_amount)으로 사용할 수 있습니다.\n\nwithSum()을 사용하여 주 쿼리 결과와 관련된 모델에서 집계된 데이터를 효율적으로 검색하여 코드를 간단하게하고 성능을 향상시킬 수 있습니다.\n\n# 40. withCount()\n\nLaravel의 Eloquent ORM에서 withCount() 메서드는 관련된 모델과 관련 모델의 수를 함께 검색하는 데 사용됩니다. 이것은 추가 쿼리를 수행하거나 수동 계산을 필요로하지 않고 연결된 레코드 수를 검색하려는 경우 유용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n왜: 관련된 모델의 수를 셀 때 사용합니다.\n언제: 사용자 당 게시물 수와 같이 관련 레코드 수를 얻을 때 사용합니다.\n\n```js\nuse App\\Models\\User;\n\n$usersWithPostCounts = User::withCount('posts')-\u003eget();\n\nforeach ($usersWithPostCounts as $user) {\n    echo \"User: {$user-\u003ename}, Post Count: {$user-\u003eposts_count}\\n\";\n}\n```\n\n위 예시에서 withCount('posts')는 각 사용자와 관련된 게시물 수를 검색하는 데 사용됩니다. 게시물 수는 각 사용자 객체의 동적으로 생성된 속성(posts_count)로 사용할 수 있습니다.\n\nwithCount()를 사용하면 주 쿼리 결과와 함께 데이터베이스로부터 관련 레코드의 수를 효율적으로 검색하여 코드를 단순화하고 성능을 향상시킬 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n우리는 Eloquent에 대해 정말 깊게 알아보았습니다. Laravel 개발자라면 꼭 알아야 할 40가지 사용 빈도가 적은 Eloquent ORM 메서드를 논의했으니 즐기세요!\n\n하지만 마지막까지 읽어준 선물로, 여기 워크플로우를 향상시키고 생산성을 향상시킬 10가지 더 많은 메서드가 있습니다.\n\n- oldest(): 지정된 열을 기준으로 쿼리 결과를 오름차순으로 정렬합니다.\n- latest(): 지정된 열을 기준으로 쿼리 결과를 내림차순으로 정렬합니다.\n- has(): 관계가 있는 레코드만 포함하도록 쿼리를 필터링합니다.\n- whereHas(): 특정 조건과 일치하는 관계가 있는 레코드만 포함하도록 쿼리를 필터링합니다.\n- doesntHave(): 관계가 없는 레코드만 포함하도록 쿼리를 필터링합니다.\n- whereDoesntHave(): 특정 조건과 일치하는 관계가 없는 레코드만 포함하도록 쿼리를 필터링합니다.\n- withPivot(): 중간 테이블 열을 쿼리할 때 추가 피벗 테이블 열을 지정합니다.\n- morphTo(): 관련된 모델이 여러 소스 모델에 속할 수 있는 다형 관계를 정의합니다.\n- morphMany(): 관련된 모델이 여러 소스 모델에 속할 수 있는 다형 일대다 관계를 정의합니다.\n- morphToMany(): 관련된 모델이 여러 소스 모델에 속할 수 있는 다형 다대다 관계를 정의합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n즐겁게 보내세요.\n\n계속 주목하세요!!! 다음 기사에서는 멋진 Laravel 튜토리얼을 더 소개할 예정이에요. 기사가 마음에 드셨길 바래요. 저를 팔로우해주세요 😇 그리고 박수를 좀 👏 부탁드려요. 궁금한 점이 있으면 언제든지 댓글을 남겨주세요.\n\n감사합니다.\n\n끝까지 읽어주셔서 정말 감사합니다. 저를 팔로우하거나 연락할 수 있는 곳:\nTwitter: https://twitter.com/EjimaduPrevail\nEmail: prevailexcellent@gmail.com\nGithub: https://github.com/PrevailExcel\nLinkedIn: https://www.linkedin.com/in/chimeremeze-prevail-ejimadu-3a3535219\nBuyMeCoffee: https://www.buymeacoffee.com/prevail\nChimeremeze Prevail Ejimadu","ogImage":{"url":"/assets/img/2024-06-19-DeepDiveintoEloquent40RarelyUsedEloquentORMMethodsEveryLaravelDeveloperMUSTKnow_0.png"},"coverImage":"/assets/img/2024-06-19-DeepDiveintoEloquent40RarelyUsedEloquentORMMethodsEveryLaravelDeveloperMUSTKnow_0.png","tag":["Tech"],"readingTime":16},{"title":"인터넷의 종말","description":"","date":"2024-06-19 14:40","slug":"2024-06-19-Theendoftheinternet","content":"\n\n![이미지](/assets/img/2024-06-19-Theendoftheinternet_0.png)\n\n알고 있는 대로의 인터넷이 끝나갈 수도 있습니다.\n\n제가 직접 목격한 몇 가지 변화와 우리가 향하고 있는 방향, 안타깝게도 예쁘지 않을 것 같습니다.\n\n긍정적인 시나리오가 있긴 하지만, 아마 대부분의 사람들이 매우 행복해하지 않을 것 같아요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n한 번 빅 벤에서 인터넷을 내려놓고 조금 더 자세히 살펴보죠. 그렇죠, 손에 들고 있을 수도 있지만 꼭 떨어뜨리지는 마세요!\n\n![인터넷](/assets/img/2024-06-19-Theendoftheinternet_1.png)\n\n# 인터넷\n\n우리는 인터넷을 당연시 여기고, 천천히 끓이는 개구리처럼 여러 해 동안 그 방향으로 이루어지는 변화들을 모두 받아들였습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 엄격한 규제: 체크.\n- 검열 및 진실 조작: 체크.\n- 개인 정보 침해 및 추적: 체크.\n- 모든 것이 광고: 응!\n\n그리고 제일 최악의 것은...\n\n- EU가 강요하는 쿠키 배너\n\n![이미지](/assets/img/2024-06-19-Theendoftheinternet_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 주요 변화\n\n## 90년대\n\n저는 1997년에 처음으로 인터넷을 사용하기 시작했습니다. 33600 kbit 모뎀을 사용했는데, 이 글을 다운로드하는 데는 5분 이상이 걸렸을 것입니다.\n\n90년대는 야만 서부였습니다. 모든 것이 허용되었고 누구라도 노골적인 사이트를 삭제할 수 없었습니다. 검열은 없었고, 예쁘지 않은 GIF 광고와 Altavista 검색 엔진이 있었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n비교할 만하다면, Altavista는 Google과 유사했는데, 그 안에서 유용한 정보를 얻기 위해 특정한 프롬프트 기술을 배워야 했던 곳이었습니다. 익숙한 것 같나요?\n\n![이미지](/assets/img/2024-06-19-Theendoftheinternet_3.png)\n\n# 2000년대 초반\n\n2000년대 초반은 애니메이션 플래시 웹사이트의 시대였습니다 - 모든 디자이너들에게 창의성이 넘치던 시기였죠. 하지만 이 또한 인터넷이 영원히 변화하는 순간이었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n구글은 1998년에 검색 엔진을 만들었지만 2000년대 초반에 인기를 끌기 시작했습니다. 그리고 2004년에 할배할머니가 알고 있는 페이스북을 만든 하버드 대학 중퇴생 마크 주커버그가 나타났어요.\n\n2000년 10월에 구글은 광고 서비스를 시작했어요. 이것은 매우 상세한 활동 추적을 통해 사람들에게 \"관련성 있는\" 광고를 제공함으로써 인터넷을 영원히 바꾸었습니다.\n\n페이스북은 7년이 걸렸지만 2007년에 자체 광고 프로그램을 시작했어요.\n\n이 모든 추적은 광고주가 제품을 판매하는 데 도움이 되었어요. 모든 게 더 관련성 있게 되었는데, 온라인 개인 정보 보호의 종말이 시작된 것이기도 해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-Theendoftheinternet_4.png\" /\u003e\n\n요 멋진 시사 당시에는 2009년 페이스북이 '좋아요' 버튼을 출시했어요.\n\n페이스북 외부에서도 무언가를 좋아할 수 있게 해 주는 코드 조각이었죠. 그리고 그 뒤에서는 사용자의 온라인 활동을 추적하여 인터넷을 어떻게 사용하는지에 대한 자세한 지도를 작성했어요.\n\n이것이 뚜렷한 시기였답니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-Theendoftheinternet_5.png\" /\u003e\n\n## SEO 운동\n\n당시에는 검색 엔진을 통해서만 발견될 수 있었기 때문에 수십 억 달러의 산업이 시작되었습니다. 검색 엔진 최적화 또는 SEO.\n\n링크 팜을 구매하거나 높은 순위의 사이트에 광고를 실어주는 등 \"더 높은 순위\"를 얻는 여러 기술이 있었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSEO 콘텐츠는 사이트에 키워드가 듬뿍 담긴 긴 단락을 추가하여 봇을 속이는 방법이었습니다.\n\n![이미지](/assets/img/2024-06-19-Theendoftheinternet_6.png)\n\n사람들이 읽고 싶어하지 않는 매우 작은 텍스트로 길게 쓰여져 있어서, 인간이 쓰거나 읽고 싶어하지 않는 방식으로 작성되었으며, 전체 제품을 차지하기 시작했습니다.\n\n모든 주요 페이지에는 SEO 전용 섹션이 포함되어 있었지만, \"로봇을 위한 블로그\"가 등장하기 시작했습니다. 알고리즘을 조작하고 더 많은 조회수를 얻기 위해 수백 개의 키워드로 가득 채워진 헛소리 포스트들이 올라오기 시작했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 실수로 이와 같은 사이트에 도착했다면 빠르게 나가셨을 것입니다. 왜냐하면 우리는 이것을 그냥 알다시피 취급할 뿐이죠 — 쓰레기 SEO 콘텐츠예요.\n\n![이미지](/assets/img/2024-06-19-Theendoftheinternet_7.png)\n\n# AI 시대\n\n우리는 이제 AI 시대에 살고 있습니다. 인덱싱하는 게 아니라 배우기 위해 웹을 탐색하는 다양한 종류의 로봇들이 있죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n오픈에이아이는 최근 뉴욕 타임스에 기사 전체를 거의 동일하게 요약했다며 소송을 당했어요. 수천 개의 콘텐츠가 침해되었다고 합니다.\n\n미드저니는 인터넷에서 대부분의 이미지를 가져오고 있는데, 이에 대해 대규모 시위와 데이터 오염 도구가 등장해 이를 막기 위한 노력이 이어졌어요.\n\n빙은 당신이 웹 사이트에 들어가지 않아도 답변해주는 AI 통합을 소개했어요.\n\n![이미지](/assets/img/2024-06-19-Theendoftheinternet_8.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n요 아크는 팬들에게 사랑받는 회사로, 이 아이디어를 더욱 발전시키며 브라우저를 재구상하려고 합니다. 이 브라우저는 더 이상 웹사이트를 방문하는 것에 관한 것이 아니라, 대신 봇을 통해 자동으로 작업을 수행하는 것이 주 목적이 될 것입니다.\n\n그러나 이 접근 방식에는 문제가 있습니다.\n\n![이미지](/assets/img/2024-06-19-Theendoftheinternet_9.png)\n\n## 인터넷 루프의 종말\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹사이트가 트래픽이 없으면 광고 수익을 잃고 사업을 폐업하게 될 거예요.\n\n그러면 봇은 이 웹사이트에서 파싱하고 처리할 새로운 콘텐츠가 없어져서 출력물의 품질이 낮아질 거에요. 그리고 이 과정이 계속해서 반복될 거예요.\n\n## 내 예상\n\n인터넷은 주로 두 가지 주요 부분으로 나눠질 것 같아요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n한 부분은 무료로 액세스할 수 있을 것이며, AI가 생성한 콘텐츠는 SEO 기사가 10년 전과 같이 사용자 참여율을 높이는 주요 목적으로 제공될 것입니다.\n\n대부분의 사람들은 검색 엔진을 위한 키워드 농장 기사라는 것을 깨달은 후에는 읽기를 계속하지 않았습니다.\n\n![이미지](/assets/img/2024-06-19-Theendoftheinternet_10.png)\n\n## 품질 넷\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n인터넷의 다른 부분은 유료 구조로 전환될 것입니다.\n\n높은 품질의 콘텐츠가 주를 이루는데, 대부분은 인간이 만들었습니다. 물론, 조금은 AI의 도움도 받았지만 그 양은 매우 적고 사실 명시될 것입니다.\n\n예를 들어, 교육적인 게시물에서 AI를 사용하여 이미지를 생성하는 경우가 있습니다. 텍스트는 사람이 작성해야 하므로, 그 이미지조차도 AI에서 나왔다는 사실이 명시됩니다. 완벽히 투명하게 공개됩니다.\n\n이 유료 구조는 현실적으로 요금을 지불해야 하는 구조이거나, 이메일로 로그인하고 뉴스레터를 구독하면서 지불하는 방식으로 운영될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n당연하지!\n\n# 로봇 금지\n\n콘텐츠 스크래핑을 방지하기 위한 지속적인 노력이 이루어질 것입니다. 이는 검색 엔진에 나타나는 고품질 콘텐츠가 줄어들 수 있다는 것을 의미합니다.\n\n결과적으로, 인터넷의 자유는 혜택을 완전히 상쇄하게 될 것입니다. 특히 질 좋은 콘텐츠에 대한 지불 능력이 없는 불우한 사람들에게는 이상적인 상황이 성립하지 않을 수 있습니다. 이들은 쓰레기로부터 배우게 되어 삶의 질을 향상하기가 더 어려워질 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다른 분들을 위해 AI가 생성한 콘텐츠를 요약해주기 때문에 이는 콘텐츠의 질을 더 희석시키는 결과를 가져올 수 있어요.\n\n오랜 기간 동안 지속할 수 없는 모델이며, 결국은 인류에게 해로울 것이 분명해요.\n\n하지만 지금은 편리하니까, 그냥 괜찮지 않을까요?\n\n# 인터넷 3.0\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n인터넷이 큰 변화를 맞이하고 있어요. 이미 우리는 접속 벽 뒤로 물건을 옮기고 스크래핑을 방지하기 시작했어요. 모든 산업이 최적화 경로를 선택하고 있어요. 심지어 내가 사랑하는 디자인 분야도 그렇죠. \n\n2024년에는 전통적인 검색에서 나타나는 것에 관심을 가지는 사람이 거의 없을 거예요. 대부분의 경우, 사람들은 보다 직접적인 마케팅 기술을 사용할 거예요.\n\n이것은 더욱 가속화될 거예요.\n\n어떻게 생각하세요? 댓글로 알려주세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n미래가 두려운 것인지 즐거운 것인지 어떻게 생각하시나요?","ogImage":{"url":"/assets/img/2024-06-19-Theendoftheinternet_0.png"},"coverImage":"/assets/img/2024-06-19-Theendoftheinternet_0.png","tag":["Tech"],"readingTime":5},{"title":"간단한 Snake 게임 만들기 HTML, CSS 및 JavaScript를 활용하여 함께 해봐요","description":"","date":"2024-06-19 14:38","slug":"2024-06-19-BuildingaSimpleSnakeGamewithHTMLCSSandJavaScript","content":"\n\n\n![Game screenshot](/assets/img/2024-06-19-BuildingaSimpleSnakeGamewithHTMLCSSandJavaScript_0.png)\n\n클래식 스네이크 게임을 만드는 것은 JavaScript 기술을 향상시키는 환상적인 방법입니다. 이 튜토리얼에서는 HTML, CSS 및 JavaScript를 사용하여 간단한 스네이크 게임을 만드는 방법을 단계별로 안내해 드리겠습니다.\n\n여기에서 게임을 확인하실 수 있고, 여기에서 GitHub 저장소를 확인하실 수 있습니다.\n\n# HTML 구조\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nHTML 구조부터 시작할게요. 주요 구성 요소는 게임을 렌더링하는 캔버스, 현재 및 최고 점수를 표시하는 스코어보드, 그리고 효과음을 출력하는 오디오 요소입니다.\n\n```js\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eSnake Game\u003c/title\u003e\n    \u003clink rel=\"stylesheet\" href=\"styles.css\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \u003cdiv class=\"game-container\"\u003e\n        \u003cdiv class=\"score-board\"\u003e\n            \u003cspan id=\"score\"\u003eScore: 0\u003c/span\u003e\n            \u003cspan id=\"high-score\"\u003eHigh Score: 0\u003c/span\u003e\n        \u003c/div\u003e\n        \u003ccanvas id=\"gameCanvas\"\u003e\u003c/canvas\u003e\n    \u003c/div\u003e\n    \u003caudio id=\"eatSound\" src=\"eat.wav\"\u003e\u003c/audio\u003e\n    \u003caudio id=\"bombSound\" src=\"bomb.wav\"\u003e\u003c/audio\u003e\n    \u003caudio id=\"gameOverSound\" src=\"gameover.wav\"\u003e\u003c/audio\u003e\n    \u003cscript src=\"script.js\"\u003e\u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n```\n\n# CSS 스타일링\n\n다음으로, 게임을 중앙 정렬하고 캔버스와 스코어보드 스타일을 추가할게요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nbody {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    height: 100vh;\n    margin: 0;\n    background-color: #282c34;\n    color: #61dafb;\n    font-family: 'Arial', sans-serif;\n}\n.game-container {\n    text-align: center;\n}\n.score-board {\n    margin-bottom: 10px;\n    font-size: 24px;\n}\ncanvas {\n    border: 1px solid #61dafb;\n    background-color: #000;\n}\n```\n\n# JavaScript Logic\n\n자, 이제 게임을 기능적으로 만들기 위해 JavaScript에 집중해 봅시다. 게임을 초기화하는 것, 게임 루프를 처리하는 것, 뱀을 그리고 움직이는 것, 음식을 다루는 것, 그리고 게임 오버 조건을 확인하는 것 등이 있습니다.\n\n# 초기 설정\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저 캔버스, 콘텍스트 및 초기 게임 변수를 설정합니다.\n\n```js\nconst canvas = document.getElementById('gameCanvas');\nconst ctx = canvas.getContext('2d');\nconst scoreElement = document.getElementById('score');\nconst highScoreElement = document.getElementById('high-score');\nconst eatSound = document.getElementById('eatSound');\nconst bombSound = document.getElementById('bombSound');\nconst gameOverSound = document.getElementById('gameOverSound');\nconst gridSize = 20;\ncanvas.width = 400;\ncanvas.height = 400;\nlet snake = [{x: gridSize * 2, y: gridSize * 2}];\nlet direction = {x: 0, y: 0};\nlet food = {};\nlet bombFood = null;\nlet score = 0;\nlet highScore = localStorage.getItem('highScore') || 0;\nlet bombTimeout;\nhighScoreElement.innerText = `High Score: ${highScore}`;\n```\n\n# 게임 초기화\n\ninit 함수는 초기 음식을 배치하고 키 입력에 대한 이벤트 리스너를 설정합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nfunction init() {\n    placeFood();\n    document.addEventListener('keydown', changeDirection);\n    gameLoop();\n}\n```\n\n# 게임 루프\n\n게임 루프 함수는 게임의 핵심입니다. 일정 간격으로 게임 상태를 업데이트합니다.\n\n```js\nfunction gameLoop() {\n    if (isGameOver()) {\n        return;\n    }\n    setTimeout(() =\u003e {\n        clearCanvas();\n        drawSnake();\n        moveSnake();\n        drawFood();\n        if (bombFood) drawBombFood();\n        checkFoodCollision();\n        checkBombFoodCollision();\n        gameLoop();\n    }, 100);\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 캔버스 초기화\n\nclearCanvas 함수는 매번 새로 그려짐에 앞서 캔버스를 지웁니다.\n\n```js\nfunction clearCanvas() {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n}\n```\n\n# 뱀 그리기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음은 캔버스에 뱀을 렌더링하는 drawSnake 함수입니다.\n\n```js\nfunction drawSnake() {\n    ctx.fillStyle = 'green';\n    snake.forEach((segment, index) =\u003e {\n        if (index === 0) {\n            ctx.fillStyle = 'lightgreen'; // 머리 색상\n        } else {\n            ctx.fillStyle = 'green';\n        }\n        ctx.fillRect(segment.x, segment.y, gridSize, gridSize);\n    });\n}\n```\n\n# 뱀 이동\n\nmoveSnake 함수는 현재 방향을 기반으로 뱀의 위치를 업데이트합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nfunction moveSnake() {\n    const head = {x: snake[0].x + direction.x, y: snake[0].y + direction.y};\n    if (head.x \u003e= canvas.width) {\n        head.x = 0;\n    } else if (head.x \u003c 0) {\n        head.x = canvas.width - gridSize;\n    }\n    if (head.y \u003e= canvas.height) {\n        head.y = 0;\n    } else if (head.y \u003c 0) {\n        head.y = canvas.height - gridSize;\n    }\n    snake.unshift(head);\n    snake.pop();\n}\n```\n\n# 방향 변경\n\nchangeDirection 함수는 뱀의 방향을 변경하는 키 입력을 처리합니다.\n\n```js\nfunction changeDirection(event) {\n    const keyPressed = event.keyCode;\n    const LEFT = 37;\n    const UP = 38;\n    const RIGHT = 39;\n    const DOWN = 40;\n    const W = 87;\n    const A = 65;\n    const S = 83;\n    const D = 68;\n    const goingUp = direction.y === -gridSize;\n    const goingDown = direction.y === gridSize;\n    const goingRight = direction.x === gridSize;\n    const goingLeft = direction.x === -gridSize;\n    if ((keyPressed === LEFT || keyPressed === A) \u0026\u0026 !goingRight) {\n        direction = {x: -gridSize, y: 0};\n    } else if ((keyPressed === UP || keyPressed === W) \u0026\u0026 !goingDown) {\n        direction = {x: 0, y: -gridSize};\n    } else if ((keyPressed === RIGHT || keyPressed === D) \u0026\u0026 !goingLeft) {\n        direction = {x: gridSize, y: 0};\n    } else if ((keyPressed === DOWN || keyPressed === S) \u0026\u0026 !goingUp) {\n        direction = {x: 0, y: gridSize};\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 음식 배치\n\nplaceFood 함수는 캔버스의 무작위 위치에 음식을 배치합니다.\n\n```js\nfunction placeFood() {\n    food = {\n        x: Math.floor(Math.random() * canvas.width / gridSize) * gridSize,\n        y: Math.floor(Math.random() * canvas.height / gridSize) * gridSize\n    };\n}\n```\n\n# 음식 그리기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ndrawFood 함수는 캔버스에 음식을 렌더링합니다.\n\nfunction drawFood() {\n    ctx.fillStyle = 'red';\n    ctx.fillRect(food.x, food.y, gridSize, gridSize);\n}\n```\n\n# 음식 충돌 처리\n\ncheckFoodCollision 함수는 뱀이 음식을 먹었는지 확인합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nfunction checkFoodCollision() {\n    if (snake[0].x === food.x \u0026\u0026 snake[0].y === food.y) {\n        eatSound.play();\n        score++;\n        scoreElement.innerText = `Score: ${score}`;\n        snake.push({});\n        placeFood();\n        if (Math.random() \u003c 0.1) {\n            placeBombFood();\n        }\n    }\n}\n```\n\n# 폭탄 음식 배치\n\nplaceBombFood 함수는 뱀이 추가 점수를 얻을 수 있는 폭탄 음식을 배치합니다.\n\n```js\nfunction placeBombFood() {\n    bombFood = {\n        x: Math.floor(Math.random() * canvas.width / gridSize) * gridSize,\n        y: Math.floor(Math.random() * canvas.height / gridSize) * gridSize\n    };\n    bombSound.play();\n    bombTimeout = setTimeout(() =\u003e {\n        bombFood = null;\n    }, 5000);\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 폭탄 음식 그리기\n\ndrawBombFood 함수는 캔버스에 폭탄 음식을 렌더링합니다\n\n```js\nfunction drawBombFood() {\n    if (bombFood) {\n        ctx.fillStyle = 'purple';\n        ctx.fillRect(bombFood.x, bombFood.y, gridSize, gridSize);\n    }\n}\n```\n\n# 폭탄 음식 충돌 처리\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 Markdown 형식으로 변경하세요.\n\n```js\nfunction checkBombFoodCollision() {\n    if (bombFood \u0026\u0026 snake[0].x === bombFood.x \u0026\u0026 snake[0].y === bombFood.y) {\n        eatSound.play();\n        score += 2;\n        scoreElement.innerText = `점수: ${score}`;\n        snake.push({}, {});\n        bombFood = null;\n        clearTimeout(bombTimeout);\n    }\n}\n```\n\n## 게임 종료 확인\n\nisGameOver 함수는 뱀이 자신과 충돌했는지 확인합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nfunction isGameOver() {\n    for (let i = 4; i \u003c snake.length; i++) {\n        if (snake[i].x === snake[0].x \u0026\u0026 snake[i].y === snake[0].y) {\n            playGameOverSound()\n                .then(() =\u003e {\n                    if (score \u003e highScore) {\n                        highScore = score;\n                        localStorage.setItem('highScore', highScore);\n                        highScoreElement.innerText = `High Score: ${highScore}`;\n                    }\n                    alert('게임 오버!');\n                })\n                .catch((error) =\u003e {\n                    console.error('게임 오버 사운드 재생 중 오류 발생:', error);\n                    if (score \u003e highScore) {\n                        highScore = score;\n                        localStorage.setItem('highScore', highScore);\n                        highScoreElement.innerText = `High Score: ${highScore}`;\n                    }\n                    alert('게임 오버!');\n                });\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n# 게임 오버 사운드 재생\n\nplayGameOverSound 함수는 게임 오버 사운드 효과를 재생합니다.\n\n```js\nfunction playGameOverSound() {\n    return new Promise((resolve, reject) =\u003e {\n        gameOverSound.onended = resolve;\n        gameOverSound.onerror = reject;\n        gameOverSound.play();\n    });\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 게임 시작\n\n마침내 init 함수를 호출하여 게임을 시작합니다.\n\n```js\ninit();\n```\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기에서 간단한 뱀 게임이 HTML, CSS 및 JavaScript로 구축되었습니다. 레벨, 다양한 종류의 음식 또는 보다 복잡한 뱀 이동과 같은 기능을 추가하여 이 게임을 확장할 수 있습니다.\n\n읽어 주셔서 감사합니다! 이 기사를 즐겁게 보셨다면 미디엄에서 저를 팔로우해 주시면 저의 향후 컨텐츠를 계속 받아보실 수 있습니다. 응원을 보내주세요!\n\n콘텐츠가 마음에 드셨다면 커피 한 잔 사주는 것으로 응원해 주세요!\n\n![BuildingaSimpleSnakeGamewithHTMLCSSandJavaScript_1.png](/assets/img/2024-06-19-BuildingaSimpleSnakeGamewithHTMLCSSandJavaScript_1.png)","ogImage":{"url":"/assets/img/2024-06-19-BuildingaSimpleSnakeGamewithHTMLCSSandJavaScript_0.png"},"coverImage":"/assets/img/2024-06-19-BuildingaSimpleSnakeGamewithHTMLCSSandJavaScript_0.png","tag":["Tech"],"readingTime":9},{"title":"C Net에서의 멀티스레딩 소개 및 모범 사례","description":"","date":"2024-06-19 14:35","slug":"2024-06-19-MultithreadinginCNetIntroductionandBestpractices","content":"\n\n\n![image](/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_0.png)\n\n# Agenda\n\n## I/ Introduction\n\n- Threads in a Computer CPU\n- Scheduler \u0026 Time slices\n- Processes \u0026 Threads\n- Concurrency and parallelism\n- Asynchrony vs Multithreading\n- Benefits of using multithreading in C#\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## II 스레드 C#에서\n\n스레드 라이프사이클\n스레드 생성, 시작 및 일시 중지\nJoin\nAbort\nInterrupt\n스레드 취소: 스레드를 중지하는 더 나은 방법\n\n## III/ 스레드 관련 문제\n\n데드락과 레이스 컨디션\nJoin 및 Locks를 사용하여 레이스 컨디션 및 데드락 방지\nAutoResetEvent\n스레드 성능 문제\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## IV/ 스레드 풀\n\n## V/ 동기화 메커니즘\n\nMutex\nSemaphore\nMonitor (lock)\n\n## VI/ 스레드 관리하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n포그라운드 대비 백그라운드 스레드\n스레드 컨텍스트\n스레드에 데이터 전달\n스레드 우선순위\n스레드 로컬 저장소\n스레드 디버깅\n\n## VII/ .Net에서 스레드를 다루는 추천 방법\n\n# I/ 소개\n\n## 컴퓨터 CPU에서의 스레드\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n쓰레드(thread)와 병렬성(parallelism)에 대해 이해하기 전에, 기본적인 하드웨어 동작 원리를 잘 파악하는 것이 중요합니다.\n\nCPU(중앙 처리 장치)는 컴퓨터의 뇌로, 애플리케이션을 실행하는 데 필요한 모든 명령을 실행하는 역할을 합니다.\n\n현대 컴퓨터에는 종종 여러 개의 코어(core)가 있으며, 각각이 논리 프로세서(logical processor)로 분할될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n각 프로세서는 두 개의 논리 프로세서로 나눠집니다.\n\n각 논리 코어는 이제 병렬로 여러 스레드를 처리할 수 있습니다! 예를 들어, 4코어 프로세서는 하이퍼스레딩 기술 덕분에 8개의 스레드를 동시에 처리할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n컴퓨터의 코어(core) 및 논리 코어(logical core) 수를 확인하려면 작업 관리자로 이동하여 '성능' 탭을 선택하세요.\n\n![Task Manager Performance](/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_4.png)\n\n또는 애플리케이션에서 다음 코드를 실행해도 됩니다:\n\n```js\nConsole.WriteLine(\"코어 수: \" + Environment.ProcessorCount);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 스케줄러 및 시간 조각\n\n**스케줄러**\n\n실제로 각 코어는 많은 명령을 동시에 실행합니다.\n\n다른 작업을 블록하는 것을 방지하기 위해 각 작업에 일정한 시간을 할당합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모든 작업을 아주 빠른 속도로 전환하면, 모든 작업이 동시에 실행되는 것 같아요!\n\n윈도우즈에서는 스케줄러라는 특별한 프로그램이 프로세서가 명령을 실행할 순서와 시간 프레임(프로세서 시간 조각이라고도 함)을 결정해요.\n\n이 프로그램은 프로세서가 명령을 실행할 순서와 시간 프레임을 결정하는 역할을 해요.\n\n![이미지](/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_5.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로세서 시간 조각\n\n이 시간 프레임은 프로세서 시간 조각으로도 알려져 있어요.\n\n이러한 시간 조각은 프로세서가 특정 명령을 처리하는 기간입니다. 너무 긴 명령이 전체 컴퓨터를 막는 것을 방지하기 위해 각 명령에는 특정 시간 조각이 부여됩니다.\n\n![이미지](/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_6.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 프로세스 및 스레드\n\n이제 프로세스와 스레드의 차이를 살펴보겠습니다.\n\n![Image](/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_7.png)\n\n프로세스는 실행 중인 프로그램입니다. 운영 체제는 실행 중인 응용 프로그램을 분리하기 위해 프로세스를 사용합니다. 스레드는 운영 체제가 프로세서 시간을 할당하는 기본 단위입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로세스\n\n- 기본적으로 프로그램을 실행하는 인스턴스\n- 고유한 메모리 공간과 자원을 보유합니다.\n- 다른 프로세스와 독립적으로 작동합니다.\n- 스레드를 하나 이상 포함할 수 있습니다.\n\n전형적인 시스템에는 수백 개의 프로세스가 동시에 실행될 수 있습니다.\n\n각 프로세스는 스레드를 포함하는 컨테이너 역할을 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로세스가 시작되면 각각이 자체 메모리 및 리소스를 할당받아 스레드 사이에서 공유됩니다.\n\n스레드\n\n- 프로세스 내에서의 실행 단위\n- 각각 자체 스택을 가짐\n- 동일한 프로세스 내 다른 스레드와 힙 메모리를 공유함\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음은 Markdown 형식으로 된 표입니다.\n\n![이미지1](/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_9.png)\n\n멀티 스레딩 프로세스에서 스레드는 힙 메모리를 공유합니다.\n\n![이미지2](/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_10.png)\n\n멀티스레딩은 프로그램이 여러 스레드를 실행할 수 있는 능력으로, 시스템 리소스를 효율적으로 활용할 수 있게 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 Markdown 형식으로 수정한 내용입니다.\n\n![image](/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_11.png)\n\n## Concurrency and parallelism\n\n![image](/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_12.png)\n\nConcurrency\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 두 개 이상의 작업이 겹치는 시간 동안 시작, 실행 및 완료될 수 있는 경우\n- 단일 쓰레드가 빠르게 전환하여 여러 작업을 처리하도록 하여 동시 실행의 환상을 주는 것\n\n병렬 처리\n\n- 둘 이상의 작업이 서로 다른 쓰레드에서 동시에 실행되는 경우\n- 두 개의 쓰레드가 실행하는 두 가지 작업\n\n![이미지](/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_13.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 비동기 처리 vs 멀티스레딩\n\n동기\n\n- 각 작업은 다음 작업이 시작되기 전에 완료되어야 합니다.\n- 한 작업이 너무 오래 걸리는 경우 비효율성을 야기할 수 있으며, 작업이 완료될 때까지 앱이 멈추거나 블로킹될 수 있습니다.\n\n작업은 순차적으로 실행됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n비동기 (단일 스레드)\n\n- 한 스레드가 여러 작업을 처리하면서 그 사이를 전환함\n- 흐름을 차단하지 않고 작업이 동시에 진행되도록 함\n\n두 작업이 같은 스레드 내에서 시작되고 동시에 진행됨\n\n비동기 (다중 스레드)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 여러 스레드가 동시에 서로 다른 작업을 처리합니다\n- 두 작업을 빠르고 효율적으로 완료합니다\n\n두 스레드를 사용하면 두 작업이 서로 독립적으로 동시에 진행됩니다\n\n![이미지](/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_14.png)\n\n## C#에서 멀티스레딩을 사용하는 장점\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n성능\n\n첫 번째 분명한 장점은 하드웨어 성능을 활용하여 작업을 병렬로 실행하여 속도를 높일 수 있다는 것입니다.\n\n응답성\n\n여러 프로세스가 동시에 실행되는 경우 데이터를 검색하기 위해 사용자가 클릭하더라도, 하나의 스레드가 데이터를 가져오는 동안 앱 전체가 반응성을 유지합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n확장성\n\n더 많은 요청을 처리하기 위해서는 각 작업에 대해 다른 스레드를 사용하여 동시에 처리하는 것이 가능합니다.\n\n## II. C#에서의 스레드\n\n이미 소개된 것처럼, 스레드는 CPU의 가장 낮은 작업 단위입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nC#은 스레드를 다루기 쉽게 만드는 라이브러리를 제공합니다: Thread 클래스입니다. 이 클래스를 사용하면 전체 스레드 라이프사이클을 관리할 수 있어요!\n\n![Thread Lifecycle](/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_15.png)\n\n## Thread Lifecycle\n\n일반적인 스레드는 다음과 같은 단계를 거칩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 스레드가 생성되었습니다\n- 스레드가 시작되었습니다\n- 스레드가 메소드를 완료했습니다\n- 스레드가 자동으로 종료되었습니다\n\n## 스레드 생성, 시작 및 일시 중지\n\n스레드를 생성하는 방법은 여러 가지가 있습니다\n\n```js\n// 새로운 스레드 생성\nvar thread = new Thread(new ThreadStart(Operation));\n\n// 또는 더 간결한 방법으로\nvar thread = new Thread(Operation);\n\n// 또는 람다를 사용하여\nvar thread = new Thread(() =\u003e { Operation(); });\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위에서 볼 수 있듯이 스레드는 인스턴스화되려면 메서드 대리자를 가져야 합니다.\n\n```js\n// 스레드는 작업(메서드 대리자)이 필요합니다\nvar thread = new Thread(Operation);\n\n// 완료해야 할 작업이 스레드 내로 전달됩니다\nprivate void Operation()\n{\n    Console.WriteLine(\"스레드에서 안녕하세요\");\n}\n```\n\n스레드가 생성되었더라도 명시적으로 시작해야 합니다.\n\n```js\n// 스레드 시작\nthread.Start();\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n한 번 시작되면 작업을 자동으로 수행하고 완료될 때까지 계속됩니다.\n\n한 번 종료된 스레드는 다시 시작할 수 없습니다.\n\n그러나 .Sleep 메서드를 사용하여 스레드를 일시 중지할 수 있습니다.\n\n시간이 경과한 후 자동으로 다시 시작됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 쓰레드를 일시 중지하고 중단하는 방법\nThread.Sleep(2000); // 밀리초나 TimeSpan을 사용합니다.\nsleepingThread.Interrupt();\n```\n\n쓰레드를 중지하는 방법에는 장단점이 있는 여러 가지 방법이 있습니다:\n\n- Join\n- Abort\n- Interrupt\n\n## Join\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nThread.Join은 스레드를 \"정상적으로\" 중지시키므로 코드는 스레드가 중지될 때까지 기다립니다.\n\n```js\nThread thread = new Thread(Work);\nthread.Start();\n\n// 스레드가 \"정상적으로\" 중지될 때까지 대기\nthread.Join();\n\nConsole.WriteLine(\"스레드가 종료되었습니다.\");\n```\n\n또한, 스레드가 완료될 때까지 무기한 대기하는 것을 피하기 위해 타임아웃을 전달하는 것도 가능합니다.\n\n```js\nThread thread = new Thread(Work);\nthread.Start();\n\n// 스레드가 중지되거나 타임아웃 시간이 경과할 때까지 대기\nbool didComplete = thread.Join(1000);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n주로 이 코드는 주 스레드가 1초 동안 대기하도록 하고 해당 스레드의 실행이 완료됐는지 확인합니다.\n\nJoin의 블로킹 특성\n\nThread.Join은 블로킹 호출이므로, 해당 스레드가 실행을 완료하거나 선택적으로 지정된 시간 제한이 경과할 때까지 반환하지 않습니다.\n\n즉, 주 스레드가 해당 스레드의 완료를 기다려야 한다는 것을 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어, Join을 현재 스레드에서 호출해서는 안 돼요.\n\n현재 스레드에서 현재 스레드에 Thread.Join을 호출하면 현재 스레드가 자기 자신을 기다리기 때문에 애플리케이션이 응답하지 않게 될 거에요.\n\n```js\nThread thread = Thread.CurrentThread;\n\n// 이렇게 하면 데드락이 발생하여 애플리케이션이 응답하지 않게 됩니다\n// thread.Join(); // 이렇게 하지 마세요\n\nConsole.WriteLine(\"현재 스레드에 Join을 호출하는 것을 피하세요.\");\n```\n\n멀티스레드 환경에서 Join\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n조인은 블로킹 호출이기 때문에 멀티스레딩(그리고 병렬) 목표에 부합하지 않아요!\n\n하지만 언제는 유용할 수도 있어요. 다른 스레드가 객체를 조작하는 하나의 스레드를 기다려야 하는 경쟁 조건에서 유용할 수 있답니다 (나중에 더 설명할게요).\n\n\u003cimg src=\"/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_16.png\" /\u003e\n\n## 중단\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n쓰레드를 강제로 미리 종료하도록 하는 ThreadAbortException이 발생합니다.\n\n그러나 스트림 연결을 닫지 않은 채로 갑작스럽게 스레드를 중지시킴으로써 메모리 누수나 리소스 누수가 발생할 수 있습니다.\n\n게다가, 스레드가 중단될 때 스레드나 조작된 객체들의 상태가 불분명합니다.\n\n이는 교착 상태, 리소스 누수 또는 메모리 누수로 이어질 수 있습니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마크다운 형식의 표 태그를 바꿔보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n인터럽트된 스레드가 Thread.Join 또는 Thread.Sleep를 호출했을 때에만 ThreadInterruptedException을 throw합니다.\n\n이는 동기화된 코드 영역에 대한 액세스를 기다리거나 Thread.Sleep 중에 스레드를 차단하는 작업을 중지하는 데 사용할 수 있습니다.\n\n```js\nThread thread = new Thread(Work);\nthread.Start();\n\n// 스레드가 시작할 시간을 줍니다\nThread.Sleep(500);\n\n// 스레드를 인터럽트하여 ThreadInterruptedException을 발생시킵니다\nthread.Interrupt();\n\n// 스레드가 인터럽션을 처리하고 완료할 때까지 기다립니다\nthread.Join();\n```\n\nThread.Interrupt는 스레드가 차단된 상태에서만 스레드를 인터럽트합니다. Thread.Sleep와 같이 현재 블로킹 호출 중인 코드가 아닌 경우엔 제3자 코드를 임의로 중단하지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nThread.Interrupt은 아직 지원되지만 CancellationToken을 사용한 협력적 취소가 더 예측 가능하고 관리하기 쉬운 스레드 중단 방법으로 자주 선호됩니다.\n\n## 스레드 취소: 스레드를 중지하는 더 좋은 방법\n\n그러나 .Net 5+부터 스레드 중단과 관련된 문제를 따라 Thread.Abort 또는 Thread.Interrupt 대신 스레드 취소를 사용하는 것을 Microsoft가 권장합니다.\n\n이 접근 방식은 스레드를 갑작스럽게 종료하는 것과 관련된 예측할 수 없는 상황 및 잠재적인 리소스 누수를 방지합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```cs\n// 취소 토큰을 인스턴스화합니다\nCancellationTokenSource cts = new CancellationTokenSource();\n\n// 스레드에 토큰 전달\nThread thread = new Thread(() =\u003e Work(cts.Token));\nThread.Start();\n\n// 주 스레드에서 다른 작업 시뮬레이션\nThread.Sleep(1000);\n\n// 1초 후 스레드 작업 취소\ncts.Cancel();\n\n// 스레드가 정상적으로 종료될 때까지 대기\nthread.Join();\n```\n\nCancellationTokenSource: 이 클래스는 취소를 신호하는 메커니즘을 제공합니다. 스레드로 전달할 수 있는 CancellationToken을 생성합니다.\n\nWork 메서드에 취소 토큰 전달\n\n```cs\nstatic void Work(CancellationToken cancellationToken)\n{\n    try\n    {\n        while (true)\n        {\n            // 취소 요청 확인\n            cancellationToken.ThrowIfCancellationRequested();\n\n            // 작업 시뮬레이션\n            Thread.Sleep(500);\n            Console.WriteLine(\"작업 중...\");\n        }\n    }\n    catch (OperationCanceledException)\n    {\n        Console.WriteLine(\"취소 요청 받음, 작업 종료.\");\n    }\n    finally\n    {\n        Console.WriteLine(\"여기 정리 코드가 있습니다.\");\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nThrowIfCancellationRequested: 이 메서드는 취소가 요청된 경우 OperationCanceledException을 throw하여 스레드가 안전하게 종료될 수 있도록합니다.\n\nCancellationToken을 사용하는 이점\n\n- 안전한 종료: 스레드는 종료하기 전에 현재 작업을 마무리하고 자원을 적절히 정리할 수 있습니다.\n- 예측 가능성: 스레드는 제어된 방식으로 종료되어 갑작스러운 종료의 위험을 피합니다.\n- 협력적인 취소: 스레드는 주기적으로 토큰을 확인하여 중지해야 하는지 여부를 확인하여 스레드 관리에 협력적인 접근이 가능합니다.\n\n현대 .NET 애플리케이션에서 스레드 라이프사이클을 관리하는 선호되는 방법은 CancellationToken을 사용하는 것입니다. 이를 통해 스레드가 예측 가능하고 안전하게 취소될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 쓰레드 관련 문제\n\n## 데드락과 경쟁 조건\n\n이미 소개된 대로, 각 쓰레드는 고유한 스택을 가지고 있지만 힙 메모리는 공유합니다.\n\n![이미지](/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_18.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여러 스레드가 하나의 공유된 값을 액세스하고 수정할 수 있다는 것을 의미합니다.\n\n이는 레이스 조건이라고 불리는 것을 일으킬 수 있습니다. 기본적으로 두 스레드가 동시에 동일한 값을 변경하는 상황입니다.\n\n![이미지 1](/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_19.png)\n\n![이미지 2](/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_20.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n요청해주신 코드 예제를 확인해보세요\n\n```js\n// 공유 변수\npublic static int i = 0;\n\npublic static void ExecuteWork()\n{\n    // 스레드가 루프를 실행\n    var t = new Thread(DoWork);\n    t.Start();\n    // 다른 스레드가 루프를 실행하면 경쟁 상태로 이어집니다\n    DoWork();\n}\n// 두 스레드가 이 메서드를 실행함\npublic static void DoWork()\n{\n    for(i = 0;i \u003c 5; i++)\n    {\n        Console.WriteLine(\"*\");\n    }\n}\n// \"******\"이 출력되어야 할 것을 5개가 아닌 6개 출력함\n```\n\n또다른 문제는 데드락인데, 이는 두 개 이상의 스레드가 영원히 차단되어 서로 다른 쓰레드가 리소스를 해제할 때를 기다리는 경우 발생합니다.\n\n데드락은 여러 스레드가 동일한 리소스 세트가 필요하고 이를 서로 다른 순서로 획득할 때 발생할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:520/0*QImExmL-baj0qzsk.gif\" /\u003e\n\n## Join과 Lock을 사용하여 경합 조건과 데드락 방지하기\n\n경합 조건을 방지하려면 다음 중 하나를 할 수 있습니다:\n\n- 스레드가 서로 기다릴 수 있도록 하기\n- 스레드를 잠그기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이전에 보았던 것처럼 `Thread.Join`을 사용하여 스레드를 대기할 수 있습니다.\n\n```js\n// 메인 스레드를 일시 중지합니다.\n// 스레드가 완료될 때까지 대기합니다.\n// 메인 스레드를 다시 실행합니다.\nthread.Join();\n\n// TimeSpan 또는 int Milliseconds도 사용할 수 있습니다.\nbool Thread.Join(TimeSpan timeout);\n```\n\n다른 방법은 `Thread.Lock` 문을 사용하는 것입니다.\n\n해당 문은 기본적으로 공유 객체를 \"잠그고\" 실행 중인 스레드만에게 액세스할 수 있도록 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n한 번 스레드가 끝나면 객체를 해제합니다.\n\n```js\nusing System;\nusing System.Threading;\n\nclass Program\n{\n// 이 객체들은 공유됩니다\n    private static readonly object lock1 = new object();\n    private static readonly object lock2 = new object();\n\n    public static void Main()\n    {\n        // 스레드 1\n        var t1 = new Thread(Thread1);\n        t1.Start();\n\n        // 스레드 2\n        var t2 = new Thread(Thread2);\n        t2.Start();\n\n        t1.Join();\n        t2.Join();\n    }\n\n    public static void Thread1()\n    {\n        lock (lock1)\n        {\n            Thread.Sleep(100); // 일부 작업 시뮬레이션\n            lock (lock2)\n            {\n                Console.WriteLine(\"Thread 1이 두 개의 락을 획득했습니다\");\n            }\n        }\n    }\n\n    public static void Thread2()\n    {\n        lock (lock2)\n        {\n            Thread.Sleep(100); // 일부 작업 시뮬레이션\n            lock (lock1)\n            {\n                Console.WriteLine(\"Thread 2가 두 개의 락을 획득했습니다\");\n            }\n        }\n    }\n}\n```\n\n## AutoResetEvent\n\nAutoResetEvent를 사용하면 스레드 간 통신을 동기화할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음은 작동 방법입니다:\n\n- AutoResetEvent를 생성합니다 =` 이벤트가 생성됨\n- 1번 스레드가 이벤트에 대해 WaitOne()을 호출합니다 =` 스레드1은 이벤트가 해제될 때까지 기다립니다\n- 2번 스레드가 작업을 수행한 후 이벤트에 대해 set()을 호출합니다 =` 스레드1이 작업을 수행할 수 있습니다\n\n```js\n   static AutoResetEvent autoResetEvent = new AutoResetEvent(false);\n\n    static void Thread1()\n    {\n        autoResetEvent.WaitOne(); // 이벤트가 신호를 받을 때까지 대기합니다\n        // 여기에서 작업을 수행합니다\n    }\n\n    static void Thread2()\n    {\n        // 일부 작업을 시뮬레이션합니다.\n        Thread.Sleep(2000); \n        autoResetEvent.Set(); // 이벤트를 신호하여 대기 중인 스레드 하나를 해제합니다\n    }\r\n```\n\n이제 스레드 간 통신이 이루어지며 서로 작업을 수행할 수 있는 시기를 신호로 알릴 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n로버스트한 통신을 위해서는 락을 피하기 위해 두 개의 AutoResetEvent와 함께 작업하는 것이 가장 좋습니다. 이렇게 하면 두 스레드가 필요할 때 Set 및 Wait를 시그널할 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_21.png)\n\n## 스레드 성능 문제\n\n새로운 스레드를 시작하는 것은 성능적으로 비용이 많이 드는데, 그 이유는 여러 가지가 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 메모리 할당\n\n새로운 스레드가 생성되면, 시스템은 해당 스레드의 스택과 스레드 제어 블록(TCB)을 위한 메모리를 할당합니다.\n\n이러한 리소스를 할당하고 초기화하는 작업은 메모리와 시간을 모두 소모합니다.\n\n- 운영 체제(OS) 오버헤드\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n각 스레드의 수명주기를 관리해야 합니다. 이러한 작업에는 CPU 사이클이 필요하며 스레드를 시작하는 오버헤드에 기여합니다.\n\n- 스레드 초기화\n\n스레드를 생성하는 것은 즉각적으로 이루어지지 않습니다. 할당된 자원을 설정하고 실행 환경을 구성하고 스케줄러에 통보하는 시간이 필요합니다.\n\n이 문제의 해결책은 스레드 풀을 사용하는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![ThreadPool](https://miro.medium.com/v2/resize:fit:720/0*9oNxhHqD2tltG8U4.gif)\n\n# IV/ The ThreadPool\n\nSystem.Threading.ThreadPool 클래스는 worker 스레드 풀을 제공합니다. 또한 스레드 풀 스레드를 사용할 수 있습니다.\n\n새 스레드를 생성하는 대신 스레드 풀을 사용하면 기존 스레드를 재사용하여 성능을 향상시킬 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기 과정이에요:\n\n- 쓰레드풀이 작업을 받음\n- 쓰레드풀이 쓰레드 할당\n- 쓰레드가 작업 실행\n- 쓰레드가 풀로 반환\n\n.NET 프레임워크는 스레드 관리를 수동으로 하지 않고도 쓰레드 풀을 사용할 수 있게 해주는 내장 ThreadPool 클래스를 제공합니다.\n\n그래서 이전에 하던 것처럼 쓰레드를 생성하는 대신 쓰레드를 쓰레드풀에 대기시키면 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nThreadPool.QueueUserWorkItem(Worker);\n\nvoid Worker()\n{\n    Console.WriteLine(\"작업이 실행되었습니다.\");\n}\n```\n\n관리되는 스레드 풀의 스레드는 백그라운드 스레드입니다.\n\n언제든지 사용 가능한 스레드, 풀의 최대 및 최소 스레드를 볼 수 있습니다. 또한 이를 설정할 수도 있습니다!\n\n```js\n// 사용 가능한 스레드 얻기\nThreadPool.GetAvailableThreads(out int workerThreads, out int completionPortThreads);\n\n// 최대 스레드 얻기\nThreadPool.GetMaxThreads(out int maxWorkerThreads, out int maxCompletionPortThreads);\n\n// 최소 스레드 얻기\nThreadPool.GetMinThreads(out int minWorkerThreads, out int minCompletionPortThreads);\n\n// 최대 스레드 설정\nThreadPool.SetMaxThreads(8, 8);\n\n// 최소 스레드 설정\nThreadPool.SetMinThreads(4, 4);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n쓰레드 풀을 사용해도 공유 데이터를 사용할 때는 여전히 쓰레드를 동기화해야 해요.\n\n# 동기화 메커니즘\n\nThread 클래스는 .NET의 동기화 기본 요소인 Mutex, Semaphore, Monitor와 원활하게 작동해요.\n\n이러한 메커니즘은 공유 리소스에 대한 액세스를 관리하고, 데이터 일관성을 보장하며 경쟁 조건을 방지하는 데 도움이 돼요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 뮤텍스\n\n뮤텍스(Mutex: mutual exclusion의 줄임말)는 한 번에 하나의 스레드만 락을 획득할 수 있는 동기화 기본 요소입니다.\n\n```js\nMutex mutex = new Mutex();\n\nfor (int i = 0; i \u003c 5; i++)\n{\n   Thread thread = new Thread(EnterCriticalSection);\n   thread.Start(i);\n}\n\nvoid EnterCriticalSection(object threadId)\n{\n  mutex.WaitOne(); // 뮤텍스 락 획득\n\n  try\n  {      \n      Thread.Sleep(1000); // 작업 시뮬레이션\n  }\n  \n  finally\n  {\n      mutex.ReleaseMutex(); // 뮤텍스 락 해제\n  }\n}\n```\n\n## 세마포어\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n세마포어는 동시에 리소스에 접근할 수 있는 스레드 수를 제한하는 동기화 기본 요소입니다.\n\n사용 가능한 리소스 수를 유지하고, 수가 0이 될 때 스레드를 차단합니다.\n\n```js\nSemaphore semaphore = new Semaphore(2, 2); // 2개의 스레드가 동시에 허용됨\n\nfor (int i = 0; i \u003c 5; i++)\n{\n    Thread thread = new Thread(EnterCriticalSection);\n    thread.Start(i);\n}\n\nstatic void EnterCriticalSection(object threadId)\n{\n    semaphore.WaitOne(); // 세마포어 획득\n    try\n    {\n        // Critical section: 공유 리소스에 액세스\n        Thread.Sleep(1000); // 작업 시뮬레이션\n    }\n    finally\n    {\n        semaphore.Release(); // 세마포어 해제\n    }\n}\n```\n\n## 모니터 (lock)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nMonitor 클래스는 C#의 lock 키워드를 사용하는 것과 유사하게 리소스에 대한 독점적 액세스 메커니즘을 제공합니다.\n\n이는 한 번에 한 스레드만 코드의 중요한 섹션을 실행할 수 있도록 보장합니다.\n\n```js\nstatic object lockObject = new object();\n\n\nfor (int i = 0; i \u003c 5; i++)\n{\n     Thread thread = new Thread(EnterCriticalSection);\n     thread.Start(i);\n    }\n }\n\nstatic void EnterCriticalSection(object threadId)\n{\n   lock (lockObject) // 락을 획득합니다.\n    {\n      Thread.Sleep(1000); // 작업 시뮬레이션\n    }\n}\n```\n\n# VI/ 스레드 관리\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## Foreground vs background thread\n\n기본적으로 .NET에서 생성된 쓰레드는 전경 스레드이므로 완료될 때까지 애플리케이션을 유지합니다.\n\n그러나 쓰레드를 백그라운드 쓰레드로 명시적으로 설정할 수 있으며, 전경 스레드가 모두 실행을 마치면 자동으로 종료됩니다.\n\n```js\n// 쓰레드를 백그라운드로 명시적으로 설정합니다.\nthread.IsBackground = true;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image](/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_22.png)\n\n## 스레드 컨텍스트\n\n스레드 컨텍스트에는 스레드가 실행을 중단하고 다시 시작할 수 있는 모든 정보가 포함되어 있습니다. 이에는 CPU 레지스터, 스택 및 기타 관련 데이터가 포함됩니다.\n\n```js\n// 스레드의 현재 상태에 대한 정보를 확인하려면 (실행 중, 백그라운드, 중지됨, 중단됨...)\n var threadState = thread.ThreadState;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 쓰레드에 데이터 전달하기\n\n람다 표현식은 쓰레드를 초기화하고 데이터를 전달하는 데 자주 사용됩니다.\n\n```js\n// 한 개의 인수만 전달 가능\nvar thread = new Thread(() =\u003e Operation(\"Hello\"));\n```\n\n```js\nprivate void Operation(string name)\n{\n    Console.WriteLine(\"쓰레드에서의 안녕\" + name);\n}\n```  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러나 race condition을 피하기 위해 공유 변수를 스레드에 전달할 때 주의해야 합니다. 상수 또는 지역 변수를 사용하는 것이 가장 좋습니다.\n\n```js\nconst string greeting = \"Hello\";\nvar thread = new Thread(() =\u003e Operation(greeting));\n```\n\n## 스레드 우선순위\n\n스레드는 실행 순서를 결정하는 서로 다른 우선순위를 가질 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더 높은 우선순위를 가진 스레드가 더 많은 CPU 시간을 받습니다. 기본 우선순위는 Normal입니다.\n\n```js\nthread.Priority = ThreadPriority.Highest;\n\n// 가능한 옵션은:\nLowest\nBelowNormal\nNormal\nAboveNormal\nHighest\n```\n\n## 스레드 로컬 스토리지\n\nThread 클래스는 ThreadLocal`T` 클래스를 사용하여 스레드 로컬 스토리지를 지원합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n각 스레드가 고유한 데이터를 가지도록하여 스레드 안전을 보장하고 데이터 손상을 방지합니다.\n\n```js\nThreadLocal\u003cint\u003e threadLocalValue = new ThreadLocal\u003cint\u003e(() =\u003e 0);\n```\n\n## 스레드 디버깅\n\n스레드에 이름을 지정하여 쉽게 디버깅할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_23.png)\n\n```js\nthread.Name = \"Bob Thread\";\n```\n\n![이미지](/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_24.png)\n\n다음과 같이 사용중인 스레드 정보를 얻을 수 있습니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nConsoleWriteLine(\"메인 스레드의 ID: \" + Thread.CurrentThread.ManagedThreadId);\n```\n\n또한 디버깅 중에는 어떤 스레드가 무엇을 수행하고 있는지 확인할 수도 있어요\n\n![이미지](/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_25.png)\n\n위 내용은 아래 창을 표시합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_26.png)\n\n# VII/ .Net에서 스레드 작업 추천 방법\n\n- Thread.Abort를 사용하지 마세요\n\n해당 스레드에 예외를 throw하는 것과 유사하게 스레드를 강제로 종료시킵니다. 대신 취소 토큰을 사용하세요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 다른 리소스를 필요로 하는 작업에는 여러 스레드를 사용하고 단일 리소스에 여러 스레드를 할당하는 것은 피하십시오.\n\nI/O 작업을 포함하는 작업은 블록을 방지하고 전체 처리량을 향상시키기 위해 각각 자체 스레드를 가지는 것이 좋습니다.\n\n마찬가지로 사용자 입력 처리와 같은 작업은 전용 스레드로 처리하는 것이 가장 좋습니다.\n\n```js\nThreadPool.QueueUserWorkItem(PerformIOOperation);\nThreadPool.QueueUserWorkItem(ProcessUserInput);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 쓰레드에서 예외를 처리하세요.\n\n쓰레드에서 처리되지 않은 예외는 일반적으로 프로세스를 종료시킵니다.\n\n```js\nThreadPool.QueueUserWorkItem(DoWork);\n\nvoid DoWork(object state)\n{\n    try\n    {\n        // 여기서 작업 수행\n    }\n    catch (Exception ex)\n    {\n        // 예외 처리\n    }\n}\n```\n\n- System.Threading.ThreadPool을 사용하여 쓰레드를 초기화하고 관리하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`System.Threading.ThreadPool` 클래스를 사용하여 스레드를 초기화하고 관리하세요. 특히 짧은 수명을 가진 작업과 비동기 작업에 유용합니다.\n\n스레드 풀은 작업자 스레드의 풀을 효율적으로 관리하여 스레드 생성 및 소멸의 부하를 줄입니다.\n\n```js\nThreadPool.QueueUserWorkItem(DoWork);\n```\n\n- 스레드 대신 작업들을 사용하세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n.NET Framework 4부터 멀티스레딩을 활용하는 권장 방법은 Task Parallel Library (TPL) 및 Parallel LINQ (PLINQ)를 사용하는 것입니다. 자세한 내용은 병렬 프로그래밍을 참조하십시오. (Microsoft)\n\n![이미지](/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_27.png)\n\n다음 블로그에서 다시 만나요! :)\n\n## 언제 스레드를 사용해야 할까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n쓰레드는 작업과 같은 고수준 추상화로는 항상 달성할 수 없는 수준의 제어와 사용자 정의를 제공합니다.\n\n쓰레드는 개발자에게 코드 실행을 저수준에서 직접 제어할 수 있는 기회를 제공합니다.\n\n이는 특정 성능 중요한 상황이나 전문화된 시나리오에서 중요할 수 있는 리소스, 스케줄링 및 동기화의 정확한 관리를 가능하게 합니다.\n\n쓰레드는 더 많은 제어와 유연성을 제공하지만 경합 조건, 데드락 및 동기화 문제와 같은 추가 복잡성과 잠재적인 함정도 동반합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n따라서, 귀하의 애플리케이션 요구 사항에 기반을 두고 상호 작용 모델을 신중히 고려하고 적절한 동시성 모델을 선택하는 것이 중요합니다.\n\n# 소스\n\n## 비동기\n\nhttps://www.udemy.com/course/ultimate-csharp-masterclass/\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 쓰레드\n\n[멀티쓰레드 C# 코드 작성 방법](https://www.udemy.com/course/how-to-write-multi-threaded-csharp-code)\n\n## .Net에서 병렬 프로그래밍","ogImage":{"url":"/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_0.png"},"coverImage":"/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_0.png","tag":["Tech"],"readingTime":21},{"title":"프론트엔드 주간 요약 367 2024년 6월 10일 - 6월 16일","description":"","date":"2024-06-19 14:31","slug":"2024-06-19-FrontendWeeklyDigest3671016Jun2024","content":"\n\n\n![Frontend Weekly Digest](/assets/img/2024-06-19-FrontendWeeklyDigest3671016Jun2024_0.png)\n\n# 웹 개발\n\n- Markdown에 대한 빠르고 쉬운 안내서\n- JavaScript 없이 비동기 DOM 업데이트를 하는 Streaming HTML\n- 새로운 HTML `permission` 요소에 대한 오리진 트라이얼\n- Node.js는 여기에 남아 있습니다\n- WWDC24 소식: Safari 18 베타에서 WebKit\n- 개발자들이 Wasm을 사용하는 놀라운 방법 11가지\n- 6년 만에 GraphQL에 미련이 없어졌습니다\n- 2024년 프론트엔드 현황 조사\n- 최소한의 SVG 파비콘\n\n## 도구\n- Deno에서 NestJS 사용하기?\n- 2024년에 DIY 노드 서버 실행하는 방법\n- IDE가 덜 똑똑하게 만들까요?\n\n## 성능\n- Speculation Rules로 초강력 웹사이트 만들기\n- 2024년에 Google Lighthouse 점수 변경하는 방법\n\n## 접근성\n- 표준화의 장점인 World Wide Accessibility\n- 접근 가능한 디자인을 위한 CSS에서 Rem 단위 사용 방법\n- 콘텐츠 숨김 기법과 그 접근성 영향\n\n## 효과\n- SDF 및 WebGL을 사용한 Shape Lens Blur 효과\n- SVG에서 임의 경로 변형\n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# CSS\n\n- CSS 컨테이너 스타일 쿼리는 무엇을 위해 좋을까요?\n- CSS와 웹 UI의 최신 소식: I/O 2024 요약\n- CSS의 보스 배틀 중 하나는 거의 이겼습니다! Auto로의 전환\n- 사용자 정의 속성에 대한 조건문\n- 또 다른 앵커 위치 설정 데모: 여러 앵커\n\n# JavaScript\n\n- TypeScript 5.5 RC 발표\n- TC39가 중요 제안들을 진행 중: 지연된 Import 평가, Error.isError(), RegExp 이스케이핑, Promise.try\n- 여러 매개변수를 받는 JavaScript 함수를 어떻게 구성하는지 (에픽 가이드)\n- 단일 취약점이 JavaScript 생태계를 무너뜨릴 수 있는 방법\n- JavaScript가 모듈 경험을 개선하고 있는 이유\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- TypeScript\n  - 나는 TypeScript을 이해하지 못한 채로 작성해 왔어요\n  - TypeScript은 ECMAScript의 Set 메소드를 지원합니다\n- React\n  - 오늘 React 컴파일러를 시도해 봤는데, 짠! 😉\n  - React에서 이커머스 검색을 구현하는 최고의 도구들\n  - 내가 발견한 멋진 VSCode 확장 프로그램들\n- Vue\n  - Composition API로 Vue.js 3에서 Vue Router를 어떻게 마스터할까요?\n- Angular\n  - Rust(Wasm)로 Angular을 강화하는 방법\n  - Angular을 이용한 모듈 페더레이션을 사용한 마이크로 프론트엔드 구축 — Angular을 이용한 수직 애플리케이션","ogImage":{"url":"/assets/img/2024-06-19-FrontendWeeklyDigest3671016Jun2024_0.png"},"coverImage":"/assets/img/2024-06-19-FrontendWeeklyDigest3671016Jun2024_0.png","tag":["Tech"],"readingTime":2},{"title":"슈퍼 빠른 http 서버 만들기 with Rust  htmx 파트 1","description":"","date":"2024-06-19 14:31","slug":"2024-06-19-SuperfasthttpserverwithRusthtmxpart1","content":"\n\n\n![SuperfasthttpserverwithRusthtmxpart1_0](/assets/img/2024-06-19-SuperfasthttpserverwithRusthtmxpart1_0.png)\n\n내 첫 번째 글 중 하나에서는 다양한 아키텍처에서 Rust의 사용에 대해 이야기했습니다. 내가 임베디드 리눅스 시스템에서 작업하면서, 사용 가능한 하드웨어 자원을 최적으로 활용하는 효율적인 프로그래밍 언어를 채용하는 것이 반드시 필요해집니다. 이전 논의는 Rust에서의 크로스 컴파일의 간단함에 초점을 맞추었지만, 이는 프로세스의 최초 단계에 불과합니다.\n\n내 작업을 고려할 때, 고객에게 장치를 관리할 수 있는 인터페이스를 제공하는 것이 흔한 요구사항입니다. 이 측면을 임베디드 웹 서버라고 적절히 표현할 수 있습니다.\n\n이 주제에 대한 정보를 찾기 위해 웹을 뒤지면 다양하고 흥미로운 글과 자습서를 만날 수 있습니다. 그러나 문제는 이러한 리소스의 거의 90%가 내 것보다 훨씬 강력한 하드웨어를 위한 맞춤형 우수한 솔루션을 제공한다는 것입니다. 보통 그들은 다음과 같은 주제를 다룹니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 백엔드와 프론트엔드의 분리.\n- 마이크로서비스 아키텍처 활용.\n- 메시지 브로커 구현.\n- 고급 데이터베이스 사용.\n\n이러한 측면들은 서버 배포에 기본적으로 중요하지만, 임베디드 리눅스 솔루션에서는 지나치게 복잡할 수 있습니다. 이에 따라 지난 달에 htmx를 탐색하여 더 가벼운 것을 설계하고자 시작했습니다. 임베디드 웹 서버의 제약 사항 내에서 쾌적한 사용자 경험을 보장하기 위함입니다. 오늘은 제가 배운 내용을 공유하고 향후 구현에 대해 이야기하고자 합니다.\n\n## 사용 기술 스택\n\n시작하기 전에, 비교적 간단한 애플리케이션을 구성하는 데 사용할 구성 요소를 살펴봅시다. 이 애플리케이션은 정적 HTML을 제공하지만 htmx로 구동되는 반응성이 있습니다. 사용할 샌드박스 설정은 다음과 유사할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Rust: (믿을 수 있니?)\n- Axum: 정적 자산을 제공하고 백엔드 API를 구동하기 위해\n- Askama: HTML 템플릿팅에 사용되며, 레이아웃, 스크립트, CSS 등을 공유하는 데 도움이 됩니다.\n- htmx: UI의 반응성을 위해 사용합니다.\n- Tailwind: 내장되어 있다고 해도 미적이어야만 하는 것은 아니죠?\n\n## 첫 번째 설정\n\n먼저 필요한 종속성을 Cargo.toml 파일에 추가해보겠습니다.\n\n```js\n[package]\nname = \"rust-htmx\"\nauthors = [\"Davide Ferrero\"]\ndescription = \"Rust-Axum-Askama-HTMX: 경량 임베디드 웹 서버 만들기\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nanyhow = \"1.0.79\"\naskama = \"0.12.1\"\naxum = \"0.7.4\"\ntokio = { version = \"1.36.0\", features = [\"full\"] }\ntower = \"0.4.13\"\ntower-http = { version = \"0.5.1\", features = [\"fs\"] }\ntracing = \"0.1.40\"\ntracing-subscriber = { version = \"0.3.18\", features = [\"env-filter\"] }\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\ncargo-watch라는 편리한 핫 리로드 기능을 위해서 cargo-watch를 설치하는 것을 추천해드립니다. 매번 변경사항을 확인하려고 할 때마다 `cargo run`을 입력할 필요가 없어져요. 전역으로 설치하려면, 간단히 `cargo install cargo-watch`를 사용하시면 됩니다. 한 번 설치하면 `cargo-watch -x run`으로 실행할 수 있어요.\n\n이제 우리는 모든 종속성을 다운로드하고 컴파일하기 위해 cargo build를 실행할 준비가 되었어요. 컴파일 중에는 main.rs 파일에서 추적기를 설정하고 구성할 수 있어요.\n\n```rust\nuse tracing::info;\nuse tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};\n\n#[tokio::main]\nasync fn main() {\n    tracing_subscriber::registry()\n        .with(\n            tracing_subscriber::EnvFilter::try_from_default_env()\n                .unwrap_or_else(|_| \"rust_htmx=debug\".into()),\n        )\n        .with(tracing_subscriber::fmt::layer())\n        .init();\n\n    info!(\"내장 웹 서버가 말합니다: 안녕, 세상아!\");\n}\n```\n\n트레이서를 사용해본 적이 없다면, 제 앱의 이름이 `rust-htmx`이지만 EnvFilrer에서는 `rust_htmx`를 사용해야 한다는 것을 주목하세요. 앱을 실행하면 다음과 같은 내용이 표시될 거예요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n   Compiling rust-htmx v0.1.0 (C:\\Users\\davide.ferrero\\Documents\\Rust\\rust-htmx)\n    Finished dev [unoptimized + debuginfo] target(s) in 1.88s\n     Running `target\\debug\\rust-htmx.exe`\n2024-02-05T14:54:56.118052Z  INFO rust_htmx: Embedded Web Server says: Hello, World!\n```\n\n이제 main.rs에서 axum 라우트를 추가하여 askama 템플릿을 제공하겠습니다.\n\n```js\nuse anyhow::Context;\nuse askama::Template;\nuse axum::{\n    http::StatusCode,\n    response::{Html, IntoResponse, Response},\n    routing::get,\n    Router,\n};\nuse tracing::info;\nuse tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};\n\n#[tokio::main]\nasync fn main() -\u003e anyhow::Result\u003c()\u003e {\n    tracing_subscriber::registry()\n        .with(\n            tracing_subscriber::EnvFilter::try_from_default_env()\n                .unwrap_or_else(|_| \"rust_htmx=debug\".into()),\n        )\n        .with(tracing_subscriber::fmt::layer())\n        .init();\n\n    info!(\"router init...\");\n\n    let router = Router::new().route(\"/\", get(hello));\n    let port = 8086_u16;\n    let listener = tokio::net::TcpListener::bind(format!(\"0.0.0.0:{}\", port))\n        .await\n        .unwrap();\n\n    info!(\"router init complete: now listening on port {}\", port);\n\n    axum::serve(listener, router).await.unwrap();\n\n    Ok(())\n}\n\nasync fn hello() -\u003e impl IntoResponse {\n    let template = HelloTemplate {};\n    HtmlTemplate(template)\n}\n\n#[derive(Template)]\n#[template(path = \"app.html\")]\nstruct HelloTemplate;\n\n/// Askama로 파싱된 HTML을 axum에서 제공할 수 있는 형태로 캡슐화하는 래퍼 타입입니다.\nstruct HtmlTemplate\u003cT\u003e(T);\n\n/// Askama HTML 템플릿을 axum에서 응답으로 제공할 수 있도록 변환합니다.\nimpl\u003cT\u003e IntoResponse for HtmlTemplate\u003cT\u003e\nwhere\n    T: Template,\n{\n    fn into_response(self) -\u003e Response {\n        // Askama로 템플릿 렌더링을 시도합니다.\n        match self.0.render() {\n            // 템플릿을 성공적으로 파싱하고 집계할 수 있는 경우 제공합니다.\n            Ok(html) =\u003e Html(html).into_response(),\n            // 그렇지 않은 경우 에러를 반환하거나 대체 HTML 조각을 제공합니다.\n            Err(err) =\u003e (\n                StatusCode::INTERNAL_SERVER_ERROR,\n                format!(\"Failed to render template. Error: {}\", err),\n            )\n                .into_response(),\n        }\n    }\n}\n```\n\n이제 hello 함수 다음에 오류가 발생할 수 있습니다. 이는 Askama가 템플릿 폴더에서 app.html 파일을 찾기 때문입니다. 그러나 현재 이 두 구성 요소가 없습니다. 이를 해결하려면 루트 디렉토리에 templates라는 폴더를 만들고 그 안에 app.html이라는 파일을 생성하십시오. 내용을 자유롭게 추가할 수 있으며, 예를 들어 `h1`인사말: 임베디드 웹 서버로부터`/h1`을 작성했습니다. 이제 코드를 실행하면 localhost:8086에서 유사한 결과를 관찰해야합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-SuperfasthttpserverwithRusthtmxpart1_1.png\" /\u003e\n\n페이지를 보니 개선할 여지가 있네요. 외관을 개선하여 현재에 맞추어 보겠습니다. 저는 다양한 유틸리티를 제공하는 Tailwind를 선호합니다.\n\nTailwind는 다양한 기술 스택에 대한 통합 가이드를 제공하지만, Axum으로 구성된 Rust 기반의 정적 파일 서빙은 아직 다루지 않았습니다. 걱정하지 마세요. Tailwind의 기본 전략을 활용하여 스타일링을 추가할 수 있습니다.\n\nTailwind에 익숙하지 않다면 설명서를 참조하고 디자인 시스템 철학을 이해해보세요. 우리는 최적화를 활용할 것이며, Tailwind의 주요 장점 중 하나는 CSS를 최소화하여 번들된 스타일을 간결하게 유지해준다는 점입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 이제 Tailwind를 프로젝트에 통합하기 위해 프로젝트의 루트 폴더에 간단한 package.json 파일을 생성해야 합니다. npm init을 입력하세요.\n\n```js\n{\n  \"name\": \"rust-htmx\",\n  \"version\": \"0.1.0\",\n  \"description\": \"Rust-Axum-Askama-HTMX: 경량 임베디드 웹 서버 제작\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" \u0026\u0026 exit 1\"\n  },\n  \"author\": \"Davide Ferrero\",\n  \"license\": \"ISC\"\n}\n```\n\n패키지 매니페스트가 설정되었으니, 몇 가지 추가를 해보겠습니다.\n\n```js\nnpm add -D tailwindcss prettier prettier-plugin-tailwindcss\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 우리는 불필요한 부분을 제거하고 린팅 목적을 위해 빠른 스크립트를 추가하여 JSON을 개선할 수 있습니다.\n\n```js\n{\n  \"name\": \"rust-htmx\",\n  \"version\": \"0.1.0\",\n  \"scripts\": {\n    \"format\": \"prettier --write --ignore-unknown .\"\n  },\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"prettier\": \"^3.2.5\",\n    \"prettier-plugin-tailwindcss\": \"^0.5.11\",\n    \"tailwindcss\": \"^3.4.1\"\n  }\n}\n```\n\n이제 터미널에서 npm run format을 실행하여 코드를 포맷할 수 있습니다. 이제 app.html 파일로 돌아가서 몇 가지 추가를 해보겠습니다. 파일 상단의 존재하지 않는 main.css에 대해 걱정하지 마세요. 이 CSS 파일은 Tailwind의 CLI가 생성하는 컴파일된 출력을 저장할 것입니다. CLI는 /templates 디렉토리의 HTML 파일을 스캔하여 불필요한 유틸리티 클래스를 식별하고 제외합니다. 이 최적화는 번들링된 CSS 파일의 크기를 줄여 사용자 브라우저에 전달될 것입니다.\n\n```js\n\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n    \u003chead\u003e\n        \u003clink href=\"/assets/main.css\" rel=\"stylesheet\" /\u003e\n    \u003c/head\u003e\n    \u003cbody\u003e\n        \u003ch1 class=\"text-indigo-500\"\u003e임베디드 웹 서버에서 인사드립니다!\u003c/h1\u003e\n    \u003c/body\u003e\n\u003c/html\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이전에 언급했듯이, 이것은 생성된 파일이며 기본적으로 포함되지 않을 수 있습니다. 시작하려면 Tailwind가 HTML 템플릿에서 사용하는 유틸리티를 생성하는 데 사용할 CSS 파일을 추가해야 합니다. styles 디렉토리에 tailwind.css라는 파일을 생성해 봅시다:\n\n```js\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n```\n\nCLI를 활용하여 tailwind.css 파일을 입력으로 읽고, HTML에서 사용된 유틸리티를 분석하고, 제공을 위한 최적화된 스타일시트를 생성할 것입니다. 첫 번째 작업을 시작해 봅시다:\n\n```js\nnpx tailwindcss -i styles/tailwind.css -o styles/main.css --watch\n\n재빌드 중...\n\nwarn - 소스 파일에서 유틸리티 클래스가 감지되지 않았습니다. 이 점이 예상치 않은 것이라면 Tailwind CSS 구성의 'content' 옵션을 다시 확인하세요.\nwarn - https://tailwindcss.com/docs/content-configuration\n\n182ms 내에 완료되었습니다.\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n잘 하고 계신데요! 그러나 Tailwind는 제거를 위한 유틸리티 클래스를 감지하지 못했습니다. 이는 우리가 Tailwind가 마크업을 분석하는 것을 안내할 설정 파일이 없기 때문입니다. 한 가지 추가해봅시다:\n\n```js\nnpx tailwindcss init     \n\nTailwind CSS 구성 파일 생성됨: tailwind.config.js\n```\n\n그리고 생성된 파일에 약간의 수정을 가해봅시다:\n\n```js\n/** @type {import('tailwindcss').Config} */\nmodule.exports = {\n  content: ['./templates/*.html'],\n  theme: {\n    extend: {},\n  },\n  plugins: [],\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그리고 ESLint과의 호환성을 보장하기 위해 확장자를 .cjs로 변경하겠습니다. Tailwind에 익숙하지 않은 분들을 위해 말씀드리자면, 이는 주로 유틸리티 클래스를 찾을 위치를 Tailwind에 지시하는 구성 파일입니다. 이제 main.rs 파일로 돌아와서 Axum에게 Tower 서비스 라우트를 통해 'assets' 폴더에서 Tailwind로 컴파일된 CSS 파일을 제공하도록 지시해야 합니다.\n\n```rust\n// 라우터에 assets 추가\nlet assets_path = std::env::current_dir().unwrap();\nlet router = Router::new().route(\"/\", get(hello)).nest_service(\n    \"/assets\",\n    ServeDir::new(format!(\"{}/assets\", assets_path.to_str().unwrap())),\n);\n```\n\nTailwind CLI를 다시 실행하면 main.css 파일이 업데이트되며 페이지를 새로 고치면 인디고 색상으로 된 h1 블록이 최종적으로 표시됩니다.\n\n## 템플릿 구조 확장\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희 현재 템플릿 생성 시스템에는 필수적인 요소가 부족합니다: 템플릿 상속 기능이 없습니다. 추가적인 Axum 루트들이 HTML을 제공하도록 도입한다면, 각 파일마다 `head` 태그를 포함해야 하는 불편함이 발생할 것입니다. 이는 개발자 경험이 최적화되지 않는 것이죠. 이상적으로는 우리가 공통 head 메타데이터를 포함하는 기본 마크업 파일을 확장할 수 있는 템플릿을 원할 것입니다.\n\n다행히도, Askama가 이 문제에 대한 해결책을 제공합니다. 우리는 개별 루트 템플릿이 확장할 수 있는 기본 템플릿 레이아웃을 정의할 수 있습니다. 모든 템플릿에 중복되는 보일러플레이트 HTML을 줄이고 개발 프로세스를 간소화하기 위해, `base.html` 파일을 생성해 보겠습니다. 이 파일은 모든 공유 head 메타데이터를 포함하여 일관되고 효율적인 접근 방법의 기반이 될 것입니다.\n\n이제 우리는 `app.html`을 다음과 같이 정리할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003c!-- prettier-ignore --\u003e\n{ extends \"base.html\" }\n\n{ block title }App{ endblock }\n\n{ block content }\n\u003ch1 class=\"text-indigo-500\"\u003e임베디드 웹 서버에서 인사드립니다!\u003c/h1\u003e\n{ endblock }\n```\n\n우리가 이제 좋은 확장 가능한 페이지 모델을 갖고 있다는 것을 증명하기 위해, 홈페이지에 라우팅되는 링크가 있는 다른 페이지를 추가해 보겠습니다. 이 새로운 페이지는 아주 잘 지어진 템플릿인 another-page.html을 사용할 것입니다.\n\n```js\n\u003c!-- prettier-ignore --\u003e\n{ extends \"base.html\" }\n\n{ block title }다른 페이지!{ endblock }\n\n{ block content }\n\u003ch1 class=\"font-bold text-red-500\"\u003e다른 페이지\u003c/h1\u003e\n{ endblock }\n```\n\n이제 /another-page 프론트엔드 경로에 액섬 라우트를 통합하여, 사용자가 이 템플릿을 요청했을 때의 응답을 처리해보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```js\nlet router = Router::new()\n    .route(\"/\", get(hello))\n    .route(\"/another-page\", get(another_page))\n    .nest_service(\n        \"/assets\",\n        ServeDir::new(format!(\"{}/assets\", assets_path.to_str().unwrap())),\n    );\n\n........\n\nasync fn another_page() -\u003e impl IntoResponse {\n    let template = AnotherPageTemplate {};\n    HtmlTemplate(template)\n}\n\n#[derive(Template)]\n#[template(path = \"another-page.html\")]\nstruct AnotherPageTemplate;\n```\n\n만약 이전에 Tailwind CLI를 중지했다면, 최근에 추가된 스타일로 main.css 파일을 업데이트하려면 다시 시작해야 합니다. 그 이후에 로컬호스트 경로에서 다른 페이지로 직접 이동하면 이제 빨간색으로 스타일이 적용된 두 번째 페이지가 표시될 것입니다. 멋지네요!\n\n## 다음 단계\n\n오늘은 여기까지입니다! 다음 세그먼트에서는 네비게이션 기능을 통합하고 간단한 앱을 향상시키기 위해 몇 가지 흥미로운 htmx 기능을 구현하기 시작할 것입니다. 직접 리포지토리를 다운로드하길 원하시면 여기로 시작할 수 있는 링크가 있습니다. 이 첫 번째 부분이 흥미롭다고 생각되었으면서, 도전적인 문제에 부딪히거나 질문이 있으면 망설이지 말고 문의해 주세요. 다음 시간까지, 감사합니다. 다음 세션에서 뵙겠습니다!\n","ogImage":{"url":"/assets/img/2024-06-19-SuperfasthttpserverwithRusthtmxpart1_0.png"},"coverImage":"/assets/img/2024-06-19-SuperfasthttpserverwithRusthtmxpart1_0.png","tag":["Tech"],"readingTime":11},{"title":"플러터 앱 라이프사이클 이해하기 단계별 안내","description":"","date":"2024-06-19 14:29","slug":"2024-06-19-UnderstandingFlutterAppLifecycleAStep-by-StepGuide","content":"\n\n# 소개\n\nFlutter 애플리케이션의 수명주기를 이해하는 것은 효과적인 앱 개발에 중요합니다. 이 포관적인 안내서에서는 앱의 다양한 수명주기 상태를 모니터링하고 표시하는 방법을 보여주는 Flutter 코드 스니펫을 살펴보겠습니다. 코드를 분석하고 설명을 제공하며 각 단계를 안내하는 과정을 함께 따라와 주세요.\n\n# Flutter 앱 수명 주기\n\n![이미지](/assets/img/2024-06-19-UnderstandingFlutterAppLifecycleAStep-by-StepGuide_0.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 스크린샷\n\n![UnderstandingFlutterAppLifecycleAStep-by-StepGuide_1](/assets/img/2024-06-19-UnderstandingFlutterAppLifecycleAStep-by-StepGuide_1.png)\n\n# Flutter 앱 라이프사이클 상태\n\n- resumed: 앱이 전경으로 돌아왔고 사용자와 상호 작용할 준비가 되어 있는 상태입니다. 일시 중지되거나 비활성 상태에서 전환됩니다.\n- inactive: 앱이 비활성 상태이며 일반적으로 전경과 배경 사이를 전환 중인 상태입니다. 이 상태에서는 사용자 상호 작용이 처리되지 않습니다.\n- hidden: 앱이 숨겨진 상태이며 사용자에게 보이지 않음을 나타냅니다. 이 상태는 앱이 최소화되거나 다른 애플리케이션에 의해 가려졌을 때 자주 발생합니다.\n- paused: 앱이 일시 중지되어 코드를 실행하지 않습니다. 이 상태는 앱이 배경에 있고 사용자에게 보이지 않을 때 발생합니다.\n- detached: 앱이 프레임워크에서 완전히 분리되어 종료되기 직전임을 나타냅니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 준비 사항\n\n코드를 시작하기 전에 다음 사항을 확인해주세요:\n\n- 컴퓨터에 Flutter SDK가 설치되어 있어야 합니다.\n- Flutter 앱 구조에 대한 기본적인 이해가 필요합니다.\n\n# 단계 1: 새로운 Flutter 앱 생성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n새로운 Flutter 앱을 만들어보세요. 즐겁게 사용하시는 IDE나 명령 줄을 사용하시면 됩니다. 이름을 app_lifecycle_demo로 지어보세요.\n\n```js\nvoid main() {\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: Scaffold(body: AppLifecycleDisplay()),\n    );\n  }\n}\n```\n\n# 단계 2: 앱 구조 정의하기\n\nmain.dart 파일에서 Flutter 앱의 구조를 정의해보세요. AppLifeCycleDisplay 위젯을 포함한 간단한 MaterialApp과 Scaffold를 생성해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 단계 3: AppLifecycleDisplay 위젯 구현\n\nAppLifeCycleDisplay 위젯을 만들어주세요. 이 위젯은 앱 라이프사이클 상태를 모니터링하고 표시합니다. 이 위젯은 StatefulWidget을 확장하여 상태를 관리합니다.\n\n```js\nclass AppLifecycleDisplay extends StatefulWidget {\n  const AppLifecycleDisplay({super.key});\n\n  @override\n  State\u003cAppLifecycleDisplay\u003e createState() =\u003e _AppLifecycleDisplayState();\n}\n``` \n\n# 단계 4: _AppLifecycleDisplayState 구현\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAppLifeCycleDisplay 위젯의 상태를 정의하세요. 앱 라이프사이클 이벤트에 대한 리스너와 스크롤을 위한 ScrollController를 포함한 필수 변수를 초기화하세요. initState 메서드 내에서 앱 라이프사이클 이벤트를 위한 리스너를 설정하고 초기 상태를 상태 히스토리에 추가하세요. 또한 메모리 누출을 방지하기 위해 dispose 메서드에서 리스너를 해제하세요.\n\n```js\nclass _AppLifecycleDisplayState extends State\u003cAppLifecycleDisplay\u003e {\n  late final AppLifecycleListener _listener;\n  final ScrollController _scrollController = ScrollController();\n  final List\u003cString\u003e _states = \u003cString\u003e[];\n  late AppLifecycleState? _state;\n\n  @override\n  void initState() {\n    super.initState();\n    _state = SchedulerBinding.instance.lifecycleState;\n    _listener = AppLifecycleListener(\n      // 이벤트 핸들러...\n    );\n    if (_state != null) {\n      _states.add(_state!.name);\n    }\n  }\n  \n  @override\n  void dispose() {\n    _listener.dispose();\n    super.dispose();\n  }\n}\n```\n\n# 스텝 5: 라이프사이클 전환 처리하기\n\n다양한 앱 라이프사이클 전환을 처리하는 메서드를 구현하세요. 전환 발생 시 상태를 업데이트하고 히스토리의 가장 아래로 스크롤하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nvoid _handleTransition(String name) {\n  setState(() {\n    _states.add(name);\n  });\n  _scrollController.animateTo(\n    _scrollController.position.maxScrollExtent,\n    duration: const Duration(milliseconds: 200),\n    curve: Curves.easeOut,\n  );\n}\n\nvoid _handleStateChange(AppLifecycleState state) {\n  setState(() {\n    _state = state;\n  });\n}\n```\n\n# 단계 7: UI 구축하기\n\nMaterialApp, Scaffold 및 현재 상태와 상태 히스토리를 표시하는 텍스트 위젯이 있는 중앙 정렬된 column을 사용하여 UI를 빌드하는 코드를 완성하세요.\n\n```js\n@override\nWidget build(BuildContext context) {\n  return MaterialApp(\n    debugShowCheckedModeBanner: false,\n    home: Scaffold(\n      appBar: AppBar(\n        elevation: 0,\n        title: const Text('App LifeCycle State'),\n      ),\n      body: Center(\n        child: SizedBox(\n          width: 300,\n          child: SingleChildScrollView(\n            controller: _scrollController,\n            child: Column(\n              children: \u003cWidget\u003e[\n                Text('Current State: ${_state ?? 'Not initialized yet'}'),\n                const SizedBox(height: 30),\n                Text('State History:\\n  ${_states.join('\\n  ')}'),\n              ],\n            ),\n          ),\n        ),\n      ),\n    ),\n  );\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n플러터 앱 라이프사이클을 이해하는 데 도움이 되는 이 포괄적인 안내서를 완료하신 것을 축하드립니다! 이 튜토리얼을 통해 플러터 앱 상태의 복잡성에 대한 소중한 통찰력을 얻으셨으며, 앱의 성능과 사용자 경험을 최적화할 수 있게 되었습니다. 요약하자면, ‘hidden,’ ‘inactive,’ ‘paused,’ ‘resumed,’ ‘suspending,’ 그리고 ‘detached’와 같은 다양한 앱 라이프사이클 상태에 대해 배우셨습니다. 이러한 상태 간의 앱 전환 시점을 파악함으로써 효율적인 리소스 관리를 구현하고 사용자 상호작용에 적절히 대응하는 능력을 키울 수 있습니다.\n\n이 예제의 전체 코드는 여기에서 확인하실 수 있습니다.\n\n즐거운 코딩 되세요!","ogImage":{"url":"/assets/img/2024-06-19-UnderstandingFlutterAppLifecycleAStep-by-StepGuide_0.png"},"coverImage":"/assets/img/2024-06-19-UnderstandingFlutterAppLifecycleAStep-by-StepGuide_0.png","tag":["Tech"],"readingTime":5},{"title":"플러터에서 ORM으로 Drift 사용하기","description":"","date":"2024-06-19 14:28","slug":"2024-06-19-UseDriftforORMinFlutter","content":"\n\n\u003cimg src=\"/assets/img/2024-06-19-UseDriftforORMinFlutter_0.png\" /\u003e\n\n# 1. 소개\n\nDrift은 Dart와 Flutter 애플리케이션용 강력한 데이터베이스 라이브러리입니다. 타입 안정한 SQL 쿼리, 데이터베이스의 검증 및 마이그레이션과 같은 고급 기능을 지원하기 위해, 컴파일 시간에 실행되는 빌더와 명령줄 도구를 사용합니다.\n\n아래 표를 마핑하기 위한 Dart 클래스를 생성할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nclass TodoItems extends Table {\n  IntColumn get id =\u003e integer().autoIncrement()();\n  TextColumn get title =\u003e text().withLength(min: 6, max: 32)();\n  TextColumn get content =\u003e text().named('body')();\n  IntColumn get category =\u003e integer().nullable()();\n}\n```\n\n하지만 저는 ORM 코딩을 생성하기 위해 SQL 문을 사용하는 것을 선호합니다 (나중에 보여드리겠습니다). 보통 테이블용 SQL을 먼저 생성하고, 그 SQL을 재사용해야 하기 때문에 괜찮을 거예요 🙂\n\n# 2. 사용법\n\n나중에 Drift에서 모델을 생성할 때 SQL 문을 사용하는 방법을 보여드리겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 2.1 필수 라이브러리 가져오기\n\nDrift는 sqlite3와 코드를 생성하는 Flutter 빌드 러너를 기반으로 하고 있기 때문에, pubspec.yaml 파일에 아래 종속성을 가져와야합니다:\n\n```yaml\ndependencies:\n  drift: ^2.16.0\n  sqlite3_flutter_libs: ^0.5.20\n  path_provider: ^2.1.2\n  path: ^1.9.0\n\ndev_dependencies:\n  drift_dev: ^2.16.0\n  build_runner: ^2.4.8\n```\n\n# 2.2 데이터베이스 클래스 생성하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어, 책 데이터베이스를 생성해야 한다면 아래의 book_database.dart 파일을 만들 수 있습니다.\n\n```dart\nimport 'dart:io';\n\nimport 'package:drift/drift.dart';\nimport 'package:path_provider/path_provider.dart';\nimport 'package:path/path.dart' as p;\nimport 'package:drift/native.dart';\n\npart 'book_database.g.dart'; // 이 파일은 생성 파일이며 기존 db 파일과 동일한 파일 이름을 사용해야 함\n\n@DriftDatabase(\n  include: {'book.drift'}, // 책 테이블을 만들기 위한 SQL 파일\n)\nclass BookDatabase extends _$BookDatabase {\n  BookDatabase() : super(_openConnection());\n\n  @override\n  int get schemaVersion =\u003e 1;\n}\n\nLazyDatabase _openConnection() {\n  return LazyDatabase(() async {\n    // 데이터베이스 파일인 db.sqlite을 여기 앱의 documents 폴더로 넣습니다.\n    final dbFolder = await getApplicationSupportDirectory();\n\n    // db 파일의 경로 설정\n    final file = File(p.join(dbFolder.path, 'book.db'));\n    return NativeDatabase.createInBackground(file);\n  });\n}\n```\n\n# 2.2 SQL 문장 파일 생성\n\nbook.drift 파일을 생성하여 테이블을 만드는 일반적인 SQL 문장을 입력하고, SQL에서 사용자 정의 메서드도 생성할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nCREATE TABLE IF NOT EXISTS \"book\" (\n            \"id\" INTEGER PRIMARY KEY NOT NULL UNIQUE,\n            \"viewCount\" INTEGER DEFAULT(NULL),\n            \"name\" VARCHAR(64) COLLATE NOCASE NOT NULL UNIQUE,\n            \"artist\" VARCHAR(64) COLLATE NOCASE NOT NULL,\n            \"folder\" VARCHAR(64) COLLATE NOCASE NOT NULL,\n            \"coverImg\" VARCHAR(64) COLLATE NOCASE NOT NULL\n);\nCREATE UNIQUE INDEX IF NOT EXISTS \"book_1\" ON book (id);\nCREATE UNIQUE INDEX IF NOT EXISTS \"book_2\" ON book (name);\n\nisBookExists: Select count(*) from book where name = :name Limit 1;\nfilterBooks: SELECT * FROM book WHERE $predicate;\ngetTop10: SELECT * FROM book ORDER BY viewCount DESC Limit 10;\n```\n\n여기서 간단한 book 테이블을 만들었고, id 및 name 열에 대한 인덱스를 생성했습니다. 한편, 3가지 사용자 정의 메서드도 만들었고, 이후에 사용 방법을 알려드리겠습니다.\n\n코드를 생성한 후 drift가 dart 코드로 DB 도우미 클래스에서 이러한 3가지 메서드를 자동으로 생성할 것입니다.\n\n# 2.3 데이터베이스 도우미 클래스 생성하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래 명령어를 실행하여 DB 헬퍼 클래스를 생성할 수 있습니다:\n\n```js\ndart run build_runner build\n```\n\n그 결과로 book_database.g.dart와 같은 하나의 파일이 더 생성될 것이고, 해당 파일 안에 사용자 정의 메서드도 찾을 수 있을 거예요. 물론, 이 동작 방식에 대해 걱정할 필요는 없습니다. 그냥 사용하면 됩니다!\n\n# 2.4 데이터베이스 헬퍼 사용하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 예시로 GetX 프레임워크를 사용할 것입니다.\n\nmain.dart 파일에 BookDatabase 클래스를 넣어주세요.\n\n```js\nGet.put(BookDatabase());\n```\n\n이제 우리는 어디서든 사용할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n//책 DB 도우미 가져오기\nfinal BookDatabase _bookDB = Get.find\u003cBookDatabase\u003e();\n\n...\n\n//DB에서 모든 책 아이템 가져오기\nvar dbBooks = await _bookDB.book.select().get();\n...\n//책 아이템의 folder 열만 업데이트하여 DB에 저장\n_bookDB.updateBookItem(\n  bookItem.id,\n  BookCompanion(\n      folder: drift.Value(bookItem.folder),\n  ),\n);\n...\n//책 아이템 일괄 삽입\nList\u003cBookData\u003e dbBooks = [];\ndbBooks.add(BookData(\n        id: 1,\n        viewCount: 0,\n        name: 'book 1',\n        artist: 'artist 1',\n        folder: 'assets/books/01/',\n        coverImg: 'assets/books/01/cover.jpg',));\ndbBooks.add(BookData(\n        id: 2,\n        viewCount: 0,\n        name: 'book 2',\n        artist: 'artist 2',\n        folder: 'assets/books/02/',\n        coverImg: 'assets/books/02/cover.jpg',));\n_bookDB.book.insertAll(dbBooks);e custom methods\n```\n\n예제에서는 SQL 문으로 3개의 메서드를 정의했습니다:\n\n```js\nisBookExists: Select count(*) from book where name = :name Limit 1 ;\nfilterBooks: SELECT * FROM book WHERE $predicate;\ngetTop10: SELECT * FROM book ORDER BY viewCount DESC Limit 10;\n```\n\n아래에서 이를 사용할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 도서 이름으로 책이 있는지 확인\nint bookCount = await _bookDB.isBookExists('bookName').getSingle();\n\n// 사용자 지정 필터로 책 가져오기\nvar bookItems = await _bookDB.filterBooks((book) =\u003e book.name.contains('bookName')).get();\n\n// 상위 10권의 책 가져오기\nvar topTenBooks = await _bookDB.getTop10().get();\n```\n\n# 3. 결론\n\nDrift는 데이터베이스를 관리하는 데 유용합니다. 데이터를 가져오기 위해 사용자 지정 메서드를 생성할 수 있으며 SQL 문을 사용하지 않고 Dart API를 사용할 수도 있습니다. 자세한 내용은 여기에서 확인할 수 있습니다. 여전히 오피서 웹사이트에서 많은 강력한 기능을 찾을 수 있습니다.\n\n이 글이 마음에 드셨다면 .Net Core, Angular 및 기타 기술에 관한 더 많은 이야기를 보려면 Medium에서 팔로우해주세요! 🙂\n","ogImage":{"url":"/assets/img/2024-06-19-UseDriftforORMinFlutter_0.png"},"coverImage":"/assets/img/2024-06-19-UseDriftforORMinFlutter_0.png","tag":["Tech"],"readingTime":6}],"page":"15","totalPageCount":21,"totalPageGroupCount":2,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"15"},"buildId":"Is-d56jDFXkc1ZfN4DhBP","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>