<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>uidev-css</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://uidev-css.github.io///posts/4" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="uidev-css" data-gatsby-head="true"/><meta property="og:title" content="uidev-css" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://uidev-css.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://uidev-css.github.io///posts/4" data-gatsby-head="true"/><meta name="twitter:title" content="uidev-css" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | uidev-css" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/873-1e1f6fb6fd3c8994.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-498da29379dd58dc.js" defer=""></script><script src="/_next/static/kPqZsTmJiF9vEOxaTPfEy/_buildManifest.js" defer=""></script><script src="/_next/static/kPqZsTmJiF9vEOxaTPfEy/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UIDEV CSS</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Flutter에서 폼과 유효성 검사 실용 가이드" href="/post/2024-06-21-FormsandValidationinFlutterAPracticalGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter에서 폼과 유효성 검사 실용 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-FormsandValidationinFlutterAPracticalGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter에서 폼과 유효성 검사 실용 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Flutter에서 폼과 유효성 검사 실용 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 21, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter에서 간단한 BottomAppBar 만들기" href="/post/2024-06-21-ASimpleBottomAppBarinFlutter"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter에서 간단한 BottomAppBar 만들기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-ASimpleBottomAppBarinFlutter_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter에서 간단한 BottomAppBar 만들기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Flutter에서 간단한 BottomAppBar 만들기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 21, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter 알림 마스터하기 awesome_notification 패키지 가이드 Part-I 단계별 가이드" href="/post/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter 알림 마스터하기 awesome_notification 패키지 가이드 Part-I 단계별 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter 알림 마스터하기 awesome_notification 패키지 가이드 Part-I 단계별 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Flutter 알림 마스터하기 awesome_notification 패키지 가이드 Part-I 단계별 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 21, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Dio 패키지를 사용하여 Flutter에서 REST API에 이미지 업로드하는 방법" href="/post/2024-06-21-UploadimagestoRESTAPIwithFlutterusingDioPackage"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Dio 패키지를 사용하여 Flutter에서 REST API에 이미지 업로드하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-UploadimagestoRESTAPIwithFlutterusingDioPackage_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Dio 패키지를 사용하여 Flutter에서 REST API에 이미지 업로드하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Dio 패키지를 사용하여 Flutter에서 REST API에 이미지 업로드하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 21, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter에서 ElevatedButton 모양 커스터마이징 하는 방법" href="/post/2024-06-21-HowtoCustomizetheShapeofanElevatedButtoninFlutter"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter에서 ElevatedButton 모양 커스터마이징 하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-HowtoCustomizetheShapeofanElevatedButtoninFlutter_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter에서 ElevatedButton 모양 커스터마이징 하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Flutter에서 ElevatedButton 모양 커스터마이징 하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 21, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter에서 노치가 있는 하단 내비게이션 바 만드는 방법" href="/post/2024-06-21-HowtocreateaNotchedBottomNavigationBarFlutter"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter에서 노치가 있는 하단 내비게이션 바 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-HowtocreateaNotchedBottomNavigationBarFlutter_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter에서 노치가 있는 하단 내비게이션 바 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Flutter에서 노치가 있는 하단 내비게이션 바 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 21, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="플러터에서 BloC 패턴으로 Fetch API 사용 방법" href="/post/2024-06-21-FetchAPIWithBloCinFlutter"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="플러터에서 BloC 패턴으로 Fetch API 사용 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-FetchAPIWithBloCinFlutter_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="플러터에서 BloC 패턴으로 Fetch API 사용 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">플러터에서 BloC 패턴으로 Fetch API 사용 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 21, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="플러터에서 네이티브 코드와의 양방향 통신을 위한 메소드 채널 사용 방법" href="/post/2024-06-21-MethodChannelinFlutterBridgingNativeCodeandFlutterwithTwo-WayCommunication"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="플러터에서 네이티브 코드와의 양방향 통신을 위한 메소드 채널 사용 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-MethodChannelinFlutterBridgingNativeCodeandFlutterwithTwo-WayCommunication_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="플러터에서 네이티브 코드와의 양방향 통신을 위한 메소드 채널 사용 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">플러터에서 네이티브 코드와의 양방향 통신을 위한 메소드 채널 사용 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 21, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter에서 백그라운드 서비스와 포어그라운드 서비스 사용 방법" href="/post/2024-06-21-BackgroundandForegroundservicesinFlutter"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter에서 백그라운드 서비스와 포어그라운드 서비스 사용 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-BackgroundandForegroundservicesinFlutter_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter에서 백그라운드 서비스와 포어그라운드 서비스 사용 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Flutter에서 백그라운드 서비스와 포어그라운드 서비스 사용 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 21, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter로 작성된 모바일 앱인지 확인하는 방법" href="/post/2024-06-21-HowtoDetermineifaMobileAppisWritteninFlutter"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter로 작성된 모바일 앱인지 확인하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-HowtoDetermineifaMobileAppisWritteninFlutter_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter로 작성된 모바일 앱인지 확인하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Flutter로 작성된 모바일 앱인지 확인하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 21, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link posts_-active__YVJEi" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Flutter에서 폼과 유효성 검사 실용 가이드","description":"","date":"2024-06-21 22:50","slug":"2024-06-21-FormsandValidationinFlutterAPracticalGuide","content":"\n\n모바일 폼은 스마트폰, 태블릿 등의 모바일 장치로 접근할 수 있는 전자 버전의 종이 양식입니다.\n\n현재의 대부분의 모바일 및 웹 애플리케이션은 양식을 어떤 형태로든 사용합니다. 주로 사용자가 앱과 소통하고 정보를 제공할 수 있는 방법으로 기능합니다. 비즈니스 요구 사항 및 논리의 성격에 따라 다양한 기능을 수행할 수 있습니다. 일반적으로 다음과 같은 일반적인 기능이 포함됩니다:\n\n1. 사용자 인증\n\n2. 사용자 추가\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. 검색\n\n4. 필터링\n\n5. 정렬\n\n6. 예약\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n양식에 포함될 수 있는 요소로는 다음과 같은 것들이 있을 수 있습니다:\n\n1. 텍스트 필드\n\n2. 버튼\n\n3. 체크박스\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n4. 라디오 버튼\n\n디지턈 양식의 장점은 다음과 같이 언급됩니다:\n\n1. 정보의 이동성이 크다.\n\n2. 기민성이 향상된다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. 높은 정밀도\n\n4. 더 뛰어난 응답 능력\n\n5. 더 빠른 콘텐츠 수정\n\n# 폼 관리의 중요성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n양식 관리는 데이터 수집과 결정을 위해 양식을 생성, 보급, 완료, 평가하고 자동화하는 프로세스를 의미합니다.\n\n양식은 옛날에는 물리적인 물건이었지만, 많은 기업들이 종이 양식 대신 전자 문서를 사용하도록 전환했습니다. 자동화는 기존에 인간이 처리하던 작업을 기술을 사용하여 처리하는 것을 의미하며, 양식 관리도 그 예외가 아닙니다.\n\n# 양식\n\n종이 양식의 온라인 버전인 디지털 양식은 조직 내에서 빠르게 흘러가는 데이터를 캡처하는 데 사용됩니다. 기업이 데이터를 정확하게 기록하고 작업을 시작하는 주요 방법으로 종이 양식을 빠르게 대체하고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n디지턈 폼으로 전환함으로써 놀라운 많은 이점이 있습니다. 실시간 위치 공유, 이미지 촬영 및 추가, 신속한 계산 수행, 시간 추적 및 바코드 스캔 등 다양한 기능을 제공합니다.\n\n디지턈 폼을 사용하면 데이터의 구성이 간단합니다. 위치, 신원, 주소 또는 기타 중요 정보와 같은 데이터를 수집하고 구성할 수 있습니다. 모든 데이터가 한 곳에서 처리 및 저장되기 때문에 사용자는 언제든지 어디서든 데이터에 액세스할 수 있습니다.\n\n폼을 디지턈화함으로써 수집된 모든 정보를 신속하고 효과적으로 체계적으로 보관할 수 있습니다. 이러한 조정은 비즈니스가 시간과 비용을 절약하며 일상적인 작업 생산성과 효율성을 향상시킬 수 있도록 도와줄 것입니다.\n\n# Flutter forms\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n요즘에는 모바일 애플리케이션이나 웹 애플리케이션에서 양식이 필수적인 구성 요소입니다. 사용자 정보는 양식을 사용하여 수집됩니다. 플러터는 양식 위젯을 제공하여 양식을 개발할 수 있습니다. 이 양식 위젯의 컨테이너 기능을 사용하여 여러 양식 필드를 그룹화할 수 있습니다. 양식을 생성할 때 고유하게 식별할 수 있도록 GlobalKey가 필요하며 양식 필드를 유효성 검사할 수 있습니다.\n\n사용자가 텍스트를 입력할 수 있도록 하려면 양식 위젯이 자식 위젯인 TextFormField를 사용합니다. 이 위젯은 머티리얼 디자인의 텍스트 필드를 제공하며 발생하는 유효성 검사 문제를 보여줄 수 있습니다.\n\n사용자는 앱에서 자주 텍스트 필드에 데이터를 입력해야 합니다. 예를 들어, 이메일 주소와 비밀번호를 사용하여 사용자가 로그인해야 할 수도 있습니다. 애플리케이션을 안전하고 사용하기 쉽도록 만들기 위해 제공된 정보의 유효성을 확인하십시오. 사용자가 양식을 올바르게 작성했을 경우 데이터를 처리하십시오. 잘못된 정보를 제출할 경우 사용자에게 문제를 알리는 유용한 오류 메시지를 표시하십시오.\n\n# 양식 유효성 검사\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n특정 기준을 수정하거나 확인할 수 있는 기술을 검증이라고 합니다. 데이터 입력의 신뢰성을 보장합니다. 양식 유효성 검사는 모든 디지털 거래에서의 표준 절차입니다. Flutter에서 양식을 유효성 검사하는 데 필요한 세 가지 단계를 구현해야 합니다.\n\n1. Form 위젯과 함께 전역 키를 사용합니다.\n   \n2. TextFormField를 사용하여 입력 필드에 validator 속성을 제공합니다.\n   \n3. 양식 필드를 확인하고 오류를 표시할 버튼을 만듭니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 양식 생성\n\n다음 단계를 따라 양식을 만들어보세요:\n\n## GlobalKey가 포함된 양식 만들기\n\n먼저 Form을 만들어보세요. Form 위젯을 사용하여 여러 양식 필드를 모아 유효성을 검사할 수 있습니다. 양식을 만들 때 GlobalKey를 지정해 주세요. 이를 통해 양식 유효성을 확인하고 양식을 고유하게 식별할 수 있게 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 유효성 검사 로직이 추가된 TextFormField를 추가해야 합니다\n\n양식은 있지만 사용자가 사용할 수 있는 텍스트 입력 필드가 없습니다. TextFormField의 역할은 이를 수행하는 것입니다. TextFormField 위젯은 텍스트 필드를 재료 디자인으로 표시하고 유효성 검사 문제를 표시할 수 있습니다. TextFormField에 입력을 확인하는 validator() 함수를 제공하세요. validator 메서드는 사용자의 입력이 잘못된 경우 오류 메시지가 포함된 문자열을 반환합니다. 오류가 없는 경우 validator는 null을 반환해야 합니다.\n\n# 양식을 유효성 검사하고 제출하기 위해 버튼 만들기\n\n양식에 텍스트 필드가 있는지 확인한 후 사용자가 정보를 제출할 수 있는 버튼을 제공하세요. 사용자가 제출하려고 할 때 양식의 유효성을 검사하세요. 유효한 경우 성공 메시지를 표시하세요. 텍스트 필드가 비어 있다면 오류 메시지를 표시하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 단일 필드 폼을 위한 코드\n\n단일 필드 플러터 폼을 만들려면 Flutter를 열고 새 프로젝트를 만든 다음 다음 코드를 사용하십시오 [2]:\n\n```js\nimport 'package:flutter/material.dart';\n\nvoid main() =\u003e runApp(const MyApp());\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    const appTitle = '테스트 폼';\n\n    return MaterialApp(\n      title: appTitle,\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text(appTitle),\n        ),\n        body: const MyCustomForm(),\n      ),\n    );\n  }\n}\n\n// 폼 위젯을 만듭니다.\nclass MyCustomForm extends StatefulWidget {\n  const MyCustomForm({super.key});\n\n  @override\n  MyCustomFormState createState() {\n    return MyCustomFormState();\n  }\n}\n\n// 해당 State 클래스를 만듭니다.\n// 이 클래스는 폼과 관련된 데이터를 보유합니다.\nclass MyCustomFormState extends State\u003cMyCustomForm\u003e {\n  // 폼 위젯을 고유하게 식별하는 전역 키를 만들어 폼의 유효성을 검사할 수 있게 합니다.\n  //\n  // 참고: 이것은 GlobalKey\u003cFormState\u003e이며\n  // GlobalKey\u003cMyCustomFormState\u003e가 아닙니다.\n  final _formKey = GlobalKey\u003cFormState\u003e();\n\n  @override\n  Widget build(BuildContext context) {\n    // 위에서 만든 _formKey를 사용하여 폼 위젯을 빌드합니다.\n    return Form(\n      key: _formKey,\n      child: Column(\n        crossAxisAlignment: CrossAxisAlignment.start,\n        children: [\n          TextFormField(\n            // validator는 사용자가 입력한 텍스트를 받습니다.\n            validator: (value) {\n              if (value == null || value.isEmpty) {\n                return '텍스트를 입력해주세요';\n              }\n              return null;\n            },\n          ),\n          Padding(\n            padding: const EdgeInsets.symmetric(vertical: 16),\n            child: ElevatedButton(\n              onPressed: () {\n                // 폼이 유효하면 true를 반환하고 그렇지 않으면 false를 반환합니다.\n                if (_formKey.currentState!.validate()) {\n                  // 폼이 유효하면 스낵바를 표시합니다. 실제로는\n                  // 서버를 호출하거나 정보를 데이터베이스에 저장하는 경우가 많습니다.\n                  ScaffoldMessenger.of(context).showSnackBar(\n                    const SnackBar(content: Text('데이터 처리 중')),\n                  );\n                }\n              },\n              child: const Text('제출'),\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n결과:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-21-FormsandValidationinFlutterAPracticalGuide_0.png)\n\n# 설명\n\n스텝 1에서 생성된 _formKey를 활용하여 폼을 검증하세요. Form을 생성할 때 자동으로 생성되는 FormState에 접근하려면 _formKey.currentState() 메서드를 사용하세요. validate() 메서드는 FormState 클래스의 일부입니다. 폼의 각 텍스트 필드는 validate() 메서드가 호출될 때 validator() 함수를 가지며, 모두 정상인 경우 true를 반환합니다. validate() 함수는 어떠한 오류 경고도 표시하고, 텍스트 필드 중에 오류가 있는 경우 false를 반환합니다.\n\n[인터랙티브 예시2](링크)에서 코드를 작성하고 온라인에서 테스트할 수 있으며, 결과를 즉시 확인할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 비동기 유효성 검사\n\n폼에서 필드를 유효성 검사하려면 백엔드 서비스를 활용해 정보를 찾는 것이 종종 도움이 됩니다. 로그인 및 비밀번호를 데이터베이스에서 유효성을 검사하는 것이 전형적인 예입니다. 플러터의 비동기 폼 유효성 검사 기능은 사용자 인터페이스가 제대로 나오지 않을 수 있기 때문에 개발자가 동기식과 비동기식 유효성 검사기를 부적절하게 조합하거나 문제를 식별하기 어려울 수 있습니다. 따라서 플러터 팀은 비동기 유효성 검사 지원을 제공하지 않습니다. 그러나 이 문제에 대한 해결책이 있습니다[3]. 이 문제를 다음과 같은 세 가지 부분으로 나눌 수 있습니다:\n\n1. 먼저 비동기 호출 결과의 성공 또는 실패를 추적하는 로컬 부울을 생성하세요. 그런 다음, 이를 동기식 유효성 검사에 포함하여 실패 상태를 설명하는 비동기 유효성 검사 메시지(예: \"잘못된 사용자 이름\")를 생성합니다.\n\n2. 폼을 제출하고 동기식 유효성 검사를 통과한 후 백엔드로 비동기 호출을 하는 등의 비동기 호출을 수행하세요. 비동기 호출의 결과가 완료되면 로컬 부울을 해당 호출의 성공 또는 실패로 설정한 후 SetState()를 호출합니다. 그런 다음, 폼이 다시 그려집니다. 그러나 비동기 유효성 검사는 다시 시작되지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. build() 메서드를 호출하여 명시적으로 async validator를 다시 실행합니다. Form이 재생성되기 전에 async validator가 다시 실행됩니다. Async validator 결과 (있는 경우)는 Form이 재구성을 마치면 예상대로 Form에 표시됩니다.\n\n# 참고 자료:\n\n[1] https://www.javatpoint.com/flutter-forms\n\n[2] https://docs.flutter.dev/cookbook/forms/validation\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n[3]https://medium.com/@nocnoc/the-secret-to-async-validation-on-flutter-forms-4b273c667c03#:~:text=Once%20the%20sync%20validator%20passes,the%20correct%20user%2Fpass%20combination.","ogImage":{"url":"/assets/img/2024-06-21-FormsandValidationinFlutterAPracticalGuide_0.png"},"coverImage":"/assets/img/2024-06-21-FormsandValidationinFlutterAPracticalGuide_0.png","tag":["Tech"],"readingTime":7},{"title":"Flutter에서 간단한 BottomAppBar 만들기","description":"","date":"2024-06-21 22:49","slug":"2024-06-21-ASimpleBottomAppBarinFlutter","content":"\n\n현재 작업 중인 프로젝트에서 — 곧 공유할 예정이에요, BottomNavigationBar를 포함해야 했어요. 하지만 단순한 하단 네비게이션 바가 아니라, 약간은 멋지고 세련된 모습으로 구현하고 싶었어요.\n\n![BottomNavigationBar](/assets/img/2024-06-21-ASimpleBottomAppBarinFlutter_0.png)\n\nBottomNavigationBar는 하단에 작은 위젯들(아이콘 또는 레이블)을 나란히 표시할 수 있는 위젯이에요. 이를 통해 한 번에 하나의 항목을 선택하고 해당 페이지/UI로 빠르게 이동할 수 있어요. 하단 네비게이션 바에는 2~5개의 항목을 넣는 것이 권장되고요. 그 이상의 경우에는 네비게이션 드로어나 탭을 사용하는 것이 더 좋아요.\n\n구현\nFlutter에서 하단 네비게이션 바를 사용하려면 build 메서드가 Scaffold 위젯을 반환해야 해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\nclass _MyHomePageState extends State\u003cMyHomePage\u003e {\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Bottom Navigation Bar'),\n        centerTitle: true,\n      ),\n      body: const Center(),\n    );\n  }\n}\n```\n\nScaffold 위젯에는 bottomNavigationBar 속성이 있으며, 이를 통해 BottomAppBar 위젯을 추가할 수 있습니다. 나는 내 탐색 바에 '노치'를 추가하고 싶었기 때문에 BottomAppBar를 사용하고 있습니다 — 그래서 \"조금 멋지고 멋있어 보이게\"하고 있는 것이죠.\n\nBottomAppBar에는 다음과 같은 속성들을 사용하고 싶었어요:\n\n- shape — 탐색 바에 노치를 추가하여 겹치는 FAB(Floating Action Button)에 공간을 만듦\n- notchMargin — 탐색 바 노치와 FAB 사이의 여백\n- clipBehavior — 설정 옵션에 따라 내용이 클리핑되는지 여부를 지정합니다\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nbottomNavigationBar: BottomAppBar(\n  shape: const CircularNotchedRectangle(),\n  notchMargin: 5.0,\n  clipBehavior: Clip.antiAlias,\n  child: SizedBox(\n    height: kBottomNavigationBarHeight,\n    child: Row(\n      mainAxisSize: MainAxisSize.max,\n      mainAxisAlignment: MainAxisAlignment.spaceAround,\n      children: \u003cWidget\u003e[\n        IconButton(\n          icon: const Icon(Icons.home),\n          onPressed: () {\n            setState(() {\n            });\n          },\n        ),\n        IconButton(\n          icon: const Icon(Icons.search),\n          onPressed: () {\n            setState(() {\n            });\n          },\n        ),\n        IconButton(\n          icon: const Icon(Icons.favorite_border_outlined),\n          onPressed: () {\n            setState(() {\n            });\n          },\n        ),\n        IconButton(\n          icon: const Icon(Icons.account_circle_outlined),\n          onPressed: () {\n            setState(() {\n            });\n          },\n        )\n      ],\n    ),\n  ),\n),\n```\n\n![스크린샷](/assets/img/2024-06-21-ASimpleBottomAppBarinFlutter_1.png)\n\n이제 BottomAppBar 속성을 사용하기 위해 FAB를 추가할 때 centerDocked 속성을 사용해야 합니다.\n\n```js\nfloatingActionButtonLocation: FloatingActionButtonLocation.centerDocked,\nfloatingActionButton: FloatingActionButton(\n  onPressed: () {},\n  child: const Icon(Icons.add),\n),\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![BottomAppBar](/assets/img/2024-06-21-ASimpleBottomAppBarinFlutter_2.png)\n\n그래서 우리는 이제 '다른' ​​디자인의 하단 네비게이션 바를 얻을 수 있게 되었습니다.\n\n그러나 구현이 간단해 보이더라도, 실제로 작동하게 만드는 데 꽤 고생했습니다. 먼저 BottomAppBar에는 currentIndex 속성이 없어서 어떤 아이콘이 선택되었는지 알아야 페이지를 이동할 수 없습니다. 또한 selectedItemColor와 unselectedItemColor 속성도 없어서 해당 화면으로 이동될 때 아이콘 색상을 전환할 수 없습니다.\n\n그래서 BottomAppBar의 자식으로 BottomNavigationBar를 사용해야 합니다. 또한 페이지 간 전환을 허용하기 위해 pageController를 사용할 것입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\nbottomNavigationBar: BottomAppBar(\n  shape: const CircularNotchedRectangle(),\n  notchMargin: 5.0,\n  clipBehavior: Clip.antiAlias,\n  child: SizedBox(\n    height: kBottomNavigationBarHeight,\n    child: BottomNavigationBar(\n      type: BottomNavigationBarType.fixed,\n      backgroundColor: Colors.green,\n      currentIndex: _selectedIndex,\n      selectedItemColor: Colors.white,\n      unselectedItemColor: Colors.black,\n      onTap: (index) {\n        setState(() {\n          _selectedIndex = index;\n          pageController.jumpToPage(index);\n        });\n      },\n      items: const [\n        BottomNavigationBarItem(\n          icon: Icon(Icons.home_outlined),\n          label: '',\n        ),\n        BottomNavigationBarItem(\n          icon: Icon(Icons.search),\n          label: '',\n        ),\n        BottomNavigationBarItem(\n          icon: Icon(Icons.favorite_border_outlined),\n          label: '',\n        ),\n        BottomNavigationBarItem(\n          icon: Icon(Icons.account_circle_outlined),\n          label: '',\n        ),\n      ],\n    ),\n  ),\n),\nbody: PageView(\n  controller: pageController,\n  children: const \u003cWidget\u003e[\n    Center(\n      child: Home(),\n    ),\n    Center(\n      child: Search(),\n    ),\n    Center(\n      child: Favourite(),\n    ),\n    Center(\n      child: Profile(),\n    ),\n  ],\n),\n```\n\n![Here is the full code:](https://miro.medium.com/v2/resize:fit:1200/1*1LiVHOIR0xdH2Kzg3FdygQ.gif)\n\nLet me know how I can improve on this implementation (e.g., the spacing of the icons next to the notch could be better when there are four navigation items. It looks okay when it’s just two items.)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n읽어 주셔서 감사합니다 ❤","ogImage":{"url":"/assets/img/2024-06-21-ASimpleBottomAppBarinFlutter_0.png"},"coverImage":"/assets/img/2024-06-21-ASimpleBottomAppBarinFlutter_0.png","tag":["Tech"],"readingTime":5},{"title":"Flutter 알림 마스터하기 awesome_notification 패키지 가이드 Part-I 단계별 가이드","description":"","date":"2024-06-21 22:46","slug":"2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide","content":"\n\n- Flutter 앱에서 원활하고 강력하며 사용자 친화적인 알림 경험을 위해 awesome_notification의 모든 기능을 활용해보세요.\n\n![이미지](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_0.png)\n\nFlutter에서 push 알림의 힘을 활용하는 것은 사용자 참여도와 유지율 향상에 중요합니다. 이러한 동적 알림은 사용자에게 실시간 업데이트 및 맞춤화된 상호작용을 제공하여 더 입체적이고 빠른 앱 경험을 조성합니다. 시각적으로 매력적이고 기능이 풍부한 알림을 만들 수 있는 awesome_notifications은 Flutter 개발자들이 사용자를 매혹시키고 앱이 계속해서 주목받을 수 있도록 돕습니다. 오늘날의 경쟁적인 모바일 환경에서 성공을 위한 키패드인 push 알림으로 앱의 커뮤니케이션 전략을 높여보세요.\n\n이 튜토리얼을 위한 프로젝트 구조를 시작해봅시다. 이 이미지에서 기본 구조를 확인할 수 있습니다: -\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_1.png)\n\n홈 페이지와 제품 상세 페이지 두 개의 페이지를 만들었습니다.\n\nFlutter에서 멋진 푸시 알림의 세계로 여정을 시작하기 위해, 우리의 Flutter 앱이 사용자에게 멋진과 동적인 알림을 만드는 데 필요한 도구를 갖추도록 보장하는 필수 종속성을 pubspec.yaml 파일에 추가하는 것으로 시작해봅시다.\n\npubspec.yaml 파일을 열고 다음 라인을 추가해주세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래 이미지는 Flutter에 최신 버전의 awesome_notifications 및 http 패키지를 가져와 통합하라고 알려줍니다.\n\nawesome_notifications 패키지는 매력적이고 기능이 풍부한 알림을 만들기 위한 해결책으로 사용되고, http 패키지는 알림 워크플로에 필요한 모든 HTTP 요청을 용이하게 처리할 것입니다.\n\n터미널에서 flutter pub get을 실행하여 이러한 종속성을 가져오고 설치하는 것을 기억하세요.\n\n기본 작업이 완료되었으므로, 이제 awesome_notifications 패키지가 제공하는 끝없는 가능성을 탐험할 준비가 되었습니다. 즉각적인 알림, 예약된 경고 및 더 많은 기능을 만들어보자!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리의 플러터 프로젝트의 핵심은 main.dart 파일에 있습니다. 이 파일은 우리 멋진 알림 시스템의 초기화를 조정하는 진입점입니다. 즐거운 알림 경험을 위한 무척 중요한 코드 조각을 살펴보겠습니다.\n\nmain.dart에는 클래스 구성 메서드를 호출하고 라우트 생성기 클래스를 생성하여 material 앱 섹션에 할당하는 내용이 담겨 있습니다.\n\nmain.dart\n\n![이미지](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nRouteGenerator.dart\n\n이 클래스에 뷰 파일을 추가하고 네비게이션에 연결하세요.\n\n\u003cimg src=\"/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_4.png\" /\u003e\n\n애플리케이션 알림 유틸리티 클래스의 중요한 부분은 이 클래스에 있습니다. 사용자에게 멋진 알림을 제공하기 위해 몇 가지 속성과 메서드를 만들었으니 알림 유틸리티를 시작해보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nnotification configuration 코드를 시작하기 전에, 이미지를 통해 멋진 notification 패키지에 의해 제공되는 매개변수를 확인할 수 있고, 이러한 매개변수를 사용하여 push notification을 탐색해보세요. 첫 번째 이미지에서는 단순한 notification만 볼 수 있고, 다른 이미지에서는 사용자 지정 버튼이 있는 notification을 볼 수 있습니다.\n\n\n![First Image](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_5.png)\n\n![Second Image](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_6.png)\n\n\nNotification_utils.dart\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_7.png)\n\n이제 사용자에게 알림 권한을 확인합니다. 이미 권한이 허용되어 있으면 네 개의 상자를 보여주는 홈 화면 UI가 표시됩니다. 권한이 허용되었는지 아닌지 확인하는 코드를 추가했습니다. 매우 간단한 내용이니 이 코드를 따라해보세요:-\n\n![이미지](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_8.png)\n\n코드와 주요 기능을 사용한 멋진 알림 패키지를 확인해봅시다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n🚨 주요 기능:\n\n1️⃣ 즉시 알림: 몇 줄의 코드로 손쉽게 즉시 알림을 생성하고 표시할 수 있어요! ⚡️\n\n2️⃣ 예약 알림: 특정 시간에 전달될 알림을 예약해서 미리 계획하세요. 📅⏰\n\n3️⃣ JSON 데이터 알림: JSON 데이터를 활용하여 동적으로 알림을 사용자 정의해보세요. 🧩📤\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n4️⃣ 사용자 정의 버튼 알림: 사용자 상호작용을 더욱 향상시키기 위해 알림 내에 사용자 정의 버튼을 통합하세요. 🎛️📲\n\n- . 즉시 알림: 몇 줄의 코드로 쉽게 즉시 알림을 생성하고 표시할 수 있습니다! ⚡️\n\n![Screenshot](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_9.png)\n\n2). 예약 알림: 알림을 특정 시간에 전달할 수 있도록 예약함으로써 미리 계획하세요. 📅⏰, 이 코드에서는 이 메소드를 호출한 후 1분 후에 알림이 도착하도록 예약 설정을 합니다. 이 기능을 이용하여 사용자에게 정기적으로 업데이트를 알리는 리마인더 또는 전자상거래 프로젝트나 피트니스 앱에서 일정 시간에 사용자에게 알리기 위해 사용할 수 있습니다. 예약된 알림을 다룰 때에는 안드로이드 manifest 파일에서 권한을 몇 가지 추가할 수 있습니다. 아래 이미지에서 해당 권한을 확인할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지 1](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_10.png)\n\n![이미지 2](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_11.png)\n\n3). JSON 데이터 통지: JSON 데이터를 활용하여 알림을 동적으로 사용자 정의하세요. 🧩📤 메서드 호출 시 jsonData를 전달할 수 있습니다. 자세한 내용은 홈페이지에서 확인해주세요. 그러면 메서드가 어떻게 작동하는지 쉽게 이해하고 확인할 수 있습니다.\n\n![이미지 3](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_12.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n4). 사용자 상호작용을 더욱 향상시키기 위해 맞춤 버튼을 알림에 포함하여 사용하세요. 🎛️📲\n\n지금부터 제가 최고로 선호하는 주요 기능은 더 나은 사용자 경험을 위한 것입니다. 이 멋진 알림이 도착했을 때 맞춤 버튼을 추가하여 필요에 따라 더 많은 사용자 경험을 제공할 수 있습니다. 사용자의 이동 부분에 대해 알아보시죠. 한 예를 통해 이해해보겠습니다. 전자 상거래 프로젝트를 작업 중이라고 가정해보세요. 두 개의 버튼 중 하나는 \"지금 구매\"이고 다른 하나는 \"장바구니에 추가\"입니다. 이 경우 사용자가 \"지금 구매\" 버튼을 클릭하면 사용자가 체크 아웃 화면 또는 페이지로 이동할 것이고, \"장바구니에 추가\"를 클릭하면 제품이 장바구니에 추가되고 사용자는 장바구니 화면으로 이동하게 됩니다. 이것이 기본 설명입니다. 이제 코드로 돌아가 봅시다. 여기 createCustomNotificationWithActionButtons() 메서드명이 있습니다.\n\n![이미지](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_13.png)\n\n이제 거의 모든 코드 작업을 마쳤습니다. 성공적으로 알림이 생성되거나 화면에 도착한 후 알림을 탭하면 사용자로 이동하게 만들어야 합니다. 그래서 이 코드를 추가했습니다. 위 코드를 따라해 주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nonActionRecivedMethod은 사용자를 새 페이지로 리디렉션하거나 유효한 컨텍스트를 사용해야 할 때에만 필요합니다. 병렬 격리본은 유효한 컨텍스트를 갖고 있지 않기 때문에, 실행을 주 격리본으로 리디렉션해야 합니다.\n\n\n![Image](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_14.png)\n\n\nonActionRecivdeImplementationMethod은 사용자를 탐색할 때 실행될 것이므로, 이 방법을 사용하면 사용자에게 특정 페이지의 뷰나 화면을 정의할 수 있습니다. 또한, 사용자가 커스텀 버튼을 클릭하는 동안 사용자를 탐색할 수도 있으므로, 커스텀 버튼과 함께 알림을 생성할 때 키와 레이블을 전달하면 됩니다. 키를 사용하여 버튼을 클릭했을 때 페이지를 리디렉션할 조건이나 구성을 설정할 수 있으므로, 이 코드를 추가합니다. 아래 코드를 확인할 수 있습니다.\n\n\n![Image](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_15.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 우리는 onActionRecivedMethod, onNotificationCreatedMethod, onNotificationDisplayedMethod, onDismissActionReceivedMethod과 같은 멋진 알림 패키지에서 제공하는 이벤트를 수신하는 리스너를 설정했습니다. 이 메서드들을 사용하여 알림의 생성, 표시 및 해제를 감지할 수 있습니다. initState()에서 Homeview에서 startListeningNotificationEvents 메서드를 호출합니다.\n\n![image](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_16.png)\n\n이제 알림에 대한 논리 부분을 생성하고 추가했습니다. 이제 UI 부분으로 이동하여 사용자 인터페이스에서 화면을 만들겠습니다. 홈 화면과 제품 세부 정보 화면을 추가했습니다. 홈 페이지에는 아래와 같이 4개의 상자가 있는 GridView를 만듭니다.\n\n![image](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_17.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nHome_view.dart에 대한 설명입니다.\n\nBuild 메소드 내에서 제목을 구현하고, notificationType에 알림 유형 서브 위젯을 추가합니다. GridView.extent를 사용하여 4가지 상자를 만들고 각각의 탭 기능에는 Gesture Detector 위젯을 사용하며, 탭할 때 해당하는 알림 클래스 메소드를 호출합니다.\n\n![이미지](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_18.png)\n\n첫 번째 상자에서 사용자가 즉시 통지를 탭하면 즉시 로컬 통지가 전송되며, 기기에 통지가 표시되고, 동시에 리디렉션도 수행됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n첫 번째 상자는 인스턴트 알림 생성을 통해 사용자가 상자를 탭할 때 utils 클래스의 createInstantNotification 메서드가 호출되고 알림이 전송됩니다.\n\n두 번째 상자는 일정된 알림을 가지고 있습니다. 이는 스케줄 알림 기능을 사용하여 트리거된 알림을 설정하는 것을 의미합니다. 이러한 기능은 전자 상거래 앱, 피트니스 앱, 리마인더 앱 등 다양한 애플리케이션에서 주로 볼 수 있습니다.\n\n따라서 상자 안에서 사용자가 탭하면 notification_utils 클래스의 createScheduleNotification 메서드를 호출합니다. 이 코드에서는 탭한 후 1분 동안의 시간이 경과한 후에 알림이 표시되며, 필요에 맞게 사용자 정의할 수 있습니다.\n\n![이미지](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_19.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n세 번째 상자에는 JSON 객체로 알림을 생성하고 API나 JSON 응답에 따라 사용자 정의하거나 동적으로 만들 수 있습니다. 이를 위해 호출 jsonDataNotification 메소드가 호출될 때 매개변수를 JSON 객체 형식으로 전달할 수 있습니다.\n\n![이미지](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_20.png)\n\n마지막으로 가장 좋아하는 기능 중 하나는 사용자 정의 버튼 알림입니다.\n\n네 번째 상자에서 상자를 탭하면 알림 클래스에서 createCustomNotificationWithActionButtons가 호출되고 이 메서드에서 actionButtons를 추가하여 사용자에게 표시합니다. actionButton에서 위젯 목록을 제공하고 버튼에 대한 키와 레이블을 잊지 마세요. 키를 사용하여 버튼KeyInput을 식별하고 동작을 수행하고 레이블은 단순 표시 용도입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_21](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_21.png)\n\n이 화면의 제품 상세 페이지 UI는 단지 제품 데이터와 수량, 제품 크기, 그리고 제품 가격을 보여줍니다.\n\n![2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_22](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_22.png)\n\n어서요, 기다리던 것이 끝났습니다. 리다이렉션을 통해 멋진 알림 패키지를 성공적으로 구현했습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![image](https://miro.medium.com/v2/resize:fit:600/1*KBn0C6MmIzCdSEM_1xZrfQ.gif)\n\n플러터 개발의 복잡한 태피스트리 속에서 우리의 awesome_notifications 탐험은 혁신과 무한한 잠재력으로 가득한 여정이었습니다. 즉시 알림부터 예약된 통지 및 JSON 데이터의 동적 매력까지, 우리는 플러터 앱을 참여의 전도사로 변화시킬 수 있는 도구들을 발견했습니다.\n\n이 기사가 가이드 역할을 해 준 것으로서 부디 당신이 푸시 알림을 통해 몰입형 사용자 경험을 만들어가는 길을 밝혀 주었기를 바랍니다. 이 놀라운 논의를 마무리하면서 새롭게 얻은 지식이 얼마나 매료시키고 당신의 플러터 프로젝트가 디지털 환경에서 빛날 수 있는지 곰곰히 생각해 보시기 바랍니다.\n\nawesome_notifications 패키지 내부 동작을 더 깊이 파고들고 싶은 분들을 위해 GitHub의 포괄적인 코드베이스를 살펴보시기를 초대합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGitHub 저장소\n\n저와 함께하시면 플러터 개발 세계에서 계속되는 토론, 통찰, 그리고 미래 탐구를 경험할 수 있습니다:\n\nLinkedIn 프로필\n\n이 여정에 투자해 주신 여러분께 감사드립니다. 여러분의 플러터 노력이 혁신적이고 원활한 기능성을 갖추며, 사용자들로부터 진정으로 중요한 알림을 받을 수 있기를 바라겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플러터 우수성을 위한 이 여정에 참여해 주셔서 감사합니다. 다음 탐험 때까지 즐거운 코딩하세요! 알림이 항상 멋지고 효과적하기를 바라요! 🚀📲","ogImage":{"url":"/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_0.png"},"coverImage":"/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_0.png","tag":["Tech"],"readingTime":10},{"title":"Dio 패키지를 사용하여 Flutter에서 REST API에 이미지 업로드하는 방법","description":"","date":"2024-06-21 22:44","slug":"2024-06-21-UploadimagestoRESTAPIwithFlutterusingDioPackage","content":"\n\n플러터 개발자들로부터 받은 엄청난 반응 뒤에 http 패키지를 사용하여 REST API에 이미지를 업로드하는 방법에 대한 이야기를 공유한 후, 많은 사람들이 dio 패키지를 사용하여 그렇게 하는 데 어려움을 겪는 것을 보았습니다. 초보자들은 일반적으로 사용할 수 있는 코드 스니펫을 찾을 수 있는 자세하고 쉽게 배울 수 있는 자료를 원합니다.   \n이 이야기에서는 flutter에서 이미지를 업로드하는 방법에 대해 dio 패키지를 사용하여 작성하겠습니다. 가능한 모든 측면에 대해 설명하기 위해 최선을 다하겠지만, 빠진 부분이 있다고 생각하거나 의겢가 있으면 의겢를 남겨주시고 학습 과정에서 도와주십시오.  \n\n우선 dio 패키지를 앱에 추가하는 방법부터 시작해봅시다.  \n\nDio는 다트를위한 강력한 HTTP 클라이언트로서 내 flutter 앱에서 서버에 연결하는 동안 응답의 직렬화 및 역직렬화와 같은 여러 측면에서 도움이 됩니다.   \n\n프로젝트 디렉토리 터미널에서 다음 명령을 실행합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\n $ dart pub add dio\n```\n\n기기 갤러리나 카메라에서 이미지를 가져 오기 위해 Image Picker 패키지를 사용했어요.\n\n프로젝트 디렉토리 터미널에서 다음 명령어를 실행해주세요:\n\n```dart\n$ flutter pub add image_picker\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기 갤러리에서 이미지를 가져 오는 코드입니다.\n\n```js\nFuture\u003cFile\u003e getImage() async {\n  final ImagePicker _picker = ImagePicker();\n  // 이미지 선택\n  final XFile? image = await _picker.pickImage(source: ImageSource.gallery);\n  // XFile을 파일로 변환\n  File file = File(image!.path);\n  // print(‘이미지 선택됨');\n  return file;\n}\n```\n\n이제 갤러리에서 이미지를 선택했습니다. 다음은 MultipartRequest를 수행 할 dart 파일에서 dio 패키지를 가져 오는 방법입니다.\n\n```js\nimport 'package:dio/dio.dart';\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그럼 REST API에 전송할 이미지를 포함하는 fromMap이라는 이름의 이름이 지정된 생성자를 사용하여 FormData 객체를 만들어보겠습니다.\n\n```js\nvar formData = FormData.fromMap({\n        'file': await MultipartFile.fromFile(empFace.path, filename: empCode),\n      });\n```\n\n여기서 'file' 키를 사용하여 파일을 Map에 포함했습니다. 이는 서버로 보낼 FormData 객체를 반환하며, 우리는 이 객체를 사용하여 서버로 전송할 것입니다. 카메라 이미지의 파일을 사용하여 MultipartFile을 생성하고, 이를 인터넷을 통해 전송할 수 있습니다.\n\n마지막으로 dio를 사용하여 REST API에 요청을 보내보세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\n최종 응답 = await Dio().post(\n        '당신의 API URL',\n        data: formData,\n      );\n```\n\n우리는 formData를 post 메소드에 전달했고, 자동으로 contentType을 처리해줄 것입니다. 일반적으로 서버로 이미지를 보낼 때 form-data 헤더를 사용합니다.:\n\n```dart\nheaders: {\n    'Content-Type': 'multipart/form-data'\n  },\n```\n\ndio를 사용하면 헤더에서 content-type을 명시적으로 지정할 필요가 없습니다.  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기에서 시나리오와 사용 사례를 더 잘 이해하기 위한 완전한 코드입니다:\n\n```js\nFuture\u003cbool\u003e registerEmployeeFace(\n      {required File empFace, required String empCode}) async {\n    final url =\n        '내 API URL';\n    try {\n      var formData = FormData.fromMap({\n        'file': await MultipartFile.fromFile(empFace.path, filename: empCode),\n      });\n      final response = await Dio().post(\n        url,\n        data: formData,\n      );\n      if (response.statusCode == 200) {\n        var map = response.data as Map;\n        print('success');\n        if (map['status'] == 'Successfully registered') {\n          return true;\n        } else {\n          return false;\n        }\n      } else {\n        // BotToast는 pub.dev에서 사용 가능한 토스트 패키지입니다.\n        BotToast.showText(text: '에러');\n        return false;\n      }\n    } on DioError catch (error) {\n      log(error.message);\n      throw YourException(error);\n    } catch (_) {\n      log(_.toString());\n      throw '문제가 발생했습니다';\n    }\n  }\n```\n\n초보자들도 이 요청을 쉽게 수행하고 복잡한 API를 빠르게 통합할 수 있기를 바랍니다. 더 많은 Github를 위해\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 도움이 되었다면 좋아요 버튼을 눌러주시고 친구들과 공유해주세요.","ogImage":{"url":"/assets/img/2024-06-21-UploadimagestoRESTAPIwithFlutterusingDioPackage_0.png"},"coverImage":"/assets/img/2024-06-21-UploadimagestoRESTAPIwithFlutterusingDioPackage_0.png","tag":["Tech"],"readingTime":4},{"title":"Flutter에서 ElevatedButton 모양 커스터마이징 하는 방법","description":"","date":"2024-06-21 22:43","slug":"2024-06-21-HowtoCustomizetheShapeofanElevatedButtoninFlutter","content":"\n\n![이미지](/assets/img/2024-06-21-HowtoCustomizetheShapeofanElevatedButtoninFlutter_0.png)\n\nElevatedButtons의 모양을 shape 속성으로 사용자 정의하세요!\n\nElevatedButton 위젯은 작업을 실행하는 Material Design 버튼입니다. 발판 모양을 가지고 있으며 모양 속성을 포함한 다양한 속성으로 사용자 정의할 수 있습니다.\n\n기본 ElevatedButton 모양은 8.0의 테두리 반경을 가진 둥근 직사각형입니다. 그러나 ElevatedButton 위젯의 shape 속성을 설정하여 버튼의 모양을 사용자 정의할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모양 속성은 다양한 형태로 설정할 수 있습니다. 예를 들어 다음과 같은 형태들이 있습니다:\n\n- RoundedRectangleBorder\n- BeveledRectangleBorder\n- CircleBorder\n- NotchedShape\n- ContinuousRectangleBorder\n\n예를 들어, 다음 코드는 둥근 테두리 반경이 5.0인 ElevatedButton을 생성합니다:\n\n```js\nElevatedButton.icon(\n  style: ElevatedButton.styleFrom(\n    shape: RoundedRectangleBorder(\n      borderRadius: BorderRadius.circular(5.0),\n    ),\n  ), \n  onPressed: () {},\n  icon: const Icon(Icons.filter_list),\n  label: const Text('Filter'),\n);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더 알고 싶다면 irawnewton을 방문해보세요. Flutter에 관한 심층적인 기사와 안내서가 있습니다. Flutter 및 관련 기사에 대한 블로그를 계속 올릴 거에요.\n\n또한 버튼의 모양을 사용자 정의하려면 shape 속성을 사용할 수 있어요. 예를 들어, 다음 코드는 원형 테두리가 있는 ElevatedButton을 만듭니다:\n\n```js\nElevatedButton.icon(\n  style: ElevatedButton.styleFrom(\n    shape: StadiumBorder(),\n  ),\n  onPressed: () {},\n  icon: const Icon(Icons.filter_list),\n  label: const Text('Filter'),\n);\n```\n\nshape 속성을 사용하면 ElevatedButton의 외관을 사용자 정의하는 강력한 방법입니다. 사용 가능한 다양한 모양을 활용하여 특정한 요구사항과 스타일에 맞는 버튼을 만들 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안녕하세요! ElevatedButton의 모양을 사용자 정의하는 몇 가지 팁을 제공합니다:\n\n- borderRadius 속성을 사용하여 버튼의 모퉁이 반경을 제어합니다.\n- side 속성을 사용하여 버튼의 테두리 색상 및 너비를 설정합니다.\n- elevation 속성을 사용하여 버튼의 그림자 높이를 설정합니다.\n- padding 속성을 사용하여 버튼 콘텐츠 주변의 패딩 양을 설정합니다.\n\nElevatedButton의 모양을 사용자 정의하는 자세한 내용은 다음 ElevatedButton 문서를 참조해주세요: [ElevatedButton 문서](https://api.flutter.dev/flutter/material/ElevatedButton-class.html).\n\n이 문서가 Flutter에서 ElevatedButtons의 모양을 사용자 정의하는 데 도움이 되기를 바랍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n질문이 있으시면 언제든지 댓글을 남겨주세요. 도와드릴 수 있어서 더할 나위 없이 기쁩니다.","ogImage":{"url":"/assets/img/2024-06-21-HowtoCustomizetheShapeofanElevatedButtoninFlutter_0.png"},"coverImage":"/assets/img/2024-06-21-HowtoCustomizetheShapeofanElevatedButtoninFlutter_0.png","tag":["Tech"],"readingTime":2},{"title":"Flutter에서 노치가 있는 하단 내비게이션 바 만드는 방법","description":"","date":"2024-06-21 22:41","slug":"2024-06-21-HowtocreateaNotchedBottomNavigationBarFlutter","content":"\n\n이 가이드는 하단 네비게이션 앱 바에 노치가 있는 플로팅 액션 버튼을 추가하는 방법을 보여줍니다. 하단 바의 노치가 있는 플로팅 액션 버튼은 앱의 사용자 인터페이스를 더욱 미려하게 만들어줍니다. 더 자세한 정보는 아래 코드를 참조해주세요:\n\n![Notched Floating Action Button](/assets/img/2024-06-21-HowtocreateaNotchedBottomNavigationBarFlutter_0.png)\n\n시작해 봅시다\n\n플로팅 액션 버튼이 있는 BottomAppBar는 아래 코드를 사용하여 앱에 추가할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nScaffold(\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {},\n        child: const Icon(Icons.add),\n      ),\n      bottomNavigationBar: BottomAppBar(\n        padding: const EdgeInsets.symmetric(horizontal: 10),\n        height: 60,\n        color: Colors.cyan.shade400,\n        notchMargin: 5,\n        child: Row(\n          mainAxisSize: MainAxisSize.max,\n          mainAxisAlignment: MainAxisAlignment.spaceBetween,\n          children: \u003cWidget\u003e[\n            IconButton(\n              icon: const Icon(\n                Icons.menu,\n                color: Colors.black,\n              ),\n              onPressed: () {},\n            ),\n            IconButton(\n              icon: const Icon(\n                Icons.search,\n                color: Colors.black,\n              ),\n              onPressed: () {},\n            ),\n            IconButton(\n              icon: const Icon(\n                Icons.print,\n                color: Colors.black,\n              ),\n              onPressed: () {},\n            ),\n            IconButton(\n              icon: const Icon(\n                Icons.people,\n                color: Colors.black,\n              ),\n              onPressed: () {},\n            ),\n          ],\n        ),\n      ),\n    );\n```\n\n아래는 코드의 출력이고 실행하면 앱에 사용 가능한 FloatingActionButton이 있는 BottomAppBar가 표시됩니다.\n\n\u003cimg src=\"/assets/img/2024-06-21-HowtocreateaNotchedBottomNavigationBarFlutter_1.png\" /\u003e\n\n시작하려면, Scaffold 위젯의 floatingActionButtonLocation 속성을 사용하여 FloatingActionButton 버튼의 위치를 조정하세요.\n아래에 표시된 centerDocked를 사용하여 중앙에 위치하도록 설정할 것입니다: \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래와 같이 `BottomAppBar`에 모양을 적용하세요.\n\n```js\nshape: const CircularNotchedRectangle()\n```\n\n\u003cimg src=\"/assets/img/2024-06-21-HowtocreateaNotchedBottomNavigationBarFlutter_2.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`extendBody: true`을 지정하면 스캐폴드의 본문이 하단 네비게이션 바의 노치를 통해 보이게 됩니다.\n\n```js\n extendBody: true,\n```\n\n\u003cimg src=\"/assets/img/2024-06-21-HowtocreateaNotchedBottomNavigationBarFlutter_3.png\" /\u003e\n\n그게 다에요. 🎉🎉\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n풀 코드:\n\n```dart\n return Scaffold(\n      extendBody: true,\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {},\n        child: const Icon(Icons.add),\n      ),\n      floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked,\n      bottomNavigationBar: BottomAppBar(\n        padding: const EdgeInsets.symmetric(horizontal: 10),\n        height: 60,\n        color: Colors.cyan.shade400,\n        shape: const CircularNotchedRectangle(),\n        notchMargin: 5,\n        child: Row(\n          mainAxisSize: MainAxisSize.max,\n          mainAxisAlignment: MainAxisAlignment.spaceBetween,\n          children: \u003cWidget\u003e[\n            IconButton(\n              icon: const Icon(\n                Icons.menu,\n                color: Colors.black,\n              ),\n              onPressed: () {},\n            ),\n            IconButton(\n              icon: const Icon(\n                Icons.search,\n                color: Colors.black,\n              ),\n              onPressed: () {},\n            ),\n            IconButton(\n              icon: const Icon(\n                Icons.print,\n                color: Colors.black,\n              ),\n              onPressed: () {},\n            ),\n            IconButton(\n              icon: const Icon(\n                Icons.people,\n                color: Colors.black,\n              ),\n              onPressed: () {},\n            ),\n          ],\n        ),\n      ),\n    );\n```\n\n감사합니다! :)","ogImage":{"url":"/assets/img/2024-06-21-HowtocreateaNotchedBottomNavigationBarFlutter_0.png"},"coverImage":"/assets/img/2024-06-21-HowtocreateaNotchedBottomNavigationBarFlutter_0.png","tag":["Tech"],"readingTime":4},{"title":"플러터에서 BloC 패턴으로 Fetch API 사용 방법","description":"","date":"2024-06-21 22:39","slug":"2024-06-21-FetchAPIWithBloCinFlutter","content":"\n\n이 문서에서는 블록 라이브러리를 사용하여 HTTP 요청을 수행하고 애플리케이션의 상태를 관리하는 방법을 살펴보겠습니다. 최종 애플리케이션은 다음과 같습니다:\n\n![애플리케이션 데모](https://miro.medium.com/v2/resize:fit:576/1*amzYfYKgiZ8zpehBTVcx4w.gif)\n\n앱이 처음 실행될 때, 서버에서 데이터를 가져올 때 로딩 표시기가 표시됩니다. 데이터를 가져온 후에는 목록에 표시됩니다.\n\n이를 위해 몇 가지 패키지를 사용하겠습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```yaml\ndependencies:\n  flutter_bloc: ^8.1.1\n  http: ^0.13.5\n  equatable: ^2.0.5\n```\n\n이제 API를 사용하여 서버에서 데이터를 가져오는 메커니즘을 만들어 보겠습니다. http 작업을 수행하기 위해 lib 내부에 폴더를 생성하고 repo라는 이름으로 지정합니다. 이 repo 내부에 repositories.dart라는 새 파일을 생성합니다.\n\n```dart\nimport 'dart:convert';\n\nimport 'package:bloc_example/models/user_model.dart';\nimport 'package:http/http.dart';\n\nclass UserRepository {\n  String userUrl = 'https://reqres.in/api/users?page=2';\n\n  Future\u003cList\u003cUserModel\u003e\u003e getUsers() async {\n    Response response = await get(Uri.parse(userUrl));\n   \n    if (response.statusCode == 200) {\n      final List result = jsonDecode(response.body)['data'];\n      return result.map((e) =\u003e UserModel.fromJson(e)).toList();\n    } else {\n      throw Exception(response.reasonPhrase);\n    }\n  }\n}\n```\n\nhttp 요청을 수행하려면 http 패키지를 사용할 것입니다. 이제 json 내용을 살펴봅시다. 우리는 이 링크의 API를 사용하고 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 링크에서 제공되는 JSON을 보면 모델이 어떻게 보일지에 대한 아이디어를 얻을 수 있습니다. 이 JSON에서는 데이터 태그의 속성을 갖게 될 것입니다. 여기서 우리는 firstname, lastname, email, 그리고 avatar에 초점을 맞출 것입니다.\n\n이제 모델 클래스를 만들어 봅시다.\n\n```js\nclass UserModel {\n  int? id;\n  String? email;\n  String? firstName;\n  String? lastName;\n  String? avatar;\n\n  UserModel({this.id, this.email, this.firstName, this.lastName, this.avatar});\n\n  UserModel.fromJson(Map\u003cString, dynamic\u003e json) {\n    id = json['id'];\n    email = json['email'];\n    firstName = json['first_name'];\n    lastName = json['last_name'];\n    avatar = json['avatar'];\n  }\n}\n```\n\n계속해서, 이제 우리의 블록이 어떻게 작동하는지에 대해 알아보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-21-FetchAPIWithBloCinFlutter_0.png\" /\u003e\n\n위의 그림을 보면\n\n- 먼저 UI가 있고 UI에서 블록으로 요청을 합니다.\n- 블록에는 이벤트와 상태 두 가지가 있습니다. 먼저 UI가 블록에 연결되면 이벤트를 생성하고 트리거합니다.\n- 이벤트는 최종적으로 엔드포인트를 통해 서버에 저장소를 호출합니다.\n- 서버에서 데이터를 가져와 블록에 다시 전달합니다. 데이터가 있으므로 상태를 트리거합니다.\n- 상태가 변경되었으므로 UI는 Bloc 패턴에서 알고 UI를 업데이트합니다.\n\n새 폴더 blocs를 만들고 app_states.dart라는 새 파일을 생성합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```dart\nimport 'package:bloc_example/models/user_model.dart';\nimport 'package:equatable/equatable.dart';\nimport 'package:flutter/material.dart';\n\n@immutable\nabstract class UserState extends Equatable {}\n\nclass UserLoadingState extends UserState {\n  @override\n  List\u003cObject?\u003e get props =\u003e [];\n}\n\nclass UserLoadedState extends UserState {\n  final List\u003cUserModel\u003e users;\n  UserLoadedState(this.users);\n  @override\n  List\u003cObject?\u003e get props =\u003e [users];\n}\n\nclass UserErrorState extends UserState {\n  final String error;\n  UserErrorState(this.error);\n  @override\n  List\u003cObject?\u003e get props =\u003e [error];\n}\n```\n\nEquatable를 사용하면 값들을 비교할 수 있습니다. 두 변수가 동일한 값을 갖고 있다면 UI를 변경하거나 업데이트하지 않을 것입니다.\n\n먼저 상태를 생성하려면 equatable을 확장해야 하는 추상 클래스를 생성해야 합니다.\n\nBloc에서 x.obs를 통해 변수를 반응형으로 만들 수 있는 Getx와 달리 Bloc에서는 이와 같이 작동하지 않습니다. Bloc을 사용할 때는 모든 상태가 클래스임을 염두에 두어야 합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 프로젝트에서는 세 가지 상태가 있습니다.\n\n- 데이터를 불러올 때의 상태\n- 데이터를 불러왔을 때의 상태\n- 데이터를 가져오는 데 오류가 발생했을 때의 상태\n\n그리고 Equatable 내부에 get props라는 속성이 있습니다. 이를 재정의해야 합니다. UserState 클래스가 Equatable을 확장했으므로 UserLoadingState, UserLoadedState 및 UserErrorState 상태 클래스가 get props 속성에 액세스할 수 있게 됩니다. 이를 얻기 위해 재정의하고 해당 값을 설정해야 합니다.\n\n상태 이후, Flutter 블록에서는 각 상태마다 이벤트가 있습니다. 지금 app_events.dart라는 파일을 만들어야 합니다. 상태와 마찬가지로 이벤트를 위한 클래스를 생성해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport 'package:equatable/equatable.dart';\nimport 'package:flutter/material.dart';\n\n@immutable\nabstract class UserEvent extends Equatable {\n  const UserEvent();\n}\n\nclass LoadUserEvent extends UserEvent {\n  @override\n  List\u003cObject?\u003e get props =\u003e [];\n}\n```\n\n상태처럼 이벤트도 Equatable 클래스를 확장해야 합니다. 각 이벤트를 위한 전용 클래스를 만들어야 합니다. 이벤트 클래스는 기본 클래스를 확장해야 합니다. 여기서 기본 클래스는 UserEvent입니다. 그리고 이벤트는 LoadUserEvent입니다. 그리고 get props를 재정의해야 합니다.\n\n@immutable은 클래스의 속성을 변경하고 싶지 않다는 것을 나타냅니다.\n\n상태와 이벤트를 생성한 후에는 그들을 연결하는 방법을 찾아야 합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러려면 새 클래스를 만들고 방금 만든 상태와 이벤트를 삽입해야 해요. 이제 Bloc 라이브러리를 사용하여 이것들을 연결해 보죠.\n\nblocs 폴더 안에 app_blocs라는 새 파일을 만들어주세요.\n\n```dart\nimport 'package:bloc_example/blocs/app_events.dart';\nimport 'package:bloc_example/blocs/app_states.dart';\nimport 'package:bloc_example/repos/repositories.dart';\nimport 'package:flutter_bloc/flutter_bloc.dart';\n\nclass UserBloc extends Bloc\u003cUserEvent, UserState\u003e {\n  final UserRepository _userRepository;\n\n  UserBloc(this._userRepository) : super(UserLoadingState()) {\n    on\u003cLoadUserEvent\u003e((event, emit) async {\n      emit(UserLoadingState());\n      try {\n        final users = await _userRepository.getUsers();\n        emit(UserLoadedState(users));\n      } catch (e) {\n        emit(UserErrorState(e.toString()));\n      }\n    });\n  }\n}\n```\n\n여기엔 UserBloc이라는 클래스가 있습니다. 이 클래스는 Bloc을 확장합니다. 이 Bloc은 이벤트와 상태를 가져와야 합니다. 저희 경우에는 UserEvent와 UserState입니다. 이곳에서 사용하는 Bloc은 실제로 Bloc 라이브러리에서 제공됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 UserBloc에는 리포지토리를 전달하는 생성자가 있어요. UI에서 이것을 호출할 거거든요. 이 클래스를 호출하는 동안 UserRepository를 전달합니다. Bloc을 사용했기 때문에 초기 상태를 슈퍼 생성자에 전달해야해요. 초기값을 호출한 후에는 on 메소드를 호출하게 됩니다.\n\n이제 on 메소드는 이벤트 유형을 가져와서 LoadUserEvent를 여기에 전달합니다. 이 이벤트를 사용하여 어떤 작업을 수행할 수 있어요. 이 이벤트가 호출되면 일부 상태를 방출하도록 지정합니다. 이 경우에는 UserLoadingState를 UI에서 변경 사항을 확인하려고 해요.\n\nBLoc에서 상태, 이벤트를 연결하여 상태를 트리거하고 작업할 수 있도록 하려면 lib 폴더에 homepage.dart라는 새 파일을 만들어요.\n\n```js\nclass HomePage extends StatelessWidget {\n  const HomePage({Key key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MultiBlocProvider(\n      providers: [\n        BlocProvider\u003cUserBloc\u003e(\n          create: (BuildContext context) =\u003e UserBloc(UserRepository()),\n        ),\n      ],\n      child: Scaffold(\n          appBar: AppBar(title: const Text('The BloC App')),\n          body: blocBody()),\n    );\n  }\n\nWidget blocBody() {\n    return BlocProvider(\n      create: (context) =\u003e UserBloc(\n        UserRepository(),\n      )..add(LoadUserEvent()),\n      child: BlocBuilder\u003cUserBloc, UserState\u003e(\n        builder: (context, state) {\n          if (state is UserLoadingState) {\n            return const Center(\n              child: CircularProgressIndicator(),\n            );\n          }\n           if (state is UserErrorState) {\n            return const Center(child:  Text(\"Error\"));\n          }\n          if (state is UserLoadedState) {\n            List\u003cUserModel\u003e userList = state.users;\n            return ListView.builder(\n                itemCount: userList.length,\n                itemBuilder: (_, index) {\n                  return Padding(\n                    padding:\n                        const EdgeInsets.symmetric(vertical: 4, horizontal: 8),\n                    child: Card(\n                        color: Theme.of(context).primaryColor,\n                        child: ListTile(\n                            title: Text(\n                              '${userList[index].firstName}  ${userList[index].lastName}',\n                              style: const TextStyle(color: Colors.white),\n                            ),\n\n                            subtitle: Text(\n                              '${userList[index].email}',\n                              style: const TextStyle(color: Colors.white),\n                            ),\n                            \n                            leading: CircleAvatar(\n                              backgroundImage: NetworkImage(\n                                  userList[index].avatar.toString()),\n                            ))),\n                  );\n                });\n          }\n\n          return Container();\n        },\n      ),\n    );\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n보시다시피 'MultiBlocProvider'가 제공되는 우리의 bloc 라이브러리에서 온 것을 확인할 수 있어요. 서버에서 데이터를로드하고 한 번만 로드하려고하기 때문에 빌드 방법에서 UserRepository를 주입합니다. bloc 형식의 MultiBlocProvider에서는 클래스에 여러 Bloc을 추가하여 전체 클래스에서 사용할 수 있습니다. 또한이 리포지토리를 배치할 위치에는 클래스가 있어야합니다. 우리의 경우에는 Scaffold입니다.\n\n그래서 MultiBlocProvider가 하는 일은 서버에서 데이터를 이동시키고 이를 만들어서 데이터와 상태를 모든 하위 요소에서 사용할 수 있게하는 것입니다.\n\nblocBody 내부에서 BlocProvider를 볼 수 있습니다. Getx에 익숙하다면 Get.put와 비슷합니다. BlocProvider 내부에서는 리포지토리와 함께 bloc 즉 UserBloc을 주입합니다. 위에서 이미 bloc을 주입했으므로 blocBody 내에서 이벤트에 액세스 할 수 있습니다.\n\n리포지토리와 함께 bloc을 주입 한 후에는 이벤트 즉 LoadUserEvent를 추가하고 이를 사용하여 UserBloc에서 UserLoadingState를 트리거하는 캐스캐이딩 연산자를 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 빌더 내부의 상태를 확인할 수 있습니다. 세 가지 상태가 있으므로 각각을 확인하여 다른 작업을 수행하고 다른 UI를 반환합니다.\n\n다음과 같이 확인할 수 있습니다.\n\n- `UserLoadingState`일 때는 데이터를 불러오고 있다는 의미로 CircularProgressIndicator를 표시합니다.\n- `UserLoadedState`일 때는 데이터 목록을 반환합니다.\n- `UserErrorState`일 때는 오류 메시지를 반환합니다.\n\n이제 애플리케이션을 실행하면 bloc 라이브러리를 사용하여 데이터가 검색될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n단점을 확인하려면 잘못된 종단점을 만들어 보실 수 있습니다.\n\n# 결론\n\n이 글에서 Bloc 및 Bloc 작업 메커니즘에 대해 설명했습니다. 필요에 맞게 코드를 조정하여 사용해 보세요. 새 페이지를 만들어 보는 것도 좋은 방법입니다. Bloc 아키텍처는 대규모 프로젝트에 매우 유용할 수 있습니다.\n\n이 블로그 게시물이 앞으로의 프로젝트에서 bloc 라이브러리와 아키텍처를 사용하는 데 충분한 중요한 정보를 제공해 줄 것을 바랍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n❤ ❤ 이 글 읽어주셔서 감사합니다 ❤ ❤\n\n만약 이 글을 좋아하셨다면 👏 두 번 치세요.\n\n또한, 업데이트되는 흥미로운 글과 프로젝트를 확인하려면 팔로우하세요.\n\n무엇인가 잘못된 점이 있다면? 댓글로 알려주세요. 개선해나가겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 함께 연결해요\n\n우리 친구가 되어요. 페이스북, 링크드인, 깃허브, 유튜브, BuyMeACoffee, 그리고 인스타그램에서 찾아요.\n\n방문하기: Flutter Junction\n\n기여하기: BuyMeACoffee\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 링크에서 전체 코드를 확인하세요:","ogImage":{"url":"/assets/img/2024-06-21-FetchAPIWithBloCinFlutter_0.png"},"coverImage":"/assets/img/2024-06-21-FetchAPIWithBloCinFlutter_0.png","tag":["Tech"],"readingTime":10},{"title":"플러터에서 네이티브 코드와의 양방향 통신을 위한 메소드 채널 사용 방법","description":"","date":"2024-06-21 22:37","slug":"2024-06-21-MethodChannelinFlutterBridgingNativeCodeandFlutterwithTwo-WayCommunication","content":"\n\n플러터의 메소드 채널은 플러터와 플랫폼별 코드 간에 원활한 통신을 제공하는 강력한 메커니즘을 제공합니다. 이 블로그 포스트에서는 플러터에서 메소드 채널을 설정하고 네이티브 MainActivity.kt(Android) 및 AppDelegate.swift(iOS) 코드에서 데이터를 플러터 애플리케이션으로 반환하는 과정을 살펴보겠습니다. 함께 알아보겠습니다!\n\n플러터에서 메소드 채널 설정하기: 먼저, 플러터 프로젝트에 메소드 채널을 설정해 봅시다.\n\n- 의존성 추가: 플러터 프로젝트의 pubspec.yaml 파일에 flutter/services 패키지를 의존성으로 추가하세요:\n\n```js\ndependencies:\n  flutter:\n    sdk: flutter\n  flutter/services:\n    ^2.0.0\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Method Channel 정의하기: 플러터 Dart 코드에서 Method Channel을 정의하세요:\n\n```js\nimport 'package:flutter/services.dart';\n\n// MethodChannel의 인스턴스 생성\nfinal MethodChannel platformChannel = MethodChannel('your_channel_name');\n```\n\nAndroid에서 Method Channel 통신 구현하기: 이제 Android 플랫폼에서 Method Channel 통신을 구현해 봅시다.\n\n- MainActivity.kt에서 메소드 호출 수신하기: MainActivity.kt 파일에서 onMethodCall 메소드를 오버라이드하여 Flutter로부터의 메소드 호출을 처리하고 데이터를 반환하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\nimport io.flutter.embedding.android.FlutterActivity\nimport io.flutter.embedding.engine.FlutterEngine\nimport io.flutter.plugin.common.MethodChannel\n\nclass MainActivity : FlutterActivity() {\n    private val CHANNEL = \"your_channel_name\"\n\n    override fun configureFlutterEngine(flutterEngine: FlutterEngine) {\n        super.configureFlutterEngine(flutterEngine)\n\n        // Set up the MethodChannel with the same name as defined in Dart\n        MethodChannel(flutterEngine.dartExecutor.binaryMessenger, CHANNEL).setMethodCallHandler { call, result -\u003e\n            if (call.method == \"getDataFromNative\") {\n                // Perform platform-specific operations and obtain the result\n                val data = getDataFromNative()\n\n                // Send the result back to Flutter\n                result.success(data)\n            } else {\n                result.notImplemented()\n            }\n        }\n    }\n\n    private fun getDataFromNative(): String {\n        // Perform platform-specific operations to fetch the data\n        return \"Data from Native\"\n    }\n}\n```\n\niOS에서 Method Channel 통신 구현하기: 이제 iOS 플랫폼에서 메서드 채널 통신을 구현해봅시다.\n\n- AppDelegate.swift에서 메서드 호출 받기: AppDelegate.swift 파일에 아래 코드를 추가하여 Flutter에서의 메서드 호출을 처리하고 데이터를 반환합니다:\n\n```swift\nimport UIKit\nimport Flutter\n\n@UIApplicationMain\n@objc class AppDelegate: FlutterAppDelegate {\n    private let CHANNEL = \"your_channel_name\"\n\n    override func application(\n        _ application: UIApplication,\n        didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?\n    ) -\u003e Bool {\n        // Set up the MethodChannel with the same name as defined in Dart\n        if let flutterViewController = window?.rootViewController as? FlutterViewController {\n            let methodChannel = FlutterMethodChannel(name: CHANNEL, binaryMessenger: flutterViewController.binaryMessenger)\n            methodChannel.setMethodCallHandler { [weak self] (call: FlutterMethodCall, result: FlutterResult) in\n                if call.method == \"getDataFromNative\" {\n                    // Perform platform-specific operations and obtain the result\n                    let data = self?.getDataFromNative()\n\n                    // Send the result back to Flutter\n                    result(data)\n                } else {\n                    result(FlutterMethodNotImplemented)\n                }\n            }\n        }\n\n        return super.application(application, didFinishLaunchingWithOptions: launchOptions)\n    }\n\n    private func getDataFromNative() -\u003e String {\n        // Perform platform-specific operations to fetch the data\n        return \"Data from Native\"\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플러터에서 네이티브로 데이터 전달 및 결과 반환하기: 이제 플러터에서 네이티브에 데이터를 전달하고 결과를 다시 플러터에서 받는 방법을 살펴봅시다.\n\n- 플러터에서 메소드 호출: 플러터 Dart 코드에서 플랫폼별 코드에서 메소드를 호출하고 결과를 처리하세요.\n\n```js\nvoid fetchDataFromNative() async {\n  try {\n    final String result = await platformChannel.invokeMethod('getDataFromNative');\n    print('Result from Native: $result');\n  } on PlatformException catch (e) {\n    print('Error: ${e.message}');\n  }\n}\n```\n\n결론: 축하합니다! 이제 플러터에서 메서드 채널을 성공적으로 설정했습니다. 이를 통해 플러터와 플랫폼별 코드 간의 양방향 통신이 가능해졌습니다. 이 블로그 포스트에서 안내된 단계와 코드 예제를 따라 하시면, 네이티브 기능을 쉽게 통합하고 네이티브 측에서 플러터 응용 프로그램으로 데이터를 반환할 수 있습니다. 실험하고 탐색하며, 메서드 채널의 강력한 기능을 활용하여 플러터 프로젝트의 무한한 가능성을 발견하세요. 즐거운 코딩되세요!","ogImage":{"url":"/assets/img/2024-06-21-MethodChannelinFlutterBridgingNativeCodeandFlutterwithTwo-WayCommunication_0.png"},"coverImage":"/assets/img/2024-06-21-MethodChannelinFlutterBridgingNativeCodeandFlutterwithTwo-WayCommunication_0.png","tag":["Tech"],"readingTime":5},{"title":"Flutter에서 백그라운드 서비스와 포어그라운드 서비스 사용 방법","description":"","date":"2024-06-21 22:36","slug":"2024-06-21-BackgroundandForegroundservicesinFlutter","content":"\n\n\n![그림](/assets/img/2024-06-21-BackgroundandForegroundservicesinFlutter_0.png)\n\n플러터의 백그라운드 및 포그라운드 서비스를 사용하면 앱이 활발히 실행되거나 활성화되어 있지 않을 때에도 백그라운드에서 작업을 수행할 수 있습니다. 이는 음악 재생, 인터넷에서 데이터 가져오기, 또는 사용자 경험을 방해하지 않고 장기간 실행되는 계산과 같은 작업을 포함합니다.\n\n패키지 추가: Flutter Background Service 문서 읽기를 클릭\n\n```js\n  flutter_background_service: 5.0.2\n  flutter_background_service_android: 6.1.0\n  flutter_background_service_ios: ^5.0.0\n``` \n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n매니페스트에 다음 항목 추가해주세요.\n\n```js\n    \u003cuses-permission android:name=\"android.permission.FOREGROUND_SERVICE\"/\u003e\n    \u003cuses-permission android:name=\"android.permission.FOREGROUND_SERVICE_LOCATION\"/\u003e\n    \u003cuses-permission android:name=\"android.permission.FOREGROUND_SERVICE_DATA_SYNC\"/\u003e\n\n    \u003cuses-permission android:name=\"android.permission.RECEIVE_BOOT_COMPLETED\"/\u003e\n    \u003cuses-permission android:name=\"android.permission.WAKE_LOCK\"/\u003e\n```\n\n애플리케이션 태그 안에 다음을 추가해주세요.\n\n```js\n\u003cservice\n    android:name=\"id.flutter.flutter_background_service.BackgroundService\"\n    android:foregroundServiceType=\"location\"\n/\u003e\n\n\u003cservice\n    android:enabled=\"true\"\n    android:exported=\"true\"\n    android:name=\".BackgroundService\"\n    android:stopWithTask=\"false\"\n/\u003e\n\n\u003creceiver\n    android:name=\".WatchdogReceiver\"\n    android:enabled=\"true\"\n    android:exported=\"true\"\n/\u003e\n\n\u003creceiver\n    android:name=\".BootReceiver\"\n    android:enabled=\"true\"\n    android:exported=\"true\"\u003e\n    \u003cintent-filter\u003e\n        \u003caction android:name=\"android.intent.action.BOOT_COMPLETED\"/\u003e\n        \u003caction android:name=\"android.intent.action.QUICKBOOT_POWERON\"/\u003e\n    \u003c/intent-filter\u003e\n\u003c/receiver\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음은 main.dart에서 사용하세요:\n\n```js\nFuture\u003cvoid\u003e main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n  await initializeService();\n  runApp(const MyApp());\n}\n```\n\n```js\n/// Foreground 및 Background\nFuture\u003cvoid\u003e initializeService() async {\n  final service = FlutterBackgroundService();\n\n  await service.configure(\n    androidConfiguration: AndroidConfiguration(\n      onStart: onStart,\n      autoStart: false,\n      isForegroundMode: true,\n      // notificationChannelId: 'my_foreground',\n      // initialNotificationContent: 'running',\n      foregroundServiceNotificationId: 888,\n    ),\n    iosConfiguration: IosConfiguration(\n      autoStart: true,\n      onForeground: onStart,\n      onBackground: onIosBackground,\n    ),\n  );\n}\n```\n\nIOS용:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\n@pragma('vm:entry-point')\nFuture\u003cbool\u003e onIosBackground(ServiceInstance service) async {\n  WidgetsFlutterBinding.ensureInitialized();\n  DartPluginRegistrant.ensureInitialized();\n  return true;\n}\n```\n\nAndroid용:\n\n```dart\n@pragma('vm:entry-point')\nvoid onStart(ServiceInstance service) async {\n  DartPluginRegistrant.ensureInitialized();\n  if (service is AndroidServiceInstance) {\n    service.on('setAsForeground').listen((event) {\n      service.setAsForegroundService();\n    });\n    service.on('setAsBackground').listen((event) {\n      service.setAsBackgroundService();\n    });\n  }\n  service.on('stopService').listen((event) {\n    service.stopSelf();\n  });\n\n  final FlutterLocalNotificationsPlugin flutterLocalNotificationsPlugin =\n      FlutterLocalNotificationsPlugin();\n\n  // // bring to foreground\n  Timer.periodic(const Duration(seconds: 1), (timer) async {\n    if (service is AndroidServiceInstance) {\n      if (await service.isForegroundService()) {\n        flutterLocalNotificationsPlugin.show(\n          0, 'This is foreground', '${DateTime.now()}',\n          const NotificationDetails(\n            android: AndroidNotificationDetails(\n              \"notificationChannelId\",\n              'MY FOREGROUND SERVICE',\n              icon: 'ic_bg_service_small',\n              ongoing: true,\n            ),\n          ),\n        );\n      }\n    }\n  });\n}\n```\n\n이 메서드는 어디서든 사용할 수 있습니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\nvoid backgroundService()async{\r\n  final service = FlutterBackgroundService();\r\n  var isRunning = await service.isRunning();\r\n  if (isRunning) {\r\n    Timer.periodic(const Duration(seconds: 1), (timer) async {\r\n      if (mounted) {\r\n        setState(() {\r\n          debugPrint(\"runningSanjay\");\r\n          CustomLoader.message(\"runningSanjay\");\r\n        });\r\n      }\r\n    });\r\n  } else {\r\n    service.startService();\r\n  }\r\n  setState(() {});\r\n}\r\n```\r\n\r\n전체 코드:\r\n\r\n```js\r\nimport 'dart:async';\r\nimport 'dart:convert';\r\nimport 'dart:io';\r\nimport 'dart:ui';\r\nimport 'package:flutter_background_service/flutter_background_service.dart';\r\nimport 'package:flutter_background_service_android/flutter_background_service_android.dart';\r\n\r\nFuture\u003cvoid\u003e main() async {\r\n  WidgetsFlutterBinding.ensureInitialized();\r\n  await initializeService(); \r\n  runApp(const MyApp());\r\n}\r\n\r\n/// Foreground and Background\r\nFuture\u003cvoid\u003e initializeService() async {\r\n  final service = FlutterBackgroundService();\r\n  await service.configure(\r\n    androidConfiguration: AndroidConfiguration(\r\n      onStart: onStart,\r\n      autoStart: false,\r\n      isForegroundMode: true,\r\n      // notificationChannelId: 'my_foreground',\r\n      // initialNotificationContent: 'running',\r\n      foregroundServiceNotificationId: 888,\r\n    ),\r\n    iosConfiguration: IosConfiguration(\r\n      autoStart: true,\r\n      onForeground: onStart,\r\n      onBackground: onIosBackground,\r\n    ),\r\n  );\r\n}\r\n\r\n@pragma('vm:entry-point')\r\nFuture\u003cbool\u003e onIosBackground(ServiceInstance service) async {\r\n  WidgetsFlutterBinding.ensureInitialized();\r\n  DartPluginRegistrant.ensureInitialized();\r\n  return true;\r\n}\r\n\r\n@pragma('vm:entry-point')\r\nvoid onStart(ServiceInstance service) async {\r\n  DartPluginRegistrant.ensureInitialized();\r\n  if (service is AndroidServiceInstance) {\r\n    service.on('setAsForeground').listen((event) {\r\n      service.setAsForegroundService();\r\n    });\r\n    service.on('setAsBackground').listen((event) {\r\n      service.setAsBackgroundService();\r\n    });\r\n  }\r\n  service.on('stopService').listen((event) {\r\n    service.stopSelf();\r\n  });\r\n\r\n  final FlutterLocalNotificationsPlugin flutterLocalNotificationsPlugin = \r\n  FlutterLocalNotificationsPlugin();\r\n  // bring to foreground\r\n  Timer.periodic(const Duration(seconds: 1), (timer) async {\r\n    if (service is AndroidServiceInstance) {\r\n      if (await service.isForegroundService()) {\r\n        CustomLoader.message(\"foreground\");\r\n        flutterLocalNotificationsPlugin.show(\r\n          0, 'COOL SERVICE', 'Awesome ${DateTime.now()}',\r\n          const NotificationDetails(\r\n            android: AndroidNotificationDetails(\r\n              \"notificationChannelId\",\r\n              'MY FOREGROUND SERVICE',\r\n              icon: 'ic_bg_service_small',\r\n              ongoing: true,\r\n            ),\r\n          ),\r\n        );\r\n      }\r\n    }\r\n  });\r\n}\r\n\r\nclass MyApp extends StatefulWidget {\r\n  const MyApp({Key key}) : super(key: key);\r\n  @override\r\n  State\u003cMyApp\u003e createState() =\u003e _MyAppState();\r\n}\r\n\r\nclass _MyAppState extends State\u003cMyApp\u003e{\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return MaterialApp(\r\n      debugShowCheckedModeBanner: false,\r\n      theme: ThemeData(\r\n          scaffoldBackgroundColor: Colors.white,\r\n          inputDecorationTheme: const InputDecorationTheme(\r\n            focusedBorder: UnderlineInputBorder(\r\n                borderSide: BorderSide(color: Colors.blue)\r\n            ),\r\n          )),\r\n      home:  Container(\r\n        color: Colors.white,\r\n        child:  Center(\r\n            child: Text(\"This is foreground service app\"),\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n\u003cimg src=\"/assets/img/2024-06-21-BackgroundandForegroundservicesinFlutter_1.png\" /\u003e\r\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기사를 즐겁게 읽으셨기를 바랍니다! 제공된 정보를 감사히 여기신다면 'Buy Me A Coffee'로 저를 지원할 수 있습니다! 여러분의 제스처에 감사드립니다!","ogImage":{"url":"/assets/img/2024-06-21-BackgroundandForegroundservicesinFlutter_0.png"},"coverImage":"/assets/img/2024-06-21-BackgroundandForegroundservicesinFlutter_0.png","tag":["Tech"],"readingTime":8},{"title":"Flutter로 작성된 모바일 앱인지 확인하는 방법","description":"","date":"2024-06-21 22:34","slug":"2024-06-21-HowtoDetermineifaMobileAppisWritteninFlutter","content":"\n\n안녕하세요, Flutter 팬 여러분들! 오늘은 모바일 앱이 Flutter로 작성되었는지 확인하는 방법에 대해 이야기해보겠습니다. 이 지식은 경쟁 조사를 위해 개발자와 매니저들에게 유용하며, 자신이 좋아하는 앱의 내부를 더 알고 싶어하는 기술 애호가들에게도 도움이 될 수 있습니다. 그래서, 더 이상 말뿐인 소리는 그만하고 시작해봅시다.\n\n# 부드러운 인터페이스와 복잡한 애니메이션\n\n- 복잡성: 1\n- 정확성: 2\n\nFlutter는 부드럽고 아름다운 인터페이스를 만들어내는 능력으로 유명합니다. 만약 예상치 못한 아름다움과 부드러움을 발견한다면, 그것이 Flutter 앱일 수 있습니다. 그러나, 좋은 디자인과 애니메이션 부드러움은 다른 프레임워크로도 구현할 수 있기 때문에 이것은 단지 많은 조직 중 하나에 불과합니다. 반면, 앱이 끊기는 애니메이션과 오랜 응답 시간을 보인다면, 그 또한 Flutter 앱일 수 있습니다. 대부분, 개발자들이 이 앱에 큰 노력을 기울이지 않았거나, 클라이언트가 비용을 줄이기로 결정했을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 두 손가락 스크롤링 속도가 두 배 빨라졌어요\n\n- 복잡도: 1\n- 정확도: 3\n\nFlutter 앱에서는 네이티브 앱과 비교했을 때 두 손가락으로 스크롤링 하는 것이 두 배 빨라집니다. 게다가, 세 손가락 스크롤링은 세 배 빠릅니다. 그러나 Flutter 개발자들은 항상 개선해 나가는 중이며, 최근에 이 \"버그\"를 수정했기 때문에 이 방법은 이전만큼 신뢰할 수 없을 수도 있습니다.\n\n# 공식 Flutter 페이지에 피처된 앱들\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 복잡도: 1\n- 정확성: 5\n\n가장 신뢰할 수 있는 방법은 공식 플러터 페이지를 확인하는 것입니다. 그곳에는 플러터로 개발된 앱들의 모음을 볼 수 있습니다.\n\n![이미지](/assets/img/2024-06-21-HowtoDetermineifaMobileAppisWritteninFlutter_0.png)\n\n# 온라인 서비스 플러터헌트\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 복잡도: 1\n- 정확도: 4\n\nFlutterHunt은 Flutter로 개발된 앱에 대한 정보를 수집하는 온라인 데이터베이스입니다. 그런데 이 서비스의 제작자와 채팅할 수도 있어요.\n\n![이미지](/assets/img/2024-06-21-HowtoDetermineifaMobileAppisWritteninFlutter_1.png)\n\n# 플러터 상어 앱\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 복잡성: 1\n- 정확성: 4\n\n네, 다른 앱이 플러터를 사용하는지 여부를 결정하는 데 전용 앱이 있습니다! 기기에 설치된 앱을 분석하고 해당 앱이 플러터로 개발되었는지 식별합니다. 신기하게도, 플러터 Shark는 플러터로 작성되었습니까?\n\n![이미지](/assets/img/2024-06-21-HowtoDetermineifaMobileAppisWritteninFlutter_2.png)\n\n# 개발 속도 및 통합 코드베이스\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 복잡도: 3\n- 정확성: 2\n\n플러터를 사용하면 Android와 iOS용 앱을 생성하는 데 동일한 코드를 사용할 수 있어 개발 프로세스를 크게 가속화할 수 있습니다. 한 회사가 새로운 기능을 두 플랫폼에서 동시에 빠르게 출시한다면, 그들은 플러터를 사용하고 있을 수도 있습니다.\n\n# 개발자 메뉴에서 \"레이아웃 경계 표시\" 활성화하기\n\n- 복잡도: 4\n- 정확성: 4\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 방법은 강력한 중급 개발자를 대상으로 합니다. 안드로이드 개발자 설정에서 \"레이아웃 경계 표시\" 옵션을 활성화하여 인터페이스 요소의 경계를 볼 수 있습니다. 플러터 앱은 자체 렌더링 메커니즘이 있기 때문에 네이티브 앱과 달리 인터페이스 요소에는 경계가 없습니다.\n\n## 안드로이드 개발자 메뉴에서 \"레이아웃 경계 표시\"를 활성화하는 방법:\n\n단계 1: 개발자 모드 활성화\n\n- 안드로이드 기기의 설정을 엽니다.\n- 아래로 내려 \"휴대폰 정보\"를 찾습니다.\n- 빌드 번호를 찾습니다 (소프트웨어 정보 또는 휴대폰 정보 섹션에 있을 수 있습니다).\n- 빌드 번호를 7번 탭합니다. \"개발자가 되고 있습니다\"라는 메시지가 표시됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n**단계 2: 레이아웃 바운드 보기 활성화**\n\n- 메인 설정 메뉴로 돌아갑니다.\n- 개발자 모드를 활성화한 후 나타난 \"개발자용\" 또는 \"개발자 옵션\" 항목으로 스크롤합니다.\n- \"개발자 옵션\"을 선택합니다.\n- \"디버깅\" 또는 \"시각화\" 섹션으로 스크롤합니다.\n- \"레이아웃 바운드 보기\" 또는 \"레이아웃 테두리 표시\" 옵션을 찾아 활성화합니다.\n\n# 디버깅 정보 및 개발자 도구\n\n- 복잡성: 5\n- 정확도: 5\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n진짜 고급 사용자를 위한 방법을 찾아왔어요. Flutter 앱은 작동 방식과 시스템과의 상호 작용에 따라 구별될 수 있는 특정 특성이 있어요. 디버깅 중에 접근할 수 있어요. Android Studio와 Visual Studio Code를 사용하면 애플리케이션의 라이프사이클, 시스템과의 상호 작용 및 기타 기술적 측면을 관찰할 수 있어요.\n\n## 다음은 방법이에요:\n\n- 기기를 컴퓨터에 연결하세요. 기기의 개발자 모드가 활성화되어 있고 USB 디버깅이 허용되어 있는지 확인하세요.\n- 즐겨 사용하는 코드 편집기를 열어주세요. Flutter와 Dart 플러그인이 설치된 Android Studio 또는 Visual Studio Code를 시작하세요.\n- ADB (Android Debug Bridge)를 시작하세요. 터미널이나 명령 프롬프트를 열고 adb devices 명령을 입력하여 기기가 연결되어 있는지 확인하세요.\n- 애플리케이션을 기기에서 시작하세요. 기기에서 원하는 Flutter 앱을 열어주세요.\n- Android Studio에서 Logcat을 엽니다. Android Studio에서는 화면 하단의 \"Logcat\" 탭을 선택하세요. Visual Studio Code에서는 통합 터미널을 사용하여 해당 명령을 실행하여 로그를 볼 수 있어요.\n- 로그 출력을 애플리케이션 식별자로 필터링하세요.\n- Flutter 및 Dart VM에 대한 언급을 찾아보세요. Flutter 앱을 시작하고 실행할 때, 로그에 Dart VM 또는 Flutter Engine과 관련된 메시지가 표시될 수 있어요.\n- 이 방법은 Flutter를 사용하여 개발된 앱을 확인하는 가장 신뢰할 수 있는 방법 중 하나에요.\n\n# APK 파일 분석\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 복잡성: 666\n- 정확도: 5\n\n이전 방법들이 만족스럽지 않다면, APK를 언패킹하여 애플리케이션을 심층적으로 탐색해볼 수 있습니다.\n\n## 단계별로:\n\n- 애플리케이션의 APK를 다운로드합니다. 다양한 온라인 서비스나 도구를 사용하여 Google Play Store에서 APK를 직접 다운로드할 수 있습니다.\n- APK를 \"언팩\"할 도구를 사용합니다. 이 작업에 대한 인기 있는 도구 중 하나는 APKTool이며, APK를 디컴파일하고 내용을 확인할 수 있는 다른 유사한 도구도 사용할 수 있습니다.\n- libflutter.so 및 kernel_blob.bin 파일을 찾습니다. 디컴파일된 APK를 열고 ./lib/ 및 ./assets/flutter_assets/ 디렉토리를 찾아봅니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 왜 이것이 동작하는지:\n\n- libflutter.so는 안드로이드에서 Dart 코드를 로드하고 실행하는 데 사용되는 Flutter 전용 라이브러리입니다.\n- kernel_blob.bin은 애플리케이션의 컴파일된 Dart 코드를 포함하고 있습니다.\n\n이 방법은 좀 더 기술적인 지식이 필요하며, 진정한 엔지니어를 위한 것입니다.\n\n이 방법은 Alexandra Kovaleva가 제안했으며, 그녀에게 특별한 감사의 말씀을 전합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n그게 다야! 이 방법들이 플러터의 세계에 대해 더 많이 알게 해주고 당신에게 자극을 주어 여러분만의 프로젝트를 만들게 하는 데 도움이 되길 바랍니다.\n\n흥미롭고 유용하다면, 링크드인과 X(트위터)에서 저와 함께하세요.","ogImage":{"url":"/assets/img/2024-06-21-HowtoDetermineifaMobileAppisWritteninFlutter_0.png"},"coverImage":"/assets/img/2024-06-21-HowtoDetermineifaMobileAppisWritteninFlutter_0.png","tag":["Tech"],"readingTime":5}],"page":"4","totalPageCount":20,"totalPageGroupCount":1,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"4"},"buildId":"kPqZsTmJiF9vEOxaTPfEy","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>