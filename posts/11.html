<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>uidev-css</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://uidev-css.github.io///posts/11" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="uidev-css" data-gatsby-head="true"/><meta property="og:title" content="uidev-css" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://uidev-css.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://uidev-css.github.io///posts/11" data-gatsby-head="true"/><meta name="twitter:title" content="uidev-css" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | uidev-css" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/873-1e1f6fb6fd3c8994.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-498da29379dd58dc.js" defer=""></script><script src="/_next/static/-yEBofE4jMl3RL1kr5c4Y/_buildManifest.js" defer=""></script><script src="/_next/static/-yEBofE4jMl3RL1kr5c4Y/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UIDEV CSS</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Flutter로 강력한 크로스플랫폼 모바일 앱 만드는 방법" href="/post/2024-06-21-BuildingPowerfulCross-PlatformMobileAppswithFlutter"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter로 강력한 크로스플랫폼 모바일 앱 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-BuildingPowerfulCross-PlatformMobileAppswithFlutter_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter로 강력한 크로스플랫폼 모바일 앱 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Flutter로 강력한 크로스플랫폼 모바일 앱 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">4 hours ago</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter 기본 위젯들을 알고 계신가요" href="/post/2024-06-21-DoyouknowthebasicwidgetsofFlutter"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter 기본 위젯들을 알고 계신가요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-DoyouknowthebasicwidgetsofFlutter_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter 기본 위젯들을 알고 계신가요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Flutter 기본 위젯들을 알고 계신가요</strong><div class="PostList_meta__VCFLX"><span class="date">4 hours ago</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter에서 Clean Architecture 시작하기" href="/post/2024-06-21-IntroductiontoCleanArchitectureinFlutter"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter에서 Clean Architecture 시작하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-IntroductiontoCleanArchitectureinFlutter_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter에서 Clean Architecture 시작하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Flutter에서 Clean Architecture 시작하기</strong><div class="PostList_meta__VCFLX"><span class="date">4 hours ago</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter 프로젝트에서 Riverpod 20  Generator 사용법" href="/post/2024-06-21-HowtouseRiverpod20GeneratorinyourFlutterProject"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter 프로젝트에서 Riverpod 20  Generator 사용법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-HowtouseRiverpod20GeneratorinyourFlutterProject_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter 프로젝트에서 Riverpod 20  Generator 사용법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Flutter 프로젝트에서 Riverpod 20  Generator 사용법</strong><div class="PostList_meta__VCFLX"><span class="date">4 hours ago</span><span class="PostList_reading_time__6CBMQ">15<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="크로스 플랫폼 개발 대결 MVP를 위한 FlutterFlow vs React Native vs Flutter 비교" href="/post/2024-06-21-Cross-PlatformDevelopmentShowdownFlutterFlowvsReactNativevsFlutterforMVPs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="크로스 플랫폼 개발 대결 MVP를 위한 FlutterFlow vs React Native vs Flutter 비교" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-Cross-PlatformDevelopmentShowdownFlutterFlowvsReactNativevsFlutterforMVPs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="크로스 플랫폼 개발 대결 MVP를 위한 FlutterFlow vs React Native vs Flutter 비교" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">크로스 플랫폼 개발 대결 MVP를 위한 FlutterFlow vs React Native vs Flutter 비교</strong><div class="PostList_meta__VCFLX"><span class="date">4 hours ago</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="FlutterFlow와 네이티브 모바일 앱 개발 비교 비용과 품질 - MVP 기준" href="/post/2024-06-21-MoneyandQualityMVPinFlutterFlowvsNativeMobileAppDevelopment"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="FlutterFlow와 네이티브 모바일 앱 개발 비교 비용과 품질 - MVP 기준" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-MoneyandQualityMVPinFlutterFlowvsNativeMobileAppDevelopment_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="FlutterFlow와 네이티브 모바일 앱 개발 비교 비용과 품질 - MVP 기준" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">FlutterFlow와 네이티브 모바일 앱 개발 비교 비용과 품질 - MVP 기준</strong><div class="PostList_meta__VCFLX"><span class="date">4 hours ago</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter 프라이빗 패키지 만드는 방법" href="/post/2024-06-21-FlutterCreatePrivatePackages"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter 프라이빗 패키지 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-FlutterCreatePrivatePackages_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter 프라이빗 패키지 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Flutter 프라이빗 패키지 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">4 hours ago</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter Web Github Pages에 배포하는 방법" href="/post/2024-06-21-FlutterWebGithubpages"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter Web Github Pages에 배포하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-FlutterWebGithubpages_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter Web Github Pages에 배포하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Flutter Web Github Pages에 배포하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">4 hours ago</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="undefined" href="/post/undefined"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="undefined" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/undefined_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="undefined" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">undefined</strong><div class="PostList_meta__VCFLX"><span class="date">4 hours ago</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter에서 위젯 크기를 동적으로 측정하는 방법" href="/post/2024-06-21-HowtoDynamicallyMeasureWidgetSizeinFlutter"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter에서 위젯 크기를 동적으로 측정하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-HowtoDynamicallyMeasureWidgetSizeinFlutter_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter에서 위젯 크기를 동적으로 측정하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Flutter에서 위젯 크기를 동적으로 측정하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">4 hours ago</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link posts_-active__YVJEi" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Flutter로 강력한 크로스플랫폼 모바일 앱 만드는 방법","description":"","date":"2024-06-21 20:24","slug":"2024-06-21-BuildingPowerfulCross-PlatformMobileAppswithFlutter","content":"\n\n플러터(Flutter)를 활용하여 모바일 개발의 최대 잠재력을 발휘하세요. iOS와 안드로이드를 위한 고성능, 아름다운 앱을 만드는 방법을 배워보세요!\n\n![플러터 이미지](/assets/img/2024-06-21-BuildingPowerfulCross-PlatformMobileAppswithFlutter_0.png)\n\n오늘날 빠르게 변화하는 디지털 환경에서, 모바일 앱 개발자들은 여러 플랫폼에서 원활히 실행되는 고품질 앱을 효율적으로 구축하는 방법을 계속해서 찾고 있습니다. 구글의 UI 툴킷인 플러터(Flutter)는 이 분야에서 혁신적인 변화를 가져오고 있습니다.\n\n본 블로그는 플러터에 대해 소개하고, 그 혜택을 소개하며 플러터를 사용하여 크로스 플랫폼 모바일 앱을 개발하는 포괄적인 가이드를 제공하는 것을 목표로 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플러터의 배경, 필수 도구와 기술, 단계별 구현 가이드, 그리고 실제 사례 연구를 포함하여 그 효과를 강조할 예정입니다. 마지막에는 플러터가 크로스 플랫폼 모바일 개발에 대한 최고의 선택인 이유에 대해 명확히 이해하게 될 것입니다.\n\n플러터는 구글에서 만든 오픈 소스 UI 소프트웨어 개발 키트(SDK)입니다. 이를 통해 개발자는 단일 코드베이스로 모바일, 웹 및 데스크톱용 네이티브 컴파일된 애플리케이션을 구축할 수 있습니다.\n\niOS와 Android에서 모두 작동하는 앱이 필요한 수요가 증가함에 따라, 플러터는 개발 시간과 비용을 줄이는 강력한 솔루션을 제공하며 높은 성능과 품질을 유지합니다.\n\n도구 설명:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플러터 SDK: 앱을 개발하는 데 필요한 모든 것을 포함하는 핵심 도구 모음인 SDK입니다. 라이브러리, API 및 도구가 포함됩니다.\n\n다트 언어: 플러터는 빠른 앱을 위해 최적화된 언어인 다트를 사용합니다.\n\n플러터 프레임워크: 복잡한 UI를 쉽게 만들 수 있도록 도와주는 재사용 가능한 위젯 모음입니다.\n\nIDE 지원: 플러터는 안드로이드 스튜디오, 인텔리제이, 비주얼 스튜디오 코드와 같은 인기 있는 IDE에서 지원되며 유용한 플러그인과 확장 기능을 통해 개발 경험을 향상시킵니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n혜택:\n\n단일 코드베이스: 한 번 작성하고 어디서나 실행하세요. Flutter를 사용하면 iOS 및 Android 앱 모두에 대해 단일 코드베이스를 사용할 수 있습니다.\n\n빠른 개발: 핫 리로드 기능을 통해 변경 사항을 즉시 볼 수 있어 개발 프로세스를 가속화시킵니다.\n\n표현력이 풍부하고 유연한 UI: Flutter의 다양한 사전 설계된 위젯과 다양한 사용자 정의 옵션을 통해 아름다운, 매우 적응 가능한 UI를 만들 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n단계별 안내:\n\nFlutter 설정하기:\n\n- 공식 Flutter 웹사이트에서 Flutter SDK 설치하기.\n- 선호하는 통합 개발 환경(예: Visual Studio Code 또는 Android Studio) 설정하기.\n\n새로운 Flutter 프로젝트 생성하기:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nflutter create my_app\ncd my_app\n```\n\n앱 실행하기:\n\n- 기기를 연결하거나 에뮬레이터를 시작합니다.\n- flutter run을 실행하여 앱을 시작합니다.\n\nUI 디자인:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport 'package:flutter/material.dart';\n\nvoid main() =\u003e runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: Text('Hello Flutter')),\n        body: Center(child: Text('Welcome to Flutter')),\n      ),\n    );\n  }\n}\n```\n\n상호 작용성 추가:\n\n```js\nclass MyApp extends StatefulWidget {\n  @override\n  _MyAppState createState() =\u003e _MyAppState();\n}\n\nclass _MyAppState extends State\u003cMyApp\u003e {\n  int _counter = 0;\n\n  void _incrementCounter() {\n    setState(() {\n      _counter++;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: Text('Counter App')),\n        body: Center(\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: \u003cWidget\u003e[\n              Text('버튼을 누른 횟수:'),\n              Text('$_counter', style: Theme.of(context).textTheme.headline4),\n            ],\n          ),\n        ),\n        floatingActionButton: FloatingActionButton(\n          onPressed: _incrementCounter,\n          tooltip: '증가',\n          child: Icon(Icons.add),\n        ),\n      ),\n    );\n  }\n}\n```\n\n실전 케이스 스터디:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 구글 애드워즈: 이 앱은 Flutter를 사용하여 플랫폼 간에 표현력 있는 UI 및 높은 성능을 제공합니다.\n- 알리바바: 플러터를 선택하여 탁월한 플랫폼 간 기능을 갖추고 사용자 경험을 향상시키며 개발 시간을 단축했습니다.\n\n성능: Flutter 앱은 거의 네이티브 속도를 제공하여 성능이 우수합니다.\n\n개발 효율성: 팀들은 개발 및 테스트 시간을 상당히 단축했다고 보고하고 있습니다.\n\n커뮤니티 지원: 강력하고 활발한 커뮤니티가 Flutter의 지속적인 향상과 리소스 이용 가능성에 기여합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플러터(Flutter)는 통합적이고 효율적이며 유연한 접근 방식을 제공하여 크로스 플랫폼 모바일 앱 개발을 혁신하고 있습니다. 포괄적인 툴킷과 단일 코드베이스는 개발의 복잡성과 비용을 줄입니다.\n\n플러터를 채택하면 고품질의 앱을 빠르고 효율적으로 제공할 수 있는 능력이 상당히 향상되어, 개발자와 비즈니스에게 모두 귀중한 기술이 됩니다.\n\n오늘부터 플러터를 탐험하고 첫 번째 앱을 만들어보며 플러터 개발자 커뮤니티에 참여해 보세요.\n\n독서/자료:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 플러터 문서\n- 다트 언어 안내서\n- 플러터 패키지\n\n다운로드:\n\n- 플러터 SDK\n- 비주얼 스튜디오 코드\n\n플러터에 대한 경험을 공유하거나 궁금한 점이 있다면 아래 댓글에 남겨주세요.","ogImage":{"url":"/assets/img/2024-06-21-BuildingPowerfulCross-PlatformMobileAppswithFlutter_0.png"},"coverImage":"/assets/img/2024-06-21-BuildingPowerfulCross-PlatformMobileAppswithFlutter_0.png","tag":["Tech"],"readingTime":4},{"title":"Flutter 기본 위젯들을 알고 계신가요","description":"","date":"2024-06-21 20:23","slug":"2024-06-21-DoyouknowthebasicwidgetsofFlutter","content":"\n\n\"플러터로 UI를 만들고 싶으신가요? 네.\n\n플러터의 기본 위젯을 아시나요?\n\n# 아니라면, 읽어보세요.\n\n플러터에는 전체 프레임워크에서 사용할 수 있는 다양한 유용한 위젯이 있지만, 플러터에서 UI를 만들기 시작할 때 알고 있어야 하는 가장 기본적인 위젯을 여기에 소개합니다.\"\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n1) **Scaffold**: Scaffold는 기본적인 재료 디자인 시각적 레이아웃 구조를 구현하는 데 사용되는 플러터 위젯입니다.\n\n![이미지](/assets/img/2024-06-21-DoyouknowthebasicwidgetsofFlutter_0.png)\n\n2) **Row**: Row 위젯은 자식 위젯을 가로로 정렬합니다. 여러 위젯을 연이어 표시하는 데 일반적으로 사용됩니다.\n\n![이미지](/assets/img/2024-06-21-DoyouknowthebasicwidgetsofFlutter_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3) **컬럼:** 컬럼 위젯은 플러터 애플리케이션에서 가장 일반적으로 사용되는 레이아웃 패턴 중 하나입니다. 이는 수직 배열로 자식 위젯을 표시하는 다중 자식 위젯입니다.\n\n![Column Widget](/assets/img/2024-06-21-DoyouknowthebasicwidgetsofFlutter_2.png)\n\n4) **스택:** 플러터에서의 스택은 여러 위젯을 겹쳐서 표시할 수 있게 해주는 위젯입니다.\n\n![Stack Widget](/assets/img/2024-06-21-DoyouknowthebasicwidgetsofFlutter_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이미지 안에 있는 링크를 통해 더 많은 정보를 얻을 수 있어요.\n\n더 많은 플러터 콘텐츠를 보려면 Panchalyagnik을 팔로우해 주세요.","ogImage":{"url":"/assets/img/2024-06-21-DoyouknowthebasicwidgetsofFlutter_0.png"},"coverImage":"/assets/img/2024-06-21-DoyouknowthebasicwidgetsofFlutter_0.png","tag":["Tech"],"readingTime":1},{"title":"Flutter에서 Clean Architecture 시작하기","description":"","date":"2024-06-21 20:21","slug":"2024-06-21-IntroductiontoCleanArchitectureinFlutter","content":"\n\n\n![Clean Architecture in Flutter](/assets/img/2024-06-21-IntroductiontoCleanArchitectureinFlutter_0.png)\n\nFlutter는 빠르게 인기를 얻은 프레임워크로, 크로스 플랫폼 모바일 애플리케이션을 구축하는 데 사용됩니다. 사용하기 쉽고 강력한 기능으로 많은 개발자들에게 선택되는 이유입니다. 그러나 앱이 성장함에 따라 깨끗하고 확장 가능하며 테스트 가능한 코드를 유지하는 것이 어려워질 수 있습니다. 이때 Clean Architecture가 필요합니다.\n\n# Clean Architecture란?\n\nClean Architecture는 로버트 C. 마틴 (Uncle Bob)이 만든 용어로, 관심사 분리를 촉진하여 시스템이 유지 가능하고 확장 가능하며 테스트 가능하도록 하는 소프트웨어 디자인 접근 방식입니다. 핵심 아이디어는 앱을 계층으로 나누어 각각에 특정 책임을 부여하여 내부 계층이 외부 계층에 의존하지 않도록 하는 것입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-21-IntroductiontoCleanArchitectureinFlutter_1.png\" /\u003e\n\n## Clean Architecture의 주요 원칙\n\n- 염려 사항의 분리: 기능에 따라 응용 프로그램을 구분된 섹션으로 분할합니다. 이는 복잡성을 줄이고 코드 가독성을 향상시킵니다.\n- 의존성 규칙: 모든 소스 코드 의존성은 내부로 향해야 합니다. 상위 레이어는 하위 레이어에 의존해서는 안 되며, 내부 레이어는 외부 레이어에 대해 알 필요가 없습니다.\n- 프레임워크로부터 독립: 아키텍처는 특정 프레임워크의 존재에 의존해서는 안 됩니다. 이렇게 하면 시스템을 프레임워크에 의존시키는 대신에 도구로써 프레임워크를 사용할 수 있습니다.\n- 테스트 가능성: 비즈니스 로직을 UI, 데이터베이스, 웹 서버 또는 다른 외부 요소 없이 테스트할 수 있어 자동화된 테스트가 쉬워집니다.\n- UI의 독립성: UI를 변경할 때 시스템의 나머지 부분에 영향을 미치지 않습니다. 예를 들어, 웹 UI를 비즈니스 규칙을 변경하지 않고 콘솔 UI로 교체할 수 있습니다.\n- 데이터베이스의 독립성: 비즈니스 규칙은 데이터베이스에 종속되지 않으므로 데이터베이스 간 쉬운 전환을 허용합니다.\n- 모든 외부 기관의 독립성: 비즈니스 규칙은 외부 세계에 대해 아무것도 알지 못하도록 하여 일관성과 안정성을 보장합니다.\n\n# Clean Architecture 코네\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nClean Architecture 콘은 Clean Architecture 원칙을 따라 설계된 시스템의 구조를 보여줍니다. 다이어그램에는 여러 원이 나란히 그려져 있습니다. 각각 다른 애플리케이션 계층을 나타냅니다. 최외부 원에는 저수준의 구체적인 세부 사항이 들어 있고, 최내부 원에는 고수준의 추상적인 정책이 포함되어 있습니다.\n\n![Clean Architecture Cone](/assets/img/2024-06-21-IntroductiontoCleanArchitectureinFlutter_2.png)\n\n## Clean Architecture Cone의 계층\n\n- Entities (기업 비즈니스 규칙): 핵심 데이터 구조와 비즈니스 규칙을 나타냅니다. 이러한 계층은 매우 안정적이며 변경될 가능성이 매우 낮습니다.\n- Use Cases (애플리케이션 비즈니스 규칙): 응용 프로그램별 비즈니스 규칙을 포함하며 엔티티 및 외부 세계 간 데이터 흐름을 조정합니다.\n- Controllers, Gateways, Presenters (인터페이스 어댑터): UI와 비즈니스 로직 간 통신을 처리하고 계층 간 데이터를 적응시킵니다. 이는 상태 관리 솔루션 및 프레젠테이션 로직을 포함합니다.\n- User Interface, Database, Devices (프레임워크 및 드라이버): 최외부 계층으로, 데이터베이스, 웹 프레임워크, UI, 장치 등과 같은 외부 요소를 포함합니다. 이 계층은 외부 세계와 상호 작용하며 변경될 가능성이 가장 높습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 플러터에 Cone 적용하기\n\n이제 이러한 개념들이 플러터 프로젝트로 어떻게 전환되는지 탐색해보겠습니다. Clean Architecture의 각 계층을 구체적인 구성 요소로 매핑하는 방법을 이해하면 견고하고 유지보수 가능한 애플리케이션을 구축하는 데 도움이 됩니다.\n\n- 사용자 인터페이스, 데이터베이스, 장치: 플러터에서 이 계층은 플러터 SDK 자체, 외부 패키지 및 플러그인을 포함합니다. 예를 들어, 플러터 SDK에는 UI를 구축하는 위젯이 포함되어 있습니다.\n- 컨트롤러, 게이트웨이, 프레젠터: 이 계층은 BLoC와 Provider와 같은 플러터의 상태 관리 솔루션을 포함하며 데이터 및 UI 상태의 흐름을 관리합니다.\n- 사용 사례: 비즈니스 규칙을 처리하는 사용 사례 클래스를 사용하여 애플리케이션별 로직을 구현합니다.\n- 엔티티: 핵심 데이터 구조와 비즈니스 규칙을 일반적인 Dart 클래스로 정의합니다.\n\n# 실전에서의 의존성 규칙\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n의존성 규칙은 모든 종속성이 안쪽으로 향해야 함을 보장합니다. 내부 원 안의 코드는 외부 원에 대해 아무것도 알지 못해야 합니다. 이 규칙을 준수하면 비즈니스 로직을 격리된 상태로 테스트하는 것이 더 쉬워지며, 내부 레이어에 영향을 주지 않고 외부 레이어를 변경하는 유연성이 향상됩니다.\n\n# 플러터에서 클린 아키텍처의 장점\n\n플러터 프로젝트에서 클린 아키텍처를 채택함으로써 다음과 같은 혜택을 누릴 수 있습니다:\n\n- 향상된 코드 품질: 역할의 명확한 분리로 인해 더 깨끗하고 가독성 있는 코드를 작성할 수 있습니다.\n- 쉬운 테스트: 레이어 간의 명확한 경계는 테스트를 작성하고 유지보수하기 쉽게 만듭니다.\n- 더 나은 확장성: 모듈식 코드를 통해 새로운 기능을 추가하거나 변경을 가할 때 다른 부분에 영향을 주지 않고 진행할 수 있습니다.\n- 향상된 유지보수성: 더 깔끔한 아키텍처는 코드를 이해하고 디버깅하며 확장하는 데 용이하게 만듭니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n플러터에서의 Clean Architecture는 확장 가능하고 테스트 가능하며 유지보수가 용이한 애플리케이션을 구축하는 데 도움이 됩니다. 앱을 다양한 계층으로 분리함으로써 복잡성을 관리하고 코드를 깔끔하고 모듈화된 상태로 유지할 수 있습니다.\n\n# 다음은 무엇인가요?\n\n다음 기사에서는 \"Clean Architecture로 플러터 프로젝트 설정 및 구성하기\"를 안내해 드리겠습니다. 프로젝트 구조 설정, 의존성 구성, 그리고 깔끔하고 견고한 플러터 애플리케이션 구축에 시작하는 방법에 대해 다룰 것입니다. 기대해 주세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 참고 자료\n\n- Clean Coder 블로그\n- Clean Architecture에 대한 간단한 소개","ogImage":{"url":"/assets/img/2024-06-21-IntroductiontoCleanArchitectureinFlutter_0.png"},"coverImage":"/assets/img/2024-06-21-IntroductiontoCleanArchitectureinFlutter_0.png","tag":["Tech"],"readingTime":4},{"title":"Flutter 프로젝트에서 Riverpod 20  Generator 사용법","description":"","date":"2024-06-21 20:19","slug":"2024-06-21-HowtouseRiverpod20GeneratorinyourFlutterProject","content":"\n\n\u003cimg src=\"/assets/img/2024-06-21-HowtouseRiverpod20GeneratorinyourFlutterProject_0.png\" /\u003e\n\nRiverpod은 플러터(Flutter)에서 상태 관리 및 반응형 데이터 캐싱의 새로운 표준입니다. 두 번째 버전인 Riverpod 2.0은 꽤 오랫동안 출시되었지만, 새로운 데이터 관리 방법과 컨셉을 이해하기 어려울 수 있습니다.\n\n# 우리가 배울 내용\n\n- Riverpod 2.0의 새로운 프로바이더로 기존 프로바이더를 업데이트하는 방법.\n- 앱 내에서 상태를 새로운 방식으로 관리하는 방법.\n- Riverpod 2.0에서 퓨처(futures)를 다루는 방법.\n- 프로바이더를 자동으로 생성하고 프로바이더 생성 프로세스를 간소화하는 방법.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n시작하기 전에, Riverpod가 무엇을 할 수 있는지 알아보아야 합니다. Riverpod는 상태를 관리하기 위해 providers라는 것을 사용하며, 다음은 2.0 이전에 존재했던 providers입니다. 다양한 유형의 providers를 빠르게 살펴보겠습니다:\n\n- Provider: 이 provider는 값을 생성합니다. 반응적 상태나 메모리가 없기 때문에 대부분의 경우에 최적이 아니지만, 많은 정적 메소드를 가진 클래스나 접근하려는 종속성이 있는 경우 유용합니다.\n- ChangeNotifierProvider, StateNotifierProvider, StateProvider: 이들은 앱 내부에서 로컬 상태를 생성, 액세스 및 캐싱하는 데 도움을 줍니다. 모두 반응적인 변경을 지원합니다.\n- FutureProvider, StreamProvider: 이들은 앱 내에서 비동기 데이터를 캐싱하고 액세스하는 데 도움을 줍니다.\n\nRiverpod 2.0에서는 이러한 모든 providers를 대체하는 2개의 providers가 있습니다... 하나만 제외하고요.\n\n- NotifierProvider: 이는 변경 알림/동기 변경에 사용되며, ChangeNotifierProvider, StateNotifierProvider, StateProvider를 대체합니다.\n- AsyncNotifier: 이는 비동기 변경에 사용되며, FutureProvider를 대체합니다. 2024년 6월 19일 현재, StreamProvider를 대체할 대안이 없습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이전에 언급한 대로, 생성기를 사용하여 우리의 프로바이더를 만들기도 할 겁니다. 생성기는 새로운 프로바이더 구문을 지원합니다 (StreamProviders를 제외하고). 또한 AutoDisposeProviders를 지원합니다. @riverpod 어노테이션을 사용하여 생성기에게 다음 함수를 프로바이더로 만들라고 알립니다.\n\n새로운 프로바이더에 대해 익숙해졌으니, 생성기를 사용하여 어떻게 앱에서 사용할 지 살펴봅시다.\n\n# 시작하기\n\n가장 중요한 것은 앱에 Riverpod 2.0 패키지를 설치하는 것입니다. pubspec.yaml 파일에 다음 줄을 추가하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```yaml\n# pubspec.yaml\n\ndependencies:\n  flutter_riverpod: ^2.1.3\n  riverpod_annotation: ^1.1.1\ndev_dependencies:\n  build_runner:\n  riverpod_generator: ^1.1.1\n```\n\n# HelloWorld Provider 생성\n\n이제 가장 기본적인 provider 스타일을 만들고 사용하는 방법을 보여주는 다음 코드 조각을 살펴봅시다.\n\n```dart\n// main.dart\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:riverpod_annotation/riverpod_annotation.dart';\n// 생성기는 provider가 포함된 파일을 생성합니다. 전형적으로 \"\u003cfilename\u003e.g.dart\" 구문을 따르도록 합니다.\n// 또한 import 문 이후에 코드를 작성하는 것이 좋습니다.\npart 'main.g.dart';\n\n// 단순히 메서드를 생성하고 \"@riverpod\"로 주석을 달아 provider를 만듭니다.\n// \"HelloWorldRef\" 객체를 생성하는 방법에 유의하세요.\n// 이 객체는 아직 존재하지 않지만 \"dart run build_runner watch\" 명령을 실행하면 생성됩니다.\n@riverpod\nString helloWorld(HelloWorldRef ref) {\n  return 'Hello world';\n}\n\n// provider를 사용하기 위해서는 동기식 provider를 사용하는 방식과 동일한 방식으로 사용합니다.\nvoid main() {\n  runApp(\n    // 앱의 모든 provider 상태는 ProviderScope 내에 저장됩니다.\n    // provider를 읽기 위해서는 이를 반드시 포함해야 합니다.\n    ProviderScope(\n      child: MyApp(),\n    ),\n  );\n}\n\n// Riverpod는 Stateless와 Stateful 위젯과 유사한 ConsumerWidget 및 ConsumerStatefulWidget 클래스 액세스를 제공합니다.\nclass MyApp extends ConsumerWidget {\n  // ConsumerWidget의 build 메서드가 WidgetRef 객체를 가져오는 방식에 유의하세요.\n  // WidgetRef는 provider를 읽는 데 사용됩니다.\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // provider를 읽는 두 가지 방법이 있습니다.\n    // 값을 읽고 변경 사항을 감시하려면 ref.watch(...)를 사용하고,\n    // 함수를 호출하려면 ref.read(...)를 사용합니다.\n    final String val = ref.watch(helloWorldProvider);\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Hello World Example')),\n        body: Center(\n          child: Text(val),\n        ),\n      ),\n    );\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 제너레이터는 프로바이더가 포함된 파일을 생성합니다. 일반적으로 이 구문을 따르도록 하려면 `filename`.g.dart 형식을 따르길 원합니다. 그리고 import 문 이후에 이를 유지하는 것이 좋습니다. 이 부분은 파일이 서로 관련되어 있음을 Dart에게 알려주는 부분입니다.\n- 프로바이더를 만들기 위해서는 단순히 메서드를 만들고 이를 “@riverpod”으로 주석 처리하여 우리의 프로바이더를 생성합니다. \"HelloWorldRef\" 객체를 만든 방법에 주목해보세요. 아직 존재하지는 않지만 우리가 터미널에서 dart run build_runner watch 명령을 실행하면 생성될 것입니다. 따라서 해당 명령을 실행하고 `filename`.g.dart라는 파일을 생성하고 생성 중 발생한 오류를 해결하세요. 해당 파일은 다음과 같습니다:\n\n```js\n// GENERATED CODE - DO NOT MODIFY BY HAND\n\npart of 'main.dart';\n// **************************************************************************\n// RiverpodGenerator\n// **************************************************************************\n// ignore_for_file: avoid_private_typedef_functions, non_constant_identifier_names, subtype_of_sealed_class, invalid_use_of_internal_member, unused_element, constant_identifier_names, unnecessary_raw_strings, library_private_types_in_public_api\n/// Dart SDK에서 복사함\nclass _SystemHash {\n  _SystemHash._();\n  static int combine(int hash, int value) {\n    // ignore: parameter_assignments\n    hash = 0x1fffffff \u0026 (hash + value);\n    // ignore: parameter_assignments\n    hash = 0x1fffffff \u0026 (hash + ((0x0007ffff \u0026 hash) \u003c\u003c 10));\n    return hash ^ (hash \u003e\u003e 6);\n  }\n  static int finish(int hash) {\n    // ignore: parameter_assignments\n    hash = 0x1fffffff \u0026 (hash + ((0x03ffffff \u0026 hash) \u003c\u003c 3));\n    // ignore: parameter_assignments\n    hash = hash ^ (hash \u003e\u003e 11);\n    return 0x1fffffff \u0026 (hash + ((0x00003fff \u0026 hash) \u003c\u003c 15));\n  }\n}\nString $helloWorldHash() =\u003e r'8bbe6cff2b7b1f4e1f7be3d1820da793259f7bfc';\n/// [helloWorld]도 참고하세요.\nfinal helloWorldProvider = AutoDisposeProvider\u003cString\u003e(\n  helloWorld,\n  name: r'helloWorldProvider',\n  debugGetCreateSourceHash:\n      const bool.fromEnvironment('dart.vm.product') ? null : $helloWorldHash,\n);\ntypedef HelloWorldRef = AutoDisposeProviderRef\u003cString\u003e;\n```\n\n- 생성된 프로바이더가 AutoDisposeProvider인 것을 주목하세요. 이는 상태가 없는 데이터와 유사하기 때문입니다.\n- 파일을 저장한 후, dart run build_runner watch가 실행 중인 한 모든 생성된 프로바이더가 다시 생성됩니다.\n\n# 위젯 트리 어디서든 프로바이더에 접근하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 당신은 앱 내에서 제공 업체의 데이터를 어디서든 읽을 수 있는지 궁금해 할 수도 있습니다. 이를 제공 업체 소비하기라고하며, 이를 위해 ref.watch(…) 메서드를 호출하는 WidgetRef 개체를 사용해야합니다. 위젯의 특정 부분만 제공 업체에 액세스해야하는 경우 Consumer 클래스를 사용할 수 있습니다.\n\n다음은 Consumer 클래스를 사용한 예시입니다.\n\n```dart\n// main.dart\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:riverpod_annotation/riverpod_annotation.dart';\n\npart 'main.g.dart';\n\n@riverpod\nString helloWorld(HelloWorldRef ref) {\n  return 'Hello world';\n}\n\nvoid main() {\n  runApp(\n    ProviderScope(\n      child: MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Hello World Example')),\n        body: Center(\n          child: Consumer(\n            builder: (context, ref, child) {\n              final String val = ref.watch(helloWorldProvider);\n              // Consumer has a return type of Widget.\n              // Almost like using a Builder widget, but Riverpodified :)\n              return Text(val);\n            },\n        ),\n      ),\n    );\n  }\n}\n```\n\n# 변수에 반응형 상태 추가하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더 복잡한 제공자 예제를 살펴봅시다. 클래스를 사용하는 것과 같은 예제입니다. 이는 체크박스 부울 값이나 요소 목록과 같은 반응성 상태가 필요한 변수가 있는 경우 유용할 수 있습니다.\n\n다음 예제에서는 클래스를 사용하여 변수의 저장소로 사용하고 제공자로 변환하는 방법을 보여줍니다.\n\n```js\n@riverpod\nclass HelloWorld extends _$HelloWorld {\n  String build() {\n    return \"hello world\";\n  }\n\n  void toCamelCase() {\n      // 변수 상태를 사용하여 제공자의 현재 상태에 액세스하는 방법에 주목해주세요.\n      state = '${state[0].toUpperCase()}${state.substring(1).toLowerCase()}';\n  }\n}\n\nref.watch(helloWorldProvider); // hello world\nref.watch(helloWorldProvider.notifier).toCamelCase();\nref.watch(helloWorldProvider); // Hello World\n```\n\n이 예제에서는 우리의 클래스가 _$`클래스명`을 확장하고 제공자로 변환되어야 한다는 것을 riverpod에게 알려주기 위해 위에 riverpod 주석이 달렸습니다. 참고: 클래스로 만든 모든 제공자는 build() 메서드가 필요합니다. 이곳이 제공자의 초기 상태를 구성하는 곳입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제공자를 사용하는 것은 이전에 언급한 예제들만큼 간단합니다: 단순히 ref.watch(`생성된 제공자 이름`)을 호출하면 앱이 변경 사항을 감시합니다. 그리고 클래스의 접근자 메서드를 사용하려면 ref.watch(`생성된 제공자 이름`.notifier).`메서드 이름`()을 호출해야 합니다. .notifier를 꼭 포함하도록 하세요.\n\n# 제공자의 현재 값 변경하기\n\n이제 제공자 내의 현재 값을 변경하려면 클래스 내에 생성자를 사용하고 약간 수정해야 합니다. 즐겨 사용하는 단어 목록을 살펴보겠습니다.\n\n```js\n@riverpod\nclass FavoriteWordsRepository extends _$FavoriteWordsRepository {\n  FavoriteWordsRepository(List\u003cString\u003e favoriteWords) {\n    words = favoriteWords;\n  }\n\n  List\u003cString\u003e words = [];\n\n  @override\n  List\u003cString\u003e build() {\n    return words;\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nmain.g.dart 파일에서 FavoriteWordsRepository.new를 사용할 수 없다는 오류가 발생할 수 있습니다. 이 간단한 수정으로 해결할 수 있습니다:\n\n```js\nfinal favoriteWordsRepositoryProvider =\n    AutoDisposeAsyncNotifierProvider\u003cFavoriteWordsRepository, List\u003cString\u003e\u003e(\n  () =\u003e FavoriteWordsRepository([]), // FavoriteWordsRepository.new --\u003e () =\u003e FavoriteWordsRepository([])\n```\n\n이것을 값으로 리스트를 초기화하는 것과 혼동하지 마세요. 이것은 단순히 시작점일 뿐이고 실제로 초기화된 리스트는 List`String` words = []; 입니다.\n\n그리고 위젯 코드 내에서 provider의 상태를 다음과 같이 업데이트할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nref.watch(favoriteWordsRepositoryProvider.notifier).words = ['Cars', 'Dogs', 'Flutter'];\n```\n\n# 비동기 공급자 생성\n\n지역 공급자 데이터 작업에 익숙해지면 futures를 다루는 방법도 알아봅시다! 아래 예시는 기본적인 future 공급자를 만드는 방법을 보여줍니다.\n\n```js\n@riverpod\nFuture\u003cString\u003e helloWorldFuture(HelloWorldFutureRef ref) async {\n  try {\n    await Future.delayed(const Duration(seconds: 3));\n    return 'Hello World';\n  } catch (e) {\n    // 이 함수는 오류를 발생시킬 수 없습니다.\n    // futures에 대한 Try/Catch 블록은 좋은 실천법입니다 :)\n    rethrow;\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리의 함수는 다시 HelloWorldFutureRef를 가져와야 합니다. 이것은 단일 공급자에서 여러 제공자를 사용하는 데에 사용됩니다. 다음은 dio: ^4.0.6을 사용하여 예제 API에 HTTP 요청을하는 예제입니다:\n\n```dart\n// dio_provider.dart\n\nimport 'package:dio/dio.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:riverpod_annotation/riverpod_annotation.dart';\npart 'dio_provider.g.dart';\n\n@riverpod\nDio dio(DioRef ref, {Map\u003cString, dynamic\u003e? headers, String? subDomain}) {\n  return Dio(BaseOptions(baseUrl: 'https://api.example.com', headers: headers));\n}\n```\n\n그리고 우리의 공급자에서 액세스하는 방법은 다음과 같습니다:\n\n```dart\n// greeting_service.dart\n\nimport 'dio_provider.dart';\n@riverpod\nFuture\u003cString\u003e getGreeting(GetGreetingRef ref, {required String name}) async {\n  try {\n    final response = await ref.watch(dioProvider()).get('/greeting');\n    final result = response.data;\n    final greeting = result + ', ' + name;\n    return greeting; // Hello there, Carlton\n  } catch (e) {\n    rethrow;\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다른 공급자를 사용해 공급자를 `.family`로 만들어요.\n\n# build 메서드에 인수 전달하기\n\nRiverpod은 초기화할 때 build 메서드로 인수를 전달할 수 있게 해줘요. 이를 코드에서 어떻게 할 수 있는지 알아볼게요.\n\n```js\n@riverpod\nclass MyRepository extends _$MyRepository {\n  @override\n  // 여기에 위치 인수를 추가하세요. 이름 지정도 가능해요.\n  Future\u003cString\u003e build(String id, {bool value}) async {\n    final String result = await myFuture(id, value);\n    return anotherFutureThatReturnsAString(result);\n  }\n  // ...\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# AsyncProvider를 사용하는 방법\n\nAsyncProvider를 사용하는 방법은 로컬 공급자를 사용하는 방법과 다르며 데이터와 상호 작용하는 방식이 변경됩니다. 주의 깊게 살펴보세요, 이것은 매우 중요합니다!\n\nUI에서 공급자를 사용하려면 .when() 구문을 사용해야 합니다. 이 구문에는 3가지 다른 상태가 포함되어 있습니다: 데이터(완료), 로딩, 오류. ConnectionState를 확인하고 해당 위젯을 반환하는 것의 번거로움을 제거하기 때문에 FutureBuilders를 이것으로 교체할 수 있습니다. 아래는 완전한 앱의 예시를 살펴봅시다:\n\n초기 앱 만들기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\n// main.dart\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({Key? key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const ProviderScope(\n      child: MaterialApp(\n        home: MyHomePage(),\n      ),\n    );\n  }\n}\n```\n\nCreating foo class and provider\n\n```dart\n// foo.dart\n\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:riverpod_annotation/riverpod_annotation.dart';\n\npart 'foo.g.dart';\n\nclass Foo {\n  final int bar;\n  int? baz;\n\n  Foo(\n    this.bar, {\n    this.baz,\n  });\n}\n\n@riverpod\nclass FooController extends _$FooController {\n  FooController(this.foo);\n  Foo foo;\n\n  @override\n  FutureOr\u003cFoo\u003e build() async {\n    foo = await getFoo();\n    return foo;\n  }\n\n  Future\u003cFoo\u003e getFoo() async {\n    await Future.delayed(const Duration(seconds: 1));\n    return Foo(1);\n  }\n}\n```\n\nConsuming foo provider\n```dart\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\n// home.dart\n\nclass MyHomePage extends StatelessWidget {\n  const MyHomePage({key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(),\n      body: Consumer(\n        builder: (context, ref, _) {\n          // Provider를 얻어와서 watch합니다\n          final fooAsync = ref.watch(fooControllerProvider);\n          // .when을 사용하여 Future로부터 UI를 렌더링합니다\n          return fooAsync.when(\n            data: (foo) =\u003e Text('bar: ${foo.bar}, baz: ${foo.baz}'),\n            loading: () =\u003e const CircularProgressIndicator(),\n            error: (err, stack) =\u003e Text(err.toString()),\n          );\n        },\n      ),\n    );\n  }\n}\n```\n\n이 예시에서는 Consumer 위젯을 사용하여 ref에 액세스하므로 ref.watch(fooControllerProvider)를 호출하여 AsyncData 유형을 반환할 수 있습니다. 그런 다음 .when(…) 함수가 제공하는 속성을 사용하여 UI를 매우 깨끗하고 관리하기 쉬운 형식으로 구성할 수 있습니다.\n\n이 작업은 생성된 파일에서 provider의 초기값을 설정해야 합니다.\n\n```dart\nfinal fooControllerProvider = AutoDisposeAsyncNotifierProvider\u003cFooController, Foo\u003e(\n  () =\u003e FooController(Foo(1)), // FooController.new --\u003e FooController(Foo(1))\n  name: r'fooControllerProvider',\n  debugGetCreateSourceHash: const bool.fromEnvironment('dart.vm.product') ? null : $FooControllerHash,\n);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# AsyncProvider의 현재 상태를 개체/가공 가능한 데이터처럼 가져오는 방법\n\n현재 방법은 API 데이터에 빠르게 액세스하는 데 유용하지만 문제가 발생합니다. 미래 Provider 내부의 데이터를 어떻게 가공 가능한 데이터처럼 액세스할 수 있을까요? API에서 사용자 데이터를 요청하고, 사용자 설정에서 사용자의 이름을 업데이트하고 싶다고 가정해 봅시다. 우리는 ref.watch(`YourFutureProvider`)가 User 클래스가 아닌 AsyncData 유형을 반환하기 때문에 이렇게 할 수 없습니다. 일부 데이터를 알고 싶을 때마다 GET 요청을 완료하고 싶지 않으며, 특히 첫 번째로로드되고 사용 가능한 경우입니다. 두 Provider를 만들어야할 것으로 생각할 수 있지만, 하나는 AsyncProvider이고, 하나는 NotifierProvider로 대화해야 한다면 그것은 비효율적입니다. 다행히도 이를 처리하는 방법이 있습니다.\n\n다음 코드는 AsyncProvider를 사용하고 로드된 데이터를 NotifierProvider처럼 사용하는 방법을 보여줍니다.\n\n```js\n// home.dart\n\nclass MyHomePage extends StatelessWidget {\n  const MyHomePage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(),\n      body: Consumer(\n        builder: (context, ref, _) {\n          // Foo Provider를 가져와 상태를 설정합니다.\n          // State Provider처럼 사용합니다.\n          ref.watch(fooControllerProvider.notifier).foo = Foo(3);\n          // UI에서 Foo 사용 (.requireValue는 변경 사항을 청취할 수 있도록 사용됨)\n          final foo = ref.watch(fooControllerProvider).requireValue;\n          // .when을 사용하여 미래에서 UI를 렌더링합니다.\n          return Text('bar: ${foo.bar}, baz: ${foo.baz}');\n        },\n      ),\n    );\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\nRiverpod는 플러터에서 상태 관리의 가장 추천되는 방법으로 나타났으며 완전히 반응적인 상태 프레임워크로 발전했습니다.\n\n나중에 Provider와 같은 다른 패키지는 더 이상 유지되지 않을 수 있으므로 Riverpod를 배우는 것이 중요합니다 (물론 먼 훗날입니다). 또한 Riverpod는 새로운 제너레이터 덕분에 상태를 효과적으로 관리할 수 있는 유연성과 제어성을 제공하여 build_runner를 사용해 강력하고 메모리를 고려한 프로바이더를 쉽게 만들 수 있습니다.\n\n이 글을 만드는 과정에서 도움이 된 멋진 자료를 제공해 준 다음 분들께 큰 박수를 보냅니다. 🎉\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- CodeWithAndrea\n- Adnanjpg\n- rrouselgit\n\n이 글이 도움이 되셨기를 바랍니다. 만약 도움이 되었다면, 더 많은 튜토리얼, 경험, 그리고 안내서가 포함된 다른 글도 자유롭게 읽어보세요!\n\n하나님을 신뢰합니다 🙏🏾","ogImage":{"url":"/assets/img/2024-06-21-HowtouseRiverpod20GeneratorinyourFlutterProject_0.png"},"coverImage":"/assets/img/2024-06-21-HowtouseRiverpod20GeneratorinyourFlutterProject_0.png","tag":["Tech"],"readingTime":15},{"title":"크로스 플랫폼 개발 대결 MVP를 위한 FlutterFlow vs React Native vs Flutter 비교","description":"","date":"2024-06-21 20:17","slug":"2024-06-21-Cross-PlatformDevelopmentShowdownFlutterFlowvsReactNativevsFlutterforMVPs","content":"\n\n\u003cimg src=\"/assets/img/2024-06-21-Cross-PlatformDevelopmentShowdownFlutterFlowvsReactNativevsFlutterforMVPs_0.png\" /\u003e\n\n경쟁이 치열한 디지털 환경에서, 모바일 앱을 개발하려는 기업들은 다수의 결정을 직면하게 됩니다. 이 중 가장 중요한 결정 중 하나는 개발 프레임워크의 선택입니다. 최소 실현 가능 제품(MVP)을 신속하고 비용 효율적으로 출시하려는 사용자들을 위해, 크로스 플랫폼 개발이 전략적인 해결책으로 부상했습니다. 본 철저한 분석에서는 FlutterFlow, React Native, Flutter 세 가지 인기 있는 프레임워크를 살펴보며 그들의 강점과 약점을 특히 MVP 개발의 맥락에서 자세히 살펴보겠습니다. 각 프레임워크가 제공하는 금전적 이점, 품질 고려사항, 그리고 독특한 장점을 강조하여 FlutterFlow의 장점에 특히 중점을 두겠습니다.\n\n# 소개: 신속한 MVP의 필수성\n\nMVP를 만드는 것은 앱 아이디어를 검증하고 사용자 피드백을 수집하며 초기 도입자를 확보하려는 기업들에게 중요한 단계입니다. 주요 목표는 출시까지의 시간을 최소화하고 개발 비용을 줄이면서 품질 높은 사용자 경험을 보장하는 것입니다. 개발 프레임워크의 선택은 이러한 목표에 상당한 영향을 미칠 수 있습니다. 이는 금전 투자와 최종 제품 품질 양쪽에 영향을 미치며, 최종 제품의 품질에 영향을 줄 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# FlutterFlow: 시각적 도구를 통한 개발 단순화\n\n# 개요\n\nFlutterFlow는 Google의 Flutter 프레임워크를 기반으로 한 로우코드 플랫폼으로, 시각적 인터페이스를 통해 신속한 개발을 가능하게 하는 것이 목적입니다. 개발자와 비개발자 모두가 쉽게 고품질의 크로스 플랫폼 앱을 만들 수 있도록 합니다.\n\n# 속도와 효율\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nFlutterFlow의 뛰어난 기능 중 하나는 속도입니다. 시각적 드래그 앤 드롭 인터페이스를 통해 빠른 프로토타이핑 및 개발을 할 수 있어 MVP를 구축하는 데 필요한 시간을 크게 줄일 수 있습니다. 이는 빠르게 시장에 진입하고 사용자 피드백에 따라 적응해야 하는 비즈니스에 특히 유용합니다.\n\n## 비용 효율성\n\n재정적 측면에서 FlutterFlow는 상당한 비용 절감을 제공합니다. 단축된 개발 시간은 직접 인력 비용을 줄여줍니다. 게다가 FlutterFlow는 Flutter 기반으로 구축되어 iOS와 Android 모두에 대해 단일 코드베이스를 지원하기 때문에 별도의 개발팀이 필요 없어지며 더 많은 비용을 절감할 수 있습니다.\n\n## 품질과 성능\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nFlutterFlow의 저코드 특성에도 불구하고 품질을 절대 양보하지 않아요. 플러터의 견고한 프레임워크를 활용하여, 여러 플랫폼에서 고품질 성능과 일관된 사용자 경험을 제공합니다. 미리 구축된 위젯과 구성 요소는 iOS와 Android 모두에 최적화되어 있어, 광범위한 사용자 정의가 필요 없이 자연스러운 느낌을 줍니다.\n\n# OneQ의 FlutterFlow 전문 지식\n\n원큐에서는 우수한 MVP를 제공하는 데 FlutterFlow를 효과적으로 활용합니다. 우리 팀은 긴 시한과 예산 내에서 전자상거래 플랫폼부터 핀테크 솔루션까지 다양한 애플리케이션을 성공적으로 개발해 왔습니다. 예를 들어, 최근에는 고객이 전통적인 네이티브 접근 방식에 비해 개발 비용을 50% 이상 절약할 수 있도록 한 소매 관리 앱을 단 4주 만에 완성했어요.\n\n# React Native: 성숙한 크로스 플랫폼 솔루션\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 개요\n\nFacebook에서 개발한 React Native는 JavaScript와 React를 사용하여 모바일 앱을 구축할 수있게 해주는 널리 사용되는 프레임워크입니다. React Native는 거의 네이티브 수준의 성능과 풍부한 라이브러리 및 도구 생태계를 제공합니다.\n\n# 개발 속도\n\nReact Native는 재사용 가능한 구성 요소와 실시간으로 변경 사항을 볼 수 있게 해주는 핫 리로딩 기능으로 비교적 빠른 개발을 가능하게 합니다. 그러나 MVP를 위한 개발 일정을 연장할 수 있는 플러터플로우의 시각적 인터페이스에 비해 더 많은 코딩이 필요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 비용 측면\n\nReact Native는 플랫폼 간에 코드 재사용을 허용하지만 종종 플랫폼별 조정이 필요할 수 있어 개발 시간과 비용이 증가할 수 있습니다. 또한 비즈니스는 때로는 더 높은 급여를 요구할 수 있는 JavaScript 및 React에 능통한 개발자에 투자해야 합니다.\n\n# 품질 및 성능\n\nReact Native는 거의 네이티브 수준의 사용자 경험을 제공하지만, 성능은 때로는 매우 복잡한 애플리케이션에 대해 문제가 될 수 있습니다. 네이티브 코드를 연결하는 필요로 인해 성능 병목 현상이 발생하고 유지 관리의 복잡성이 증가할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 유지보수 및 확장성\n\nReact Native의 다양한 라이브러리 지원과 커뮤니티 기여는 한편으로는 큰 도움이지만, 의존성 관리와 장기적 안정성 확보는 도전이 될 수 있습니다. 증가하는 유지보수 비용을 감안해야 합니다.\n\n# 플러터: 구글의 강력한 프레임워크\n\n# 개요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플러터(Flutter)는 구글에서 개발된 오픈 소스 UI 환경 구성 도구로, 모바일, 웹 및 데스크톱용 네이티브 컴파일된 애플리케이션을 단일 코드베이스로 구축할 수 있습니다. 플러터플로(FlutterFlow)와 달리 플러터는 완전한 코딩이 필요하며, 더 많은 유연성과 제어를 제공합니다.\n\n# 개발 속도\n\n플러터는 핫 리로드 기능으로 빠른 개발을 가능케하지만, 일반적으로 플러터플로보다 수동 코딩이 필요하기 때문에 더 많은 시간이 소요됩니다. 다트(Dart) 프로그래밍 언어는 강력하지만, 자바스크립트와 비교할 때 학습 곡선이 가파르기 때문에 초기 개발 단계의 속도가 느려질 수 있습니다.\n\n# 재정적 고려 사항\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nFlutte의 단일 코드베이스는 원시 개발과 비교하여 전체 개발 비용을 줄입니다. 그러나 여전히 Dart에 능숙한 숙련된 개발자가 필요하며 이는 인재 풀을 제한하고 잠재적으로 급여비용을 증가시킬 수 있습니다.\n\n# 품질과 성능\n\nFlutter는 높은 품질의 고성능 애플리케이션을 제공하는 데 뛰어납니다. 그 렌더링 엔진은 iOS와 Android의 네이티브 외관과 느낌을 흉내 낼 수 있는 매우 사용자 정의 가능한 UI를 가능하게 합니다. 이는 원활한 사용자 경험을 우선시하는 비즈니스에 우수한 선택입니다.\n\n# 장기적인 유지보수\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플러터의 안정성과 구글의 지원은 오랜 기간 동안 지원 및 업데이트를 보장하며, 기업이 MVP를 완벽한 애플리케이션으로 확장하기를 원하는 경우 신뢰할 만한 선택지가 됩니다. 포괄적인 문서와 성장하는 커뮤니티도 유지보수 및 확장성을 쉽게 할 수 있도록 도와줍니다.\n\n# 재무 비교: 플러터플로우 vs. 리액트 네이티브 vs. 플러터\n\n# 초기 개발 비용\n\n- 플러터플로우: 시각적 개발 접근 방식으로 인해 개발 주기가 짧아지고 필요한 개발자가 적어져 초기 비용이 30–50% 절감됩니다.\n- 리액트 네이티브: 코드 재사용으로 비용을 절감할 수 있지만, 플랫폼별 조정이 필요할 수 있어 초기 비용이 증가할 수 있습니다.\n- 플러터: 단일 코드베이스를 통해 비용을 줄이지만, 숙련된 Dart 개발자가 필요하며, 이로 인해 급여 비용이 증가할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 유지 보수 및 업데이트\n\n- FlutterFlow: 단일 코드베이스로 유지 관리가 간단하여 지속적인 비용이 낮아집니다.\n- React Native: 의존성을 관리하는 복잡성으로 인해 유지 보수 비용이 증가할 수 있습니다.\n- Flutter: 구글의 지원을 받아 지속적인 업데이트와 지원으로 오랜 기간 동안 신뢰할 수 있습니다.\n\n# 시장 진입 시간\n\n- FlutterFlow: 신속한 개발로 시장 진입 시간을 단축하며, 사용자 피드백 모으고 초기 수익을 창출하는 데 중요합니다.\n- React Native: 네이티브 개발보다 빠르지만 FlutterFlow보다 수동 코딩이 많아 개발 시간이 더 걸립니다.\n- Flutter: 높은 품질을 가진 빠른 개발이 가능하지만 처음에는 빠른 학습 곡선이 필요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론: MVP에 적합한 프레임워크 선택하기\n\n고품질이면서 비용 효율적인 MVP를 개발하려는 기업들에게는 개발 프레임워크 선택이 매우 중요합니다. FlutterFlow는 신속한 개발, 비용 절감 및 견고한 성능으로 빠르고 효율적으로 시장에 진입하고자 하는 기업들에게 이상적인 선택지입니다.\n\nReact Native는 성숙하고 널리 지원되지만, 플랫폼별 조정이 필요하기 때문에 더 많은 개발 시간과 높은 비용을 요구할 수 있습니다. Flutter는 뛰어난 품질과 성능을 제공하지만, 숙련된 개발자와 더 오랜 초기 설정이 필요합니다.\n\n원큐(OneQ)에서는 FlutterFlow 전문 지식을 바탕으로 고객 기대치를 능가하는 최고 수준의 MVP를 제공합니다. FlutterFlow를 선택하고 저희 경험丰부한 팀과 협력하면, 첨단 기술을 활용하여 목표를 더 빠르고 더 경제적으로 달성할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# OneQ와 함께하세요!\n\n저렴하고 고품질 MVP를 통해 모바일 앱 아이디어를 실현하고 싶으신가요? 오늘 바로 OneQ에 연락하여 저희 FlutterFlow 전문가들이 프로세스를 안내하도록 도와드릴 수 있도록 해보세요. 선명하고 성공적인 론칭을 위해 최선을 다하겠습니다.","ogImage":{"url":"/assets/img/2024-06-21-Cross-PlatformDevelopmentShowdownFlutterFlowvsReactNativevsFlutterforMVPs_0.png"},"coverImage":"/assets/img/2024-06-21-Cross-PlatformDevelopmentShowdownFlutterFlowvsReactNativevsFlutterforMVPs_0.png","tag":["Tech"],"readingTime":5},{"title":"FlutterFlow와 네이티브 모바일 앱 개발 비교 비용과 품질 - MVP 기준","description":"","date":"2024-06-21 20:15","slug":"2024-06-21-MoneyandQualityMVPinFlutterFlowvsNativeMobileAppDevelopment","content":"\n\n\u003cimg src=\"/assets/img/2024-06-21-MoneyandQualityMVPinFlutterFlowvsNativeMobileAppDevelopment_0.png\" /\u003e\n\n휴대폰 앱 개발의 빠르게 변화하는 풍경에서 효율성, 품질, 비용 효율성을 위한 탐구는 모든 비즈니스 전략의 최전선에 머무릅니다. 기업들이 아이디어를 검증하고 시장 점유율을 빠르게 확보하기 위해 최소 기능 제품(MVP)을 만들려는 노력 속에서 개발 프레임워크의 선택은 예산 및 최종 제품 품질에 중대한 영향을 미칠 수 있습니다. 이 포괄적인 분석에서, 우리는 FlutterFlow와 기본 모바일 앱 개발을 사용하는 세심한 점을 파헤치며 비즈니스 의사 결정자에게 중요한 재정 혜택과 품질 고려 사항을 강조합니다.\n\n# 소개: 휴대폰 앱 개발에서 MVP의 중요성\n\n최소 기능 제품(MVP)을 만드는 것은 특히 치열한 휴대폰 앱 시장에서 중요한 제품 개발 전략입니다. MVP를 통해 기업은 자사의 개념을 시험하고 사용자 피드백을 수집하며 자원을 투입하지 않고 데이터 기반 결정을 내릴 수 있습니다. 그러나 MVP를 구축하는 데 선택한 개발 프레임워크는 프로세스를 가속화하고 비용을 줄일 수도 있고, 반대로 비용 증가와 시간이 늘어날 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# FlutterFlow: MVP 개발을 혁신하는 중\n\nFlutterFlow는 Google의 Flutter 프레임워크를 활용한 강력한 시각적 앱 빌더로, 모바일 앱 개발 분야에서 게임 체인저로 등장했습니다. 기존 방법에 필요한 노력의 일부분으로 고품질의 크로스 플랫폼 애플리케이션을 만들 수 있게 해줍니다.\n\n# 속도와 효율성\n\nFlutterFlow의 주요 장점 중 하나는 MVP를 개발하는 놀라운 속도입니다. 시각적 인터페이스를 통해 빠른 프로토타이핑과 즉시 미리보기가 가능하며, 피드백을 바탕으로 신속하게 반복할 수 있습니다. iOS와 Android를 위한 별도의 코드베이스가 필요한 네이티브 개발과 달리, FlutterFlow의 단일 코드베이스 접근 방식은 개발 시간을 크게 줄여줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 비용 효율성\n\n재정적인 측면에서, FlutterFlow는 기업에게 매력적인 이유를 제시합니다. 개발 시간 감소는 직간접적으로 노동 비용을 낮추는 결과로 이어집니다. 뿐만 아니라, 동일한 코드베이스를 여러 플랫폼에 배포할 수 있는 능력은 iOS 및 안드로이드 개발자의 별도 팀 필요성을 제거하여 추가 지출을 줄입니다.\n\n# 품질과 일관성\n\n가속화된 개발 프로세스에도 불구하고, FlutterFlow는 품질에 타협하지 않습니다. 견고한 Flutter 프레임워크 위에 구축되어 고품질의 성능과 일관된 사용자 경험을 여러 플랫폼에서 제공합니다. FlutterFlow 내에서 제공되는 위젯과 구성 요소는 iOS와 안드로이드 모두에서 최적화되어 있어 플랫폼별 조정이 필요하지 않고도 네이티브와 유사한 느낌을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 케이스 스터디: OneQ의 FlutterFlow 전문 지식\n\nOneQ에서는 FlutterFlow의 힘을 이용하여 우리 고객을 위한 훌륭한 MVP를 제공했습니다. 저희 전문가 팀은 금융 기술 솔루션부터 전자 상거래 플랫폼까지 다양한 애플리케이션을 개발했으며, 모두 엄격한 기한과 예산 내에서 개발되었습니다. 이 중 하나의 예시로, 단 6주 만에 컨셉에서 배포까지 이뤄낸 금융 관리 앱의 급속한 개발이 있습니다. 해당 앱은 원래 방식에 비해 개발 비용을 40% 이상 절감하여 우리 고객에게 혜택을 주었습니다.\n\n# 네이티브 모바일 앱 개발: 전통적인 방식\n\n네이티브 모바일 앱 개발은 iOS와 Android를 위한 개별 코드베이스를 활용하는 것으로, 수년간 산업 표준으로 자리를 잡았습니다. 특정 장점을 제공하지만, 특히 MVP 개발 문맥에서 상당한 어려움을 겪을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 성능 및 사용자 정의\n\n네이티브 개발은 탁월한 성능과 깊은 사용자 정의를 제공합니다. 애플리케이션은 플랫폼별 특징과 하드웨어 기능을 최대한 활용하도록 최적화될 수 있습니다. 이러한 최적화 수준은 고성능 컴퓨팅 능력이 필요하거나 장치별 기능에 크게 의존하는 앱에서 중요할 수 있습니다.\n\n# 개발 시간 및 비용\n\n그러나 네이티브 개발의 장점은 비용이 발생합니다. iOS 및 Android를 위한 별도의 코드베이스를 생성하고 유지하는 것은 시간이 많이 걸리며 리소스가 많이 소모됩니다. 기업은 각 플랫폼에 대한 전문 지식을 갖춘 대규모 개발 팀에 투자해야 하며, 이는 노동비용을 증가시킵니다. 게다가, 모든 변경 또는 업데이트는 두 코드베이스에 모두 반영되어야 하며, 이로 인해 개발 주기가 더 길어지고 비용이 증가할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 품질 보증 및 유지 관리\n\n네이티브 개발에서의 품질 보증은 여러 플랫폼에서 테스트가 필요하기 때문에 더 복잡할 수 있습니다. iOS 및 Android 간 일관된 사용자 경험을 보장하기 위해서는 철저한 테스트가 필요하며 종종 오랜 디버깅 및 유지 관리 단계를 필요로 합니다. 이로 인해 출시가 지연될 뿐만 아니라 추가 비용이 발생합니다.\n\n# 금융 비교: FlutterFlow 대 네이티브 개발\n\n보다 명확한 그림을 제공하기 위해 MVP 개발을 위해 FlutterFlow를 선택하면 네이티브 개발보다 발생하는 금융적 영향을 분석해보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 초기 개발 비용\n\n- FlutterFlow: 단일 코드베이스로 크로스 플랫폼 앱을 구축할 수 있는 기능은 초기 개발 비용을 약 30-50% 절감시킵니다. 시각적 인터페이스는 프로토타입 단계를 가속화하여 더 빨리 MVP를 제공합니다.\n- 네이티브 개발: iOS 및 안드로이드용 별도 팀이 필요하여 노동 비용이 2배가 됩니다. 확장된 개발 시간으로 초기 투자가 더욱 증가합니다.\n\n# 유지 및 업데이트\n\n- FlutterFlow: 단일 코드베이스로 유지보수 및 업데이트가 간단해지므로 지속적인 비용이 줄어듭니다. 어떤 변경 사항이든 한 번에 구현하여 모든 플랫폼에 반영됩니다.\n- 네이티브 개발: 유지보수는 두 코드베이스를 별도로 업데이트하고 테스트해야 하므로 지속적인 비용과 업데이트 주기가 더 길어집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Time-to-Market\n\n- FlutterFlow: 빠른 개발 과정은 기업이 빠르게 사용자 피드백을 수집하고 수익을 창출할 수 있도록하여 빨리 시장에 진입할 수 있는 시간을 제공합니다.\n- 네이티브 개발: 긴 개발 주기로 인해 출시가 지연되어 사용자 피드백 및 잠재적인 수익 창출이 미뤄집니다.\n\n# 결론: FlutterFlow의 전략적 장점\n\nMVP를 효율적으로 비용 효율적으로 개발하려는 기업에게 FlutterFlow는 전통적인 네이티브 개발보다 전략적 이점을 제공합니다. 개발 프로세스를 최적화하고 비용을 절감하며 높은 품질을 유지할 수 있는 능력으로 기업이 아이디어를 확인하고 빠르게 시장에 진입할 수 있도록 하는 이상적인 선택지입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nOneQ에서 FlutterFlow 전문 지식을 바탕으로 우수한 MVP를 제공하여 고객 기대치를 뛰어넘는 것에 자부심을 가지고 있습니다. FlutterFlow를 선택하고 우리 같은 경험이 풍부한 개발자와 파트너십을 맺음으로써 기업은 최신 기술을 활용하여 더 빠르고 더 저렴하게 목표를 달성할 수 있습니다.\n\n# OneQ가 도와드립니다!\n\n비용 효율적이고 고품질의 MVP로 모바일 앱 아이디어를 구현하실 준비가 되셨나요? OneQ에 연락하여 FlutterFlow 전문가들이 프로세스를 안내해주어 원활하고 성공적인 런칭을 보장받을 수 있도록 도와드릴게요.","ogImage":{"url":"/assets/img/2024-06-21-MoneyandQualityMVPinFlutterFlowvsNativeMobileAppDevelopment_0.png"},"coverImage":"/assets/img/2024-06-21-MoneyandQualityMVPinFlutterFlowvsNativeMobileAppDevelopment_0.png","tag":["Tech"],"readingTime":4},{"title":"Flutter 프라이빗 패키지 만드는 방법","description":"","date":"2024-06-21 20:13","slug":"2024-06-21-FlutterCreatePrivatePackages","content":"\n\n\n![Flutter Create Private Packages](/assets/img/2024-06-21-FlutterCreatePrivatePackages_0.png)\n\nFlutter 패키지와 함께한 나의 여정은 처음부터 하나를 만들어야 했을 때 시작되었습니다. 오늘은 이 주제에 대한 나의 경험과 통찰을 공유하는 것에 흥분하고 있습니다. Google I/O’23에서도 이에 대해 논의했지만, 여기에서는 개념을 이해하고 자신만의 패키지를 구축하려는 분들을 위한 내용입니다.\n\n# 패키지와 플러그인 이해\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n패키지는 라이브러리, 리소스, 앱, 테스트, 이미지, 글꼴 및 예시로 이루어진 다트 코드의 자체 포함 컬렉션이에요. 이것들은 어떤 네이티브 플랫폼에도 독립적이에요. 예를 들어, UI 구성 요소의 구현에 사용될 수 있어요.\n\n플러그인\n\n플러그인은 플랫폼별 및 다트 코드로 작성된 API를 포함하고 있어요. 플러그인은 카메라와 같은 기기 특성에 접근하기 위해 필수적이에요.\n\n# 의존성 관리 \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n패키지 생성의 구성을 자세히 살펴보기 전에 의존성 관리가 무엇인지 이해하는 것이 중요합니다. 개발자들이 플러터 프로젝트에서 사용할 수 있는 의존성을 추적하고 관리할 수 있도록 해줍니다. 이를 통해 프로젝트에 빠르게 기능을 구현할 수 있는 패키지의 버전을 추적하고, 이러한 패키지들이 서로 호환되도록 보장할 수 있습니다.\n\n프로젝트에 패키지가 추가되면 의존성이 됩니다. 세 가지 유형의 의존성 구성이 있습니다:\n\n- dependencies\n- dev dependencies\n- dependency overrides\n\n이 구성 간의 차이는 간단합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- dependencies와 dependency_overrides은 컴파일 후 프로젝트에서 사용할 수 있는 패키지입니다.\n- dev_dependencies은 개발 환경에서만 사용할 수 있습니다.\n\n의존성 분류\n\n의존성은 다음과 같이 분류할 수 있습니다:\n\n- 중간 의존성: 프로젝트와 직접 관련된 의존성입니다.\n- 전이적 의존성: 다른 패키지에 의존하는 패키지입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 버전 관리\n\n의존성이 추가되고 제약 조건과 함께 추가되었을 때, 앱에서 생성된 락 파일은 추가된 특정 버전만 사용합니다.\n\n![image](/assets/img/2024-06-21-FlutterCreatePrivatePackages_1.png)\n\n위의 예시 이미지를 살펴보면, package_a 및 package_c가 의존성에 추가되었으며, package_b는 개발 의존성에 있고 package_c는 의존성 재정의에 있습니다. 락 파일은 \"의존성\"에 추가된 것이 아닌 버전 2.1.0의 Package_c를 사용할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 플러터 패키지 만들기\n\n자, 이제 실제 플러터 패키지를 만드는 과정에 대해 알아봅시다. 다음 명령어를 사용하여 패키지를 생성하세요:\n\n```bash\nflutter packages pub publish\n```\n\n- [packages] — 플러터 프로젝트에서 패키지를 관리합니다.\r\n- [pub] — 패키지에 문제나 누락된 정보를 확인하는 데 사용되는 유효성 검사기입니다.\r\n- [publish] — 패키지를 게시하는 명령어입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n패키지는 사용 사례에 따라 공개적으로 또는 비공개적으로 배포할 수 있습니다. 비공개 패키지는 pub.dev에 게시할 수 없습니다. 대신 GitHub와 같은 플랫폼이나 서비스로 다트 저장소에 호스팅할 수 있습니다. 일부 서비스로는 다음이 있습니다:\n\n- OnePub\n- Cloudsmith\n- Ifrog 저장소\n- Jetbrains Space\n\n# OnePub을 활용하기\n\nOnePub에 연결하여 패키지를 게시하려면 다음 단계를 따르세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nflutter pub global active onepub \ncd \u003c내 패키지\u003e\nflutter pub publish\n```\n\n패키지를 비공개로 호스팅하려면 publish를 사용해 저장소를 가리키도록합니다:\n\n![이미지](/assets/img/2024-06-21-FlutterCreatePrivatePackages_2.png)\n\n한 번 발행되면 패키지를 비공개로 호스팅하여 권한이있는 사용자에게만 액세스 가능하도록 할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\u003cimg src=\"/assets/img/2024-06-21-FlutterCreatePrivatePackages_3.png\" /\u003e\n\n# 보안 고려 사항\n\n- 어택에게 코드를 역공학으로 복원하기 어렵게 만들기 위해 --obfuscate를 사용하세요.\n- 보안 취약점이 소개되지 않도록 코드와 종속성을 자주 검토하세요.\n- 제 3자 종속성을 사용할 경우 보안 및 취약성을 확인하세요.\n- 공격자가 미인가된 액세스를 얻지 못하도록 민감한 정보를 삭제하세요.\n- 취약점을 검사하여 보안 문제를 식별하고 해결하는 데 도움이 됩니다.\n\n여기서 플러터 패키지를 만드는 방법에 대해 알아보았습니다. 필요한 경우 댓글에서 추가로 의견을 남겨주세요. 함께 학습할 수 있도록 도와드리겠습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 참고 자료\n\n패키지 발행하기\n\nDart 패키지를 pub.dev에 발행하는 방법을 배우세요.\n\n![이미지](/assets/img/2024-06-21-FlutterCreatePrivatePackages_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\nDart\n\n![image](/assets/img/2024-06-21-FlutterCreatePrivatePackages_5.png)\n\nDeveloping packages \u0026 plugins\n\nHow to write packages and plugins for Flutter.\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래가 markdown 형식으로 변환됐습니다.\n\n![Flutter Logo](/assets/img/2024-06-21-FlutterCreatePrivatePackages_6.png)\n\n![Package dependencies](/assets/img/2024-06-21-FlutterCreatePrivatePackages_7.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앱에 다른 패키지를 추가해보세요. 패키지 위치, 버전 제한 등을 명시하세요.\n\n![image1](/assets/img/2024-06-21-FlutterCreatePrivatePackages_8.png)\n\nDart\n\n![image2](/assets/img/2024-06-21-FlutterCreatePrivatePackages_9.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저에 대해\n\n안녕하세요! 제 이름은 Zaahra입니다. 구글 Women Techmakers 대사로 활동하고 있습니다. 사람들을 지도하고 기술적인 내용을 쓰는 것을 즐기며, 개발자로서 여러분의 여정을 도울 수 있는 기술 콘텐츠에 대해 글을 쓰는 것을 즐깁니다. 또한 실생활 문제를 해결하기 위해 무언가를 만드는 것을 즐깁니다.\n\n제게 연락하려면:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마크다운 형식으로 변환하겠습니다.\n\nLinkedIn: [https://www.linkedin.com/in/faatimah-iz-zaahra-m-0670881a1/](https://www.linkedin.com/in/faatimah-iz-zaahra-m-0670881a1/)\n\nX (이전 Twitter): _fz3hra\n\nGitHub: [https://github.com/fz3hra](https://github.com/fz3hra)\n\n건배,\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nUmme Faatimah-Iz-Zaahra Mujore | Google Women TechMakers 대사 | 소프트웨어 엔지니어","ogImage":{"url":"/assets/img/2024-06-21-FlutterCreatePrivatePackages_0.png"},"coverImage":"/assets/img/2024-06-21-FlutterCreatePrivatePackages_0.png","tag":["Tech"],"readingTime":5},{"title":"Flutter Web Github Pages에 배포하는 방법","description":"","date":"2024-06-21 20:12","slug":"2024-06-21-FlutterWebGithubpages","content":"\n\n- 이미 \"your_id.github.io\" 레포지토리를 생성했어요\n- 이미 플러터 웹 프로젝트를 만들었어요\n\n- 도메인을 소유하고 계신다면, 플러터 프로젝트 디렉토리로 이동해주세요\n\n```sh\n$ cd my_flutter_directory\n$ echo -e 'sidcode.me' \u003e web/CNAME\n$ cat web/CNAME         \nsidcode.me\n```\n\n2. 플러터 웹 빌드\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n$ flutter build web --release\n------------------------------  \n폰트 자산 \"CupertinoIcons.ttf\"이 트리 쉐이크되어 257628바이트에서 1172바이트로 줄었습니다 (99.5% 감소). 앱을 빌드할 때 --no-tree-shake-icons 플래그를 제공하면 트리 쉐이킹을 비활성화할 수 있습니다.\n폰트 자산 \"MaterialIcons-Regular.otf\"이 트리 쉐이크되어 1645184바이트에서 7760바이트로 줄었습니다 (99.5% 감소). 앱을 빌드할 때 --no-tree-shake-icons 플래그를 제공하면 트리 쉐이킹을 비활성화할 수 있습니다.\nlib/main.dart를 웹용으로 컴파일 중...                           1,407밀리초\n✓ build/web가 생성되었습니다\n```\n\n3. flutter build web으로 생성된 웹 페이지로 이동하기\n\n```js\n$ cd build/web/\n$ ls -all                                                   \ndrwxr-xr-x sidcode staff 480 B  Thu Jun 20 15:56:49 2024  .\ndrwxr-xr-x sidcode staff  96 B  Thu Jun 20 15:56:47 2024  ..\n.rw-r--r-- sidcode staff  32 B  Thu Jun 20 15:56:49 2024  .last_build_id\ndrwxr-xr-x sidcode staff 320 B  Thu Jun 20 15:56:48 2024  assets\ndrwxr-xr-x sidcode staff 320 B  Thu Jun 20 15:56:47 2024  canvaskit\n.rw-r--r-- sidcode staff  13 B  Thu Jun 20 15:51:32 2024  CNAME\n.rw-r--r-- sidcode staff 917 B  Wed Feb  1 13:05:06 2023  favicon.png\n.rw-r--r-- sidcode staff 7.6 KB Tue Jun  4 21:05:58 2024  flutter.js\n.rw-r--r-- sidcode staff 7.9 KB Thu Jun 20 15:56:48 2024  flutter_bootstrap.js\n.rw-r--r-- sidcode staff 8.0 KB Thu Jun 20 15:56:49 2024  flutter_service_worker.js\ndrwxr-xr-x sidcode staff 192 B  Thu Jun 20 15:56:48 2024  icons\n.rw-r--r-- sidcode staff 1.2 KB Thu Jun 20 15:56:48 2024  index.html\n.rw-r--r-- sidcode staff 1.5 MB Thu Jun 20 15:47:11 2024  main.dart.js\n.rw-r--r-- sidcode staff 928 B  Thu Jun 20 15:35:13 2024  manifest.json\n.rw-r--r-- sidcode staff 102 B  Thu Jun 20 15:56:48 2024  version.json\n```\n\n4. git push\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n$ git init \u0026\u0026 git add . \u0026\u0026 git commit -m  \"init\" \u0026\u0026 git branch -M gh-pages\n===============================================\n$ git remote add origin https://github.com/[your_id]/[repo_name].git\n ******** 토큰이 없는 경우 혹은 깃허브 토큰이 필요한 경우 선택 \n$ git remote add origin https://[your_id]:[your_token]@github.io/{your_id}/{repo_name}.git\n===============================================\n$ git push -u origin gh-pages\n------------------------------------------------\n오브젝트 나열 중: 43, 완료.\n오브젝트 개수 측정 중: 100% (43/43), 완료.\nDelta 압축이 최대 10개의 스레드로 이용됨\n오브젝트 압축 중: 100% (37/37), 완료.\n오브젝트 쓰기 중: 100% (43/43), 5.50 MiB | 5.07 MiB/s, 완료.\n총 43 (델타 6), 재사용 0 (델타 0), 팩 재사용 0 (0개로부터)\nremote: 변화 해결 중: 100% (6/6), 완료.\nTo https://github.com/sidcodeme/sidcodeme.github.io.git\n * [새 브랜치]      gh-pages -\u003e gh-pages\n'gh-pages' 브랜치가 'origin/gh-pages'를 추적하도록 설정되었습니다.\n```\n\n5. 깃허브 페이지 설정\n\n\u003cimg src=\"/assets/img/2024-06-21-FlutterWebGithubpages_0.png\" /\u003e\n\n작업 완료! 홈페이지로 이동합시다!!!!!\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```Markdown\n![Image](/assets/img/2024-06-21-FlutterWebGithubpages_1.png)\n```","ogImage":{"url":"/assets/img/2024-06-21-FlutterWebGithubpages_0.png"},"coverImage":"/assets/img/2024-06-21-FlutterWebGithubpages_0.png","tag":["Tech"],"readingTime":3},{"title":"undefined","description":"","date":"2024-06-21 20:10","slug":"undefined","content":"\n\nAudioPlayers는 강력한 Flutter 플러그인으로, 여러 플랫폼에서 동시에 여러 오디오 파일을 재생할 수 있는 능력을 제공합니다. 다양한 기능을 갖춘 이 플러그인은 매력적인 오디오 경험을 제공하기에 이상적인 솔루션이 될 것입니다.\n\n시작하기\n\nFlutter 프로젝트에 AudioPlayers를 통합하는 것은 매우 간단합니다:\n\n```js\nimport 'package:audioplayers/audioplayers.dart';\n\n// AudioPlayer 인스턴스를 초기화합니다.\nfinal player = AudioPlayer();\n\n// URL에서 오디오 파일을 로드하고 재생합니다.\nawait player.play(UrlSource('https://example.com/my-audio.wav'));\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n주요 특징\n\n- 다중 플랫폼 지원: AudioPlayers는 Android, iOS, Linux, macOS, Windows 및 웹에서 심장을 가다듬는 시계의 역할을 합니다.\n- 동시 재생: 여러 오디오 트랙을 동시에 재생하여 몰입형 오디오 체험을 가능하게 합니다.\n- 다양한 오디오 소스: 로컬 파일, URL 및 스트림에서 재생을 지원하여 오디오 원본에서 유연성을 제공합니다.\n- 재생 제어: 오디오 스트림을 쉽게 일시 중지, 다시 시작, 정지, 시간 설정 및 볼륨 조절할 수 있습니다.\n- 오디오 효과: 속도 조절, 볼륨 정규화, 반복 등의 오디오 효과를 적용하여 오디오 출력을 향상시킬 수 있습니다.\n\n코드 예시\n\nURL에서 오디오 재생하기:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\nimport 'package:audioplayers/audioplayers.dart';\n\n// AudioPlayer 인스턴스를 초기화합니다\nfinal player = AudioPlayer();\n\n// URL에서 오디오 파일을 로드하고 재생합니다\nawait player.play(UrlSource('https://example.com/my-audio.wav'));\n```\n\n재생 제어:\n\n```dart\n// 오디오 재생을 일시 중지합니다\nplayer.pause();\n\n// 오디오 재생을 다시 시작합니다\nplayer.resume();\n\n// 오디오 재생을 중지합니다\nplayer.stop();\n\n// 오디오 파일에서 특정 위치로 이동합니다 (초 단위)\nplayer.seek(Duration(seconds: 10));\n\n// 오디오 재생의 볼륨을 조절합니다\nplayer.setVolume(0.5);\n```\n\n오디오 효과 적용하기:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 오디오 재생 속도를 빠르게 설정합니다\nplayer.setPlaybackRate(1.5);\n\n// 오디오 볼륨을 정규화합니다\nplayer.setReleaseMode(ReleaseMode.STOP);\n\n// 오디오 파일을 무한정 반복 재생합니다\nplayer.setLoopMode(LoopMode.LOOP);\n```\n\n시작하기\n\nAudioPlayers를 사용하는 방법에 대한 깊은 이해를 얻으려면 포괄적인 시작하기 튜토리얼을 참조하십시오:\n\nAudioPlayers와 함께 시작하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n**기능 동등성 표**\n\n서로 다른 플랫폼 간의 기능 가용성을 이해하기 위해 기능 동등성 표를 살펴보세요:\n\n**기능 동등성 표**\n\n결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAudioPlayers는 플러터 앱에서 매혹적인 오디오 체험을 만들기 위한 포괄적인 기능 세트를 제공하여 여러분을 더욱 강력하게 만들어줍니다. AudioPlayers의 다재다능성을 받아들이고 오디오 재생 능력을 향상해보세요!\n\n플러터와 다트에 대한 더 많은 정보는 웹 사이트를 방문해주세요.","ogImage":{"url":"/assets/img/undefined_0.png"},"coverImage":"/assets/img/undefined_0.png","tag":["Tech"],"readingTime":2},{"title":"Flutter에서 위젯 크기를 동적으로 측정하는 방법","description":"","date":"2024-06-21 20:09","slug":"2024-06-21-HowtoDynamicallyMeasureWidgetSizeinFlutter","content":"\n\n\u003cimg src=\"/assets/img/2024-06-21-HowtoDynamicallyMeasureWidgetSizeinFlutter_0.png\" /\u003e\n\n플러터 개발에서 흔한 도전 과제 중 하나는 위젯이 렌더링된 후에 해당 위젯의 동적 크기를 결정하는 것입니다. 이는 다양한 레이아웃 조정 및 애니메이션에 중요할 수 있습니다. 이 포스트에서는 사용자 지정 위젯을 사용하여 위젯의 크기를 측정하는 간단하고 효율적인 방법을 보여 드리겠습니다.\n\n# SizeMeasureWidget\n\n해결책의 핵심은 모든 위젯을 감싸고 렌더링된 후에 크기를 제공하는 사용자 지정 SizeMeasureWidget입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport 'package:flutter/material.dart';\n\nclass SizeMeasureWidget extends StatefulWidget {\n  final Widget child;\n  final ValueChanged\u003cSize\u003e onSizeMeasured;\n\n  const SizeMeasureWidget({\n    Key? key,\n    required this.onSizeMeasured,\n    required this.child,\n  }) : super(key: key);\n\n  @override\n  _SizeMeasureWidgetState createState() =\u003e _SizeMeasureWidgetState();\n}\n\nclass _SizeMeasureWidgetState extends State\u003cSizeMeasureWidget\u003e {\n  final GlobalKey _sizeKey = GlobalKey();\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      key: _sizeKey,\n      child: widget.child,\n    );\n  }\n\n  @override\n  void initState() {\n    super.initState();\n    WidgetsBinding.instance.addPostFrameCallback((_) {\n      _getSize();\n    });\n  }\n\n  void _getSize() {\n    RenderBox renderBox = _sizeKey.currentContext!.findRenderObject() as RenderBox;\n    Size size = renderBox.size;\n    widget.onSizeMeasured(size);\n  }\n}\n```\n\n## 작동 방식\n\n- Stateful Widget: SizeMeasureWidget은 자식 위젯과 onSizeMeasured 콜백 함수를 가져오는 상태를 가진 위젯입니다.\n- GlobalKey: 위젯을 고유하게 식별하고 해당 컨텍스트를 얻기 위해 GlobalKey를 사용합니다.\n- Post Frame Callback: initState에서 WidgetsBinding.instance.addPostFrameCallback를 사용하여 위젯 트리가 레이아웃 된 후에 코드를 실행할 콜백을 등록합니다.\n- RenderBox: GlobalKey를 사용하여 위젯의 RenderBox를 가져와서 해당 크기를 가져옵니다.\n- Callback: 마지막으로 위젯의 크기와 함께 onSizeMeasured 콜백을 호출합니다.\n\n# SizeMeasureWidget 사용 방법  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기는 귀하의 응용 프로그램에서 SizeMeasureWidget을 사용하는 방법입니다:\n\n```js\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: Text('Dynamic Size Measurement')),\n        body: Center(\n          child: SizeMeasureWidget(\n            onSizeMeasured: (size) {\n              print(\"Widget size: $size\");\n            },\n            child: Container(\n              color: Colors.blue,\n              height: 200,\n              width: 200,\n              child: Center(child: Text('Measure my size!')),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n```\n\n# 설명\n\n이 예제에서:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- SizeMeasureWidget 안에 Container를 감쌉니다.\n- onSizeMeasured 콜백은 Container의 크기를 콘솔에 출력합니다.\n\n# 장점\n\n- 다이나믹한 레이아웃 조정: 위젯의 크기에 따라 레이아웃을 동적으로 조정할 수 있습니다.\n- 애니메이션: 요소의 크기를 알고 있을 때 더 복잡한 애니메이션을 만들 수 있습니다.\n- 반응형 디자인: 더 반응형이고 적응형인 UI를 구축할 수 있습니다.\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSizeMeasureWidget을 사용하면 Flutter에서 어떤 위젯의 동적 크기를 측정하고 반응하는 것이 쉽습니다. 이 기술은 유연하고 반응적인 레이아웃을 만드는 데 귀중합니다. 여러분의 프로젝트에서 시도해보고 레이아웃 로직을 얼마나 간단하게 만드는지 확인해보세요!","ogImage":{"url":"/assets/img/2024-06-21-HowtoDynamicallyMeasureWidgetSizeinFlutter_0.png"},"coverImage":"/assets/img/2024-06-21-HowtoDynamicallyMeasureWidgetSizeinFlutter_0.png","tag":["Tech"],"readingTime":3}],"page":"11","totalPageCount":21,"totalPageGroupCount":2,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"11"},"buildId":"-yEBofE4jMl3RL1kr5c4Y","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>