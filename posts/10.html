<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>uidev-css</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://uidev-css.github.io///posts/10" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="uidev-css" data-gatsby-head="true"/><meta property="og:title" content="uidev-css" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://uidev-css.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://uidev-css.github.io///posts/10" data-gatsby-head="true"/><meta name="twitter:title" content="uidev-css" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | uidev-css" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/873-1e1f6fb6fd3c8994.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-498da29379dd58dc.js" defer=""></script><script src="/_next/static/fyfGyRz00q80ZdkogiVCt/_buildManifest.js" defer=""></script><script src="/_next/static/fyfGyRz00q80ZdkogiVCt/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UIDEV CSS</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Flutter에서 Shared Preferences 사용하기 데모 앱과 함께하는 가이드" href="/post/2024-06-21-SharedPreferencesinFlutterAGuidewithaDemonstrativeApp"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter에서 Shared Preferences 사용하기 데모 앱과 함께하는 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-SharedPreferencesinFlutterAGuidewithaDemonstrativeApp_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter에서 Shared Preferences 사용하기 데모 앱과 함께하는 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Flutter에서 Shared Preferences 사용하기 데모 앱과 함께하는 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">4 hours ago</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="완벽한 Flutter 가이드 다크 모드, 동적 테마 및 테마 전환 구현하는 방법" href="/post/2024-06-21-CompleteFlutterGuideHowtoImplementDarkModeDynamicThemingandThemeSwitching"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="완벽한 Flutter 가이드 다크 모드, 동적 테마 및 테마 전환 구현하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-CompleteFlutterGuideHowtoImplementDarkModeDynamicThemingandThemeSwitching_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="완벽한 Flutter 가이드 다크 모드, 동적 테마 및 테마 전환 구현하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">완벽한 Flutter 가이드 다크 모드, 동적 테마 및 테마 전환 구현하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">4 hours ago</span><span class="PostList_reading_time__6CBMQ">14<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Dart에서 CC Rest Api로 REST API 호출 간단하게 하는 방법" href="/post/2024-06-21-SimplifyYourRESTAPICallswithCCRestApiinDart"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Dart에서 CC Rest Api로 REST API 호출 간단하게 하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-SimplifyYourRESTAPICallswithCCRestApiinDart_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Dart에서 CC Rest Api로 REST API 호출 간단하게 하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Dart에서 CC Rest Api로 REST API 호출 간단하게 하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">4 hours ago</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="효과적인 Dart 2024년 최신 다트 관용구 작성하기" href="/post/2024-06-21-EffectiveDartWritingIdiomaticDartCode"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="효과적인 Dart 2024년 최신 다트 관용구 작성하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-EffectiveDartWritingIdiomaticDartCode_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="효과적인 Dart 2024년 최신 다트 관용구 작성하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">효과적인 Dart 2024년 최신 다트 관용구 작성하기</strong><div class="PostList_meta__VCFLX"><span class="date">4 hours ago</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="카운팅 정렬 딜레마 속도와 자원 사용 균형 맞추는 방법" href="/post/2024-06-21-TheCountingSortConundrumBalancingSpeedandResourceUsage"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="카운팅 정렬 딜레마 속도와 자원 사용 균형 맞추는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-TheCountingSortConundrumBalancingSpeedandResourceUsage_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="카운팅 정렬 딜레마 속도와 자원 사용 균형 맞추는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">카운팅 정렬 딜레마 속도와 자원 사용 균형 맞추는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">4 hours ago</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter 애플리케이션에서 빌드 플레버 설정하는 방법 iOS, Android" href="/post/2024-06-21-CreateBuildFlavorinFlutterApplicationiOSAndroid"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter 애플리케이션에서 빌드 플레버 설정하는 방법 iOS, Android" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-CreateBuildFlavorinFlutterApplicationiOSAndroid_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter 애플리케이션에서 빌드 플레버 설정하는 방법 iOS, Android" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Flutter 애플리케이션에서 빌드 플레버 설정하는 방법 iOS, Android</strong><div class="PostList_meta__VCFLX"><span class="date">4 hours ago</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter 테스트 완벽 가이드 유닛 테스트부터 통합 테스트까지" href="/post/2024-06-21-TestinginFlutterFromUnitTeststoIntegrationTests"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter 테스트 완벽 가이드 유닛 테스트부터 통합 테스트까지" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-TestinginFlutterFromUnitTeststoIntegrationTests_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter 테스트 완벽 가이드 유닛 테스트부터 통합 테스트까지" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Flutter 테스트 완벽 가이드 유닛 테스트부터 통합 테스트까지</strong><div class="PostList_meta__VCFLX"><span class="date">4 hours ago</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter로 강력한 크로스플랫폼 모바일 앱 만드는 방법" href="/post/2024-06-21-BuildingPowerfulCross-PlatformMobileAppswithFlutter"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter로 강력한 크로스플랫폼 모바일 앱 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-BuildingPowerfulCross-PlatformMobileAppswithFlutter_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter로 강력한 크로스플랫폼 모바일 앱 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Flutter로 강력한 크로스플랫폼 모바일 앱 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">4 hours ago</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter 기본 위젯들을 알고 계신가요" href="/post/2024-06-21-DoyouknowthebasicwidgetsofFlutter"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter 기본 위젯들을 알고 계신가요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-DoyouknowthebasicwidgetsofFlutter_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter 기본 위젯들을 알고 계신가요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Flutter 기본 위젯들을 알고 계신가요</strong><div class="PostList_meta__VCFLX"><span class="date">4 hours ago</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter에서 Clean Architecture 시작하기" href="/post/2024-06-21-IntroductiontoCleanArchitectureinFlutter"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter에서 Clean Architecture 시작하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-IntroductiontoCleanArchitectureinFlutter_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter에서 Clean Architecture 시작하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Flutter에서 Clean Architecture 시작하기</strong><div class="PostList_meta__VCFLX"><span class="date">4 hours ago</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link posts_-active__YVJEi" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Flutter에서 Shared Preferences 사용하기 데모 앱과 함께하는 가이드","description":"","date":"2024-06-21 20:38","slug":"2024-06-21-SharedPreferencesinFlutterAGuidewithaDemonstrativeApp","content":"\n\n![image](/assets/img/2024-06-21-SharedPreferencesinFlutterAGuidewithaDemonstrativeApp_0.png)\n\n모바일 앱 개발에서의 공유 환경은 사용자 기기에 키-값 쌍의 작은 데이터를 저장할 수 있게 해주는데요. 이 데이터는 영구적이며 앱이 종료된 후에도 접근할 수 있습니다. Flutter에서는 shared_preferences 패키지를 사용하여 공유 환경을 쉽게 관리할 수 있어요.\n\n이 글에서는 Flutter에서의 공유 환경 기본을 살펴보고, 사용 방법을 보여줄 간단한 앱을 만들어볼 거에요.\n\nshared_preferences 시작하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"shared_preferences\" 패키지를 쉽게 추가할 수 있습니다. Flutter 프로젝트에 다음 줄을 pubspec.yaml 파일에 추가하세요:\n\n```yaml\ndependencies:\n  shared_preferences: ^0.5.12+4\n```\n\n의존성을 추가했으면 Dart 파일에서 가져와 초기화할 수 있습니다:\n\n```dart\nimport 'package:shared_preferences/shared_preferences.dart';\n\nSharedPreferences prefs;\n\n// 공유 설정 초기화\nprefs = await SharedPreferences.getInstance();\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 공유 설정을 초기화했으니, 공유 설정에서 데이터를 저장하고 검색하는 방법을 알아보겠습니다.\n\n공유 설정에 데이터 저장\n\n공유 설정에 데이터를 저장하는 것은 간단하며 아래와 같이 수행할 수 있습니다:\n\n```js\n// 문자열 값을 저장\nprefs.setString('키', '값');\n\n// 정수 값을 저장\nprefs.setInt('키', 42);\n\n// 실수 값을 저장\nprefs.setDouble('키', 3.14);\n\n// 부울 값을 저장\nprefs.setBool('키', true);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n공유 프리퍼런스에서 데이터를 검색하는 것은 데이터를 저장하는 것만큼 쉽습니다:\n\n```js\n// 문자열 값 검색\nString stringValue = prefs.getString('key');\n\n// 정수 값 검색\nint intValue = prefs.getInt('key');\n\n// 배정밀도 부동 소수점 값 검색\ndouble doubleValue = prefs.getDouble('key');\n\n// 부울 값 검색\nbool boolValue = prefs.getBool('key');\n```\n\n시연용 앱\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이번에는 Flutter에서의 공유 환경 설정(shared preferences)의 기본적인 이해를 한 것 같네요. 이제 이를 활용한 간단한 앱을 만들어보겠습니다.\n\n이 앱에서는 사용자 이름을 입력하는 TextField와 사용자 이름을 기억할지 여부를 나타내는 SwitchListTile이 있습니다. 스위치가 켜져 있고(true), \"저장\" 버튼이 눌리면 입력된 사용자 이름과 스위치 상태가 공유 환경 설정에 저장됩니다. 앱을 다음에 열면, 이전에 저장된 값이 공유 환경 설정에서 로드되어 Text에 표시되며, Switch는 여전히 true로 설정될 것입니다.\n\n다음은 우리의 데모 앱 코드입니다:\n\n```js\nimport 'package:flutter/material.dart';\nimport 'package:shared_preferences/shared_preferences.dart';\n\nvoid main() =\u003e runApp(MyApp());\n\nclass MyApp extends StatefulWidget {\n  @override\n  _MyAppState createState() =\u003e _MyAppState();\n}\n\nclass _MyAppState extends State\u003cMyApp\u003e {\n  // 공유 환경 설정 데이터를 저장하는 변수들\n  String _username;\n  bool _rememberMe;\n\n  @override\n  void initState() {\n    super.initState();\n    _loadPreferences();\n  }\n\n  // 공유 환경 설정 데이터를 로드하는 메서드\n  void _loadPreferences() async {\n    final prefs = await SharedPreferences.getInstance();\n    setState(() {\n      _username = prefs.getString('username') ?? '';\n      _rememberMe = prefs.getBool('rememberMe') ?? false;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text('Shared Preferences Demo'),\n        ),\n        body: Padding(\n          padding: const EdgeInsets.all(16.0),\n          child: Column(\n            children: \u003cWidget\u003e[\n              TextField(\n                decoration: InputDecoration(\n                  labelText: 'Username',\n                  hintText: 'Enter your username',\n                ),\n                onChanged: (value) {\n                  setState(() {\n                    _username = value;\n                  });\n                },\n              ),\n              CheckboxListTile(\n                title: Text('Remember me'),\n                value: _rememberMe,\n                onChanged: (value) {\n                  setState(() {\n                    _rememberMe = value;\n                  });\n                },\n              ),\n              RaisedButton(\n                child: Text('Save'),\n                onPressed: () async {\n                  final prefs = await SharedPreferences.getInstance();\n                  prefs.setString('username', _username);\n                  prefs.setBool('rememberMe', _rememberMe);\n                },\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 마크다운 형식으로 변경하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 앱에서 사용하시고 로컬 저장소의 아름다움을 즐기세요!!!\n\n만약 유용하다고 느끼신다면, 좋아요를 남겨주세요\n\n소스 코드: github","ogImage":{"url":"/assets/img/2024-06-21-SharedPreferencesinFlutterAGuidewithaDemonstrativeApp_0.png"},"coverImage":"/assets/img/2024-06-21-SharedPreferencesinFlutterAGuidewithaDemonstrativeApp_0.png","tag":["Tech"],"readingTime":4},{"title":"완벽한 Flutter 가이드 다크 모드, 동적 테마 및 테마 전환 구현하는 방법","description":"","date":"2024-06-21 20:35","slug":"2024-06-21-CompleteFlutterGuideHowtoImplementDarkModeDynamicThemingandThemeSwitching","content":"\n\n# 소개\n\n요즘 플러터 개발을 공부하고 있어요. 테마 전환은 사용자 경험을 향상시키는 중요한 방법이자, 플러터 학습에서 무시할 수 없는 주제입니다. 이 글에서는 플러터에서 테마 전환을 구현하는 방법을 자세히 설명하겠습니다.\n\n# 주요 내용\n\n이 글은 주로 다음 주제를 다룹니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 왜 앱이 테마 전환을 지원해야 하는지\n- 플러터에서 테마를 설정하는 방법\n- 플러터에서 주간 및 야간 모드 전환하는 방법\n- 플러터에서 동적으로 색상 테마를 변경하는 방법\n- Provider를 사용하여 동적 테마 전환 구현하는 방법\n\n# 왜 앱이 테마 전환을 지원해야 하는지\n\n- 사용자 경험 향상: 각 사용자는 각각의 미적 취향을 가지고 있습니다. 테마 전환이 더 많은 사용자의 시각적 취향을 충족시킬 수 있습니다.\n- 맞춤화된 경험: 테마 전환은 앱의 맞춤 특성을 나타내고 사용자가 테마를 사용자 정의하여 경험을 개인화할 수 있게 합니다.\n- 접근성 지원: 고대비 테마로 전환하는 것은 시각 장애가 있는 사용자들에게 접근성을 향상시킬 수 있습니다.\n\n# 플러터에서 테마를 설정하는 방법\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플러터에서 테마를 설정하는 것은 매우 간단합니다. 단순히 테마 매개변수를 구성하면 됩니다. 테마를 설정하지 않아도 기본 테마를 사용할 수 있어요. 예를 들면:\n\n![image](/assets/img/2024-06-21-CompleteFlutterGuideHowtoImplementDarkModeDynamicThemingandThemeSwitching_0.png)\n\n다크 모드를 사용하고 싶다면, darkTheme: ThemeData.dark()를 추가하세요.\n\n```dart\nclass MainApp extends StatelessWidget {\n  const MainApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(\n          colorScheme: ColorScheme.fromSwatch(primarySwatch: Colors.green)),\n      darkTheme: ThemeData.dark(),\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text(\"AppBar\"),\n        ),\n        body: const Center(\n          child: Text('Hello World!'),\n        ),\n      ),\n    );\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앱은 시스템 설정에 따라 자동으로 테마 모드를 변경합니다. 테마 모드를 수동으로 지정하려면 코드에서 themeMode: ThemeMode.light로 설정할 수 있습니다. 이렇게 하면 앱의 테마 모드가 라이트 모드로 강제 지정됩니다.\n\n# Material 3 설정 방법\n\nMaterial 3를 설정하는 것은 더 간단합니다. useMaterial3: true를 지정하기만 하면 됩니다.\n\n```js\nclass MainApp extends StatelessWidget {\n  const MainApp({super.key});\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData.light(useMaterial3: true,),\n      darkTheme: ThemeData.dark(),\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text(\"AppBar\"),\n        ),\n        body: const Center(\n          child: Text('Hello World!'),\n        ),\n      ),\n    );\n  }\n}\n``` \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nMaterial 3은 애플리케이션의 전체 색상 테마를 단일 시드 색상에서 설정할 수 있습니다. 테마 생성자에서 colorSchemeSeed 매개변수를 설정하여 Flutter가이 항목에서 앱의 각 위젯에 대한 조화로운 색상 테마를 생성합니다.\n예를 들어, 아래 색상 테마는 colorSchemeSeed를 사용하여 생성됩니다: const Color.fromARGB(86, 80, 14, 171)\n\n```dart\nclass MainApp extends StatelessWidget {\n  const MainApp({Key key});\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(\n        useMaterial3: true,\n        colorSchemeSeed: const Color.fromRGBO(86, 80, 14, 171),\n      ),\n      darkTheme: ThemeData(\n        useMaterial3: true,\n        brightness: Brightness.dark,\n        colorSchemeSeed: const Color.fromRGBO(86, 80, 14, 171),\n      ),\n      themeMode: ThemeMode.dark,\n      home: const HomePage(),\n    );\n  }\n}\n```\n\n![image1](/assets/img/2024-06-21-CompleteFlutterGuideHowtoImplementDarkModeDynamicThemingandThemeSwitching_1.png)\n\n![image2](/assets/img/2024-06-21-CompleteFlutterGuideHowtoImplementDarkModeDynamicThemingandThemeSwitching_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 플러터에서 주간 모드와 야간 모드 전환하는 방법\n\n어플리케이션에서 주간 모드와 야간 모드는 앱의 디스플레이 스타일을 의미합니다. 주간 모드는 일반적으로 밝은 색상과 높은 대비를 사용하며, 야간 모드는 어두운 배경과 낮은 대비를 사용합니다.\n\n주간 모드는 밝은 환경에서 앱을 사용할 때 주로 사용됩니다. 밝은 색상과 높은 대비가 사용자가 콘텐츠를 더 쉽게 볼 수 있도록 도와줍니다. 야간 모드는 어두운 환경에서 앱을 사용할 때 주로 사용됩니다. 어두운 배경과 낮은 대비는 시력 피로를 줄일 수 있습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:844/1*2zyd9D-e4c6Z35u_2xPpeg.gif)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플러터에서는 낮과 밤 모드 사이를 동적으로 전환하는 것이 매우 간단합니다. 테마 모드를 저장할 중간 변수를 추가하기만 하면 됩니다.\n\n모드 전환을 구현하는 단계는 다음과 같습니다:\n\n- 낮과 밤을 위한 두 가지 테마 세트를 정의합니다.\n- 현재 테마 모드를 저장할 ThemeMode 변수를 추가합니다.\n- 이 변수를 light/dark로 설정하여 테마 모드를 전환합니다.\n- 전환 후 인터페이스가 새로운 테마를 적용하기 위해 자동으로 다시 빌드됩니다.\n\n구체적인 코드는 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\nclass _MainAppState extends State\u003cMainApp\u003e {\n  ThemeMode themeMode = ThemeMode.system;\n  \n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp( \n      theme: ThemeData(\n        useMaterial3: true,\n      ),\n      darkTheme: ThemeData(\n        useMaterial3: true,\n        brightness: Brightness.dark,\n      ),\n      themeMode: themeMode,  // MaterialApp이 테마 모드 변수를 읽어서 테마를 전환합니다.\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text(\"AppBar\"),\n        ),\n        body: Column(\n          children: [\n            Row(\n              children: [\n                TextButton(\n                    onPressed: () {\n                      setState(() {\n                        themeMode = ThemeMode.light;\n                      });\n                    },\n                    child: const Text(\"라이트\")),\n                TextButton(\n                    onPressed: () {\n                      setState(() {\n                        themeMode = ThemeMode.dark;\n                      });\n                    },\n                    child: const Text(\"다크\")),\n              ],\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n```\n\n이 코드는 라이트 테마와 다크 테마를 갖춘 간단한 Flutter 앱을 정의합니다. 먼저 ThemeMode 변수 themeMode를 정의하고 ThemeMode.system으로 초기화합니다. 이는 앱이 일반적으로 안드로이드에서 라이트 테마, iOS에서 다크 테마를 사용하는 시스템의 기본 테마를 사용함을 의미합니다.\n\n다음으로, 라이트 테마와 다크 테마가 정의됩니다. 라이트 테마는 ThemeData 클래스를 사용합니다. useMaterial3 속성은 새로운 Material 3 디자인 언어를 사용하기 위해 true로 설정됩니다. colorSchemeSeed 속성은 해당 테마의 기본 색상으로 사용될 특정 색상으로 설정됩니다.\n\n다크 테마는 비슷한 방식으로 정의되지만 brightness 속성이 Brightness.dark로 설정됩니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마지막으로, MaterialApp 위젯이 앱을 생성하는 데 사용됩니다. theme 속성은 밝은 테마로 설정되고, themeMode 속성은 themeMode 변수로 설정됩니다. 이것은 앱이 밝은 테마로 시작하지만 사용자가 해당 버튼을 탭하여 테마를 어둡게 변경할 수 있음을 의미합니다.\n\nScaffold 위젯은 앱의 기본 레이아웃을 만드는 데 사용됩니다. appBar 속성은 앱 바를 만들고, backgroundColor은 현재 테마의 기본 컨테이너 색상으로 설정됩니다. body 속성은 이 경우 간단한 목록과 두 개의 버튼으로 구성된 앱의 주요 콘텐츠를 만드는 데 사용됩니다.\n\n두 버튼은 테마를 변경하는 데 사용됩니다. 사용자가 \"light\" 버튼을 탭하면 themeMode 변수가 ThemeMode.light로 설정되어 앱이 밝은 테마로 변경됩니다. 사용자가 \"dark\" 버튼을 탭하면 themeMode이 ThemeMode.dark로 설정되어 어두운 테마로 변경됩니다.\n\n# 플러터에서 동적으로 색상 테마 변경하는 방법\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 색 테마 설정하는 방법\n\n플러터 앱의 색 테마를 구성하는 두 가지 방법이 있습니다:\n\n- 토큰을 사용하여 테마 색상 설정\n- 사용자 정의 색 구성표를 사용\n\n# 테마 색상 설정을 위한 토큰 사용\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플러터의 머티리얼 디자인에서 \"토큰\"은 디자인 시스템과 관련된 개념으로, 특히 구글의 \"Material You\" 시스템에서 중요한 역할을 합니다. 이 시스템에서 토큰은 앱의 모양과 느낌을 정의하는 데 사용되는 매개변수 집합입니다. 이는 색상, 글꼴, 모양 및 기타 요소를 포함하여 앱에서 일관된 시각적 경험을 만들어내는 데 사용됩니다.\n\n토큰은 특정 시각적 스타일을 나타내는 변수 또는 식별자로 생각할 수 있는 추상적인 개념입니다. 예를 들어, 색상 토큰은 테마의 주요 색상을 나타낼 수 있고, 글꼴 토큰은 앱에서 사용하는 헤드라인 글꼴을 나타낼 수 있습니다. 이를 통해 앱의 시각적 스타일이 머티리얼 디자인 요구 사항을 준수하고, 여러 페이지와 구성 요소 간에 일관된 스타일이 유지되도록 도와줍니다.\n\n플러터에서는 ThemeData를 사용하여 이러한 토큰을 설정할 수 있습니다. 예를 들어, ThemeData의 primaryColor 및 accentColor 속성을 사용하여 앱의 주요 색상 및 강조 색상을 설정할 수 있습니다. 마찬가지로, textTheme을 사용하여 앱 전체에 걸쳐 글꼴 스타일을 설정할 수 있습니다.\n\n머티리얼 3의 경우, 전체 앱에서 재사용할 수 있는 색상 토큰을 설정하는 아래 접근 방식을 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\nThemeData(\n        useMaterial3: true,\n        colorSchemeSeed: const Color.fromRGBO(86, 80, 14, 171),\n      )\n```\n\n# 사용자 정의 색 구성표 사용하기\n\nFlutter에서 Material 스타일 색 구성표를 사용자 정의하는 방법은 다음과 같습니다:\n\n- colors.dart 파일을 생성하고 내부에 색 변수를 정의합니다. 예시:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\nimport 'package:flutter/material.dart';\nconst lightColorScheme = ColorScheme(\n  brightness: Brightness.light,\n  primary: Color(0xFF96416A),\n  onPrimary: Color(0xFFFFFFFF),\n  primaryContainer: Color(0xFFFFD8E6),\n  onPrimaryContainer: Color(0xFF3D0024),\n  secondary: Color(0xFF735761),\n  ...\n);\nconst darkColorScheme = ColorScheme(\n  brightness: Brightness.dark,\n  primary: Color(0xFFFFB0D0),\n  onPrimary: Color(0xFF5C113B),\n  primaryContainer: Color(0xFF792952),\n  onPrimaryContainer: Color(0xFFFFD8E6),\n  secondary: Color(0xFFE1BDCA),\n  onSecondary: Color(0xFF412A33),\n  ...\n);\n```\n\n- 이러한 사용자 정의 색상을 테마에서 참조하십시오:\n\n```dart\nclass MyApp extends StatelessWidget {\n  const MyApp({Key? key}) : super(key: key);\n// 이 위젯은 애플리케이션의 루트입니다.\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(useMaterial3: true, colorScheme: lightColorScheme),\n      darkTheme: ThemeData(useMaterial3: true, colorScheme: darkColorScheme),\n      home: const Home(),\n    );\n  }\n}\n```\n\n- 테마를 적용하려는 페이지에 colors.dart를 가져와서 Theme.of(context)를 통해 테마 설정 구성 스타일을 가져옵니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\n최종 defaultColorScheme = Theme.of(context).colorScheme;\nappBar: AppBar(\n        title: const Text(\"AppBar\"),\n        backgroundColor: defaultColorScheme.primaryContainer,\n      ),\n```\n\n4, 여러 테마를 만들 수도 있습니다. 테마를 전환할 때 다른 ThemeData 객체를 전달하세요:\n\n```dart\nMaterialApp(\n  theme: lightTheme, \n  darkTheme: darkTheme,\n)\n```\n\n5 테마에서 글꼴, 모양, 그림자 등을 포함한 다른 스타일을 사용자 정의할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이렇게 하면 Material 소스 코드에 깊이 파지 않고 색상과 시각적 효과를 자유롭게 결합하여 사용자 정의된 브랜드 전용 테마를 구현할 수 있어요.\n\n![Image](https://miro.medium.com/v2/resize:fit:1400/1*ekAvAGKVuYuCQb0WEbnxlA.gif)\n\n# 테마 색상을 동적으로 변경하는 방법\n\n![Image](https://miro.medium.com/v2/resize:fit:800/1*JQFs1GLX1gGM8T3roPhRmQ.gif)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앱에서 테마 색상을 동적으로 전환할 수 있는 다양한 방법이 있습니다. 오늘은 주로 권장되는 방법인 Provider를 사용하는 방법을 소개하겠습니다.\n\nProvider를 사용하면 테마의 중앙 상태 관리가 가능해져 테마를 동적으로 변경할 수 있습니다.\n\n- 상태 관리를 담당하는 ThemeProvider 클래스를 만듭니다.\n- 루트 페이지에 ThemeProvider를 설정합니다.\n- 페이지에서 Consumer를 통해 인스턴스를 얻습니다.\n- 테마 구성을 수정하기 위해 set 메서드를 호출합니다.\n- 테마 변경이 인터페이스 업데이트를 트리거합니다.\n\n# 1. 테마 프로바이더 생성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우선 ThemeProvider 클래스를 만들어서 테마 상태를 저장합니다:\n\n```js\n// theme_provider.dart\nimport 'package:flutter/material.dart';\nimport 'color_schemes.g.dart';\n\nclass ThemeProvider with ChangeNotifier {\n  late ThemeMode _themeMode = ThemeMode.system;\n  late ColorScheme _darkScheme = darkColorScheme;\n  late ColorScheme _lightScheme = lightColorScheme;\n\n  ThemeMode get themeMode =\u003e _themeMode;\n\n  void setThemeMode(ThemeMode value) {\n    _themeMode = value;\n    notifyListeners();\n  }\n\n  ColorScheme get darkScheme =\u003e _darkScheme;\n\n  void setDarkScheme(ColorScheme value) {\n    _darkScheme = value;\n    notifyListeners();\n  }\n\n  ColorScheme get lightScheme =\u003e _lightScheme;\n\n  void setLightScheme(ColorScheme value) {\n    _lightScheme = value;\n    notifyListeners();\n  }\n}\n```\n\n이 코드는 앱의 밝은 테마와 어두운 테마를 동적으로 수정할 수 있는 ThemeProvider를 구현합니다.\n\n# 2. ThemeProvider 제공\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n루트 페이지에 다음 ThemeProvider를 제공하십시오:\n\n```js\nWidget build(BuildContext context) {\n    return ChangeNotifierProvider(\n        create: (context) =\u003e ThemeProvider(),\n        child:\n            Consumer\u003cThemeProvider\u003e(builder: (context, themeProvider, child) {\n          return MaterialApp(\n            theme: ThemeData(\n                useMaterial3: true, colorScheme: themeProvider.lightScheme),\n            darkTheme: ThemeData(\n                useMaterial3: true, colorScheme: themeProvider.darkScheme),\n            themeMode: themeProvider.themeMode,\n            home: const HomePage(),\n          );\n        }));\n  }\n```\n\n이 구현 방식은 다음 이점을 가지고 있습니다:\n\n- MaterialApp에서 ThemeProvider의 인스턴스를 Consumer를 통해 얻습니다.\n- LightTheme 및 DarkTheme의 색상 체계는 ThemeProvider의 lightScheme 및 darkScheme를 직접 참조합니다.\n- 테마 모드(themeMode)도 ThemeProvider의 themeMode 상태를 직접 참조합니다.\n- ThemeProvider의 상태가 변경되면 notifyListeners를 통해 동적으로 재구성하기 위해 Consumer를 트리거하여 테마를 전환합니다.\n- 홈 페이지나 다른 페이지에서는 context를 통해 ThemeProvider 인스턴스를 가져와서 테마 모드와 테마 색상을 변경하기 위해 setter 메서드를 호출할 수 있습니다.\n- Provider를 사용하여 테마 데이터와 상태를 추출함으로써 UI 레이어에서 간단하게 재사용하여 느슨하게 결합된 동적 테마 전환을 달성합니다.\n- ThemeProvider는 테마 상태 관리를 담당하며, UI 레이어는 디스플레이를 담당합니다. 책임의 분리는 디자인 원칙을 따릅니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 3. 테마 공급자 가져오기\n\n필요한 페이지에서 공급자 인스턴스를 가져옵니다:\n\n```js\nfinal themeProvider = Provider.of\u003cThemeProvider\u003e(context);\n```\n\n# 4. 테마 변경\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테마 색상을 변경하려면 setLightScheme 및 setDarkScheme를 호출하세요:\n\n```js\nthemeProvider.setLightScheme(lightColorScheme); \nthemeProvider.setDarkScheme(darkColorScheme);\n```\n\n이를 통해 공급자를 통해 서로 다른 페이지 간에 테마 구성을 공유하고 수정할 수 있습니다. 공급자를 사용하여 테마를 관리하면 중복 코드가 없어지며 반응형 테마 구성이 가능해집니다. Flutter에서 동적 테마를 구현하는 유연하고 간결한 방법입니다.\n\n```yaml\ndev_dependencies:\n  flutter_test:\n    sdk: flutter\n  flutter_lints: ^2.0.0\n  provider: ^6.0.5\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 요약\n\n플러터는 강력한 테마 사용자 정의 기능을 제공하여 테마 시스템을 통해 다양한 방식으로 테마를 자유롭게 전환하여 앱 경험과 접근성을 향상시킬 수 있습니다. 플러터의 테마 기구를 숙달하는 것은 고품질 앱을 개발하는 중요한 부분입니다.\n\n위 내용은 플러터에서 테마 전환을 구현하는 전반적인 소개를 제공합니다. 다른 질문이 있으면 토론을 위해 언제든 댓글을 남겨주세요.\n\n예를 들어, 테마 전환 버튼은 ThemeProvider의 세터를 호출하여 테마 모드를 전환할 수 있습니다. 다른 구성 요소는 스타일을 수정하기 위해 Provider를 통해 ThemeProvider 인스턴스를 얻을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nProvider가 테마 상태를 반응적으로 관리하면, 테마가 변경될 때 위젯들이 자동으로 다시 빌드됩니다. 이는 앱 전체 테마 업데이트를 수동으로 처리할 필요 없이 동적 런타임 테마 적용을 가능케 합니다. 전반적으로, Flutter는 사용자 경험을 즐겁게 만들기 위해 테마를 사용자 정의하고 동적으로 전환하기 쉽습니다.\n\n# 참고 링크들\n\n- [Material Theming Builder](https://m3.material.io/theme-builder#/custom)\n- [Flutter Theming](https://juejin.cn/post/7078583859536723975)\n- [Official Flutter documentation on theming](https://flutter.dev/docs/cookbook/design/themes)\n- [Provider를 이용한 동적 테마 적용 튜토리얼](https://flutter.dev/docs/cookbook/design/themes/dynamic)\n- [간단한 앱 예제를 이용한 동적 테마 비디오 튜토리얼](https://www.youtube.com/watch?v=-G75u5uoFFE)\n- [Provider 상태 관리 패키지 Pub 페이지](https://pub.dev/packages/provider)\n- [Flutter에서 테마 사용 가이드](https://flutter.dev/docs/cookbook/design/themes)\n- [공식 Material Design 시스템 테마 자료](https://material.io/design/material-theming)\n- [Flutter 웹에서 테마 전환하기](https://webmasters.googleblog.com/2021/07/theme-switching-in-flutter-web.html)\n- [Flutter 테마 전환 가이드](https://gusibi-blog.vercel.app/article/flutter-theme-switching-guide)","ogImage":{"url":"/assets/img/2024-06-21-CompleteFlutterGuideHowtoImplementDarkModeDynamicThemingandThemeSwitching_0.png"},"coverImage":"/assets/img/2024-06-21-CompleteFlutterGuideHowtoImplementDarkModeDynamicThemingandThemeSwitching_0.png","tag":["Tech"],"readingTime":14},{"title":"Dart에서 CC Rest Api로 REST API 호출 간단하게 하는 방법","description":"","date":"2024-06-21 20:34","slug":"2024-06-21-SimplifyYourRESTAPICallswithCCRestApiinDart","content":"\n\n# 안녕하세요, Dart 애호가 여러분!\n\nDart 애플리케이션에서 REST API 호출의 복잡성에 지치셨나요? HTTP 요청과 응답을 처리하는 더 체계적이고 간편한 방법이 있으면 좋겠다고 생각하시나요? 걱정하지 마세요! 여러분의 REST API 상호작용을 보다 조직적이고 관리하기 쉬운 클래스 구조로 변환하여 여러분의 삶을 더 편하게 만들어주는 Dart 패키지, CC Rest Api를 소개해 드리게 되어 매우 기쁩니다.\n\n본 문서에서는 CC Rest Api에 대해 알아야 할 모든 것을 초기화부터 모듈 생성과 사용까지 친절하게 안내해 드리겠습니다. 함께 알아보시죠!\n\n# CC Rest Api를 선택해야 하는 이유?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n세부 사항에 들어가기 전에 CC Rest Api를 사용하고 싶어 하는 이유에 대해 이야기해 보겠습니다. 이 패키지를 개발하는 가장 큰 목표는 전통적인 방법 기반의 API 상호 작용을 클래스 기반 구조로 전환하는 것입니다. 이렇게 함으로써 코드를 단순화하는 것뿐만 아니라 복잡성을 줄여 유지 및 확장하기 쉽게 만듭니다.\n\nCC Rest Api는 현재 GET, POST 및 DELETE 작업을 지원하며 API 통신에 필요한 가장 일반적인 기능을 다룹니다.\n\n# 시작하기\n\n# 설치\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저, CC Rest Api를 프로젝트에 추가해 봅시다. 간단히 pub.dev를 통해 추가할 수 있어요. 다음 줄을 pubspec.yaml 파일에 추가해 주세요:\n\n```yaml\ndependencies:\n  cc_rest_api: ^1.0.0\n```\n\n그리고 flutter pub get을 실행하여 패키지를 설치해 주세요.\n\n# 초기화\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nCC Rest API를 사용하기 전에 REST API 구성 및 로깅 옵션으로 초기화해야 합니다. 아래는 설정하는 예시입니다:\n\n```js\nimport 'package:cc_rest_api/cc_rest_api.dart';\n\nvoid main() {\n  CCRestApi.init(\n    restOptions: CCRestOptions(\n      baseUrl: \"httpbin.org\",\n      defaultHeaders: {\n        \"Access-Control-Allow-Origin\": \"*\",\n        \"Accept\": \"*\",\n        \"Content-Type\": \"application/json\",\n      },\n    ),\n    loggingOptions: CCRestLogging(\n      logEnabled: true,\n      onRequest: (handler) =\u003e print(\"Request: $handler\"),\n      onResponse: (handler) =\u003e print(\"Response: $handler\"),\n      onError: (handler) =\u003e print(\"Error: $handler\"),\n    ),\n    modules: [\n      GetUser(const CCApiConfig(\"user/get\", RequestType.GET, NetworkType.HTTPS)),\n      // 다른 모듈을 여기에 추가할 수 있습니다\n    ],\n  );\n}\n```\n\n이 예시에서는 기본 URL, 기본 헤더 및 로깅 옵션을 설정하고 있습니다. 로깅은 디버깅에 매우 유용하며 각 요청 및 응답의 세부 정보를 콘솔에서 직접 확인할 수 있습니다.\n\n# 모듈 생성하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nCC Rest Api의 진정한 힘은 모듈화된 접근 방식에서 나옵니다. 각 API 작업은 자체 모듈에 캡슐화될 수 있어 관리와 재사용이 쉬워집니다.\n\n모듈을 만드는 방법은 다음과 같습니다:\n\n```js\nclass GetUser extends CCApiModule {\n  GetUser(CCApiConfig config) : super(config);\n\n  @override\n  Future\u003cMap\u003cString, dynamic\u003e\u003e request() async {\n    return await super.request();\n  }\n\n  @override\n  response(dynamic data) {\n    // 받은 데이터에 대한 처리 로직을 여기에 추가할 수 있습니다\n  }\n}\n```\n\n또는, 요청 메서드를 사용자 정의할 필요가 없다면 더 간단하게 유지할 수도 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\nclass GetUser extends CCApiModule {\n  GetUser(CCApiConfig config): super(config);\n\n  @override\n  response(dynamic data) {\n    // 여기에 받은 데이터를 처리하는 논리를 넣을 수 있습니다.\n  }\n}\n```\n\n# 모듈 사용하기\n\n모듈을 설정한 후에 API 요청을 하는 것은 매우 간단합니다. GetUser 모듈을 사용하는 예시를 보여드리겠습니다:\n\n```dart\nimport 'package:cc_rest_api/cc_rest_api.dart'; // 패키지 import\n\nvoid main() {\n  GetUser getUser = CCRestApi.getModule\u003cGetUser\u003e();\n  getUser.setHeaders({\n    \"Authorization\": \"Bearer your_access_token\",\n  });\n  getUser.setParameters({\n    \"param1\": \"value1\",\n    \"param2\": \"value2\",\n  });\n  getUser.setBody({\n    \"firebaseToken\": \"testFT\",\n    \"user_id\": \"test\",\n  });\n\n  getUser.request(); // 요청을 트리거합니다. 응답 값을 반환할 수 있습니다.\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예제에서는 GetUser 모듈의 인스턴스를 만들고, 필요한대로 헤더, 매개변수 및 본문을 설정합니다. 그런 다음 request() 메서드를 호출하여 API 호출을 트리거합니다. 쉽죠?\n\n# 결론\n\nCC Rest Api는 REST API 상호작용을 처리하는 구조화된 유연한 방법을 제공하여 Dart 개발자로서 여러분의 삶을 더 나은 방향으로 만들도록 고안되었습니다. 이 패키지를 사용하여 코드 복잡성을 줄이고 유지 관리성을 향상시키며, 앱에 멋진 기능을 더 많이 구축하는 데 집중할 수 있습니다.\n\n이 기사가 CC Rest Api를 시작하는 방법에 대한 명확한 이해를 제공했기를 바랍니다. 한번 시도해보고 여러분에게 어떻게 작용하는지 알려주세요! 질문이나 피드백이 있으면 아래 댓글을 자유롭게 남겨주세요. 즐거운 코딩되세요!","ogImage":{"url":"/assets/img/2024-06-21-SimplifyYourRESTAPICallswithCCRestApiinDart_0.png"},"coverImage":"/assets/img/2024-06-21-SimplifyYourRESTAPICallswithCCRestApiinDart_0.png","tag":["Tech"],"readingTime":4},{"title":"효과적인 Dart 2024년 최신 다트 관용구 작성하기","description":"","date":"2024-06-21 20:32","slug":"2024-06-21-EffectiveDartWritingIdiomaticDartCode","content":"\n\n# 깨끗하고 효율적이며 관용적인 다트 코드 작성하는 방법\n\n유지보수가 간편하고 성능이 우수한 애플리케이션을 만들기 위해 깨끗하고 효율적이며 관용적인 다트 코드를 작성하는 것은 중요합니다. 다트는 플러터 애플리케이션 등을 만드는 데 사용되는 다재다능한 언어로, 올바르게 활용하면 코드 품질을 크게 향상시킬 수 있습니다. 이 안내서는 가장 좋은 관행, 고급 언어 기능 및 피해야 할 일반적인 함정을 다루어 관용적인 다트 코드를 작성하는 데 도움이 됩니다.\n\n![이미지](/assets/img/2024-06-21-EffectiveDartWritingIdiomaticDartCode_0.png)\n\n# 1. 널 안전성 활용하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 널 안전성이란 무엇인가요?\n\n널 안전성이란 Dart의 특성으로, 모든 유형을 기본적으로 null이 아닌 값으로 만들어 널 오류를 피하도록 도와줍니다. 변수를 명시적으로 nullable하게 표시해야 합니다. ? 구문을 사용합니다.\n\n# 예시\n\n```js\nString? name;\nname = 'Dart';\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 2. Final 및 Const 사용 선호\n\n# Final 및 Const를 사용해야 하는 경우\n\n- Final: 한 번 초기화된 후에 변경되지 않는 변수에 대해 final을 사용합니다.\n- Const: 컴파일 시간 상수에 대해 const를 사용합니다.\n\n# 예제\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\nval greeting: String = \"Hello\"\nconst val pi: Double = 3.14159\n```\n\n# 3. Collection if 및 Spread 연산자 사용하기\n\n# 리스트 생성 향상\n\nDart의 collection if와 spread 연산자(`...`와 `...?`)를 사용하면 더 유연하고 가독성이 좋은 리스트 생성이 가능합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 예제\n\n```js\nvar isLoggedIn = true;\nvar items = [\n  '홈',\n  isLoggedIn ? '프로필' : '',\n  '설정',\n];\n\nvar extraItems = ['도움말', '로그아웃'];\nvar allItems = [\n  '홈',\n  ...extraItems,\n  '설정',\n];\n```\n\n# 4. 확장에 대해 긍정적으로 생각하세요\n\n# 기능 확장\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nDart의 확장은 소스 코드를 수정하지 않고 기존 라이브러리와 클래스에 기능을 추가할 수 있도록 해줍니다.\n\n# 예시\n\n```js\nextension StringExtension on String {\n  String get reversed {\n    return split('').reversed.join('');\n  }\n}\n\nvoid main() {\n  print('hello'.reversed); // prints 'olleh'\n}\n```\n\n# 5. 믹스인의 힘을 활용하세요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 코드 재사용\n\n믹스인은 클래스의 코드를 여러 클래스 계층 구조에서 재사용하는 방법으로, 여러 원본에서 메서드와 속성을 섞어 사용할 수 있도록합니다.\n\n# 예시\n\n```js\nmixin Fly {\n  void fly() =\u003e print('날기');\n}\n\nmixin Swim {\n  void swim() =\u003e print('수영');\n}\n\nclass Duck with Fly, Swim {}\n\nvoid main() {\n  var duck = Duck();\n  duck.fly();\n  duck.swim();\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 6. 함수 유형에 대한 Typedef 활용\n\n# 함수 시그니처 간단히하기\n\nTypedef를 사용하면 함수 시그니처를 간단히할 수 있고 코드 가독성을 향상시킬 수 있습니다.\n\n# 예제\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\ntypedef IntBinaryOperation = int Function(int, int);\n\nint add(int a, int b) =\u003e a + b;\nint subtract(int a, int b) =\u003e a - b;\n\nvoid main() {\n  IntBinaryOperation operation;\n\n  operation = add;\n  print(operation(3, 4)); // 7 출력\n\n  operation = subtract;\n  print(operation(3, 4)); // -1 출력\n}\n```\n\n# 7. 효과적인 Dart 가이드라인을 따르세요\n\n# 코드 일관성\n\nGoogle의 효과적인 Dart 가이드라인은 일관성 있는 Dart 코드를 작성하기 위한 포괄적인 권장 사항을 제공합니다. 이 가이드라인은 네이밍 규칙부터 문서화와 디자인 원칙까지 모든 것을 다룹니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 예시\n\n- 네이밍: 변수, 매개변수 및 함수 이름에는 카멜케이스를 사용하십시오. 클래스 이름에는 UpperCamelCase를 사용하십시오.\n- 문서화: 공개 API에 대한 명확하고 간결한 문서를 제공하기 위해 ///를 사용하십시오.\n\n```js\n/// 이 함수는 두 숫자를 더합니다.\nint add(int a, int b) =\u003e a + b;\n```\n\n# 8. 오류를 공손하게 처리하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 예외 처리 사용하기\n\nDart는 예외를 사용하여 견고한 오류 처리 메커니즘을 제공합니다. 항상 예외를 잡고 정상적으로 처리하세요.\n\n# 예시\n\n```js\ntry {\n  var result = riskyOperation();\n  print(result);\n} catch (e) {\n  print('오류가 발생했습니다: $e');\n}\n\nint riskyOperation() {\n  throw Exception('문제가 발생했습니다');\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 9. async 및 await을 사용하여 성능 최적화\n\n# 비동기 프로그래밍\n\nDart의 async 및 await 키워드는 비동기 프로그래밍을 간단하고 코드를 더 읽기 쉽고 유지보수하기 쉽게 만듭니다.\n\n# 예시\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\nFuture\u003cvoid\u003e fetchData() async {\n  var data = await fetchDataFromServer();\n  print(data);\n}\n\nFuture\u003cString\u003e fetchDataFromServer() async {\n  // 네트워크 지연을 시뮬레이션합니다.\n  await Future.delayed(Duration(seconds: 2));\n  return '데이터 가져오기 완료';\n}\n```\n\n# 10. 흔한 함정 피하기\n\n# 흔한 문제점\n\n- 사용되지 않는 Imports: 코드를 깨끗하게 유지하기 위해 사용되지 않는 imports를 제거합니다.\n- Dynamic 남용: 타입 체크를 우회하고 런타임 오류를 유발할 수 있기 때문에, 꼭 필요한 경우를 제외하고 dynamic 사용을 피하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 예시\n\n```dart\n// 이렇게 피하세요\ndynamic foo = 'bar';\n\n// 이렇게 선호하세요\nString foo = 'bar';\n```\n\n# 결론\n\n다트 언어의 강력한 기능을 활용하고 최상의 관행을 준수하며 흔히 하는 실수를 피함으로써 관용적인 다트 코드를 작성할 수 있습니다. 널 안전성, final 및 const, 확장(extensions), mixin, 그리고 기타 고급 언어 기능을 활용하여 깔끔하고 효율적이며 유지보수가 용이한 다트 코드를 작성할 수 있습니다. 이러한 지침을 따르고 지속적으로 코딩 관행을 개선하여 더 효과적인 다트 개발자가 되세요. 즐거운 코딩하세요!","ogImage":{"url":"/assets/img/2024-06-21-EffectiveDartWritingIdiomaticDartCode_0.png"},"coverImage":"/assets/img/2024-06-21-EffectiveDartWritingIdiomaticDartCode_0.png","tag":["Tech"],"readingTime":4},{"title":"카운팅 정렬 딜레마 속도와 자원 사용 균형 맞추는 방법","description":"","date":"2024-06-21 20:31","slug":"2024-06-21-TheCountingSortConundrumBalancingSpeedandResourceUsage","content":"\n\n## 다트에서 카운팅 정렬 및 실용적인 응용 프로그램에 대해 깊이 파헤쳐보기\n\n![이미지](/assets/img/2024-06-21-TheCountingSortConundrumBalancingSpeedandResourceUsage_0.png)\n\n카운팅 정렬은 선형 시간에 작동하는 정수 정렬 알고리즘입니다. 원소의 범위(최대값과 최소 값의 차이)가 원소의 개수보다 크게 차이나지 않은 배열을 정렬하는 데 특히 효과적입니다. 카운팅 정렬은 각 고유한 요소의 발생 횟수를 세고, 이러한 요소들이 정렬된 배열에서의 위치를 계산하여 작동합니다.\n\n# 카운팅 정렬 작동 방식\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 범위 결정: 배열에서 최솟값과 최댓값을 찾아 요소들의 범위를 결정합니다.\n- 발생 횟수 카운트: 각 고유 요소의 발생 횟수를 저장할 카운트 배열을 만듭니다.\n- 위치 계산: 각 인덱스의 요소가 이전 카운트들의 합을 저장하도록 카운트 배열을 수정합니다. 이렇게 하면 정렬된 배열에서 요소의 위치를 알 수 있게 됩니다.\n- 요소 배치: 카운트 배열에 지시된 대로 요소를 올바른 위치에 배치하여 출력 배열을 생성합니다.\n\n# 카운팅 정렬 사용 시기\n\n카운팅 정렬은 다음 경우에 특히 유용합니다:\n\n- 정렬해야 하는 요소가 정수인 경우.\n- 요소의 범위가 요소의 개수보다 크지 않은 경우.\n- 선형 시간 복잡도를 갖는 비교 기반 정렬 알고리즘이 필요한 경우.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Counting Sort 알고리즘의 Dart 구현\n\nDart로 Counting Sort 알고리즘을 구현해봅시다.\n\n```dart\nvoid countingSort(List\u003cint\u003e arr) {\n  if (arr.isEmpty) return;\n\n  // Step 1: 최솟값과 최댓값 찾기\n  int min = arr[0];\n  int max = arr[0];\n  for (int num in arr) {\n    if (num \u003c min) {\n      min = num;\n    } else if (num \u003e max) {\n      max = num;\n    }\n  }\n\n  // Step 2: count 배열 생성\n  int range = max - min + 1;\n  List\u003cint\u003e count = List.filled(range, 0);\n\n  // Step 3: 각 요소의 발생 횟수 세기\n  for (int num in arr) {\n    count[num - min]++;\n  }\n\n  // Step 4: 위치를 계산하기 위해 count 배열 수정\n  for (int i = 1; i \u003c count.length; i++) {\n    count[i] += count[i - 1];\n  }\n\n  // Step 5: 정렬된 배열 작성\n  List\u003cint\u003e output = List.filled(arr.length, 0);\n  for (int i = arr.length - 1; i \u003e= 0; i--) {\n    int num = arr[i];\n    output[count[num - min] - 1] = num;\n    count[num - min]--;\n  }\n\n  // Step 6: 정렬된 요소를 원래 배열로 복사\n  for (int i = 0; i \u003c arr.length; i++) {\n    arr[i] = output[i];\n  }\n}\n\nvoid main() {\n  List\u003cint\u003e arr = [4, 2, 2, 8, 3, 3, 1, 7];\n  print(\"원본 배열: $arr\");\n  \n  countingSort(arr);\n  \n  print(\"정렬된 배열: $arr\");\n}\n```\n\n# 코드 설명\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 범위 찾기: 배열을 순회하여 최소값과 최대값을 찾습니다.\n- Count 배열 생성: 범위를 계산하고 각 고유 요소의 개수를 저장하는 Count 배열을 생성합니다.\n- 발생 회수 계산: 입력 배열을 순회하며 각 요소의 발생 회수로 Count 배열을 업데이트합니다.\n- 위치 계산: 누적 카운트를 저장하는 Count 배열을 수정하여 정렬된 배열에서 요소의 위치를 결정하는 데 도움이 되게 합니다.\n- 출력 배열 빌드: Count 배열을 기반으로 출력 배열에 요소를 올바른 위치에 배치합니다.\n- 정렬된 요소 복사: 마지막으로, 정렬된 요소를 출력 배열에서 원래 배열로 복사합니다.\n\n# 결론\n\nCounting Sort는 요소의 범위가 제한적일 때 특히 효율적이고 간단한 정렬 알고리즘입니다. 선형 시간 복잡성은 특정 범위 내에서 대량의 데이터를 정렬하는 데 유용한 도구로 만들어줍니다. 제공된 Dart 구현은 Counting Sort를 실제 상황에 적용하는 방법을 보여주며 사용법과 이점을 명확히 전달하여 실용적인 예제를 제공합니다.","ogImage":{"url":"/assets/img/2024-06-21-TheCountingSortConundrumBalancingSpeedandResourceUsage_0.png"},"coverImage":"/assets/img/2024-06-21-TheCountingSortConundrumBalancingSpeedandResourceUsage_0.png","tag":["Tech"],"readingTime":3},{"title":"Flutter 애플리케이션에서 빌드 플레버 설정하는 방법 iOS, Android","description":"","date":"2024-06-21 20:29","slug":"2024-06-21-CreateBuildFlavorinFlutterApplicationiOSAndroid","content":"\n\n## Flutter 앱에서 다른 환경을 설정하는 방법이 궁금한 적이 있나요? 예를 들어, 다른 API URL, API 키, 개발 및 제품용 아이콘과 같은 것들을 설정해야 하는 경우가 있습니다.\n\n![이미지](/assets/img/2024-06-21-CreateBuildFlavorinFlutterApplicationiOSAndroid_0.png)\n\n이 기사에서는 동일한 소스 코드를 사용하여 iOS 및 Android 애플리케이션의 다른 환경을 어떻게 설정하는지 단계별로 배우게 될 것입니다.\n\n# 개요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 빌드 플레이버란 무엇인가요?\n- 빌드 플레이버와 빌드 모드의 차이점은 무엇인가요?\n- 환경을 정의해보세요.\n- 플러터 앱 설정하기\n- iOS에서 빌드 플레이버 설정하기\n- 안드로이드에서 빌드 플레이버 설정하기\n- 빌드 플레이버를 기반으로 앱 실행하기\n\n# 빌드 플레이버란 무엇인가요?\n\n![이미지](/assets/img/2024-06-21-CreateBuildFlavorinFlutterApplicationiOSAndroid_1.png)\n\n플러터 앱을 개발할 때, 앱의 백엔드가 프로덕션용이 아닌 개발용으로 구성된 버전을 개발 환경에서 내부 테스터와 공유하고 싶을 수 있습니다. 이 앱의 버전을 dev 변형이라고 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앱을 공개적으로 릴리스하기 준비가 되었고 프로덕션 백엔드가 설정되어 있을 때, 프로덕션 백엔드에 연결된 앱의 다른 버전인 \"prod flavor\"이 필요합니다.\n\nBuild Flavor(빌드 플레이버)는 iOS에서의 Build Configurations(빌드 설정)과 같은 역할을 하는데, 이를 통해 동일한 코드 베이스를 사용하여 앱의 개별 환경을 만들 수 있습니다. 이를 활용하여 두 개의 별도 앱을 작성하지 않고도 앱 버전을 두 개 설정할 수 있습니다.\n\n# 빌드 플레이버, 빌드 모드 및 빌드 변형의 차이\n\n## 빌드 플레이버\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n[Build Flavor(빌드 플레이버)]은 동일한 코드베이스를 사용하여 앱의 여러 환경을 만드는 방법에 관한 것입니다.\n\n## Build Mode(빌드 모드)\n\n빌드 모드는 소스 코드를 서로 다른 모드로 컴파일하는 컴파일 모드입니다.\n\n- **개발 중 디버그 모드(Debug mode)**: 핫 리로드를 사용하고 싶을 때 사용됩니다.\n- **성능 분석을 원할 때 프로파일 모드(Profile mode)**: \n- **앱을 릴리스할 준비가 된 경우 릴리스 모드(Release mode)**:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 빌드 변형\n\n빌드 변형은 빌드 모드와 빌드 플레이버의 조합으로, 단일 프로젝트에서 빌드할 애플리케이션의 버전을 사용자 정의할 수 있게 합니다. 따라서 빌드 변형은 단일 프로젝트에서 빌드할 애플리케이션의 버전 차이를 나타낼 수 있습니다. 아래의 표 형태로 나타낼 수 있습니다.\n\n![표](/assets/img/2024-06-21-CreateBuildFlavorinFlutterApplicationiOSAndroid_2.png)\n\n# 환경 정의\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플러터에서 구현 부분으로 넘어가기 전에 원하는 환경을 먼저 정의하는 것이 좋습니다. 개발 및 프로덕션 두 가지 다른 환경을 만들 것입니다.\n\n아래 표는 준비할 환경 예시이며, 개발과 프로덕션 사이에는 필요에 따라 다른 환경을 갖게 될 것입니다.\n\n![환경 예시](/assets/img/2024-06-21-CreateBuildFlavorinFlutterApplicationiOSAndroid_3.png)\n\n# 플러터 앱 설정\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 단계 1. AppConfig 파일 만들기\nAppConfig 클래스를 만들어주세요. 이 싱글톤 클래스는 플레이버별 구성을 저장하는 데 유용합니다.\n\n```dart\nimport 'package:flutter/material.dart';\n\nenum Flavor { prod, dev }\n\nclass AppConfig {\n  String appName = \"\";\n  String baseUrl = \"\";\n  MaterialColor primaryColor = Colors.blue;\n  Flavor flavor = Flavor.dev;\n\n  static AppConfig shared = AppConfig.create();\n\n  factory AppConfig.create({\n    String appName = \"\",\n    String baseUrl = \"\",\n    MaterialColor primaryColor = Colors.blue,\n    Flavor flavor = Flavor.dev,\n  }) {\n    return shared = AppConfig(appName, baseUrl, primaryColor, flavor);\n  }\n\n  AppConfig(this.appName, this.baseUrl, this.primaryColor, this.flavor);\n}\n```\n\n## 단계 2. 각 플레이버별 진입점 생성\n`lib/main_prod.dart` 파일을 만들어주세요. 이곳에서 제품 플레이버에 맞게 앱을 실행합니다. 해당 플레이버에 따라 앱의 이름을 지정할 수 있습니다.\n\n프로덕션용 진입점\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로덕션 모드에서 앱을 실행하도록 lib/main.dart 파일을 만들거나 편집하세요. 이 파일에서는 플레이버 타입을 정의하고 앱에 특정 이름, 베이스 URL, 기본 색상 등을 부여합니다.\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:medium_build_flavor/app_config.dart';\nimport 'package:medium_build_flavor/home_page.dart';\n\nvoid main() async {\n  AppConfig.create(\n    appName: \"Prod Flavor Example\",\n    baseUrl: \"https://dwirandyh.com\",\n    primaryColor: Colors.yellow,\n    flavor: Flavor.prod,\n  );\n\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({Key key});\n\n  // 이 위젯은 애플리케이션의 루트입니다.\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Flutter Demo Production',\n      theme: ThemeData(\n        primarySwatch: AppConfig.shared.primaryColor,\n      ),\n      home: const HomePage(),\n    );\n  }\n}\n```\n\n개발용 진입점\n\n개발 모드에서 앱을 실행하도록 lib/main_prod.dart 파일을 만들어보세요. 이 파일에서는 플레이버 타입을 정의하고 앱에 특정 이름, 베이스 URL, 기본 색상 등을 부여합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:medium_build_flavor/app_config.dart';\nimport 'package:medium_build_flavor/home_page.dart';\n\nvoid main() async {\n  AppConfig.create(\n    appName: \"개발 Flavor 예시\",\n    baseUrl: \"https://dev.dwirandyh.com\",\n    primaryColor: Colors.blue,\n    flavor: Flavor.prod,\n  );\n\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({Key key}) : super(key: key);\n\n  // 이 위젯은 애플리케이션의 루트입니다.\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Flutter 데모 프로덕션',\n      theme: ThemeData(\n        primarySwatch: AppConfig.shared.primaryColor,\n      ),\n      home: const HomePage(),\n    );\n  }\n}\n```\n\n단계 3. 홈 페이지\n이 홈 페이지 뷰는 우리가 진입점 파일에서 정의한 app config을 기반으로 한 구성을 표시하는 데 사용됩니다.\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:medium_build_flavor/app_config.dart';\n\nclass HomePage extends StatefulWidget {\n  const HomePage({Key? key}) : super(key: key);\n\n  @override\n  State\u003cHomePage\u003e createState() =\u003e _HomePageState();\n}\n\nclass _HomePageState extends State\u003cHomePage\u003e {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(AppConfig.shared.appName),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Text(\"앱 이름: ${AppConfig.shared.appName}\"),\n            Text(\"기본 URL: ${AppConfig.shared.baseUrl}\"),\n            Text(\"Flavor: ${AppConfig.shared.flavor}\"),\n          ],\n        ),\n      ),\n    );\n  }\n}\n```\n\n# iOS용 빌드 Flavor 설정\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n### Step 1. 대상 복제\nios/Runner.xcworkspace을 여세요. Runner 대상을 복제합니다. 이렇게 하면 두 개의 서로 다른 대상이 생성됩니다. 방금 만든 dev 대상은 개발 대상으로 사용되고 기본 대상인 Runner은 prod로 이름을 변경하여 프로덕션 대상으로 사용됩니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*3pl3Ash1kCDEecmnD1RIeg.gif)\n\n### Step 2. 스킴 이름 바꾸기\n대상을 복제하면 생성된 스킴을 이름을 변경해야 합니다. Runner을 dev로 이름을 변경합니다. 이 스킴은 dev 플레이버를 사용하여 flutter 명령을 실행할 때 식별자로 사용됩니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*yGyUZHGWN7cI3XW-m9k69A.gif)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 Markdown 형식으로 변경해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 시점에서 CLI에서 flutter run -t lib/main_dev.dart --flavor dev를 실행하면 사용자 정의 스키마를 완료해야 할 정보가 표시됩니다. 안내에 따라 사용자 정의 스키마 설정을 마무리하세요.\n\n```js\nXcode 프로젝트는 빌드 구성(Debug, Release, Profile)을 정의합니다.\nFlutter는 Debug-dev 또는 유사한 이름의 빌드 구성을 예상합니다.\n문제를 해결하기 위해 Xcode를 엽니다:\n  ios/Runner.xcworkspace 파일을 엽니다.\n1. 프로젝트 탐색기에서 \"Runner\"를 클릭합니다.\n2. Runner PROJECT가 선택되었는지 확인하고 Runner TARGET이 아닌지 확인하세요.\n3. 편집기-\u003e구성 추가-\u003e\"Debug\" 구성 복제를 클릭합니다.\n\n   이 옵션이 비활성화된 경우, 대상 대신 프로젝트를 선택한 것일 수 있습니다.\n   https://stackoverflow.com/questions/19842746/adding-a-build-configuration-in-xcode\n   을 참조하세요.\n\n   완전히 사용자 정의된 빌드 구성 세트를 만들었다면, 새 구성에서 .xcconfig 파일에 FLUTTER_BUILD_MODE=debug를 설정하고 Xcode에서 실행할 수 있습니다.\n\n4. 완전히 사용자 정의된 빌드 구성을 사용하지 않는 경우, 새로 만든 구성을 debug로 명명하세요.\n시뮬레이터용 응용 프로그램을 빌드할 수 없습니다.\niPhone 14 Pro에서 애플리케이션을 시작하지 못했습니다.\r\n```\n\nStep 3. 개발용 빌드 모드 구성 추가\n\n모든 빌드 모드에 대한 빌드 구성을 정의해야 하므로 각 구성 (Debug, Release 및 Profile)을 + 기호를 클릭하여 복제하고 -dev 접미사를 추가하는 것을 잊지 마세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*2osPENEcGz9zFDCboBsZxw.gif)\n\n우리는 또한 기본 구성 이름을 변경하고 -prod 접미사를 추가해야 합니다.\n\n![이미지](/assets/img/2024-06-21-CreateBuildFlavorinFlutterApplicationiOSAndroid_6.png)\n\n4단계. 개발 환경을 위한 앱 ID 변경\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앱 ID는 iOS 및 안드로이드 앱을 식별하는 데 사용되는 고유 식별자입니다. 앱 개발자가 할당하는 문자열이며, 장치에 설치될 때 운영 체제가 앱을 식별하는 데 사용됩니다.\n\n개발을 위해 고유 식별자로 .dev 접미사를 추가할 수 있고, 제품용은 그대로 둘 수 있습니다\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*Og8WrFL3zvlOvpcVVaiK4A.gif)\n\n단계 5. 개발용 앱 아이콘 변경\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희는 앱 아이콘을 환경마다 변경할 수도 있습니다. 이번 경우에는 개발 환경을 위해 앱 아이콘을 변경할 거에요. 이렇게 하면 우리는 프로덕션 및 개발 애플리케이션에 다른 앱 아이콘이 나타날 거에요.\n\n개발 환경에서 앱 아이콘을 변경하려면 Assets.xcassets 안에 있는 AppIcon을 복제하고 AppIconDev이라고 이름을 지정하면 돼요.\n\n그 다음에는 RunnerDev 빌드 설정에서 'Primary App Icon Set Name'을 AppIconDev로 변경해야 해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image](https://miro.medium.com/v2/resize:fit:1400/1*2mQ1CJ_sPyIHHSodjqCVGg.gif)\n\n어플리케이션에서 변경 사항을 보려면 flutter run lib/main_dev.dart --flavor dev 명령어를 다시 실행하면, 개발용 앱 아이콘이 변경된 것을 확인할 수 있습니다.\n\n# 안드로이드에서 빌드 플레이버 설정하기\n\n단계 1. 플레이버 구성 추가\n안드로이드에서 빌드 플레이버를 생성하기 위한 첫 번째 단계는 app/build.gradle 파일에 일부 구성을 추가해야 합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```json\n안드로이드 {\n  defaultConfig {\n         ...\n      }\n  ...\n  flavorDimensions \"default\"\n  productFlavors {\n      prod {\n          dimension \"default\"\n          resValue \"string\", \"app_name\", \"Flutter Demo Prod\"\n      }\n      dev {\n          dimension \"default\"\n          applicationIdSuffix \".dev\"\n          resValue \"string\", \"app_name\", \"Flutter Demo Dev\"\n          versionNameSuffix \".dev\"\n      }\n  }\n  \n}\n```\n\n단계 2. 개발용 아이콘 변경\n\n개발 애플리케이션을 위한 앱 아이콘을 변경하려면 app/src/dev 내에 디렉토리를 생성하고 해당 폴더에 모든 앱 아이콘 리소스를 넣어야 합니다. 이렇게 하면 개발 플레이버를 실행할 때 dev/res 디렉토리에서 ic_launcher를 사용할 수 있습니다\n\n\u003cimg src=\"/assets/img/2024-06-21-CreateBuildFlavorinFlutterApplicationiOSAndroid_8.png\" /\u003e\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 플레이버에 기반한 앱 실행\n\n앱을 실행하려면 다음 명령을 사용해야 합니다:\n\n각 플레이버를 DEBUG 모드로 실행하는 방법:\n\n- flutter run -t lib/main.dart --flavor prod\n- flutter run -t lib/main_dev.dart --flavor dev\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n각각의 플레이버를 PROFILE 모드에서 실행하려면:\n\n- flutter run --profile -t lib/main.dart --flavor prod\n- flutter run --profile -t lib/main_dev.dart --flavor dev\n\n각각의 플레이버를 RELEASE 모드에서 실행하려면:\n\n- flutter run --release -t lib/main.dart --flavor prod\n- flutter run --release -t lib/main_dev.dart --flavor dev\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래의 저장소에서 전체 프로젝트를 다운로드할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-21-CreateBuildFlavorinFlutterApplicationiOSAndroid_0.png"},"coverImage":"/assets/img/2024-06-21-CreateBuildFlavorinFlutterApplicationiOSAndroid_0.png","tag":["Tech"],"readingTime":10},{"title":"Flutter 테스트 완벽 가이드 유닛 테스트부터 통합 테스트까지","description":"","date":"2024-06-21 20:26","slug":"2024-06-21-TestinginFlutterFromUnitTeststoIntegrationTests","content":"\n\n## 플러터 앱 품질 확보를 위한 포괄적 가이드\n\n테스트는 소프트웨어 개발 주기의 중요한 부분으로, 애플리케이션이 예상대로 작동하고 높은 수준의 품질을 유지하도록 보장합니다. Flutter에서는 다양한 도구와 실천 방법을 통해 편리하고 효과적인 테스트를 수행할 수 있습니다. 이 안내서에서는 Flutter에서 사용 가능한 다양한 유형의 테스트를 안내하고 예제를 제공하며 효과적인 테스트 작성을 위한 모범 사례를 공유합니다.\n\n![이미지](/assets/img/2024-06-21-TestinginFlutterFromUnitTeststoIntegrationTests_0.png)\n\n# 1. 유닛 테스트\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n단위 테스트는 기능을 독립적으로 확인하는 데 사용됩니다. 함수나 클래스와 같은 개별 구성 요소의 동작을 검증합니다. 이는 견고한 테스트 전략의 기반입니다.\n\n# 단위 테스트 설정하기\n\n플러터에서 단위 테스트를 설정하려면 pubspec.yaml 파일에 test 종속성을 추가하세요:\n\n```yaml\ndev_dependencies:\n  test: ^1.16.0Writing Unit Tests\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 유닛 테스트 작성\n\n다트 언어로 작성된 간단한 함수와 해당하는 유닛 테스트의 예시가 있습니다:\n\n```dart\n// math_utils.dart\nint add(int a, int b) =\u003e a + b;\n\n// math_utils_test.dart\nimport 'package:test/test.dart';\nimport 'math_utils.dart';\n\nvoid main() {\n  test('두 숫자의 덧셈', () {\n    expect(add(2, 3), 5);\n    expect(add(-1, 1), 0);\n  });\n}\n```\n\n# 유닛 테스트 실행\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 명령을 사용하여 단위 테스트를 실행할 수 있어요:\n\n```js\nflutter test\n```\n\n# 2. 위젯 테스트\n\n위젯 테스트는 개별 위젯 및 상호 작용의 동작을 확인합니다. 통합 테스트보다 빠르게 실행되며 실제 장치 또는 에뮬레이터가 필요하지 않아요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 위젯 테스트 설정하기\n\n새로운 플러터 프로젝트를 생성할 때 기본으로 포함되어 있는 flutter_test 종속성을 추가해주세요.\n\n# 위젯 테스트 작성하기\n\n간단한 카운터 앱을 위한 위젯 테스트 예시입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\n// main.dart\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: CounterPage(),\n    );\n  }\n}\n\nclass CounterPage extends StatefulWidget {\n  @override\n  _CounterPageState createState() =\u003e _CounterPageState();\n}\n\nclass _CounterPageState extends State\u003cCounterPage\u003e {\n  int _counter = 0;\n\n  void _incrementCounter() {\n    setState(() {\n      _counter++;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Counter App'),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: \u003cWidget\u003e[\n            Text(\n              'You have pushed the button this many times:',\n            ),\n            Text(\n              '$_counter',\n              style: Theme.of(context).textTheme.headline4,\n            ),\n          ],\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: _incrementCounter,\n        tooltip: 'Increment',\n        child: Icon(Icons.add),\n      ),\n    );\n  }\n}    \n```\n\n```dart\n// counter_page_test.dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:my_app/main.dart';\n\nvoid main() {\n  testWidgets('Counter increments smoke test', (WidgetTester tester) async {\n    await tester.pumpWidget(MyApp());\n\n    expect(find.text('0'), findsOneWidget);\n    expect(find.text('1'), findsNothing);\n\n    await tester.tap(find.byIcon(Icons.add));\n    await tester.pump();\n\n    expect(find.text('0'), findsNothing);\n    expect(find.text('1'), findsOneWidget);\n  });\n}\n```\n\n# Running Widget Tests\n\nUse the same command as for unit tests:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n플러터 테스트\n```\n\n## 3. 통합 테스트\n\n통합 테스트는 앱의 모든 부분이 예상대로 함께 작동하는지 확인합니다. 실제 기기나 에뮬레이터에서 실행되며 실제 사용자 상호작용을 시뮬레이션합니다.\n\n## 통합 테스트 설정하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\npubspec.yaml 파일에 integration_test dependency를 추가해주세요:\n\n```yaml\ndev_dependencies:\n  integration_test: ^1.0.2\n  flutter_test:\n    sdk: flutter\n```\n\n# 통합 테스트 작성\n\n다음은 카운터 앱을 위한 통합 테스트의 예시입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\n// counter_app_test.dart\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:integration_test/integration_test.dart';\nimport 'package:my_app/main.dart' as app;\n\nvoid main() {\n  IntegrationTestWidgetsFlutterBinding.ensureInitialized();\n\n  testWidgets('Counter increments test', (WidgetTester tester) async {\n    app.main();\n    await tester.pumpAndSettle();\n\n    expect(find.text('0'), findsOneWidget);\n    expect(find.text('1'), findsNothing);\n\n    await tester.tap(find.byIcon(Icons.add));\n    await tester.pumpAndSettle();\n\n    expect(find.text('0'), findsNothing);\n    expect(find.text('1'), findsOneWidget);\n  });\n}\n```\n\n# 통합 테스트 실행\n\n다음 명령을 사용하여 통합 테스트를 실행할 수 있습니다:\n\n```js\nflutter drive --target=test_driver/integration_test.dart\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Flutter 테스팅을 위한 Best Practices\n\n- 명료하고 간결한 테스트 작성: 테스트가 쉽게 읽히고 이해되도록 합니다.\n- 외부 의존성을 모의(Mocking)화: 테스트 중인 구성 요소를 격리하기 위해 모킹을 사용합니다.\n- 테스트 자동화: 테스트를 CI/CD 파이프라인에 통합하여 문제를 빨리 파악합니다.\n- 여러 기기에서 테스트: 앱이 다양한 화면 크기와 OS 버전에서 작동하는지 확인합니다.\n- 테스트를 빠르게 유지: 빠른 피드백을 제공하는 테스트 작성에 주력하여 개발 프로세스를 효율적으로 유지합니다.\n\n# 결론\n\n테스트는 고품질의 Flutter 애플리케이션을 개발하는 중요한 부분입니다. 단위 테스트, 위젯 테스트, 통합 테스트를 이해하고 활용하여 앱이 믿을 수 있고 성능이 우수하며 훌륭한 사용자 경험을 제공하는지 확인할 수 있습니다. 이러한 테스트 전략을 개발 워크플로에 구현하여 버그를 초기에 잡고 코드 품질의 높은 기준을 유지하세요. 즐거운 테스팅 되세요!","ogImage":{"url":"/assets/img/2024-06-21-TestinginFlutterFromUnitTeststoIntegrationTests_0.png"},"coverImage":"/assets/img/2024-06-21-TestinginFlutterFromUnitTeststoIntegrationTests_0.png","tag":["Tech"],"readingTime":5},{"title":"Flutter로 강력한 크로스플랫폼 모바일 앱 만드는 방법","description":"","date":"2024-06-21 20:24","slug":"2024-06-21-BuildingPowerfulCross-PlatformMobileAppswithFlutter","content":"\n\n플러터(Flutter)를 활용하여 모바일 개발의 최대 잠재력을 발휘하세요. iOS와 안드로이드를 위한 고성능, 아름다운 앱을 만드는 방법을 배워보세요!\n\n![플러터 이미지](/assets/img/2024-06-21-BuildingPowerfulCross-PlatformMobileAppswithFlutter_0.png)\n\n오늘날 빠르게 변화하는 디지털 환경에서, 모바일 앱 개발자들은 여러 플랫폼에서 원활히 실행되는 고품질 앱을 효율적으로 구축하는 방법을 계속해서 찾고 있습니다. 구글의 UI 툴킷인 플러터(Flutter)는 이 분야에서 혁신적인 변화를 가져오고 있습니다.\n\n본 블로그는 플러터에 대해 소개하고, 그 혜택을 소개하며 플러터를 사용하여 크로스 플랫폼 모바일 앱을 개발하는 포괄적인 가이드를 제공하는 것을 목표로 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플러터의 배경, 필수 도구와 기술, 단계별 구현 가이드, 그리고 실제 사례 연구를 포함하여 그 효과를 강조할 예정입니다. 마지막에는 플러터가 크로스 플랫폼 모바일 개발에 대한 최고의 선택인 이유에 대해 명확히 이해하게 될 것입니다.\n\n플러터는 구글에서 만든 오픈 소스 UI 소프트웨어 개발 키트(SDK)입니다. 이를 통해 개발자는 단일 코드베이스로 모바일, 웹 및 데스크톱용 네이티브 컴파일된 애플리케이션을 구축할 수 있습니다.\n\niOS와 Android에서 모두 작동하는 앱이 필요한 수요가 증가함에 따라, 플러터는 개발 시간과 비용을 줄이는 강력한 솔루션을 제공하며 높은 성능과 품질을 유지합니다.\n\n도구 설명:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플러터 SDK: 앱을 개발하는 데 필요한 모든 것을 포함하는 핵심 도구 모음인 SDK입니다. 라이브러리, API 및 도구가 포함됩니다.\n\n다트 언어: 플러터는 빠른 앱을 위해 최적화된 언어인 다트를 사용합니다.\n\n플러터 프레임워크: 복잡한 UI를 쉽게 만들 수 있도록 도와주는 재사용 가능한 위젯 모음입니다.\n\nIDE 지원: 플러터는 안드로이드 스튜디오, 인텔리제이, 비주얼 스튜디오 코드와 같은 인기 있는 IDE에서 지원되며 유용한 플러그인과 확장 기능을 통해 개발 경험을 향상시킵니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n혜택:\n\n단일 코드베이스: 한 번 작성하고 어디서나 실행하세요. Flutter를 사용하면 iOS 및 Android 앱 모두에 대해 단일 코드베이스를 사용할 수 있습니다.\n\n빠른 개발: 핫 리로드 기능을 통해 변경 사항을 즉시 볼 수 있어 개발 프로세스를 가속화시킵니다.\n\n표현력이 풍부하고 유연한 UI: Flutter의 다양한 사전 설계된 위젯과 다양한 사용자 정의 옵션을 통해 아름다운, 매우 적응 가능한 UI를 만들 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n단계별 안내:\n\nFlutter 설정하기:\n\n- 공식 Flutter 웹사이트에서 Flutter SDK 설치하기.\n- 선호하는 통합 개발 환경(예: Visual Studio Code 또는 Android Studio) 설정하기.\n\n새로운 Flutter 프로젝트 생성하기:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nflutter create my_app\ncd my_app\n```\n\n앱 실행하기:\n\n- 기기를 연결하거나 에뮬레이터를 시작합니다.\n- flutter run을 실행하여 앱을 시작합니다.\n\nUI 디자인:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport 'package:flutter/material.dart';\n\nvoid main() =\u003e runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: Text('Hello Flutter')),\n        body: Center(child: Text('Welcome to Flutter')),\n      ),\n    );\n  }\n}\n```\n\n상호 작용성 추가:\n\n```js\nclass MyApp extends StatefulWidget {\n  @override\n  _MyAppState createState() =\u003e _MyAppState();\n}\n\nclass _MyAppState extends State\u003cMyApp\u003e {\n  int _counter = 0;\n\n  void _incrementCounter() {\n    setState(() {\n      _counter++;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: Text('Counter App')),\n        body: Center(\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: \u003cWidget\u003e[\n              Text('버튼을 누른 횟수:'),\n              Text('$_counter', style: Theme.of(context).textTheme.headline4),\n            ],\n          ),\n        ),\n        floatingActionButton: FloatingActionButton(\n          onPressed: _incrementCounter,\n          tooltip: '증가',\n          child: Icon(Icons.add),\n        ),\n      ),\n    );\n  }\n}\n```\n\n실전 케이스 스터디:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 구글 애드워즈: 이 앱은 Flutter를 사용하여 플랫폼 간에 표현력 있는 UI 및 높은 성능을 제공합니다.\n- 알리바바: 플러터를 선택하여 탁월한 플랫폼 간 기능을 갖추고 사용자 경험을 향상시키며 개발 시간을 단축했습니다.\n\n성능: Flutter 앱은 거의 네이티브 속도를 제공하여 성능이 우수합니다.\n\n개발 효율성: 팀들은 개발 및 테스트 시간을 상당히 단축했다고 보고하고 있습니다.\n\n커뮤니티 지원: 강력하고 활발한 커뮤니티가 Flutter의 지속적인 향상과 리소스 이용 가능성에 기여합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플러터(Flutter)는 통합적이고 효율적이며 유연한 접근 방식을 제공하여 크로스 플랫폼 모바일 앱 개발을 혁신하고 있습니다. 포괄적인 툴킷과 단일 코드베이스는 개발의 복잡성과 비용을 줄입니다.\n\n플러터를 채택하면 고품질의 앱을 빠르고 효율적으로 제공할 수 있는 능력이 상당히 향상되어, 개발자와 비즈니스에게 모두 귀중한 기술이 됩니다.\n\n오늘부터 플러터를 탐험하고 첫 번째 앱을 만들어보며 플러터 개발자 커뮤니티에 참여해 보세요.\n\n독서/자료:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 플러터 문서\n- 다트 언어 안내서\n- 플러터 패키지\n\n다운로드:\n\n- 플러터 SDK\n- 비주얼 스튜디오 코드\n\n플러터에 대한 경험을 공유하거나 궁금한 점이 있다면 아래 댓글에 남겨주세요.","ogImage":{"url":"/assets/img/2024-06-21-BuildingPowerfulCross-PlatformMobileAppswithFlutter_0.png"},"coverImage":"/assets/img/2024-06-21-BuildingPowerfulCross-PlatformMobileAppswithFlutter_0.png","tag":["Tech"],"readingTime":4},{"title":"Flutter 기본 위젯들을 알고 계신가요","description":"","date":"2024-06-21 20:23","slug":"2024-06-21-DoyouknowthebasicwidgetsofFlutter","content":"\n\n\"플러터로 UI를 만들고 싶으신가요? 네.\n\n플러터의 기본 위젯을 아시나요?\n\n# 아니라면, 읽어보세요.\n\n플러터에는 전체 프레임워크에서 사용할 수 있는 다양한 유용한 위젯이 있지만, 플러터에서 UI를 만들기 시작할 때 알고 있어야 하는 가장 기본적인 위젯을 여기에 소개합니다.\"\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n1) **Scaffold**: Scaffold는 기본적인 재료 디자인 시각적 레이아웃 구조를 구현하는 데 사용되는 플러터 위젯입니다.\n\n![이미지](/assets/img/2024-06-21-DoyouknowthebasicwidgetsofFlutter_0.png)\n\n2) **Row**: Row 위젯은 자식 위젯을 가로로 정렬합니다. 여러 위젯을 연이어 표시하는 데 일반적으로 사용됩니다.\n\n![이미지](/assets/img/2024-06-21-DoyouknowthebasicwidgetsofFlutter_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3) **컬럼:** 컬럼 위젯은 플러터 애플리케이션에서 가장 일반적으로 사용되는 레이아웃 패턴 중 하나입니다. 이는 수직 배열로 자식 위젯을 표시하는 다중 자식 위젯입니다.\n\n![Column Widget](/assets/img/2024-06-21-DoyouknowthebasicwidgetsofFlutter_2.png)\n\n4) **스택:** 플러터에서의 스택은 여러 위젯을 겹쳐서 표시할 수 있게 해주는 위젯입니다.\n\n![Stack Widget](/assets/img/2024-06-21-DoyouknowthebasicwidgetsofFlutter_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이미지 안에 있는 링크를 통해 더 많은 정보를 얻을 수 있어요.\n\n더 많은 플러터 콘텐츠를 보려면 Panchalyagnik을 팔로우해 주세요.","ogImage":{"url":"/assets/img/2024-06-21-DoyouknowthebasicwidgetsofFlutter_0.png"},"coverImage":"/assets/img/2024-06-21-DoyouknowthebasicwidgetsofFlutter_0.png","tag":["Tech"],"readingTime":1},{"title":"Flutter에서 Clean Architecture 시작하기","description":"","date":"2024-06-21 20:21","slug":"2024-06-21-IntroductiontoCleanArchitectureinFlutter","content":"\n\n\n![Clean Architecture in Flutter](/assets/img/2024-06-21-IntroductiontoCleanArchitectureinFlutter_0.png)\n\nFlutter는 빠르게 인기를 얻은 프레임워크로, 크로스 플랫폼 모바일 애플리케이션을 구축하는 데 사용됩니다. 사용하기 쉽고 강력한 기능으로 많은 개발자들에게 선택되는 이유입니다. 그러나 앱이 성장함에 따라 깨끗하고 확장 가능하며 테스트 가능한 코드를 유지하는 것이 어려워질 수 있습니다. 이때 Clean Architecture가 필요합니다.\n\n# Clean Architecture란?\n\nClean Architecture는 로버트 C. 마틴 (Uncle Bob)이 만든 용어로, 관심사 분리를 촉진하여 시스템이 유지 가능하고 확장 가능하며 테스트 가능하도록 하는 소프트웨어 디자인 접근 방식입니다. 핵심 아이디어는 앱을 계층으로 나누어 각각에 특정 책임을 부여하여 내부 계층이 외부 계층에 의존하지 않도록 하는 것입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-21-IntroductiontoCleanArchitectureinFlutter_1.png\" /\u003e\n\n## Clean Architecture의 주요 원칙\n\n- 염려 사항의 분리: 기능에 따라 응용 프로그램을 구분된 섹션으로 분할합니다. 이는 복잡성을 줄이고 코드 가독성을 향상시킵니다.\n- 의존성 규칙: 모든 소스 코드 의존성은 내부로 향해야 합니다. 상위 레이어는 하위 레이어에 의존해서는 안 되며, 내부 레이어는 외부 레이어에 대해 알 필요가 없습니다.\n- 프레임워크로부터 독립: 아키텍처는 특정 프레임워크의 존재에 의존해서는 안 됩니다. 이렇게 하면 시스템을 프레임워크에 의존시키는 대신에 도구로써 프레임워크를 사용할 수 있습니다.\n- 테스트 가능성: 비즈니스 로직을 UI, 데이터베이스, 웹 서버 또는 다른 외부 요소 없이 테스트할 수 있어 자동화된 테스트가 쉬워집니다.\n- UI의 독립성: UI를 변경할 때 시스템의 나머지 부분에 영향을 미치지 않습니다. 예를 들어, 웹 UI를 비즈니스 규칙을 변경하지 않고 콘솔 UI로 교체할 수 있습니다.\n- 데이터베이스의 독립성: 비즈니스 규칙은 데이터베이스에 종속되지 않으므로 데이터베이스 간 쉬운 전환을 허용합니다.\n- 모든 외부 기관의 독립성: 비즈니스 규칙은 외부 세계에 대해 아무것도 알지 못하도록 하여 일관성과 안정성을 보장합니다.\n\n# Clean Architecture 코네\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nClean Architecture 콘은 Clean Architecture 원칙을 따라 설계된 시스템의 구조를 보여줍니다. 다이어그램에는 여러 원이 나란히 그려져 있습니다. 각각 다른 애플리케이션 계층을 나타냅니다. 최외부 원에는 저수준의 구체적인 세부 사항이 들어 있고, 최내부 원에는 고수준의 추상적인 정책이 포함되어 있습니다.\n\n![Clean Architecture Cone](/assets/img/2024-06-21-IntroductiontoCleanArchitectureinFlutter_2.png)\n\n## Clean Architecture Cone의 계층\n\n- Entities (기업 비즈니스 규칙): 핵심 데이터 구조와 비즈니스 규칙을 나타냅니다. 이러한 계층은 매우 안정적이며 변경될 가능성이 매우 낮습니다.\n- Use Cases (애플리케이션 비즈니스 규칙): 응용 프로그램별 비즈니스 규칙을 포함하며 엔티티 및 외부 세계 간 데이터 흐름을 조정합니다.\n- Controllers, Gateways, Presenters (인터페이스 어댑터): UI와 비즈니스 로직 간 통신을 처리하고 계층 간 데이터를 적응시킵니다. 이는 상태 관리 솔루션 및 프레젠테이션 로직을 포함합니다.\n- User Interface, Database, Devices (프레임워크 및 드라이버): 최외부 계층으로, 데이터베이스, 웹 프레임워크, UI, 장치 등과 같은 외부 요소를 포함합니다. 이 계층은 외부 세계와 상호 작용하며 변경될 가능성이 가장 높습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 플러터에 Cone 적용하기\n\n이제 이러한 개념들이 플러터 프로젝트로 어떻게 전환되는지 탐색해보겠습니다. Clean Architecture의 각 계층을 구체적인 구성 요소로 매핑하는 방법을 이해하면 견고하고 유지보수 가능한 애플리케이션을 구축하는 데 도움이 됩니다.\n\n- 사용자 인터페이스, 데이터베이스, 장치: 플러터에서 이 계층은 플러터 SDK 자체, 외부 패키지 및 플러그인을 포함합니다. 예를 들어, 플러터 SDK에는 UI를 구축하는 위젯이 포함되어 있습니다.\n- 컨트롤러, 게이트웨이, 프레젠터: 이 계층은 BLoC와 Provider와 같은 플러터의 상태 관리 솔루션을 포함하며 데이터 및 UI 상태의 흐름을 관리합니다.\n- 사용 사례: 비즈니스 규칙을 처리하는 사용 사례 클래스를 사용하여 애플리케이션별 로직을 구현합니다.\n- 엔티티: 핵심 데이터 구조와 비즈니스 규칙을 일반적인 Dart 클래스로 정의합니다.\n\n# 실전에서의 의존성 규칙\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n의존성 규칙은 모든 종속성이 안쪽으로 향해야 함을 보장합니다. 내부 원 안의 코드는 외부 원에 대해 아무것도 알지 못해야 합니다. 이 규칙을 준수하면 비즈니스 로직을 격리된 상태로 테스트하는 것이 더 쉬워지며, 내부 레이어에 영향을 주지 않고 외부 레이어를 변경하는 유연성이 향상됩니다.\n\n# 플러터에서 클린 아키텍처의 장점\n\n플러터 프로젝트에서 클린 아키텍처를 채택함으로써 다음과 같은 혜택을 누릴 수 있습니다:\n\n- 향상된 코드 품질: 역할의 명확한 분리로 인해 더 깨끗하고 가독성 있는 코드를 작성할 수 있습니다.\n- 쉬운 테스트: 레이어 간의 명확한 경계는 테스트를 작성하고 유지보수하기 쉽게 만듭니다.\n- 더 나은 확장성: 모듈식 코드를 통해 새로운 기능을 추가하거나 변경을 가할 때 다른 부분에 영향을 주지 않고 진행할 수 있습니다.\n- 향상된 유지보수성: 더 깔끔한 아키텍처는 코드를 이해하고 디버깅하며 확장하는 데 용이하게 만듭니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n플러터에서의 Clean Architecture는 확장 가능하고 테스트 가능하며 유지보수가 용이한 애플리케이션을 구축하는 데 도움이 됩니다. 앱을 다양한 계층으로 분리함으로써 복잡성을 관리하고 코드를 깔끔하고 모듈화된 상태로 유지할 수 있습니다.\n\n# 다음은 무엇인가요?\n\n다음 기사에서는 \"Clean Architecture로 플러터 프로젝트 설정 및 구성하기\"를 안내해 드리겠습니다. 프로젝트 구조 설정, 의존성 구성, 그리고 깔끔하고 견고한 플러터 애플리케이션 구축에 시작하는 방법에 대해 다룰 것입니다. 기대해 주세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 참고 자료\n\n- Clean Coder 블로그\n- Clean Architecture에 대한 간단한 소개","ogImage":{"url":"/assets/img/2024-06-21-IntroductiontoCleanArchitectureinFlutter_0.png"},"coverImage":"/assets/img/2024-06-21-IntroductiontoCleanArchitectureinFlutter_0.png","tag":["Tech"],"readingTime":4}],"page":"10","totalPageCount":20,"totalPageGroupCount":1,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"10"},"buildId":"fyfGyRz00q80ZdkogiVCt","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>