<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>uidev-css</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://uidev-css.github.io///posts/1" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="uidev-css" data-gatsby-head="true"/><meta property="og:title" content="uidev-css" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://uidev-css.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://uidev-css.github.io///posts/1" data-gatsby-head="true"/><meta name="twitter:title" content="uidev-css" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | uidev-css" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/873-1e1f6fb6fd3c8994.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-498da29379dd58dc.js" defer=""></script><script src="/_next/static/CfGULpm6qSb4RqH-Y7KhT/_buildManifest.js" defer=""></script><script src="/_next/static/CfGULpm6qSb4RqH-Y7KhT/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UIDEV CSS</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="CS50 경험 공유 2024 최신 강의 리뷰 및 배우는 방법" href="/post/2024-06-21-MyCS50experience"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="CS50 경험 공유 2024 최신 강의 리뷰 및 배우는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-MyCS50experience_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="CS50 경험 공유 2024 최신 강의 리뷰 및 배우는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">CS50 경험 공유 2024 최신 강의 리뷰 및 배우는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 21, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="구글 클래스룸으로 교사와 학생을 하나로 Flutter를 사용한 크로스 플랫폼 개발 방법" href="/post/2024-06-21-CrossPlatformdevelopmentwithFlutterHowGoogleClassroomgetsteachersandstudentsonthesamepage"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="구글 클래스룸으로 교사와 학생을 하나로 Flutter를 사용한 크로스 플랫폼 개발 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-CrossPlatformdevelopmentwithFlutterHowGoogleClassroomgetsteachersandstudentsonthesamepage_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="구글 클래스룸으로 교사와 학생을 하나로 Flutter를 사용한 크로스 플랫폼 개발 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">구글 클래스룸으로 교사와 학생을 하나로 Flutter를 사용한 크로스 플랫폼 개발 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 21, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="CSS 네이티브 중첩 기능 완벽 해부하기" href="/post/2024-06-21-UnpackingNativeCSSNesting"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="CSS 네이티브 중첩 기능 완벽 해부하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-UnpackingNativeCSSNesting_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="CSS 네이티브 중첩 기능 완벽 해부하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">CSS 네이티브 중첩 기능 완벽 해부하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 21, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter에서 리프레시 토큰 사용하는 방법 모바일" href="/post/2024-06-21-FlutterRefreshtokenmobileside"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter에서 리프레시 토큰 사용하는 방법 모바일" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-FlutterRefreshtokenmobileside_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter에서 리프레시 토큰 사용하는 방법 모바일" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Flutter에서 리프레시 토큰 사용하는 방법 모바일</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 21, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="데이터베이스에서 UUID 사용을 중단해야 하는 이유" href="/post/2024-06-21-StopUsingUUIDsinYourDatabase"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="데이터베이스에서 UUID 사용을 중단해야 하는 이유" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-StopUsingUUIDsinYourDatabase_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="데이터베이스에서 UUID 사용을 중단해야 하는 이유" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">데이터베이스에서 UUID 사용을 중단해야 하는 이유</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 21, 2024</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="선명한 이미지가 흐릿한 단어 천 개보다 나은 이유" href="/post/2024-06-21-Asharpimageisworthathousandblurrywords"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="선명한 이미지가 흐릿한 단어 천 개보다 나은 이유" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-Asharpimageisworthathousandblurrywords_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="선명한 이미지가 흐릿한 단어 천 개보다 나은 이유" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">선명한 이미지가 흐릿한 단어 천 개보다 나은 이유</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 21, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="코드 플로우 - 60초 랩으로 배우는 Flutter 패키지 " href="/post/2024-06-21-CodeFlow1My60SecondRapAboutFlutterPackages"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="코드 플로우 - 60초 랩으로 배우는 Flutter 패키지 " loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-CodeFlow1My60SecondRapAboutFlutterPackages_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="코드 플로우 - 60초 랩으로 배우는 Flutter 패키지 " loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">코드 플로우 - 60초 랩으로 배우는 Flutter 패키지 </strong><div class="PostList_meta__VCFLX"><span class="date">Jun 21, 2024</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Airclap  모든 기기에 파일 전송하기" href="/post/2024-06-21-AirclapSendanyfiletoanydevice"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Airclap  모든 기기에 파일 전송하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-AirclapSendanyfiletoanydevice_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Airclap  모든 기기에 파일 전송하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Airclap  모든 기기에 파일 전송하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 21, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter에서 Provider로 상태 관리 이해하기" href="/post/2024-06-21-UnderstandingstatemanagementwithProviderinFlutter"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter에서 Provider로 상태 관리 이해하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-UnderstandingstatemanagementwithProviderinFlutter_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter에서 Provider로 상태 관리 이해하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Flutter에서 Provider로 상태 관리 이해하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 21, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter 검색바 궁극의 가이드" href="/post/2024-06-21-FlutterSearchBarAnUltimateGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter 검색바 궁극의 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-FlutterSearchBarAnUltimateGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter 검색바 궁극의 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Flutter 검색바 궁극의 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 21, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link posts_-active__YVJEi" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"CS50 경험 공유 2024 최신 강의 리뷰 및 배우는 방법","description":"","date":"2024-06-21 23:59","slug":"2024-06-21-MyCS50experience","content":"\n\n\n![My CS50 Experience](/assets/img/2024-06-21-MyCS50experience_0.png)\n\n몇 달 전, 프로그래밍 여정에서 무엇을 해야 할지 전혀 감이 오지 않았어요. 그런 다음 몇몇 유튜버와 친구들의 충고 덕분에 내 CS50 여정을 시작했어요. 말하고 싶은 게—정말 훌륭한 경험이었어요!\n\n# 몇 주 전에 CS50 코스를 완료했어요\n\n- Scratch, C, 데이터 구조, 메모리 관리, HTML, CSS, SQLite, Python, JavaScript, Flask 등과 같은 다양한 기술들을 탐험하고 배우며 실패하고 이해했죠.\n- 이러한 기술들의 기초를 이렇게 짧은 시간 안에 이해하고 창의적인 설명과 시범을 통해 배웠던 것은 놀라운 경험이었어요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![2024-06-21-MyCS50experience_1.png](/assets/img/2024-06-21-MyCS50experience_1.png)\n\n- 매주 해당되는 문제 세트들은 정말 도전적이었고 내 지식과 프로그래밍 기술을 향상시키는 데 도움이 되었어요.\n\n# 문제 세트\n\n- 솔직히 말해서, 문제 세트는 최고의 것 중 하나였고, 브라이언이 문제와 해결책을 설명하는 짧은 단편이 놀랍었어요.\n- 64비트 수학을 활용하여 일반 이미지를 다양한 필터로 변환하는 문제 세트, GET 및 POST 요청의 라우팅을 찾고 Flask에서 다양한 작업을 수행해야 했던 재무 문제 세트, 그리고 데이터베이스 레코드를 활용해 도둑을 잡아야 했던 Fiftyville은 정말 흥미진진한 경험이었어요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 가장 자신없을 때\n\n- 지금은 그 경험이 훌륭했다고 말하지만, 그 코스를 수강할 때는 언제나 가짜인 줄로 느꼈습니다.\n- 제가 진짜 수행할 수 있을지 항상 의심했지만, 거기에 함께 수강한 친구가 있었어요. 그 친구 덕분에 이제는 완료에 관한 블로그를 쓰고 있답니다 🙂\n\n# 최종 프로젝트\n\n- 코스의 마지막 부분에 도착하여 최종 프로젝트를 수행할 때, 계속해서 어떻게 진행해야 할지, 무엇을 만들어야 할지, 그리고 어떤 기술을 사용해야 할지 등 많은 질문으로 인해 혼란스러웠어요.\n- 그때 나만의 문제를 살펴보려고 노력했어요. 항상 두 개의 웹사이트나 앱을 오가며 lofi study beats를 듣고 할 일 목록을 유지하는 데 어려움을 겪었어요. 만약 이 두 가지를 하나로 결합할 수 있다면 어떨까 하는 생각이 들었죠?\n- 그 웹사이트가 놀라울 정도로 위대하거나 세상을 변화시키는 것은 아니지만, 어쨌든 나는 사용할 수 있을 거라고 생각해요.\n- 그래서 생산성과 습관을 결합하는 웹사이트를 만들기로 결심했어요. 예를 들어, lofi study beats와 할 일 목록을 합치는 것이요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 웹 사이트 링크:- http://ashishnagmoti.pythonanywhere.com/\n\n- 튜토리얼 링크: https://youtu.be/NlTR48V-_rs?si=qCaCIaMN0fsdA0YP\n\n-\n\n# 결론\n\n- 마지막으로 이렇게 멋진 경험을 한 것은 제 학습 여정 중 가장 놀라운 일 중 하나였습니다. CS에 진입하고 싶은 사람에게 꼭 추천드립니다.\n\n이것이 제 경험이었습니다. 여러분의 생각/경험을 댓글에 공유해 주세요.","ogImage":{"url":"/assets/img/2024-06-21-MyCS50experience_0.png"},"coverImage":"/assets/img/2024-06-21-MyCS50experience_0.png","tag":["Tech"],"readingTime":2},{"title":"구글 클래스룸으로 교사와 학생을 하나로 Flutter를 사용한 크로스 플랫폼 개발 방법","description":"","date":"2024-06-21 23:54","slug":"2024-06-21-CrossPlatformdevelopmentwithFlutterHowGoogleClassroomgetsteachersandstudentsonthesamepage","content":"\n\nGoogle의 Classroom 앱은 원래 2014년에 시작되어 전 세계의 1억 5천만 교육자와 학생들이 수업 내에서 숙제, 성적 및 커뮤니케이션을 조직화하는 데 사용됩니다. Android 및 iOS에서 사용할 수 있으며, 개발은 처음 시작된 해부터 이어져 왔으며, 이동 플랫폼의 변화 시대를 겪었습니다. 그 다양한 변화를 관리하는 것은 어려운 일이었습니다.\n\n동기화를 위한 노력에도 불구하고, 2021년에는 7년 뒤에도 Classroom 앱의 독특한 Android 및 iOS 코드베이스가 특징, UI 및 구현에서 점진적으로 멀어졌습니다. 동일한 UI에 대해 다른 접근 방식을 취한 화면과 같은 가장 명백한 차이부터 인증 및 앱 시작 로직의 차이와 같이 덜 명백한 차이까지; Classroom은 유지 및 향상하기 어려운 앱으로 변모했고, 두 코드베이스가 소규모 개발자 풀에 부담을 주었습니다.\n\n지속적인 현상 유지, 더 많은 개발자 추가, 크로스 플랫폼 프레임워크를 사용한 두 코드베이스의 완전한 재작성이 포함된 다양한 옵션이 있었습니다. 개선에 헌신하는 팀은 상태 quo 옵션을 제외하고, 이미 존재하는 두 코드베이스를 안정화하는 데 필요한 조치를 평가한 후, 단순히 더 많은 개발자를 추가하는 것으로는 부족하다고 판단했습니다. 결국 팀은 그들의 세 번째 선택인 Flutter를 사용하여 단일 소스, 크로스 플랫폼 솔루션으로 Classroom을 재상상하기로 결정했습니다.\n\n# Flutter가 Classroom 앱을 어떻게 간단하게 만들었는지\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 일관성 없는 UIs \n\nGoogle Classroom의 가장 뚜렷한 문제 중 하나는 UI의 변화로, 선생님들이 안드로이드와 iOS UI를 깊이 알아야 했습니다. 학생들이 한 플랫폼에서 보는 숙제 화면과 지침에 관한 질문을 받았을 때, 다른 플랫폼에서 본 화면과의 비교로 답변이 상당히 혼란스러울 수 있습니다.\n\n![UI variations](/assets/img/2024-06-21-CrossPlatformdevelopmentwithFlutterHowGoogleClassroomgetsteachersandstudentsonthesamepage_0.png)\n\n일반적인 접근 방식은 시간이 지남에 따라 차이가 벌어지는 별도의 팀이 개발한 별도의 클라이언트 앱입니다. 이를 방지하기 위해서는 매우 일관된 작업을 통해 모든 기능을 동기화해야 합니다. 그것과 대조적으로, 플러터의 본질은 기본 설정으로 UI가 동일하며 [1], 사용자의 이점을 위해 적응성을 위한 노력(자주 발생)이 있을 때까지만 다른 방향으로 빗겨나갑니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 혼동된 비즈니스 로직\n\n클래스룸의 안드로이드 및 iOS 클라이언트가 맞지 않았던 유일한 곳은 사용자 인터페이스뿐만이 아니었습니다. 일부 복잡한 비즈니스 로직을 클라이언트로 오프로드하는 서버 측 솔루션에 의해 형성된 과거의 클래스룸 앱은 또한 핵심 구현에서의 차이를 처리했습니다. 가끔씩 플랫폼별 버그가 발생하기도 했으며 (엔지니어가 재현하려는 노력을 좌절시키는 경우도 있었습니다!), 이는 양쪽 구현의 정확성을 평가하려는 사람에게 상당한 정신적 부담을 줬습니다.\n\nFlutter를 사용하여 클래스룸을 다시 작성함으로써, Flutter가 네이티브 플랫폼 상호작용을 처리하는 방식 때문에, 이전에 보고되지 않았던 수많은 버그들이 간단히 해결되었습니다.\n\n원래 코드에서는 수년에 걸친 지속적인 개발로 UI, 비즈니스 및 플랫폼별 로직 간의 경계가 가끔씩 흐려졌습니다. 이는 사용자의 버그 보고가 거의 항상 전체 호출 스택이 잠재적으로 죄가 있는 지 절대적으로 구분해야하는 큰 노력임을 의미했습니다. 요청한 파일이 로드되지 않는 이유가 파일 시스템을 잘못 읽어서, 비즈니스 로직에서 미스통신 때문에, 아니면 UI가 파일을 수신하지만 그 후로 파일을 잃어버린 것일까요? 그것을 알아내는 유일한 방법은 모든 것을 조사하는 것뿐이었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n물론, 플러터 개발자들도 누구나 할 수 있는 것처럼 이 경계를 흐려지게 만들고 로직을 섞을 수 있지만, 수업실 엔지니어링 팀은 프레임워크 모베르 베스트 프랙티스를 따르는 것이 이를 쉽게 드러내게 만드는 것으로 발견했습니다. 플러터의 선언적 UI 시스템은 UI 위젯 내에서 실수로 비지니스 로직을 배치하는 것을 강력히 권고하며, 새로운 MVVM 아키텍처는 실수 없이 정리된 책임 층을 강제할 수 있도록 도와주었습니다. 이는 플러터 위젯 뒤에 있는 방대한 코드베이스 내에서 분명한 레이어를 유지할 수 있도록 해주는 데 도움이 되었습니다.\n\n플러터 앱은 여전히 주기적으로 기본 플랫폼과 통신해야 합니다 — 어쨌든, 숙제를 업로드하고 볼 수 있는 사용자 경로는 파일 시스템을 사용하지 않으면 이뤄질 수 없습니다. 하지만 여기서도 플러터는 플랫폼별 로직을 전용 플러그인으로 격리하는 패턴을 따라 일상적인 디스크 I/O와 같은 것이 소속되지 말아야 하는 곳으로 슬금슬금 스니킹되는 것을 방지했습니다. 아래 예제는 플러터 앱이 전체 호출 스택을 혼란스럽지 않게 하면서 파일 시스템에 액세스하는 현실적인 방법을 보여줍니다.\n\n```dart\nimport \"dart:io\";\nimport \"package:path/path.dart\" as path;\nimport \"package:path_provider/path_provider.dart\" as path_provider;\n\n// 특정 과제에 대한 학생의 저장된 숙제를 불러오는 함수\n// 반환된 값의 exists() 함수는 학생이 숙제를 먹은 경우 False를 반환합니다.\nFuture\u003cFile\u003e getHomework(Assignment assignment) async {\n  // `path_provider` 패키지를 사용하여 플랫폼별 파일 시스템 특성을 추상화합니다\n  final Directory homeworkDirectory = \n    await path_provider.getApplicationSupportDirectory();\n\n  // 학생이 업로드한 숙제를 추출합니다\n  return File(\n    path.join([homeworkDirectory.absolute.path, assignment.name]),\n  );\n}\n```\n\n이 예는 간단합니다. 수업실 엔지니어링 팀은 궁극적으로 플랫폼과 더 복잡한 상호작용을 포함하는 자체 플러그인을 개발했습니다. 흥미로운 점은, 이렇게 함으로써 그들의 네이티브 코드가 원래의 네이티브 앱보다 디버깅하기 쉬워졌습니다. 이게 가능했던 이유는 무엇일까요? Flutter 플러그인에서 반복하지 않기(Don’t Repeat Yourself, DRY) 원칙을 따르면 가능한 한 많은 비지니스 로직을 다트 코드로 올려놓고, 네이티브 상호작용을 위한 가장 간단한 메서드 호출만 남겨두기 때문입니다. 이는 도메인 로직과 플랫폼 로직 사이에 확고한 분리를 강요하여, 수업실의 안드로이드나 iOS 코드의 오류가 단일 책임 함수에 격리되어 쉽게 이해할 수 있는 것이었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 성능 저하\n\n사용자의 여정이 실패할 때, 모두가 동의하는 반드시 해결해야 할 명확한 버그가 제출됩니다. 하지만 앱 시작 시간이 점점 악화되어온 지어 올 해 말로 얼마전 앱이 출시된 후 몇 년 동안 변해온 문제와 같은 더 부드러운 문제에 대해 어떻게 해야 할까요? 여러 클라이언트를 동기화하는 것에 대한 우려를 더하면, 앱의 느린 시작 흐름을 해결하는 작업은 절망적인 일처럼 느껴집니다.\n\n여기서 Flutter이 도움을 주어 문제를 악화시키지 않으면서 충분히 빠른 속도로 도와주었고, 더 중요한 것은 깨끗한 출발의 기회를 제공했습니다. 개발 몇 년을 끌어온 기존 문제를 해결하는 대신 새로운 것을 구축하고 있다는 사실로, Classroom 팀은 중복되는 API 호출을 제거하고 다른 독립적인 API 호출을 병렬화하며, 모든 것이 해결될 때까지 shimmer 효과와 다른 UI 미리보기를 표시함으로써 권한 부여 및 시작 흐름을 명확히 했습니다. 결과는 앱 시작 시간의 놀라운 80% 감소였습니다!\n\n## 주석 기능\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n대부분의 Classroom 기능은 과제와 업로드된 숙제와 같은 내용을 공유하는 사용자들을 모아주는 비교적 일상적인 앱으로 볼 수 있습니다. 그러나 한 가지 기능이 분명히 복잡하게 빛을 발합니다. Classroom의 주요 기능 중 하나는 파일 공유입니다. 여기서 교사와 학생 모두가 파일을 만들고 보고 편집할 수 있으며, 자유형 주석을 추가할 수 있습니다. 마치 펜이나 마커로 직접 종이에 그림을 그리는 것처럼 자유롭게 주석을 추가할 수 있습니다. 이 주석 공유 기능은 이미 Classroom의 내장 Android 및 iOS 클라이언트에 존재했기 때문에 Flutter로 이식하는 것이 어려웠던 문제였습니다. \n\nClassroom 팀은 이 주석 기능을 플랫폼별 구현을 별도의 라이브러리로 위임하는 플러그인으로 재패키지할 수 있었습니다. 파일 주석에 대해, 해당 기능은 이미 Google One, Google Keep 및 이전 Classroom 앱에서 사용되는 기존 네이티브 라이브러리들을 감싼 얇은 래퍼로 되어 있었습니다. 내부적으로 Android와 iOS는 파일 공유 주변에 서로 다른 구현 요구 사항이 있습니다. iOS에서는 Classroom 앱이 네이티브 뷰를 통해 파일에 액세스하지만, Android에서는 Google Keep 앱을 직접 엽니다. 그러나 좋은 플러그인 디자인 원칙을 통해 이러한 구현 세부 사항을 격리시키고 앱의 나머지 부분에서 깨끗하고 일관된 Dart API를 노출할 수 있었습니다. 결과적으로 Classroom의 \"가장 복잡한\" 기능 중 하나가 Flutter로 성공적으로 이식되었습니다.\n\n아래는 Android에서 Classroom 주석 기능의 시각화입니다. 네이티브 및 Flutter UI 구성 요소의 혼합이 나와 있습니다.\n\n![Classroom Annotation Feature on Android](/assets/img/2024-06-21-CrossPlatformdevelopmentwithFlutterHowGoogleClassroomgetsteachersandstudentsonthesamepage_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n보다 넓게 바라보면, 플러터에서의 전형적인 플러그인 디자인은 다음과 같이 구성되어 있습니다. 단일하고 간결한 인터페이스가 플랫폼별 라이브러리를 로드하며, 이 라이브러리들은 다시 FFI 또는 JNI를 사용하여 기본 플랫폼과 통신합니다. 이를 통해 플러터 앱은 빌드 대상의 모든 플랫폼별 네이티브 API와 상호 작용할 수 있으며, 이러한 고려 사항을 Dart 코드로 유출시키지 않습니다.\n\n![이미지](/assets/img/2024-06-21-CrossPlatformdevelopmentwithFlutterHowGoogleClassroomgetsteachersandstudentsonthesamepage_2.png)\n\n# 되돌아보며\n\n## 개발 속도\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n클래스룸 팀은 앱을 다시 작성하는 데 2년이 걸렸습니다. 초기 프로토타입 단계에서 1명의 엔지니어로 시작하여 개발의 절정 단계에서는 10명의 정규 엔지니어로 성장한 팀과 함께 작업했습니다. 이것은 작은 투자가 아니지만, 개발 및 유지 보수가 영원히 빨라진다는 약속을 바탕으로 하였습니다. 클래스룸은 2023년 6월에 iOS에서 플러터 재작업을 시작하고, 2024년 1월에 Android에서 발표하여 프로젝트를 완료했습니다. 그 이후로 새로운 기능에 소요된 평균 엔지니어링 시간이 3분의 2 감소했고, 개발자 속도가 3배 증가했습니다! 2년간 새로운 기능을 기다린 이후 스테이크홀더들은 기다렸던 ✨빠른 기능 개발✨의 도래로 기뻐하고 있습니다.\n\n클래스룸 팀이 다시 작성을 결정한 부분 중 하나는, 프로젝트가 결코 \"끝나지 않을\" 것이라는 것을 인지하였기 때문입니다. 새로운 기능이 미래에도 계속 추가될 것으로 예상되었습니다. 이는 다소 비용이 많이 들더라도 언젠가는 그 대가를 치룰 것이라는 설득력 있는 이유가 되었습니다. 클래스룸 팀이 다시 작성에서 투자 회수 포인트에 도달할 때까지의 공식은 다음과 같습니다:\n\n![수식](/assets/img/2024-06-21-CrossPlatformdevelopmentwithFlutterHowGoogleClassroomgetsteachersandstudentsonthesamepage_3.png)\n\niOS를 출시한 이후 9개월 동안, 클래스룸은 플러터가 제공하는 개발자 속도 3배 증가로 초기 투자의 40%를 이미 회수했다고 추정하고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 개발자 경험\n\n개발 속도가 증가하여 가장 행복해하는 사람들은 이해 관계자보다 개발자들입니다. 교실 팀의 경우, 개발 속도가 3배 증가한 것은 각 기능을 한 번만 작성하거나(또는 무거운 네이티브 구성 요소가 있는 경우에는 최대 1.5배 작성), 종종 몇 달씩 격리되어 있는 두 팀 간의 조정 비용을 제거하고, 물론 핫 리로드가 결합된 결과입니다. 핫 리로드만으로도 약 99%의 재구축 시간 감소를 이뤘으며, 이것은 교실 팀의 사기를 높여 두 네이티브 클라이언트로부터 얻었던 것보다 더욱 크게 향상시켰습니다. 교실 팀은 Flutter로 전환한 후 엔지니어를 쉽게 유치하고 유지할 수 있었습니다.\n\n게다가, 교실 팀은 새로운 기능을 구현하는 데 평균적으로 최소 50% 더 적은 코드 라인이 필요하다는 사실을 발견했습니다. 실제로는, 재작업 중에 구축한 모든 기능이 두 네이티브 클라이언트에서 실제로 구현되어 있지 않았기 때문에 감소율은 상당히 높을 수 있습니다. 다시 말해, 이전 모든 기능뿐만 아니라(예: iOS의 오프라인 지원 포함) 큰 기능 차이를 완벽하게 수행하는데 필요한 코드의 50% 정도만으로 충분합니다.\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n교실 팀은 리라이트를 시작한 지 약 2년 후에 Android 및 iOS로 그들의 앱을 출시했으며 추가적인 기능을 추가하여 초기 투자의 40%를 상환했습니다. 새로운 앱은 이전 것보다 거의 5배 빠르게 실행되어 개발자와 최종 사용자가 시간과 귀찮음을 절약할 수 있었습니다. 미래를 전망해 보면, 새로운 기능은 이전 상태보다 개발 비용이 1/3이며 두 플랫폼에서 동시에 릴리스되고 문제 해결 및 유지보수가 더 쉽습니다. 교실이 플러터로 전환한 후 사용자, 개발자 및 이해당사자들의 사기는 그들의 미래를 투자하는 것으로 바뀐 후에 이전보다 더 높아졌습니다.","ogImage":{"url":"/assets/img/2024-06-21-CrossPlatformdevelopmentwithFlutterHowGoogleClassroomgetsteachersandstudentsonthesamepage_0.png"},"coverImage":"/assets/img/2024-06-21-CrossPlatformdevelopmentwithFlutterHowGoogleClassroomgetsteachersandstudentsonthesamepage_0.png","tag":["Tech"],"readingTime":8},{"title":"CSS 네이티브 중첩 기능 완벽 해부하기","description":"","date":"2024-06-21 23:52","slug":"2024-06-21-UnpackingNativeCSSNesting","content":"\n\n\n![이미지](/assets/img/2024-06-21-UnpackingNativeCSSNesting_0.png)\n\nCSS와 씨름한 시간이 있다면(솔직히 말해서 누가 안 했겠어요?), 그것이 약간 혼란스러워질 수 있다는 것을 알고 계실 겁니다. 선택자가 쌓이고 규칙이 곳곳에 흩어지며, 이 모든 것은 어떤 개발자라도 더 간단한 방법을 열망하게 만듭니다.\n\n좋은 소식이 있습니다! 여러분의 호소가 들려졌습니다. 이제 우리에게는 기본 CSS 중첩이 있습니다. 새끼 새의 아늑한 집처럼 들릴지도 모르지만, 믿어봐요. 실제로 그것보다 더 멋집니다.\n\n## 무슨 큰일인가요?\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n옛날에는 (좋아, 몇 년 전) CSS 규칙을 중첩해서 더 정리된 모습으로 만들고 싶다면 Sass나 Less와 같은 전처리기를 사용해야 했습니다. 이 도구들은 좋았지만, 워크플로에 추가 단계를 넣는 번거로움이 있었습니다. 브라우저가 이해할 수 있도록 코드를 컴파일해야 했습니다.\n\n기본 CSS 중첩을 통해 추가 도구가 필요하지 않은 상태에서 CSS 파일 내에서 규칙을 중첩할 수 있습니다. 마치 항상 원하던 내장형 캐비닛 정리함을 얻은 것 같은 느낌이에요 (모든 것이 자리를 차지하고 있어요), 그리고 필요한 것을 찾기가 훨씬 쉽습니다.\n\n## 코드 보여줘!\n\n그만 얘기하고, 몇 가지 예제로 이 작업이 어떻게 작동하는지 확인해보세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기본 중첩:\n\n```js\n/* 중첩 없이 */\n.card { 배경색: 흰색; 패딩: 20px; }\n.card h2 { 글꼴 크기: 24px; }\n.card p { 줄 높이: 1.6; }\n.card a { 색상: 파란색; }\n\n\n/* 중첩 사용 */\n.card {\n  배경색: 흰색;\n  패딩: 20px;\n\n  h2 { 글꼴 크기: 24px; }\n  p { 줄 높이: 1.6; }\n  a { 색상: 파란색; }\n}\n```\n\n가상 클래스와 함께 중첩:\n\n```js\n/* 중첩 없이 */\n.btn { /* ...버튼 스타일... */ }\n.btn:hover { 배경색: #0056b3; 색상: 흰색; }\n.btn:active { 박스 그림자: inset 0 3px 5px rgba(0, 0, 0, 0.125); }\n\n\n/* 중첩 사용 */\n.btn {\n  /* ...버튼 스타일... */\n\n  \u0026:hover {\n    배경색: #0056b3;\n    색상: 흰색;\n  }\n\n  \u0026:active {\n    박스 그림자: inset 0 3px 5px rgba(0, 0, 0, 0.125);\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n미디어 쿼리와 중첩 사용하기:\n\n```js\n/* 중첩 없이 */\n.container { width: 960px; margin: 0 auto; }\n@media (max-width: 768px) {\n  .container { width: 100%; padding: 0 15px; }\n}\n\n\n/* 중첩 사용 */\n.container {\n  width: 960px;\n  margin: 0 auto;\n\n  @media (max-width: 768px) {\n    width: 100%;\n    padding: 0 15px;\n  }\n}\n```\n\n## 중첩을 채택해야 하는 이유\n\n- 가독성: 관련된 스타일을 함께 유지하여 코드를 읽고 이해하기 쉽게 만듭니다 (누가 깔끔한 코드를 싫어하겠어요?).\n- 유지보수성: 무언가를 변경해야 할 때 관련 규칙을 찾기가 훨씬 간단합니다.\n- 반복 최소화: 동일한 부모 선택기를 반복해서 입력할 필요가 없습니다. (솔직히 말해서, 할 일이 아직 많은데 말이죠.)\n- 효율성: 네이티브 CSS 중첩을 사용하면 반복되는 선택기를 제거하여 파일 크기를 조금 줄일 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 주의 사항 몇 가지\n\n- 브라우저 지원: 중첩은 상대적으로 새로운 개념이므로 전면적으로 도입하기 전에 각 브라우저가 지원하는지 확인해보세요. (호환성을 확인하려면 caniuse.com과 같은 도구를 사용할 수 있습니다.)\n- 과도한 중첩: 중첩을 지나치게 사용하지 마세요. 너무 많은 수준은 코드를 이해하기 어렵게 만들 수 있습니다. (프로젝트에 \"적절한\" 중첩 수준을 찾아보세요.)\n\n## 중첩해 보세요!\n\n기본 CSS 중첩은 스타일시트의 구조와 가독성을 개선하는 간단하면서도 강력한 방법입니다. 그러니 더 이상 기다릴 이유가 있나요? 중첩을 시작해서 업무 흐름에서 만드는 차이를 보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n네이티브 CSS 중첩에 대해 더 알아보기 위해 문서를 확인해보세요:\n\n- [MDN Native CSS Nesting](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_nesting)\n- [Chrome DevTools CSS Nesting](https://developer.chrome.com/docs/css-ui/css-nesting)\n\n그리고, 도움이 되었다면 팔로우하기를 잊지마세요! 소프트웨어 엔지니어링 및 특히 웹 개발의 흥미로운 세계에 대한 팁, 통찰력 및 업데이트를 공유하는 걸 좋아합니다. 즐겨 사용하세요!","ogImage":{"url":"/assets/img/2024-06-21-UnpackingNativeCSSNesting_0.png"},"coverImage":"/assets/img/2024-06-21-UnpackingNativeCSSNesting_0.png","tag":["Tech"],"readingTime":3},{"title":"Flutter에서 리프레시 토큰 사용하는 방법 모바일","description":"","date":"2024-06-21 23:50","slug":"2024-06-21-FlutterRefreshtokenmobileside","content":"\n\n플러터에서 Dio를 사용하여 토큰을 새로 고치는 방법\n\n![image](/assets/img/2024-06-21-FlutterRefreshtokenmobileside_0.png)\n\n현대 모바일 애플리케이션에서는 사용자 인증 세션을 원활하게 유지하는 것이 사용자 경험에 매우 중요합니다. 인증을 관리하는 효과적인 방법 중 하나는 리프레시 토큰을 사용하는 것입니다. 이 기사에서는 Dio를 사용하여 플러터 애플리케이션에서 리프레시 토큰을 처리하는 방법에 대해 살펴보겠습니다.\n\n토큰이란 무엇인가요?\n토큰은 토큰 기반 인증에서 애플리케이션이 API에 액세스할 수 있도록 허용하는 데 사용됩니다. 사용자가 성공적으로 인증하고 액세스 권한을 부여한 후 애플리케이션은 액세스 토큰을 받아들이고 대상 API를 호출할 때 자격 증명으로서 액세스 토큰을 전달합니다. 전달된 토큰은 API에게 전달된 토큰의 소유자가 API에 액세스할 권한이 있으며 승인 중에 부여된 범위에 따라 특정 조치를 수행할 수 있음을 알립니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리프레시 토큰이 무엇인가요?\n리프레시 토큰은 사용자가 다시 인증을 받지 않고 새로운 엑세스 토큰을 얻는 메커니즘입니다. 일반적으로 엑세스 토큰은 보안상의 이유로 수명이 짧지만, 리프레시 토큰은 더 오래 지속됩니다. 엑세스 토큰이 만료되면 리프레시 토큰을 사용하여 새로운 엑세스 토큰을 얻을 수 있어 사용자의 세션을 중단시키지 않고 유지할 수 있습니다.\n\n단계별로 리프레시 토큰 구현하기\n\nDio의 인스턴스를 구성하고 초기화하는 'DioFactory' 클래스를 만드세요.\n\n```js\nclass DioFactory {\n\n  Future\u003cDio\u003e getDio() async {\n    Dio dio = Dio();\n\n    Map\u003cString, String\u003e headers = {\n      contentType: applicationJson,\n      accept: applicationJson,\n    };\n\n    dio.options = BaseOptions(\n      baseUrl: ConstantsApi.baseUrl,\n      headers: headers,\n      receiveTimeout: const Duration(milliseconds: Constants.apiTimeOut),\n      sendTimeout: const Duration(milliseconds: Constants.apiTimeOut),\n      connectTimeout: const Duration(milliseconds: Constants.apiTimeOut),\n    );\n\n    if (!kReleaseMode) {\n      dio.interceptors.add(\n        PrettyDioLogger(\n          requestHeader: true,\n          requestBody: true,\n          responseHeader: true,\n          error: true,\n        ),\n      );\n    }\n\n    return dio;\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nApiService 클래스는 Dio를 사용하여 API 요청을 처리하고 인증 토큰을 관리하기 위해 설계된 포괄적인 서비스 레이어입니다. 이 클래스와 기능에 대한 자세한 설명을 제공합니다.\n\n01- 클래스 선언 및 필드\n“_dio1”과 “_dio2”는 \"Dio\"의 인스턴스입니다. “_dio1”은 일반 API 요청에 사용되고, “_dio2”는 토큰 갱신 요청에 사용됩니다.\n\n```js\nclass ApiService {\n  final Dio _dio1;\n  final Dio _dio2;\n  final AppPreferences _appPref;\n\n  ApiService(\n    this._dio1,\n    this._dio2,\n    this._appPref,\n  ) {\n    _dio1.interceptors.add(\n      InterceptorsWrapper(\n        onRequest: _onRequest,\n        onError: _onError,\n      ),\n    );\n  }\n}\n```\n\n02- 인터셉터\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n생성자는 요청 및 오류 처리를 처리하기 위해 \"dio\"에 인터셉터를 추가합니다.\n\n오류 인터셉터:\n이 메서드는 오류를 처리합니다. 특히, 오류가 401 Unauthorized인 경우 토큰을 새로 고치려고 시도합니다.\n\n```js\n_onError(DioException e, ErrorInterceptorHandler handler) async {\n  if(e.response?.statusCode == 401) {\n    _refreshToken(e, handler);\n  } else {\n    handler.next(e);\n  }\n}\n```\n\n03- 토큰 새로고침 로직\n\" _refreshToken \"메서드는 새 액세스 토큰을 받아오기 위해 리프레시 토큰을 사용하려고 시도합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 성공하면 저장된 토큰을 업데이트하고 원래 요청을 다시 시도합니다.\n- 새로 고침이 실패하는 경우 (특히 새로 고침 토큰도 잘못된 경우), 사용자를 로그아웃 처리하고 오류를 거절합니다.\n\n```js\n  Future\u003cvoid\u003e _refreshToken(DioException e, ErrorInterceptorHandler handler) async {\n    try {\n      final refreshToken = _appPref.getRefreshToken();\n      final response = await _dio2.post(\n        ConstantsApi.refreshTokenUrl,\n        data: {'refreshToken': refreshToken},\n      );\n      _appPref.setToken(response.data['accessToken']);\n      _appPref.setRefreshToken(response.data['refreshToken']);\n      handler.resolve(await _dio1.fetch(e.requestOptions));\n    } catch (error) {\n      if (error is DioException) {\n        if (error.response?.statusCode == 401) {\n          _logout();\n          handler.reject(e);\n        } else {\n          handler.next(error);\n        }\n      } else {\n        handler.next(e);\n      }\n    }\n  }\n```\n\n위 단계를 따라 하면 Dio를 사용하여 Flutter 애플리케이션에서 새로 고침 토큰을 처리할 수 있어서 사용자가 원할한 경험을 얻을 수 있습니다. 이 방법은 Dio 인스턴스의 구성을 중앙 집중화하고 토큰을 효율적으로 관리하는 데 도움이 됩니다.","ogImage":{"url":"/assets/img/2024-06-21-FlutterRefreshtokenmobileside_0.png"},"coverImage":"/assets/img/2024-06-21-FlutterRefreshtokenmobileside_0.png","tag":["Tech"],"readingTime":4},{"title":"데이터베이스에서 UUID 사용을 중단해야 하는 이유","description":"","date":"2024-06-21 23:49","slug":"2024-06-21-StopUsingUUIDsinYourDatabase","content":"\n\n\u003cimg src=\"/assets/img/2024-06-21-StopUsingUUIDsinYourDatabase_0.png\" /\u003e\n\n데이터베이스에서 행을 고유하게 식별하는 가장 일반적인 방법 중 하나는 UUID 필드를 사용하는 것입니다.\n\n그러나 이 접근 방식은 성능 경고사항이 있으니 유의하셔야 합니다.","ogImage":{"url":"/assets/img/2024-06-21-StopUsingUUIDsinYourDatabase_0.png"},"coverImage":"/assets/img/2024-06-21-StopUsingUUIDsinYourDatabase_0.png","tag":["Tech"],"readingTime":1},{"title":"선명한 이미지가 흐릿한 단어 천 개보다 나은 이유","description":"","date":"2024-06-21 23:48","slug":"2024-06-21-Asharpimageisworthathousandblurrywords","content":"\n\n우리는 본능적으로 시각적인 생물입니다. MIT 연구에 따르면 인간 두뇌는 이미지를 13~33밀리초 안에 처리하는데, 이는 텍스트 보다 60,000배 빠르다고 합니다. 따라서 사용자 경험을 만드는 데 이미지를 광범위하게 사용하는 것이 중요합니다. 웹 사용자 경험을 위해 선명하고 선명한 이미지를 전달하는 뒤에 숨겨진 비밀을 발견하기 위해 이 기사를 살펴보겠습니다.\n\n## 픽셀: 물리적 vs 논리적\n\n어떤 화면이 이미지를 형성하려면 작은 정사각형으로 나뉘어집니다. 이 정사각형 중 하나를 물리적 픽셀이라고 합니다.\n\nCSS를 사용하여 웹페이지에 스타일을 프로그래밍적으로 추가할 때, 엔지니어들은 페이지의 요소 크기와 위치를 정의하는 데 측정 단위로 픽셀을 사용합니다. 이것을 논리적 픽셀이라고 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n**논리적 픽셀**은 추상적인 개념이며 물리적 픽셀과 1대1 매핑될 수도 있고 그렇지 않을 수도 있습니다.\n\n## 장치 픽셀 비율 (DPR)\n\n동일한 화면 영역 안에서 더 높은 해상도의 화면은 낮은 해상도의 화면보다 더 많은 물리적 픽셀을 갖게 됩니다. 화면 영역을 하나의 논리적 픽셀로 간주했을 때, 장치 픽셀 비율은 동일한 영역에 존재하는 물리적 픽셀의 수와 동일합니다. 화면의 해상도는 장치 픽셀 비율과 직접적으로 비례합니다.\n\n![이미지](/assets/img/2024-06-21-Asharpimageisworthathousandblurrywords_0.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 논리적 픽셀과 물리적 픽셀 매핑\n\nHTML 문서의 뷰포트 메타 태그는 화면의 디바이스 픽셀 비율을 고려하여 논리적 픽셀을 물리적 픽셀로 매핑하도록 브라우저에 지시합니다.\n\n```js\n\u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n```\n\n예를 들어, 화면의 DPR이 2인 경우, 논리적 픽셀 하나에 물리적 픽셀이 두 개 들어갈 수 있음을 의미합니다. 따라서 웹사이트 콘텐츠가 논리적으로 200 x 200 픽셀을 차지한다면 해당 화면에서는 물리적으로 400 x 400 픽셀을 차지할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 이미지 선택의 기술\n\n동일한 차량의 두 개의 이미지가 있다고 가정해봅시다. Image_one은 Image_two보다 높은 해상도를 가지고 있습니다. 이는 Image_one에는 Image_two보다 더 많은 세부 사항이 표시됨을 의미합니다. 만약 차량의 이미지를 웹사이트에 논리적으로 600 x 400 픽셀로 원한다면, 높은 DPR 화면에는 높은 해상도 이미지를 사용하고 낮은 DPR 화면에는 낮은 해상도 이미지를 사용해야 합니다.\n\n높은 DPR 화면에서는 논리적인 600 x 400 픽셀이 더 많은 물리적 픽셀 위에 펼쳐질 것이기 때문에 높은 해상도 이미지를 사용하면 더 많은 세부 사항이 표시되어 유용할 것입니다. 그러나 낮은 해상도 이미지를 사용하면 더 많은 세부 사항이 없기 때문에 흐릿해 보일 수 있으며, 느기적으로 펼치게 됩니다.\n\n\n\u003cimg src=\"/assets/img/2024-06-21-Asharpimageisworthathousandblurrywords_1.png\" /\u003e\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저해상도 화면에서는 논리적인 600 x 400 픽셀 이미지가 고해상도 화면보다 더 낮은 물리적 픽셀 수를 가질 것입니다. 따라서 더 높은 해상도의 이미지를 사용하면 작동할 것이지만 다운로드할 때 더 많은 네트워크 대역폭을 소비할 것입니다. 대신 더 낮은 해상도의 이미지를 사용하면 작동하며 다운로드할 때 더 적은 네트워크 대역폭을 소비합니다.\n\n## 말보다 행동이 중요해요, 코드를 보여줘\n\nHTML 문서에서는 아래와 같이 img 태그와 srcset 속성을 사용하여 위에서 논의한 것을 구현할 수 있습니다.\n\n```js\n\u003cimg src=\"image.jpg\" srcset=\"image-2x.jpg 2x, image-4x.jpg 4x\"\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이미지의 해상도는 다음과 같습니다:\nimage-4x.jpg ` image-2x.jpg ` image.jpg\n\nDPR이 4인 화면에는 image-4x.jpg를, DPR이 2인 화면에는 image-2x.jpg를 보여주며, 그 외의 화면에는 기본적으로 image.jpg를 사용합니다.\n\n## 결론\n\n물리적 픽셀, 논리적 픽셀, DPR 및 viewport 메타 태그에 대한 충분한 이해는 srcset 속성의 힘을 이용하여 오늘날 사용자가 웹사이트를 보는데 사용하는 다양한 기기에서 우수한 이미지 품질을 제공하는 데 도움이 됩니다. 그래서 다음 번에 핸드폰, 태블릿 또는 컴퓨터에서 화려한 시각적 효과를 볼 때, 최적화된 이미지 전달의 마법을 기억해주세요!","ogImage":{"url":"/assets/img/2024-06-21-Asharpimageisworthathousandblurrywords_0.png"},"coverImage":"/assets/img/2024-06-21-Asharpimageisworthathousandblurrywords_0.png","tag":["Tech"],"readingTime":3},{"title":"코드 플로우 - 60초 랩으로 배우는 Flutter 패키지 ","description":"","date":"2024-06-21 23:46","slug":"2024-06-21-CodeFlow1My60SecondRapAboutFlutterPackages","content":"\n\n## \"만약 내가 모든 것을 했다고 말했다면, 난 허풍을 떨었던 거야. 왜냐하면 난 바퀴를 다시 발명하지 않고 그냥 패키지를 가져오는 거야.\"\n\n![image](/assets/img/2024-06-21-CodeFlow1My60SecondRapAboutFlutterPackages_0.png)\n\n안녕하세요 여러분, 다시 한 번 코드 플로우로 들어주셔서 감사합니다. 오늘은 플러터 패키지에 대해 이야기하려고 해요.\n\n플러터 패키지는 플러터 애플리케이션에 특정 기능을 제공하는 재사용 가능한 코드 조각들이에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이러한 패키지는 UI 구성 요소, 네트워크 요청 처리를위한 라이브러리, 상태 관리 솔루션 및 데이터베이스 통합 도구 등을 포괄할 수 있습니다.\n\n이들은 플러터 생태계의 중요한 부분으로, 개발자가 앱에 기능을 쉽게 통합할 수 있도록 합니다.\n\npub.dev에서 직접 다운로드하거나 다른 사람들에게 유용할 수 있는 아이디어가 있으면 직접 만들어도 됩니다.\n\n![image](https://miro.medium.com/v2/resize:fit:1200/1*kU3a8x7UWXy3ahGYmoMT4g.gif)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 더 알아보고 싶으신가요? 이 코드 플로우의 일부분을 듣고...\n\n## ...또는 YouTube에서 전체 비디오를 시청해보세요.\n\n## 만약 도움이 되었다면 박수를 쳐 주시고 댓글을 남겨주시면 감사하겠습니다!","ogImage":{"url":"/assets/img/2024-06-21-CodeFlow1My60SecondRapAboutFlutterPackages_0.png"},"coverImage":"/assets/img/2024-06-21-CodeFlow1My60SecondRapAboutFlutterPackages_0.png","tag":["Tech"],"readingTime":1},{"title":"Airclap  모든 기기에 파일 전송하기","description":"","date":"2024-06-21 23:44","slug":"2024-06-21-AirclapSendanyfiletoanydevice","content":"\n\n\n![Airclap](/assets/img/2024-06-21-AirclapSendanyfiletoanydevice_0.png)\n\n소프트웨어 개발자로서 여러 기기 간에 파일과 텍스트를 자주 전송해야 합니다. Airdrop이 이 문제를 우아하게 해결해 주었지만, Apple 기기에만 제한되어 있고 대용량 파일 전송에 어려움을 겪기도 합니다. 더욱이, Windows, Android, Linux 등 Apple 이외의 기기로의 파일 전송을 지원하지 않습니다.\n\n유사한 소프트웨어 솔루션들을 여러 가지 시도해 보았지만, 많은 것들이 파일을 제대로 전송하지 못하거나 지나치게 복잡하거나 불필요한 기능이 많거나 구식한 디자인을 가지고 있습니다. 이러한 옵션들이 모두 만족스럽지 못해서, 나는 나만의 솔루션을 개발하기로 결심했습니다: 아름답게 디자인된, 사용하기 쉬운 응용 프로그램, 크로스 플랫폼 지원.\n\n몇 달간의 열심히 일한 끝에, 드디어 여기 Airclap이 나왔습니다!\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n특징\n\n- 세련된 미니멀한 디자인으로 매우 간단한 상호작용\n- 다운로드 및 사용이 영구적으로 무료\n- 한 단계로 파일 전송 완료\n- iOS, macOS, Android, Windows, 자동차 시스템(Android), Linux(개발 중), TV(계획 중)을 지원\n- 일반 파일 형식 식별을 통해 모든 파일 유형 전송\n- 온라인/오프라인 실시간 장치 상태 업데이트, 오프라인 전송 및 온라인 수신\n- 지속적으로 추가되는 20개 이상 언어 지원\n- 안전한 데이터 전송을 위해 AES 암호화 사용\n- 커스터마이징된 SSDP 발견 프로토콜 및 P2P 안전 전송 프로토콜을 활용하여 다중 링크 전송 기술을 통해 안전하고 안정적인 고속 전송 보장\n- 인터넷 연결이 필요 없으며 로컬 네트워크만 사용하며 귀하의 정보를 수집하지 않음\n- 파일 무결성 보장 및 파일 압축 없음\n\n사용 방법\n\n파일 공유 — 즉시 한 단계 전송\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\niOS 및 Android에서는 다른 기기로 텍스트/파일을 한 단계로 전송하려면 시스템의 \"공유\" 기능을 사용하면 됩니다. (이 기능에 대한 데스크탑 지원은 곧 제공될 예정입니다)\n\nCommand/Control + C/V 단축키\n\n드래그하여 보내기\n\nAirclap 내에서 선택하여 보내기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n개인 핫스팟 전송\n\n휴대폰이나 다른 장치에서 개인 핫스팟을 활성화하고 다른 장치를 핫스팟에 연결하여 비디오 파일을 쉽게 전송할 수 있습니다. 이를 통해 자동차 시스템에서 비디오를 내보내는 등 파일을 손쉽게 전송할 수 있습니다.\n\n![AirclapSendanyfiletoanydevice_1](/assets/img/2024-06-21-AirclapSendanyfiletoanydevice_1.png)\n\n사용 사례\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 개발자를 위한 기능: 테스트 장치 또는 개발용 기계 간에 파일과 텍스트를 손쉽게 전송하세요.\n- 콘텐츠 제작자를 위한 기능: 미디어 파일을 빠르게 컴퓨터로 전송하여 편집한 후 핸드폰으로 미리보기하세요.\n- 교육자를 위한 기능: 학생들과 동료들에게 교육 자료를 안전하고 효율적으로 공유하세요.\n- 오피스 직원을 위한 기능: 문서와 발표 자료를 동료들과 편리하게 공유하세요.\n- 비디오 편집자를 위한 기능: 여러 기기를 통해 비디오를 시행착오 없이 편집하고 미리보기하세요.\n- 자동차 시스템을 위한 기능: 안드로이드 기반 자동차 시스템에서 운전 영상 파일을 빠르게 내보내세요.\n- 그 외 더 많은 상황들…\n\n간단히 말하면, 두 대 이상의 핸드폰 또는 컴퓨터를 소유하고 있다면 Airclap이 필수입니다. 케이블에서 해방되어 다른 기기 간 파일을 쉽게 전송하고 수신할 수 있습니다. 한 번 사용하시면 Airclap의 편리함과 강력함을 경험하게 될 것이라고 믿습니다.\n\n다운로드 방법\n\n- 지원하는 기기: Android, iOS, macOS, Windows (Windows 10 이상), Linux (개발 중…)\n- Airclap 다운로드\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n결론\n\n- 이 소프트웨어는 제 모든 요구 사항을 충족합니다: 안전하고 안정적이며 시각적으로 매력적이며 간단하고 빠르며 멀티 플랫폼을 지원합니다. 단순함을 유지하면서 최적화하고 개선할 것입니다.\n- 현재 85개국의 사용자들이 Airclap을 사용하고 있어서 놀라고 설레입니다.\n- 문제가 발생하거나 아이디어가 있으면 Discord에 가입하여 함께 논의하거나 X(트위터)에 메시지를 남기실 수 있습니다.\n\nAirclap을 자유롭게 사용해 보시고 모든 기기 간의 파일 전송의 편리함을 즐기세요.","ogImage":{"url":"/assets/img/2024-06-21-AirclapSendanyfiletoanydevice_0.png"},"coverImage":"/assets/img/2024-06-21-AirclapSendanyfiletoanydevice_0.png","tag":["Tech"],"readingTime":3},{"title":"Flutter에서 Provider로 상태 관리 이해하기","description":"","date":"2024-06-21 23:43","slug":"2024-06-21-UnderstandingstatemanagementwithProviderinFlutter","content":"\n\n\u003cimg src=\"/assets/img/2024-06-21-UnderstandingstatemanagementwithProviderinFlutter_0.png\" /\u003e\n\n플러터에서 \"provider\"는 애플리케이션 내에서 상태 관리와 데이터 공유에 사용되는 인기 있는 패키지입니다. Provider를 사용하면 애플리케이션의 다양한 구성 요소(위젯) 간에 데이터를 공유하고 업데이트할 수 있습니다. 이를 통해 상태 관리를 간단히 처리하고 전통적인 상태 관리 기술을 사용하지 않고 위젯 트리에서 데이터 변경을 추적하고 업데이트할 수 있습니다.\n\nProvider 개념을 이해하기 위해 몇 가지 주요 개념을 살펴보겠습니다:\n\n- Provider: Provider는 데이터 소스를 제공하고 애플리케이션 내에서 데이터에 액세스할 수 있도록 지원하는 패키지입니다. 데이터 프로바이더를 생성할 때 일반적으로 ChangeNotifier 클래스를 사용합니다. 이 클래스는 가변 상태를 나타내며 그 내부 데이터가 변경될 때 청취자들에게 알립니다.\n- Consumer: Consumer 위젯은 데이터 프로바이더의 값을 액세스하고 해당 변경 사항을 추적하는 데 사용됩니다. 데이터 프로바이더의 위젯 트리 내에 있으며 관련 데이터에 기초하여 스스로 다시 구축됩니다. 다시 말하면 데이터가 변경될 때 자동으로 업데이트됩니다.\n- Provider.of(): 이 메소드를 사용하면 위젯 트리 내에서 가장 가까운 데이터 프로바이더에 액세스할 수 있습니다. 이를 통해 관련 데이터를 검색하고 업데이트를 추적할 수 있습니다.\n- ChangeNotifier: 이 클래스는 데이터 프로바이더의 기반이 됩니다. ChangeNotifier 클래스를 확장한 클래스를 생성함으로써 가변 상태를 나타낼 수 있습니다. 데이터가 변경될 때 notifyListeners() 메소드를 호출하여 청취자에게 알릴 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 제공자 개념을 사용하여 데이터 공유를 구현하는 방법을 살펴보겠습니다:\n\n- 먼저 데이터 제공자 클래스를 만들고 ChangeNotifier 클래스에서 확장합니다.\n\n```dart\nimport 'package:flutter/foundation.dart';\n\nclass CounterProvider with ChangeNotifier {\n  int _count = 0;\n\n  int get count =\u003e _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n```\n\n다음으로, 응용 프로그램 위젯 트리의 최상위에 MultiProvider를 생성하고 생성한 데이터 제공자를 추가합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nvoid main() {\n  runApp(\n    MultiProvider(\n      providers: [\n        ChangeNotifierProvider(create: (_) =\u003e CounterProvider()),\n      ],\n      child: MyApp(),\n    ),\n  );\n}\n```\n\n이제 Consumer 위젯을 사용하여 모든 위젯에서 데이터에 액세스할 수 있습니다.\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass MyWidget extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Consumer\u003cCounterProvider\u003e(\n      builder: (context, counterProvider, child) {\n        return Text(\n          'Count: ${counterProvider.count}',\n          style: TextStyle(fontSize: 24),\n        );\n      },\n    );\n  }\n}\n```\n\n위의 예에서는 CounterProvider 클래스 내의 count 변수에 액세스하여 업데이트가 발생할 때마다 위젯을 자동으로 다시 빌드합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nProvider 패키지를 사용하면 Flutter 애플리케이션에서 데이터 공유를 쉽게 구현할 수 있어요. 위젯 간 데이터 통신과 업데이트가 간단해지며, 애플리케이션 전체 성능이 향상될 거예요.\n\n우선, pubspec.yaml 파일에 provider 패키지를 추가했는지 확인해주세요.\n\n그런 다음, 다음 코드를 main.dart 파일로 사용할 수 있어요:\n\n```js\nimport 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\n// 단계 1: 데이터 제공자 클래스 생성\nclass CounterProvider with ChangeNotifier {\n  int _count = 0;\n\n  int get count =\u003e _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    // 단계 2: 앱을 MultiProvider로 래핑\n    MultiProvider(\n      providers: [\n        ChangeNotifierProvider(create: (_) =\u003e CounterProvider()),\n      ],\n      child: MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Provider Example',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: HomePage(),\n    );\n  }\n}\n\nclass HomePage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    // 단계 3: Consumer 위젯을 사용하여 데이터에 액세스\n    return Consumer\u003cCounterProvider\u003e(\n      builder: (context, counterProvider, child) {\n        return Scaffold(\n          appBar: AppBar(\n            title: Text('Counter App'),\n          ),\n          body: Center(\n            child: Column(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: [\n                Text(\n                  'Count:',\n                  style: TextStyle(fontSize: 24),\n                ),\n                Text(\n                  '${counterProvider.count}',\n                  style: TextStyle(fontSize: 48, fontWeight: FontWeight.bold),\n                ),\n              ],\n            ),\n          ),\n          floatingActionButton: FloatingActionButton(\n            onPressed: () {\n              // 단계 4: 상태 업데이트 트리거\n              counterProvider.increment();\n            },\n            child: Icon(Icons.add),\n          ),\n        );\n      },\n    );\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예시에서는 ChangeNotifier를 확장하는 CounterProvider 클래스를 생성합니다. 이 클래스는 카운트 변수를 관리하고 증가시키는 메서드를 제공합니다. HomePage 위젯은 Consumer 위젯을 사용하여 카운트 값을 액세스하고 화면에 표시합니다. FloatingActionButton을 누르면 프로바이더의 increment 메서드가 트리거되어 카운트를 업데이트하고 UI를 다시 빌드하도록 알립니다.\n\n이 앱을 실행하면 카운트가 표시된 화면이 표시되며 FloatingActionButton을 탭할 때마다 카운트가 증가하고 화면에 변경 내용이 반영됩니다.\n\n이것은 플러터 앱에서 상태 관리를 위해 provider 패키지를 사용하는 방법의 기본 예시입니다. 이 개념을 확장하여 더 복잡한 데이터를 관리하고 응용 프로그램 전체에서 상태 변경을 처리할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-21-UnderstandingstatemanagementwithProviderinFlutter_0.png"},"coverImage":"/assets/img/2024-06-21-UnderstandingstatemanagementwithProviderinFlutter_0.png","tag":["Tech"],"readingTime":5},{"title":"Flutter 검색바 궁극의 가이드","description":"","date":"2024-06-21 23:41","slug":"2024-06-21-FlutterSearchBarAnUltimateGuide","content":"\n\n# 소개\n\n모바일 앱 개발 분야에서 잘 설계된 검색 기능은 편의성뿐만 아니라 사용자 참여 및 접근성을 크게 향상시키는 중요한 구성 요소입니다. 특히 방대한 데이터를 다루는 애플리케이션의 경우에는 이러한 요소가 더욱 중요합니다. 모바일 개발자들 사이에서 인기를 끌고 있는 Flutter는 네이티브 컴파일된 애플리케이션을 구축하기 위한 훌륭한 프레임워크로 두드러집니다. 이 글에서는 Flutter에서 다양한 검색 위젯을 디자인하는 여정을 시작해 CustomSearchDelegate와 같은 범용 위젯을 생성하는 방법을 살펴보겠습니다. 우리는 검색을 구현하기 위해 showSearch 메서드를 활용할 것입니다. 먼저 기본 검색 바를 만들고, 이후에는 임의의 프로젝트에서 사용할 수 있는 방식으로 커스터마이징할 것입니다.\n\n결과물은 이렇게 보일 것입니다.\n\n# showSearch:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nShowSearch은 플러터의 머티리얼 라이브러리에 있는 메소드입니다. 따라서 위젯 트리 어디에서나 접근할 수 있습니다.\n\n```js\nFuture\u003cT?\u003e showSearch\u003cT\u003e({\n  required BuildContext context,\n  required SearchDelegate\u003cT\u003e delegate,\n  String? query = '',\n  bool useRootNavigator = false,\n})\n```\n\n이 메소드는 BuildContext와 SearchDelegate를 필요로 합니다. SearchDelegate는 T 타입의 파라미터를 받는 추상 클래스입니다.\n\n예시:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n showSearch(context: context, delegate: CustomSearchDelegate());\n```\n\n따라서 검색 기능을 구현하려면 SearchDelegate를 확장하는 클래스를 만들면 됩니다. 그것이 어떻게 이루어지는지 살펴봅시다.\n\n```js\nclass CustomSearchDelegate extends SearchDelegate {\n  @override\n  List\u003cWidget\u003e? buildActions(BuildContext context) {\n    // 할 일: buildActions 구현\n    throw UnimplementedError();\n  }\n\n  @override\n  Widget? buildLeading(BuildContext context) {\n    // 할 일: buildLeading 구현\n    throw UnimplementedError();\n  }\n\n  @override\n  Widget buildResults(BuildContext context) {\n    // 할 일: buildResults 구현\n    throw UnimplementedError();\n  }\n\n  @override\n  Widget buildSuggestions(BuildContext context) {\n    // 할 일: buildSuggestions 구현\n    throw UnimplementedError();\n  }\n\n}\n```\n\nSearchDelegate는 4개의 메소드를 구현하도록 요구합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- buildActions: 검색 쿼리를 지우는 작업과 같은 액션을 관리합니다. AppBar의 action 매개변수와 유사합니다.\n- buildLeading: 일반적으로 네비게이션을 위한 뒤로가기 버튼이 포함됩니다.\n- buildResults: 검색 결과를 표시합니다.\n- buildSuggestions: 사용자가 쿼리를 입력하는 동안 제안을 제공합니다.\n\n이 델리게이트를 사용하여 기본 검색을 구현해봅시다.\n\n```js\nclass CustomSearchDelegate extends SearchDelegate {\n  List\u003cString\u003e searchables = List.generate(100, (index) =\u003e '아이템 ${index + 1}');\n\n  @override\n  List\u003cWidget\u003e? buildActions(BuildContext context) {\n    return [\n      IconButton(\n        onPressed: () {\n          query = '';\n        },\n        icon: const Icon(Icons.clear),\n      ),\n    ];\n  }\n\n  @override\n  Widget? buildLeading(BuildContext context) {\n    return IconButton(\n      onPressed: () {\n        close(context, []);\n      },\n      icon: Icon(\n        Platform.isAndroid ? Icons.arrow_back : Icons.arrow_back_ios,\n        size: 22,\n      ),\n    );\n  }\n\n  @override\n  Widget buildResults(BuildContext context) {\n    return SuggestionOrResultWidget(searchables: searchables, query: query);\n  }\n\n  @override\n  Widget buildSuggestions(BuildContext context) {\n    return SuggestionOrResultWidget(searchables: searchables, query: query);\n  }\n}\n```\n\n```js\nclass SuggestionOrResultWidget extends StatelessWidget {\n  const SuggestionOrResultWidget({\n    key,\n    required this.searchables,\n    required this.query,\n  });\n\n  final List\u003cString\u003e searchables;\n  final String query;\n\n  @override\n  Widget build(BuildContext context) {\n    final List\u003cString\u003e suggestions = query.isEmpty\n        ? searchables\n        : searchables.where((element) =\u003e element.toLowerCase().contains(query.toLowerCase())).toList();\n\n    if (suggestions.isEmpty) return const NoResultWidget();\n\n    return ListView.separated(\n      itemBuilder: (context, index) =\u003e ListTile(\n        title: Text(suggestions[index]),\n      ),\n      separatorBuilder: (context, index) =\u003e const Divider(),\n      itemCount: suggestions.length,\n    );\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nclass NoResultWidget extends StatelessWidget {\n  const NoResultWidget({Key key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const Center(\n      child: Text('No Result Found'),\n    );\n  }\n}\n```\n\n결과는 다음과 같이 나타납니다\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:752/1*06CrNqmR7P5yqvzpGdtdXw.gif\" /\u003e\n\n# 검색 페이지 앱바의 ThemeData 사용자 정의하기\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하나 주목할 점은 검색 페이지를 표시할 때 앱의 테마와 동일하지 않다는 것입니다. 이는 특히 AppBar의 색상에서 확인할 수 있습니다. 아래 코드는 검색 페이지의 AppBar에 앱의 ThemeData를 직접 전달합니다.\n\n```js\nclass CustomSearchDelegate extends SearchDelegate {\n  List\u003cString\u003e searchables = List.generate(100, (index) =\u003e 'Item ${index + 1}');\n\n  @override\n  ThemeData appBarTheme(BuildContext context) {\n    return ThemeData(\n      // 앱바 테마를 사용자 정의합니다.\n      appBarTheme: const AppBarTheme(\n        backgroundColor: Colors.blue,\n        foregroundColor: Colors.white,\n      ),\n      // 입력 장식 테마를 사용자 정의합니다.\n      inputDecorationTheme: const InputDecorationTheme(\n        isDense: true,\n        isCollapsed: true,\n        contentPadding: EdgeInsets.only(left: 12, top: 6, bottom: 6),\n        enabledBorder: OutlineInputBorder(\n            borderSide: BorderSide(\n          color: Colors.white,\n        )),\n        focusedBorder: OutlineInputBorder(\n            borderSide: BorderSide(\n          color: Colors.white,\n        )),\n        border: OutlineInputBorder(\n          borderSide: BorderSide(\n            color: Colors.white,\n          ),\n        ),\n      ),\n    );\n  }\r\n```\n\n\u003cimg src=\"/assets/img/2024-06-21-FlutterSearchBarAnUltimateGuide_0.png\" /\u003e\n\n# 일반적인 검색 위젯 만들기:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더 고급 구현으로 나아가기 위해 CustomSearchDelegate를 자세히 살펴봅시다. 이 일반적인 위젯은 여러 데이터 유형에서 재사용성과 적응성을 가장합니다.\n\n```js\n/// 어디서나 사용할 수 있는 제네릭 검색 대리자입니다\nclass CustomSearchDelegate\u003cT\u003e extends SearchDelegate\u003cList\u003cT\u003e\u003e {\n  CustomSearchDelegate({\n    required this.searchables,\n    required this.suggestionOrResult,\n    required this.itemMatcher,\n    this.onTap,\n  });\n  \n  // 검색 대상 항목\n  final List\u003cT\u003e searchables;\n  \n  // 제안 또는 결과를 가져올 때 표시해야 하는 위젯입니다.\n  // 제안과 결과에 대해 별도의 위젯을 사용하려면 suggestionWidget 및 resultWidget을 추가하여 \n  // 다른 방식으로 빌드할 수 있습니다.\n  final Widget Function(List\u003cT\u003e, String) suggestionOrResult;\n\n  // 일치 실행에 대한 쿼리\n  final bool Function(T item, String query) itemMatcher;\n\n  // 항목이 탭될 때의 콜백\n  final ValueChanged\u003cT\u003e? onTap;\n\n  @override\n  List\u003cWidget\u003e? buildActions(BuildContext context) {\n    return [\n      IconButton(\n        onPressed: () {\n          query = '';\n        },\n        icon: const Icon(Icons.clear),\n      ),\n    ];\n  }\n\n  @override\n  Widget buildLeading(BuildContext context) {\n    return IconButton(\n      onPressed: () {\n        close(context, []);\n      },\n      icon: Icon(\n        Platform.isAndroid ? Icons.arrow_back : Icons.arrow_back_ios,\n        size: 22,\n      ),\n    );\n  }\n\n  @override\n  Widget buildResults(BuildContext context) {\n    return _buildSuggestionOrResult();\n  }\n\n  @override\n  Widget buildSuggestions(BuildContext context) {\n    if (searchables.isEmpty) return const SizedBox();\n    return _buildSuggestionOrResult();\n  }\n\n  Widget _buildSuggestionOrResult() {\n    final List\u003cT\u003e suggestionList =\n        query.isEmpty ? searchables : searchables.where((item) =\u003e itemMatcher(item, query)).toList();\n\n    if (suggestionList.isEmpty) {\n      return NoResultFoundWidget();\n    }\n\n    return suggestionOrResult(suggestionList, query);\n  }\n\n}\n```\n\n다음과 같이 이 일반 대리자를 사용할 수 있습니다:\n```js\nshowSearch(\n  context: context,\n  delegate: CustomSearchDelegate\u003cList\u003cString\u003e\u003e(\n    searchables: searchables,\n    suggestionOrResult: (List\u003cString\u003e suggestions, String query) =\u003e ListWidget(\n      suggestionsList: searchables,\n      query: query,\n    ),\n    itemMatcher: (String item, String query) =\u003e item.toLowerCase().contains(query.toLowerCase()),\n  ),\n)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 보너스:\n\n만일 입력된 글자를 제시 목록에서 강조하고 결과로 스크롤하고 싶다면 다음 위젯을 사용할 수 있습니다.\n\n```js\nclass ListWidget extends StatefulWidget {\n  const ListWidget({\n    super.key,\n    required this.suggestionsList,\n    required this.query,\n  });\n\n  final List\u003cString\u003e suggestionsList;\n  final String query;\n\n  @override\n  State\u003cListWidget\u003e createState() =\u003e _ListWidgetState();\n}\n\nclass _ListWidgetState extends State\u003cListWidget\u003e {\n  late List\u003cString\u003e filteredList;\n  final ScrollController scrollController = ScrollController();\n\n  @override\n  void initState() {\n    super.initState();\n    filterList();\n  }\n\n  @override\n  void didUpdateWidget(ListWidget oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    if (widget.query != oldWidget.query) {\n      filterList();\n    }\n  }\n\n  void filterList() {\n    filteredList =\n        widget.suggestionsList.where((item) =\u003e item.toLowerCase().contains(widget.query.toLowerCase())).toList();\n\n    if (filteredList.isNotEmpty) {\n      if (filteredList.isNotEmpty) {\n        WidgetsBinding.instance.addPostFrameCallback((_) =\u003e scrollToFirstMatch());\n      }\n    }\n  }\n\n  void scrollToFirstMatch() {\n    int index = widget.suggestionsList.indexOf(filteredList.first);\n    if (index != -1 \u0026\u0026 scrollController.hasClients) {\n      scrollController.animateTo(\n        index * 32.0, // 각 항목의 높이가 32로 가정\n        duration: const Duration(milliseconds: 100),\n        curve: Curves.easeInOut,\n      );\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return ListView.separated(\n      controller: scrollController,\n      itemCount: filteredList.length,\n      itemBuilder: (context, index) {\n        final String suggestionText = filteredList[index];\n        return ListTile(\n          title: RichText(\n            text: highlightMatch(suggestionText, widget.query),\n          ),\n          onTap: () {\n            // 여기에 탭 기능을 추가하세요\n          },\n        );\n      },\n      separatorBuilder: (context, index) =\u003e const Divider(),\n    );\n  }\n\n  TextSpan highlightMatch(String text, String query) {\n    if (query.isEmpty || !text.toLowerCase().contains(query.toLowerCase())) {\n      return TextSpan(\n        text: text,\n        style: const TextStyle(color: Colors.black),\n      );\n    }\n\n    List\u003cTextSpan\u003e spans = [];\n    int start = 0;\n    int indexOfHighlight = text.toLowerCase().indexOf(query.toLowerCase());\n\n    while (indexOfHighlight != -1) {\n      spans.add(TextSpan(\n        text: text.substring(start, indexOfHighlight),\n        style: const TextStyle(color: Colors.black),\n      ));\n      spans.add(TextSpan(\n        text: text.substring(indexOfHighlight, indexOfHighlight + query.length),\n        style: const TextStyle(backgroundColor: Colors.yellow, color: Colors.black),\n      ));\n\n      start = indexOfHighlight + query.length;\n      indexOfHighlight = text.toLowerCase().indexOf(query.toLowerCase(), start);\n    }\n\n    spans.add(TextSpan(\n      text: text.substring(start),\n      style: const TextStyle(color: Colors.black),\n    ));\n    return TextSpan(children: spans);\n  }\n}\n```\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:468/1*8xf8nCjiihJQ-XUSlLe5MA.gif\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론:\n\n모바일 앱 디자인에서 효과적인 검색 기능은 사용자 만족도와 참여도에 중요한 요소입니다. 이 CustomSearchDelegate은 플러터 앱에서 사용자 정의 및 다양한 검색 기능을 만들기 위한 템플릿을 제공합니다.\n\n독서해 주셔서 감사합니다. 즐거운 코딩 하세요 :)\n\n# Stackademic\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n끝까지 읽어주셔서 감사합니다. 떠나시기 전에:\n\n- 작가를 격려하고 팔로우해 주세요! 👏\n- 트위터(X), 링크드인, 그리고 유튜브에서 저희를 팔로우해 주세요.\n- 전세계에서 무료 프로그래밍 교육을 민주화하고 있는 Stackademic.com을 방문해보세요.","ogImage":{"url":"/assets/img/2024-06-21-FlutterSearchBarAnUltimateGuide_0.png"},"coverImage":"/assets/img/2024-06-21-FlutterSearchBarAnUltimateGuide_0.png","tag":["Tech"],"readingTime":11}],"page":"1","totalPageCount":20,"totalPageGroupCount":1,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"1"},"buildId":"CfGULpm6qSb4RqH-Y7KhT","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>