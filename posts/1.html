<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>uidev-css</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://uidev-css.github.io///posts/1" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="uidev-css" data-gatsby-head="true"/><meta property="og:title" content="uidev-css" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://uidev-css.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://uidev-css.github.io///posts/1" data-gatsby-head="true"/><meta name="twitter:title" content="uidev-css" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | uidev-css" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-b7042cf2308ecd1e.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/9ddMoNNI_mr3kv4sKx3b_/_buildManifest.js" defer=""></script><script src="/_next/static/9ddMoNNI_mr3kv4sKx3b_/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UIDEV CSS</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="웹 백엔드 최적화 하는 방법" href="/post/2024-07-01-OptimizingWebBackends"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="웹 백엔드 최적화 하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-01-OptimizingWebBackends_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="웹 백엔드 최적화 하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">웹 백엔드 최적화 하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 1, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="포토샵 웹 버전 출시 브라우저에서 바로 사용해보세요" href="/post/2024-07-01-Photoshopisnowontheweb"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="포토샵 웹 버전 출시 브라우저에서 바로 사용해보세요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-01-Photoshopisnowontheweb_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="포토샵 웹 버전 출시 브라우저에서 바로 사용해보세요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">포토샵 웹 버전 출시 브라우저에서 바로 사용해보세요</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 1, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="WindowAI 사용해서 AI 기능 추가하는 방법" href="/post/2024-07-01-WindowAI"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="WindowAI 사용해서 AI 기능 추가하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-01-WindowAI_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="WindowAI 사용해서 AI 기능 추가하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">WindowAI 사용해서 AI 기능 추가하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 1, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter는 어떤 언어로 작성되었을까" href="/post/2024-07-01-Flutteriswritteninwhichlanguage"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter는 어떤 언어로 작성되었을까" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-01-Flutteriswritteninwhichlanguage_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter는 어떤 언어로 작성되었을까" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Flutter는 어떤 언어로 작성되었을까</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 1, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="네오빔으로 Flutter 개발하는 방법" href="/post/2024-07-01-FlutterdevelopmentwithNeovim"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="네오빔으로 Flutter 개발하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-01-FlutterdevelopmentwithNeovim_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="네오빔으로 Flutter 개발하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">네오빔으로 Flutter 개발하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 1, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Fastlane을 사용한 Flutter CDCI 자동화 마스터하기 단계별 가이드" href="/post/2024-07-01-MasteringCDCIAutomationinFlutterwithFastlaneAStep-by-StepGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Fastlane을 사용한 Flutter CDCI 자동화 마스터하기 단계별 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-01-MasteringCDCIAutomationinFlutterwithFastlaneAStep-by-StepGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Fastlane을 사용한 Flutter CDCI 자동화 마스터하기 단계별 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Fastlane을 사용한 Flutter CDCI 자동화 마스터하기 단계별 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 1, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="이미지를 실시간으로 크기 조절하는 방법" href="/post/2024-06-30-Resizingimageson-the-fly"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="이미지를 실시간으로 크기 조절하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-30-Resizingimageson-the-fly_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="이미지를 실시간으로 크기 조절하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">이미지를 실시간으로 크기 조절하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">18 hours ago</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flask, MongoDB, 그리고 React로 실시간 GitHub Webhook 리스너 만드는 방법" href="/post/2024-06-30-BuildingaReal-TimeGitHubWebhookListenerwithFlaskMongoDBandReact"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flask, MongoDB, 그리고 React로 실시간 GitHub Webhook 리스너 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-30-BuildingaReal-TimeGitHubWebhookListenerwithFlaskMongoDBandReact_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flask, MongoDB, 그리고 React로 실시간 GitHub Webhook 리스너 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Flask, MongoDB, 그리고 React로 실시간 GitHub Webhook 리스너 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">18 hours ago</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="25개월 휴식 후 코딩한 앱, 정말 멋진 결과물" href="/post/2024-06-30-Icodedanappafter25MONTH-BREAKanditactuallylookscool"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="25개월 휴식 후 코딩한 앱, 정말 멋진 결과물" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-30-Icodedanappafter25MONTH-BREAKanditactuallylookscool_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="25개월 휴식 후 코딩한 앱, 정말 멋진 결과물" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">25개월 휴식 후 코딩한 앱, 정말 멋진 결과물</strong><div class="PostList_meta__VCFLX"><span class="date">18 hours ago</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="플러터 ToDo 애플리케이션 파트 1 인프라설정 방법" href="/post/2024-06-30-FlutterToDoapplicationPart1Infrastructure"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="플러터 ToDo 애플리케이션 파트 1 인프라설정 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-30-FlutterToDoapplicationPart1Infrastructure_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="플러터 ToDo 애플리케이션 파트 1 인프라설정 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">플러터 ToDo 애플리케이션 파트 1 인프라설정 방법</strong><div class="PostList_meta__VCFLX"><span class="date">18 hours ago</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link posts_-active__YVJEi" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"웹 백엔드 최적화 하는 방법","description":"","date":"2024-07-01 17:20","slug":"2024-07-01-OptimizingWebBackends","content":"\n\n## 자주 사용되는 백엔드 최적화 기술을 담은 핸드북\n\n저는 백엔드 엔지니어로서 다양한 성능 최적화 문제를 경험해왔습니다. 각 문제는 그에 맞는 해결책과 기술을 가지고 있죠. 이 기사에서는 이러한 내용을 다루겠습니다.\n\n성능에 대해 이야기할 때, 다양한 의미가 있을 수 있습니다:\n\n- 높은 응답 시간\n- 낮은 응용프로그램 반응성\n- 높은 메모리 또는 CPU 사용량\n- 네트워크 자원의 낭비\n- 유후한 컴퓨팅 자원\n- 그 밖에도...\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위에서 언급한 모든 것들은 성능 문제로 간주될 수 있지만, 본 문서에서는 첫 번째 범주에 초점을 맞출 것입니다. 따라서 성능 문제, 병목 현상 또는 문제라고 언급할 때, 고객과 서버 간의 상호 작용이 느린 이유로 발생하는 높은 응답 시간을 의미합니다. 이 토론의 목적을 위해 HTTP가 이 상호 작용의 프로토콜로 선택되었다고 가정하겠습니다.\n\n# 다양한 수준에서 최적화하기\n\n제 경험을 토대로, 영향을 받는 범위에 따라 웹 애플리케이션을 최적화할 수 있는 세 가지 주요 수준(또는 레이어)을 식별했습니다:\n\n- 애플리케이션 레이어\n- 데이터베이스 레이어\n- 인프라스트럭처 레이어\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-07-01-OptimizingWebBackends_0.png\" /\u003e\n\n비록이 분류는 엄격한 기준을 갖고 있지 않고 결코 절대적이지 않을 수 있지만, 독자들이 자신의 생각을 더 잘 조직화할 수 있도록 도와줄 충분히 명확한 기법 그룹화를 제공하길 바랍니다.\n\n# 어플리케이션 레이어 최적화\n\n이 레이어는 우리 어플리케이션의 코드를 변경하는 조정을 포함합니다. 우리는 데이터베이스와 인프라 레이어를 건드리지 않은 채 애플리케이션의 일부를 더 나은 방법으로 다시 작성할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리 코드를 신중하게 측정한 후에는 더 빠른 대안을 찾거나 더 나은 데이터 구조를 사용하여 사용 중인 알고리즘을 최적화하고 싶을 수 있습니다. 효율적인 처리, 탐색 및 계산 알고리즘과 목적에 맞는 데이터 구조는 성능을 크게 향상시킬 수 있습니다. 게다가 레이턴시에 민감한 코드를 낮은 수준의 프로그래밍 언어로 다시 작성하면 이점을 얻을 수도 있습니다.\n\n비동기 패턴을 구현하면 상당한 성능 향상을 이끌어 낼 수 있습니다. 긴 수행 시간이 필요한 작업을 별도의 작업자 프로세스에서 처리함으로써 애플리케이션은 이러한 작업이 완료될 때까지 응답을 기다릴 필요가 없습니다. 비긴요한 작업을 비동기 작업자로 오프로드하여 사용자 경험에 미치는 영향을 평가하고 비즈니스 요구에 맞다면 이 패턴을 수용하세요.\n\n프로그래밍 환경에서 NodeJS와 Go와 같은 것들은 응용 수준에서 동시성을 지원합니다. 이 기술을 사용하면 여러 작업이 순차적으로 실행되는 대신 동시에 실행되도록 허용되며, 모든 작업이 완료된 후에 작업을 계속할 수 있습니다. 동시 응용 프로그램은 종종보다 복잡한 코드베이스로 이어질 수 있지만, CPU 유휴 간격을 더 효과적으로 활용할 수 있습니다. 이 기법이 작업 실행 시간을 감소시키는 것은 아니지만 CPU 리소스를 더 효율적으로 이용하려는 목표를 가지고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 기술들은 성능을 향상시킬 수 있지만, 종종 클라이언트/서버 상호작용을 최적화함으로써 상당한 성과를 얻을 수 있습니다. 사용자 경험을 분석하고 클라이언트/서버 통신을 더 효율적으로 만들 수 있는 방법을 식별해보세요. 캐싱 메커니즘을 사용하면 왕복 횟수를 줄일 수 있습니다. 페이징은 콘텐츠를 과다하게 가져오는 것을 피하는 일반적인 기술입니다. 사용자 인터페이스에 필요한 데이터만 가져오는 BFF(Backend for Frontend)를 구축하면 더 적은 서버 요청으로 결과를 얻을 수 있습니다. 이제 여러 개체를 단일(총계) API 호출을 통해 가져올 수 있습니다.\n\n![이미지](/assets/img/2024-07-01-OptimizingWebBackends_2.png)\n\n## 데이터베이스 레이어 최적화\n\n데이터베이스는 종종 백엔드 응용 프로그램에서 병목 현상이 발생합니다. 잘못된 스키마 설계는 비효율적인 작업과 느린 쿼리를 야기할 수 있습니다. 다음 기술들은 이 레이어에서의 성능 문제를 해결하는 데 도움이 될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n현대 데이터베이스는 읽기 속도를 높일 수 있는 색인 기능을 제공합니다. 색인은 하나 이상의 필드를 기반으로 데이터에 대한 참조를 저장하는 보조 데이터 구조입니다. 애플리케이션에서 일반적인 읽기 패턴을 평가한 후 색인 전략을 신중하게 고려해보세요. 아직 색인을 사용하고 있지 않다면 시작할 때입니다.\n\n데이터베이스 쿼리를 실행할 때는 행과 열의 수에 따라 처리해야 하는 데이터 양이 많아집니다. 많은 개발자들이 읽기 작업의 영향 표면을 줄이면 성능이 어떻게 향상될 수 있는지를 과소평가합니다. 선택적 쿼리를 사용하여 필요한 열만 검색하거나 (예: SQL에서 SELECT *를 피하거나 MongoDB에서 프로젝션 사용) 사용 사례에 따라 페이지 쿼리를 사용하여 필요한 행만 가져올 수 있습니다.\n\n![OptimizingWebBackends_3](/assets/img/2024-07-01-OptimizingWebBackends_3.png)\n\n대부분의 데이터베이스 제공업체는 확장 기능을 제공합니다. 수직 확장은 양질의 하드웨어를 확보하여 성능을 향상시키는 반면, 수평 확장은 더 많은 처리 노드(예: 서버)를 추가하여 용량을 늘리는 방식입니다. 신중한 평가 후 데이터베이스의 확장을 고려해보세요. 수직 확장은 주로 SQL 데이터베이스에 적용되고, 수평 확장은 NoSQL 데이터베이스에서 더 일반적입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모든 데이터베이스 작업은 하나 이상의 데이터베이스 노드에서 처리되는 워크로드를 생성합니다. 이 워크로드를 더 잘 관리하기 위해 데이터 파티셔닝 기술을 고려해보세요. 데이터 파티셔닝은 데이터를 청크로 나누어 각 처리 노드의 작업량을 줄이는 방법입니다. 수직 분할은 열에 따라 데이터를 나누고, 수평 분할은 행에 따라 데이터를 나눕니다. 적시에 파티셔닝은 오래된 데이터나 자주 액세스되지 않는 행을 별도의 테이블로 이동하거나 아카이브하여 데이터베이스 부담을 줄입니다. 샤딩은 NoSQL 데이터베이스에서 흔히 볼 수 있는데, 테이블 청크를 여러 노드에 분산시켜 작업을 병렬로 진행합니다.\n\n![Optimizing Web Backends](/assets/img/2024-07-01-OptimizingWebBackends_4.png)\n\n데이터베이스 성능을 개선하는 가장 강력한 기술 중 하나는 데이터베이스 솔루션을 재설계하는 것입니다. 이 도전적인 접근 방식은 전체 응용 프로그램 재작성을 포함할 수 있지만, 일반적으로 상당한 이득을 가져옵니다. 응용 프로그램이 데이터와 상호작용하는 방식에 대해 철저히 이해한 후 스키마, 테이블 및 인덱싱 전략을 재설계하는 것이 유익할 수 있습니다. 읽기 및 쓰기 패턴이 크게 다른 경우 CQRS를 채택하거나, 응용 프로그램 요구 사항에 부합하지 않는 데이터베이스 간에 SQL 및 NoSQL을 전환하는 것을 고려해보세요. \n\n# 인프라스트럭처 레이어 최적화\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n인프라스트럭처 레이어 최적화는 통신 메커니즘, 네트워크 아키텍처 및 기저 하위 수준 자원에 대한 변경을 포함합니다. 주로 다른 레이어에서 상당한 성능 향상이 일어나지만, 이 수준에서 조정을 통해 레이턴시 및 실행 시간 면에서 상당한 이점을 얻을 수도 있습니다.\n\n콘텐츠 전달 네트워크(CDNs)는 지리적으로 분산된 네트워크를 통해 서버를 사용자 근처에 배치함으로써 사용자 친화적 콘텐츠(HTML 페이지, JavaScript, CSS)의 대기 시간과 응답 시간을 줄입니다. 사용자 친화적 자산의 일부 또는 전부를 전달하기 위해 CDNs를 고려해 보세요. 많은 CDN 공급업체가 콘텐츠 캐싱 및 HTTP/2 지원과 같은 고급 성능 기능을 제공합니다.\n\n응용 프로그램에서 불필요한 지연이 발생하고 인프라 문제가 의심될 경우 현재 네트워크 아키텍처를 평가해 보세요. 원치 않는 레이턴시를 추가하는 불필요한 호핑, 중간 장치, 프로토콜 또는 잘못 구성된 프록시의 수에 놀라실 수도 있습니다.\n\n서버의 HTTP 버전 업그레이드는 과거에는 복잡했지만 지금은 훨씬 쉬워졌습니다. 서버와 클라이언트 모두에 널리 사용되는 HTTP/2 또는 HTTP/3로 업그레이드를 고려해 보세요. 이러한 새로운 버전은 연결 최적화, 데이터 압축 및 심지어 전송 계층으로 UDP 사용과 같은 방식으로 성능 병목 현상을 해소합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nHTTP/1에 갇혀 있다면, 여전히 기본 TCP 프로토콜에 대한 저수준 최적화를 활성화할 수 있어요. 서버 운영 체제를 정기적으로 업그레이드하면 최신 TCP 향상 기능이 적용돼요. 게다가 초기 혼잡 윈도우 크기(CWND)를 증가시켜 Slow-Start 알고리즘을 가속화하는 등 구성을 직접 활성화할 수도 있어요. 또한 순서가 바뀐 데이터 패킷을 확인하기 위해 선택적 수신(Acknowledge)을 활성화하거나, 유휴 상태 후에 TCP Slow-Start를 비활성화하여 유휴 연결의 업로드 트로틀링을 방지하고, TCP Fast Open을 활성화하여 TCP 핸드쉐이크에 필요한 작업을 줄일 수도 있어요. \n\n전송 중 데이터 압축은 현대 웹 애플리케이션에서 거의 필수적이에요. 특히 HTML 자산(.html, .js, .css 파일)에 의존하는 애플리케이션에서 압축 알고리즘인 deflate, gzip, 또는 Brotli를 사용하면 트래픽 양을 줄일 수 있어요. 이를 통해 사용 가능한 대역폭을 더 효과적으로 활용할 수 있어요.\n\nHTTP는 가장 인기 있는 웹 API 기술이며, HTTP를 사용하는 대부분의 API는 REST 원칙을 따라 RESTful API가 되어요. 하지만 GraphQL과 gRPC와 같은 대안들은 시스템 간 통신에 대한 새로운 기회를 제공하거나요. GraphQL은 여전히 HTTP를 기반으로 하면서 필요한 데이터만 효율적으로 전송하여 과다 및 부족한 데이터를 피할 수 있어요. gRPC는 HTTP/2와 프로토콜 버퍼를 사용하여 대역폭을 더 효율적으로 활용할 수 있어요. REST가 더 이상 요구사항을 충족하지 못할 때 API 기술을 변경하는 것도 고려해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n백엔드 응용 프로그램의 확장은 복제를 수반할 수 있습니다. 이는 주 어플리케이션 프로세스를 복제하거나 클러스터링하는 것뿐만 아니라 인프라를 복제하는 것을 의미합니다. 가상 머신의 수(쿠버네티스의 워커 노드)와 어플리케이션 인스턴스의 수(pods in Kubernetes)를 늘리면 더 많은 트래픽을 처리할 수 있습니다. 그러나 이것이 항상 해결책은 아닙니다. 더 많은 트래픽을 처리하기 위해 복제가 유일한 방법이라면 새로운 아키텍처 대안을 고려할 시기일 수도 있습니다. 복제는 병행성 문제와 같은 새로운 도전 과제를 도입할 수 있으며, 어플리케이션이 단일 인스턴스로 실행될 때 발생하지 않았던 문제가 발생할 수 있습니다. 그러나 적용 가능하다면 어플리케이션을 복제함으로써 병렬성과 부하 분산을 활용할 수 있습니다.\n\n![OptimizingWebBackends_6](/assets/img/2024-07-01-OptimizingWebBackends_6.png)\n\n# 결론\n\n요약하면, 웹 백엔드를 최적화하기 위해 가장 흔히 사용되는 몇 가지 기술을 살펴보았습니다. 본문에서 다루지 않은 많은 기술들이 더 있습니다. 이러한 개선 사항을 구현할 지를 결정하는 것은 우리가 작업하는 애플리케이션의 유형과 기능적 비기능적 요구 사항에 달려 있으며, 종종 기존 아키텍처에 제약을 가하고 우리의 행동 영역을 제한할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n측정과 테스트는 어떤 수정을 구현할지 결정하고 어떻게 구현해야 하는지를 결정하는 데 필수적입니다. 이 없이는 해당 애플리케이션에 적합하게 작동할 것을 보장할 수 없습니다. 여러분은 여러 기능 집합을 선택하고 Proof of Concept(PoC)를 실행하여 통찰을 얻을 수 있습니다. 이 문맥에서 부하 테스트는 높은 작업량 시나리오를 에뮬레이션하고 최적화 전후에 애플리케이션이 얼마나 잘 작동하는지 확인하는 데 매우 도움이 됩니다.\n\n마지막으로 본 기사에서 다룬 기술들은 다음과 같습니다:\n\n애플리케이션 계층 최적화\n\n- 사용 중인 알고리즘 최적화\n- 비동기 함수 사용\n- 병렬 처리 기능 활용하기\n- 클라이언트/서버 상호작용 최적화하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n데이터베이스 레이어 최적화\n\n- 인덱싱 활용\n- 선택적 쿼리 사용\n- 데이터베이스 확장\n- 데이터 파티셔닝 구현\n- 데이터베이스 솔루션 재설계\n\n인프라스트럭처 레이어 최적화\n\n- CDN 사용\n- 네트워크 아키텍처 검토\n- HTTP/2 또는 HTTP/3로 업그레이드\n- TCP 최적화를 위한 낮은 수준 설정 활성화\n- 데이터 압축\n- 대안 웹 API 기술 고려\n- 인프라 복제\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 이 기사가 도움이 되었다면, 좋아요 버튼을 꾹 눌러주세요! 그리고 구독도 잊지 말아주세요. 앞으로 더 멋진 팁과 요령이 쏟아질테니 기대해주세요. 여러분의 의견을 듣는 것을 좋아해요, 의견을 남겨주세요. 더 멋진 콘텐츠가 여러분을 기다리고 있어요!","ogImage":{"url":"/assets/img/2024-07-01-OptimizingWebBackends_0.png"},"coverImage":"/assets/img/2024-07-01-OptimizingWebBackends_0.png","tag":["Tech"],"readingTime":7},{"title":"포토샵 웹 버전 출시 브라우저에서 바로 사용해보세요","description":"","date":"2024-07-01 17:18","slug":"2024-07-01-Photoshopisnowontheweb","content":"\n\nWebAssembly + Emscripten, Web Components + Lit, Service Workers + Workbox 및 새로운 Web API를 통해 가능해졌어요. Chrome과 Adobe가 함께 협력하여 이를 즐기고 있어요.\n\n웹(photoshop.adobe.com)에 Photoshop 데스크톱 애플리케이션을 가져오는 것은 브라우저로 매우 복잡하고 그래픽 집중적인 소프트웨어를 가져오는 데 거대한 새로운 이정표를 의미해요. 이는 Adobe 엔지니어들의 년에 걸친 노력과 Chrome과 같은 브라우저 공급업체와의 협력을 통해 가능하게 되었어요.\n\n이 사례 연구에서는 고급 웹 기능의 잠금을 해제하는, 성능 최적화 및 가능성을 살펴볼 거예요. '웹으로의 Photoshop 여정'도 훌륭한 읽을거리에요.\n\n# 비전: 브라우저에서의 Photoshop\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n수십 년간 Photoshop은 이미지 편집과 그래픽 디자인 분야에서의 금잔디로, Windows와 macOS에서 창의력을 불어넣어 왔습니다. 하지만 데스크톱에서 해방되면 새로운 기회의 문이 열립니다.\n\n웹은 어디에서나, 원활하게 접근할 수 있는 약속을 제공합니다. 사용자는 브라우저만 있으면 즉시 편집을 시작하고 협업을 시작할 수 있습니다. 설치가 필요하지 않습니다. 그리고 다양한 기기에서 신속하게 이어서 작업할 수 있습니다.\n\n링크 기능은 워크플로우 공유를 가능하게 합니다. Photoshop 문서는 파일 시스템에 숨기지 않고 URL을 통해 액세스할 수 있습니다. 창조자는 협업자에게 쉽게 링크를 보낼 수 있습니다.\n\n플랫폼 간 유연성. 웹을 사용한 런타임은 기본 운영 체제를 추상화시킵니다. Photoshop은 다중 플랫폼의 사용자에게 도달할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 상당한 기술적 어려움이 이 빛깔을 실현하는데 있어 장애물이 되었습니다. 특히 포토샵과 같이 강력한 앱이 웹에서 어떻게 작동할지에 대해 다시 고민할 필요가 있었습니다.\n\n# 새로운 웹 기능이 포토샵의 잠재력을 발휘\n\n최근 몇 년간, 표준화 및 구현을 통해 드디어 포토샵 수준의 애플리케이션을 가능하게 하는 새로운 웹 플랫폼 기능이 등장했습니다. Adobe 엔지니어들은 여러 핵심 차세대 API를 혁신적으로 활용하였습니다:\n\n# 원본 개인 파일 시스템을 통한 고성능 로컬 파일 액세스\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n포토샵 작업은 대용량 PSD 파일을 읽고 쓰는 것을 포함합니다. 이를 위해서 로컬 파일 시스템에 효율적으로 접근해야 합니다. 새 Origin Private File System API(OPFS)는 빠르고 특정 원점 가상 파일 시스템을 제공합니다.\n\n```js\nconst opfsRoot = await navigator.storage.getDirectory();\n```\n\nOPFS를 사용하면 파일을 빠르게 생성, 읽기, 쓰기 및 삭제할 수 있습니다. 예를 들어:\n\n```js\n// 파일 생성\nconst file = await opfsRoot.getFileHandle('image.psd', {create: true}); \n\n// 읽기/쓰기 핸들 가져오기\nconst handle = await file.createSyncAccessHandle();\n\n// 내용 쓰기  \nhandle.write(buffer); \n\n// 내용 읽기\nhandle.read(buffer);\n\n// 파일 삭제\nawait file.remove();\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가장 빠른 동기 작업을 위해서는 Web Workers가 FileSystemSyncAccessHandle을 얻을 수 있습니다.\n\n로컬 고성능 파일 시스템은 브라우저에서 Photoshop의 요구하는 파일 워크플로우를 구현하는 데 중요합니다.\n\n# 웹어셈블리의 힘 발휘\n\nWebAssembly는 JavaScript에서 Photoshop의 계산 집약적인 그래픽 처리를 재현하는 데 필수 요소였습니다. Adobe는 Emscripten 컴파일러를 사용하여 기존의 C/C++ 코드베이스를 WebAssembly 모듈로 이식했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹어셈블리(WebAssembly)의 여러 기능이 중요했어요:\n\n- 쓰레드 — 포토샵은 이미지 타일 처리와 같은 작업을 병렬로 실행하기 위해 워커 스레드를 사용합니다:\n\n```js\n// 쓰레드 함수\nvoid* tileProcessor(void* data) {\n  // 이미지 타일 데이터 처리\n  return NULL;\n}\n\n// 워커 스레드 시작\npthread_t thread1, thread2;\npthread_create(\u0026thread1, NULL, tileProcessor, NULL);\npthread_create(\u0026thread2, NULL, tileProcessor, NULL);\n\n// 스레드가 작업을 완료할 때까지 대기\npthread_join(thread1, NULL);\npthread_join(thread2, NULL);\n```\n\n- SIMD — SIMD 벡터 명령어는 픽셀 처리 및 필터링을 가속화합니다.\n- 예외 처리 — C++ 예외는 포토샵 코드베이스 전반에 널리 사용됩니다.\n- 스트리밍 인스턴스화 — 포토샵의 80MB 이상의 WASM 모듈은 스트리밍 컴파일을 필요로 합니다.\n- 디버깅 — 크롬의 웹어셈블리 디버깅 지원이 개발도구에서 큰 도움이 되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 광범위한 P3 컬러 감마 활용하기\n\nsRGB의 컬러 스펙트럼은 넓은 P3 감마와 비교하면 창의 앞에서 치졌지만, 웹에서는 오랫동안 유일한 옵션이었습니다.\n\n![Photoshop is now on the web](/assets/img/2024-07-01-Photoshopisnowontheweb_0.png)\n\nPhotoshop은 새로운 color() 함수와 Canvas API를 사용하여 P3의 전체 삶을 끌어내어 더욱 정확한 컬러 표현을 가능하게 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ncolor: color(display-p3 1 0.5 0)\n```\n\n# 웹 구성 요소와 UI 유연성\n\n포토샵은 Adobe의 포괄적인 크리에이티브 클라우드 생태계의 일부입니다. Lit을 기반으로 한 표준화된 웹 구성 요소 전략을 사용하면 응용 프로그램 간에 일관된 UI를 제공할 수 있습니다.\n\n포토샵의 UI 요소는 Adobe의 디자인 시스템을 구현하는 Adobe의 Spectrum 웹 구성 요소 라이브러리에서 가져옵니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n스펙트럼 웹 컴포넌트는 다음과 같습니다:\n\n- 기본적으로 접근성을 고려함 — 보조 기술을 지원하기 위해 기존 및 새로운 브라우저 사양을 고려하여 개발되었습니다.\n- 가벼움 — LitElement을 사용하여 최소한의 오버헤드로 구현되었습니다.\n- 표준 기반 — 맞춤 요소(custom elements) 및 쉐도우 DOM과 같은 웹 컴포넌트 표준에 기반하여 구축되었습니다.\n- 프레임워크에 중립적 — 브라우저 수준의 지원을 통해 모든 프레임워크와 작동할 수 있습니다.\n\n또한, 전체 포토샵 앱은 Lit을 기반으로 한 웹 컴포넌트를 사용하여 구축되었습니다. Lit의 템플릿 및 가상 DOM 차이 비교(diffing) 기능을 통해 효율적인 UI 업데이트를 가능케 합니다. 또한 웹 컴포넌트 캡슐화를 통해 다른 팀에서 React 코드를 필요할 때 쉽게 통합할 수 있었습니다.\n\n앞서 설명한 대로, 웹 컴포넌트의 브라우저 네이티브 맞춤 요소와 Lit의 성능이 조화를 이루어, 효율성을 유지하면서 포토샵의 복잡한 UI를 구축하는 데 필요한 유연성을 제공했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 브라우저에서 Photoshop 성능 최적화\n\n새로운 웹 기능은 기본을 제공했지만, Photoshop과 같은 엄청난 데스크톱 응용 프로그램은 여전히 우수한 온라인 경험을 제공하기 위해 포괄적인 추적과 성능 작업이 필요했습니다.\n\n![이미지](/assets/img/2024-07-01-Photoshopisnowontheweb_1.png)\n\n# 서비스 워커를 사용하여 에셋 및 코드 캐싱하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n서비스 워커는 웹 앱이 초기 방문 후에 로컬로 자산, 코드 및 기타 리소스를 캐시하여 훨씬 더 빠른로드 시간을 제공할 수 있습니다. 아직 완전히 오프라인 작동 가능한 앱은 아니지만, 포토샵은 이미 서비스 워커를 활용하여 WebAssembly 모듈, 스크립트 및 기타 자산을 캐시합니다.\n\n이 캐싱은 로드 성능에 현격한 차이를 만들어냅니다. 첫 방문 후에는 일반적으로 로드가 매우 빨라집니다 (M1 Macbook):\n\nAdobe는 Workbox 라이브러리를 사용하여 서비스 워커 캐싱을 더 쉽게 빌드 프로세스에 통합했습니다.\n\n캐시된 리소스의 V8 최적화\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nV8는 서비스 워커 캐시에서 리소스가 반환될 때 몇 가지 최적화를 적용합니다:\n\n- 설치 중에 캐시된 리소스는 일관된 빠른 성능을 위해 즉시 컴파일되고 코드가 캐시 됩니다.\n- 플레이어로 가져온 캐시 API를 통해 캐시된 리소스는 일반적인 캐싱보다 빠르게 최적화되어 2차로 로드됩니다.\n- V8는 캐시되고 중요도 있는 리소스를 감지하고 더 적극적으로 컴파일합니다.\n\n이러한 최적화를 통해 Photoshop의 대규모 캐시된 Wasm 모듈을 최적화할 수 있습니다.\n\n![Photoshop is now on the web](/assets/img/2024-07-01-Photoshopisnowontheweb_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 대규모 WebAssembly 모듈의 스트리밍 및 캐싱\n\n포토샵의 코드는 80MB 이상인 여러 대규모 WebAssembly 모듈을 필요로 합니다. V8 및 Chrome의 스트리밍 컴파일 지원을 통해 이러한 거대한 모듈을 효율적으로 처리할 수 있습니다.\n\n또한, Service Worker로부터 처음으로 WebAssembly 모듈을 요청할 때 V8는 최적화된 버전을 생성하고 캐시에 저장합니다. 이것은 포토샵의 대규모 코드 크기에 필수적입니다.\n\n# 병렬 그래픽 작업을 위한 멀티스레딩\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n많은 중요한 이미지 처리 작업들은 픽셀 변환과 같은 Photoshop의 핵심 이미지 처리 작업들이 스레드 간 병렬 실행을 통해 대규모로 가속화될 수 있습니다. WebAssembly의 스레드 지원은 계산 집약적인 그래픽 작업을 수행하기 위해 다중 코어 장치를 활용할 수 있게 합니다.\n\n이를 통해 Photoshop은 성능에 중점을 둔 이미지 처리 기능을 웹어셈블리로 이식할 때 데스크탑에서 사용하는 동일한 다중 스레딩 접근 방식을 활용할 수 있습니다.\n\n# 최적화를 위한 웹어셈블리 디버깅\n\nWebAssembly를 최적화하기 위해 튼튼한 웹어셈블리 디버깅 지원은 개발 중 성능 병목 현상을 진단하고 해결하는 데 중요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nChrome DevTool은 WASM 코드를 프로파일링하고 중단점을 설정하며 다양한 변수를 검사할 수 있는 능력이 JavaScript의 디버깅 가능성과 유사합니다:\n\n# TensorFlow.js를 활용한 기기 내 기계 학습 통합\n\n웹상의 최신 Photoshop 버전에는 TensorFlow.js를 활용한 인공 지능 기능이 포함되어 있습니다. 클라우드가 아니라 기기에서 모델을 실행하는 것은 개인 정보 보호, 응답 속도, 비용면에서 개선되었습니다.\n\n선택 주제 기능은 머신러닝을 사용하여 이미지에서 주요 전경 객체를 자동으로 추출하므로 복잡한 선택을 빠르게 처리할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모델을 TensorFlow에서 TensorFlow.js로 변환하여 로컬 실행이 가능하도록 했어요:\n\n```js\n// 선택된 주제 모델 로드\nconst model = await tf.loadGraphModel('select_subject.json');\n\n// 이미지 텐서에서 추론 실행  \nconst {mask, background} = model.execute(imgTensor);\n\n// 마스크에서 선택을 정밀화하기\n```\n\nAdobe와 Google은 Photoshop의 WebAssembly 코드와 TensorFlow.js 간의 동기화 문제를 해결하기 위해 Emscripten을 위한 프록시 API를 개발하면서 협력했어요. 이를 통해 프레임워크 간의 원활한 통합이 가능해졌어요.\n\nConv2D와 같은 성능에 중점을 둔 중요한 작업에 초점을 맞춘 주요 모델이 최적화되었어요. Photoshop은 성능 요구 사항에 따라 장치 내 또는 클라우드에서 모델을 실행할지 선택할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nTensorFlow.js 포토샵 문서에서 더 많은 내용을 확인해 보세요.\n\n# 웹 상의 포토샵 미래\n\n웹 상의 포토샵 일반 공개는 엄청난 이정표를 의미하지만, 가능성은 아직도 한계에 다다르지 않았습니다.\n\n웹 상에서 포토샵은 계속해서 발전할 것이며, 브라우저 업체들이 표준과 성능을 진화시키면서 더 많은 기능이 점진적으로 추가될 것입니다. 그리고 포토샵은 단순히 시작에 불과합니다. Adobe는 웹 상에서 전체 크리에이티브 클라우드 스위트를 적극적으로 구축할 계획이며, 브라우저에서 더욱 정교한 디자인 응용 프로그램을 개발해 나갈 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAdobe와 브라우저 엔지니어들 간의 협력은 표준과 성능 개선을 통해 더욱 적극적인 응용 프로그램을 위한 웹 플랫폼으로의 전진을 이끌어나갈 것입니다. 미래에는 흥미로운 시기가 기다리고 있어요!\n\n# 웹에서 포토샵 사용해보기\n\n웹 상에서의 포토샵은 현재 다음의 데스크톱 버전 브라우저에서 이용 가능합니다:\n\n- Chrome 102+\n- Edge 102+\n- Firefox 111+\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그리고 Safari에 대한 지원 갭을 메우기 위한 작업이 진행 중입니다.\n\n오늘 photoshop.adobe.com에서 시도해 볼 수 있어요. 웹 상의 창의성과 디자인의 미래가 손끝에서 펼쳐집니다!","ogImage":{"url":"/assets/img/2024-07-01-Photoshopisnowontheweb_0.png"},"coverImage":"/assets/img/2024-07-01-Photoshopisnowontheweb_0.png","tag":["Tech"],"readingTime":8},{"title":"WindowAI 사용해서 AI 기능 추가하는 방법","description":"","date":"2024-07-01 17:17","slug":"2024-07-01-WindowAI","content":"\n\n\u003cimg src=\"/assets/img/2024-07-01-WindowAI_0.png\" /\u003e\n\n# 소개\n\nAI 기술이 급속하게 발전하고 있습니다. Window.ai를 사용하면 이제 AI 모델을 직접 DevTools 내에서 실행할 수 있습니다! Chrome Canary 및 Chrome Dev에서 제공되는 이 기능은 웹 개발자들에게 새로운 흥미로운 기회를 제공합니다. 이 기사에서는 Window.ai를 장치에 설정하는 방법을 안내하겠습니다. Window.ai를 인터넷 연결 없이 DevTools에서 실행할 수 있다는 것은 가끔 결과가 기대에 못 미칠지라도 상당히 즐거운 경험이 될 것입니다!\n\n# 설정\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n윈도우.ai를 사용하기 시작하는 것은 빠르고 쉽습니다 - 단 5분만에 완료하세요!\n\n## 1. Chrome Canary 다운로드\n\n먼저 Chrome Canary 사이트로 이동하여 Chrome Canary를 다운로드하세요. 이 버전은 최신 기능과 실험을 포함하고 있습니다.\n\n## 2. \"젬나이 나노를 위한 API 프롬프트\" 활성화\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nChrome Canary를 열고 URL 창에 chrome://flags/를 입력한 후 엔터를 누르세요. 검색 상자에 \"prompt API\"라고 입력하면 \"Prompt API for Gemini Nano\" 항목이 나타날 것입니다. 이 옵션을 활성화하세요.\n\n## 3. 이후에는 다음 플래그를 활성화해야 합니다:\n\n- chrome://flags/#prompt-api-for-gemini-nano: 활성화됨\n- chrome://flags/#optimization-guide-on-device-model: 활성화됨 BypassPrefRequirement\n- chrome://components/: 모델을 다운로드하려면 Optimization Guide On Device Model을 클릭하세요.\n\n## 4. Gemini Nano을 설치하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 장치에 Gemini Nano를 설치하세요. 이 파일은 크기가 크므로 (1.5GB) 다소 기다려야 합니다. chrome://components/로 이동하여 \"장치 모델에 대한 최적화 안내\"를 검색하고 \"업데이트 확인\"을 클릭하여 설치하세요.\n\n![이미지](/assets/img/2024-07-01-WindowAI_1.png)\n\n# 5. Chrome Canary 재시작\n\n마지막으로 Chrome Canary를 재시작하여 변경 내용을 적용하세요. 이제 Window.ai를 사용할 준비가 되었습니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 윈도우.ai를 사용해보세요\n\n모든 것이 제대로 설정되어 있다면, DevTools (F12)를 열고 \"콘솔\" 탭으로 이동하여 실험을 시작해보세요. 콘솔에 window.을 입력하면 ai가 옵션으로 표시됩니다.\n\n# 내 생각은?\n\n# 멋지네요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 로컬 실행: AI 모델을 로컬에서 실행하면 큰 비용이나 지연 문제가 없습니다.\n- 재미있게 놀 수 있어요: 브라우저에서 인터넷 연결이 필요 없이 AI가 직접 작동하는 것을 보는 것이 멋집니다.\n- 요약에 좋아요: 텍스트를 간단히 요약하는 것과 같은 간단한 작업을 잘 처리할 수 있습니다.\n\n# 아쉬운 점\n\n- 기능 제한: Claude나 ChatGPT와 같은 고급 모델과 비교했을 때 결과가 기본적입니다.\n- 메모리 부재: 각 질문은 독립적으로 처리되므로 대화 맥락이 없습니다.\n\n# 생각들\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nWindow.ai은 로컬에서 AI를 실험해보고 싶어하는 개발자들에게 놀라운 도구입니다. 더 정교한 모델을 대체할 수는 없지만, 시도해보고 새로운 가능성을 탐험하기에 탁월합니다. 브라우저에 AI가 점점 더 통합되면, 놀라운 혁신이 나타날 수도 있습니다! 그러나 주의를 기울이는 것이 중요합니다. AI의 널리 사용은 불필요하거나 문제가 될 수 있는 응용프로그램으로 이어질 수 있습니다. 지금은 Window.ai를 즐기며 무엇을 만들 수 있는지 확인해보세요!\n\nWindow.ai가 흥미진진하더라도, 책임있게 사용하는 것이 중요합니다. 웹 개발에서의 AI 미래는 가능성으로 가득 차 있으며, 우리는 현명하게 그것을 조직하는 책임이 있습니다.","ogImage":{"url":"/assets/img/2024-07-01-WindowAI_0.png"},"coverImage":"/assets/img/2024-07-01-WindowAI_0.png","tag":["Tech"],"readingTime":3},{"title":"Flutter는 어떤 언어로 작성되었을까","description":"","date":"2024-07-01 17:16","slug":"2024-07-01-Flutteriswritteninwhichlanguage","content":"\n\n![이미지](/assets/img/2024-07-01-Flutteriswritteninwhichlanguage_0.png)\n\n플러터는 창의성, 혁신 및 열정의 언어로 작성되었습니다. 이는 장벽을 넘어 사람들을 연결하며, 꿈을 꾸고 창조하려는 이들의 마음과 영혼에 말을 걸어옵니다.\n\n플러터는 프로그래밍 언어뿐만 아니라, 개발자들이 아이디어를 아름답고 직관적인 방식으로 구현할 수 있도록 하는 도구입니다. 개발자들이 자신을 표현하고 자신들의 재능을 세계에 뽐내도록 허용하는 언어입니다.\n\n\"플러터는 어떤 언어로 작성되었나요?\"라고 묻을 때, 단순히 프레임워크의 기술적 측면에 대해 묻는 것이 아닙니다. 플러터의 본질, 플러터를 진전시키고 개발자들이 가능한 범위를 넓히도록 영감을 주는 정신에 대해 묻습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플러터는 협업과 커뮤니티의 언어로 쓰여졌어요. 아이디어를 교환하고 지식을 공유하는 데서 발전하는 언어예요. 개발자들은 서로 지원하고 배우며, 진정으로 훌륭한 것을 만들기 위해 뭉칩니다.\n\n플러터는 적응력과 유연성의 언어로 쓰여졌어요. 간단한 모바일 앱부터 복잡한 웹 인터페이스까지 다양한 애플리케이션을 만드는 데 사용될 수 있는 언어예요. 개발자들과 사용자들의 요구에 맞게 발전하고 성장할 수 있는 언어예요.\n\n플러터는 아름다움과 우아함의 언어로 쓰여졌어요. 디자인과 미학을 중요시하는 언어로, 기능적인 애플리케이션뿐만 아니라 시각적으로 멋진 애플리케이션을 만들기 위해 노력하는 언어예요. 사용자 경험의 중요성을 이해하고, 사용자를 기쁘고 매료시키기 위해 노력하는 언어예요.\n\n플러터는 열정과 헌신의 언어로 쓰여졌어요. 개발자들이 자신의 비전을 실현하고, 장애물과 도전에 극복하여 정말 특별한 것을 만들기 위해 끈질기게 노력하도록 하는 언어예요. 창의성을 자극하고, 새로운 높은 목표를 향해 나아가도록 영감을 주는 언어예요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n결론적으로, Flutter는 사용하는 개발자들만큼 다양하고 다면적인 언어로 쓰여졌습니다. 이는 아름답고 혁신적인 애플리케이션을 만들기에 열정적인 사람들의 마음과 영혼을 담아냅니다. Flutter는 개발자들이 대단한 꿈을 꾸고, 다른 이들과 협업하며, 아이디어를 마법 같은 방식으로 현실로 구현할 수 있도록 움직입니다. 그래서 다음 번에 \"Flutter는 어떤 언어로 쓰여졌지?\"라고 물어보면, 창의력, 혁신, 열정의 언어로 쓰여졌다는 것을 기억해주세요.","ogImage":{"url":"/assets/img/2024-07-01-Flutteriswritteninwhichlanguage_0.png"},"coverImage":"/assets/img/2024-07-01-Flutteriswritteninwhichlanguage_0.png","tag":["Tech"],"readingTime":2},{"title":"네오빔으로 Flutter 개발하는 방법","description":"","date":"2024-07-01 17:15","slug":"2024-07-01-FlutterdevelopmentwithNeovim","content":"\n\n이 가이드는 플러터 개발을 위해 Neovim을 설정하고 사용하는 데 도움을 줍니다. Neovim 버전은 v0.10.0이며 플러그인 매니저는 lazy.nvim입니다. 제 dotfile은 여기에서 찾을 수 있습니다.\n\n![이미지 0](/assets/img/2024-07-01-FlutterdevelopmentwithNeovim_0.png)\n\n![이미지 1](/assets/img/2024-07-01-FlutterdevelopmentwithNeovim_1.png)\n\n![이미지 2](/assets/img/2024-07-01-FlutterdevelopmentwithNeovim_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플러터 개발을 위해 [flutter-tools.nvim](https://github.com/akinsho/flutter-tools.nvim) 플러그인이 매우 유용합니다. 만약 디버거가 필요하지 않다면 nvim-dap을 설치하지 않고 flutter-tools만 사용할 수 있습니다. 아래는 관련 구성 조각입니다:\n\n```js\n -- 디버거\n    {\n        \"mfussenegger/nvim-dap\",\n        dependencies = {\n            'nvim-neotest/nvim-nio',\n            'rcarriga/nvim-dap-ui',\n        },\n        event = 'VeryLazy',\n        config = function()\n            require(\"dapui\").setup({\n                icons = { expanded = \"▾\", collapsed = \"▸\" },\n                layouts = {\n                    {\n                        elements = {\n                            { id = \"scopes\", size = 0.25 },\n                            \"breakpoints\",\n                            \"stacks\",\n                            \"watches\",\n                        },\n                        size = 10, -- 컬럼\n                        position = \"bottom\",\n                    },\n                },\n            })\n        end\n    },\n\n    -- flutter\n    {\n        \"akinsho/flutter-tools.nvim\",\n        event = \"VeryLazy\",\n        dependencies = {\n            \"nvim-lua/plenary.nvim\",\n            \"stevearc/dressing.nvim\",\n        },\n        config = function()\n            require(\"flutter-tools\").setup {\n                flutter_path = nil,\n                flutter_lookup_cmd = \"asdf where flutter\",\n                fvm = false,\n                widget_guides = { enabled = true },\n                lsp = {\n                    settings = {\n                        showtodos = true,\n                        completefunctioncalls = true,\n                        analysisexcludedfolders = {\n                            vim.fn.expand(\"$Home/.pub-cache\"),\n                        },\n                        renamefileswithclasses = \"prompt\",\n                        updateimportsonrename = true,\n                        enablesnippets = false,\n                    },\n                },\n                debugger = {\n                    enabled = true,\n                    run_via_dap = true,\n                    exception_breakpoints = {},\n                    register_configurations = function(paths)\n                        local dap = require(\"dap\")\n                        -- 관련 문서: https://github.com/akinsho/flutter-tools.nvim/pull/292\n                        dap.adapters.dart = {\n                            type = \"executable\",\n                            command = paths.flutter_bin,\n                            args = { \"debug-adapter\" },\n                        }\n                        dap.configurations.dart = {}\n                        require(\"dap.ext.vscode\").load_launchjs()\n                    end,\n                },\n            }\n        end\n    },\r\n```\n\n이 섹션에서 언급된대로, flutter_lookup_command를 asdf 등을 사용할 수 있도록 설정해야 합니다.\n\n디버깅을 위해 nvim-dap을 사용 중이라면, require(\"dap.ext.vscode\").load_launchjs()를 설정하여 .vscode/launch.json의 구성을 참조할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```json\n// .vscode/launch.json\n{\n  \"version\": \"0.0.1\",\n  \"configurations\": [\n    {\n      \"name\": \"개발용 앱 실행\",\n      \"program\": \"${workspaceFolder}/lib/main.dart\",\n      \"request\": \"launch\",\n      \"type\": \"dart\",\n      \"flutterMode\": \"debug\",\n      \"args\": [\n        \"--debug\",\n        \"--flavor\",\n        \"dev\",\n        \"--dart-define-from-file=define/flavor/dev/common.json\",\n        \"--dart-define-from-file=define/flavor/dev/firebase_options.json\"\n      ]\n    },\n    {\n      \"name\": \"운영용 앱 실행\",\n      \"program\": \"${workspaceFolder}/lib/main.dart\",\n      \"request\": \"launch\",\n      \"type\": \"dart\",\n      \"flutterMode\": \"debug\",\n      \"args\": [\n        \"--debug\",\n        \"--flavor\",\n        \"prd\",\n        \"--dart-define-from-file=define/flavor/prd/common.json\",\n        \"--dart-define-from-file=define/flavor/prd/firebase_options.json\"\n      ]\n    }\n  ]\n}\n```\n\n\u003cimg src=\"/assets/img/2024-07-01-FlutterdevelopmentwithNeovim_3.png\" /\u003e\n\n다른 권장하는 Neovim 플러그인\n\n- mini.files\n이것은 파일 탐색기 플러그인입니다. 이전에는 nvim-tree.lua를 사용했지만, 고유한 UI/UX로 인해 mini.files로 전환했습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-07-01-FlutterdevelopmentwithNeovim_4.png\" /\u003e\n\n- no-neck-pain.nvim\n이 플러그인은 버퍼를 화면 가운데에 위치시킵니다. 이 플러그인을 사용함으로써 파일 탐색기를 항상 열어두지 않아도 되는 것을 깨달았고, mini.file 플러그인과 함께 사용하면 더욱 좋습니다.\n- hlchunk.nvim\n이 플러그인은 코드 청크를 동적으로 강조하여 시각적으로 보기 좋고 중첩된 코드 블록을 따르기 쉽게 만듭니다.\n\n\u003cimg src=\"/assets/img/2024-07-01-FlutterdevelopmentwithNeovim_5.png\" /\u003e\n\n이 안내서가 더 많은 Vimmer의 수를 늘리는 데 도움이 되기를 바랍니다. Neovim과 Flutter로 즐거운 코딩하세요!","ogImage":{"url":"/assets/img/2024-07-01-FlutterdevelopmentwithNeovim_0.png"},"coverImage":"/assets/img/2024-07-01-FlutterdevelopmentwithNeovim_0.png","tag":["Tech"],"readingTime":5},{"title":"Fastlane을 사용한 Flutter CDCI 자동화 마스터하기 단계별 가이드","description":"","date":"2024-07-01 17:15","slug":"2024-07-01-MasteringCDCIAutomationinFlutterwithFastlaneAStep-by-StepGuide","content":"\n\n![이미지](/assets/img/2024-07-01-MasteringCDCIAutomationinFlutterwithFastlaneAStep-by-StepGuide_0.png)\n\n안녕하세요!\n\n이번 블로그 포스트에서는 Fastlane 및 이를 통한 모바일 앱 개발의 중요성을 소개하겠습니다. Fastlane을 Flutter 프로젝트에 통합하는 이점을 강조하고, 앱 개발 워크플로우에서 자동화의 중요성을 강조할 것입니다.\n\nFastlane이란 무엇인가요? Fastlane의 핵심 기능을 개요하여 설명하고, 이 도구가 모바일 앱 개발 수명주기에서 작업을 자동화하는 방법에 대해 설명합니다.\n\nFlutter에 Fastlane 통합하는 이유는 무엇인가요? 자동화 도구 없이 Flutter 프로젝트를 관리하는 데 어려움이 있다는 문제와 Fastlane을 Flutter에 통합하여 효율성과 확장성을 높이는 이점을 탐구할 것입니다.\n\n간단하게 소개했지만, 자세한 내용은 블로그 포스트에서 확인해 주세요! 자동화와 효율성에 대한 더 많은 정보가 여러분을 기다리고 있습니다. 함께 공부해요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n시작하기:\n\n- 플러터 프로젝트에 Fastlane 설정하는 단계별 가이드.\n- Fastlane 설치 및 플러터와 함께 사용할 수 있도록 구성하는 방법 안내.\n- 레인, 액션, 플러그인과 같은 필수 Fastlane 구성 요소 소개.\n- 공식 Fastlane 문서\n\n빌드 및 배포 프로세스 자동화:\n- Fastlane이 플랫폼 간 플러터 앱 빌드 및 배포를 어떻게 간소화하는지 시연.\n- 일반 작업(빌드, 테스트, 릴리스 배포 등)에 대한 샘플 Fastfile 구성 쇼케이스.\n- 플러터 프로젝트에 Fastlane 설정하기 위한 코드 스니펫:\n\n```js\n# Ruby gem을 사용하여 Fastlane 설치\n sudo gem install fastlane -NV\n \n # 플러터 프로젝트 디렉토리로 이동\n cd /경로/플러터_프로젝트\n \n # 플러터 프로젝트에서 Fastlane 초기화\n fastlane init\n```\n\n- 플러터 Fastlane 플러그인\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 자동 빌드 및 배포 프로세스를 자동화하기 위한 샘플 Fastfile:\n\n```js\n# Fastfile\n\ndefault_platform(:flutter)\n\nplatform :android do\n  desc \"Android 릴리즈 빌드\"\n  lane :build_android do\n    flutter_build()\n    gradle(task: 'assembleRelease')\n  end\n\n  desc \"Google Play에 배포\"\n  lane :deploy_android do\n    build_android\n    upload_to_play_store(track: 'alpha', release_status: 'draft')\n  end\nend\n\nplatform :ios do\n  desc \"iOS 릴리즈 빌드\"\n  lane :build_ios do\n    flutter_build()\n    gym\n  end\n\n  desc \"App Store에 배포\"\n  lane :deploy_ios do\n    build_ios\n    deliver\n  end\nend\n```\n\n지속적 통합 및 배포 (CI/CD):\n- Fastlane이 Jenkins, Travis CI, GitHub Actions 등 인기있는 CI/CD 서비스와 어떻게 통합되는지 설명합니다.\n- Fastlane을 Flutter 프로젝트의 CI/CD 파이프라인에 통합하는 이점을 설명합니다.\n\n고급 팁과 트릭:\n- Flutter 프로젝트에서 Fastlane 워크플로우를 최적화하는 고급 기술을 공유합니다.\n- 여러 환경 및 사용자 정의 빌드 스크립트와 같은 복잡한 시나리오를 처리하는 팁을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nBest Practices:\n- 효율적이고 깔끔한 Fastlane 환경을 유지하기 위한 최상의 방법을 제공합니다.\n- Fastlane을 Flutter와 함께 사용할 때 오류 처리, 로깅 및 버전 관리 전략을 논의합니다.\n\n결론:\n- 블로그 글에서 다룬 주요 내용을 요약합니다.\n- Fastlane을 Flutter와 통합하는 중요성을 강조하여 앱 개발 워크플로를 효율적으로 만드는 것을 재확인합니다.\n- 독자들에게 Fastlane을 더 탐구하고 그 경험을 커뮤니티와 공유할 것을 격려합니다.\n\n추가 자료:\n- Flutter 문서\n- Fastlane GitHub 저장소\n- Fastlane 액션","ogImage":{"url":"/assets/img/2024-07-01-MasteringCDCIAutomationinFlutterwithFastlaneAStep-by-StepGuide_0.png"},"coverImage":"/assets/img/2024-07-01-MasteringCDCIAutomationinFlutterwithFastlaneAStep-by-StepGuide_0.png","tag":["Tech"],"readingTime":3},{"title":"이미지를 실시간으로 크기 조절하는 방법","description":"","date":"2024-06-30 23:03","slug":"2024-06-30-Resizingimageson-the-fly","content":"\n\n\n![Resizing images on the fly](/assets/img/2024-06-30-Resizingimageson-the-fly_0.png)\n\n웹 아키텍트로서 자산 관리는 많은 문제 중 하나입니다. 그리고 자산 중에서도 가장 중요한 문제는 이미지입니다. 하나의 단순한 접근 방식은 이미지를 설정하고 브라우저가 CSS를 통해 이미지를 크기 조정하도록 하는 것입니다:\n\n```css\nimg {\n    height: 100%;\n    width: 100%;\n    object-fit: contain;\n}\n```\n\n하지만 이는 원본 이미지를 다운로드한다는 뜻입니다. 이로써 원본 이미지의 크기와 최적화되지 않은 브라우저 기반 크기 조정 두 가지 문제가 발생합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 포스트에서는 두 가지 대안을 다룹니다: 전통적인 방법과 새로운 솔루션.\n\n# 미리 크기 조정하기\n\n단일 이미지 원본에 대한 전통적인 솔루션은 미리 크기를 조정하는 것이었습니다. 출시하기 전에 디자이너들은 다양한 해상도의 여러 이미지 버전을 제공하는 데 시간을 할애했습니다. 이 블로그에서는 이 기술을 사용하고 있습니다. 포스트의 주 이미지를 다양한 맥락에서 백그라운드 이미지로 표시하기 위해 세 가지 해상도를 제공합니다:\n\n- 페이지의 포스트용 큰 크기\n- 홈페이지의 포스트용 중간 크기\n- 포스트 페이지에서 관련 포스트용 작은 크기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저는 더 높은 용량 감소를 위해 JPEG 메타데이터도 제거합니다.\n\n하지만 전통적인 방식은 HTML picture 태그를 활용하는 것입니다:\n\n그리고 다음과 같이 사용할 수 있습니다:\n\n```js\n\u003cpicture\u003e\n    \u003csource media=\"(max-width: 199px)\" srcset=\"ai-generated-200.jpg\" /\u003e\n    \u003csource media=\"(max-width: 399px)\" srcset=\"ai-generated-400.jpg\" /\u003e\n    \u003csource media=\"(max-width: 599px)\" srcset=\"ai-generated-600.jpg\" /\u003e\n    \u003csource media=\"(max-width: 799px)\" srcset=\"ai-generated-800.jpg\" /\u003e\n    \u003csource media=\"(max-width: 999px)\" srcset=\"ai-generated-1000.jpg\" /\u003e\n    \u003cimg src=\"ai-generated.jpg\" /\u003e\n\u003c/picture\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 방식은 오랫동안 잘 작동했지만 두 가지 문제가 있습니다. 먼저, 각 이미지에 대해 여러 해상도를 제공하는 작업은 시간이 많이 소요됩니다. 이를 자동화하여 AI를 사용하면 좋은 결과를 얻을 수 있습니다.\n\n그러나 필요한 저장 용량은 추가로 생성된 해상도의 수에 따라 원본 이미지의 두배 또는 세배가 될 수 있습니다. 자산이 풍부한 환경에서 예를 들어 전자 상거래와 같은 경우 비용이 크게 증가할 수 있습니다.\n\n# 실시간 크기 조정\n\n최근에 imgproxy라는 이미지 크기를 실시간으로 조정하는 구성 요소를 우연히 발견했습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nimgproxy는 다음을 정의하는 인코딩된 URL을 보낼 수 있는 엔드포인트를 제공합니다:\n- 변경할 이미지와 위치(로컬, HTTP URL, S3 버킷 등)\n- 다양한 크기 조정 매개변수, 예를 들어, 차원, 맞출지 채울지 여부 등\n- 형식. imgproxy는 JPEG 및 PNG과 같은 표준 형식을 지원하지만 WebP 및 AVIF와 같은 더 현대적인 형식도 지원합니다. 또한 'Accept' 헤더에 따라 최적의 형식을 선택할 수 있습니다.\n- 워터마킹, 필터링, 회전 등 많은(정말 많은!) 다른 옵션들\n\nimgproxy는 오픈 소스 무료 버전과 유료 버전을 제공합니다. 이 포스트에 포함된 모든 내용은 전자의 일부입니다.\n\n한 가지 해결책은 웹 개발자가 HTML에 각 imgproxy URL을 직접 코딩하는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\u003cpicture\u003e\n    \u003csource media=\"(max-width: 199px)\" srcset=\"http://imgproxy:8080//rs:fill/w:200/plain/http://server:3000/ai-generated.jpg@webp\" /\u003e\n    \u003csource media=\"(max-width: 399px)\" srcset=\"http://imgproxy:8080//rs:fill/w:400/plain/http://server:3000/ai-generated.jpg@webp\" /\u003e\n    \u003csource media=\"(max-width: 599px)\" srcset=\"http://imgproxy:8080//rs:fill/w:600/plain/http://server:3000/ai-generated.jpg@webp\" /\u003e\n    \u003csource media=\"(max-width: 799px)\" srcset=\"http://imgproxy:8080//rs:fill/w:800/plain/http://server:3000/ai-generated.jpg@webp\" /\u003e\n    \u003csource media=\"(max-width: 999px)\" srcset=\"http://imgproxy:8080//rs:fill/w:1000/plain/http://server:3000/ai-generated.jpg@webp\" /\u003e\n    \u003cimg src=\"ai-generated.jpg\" /\u003e\n\u003c/picture\u003e\n\n\n웹 페이지에 대한 토폴로지 관련 세부 정보가 노출됩니다. 이는 유지 관리하기 어려운 해결책입니다. 리버스 프록시나 API 게이트웨이를 사용하여 문제를 해결할 수 있습니다. 명백한 이유로 Apache APISIX를 사용하겠습니다.\n\n이 방법을 통해 위의 HTML이 훨씬 간단해집니다:\n\n\n\u003cpicture\u003e\n    \u003csource media=\"(max-width: 199px)\" srcset=\"/resize/200/ai-generated.jpg\" /\u003e\n    \u003csource media=\"(max-width: 399px)\" srcset=\"/resize/400/ai-generated.jpg\" /\u003e\n    \u003csource media=\"(max-width: 599px)\" srcset=\"/resize/600/ai-generated.jpg\" /\u003e\n    \u003csource media=\"(max-width: 799px)\" srcset=\"/resize/800/ai-generated.jpg\" /\u003e\n    \u003csource media=\"(max-width: 999px)\" srcset=\"/resize/1000/ai-generated.jpg\" /\u003e\n    \u003cimg src=\"ai-generated.jpg\" /\u003e\n\u003c/picture\u003e\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nApache APISIX은 /resize로 시작하는 요청을 가로채어 URL을 imgproxy로 재작성하여 imgproxy에 재작성된 URL을 전달합니다. 전체 흐름은 다음과 같습니다:\n\n![image](/assets/img/2024-06-30-Resizingimageson-the-fly_1.png)\n\n해당 Apache APISIX 구성은 다음과 같습니다:\n\n```js\nroutes:\n  - uri: /resize/*\n    plugins:\n      proxy-rewrite:\n        regex_uri:\n          - /resize/(.*)/(.*)\n          - /rs:fill/w:$1/plain/http://server:3000/$2@webp\n    upstream:\n      nodes:\n        \"imgproxy:8080\": 1\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- **/resize**로 시작하는 요청 일치시키기\n- URL 다시 작성\n- 정규 표현식에서 너비와 이미지 캡처\n- 이미지 프록시를 위한 URL 형식화. http://server:3000은 원본 이미지를 호스팅하는 서버이며, @webp은 브라우저가 지원하는 경우 WebP 형식을 선호함을 나타냄\n\n위와 같이, Apache APISIX에게서 **/resize/200/ai-generated.jpg**를 받으면 imgproxy에서 **/rs:fill/w:200/plain/http://server:3000/ai-generated.jpg@webp**로 다시 작성됩니다.\n\n# 테스트\n\nDocker Compose를 사용하여 작은 테스트 샘플을 설정할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```yaml\nservices:\n  apisix:\n    image: apache/apisix:3.5.0-debian\n    volumes:\n      - ./apisix/config.yml:/usr/local/apisix/conf/config.yaml:ro\n      - ./apisix/apisix.yml:/usr/local/apisix/conf/apisix.yaml:ro\n    ports:\n      - \"9080:9080\"\n  imgproxy:\n    image: darthsim/imgproxy:v3.19\n  server:                                                         #1\n    build: content\n```\n\n- HTML 및 주 이미지를 호스팅하는 간단한 웹 서버\n\n이제 위 설정을 브라우저의 개발자 도구를 사용하여 테스트할 수 있습니다. 작은 화면 장치인 iPhone SE를 흉내 내는 것입니다. 결과는 다음과 같습니다:\n\n\u003cimg src=\"/assets/img/2024-06-30-Resizingimageson-the-fly_2.png\" /\u003e\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 화면 해상도 때문에 요청된 이미지는 원본 이미지가 아닌 400px 폭 이미지입니다. 요청 URL에서 확인할 수 있어요.\n- 반환된 이미지는 WebP 형식이며, 용량은 14.4kb입니다.\n- 원본 JPEG 이미지는 154kb로, 10배나 더 많은 용량을 차지합니다. 네트워크 대역폭을 아주 많이 절약하는 것이죠!\n\n# 토론\n\n저장 비용을 10배 줄이는 것은 당연히 큰 이점입니다. 하지만 모든 것이 완벽한 것은 아닙니다. 이미지 크기를 조정하는 것은 계산에 많은 비용이 드는 작업이에요. 각 요청마다 CPU 시간이 소요됩니다. 또한 imgproxy가 얼마나 효율적이든 이미지 생성에는 시간이 걸립니다. 우리는 저장 비용을 CPU 비용으로 교환하고, 결과적으로 성능에 약간의 저하가 발생합니다.\n\n이를 해결하려면 앞 단에 캐싱 레이어가 필요합니다. 커스텀 캐싱이나 더 가능한 CDN 등을 사용할 수 있어요. 자산을 다시 저장할 것이라는 이의가 있을 수 있습니다. 따라서 저장 비용이 다시 증가할 거라는 거죠. 그러나 캐시는 사용된 이미지에만 작동하며, 이전 솔루션에서는 모든 이미지를 저장하기 위해 비용을 지불했습니다. 이외에도, 이미지가 필요한 경우에 캐시를 미리 로딩하는 등 캐싱에 대한 이미 알려진 레시피를 적용할 수도 있어요. 예를 들어, 이벤트 전에 필요한 이미지 그룹을 미리 로딩하는 것 등이죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n이 게시물에서는 Apache APISIX와 imgproxy를 사용하여 여러 해상도의 이미지 저장 비용을 줄이는 방법을 설명했습니다. 캐싱을 추가하면 전체 아키텍처에 더 많은 구성 요소가 추가되지만 저장 비용이 줄어듭니다.\n\n이 게시물은 Andreas Lehr의 StackConf 발표에서 영감을 받았습니다.\n\n이 게시물의 전체 소스 코드는 GitHub에서 찾을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더 알아보기:\n\n- imgproxy 문서\n- imgproxy 인터랙티브 데모\n\n2023년 10월 1일에 A Java Geek에서 처음 발행되었습니다.","ogImage":{"url":"/assets/img/2024-06-30-Resizingimageson-the-fly_0.png"},"coverImage":"/assets/img/2024-06-30-Resizingimageson-the-fly_0.png","tag":["Tech"],"readingTime":6},{"title":"Flask, MongoDB, 그리고 React로 실시간 GitHub Webhook 리스너 만드는 방법","description":"","date":"2024-06-30 23:02","slug":"2024-06-30-BuildingaReal-TimeGitHubWebhookListenerwithFlaskMongoDBandReact","content":"\n\n본 기사에서는 \"Push\", \"Pull Request\", \"Merge\"와 같은 GitHub 웹훅을 수신하는 프로젝트를 만드는 방법을 안내하겠습니다. 이러한 이벤트를 Flask 애플리케이션에서 캡처하고 MongoDB에 저장하며, React 프론트엔드를 사용하여 실시간으로 표시할 것입니다. 마지막으로 Flask 앱을 Vercel에 배포해 보겠습니다.\n\n# 배울 내용\n\n- GitHub 웹훅 설정하는 방법\n- 웹훅을 처리하기 위한 Flask 애플리케이션 만드는 방법\n- 웹훅 데이터를 MongoDB에 저장하는 방법\n- 실시간 업데이트를 표시하는 React 애플리케이션 만드는 방법\n- Flask 애플리케이션을 Vercel에 배포하는 방법\n\n# 준비물\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Python, Flask 및 React에 대한 기본 지식\n- GitHub 계정\n- 로컬에 MongoDB 설치 또는 클라우드 MongoDB 서비스\n- Node.js 및 npm 설치\n- Vercel 계정\n\n## 단계 1: GitHub Webhook 설정\n\n- GitHub 저장소 설정\n\nGitHub에서 새 저장소를 만듭니다.\n\nGitHub에서 action-repo라는 새 저장소를 만듭니다. 이 저장소는 \"Push\", \"Pull Request\", \"Merge\"와 같은 이벤트에 기반하여 웹훅을 트리거합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 웹훅 추가하기\n\n- GitHub의 작업 리포지토리로 이동합니다.\n- 설정에서 웹훅(Webhooks)으로 이동합니다.\n- 웹훅 추가를 클릭합니다.\n- 페이로드 URL을 Flask 앱의 엔드포인트로 설정합니다 (나중에 이를 설정할 예정입니다).\n- 컨텐츠 유형을 application/json으로 설정합니다.\n- 개별 이벤트를 선택하도록 \"푸쉬(Push)\", \"풀 리퀘스트(Pull Request)\", \"병합(Merge)\" 이벤트를 선택합니다.\n- 웹훅 추가를 클릭합니다.\n\n# 단계 2: Flask 애플리케이션 생성\n\n- 프로젝트 초기화\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플라스크 프로젝트를 위한 webhook-repo라는 디렉토리를 만들어보세요.\n\n```js\nmkdir webhook-repo\ncd webhook-repo\npython3 -m venv venv\nsource venv/bin/activate\npip install Flask pymongo\n```\n\n2. Flask 앱 만들기\n\nwebhook-repo 디렉토리에 다음 코드를 사용하여 app.py를 만들어보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\nfrom flask import Flask, request, jsonify\nfrom pymongo import MongoClient\nfrom datetime import datetime\n\napp = Flask(__name__)\n\n# MongoDB 연결\nclient = MongoClient('mongodb://localhost:27017/')\ndb = client['github_webhooks']\ncollection = db['events']\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    data = request.json\n    event_type = request.headers.get('X-GitHub-Event')\n    \n    if event_type == 'push':\n        author = data['pusher']['name']\n        to_branch = data['ref'].split('/')[-1]\n        timestamp = datetime.strptime(data['head_commit']['timestamp'], \"%Y-%m-%dT%H:%M:%SZ\")\n        event_data = {\n            \"type\": \"push\",\n            \"author\": author,\n            \"to_branch\": to_branch,\n            \"timestamp\": timestamp\n        }\n    elif event_type == 'pull_request':\n        author = data['pull_request']['user']['login']\n        from_branch = data['pull_request']['head']['ref']\n        to_branch = data['pull_request']['base']['ref']\n        timestamp = datetime.strptime(data['pull_request']['created_at'], \"%Y-%m-%dT%H:%M:%SZ\")\n        event_data = {\n            \"type\": \"pull_request\",\n            \"author\": author,\n            \"from_branch\": from_branch,\n            \"to_branch\": to_branch,\n            \"timestamp\": timestamp\n        }\n    elif event_type == 'pull_request' and data['pull_request']['merged']:\n        author = data['pull_request']['user']['login']\n        from_branch = data['pull_request']['head']['ref']\n        to_branch = data['pull_request']['base']['ref']\n        timestamp = datetime.strptime(data['pull_request']['merged_at'], \"%Y-%m-%dT%H:%M:%SZ\")\n        event_data = {\n            \"type\": \"merge\",\n            \"author\": author,\n            \"from_branch\": from_branch,\n            \"to_branch\": to_branch,\n            \"timestamp\": timestamp\n        }\n    else:\n        return jsonify({'message': '지원되지 않는 이벤트입니다'}), 400\n\n    collection.insert_one(event_data)\n    return jsonify({'message': '이벤트가 수신되었습니다'}), 200\n\n@app.route('/events', methods=['GET'])\ndef get_events():\n    events = list(collection.find().sort(\"timestamp\", -1).limit(10))\n    for event in events:\n        event['_id'] = str(event['_id'])\n    return jsonify(events), 200\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=5000)\n```\n\n3. requirements.txt 파일 생성\n\n필요한 의존성이 명시된 requirements.txt 파일을 만들어주세요:\n\n```python\nFlask\npymongo\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 단계 3: Vercel에 Flask 앱 배포하기\n\n- vercel.json 파일 만들기\n\nvercel.json 설정 파일을 만듭니다:\n\n```js\n{\n  \"version\": 2,\n  \"builds\": [\n    {\n      \"src\": \"app.py\",\n      \"use\": \"@vercel/python\"\n    }\n  ],\n  \"routes\": [\n    {\n      \"src\": \"/(.*)\",\n      \"dest\": \"app.py\"\n    }\n  ]\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. Vercel에 배포하기\n\n- Vercel CLI 설치하기: npm install -g vercel\n- Vercel에 로그인하기: vercel login\n- 프로젝트를 배포하기: vercel\n\n# 단계 4: React 프론트엔드 생성\n\n- React 앱 설정하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nReact 애플리케이션을 새로 만들어 보세요:\n\n```js\nnpx create-react-app github-webhooks-ui\ncd github-webhooks-ui\nnpm install axios\n```\n\n2. App.js 파일을 만들어 보세요\n\nApp.js 파일 내용을 다음과 같이 변경해 주세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport React, { useState, useEffect } from 'react';\nimport axios from 'axios';\nimport './App.css';\n\nconst App = () =\u003e {\n  const [events, setEvents] = useState([]);\n\n  useEffect(() =\u003e {\n    const fetchEvents = async () =\u003e {\n      try {\n        const response = await axios.get('https://your-vercel-app.vercel.app/events');\n        setEvents(response.data);\n      } catch (error) {\n        console.error('Error fetching events', error);\n      }\n    };\n\n    fetchEvents();\n    const interval = setInterval(fetchEvents, 15000);\n    return () =\u003e clearInterval(interval);\n  }, []);\n\n  return (\n    \u003cdiv className=\"App\"\u003e\n      \u003ch1\u003eGitHub Repository Events\u003c/h1\u003e\n      \u003cul\u003e\n        {events.map(event =\u003e (\n          \u003cli key={event._id}\u003e\n            {event.type === 'push' \u0026\u0026 `${event.author} pushed to ${event.to_branch} on ${new Date(event.timestamp).toUTCString()}`}\n            {event.type === 'pull_request' \u0026\u0026 `${event.author} submitted a pull request from ${event.from_branch} to ${event.to_branch} on ${new Date(event.timestamp).toUTCString()}`}\n            {event.type === 'merge' \u0026\u0026 `${event.author} merged branch ${event.from_branch} to ${event.to_branch} on ${new Date(event.timestamp).toUTCString()}`}\n          \u003c/li\u003e\n        ))}\n      \u003c/ul\u003e\n    \u003c/div\u003e\n  );\n};\n\nexport default App;\n```\n\n3. React 앱 실행\n\nReact 애플리케이션을 시작하려면:\n\n```js\nnpm start\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 테스트 및 확인\n\n- GitHub 웹훅 업데이트:\n\nGitHub 웹훅 설정에서 Payload URL을 배포된 Vercel의 Flask 앱을 가리키도록 업데이트하십시오:\n\n```js\nhttps://your-vercel-app.vercel.app/webhook\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 트리거 이벤트:\n\n- Push Action: 변경 사항을 만들어서 action-repo에 푸시합니다.\n- Pull Request Action: 새 브랜치를 만들어서 변경 사항을 적용하고 푸시한 다음 풀 리퀘스트를 오픈합니다.\n- Merge Action: 풀 리퀘스트를 병합합니다.\n\n3. 확인: React 앱을 확인해서 이벤트가 올바르게 표시되는지 확인해보세요.\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 프로젝트에서는 다음을 배웠습니다:\n\n- GitHub 웹훅 설정 및 처리 방법\n- 웹훅 이벤트를 처리하는 Flask 애플리케이션 생성\n- MongoDB에 이벤트 저장\n- React 프론트엔드를 사용하여 실시간 이벤트 표시\n- Vercel에 Flask 애플리케이션 배포\n\n이 프로젝트는 다양한 기술을 통합하여 실시간 업데이트를 효율적으로 처리하는 풀 스택 애플리케이션을 보여줍니다. 궁금한 점이나 개선하고 싶은 부분이 있으면 인증, 추가적인 이벤트 유형 또는 더 다양하고 진보된 UI 요소를 추가하여 이 프로젝트를 확장해보세요.\n\n즐거운 코딩되세요!","ogImage":{"url":"/assets/img/2024-06-30-BuildingaReal-TimeGitHubWebhookListenerwithFlaskMongoDBandReact_0.png"},"coverImage":"/assets/img/2024-06-30-BuildingaReal-TimeGitHubWebhookListenerwithFlaskMongoDBandReact_0.png","tag":["Tech"],"readingTime":7},{"title":"25개월 휴식 후 코딩한 앱, 정말 멋진 결과물","description":"","date":"2024-06-30 23:00","slug":"2024-06-30-Icodedanappafter25MONTH-BREAKanditactuallylookscool","content":"\n\n## 플러터를 사용한 심플한 룩의 날씨 앱 (소스 코드 제공 가능)\n\n![이미지](/assets/img/2024-06-30-Icodedanappafter25MONTH-BREAKanditactuallylookscool_0.png)\n\n코딩 피로를 극복하기 위해 다양한 기술과 분야를 탐험한 후, 2.5개월 만에 코딩으로 돌아오기로 결정했습니다. 제 목표는 간단하지만 동시에 멋지게 보이는 것을 만드는 것이었습니다. 그래서 무엇을 만들었을까요? 날씨 앱입니다. 알아요, 기본적인 것 같긴 하지만, 제 오프닝을 할 수 있는 무언가를 만들어야 했고 그래서 날씨 앱을 만들기로 했습니다. 쉽고, 동시에 유용한 것을 만든 만족감을 주거든요.\n\n인도의 온도가 50도 이상으로 치솟고 있어 모든 이들의 눈은 뉴스 채널과 날씨 앱에 집중되어 있어 앱을 만드는 것이 완벽한 시기라고 생각했습니다. 더 좋은 디자인을 위해 더 많이 나아갔으며, 색상은 더욱 간소하고 단어는 더욱 줄이기로 했습니다. 그래서 Figma를 열어 (몇 달 만에), UI를 디자인하기 시작했고, 어떻게든 꽤 괜찮아 보였습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-30-Icodedanappafter25MONTH-BREAKanditactuallylookscool_1.png\" /\u003e\n\n그래서, 이게 제가 디자인한 거에요. 가능한 한 간단하게 만들려고 노력했어요. 색상도 없고 멋진 건 없어요. 괜찮음이 최고죠!\n\n## 코딩 부분 :\n\n이제 어려운 부분이 시작됐습니다 (그렇게 어렵지는 않아요. 그냥 날씨 앱이거든요. 유튜브에 수백 개의 자습서를 찾을 수 있을 거에요) — 코딩이죠. 빠른 조언: 앱을 만드는 게 목표라면, 워크플로부터 시작해보세요. 멋진 걸 하려 할 필요는 없어요; 종이 한 장 가지고 무엇을 만들 계획 중인지 적어보세요. 항상 완전한 앱을 고려해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어 전자 상거래 앱을 고려해보세요. 기본 레이아웃은 무엇이어야 할까요?\n\n- 홈페이지\n- 다양한 제품 및 카테고리 검색 화면\n- 제품 상세 화면\n- 장바구니 화면\n- 주문 완료 화면\n\n물론, 이 외에도 많은 요소가 있지만, 이렇게 계획을 세우면 앱 시작부터 끝까지의 고정된 개발 방향을 얻을 수 있습니다. 이 방법이 저에게 효과적으로 작동했어요. 프로젝트가 완전히 계획되지 않았을 때 저를 괴롭히고 미루게 만던 일이 많았거든요. 이 기본적인 날씨 앱의 경우, 별도의 워크플로를 설계할 필요가 없었습니다.\n\n## 이 프로젝트를 다음과 같이 나누어 봅시다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n내가 하는 일은 Figma 디자인과 유사한 앱의 완전한 UI를 구축한 다음 서비스 및 API 부분으로 넘어가는 것이에요. 그 다음에는 다양한 애니메이션을 시도해보죠. Figma에서 디자인하고 다양한 애니메이션을 시도할 필요는 없어요. 그렇게 하면 시간이 많이 소요될 수 있어요. 대신, 앱이 제대로 작동한 후에 코드로 직접 애니메이션을 시도해보세요. 다시 한 번 강조하지만, 애니메이션에 너무 신경 쓸 필요는 없어요. 저는 단지 애니메이션을 위해 animate 패키지를 사용했죠.\n\n그리고 한 가지 더: 의존성 및 패키지는 생명 구원자들이에요. 특히 학습 단계에서는 주저하지 말고 사용하세요.\n\n## API 부분은 즐거워요 :\n\n한 번 앱에 API를 구현하면 멈출 수가 없어요. API와 모델/서비스에 익숙해지기 시작하면 실제로 앱 개발을 즐기기 시작할 거예요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 실제 코드 :\n\n의존성: 제가 사용한 종속성들입니다.\n\n![2024-06-30-Icodedanappafter25MONTH-BREAKanditactuallylookscool_2](/assets/img/2024-06-30-Icodedanappafter25MONTH-BREAKanditactuallylookscool_2.png)\n\n이 앱의 핵심 - `WeatherData services class page`입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport 'dart:convert';\n\nimport 'package:basicweatherapp/constants.dart';\nimport 'package:geocoding/geocoding.dart';\nimport 'package:geolocator/geolocator.dart';\nimport 'package:http/http.dart' as https;\n\nclass WeatherData {\n  String? cityname;\n  static const base_url = \"http://api.openweathermap.org/data/2.5/weather\";\n  Position? data;\n  \n  // 현재 위치의 도시 이름을 반환하는 메서드\n  Future\u003cString\u003e getcurrentcity() async {\n    // 위치 권한 요청\n    LocationPermission permission = await Geolocator.requestPermission();\n    if (permission == LocationPermission.denied) {\n      await Geolocator.requestPermission();\n    }\n    \n    // 현재 위치의 위도와 경도 데이터를 가져옴\n    Position position = await Geolocator.getCurrentPosition(\n        desiredAccuracy: LocationAccuracy.high);\n\n    // 위도와 경도 정보를 기반으로 현재 도시를 가져옴\n    List\u003cPlacemark\u003e placemark =\n        await placemarkFromCoordinates(position.latitude, position.longitude);\n    String? city = placemark[0].locality ?? \"Bahraich\";\n    return city;\n  }\n\n  // 도시를 기반으로 날씨 데이터 반환\n  Future getWeatherReport(String city) async {\n    // API를 호출하여 날씨 데이터 가져오기\n    https.Response response =\n        await https.get(Uri.parse(\"$base_url?q=$city\u0026appid=$api\u0026units=metric\"));\n    if (response.statusCode == 200) {\n      var data = jsonDecode(response.body);\n      return data;\n    } \n    else {\n      throw Exception(\"날씨 데이터를 불러오는 데 실패했습니다\");\n    }\n  }\n}\n```\n\n모델을 사용하지 않았지만 이해를 돕기 위해 간단하게 작성했습니다.\n\nAPI를 성공적으로 호출할 때 데이터가 어떻게 보이는지 예시입니다. 맵과 리스트에 대한 이해가 있으면 이해하기 쉬울 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기능 및 메소드: 이 앱에서 사용한 총 5개의 메소드에 대한 설명이 제대로 주석으로 달려 있습니다(전체 코드는 게시물의 뒷부분에 제공됩니다). 이러한 메소드는 홈 화면에서 사용됩니다.\n\n![이미지](/assets/img/2024-06-30-Icodedanappafter25MONTH-BREAKanditactuallylookscool_3.png)\n\n홈 화면 코드:\n\n처음에는 코드가 복잡해 보일 수 있지만 전체 코드를 읽으면 모든 것을 이해할 수 있을 건데요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport 'package:basicweatherapp/constants.dart';\nimport 'package:basicweatherapp/networkErrorPage.dart';\n\nimport 'package:basicweatherapp/weatherdata.dart';\nimport 'package:basicweatherapp/widgets/Drawercontent.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter_animate/flutter_animate.dart';\n\nclass HomePage extends StatefulWidget {\n  const HomePage({super.key});\n\n  @override\n  State\u003cHomePage\u003e createState() =\u003e _HomePageState();\n}\n\nclass _HomePageState extends State\u003cHomePage\u003e {\n  TextEditingController citycontroller = TextEditingController();\n  WeatherData weatherData = WeatherData();\n\n  String? city;\n  double? temp;\n  String? condition;\n  String? country;\n  bool isLoading = true; // 이 상태 변수를 추가했어요\n\n// 현재 위치 도시 날씨 데이터를 가져오기\n  void fetchData() async {\n    setState(() {\n      isLoading = true; // 데이터를 가져오기 시작할 때 로딩을 true로 설정해줘요\n    });\n\n    String cityname = await weatherData.getcurrentcity();\n\n    try {\n      final weather = await weatherData.getWeatherReport(cityname);\n      setState(() {\n        city = weather[\"name\"];\n        temp = weather[\"main\"][\"temp\"];\n        condition = weather[\"weather\"][0][\"main\"];\n        country = weather[\"sys\"][\"country\"];\n        isLoading = false; // 데이터를 가져온 후에 로딩을 false로 설정해줘요\n      });\n    } catch (e) {\n      setState(() {\n        isLoading = false; // 에러가 발생해도 로딩을 false로 설정해줘요\n      });\n      Navigator.push(\n        context,\n        MaterialPageRoute(\n          builder: (context) =\u003e NetworkErrorPage(\n            retryCallback: fetchData,\n          ),\n        ),\n      );\n    }\n  }\n\n// 특정 도시 날씨 데이터 가져오기\n  void getCityData(String searchCity) async {\n    setState(() {\n      isLoading = true; // 데이터를 가져오기 시작할 때 로딩을 true로 설정해줘요\n    });\n\n    try {\n      final weather = await weatherData.getWeatherReport(searchCity);\n      setState(() {\n        city = weather[\"name\"];\n        temp = weather[\"main\"][\"temp\"];\n        condition = weather[\"weather\"][0][\"main\"];\n        country = weather[\"sys\"][\"country\"];\n        isLoading = false; // 데이터를 가져온 후에 로딩을 false로 설정해줘요\n      });\n    } catch (e) {\n      setState(() {\n        isLoading = false;\n\n        Navigator.push(\n          context,\n          MaterialPageRoute(\n            builder: (context) =\u003e NetworkErrorPage(\n              retryCallback: fetchData,\n            ),\n          ),\n        );\n      });\n    }\n  }\n\n// 다른 온도 범위에 따라 다른 메시지를 표시해주는 메소드\n  String getWeatherMessage(double? temp) {\n    if (temp == null) return \"로딩 중...\";\n\n    if (temp \u003c= 0) {\n      return \"추워요... 따뜻하게 입으세요!\";\n    } else if (temp \u003e 0 \u0026\u0026 temp \u003c= 10) {\n      return \"쌀쌀해요. 자켓을 입어요!\";\n    } else if (temp \u003e 10 \u0026\u0026 temp \u003c= 20) {\n      return \"시원한 날씨에요. 신선한 공기를 즐기세요!\";\n    } else if (temp \u003e 20 \u0026\u0026 temp \u003c= 30) {\n      return \"따뜻하고 쾌적해요. 야외 활동하기 딱 좋아요!\";\n    } else if (temp \u003e 30 \u0026\u0026 temp \u003c= 40) {\n      return \"더워요. 수분을 보충하세요!\";\n    } else {\n      return \"극심한 더위! 주의를 기울이고 시원하게 지내세요.\";\n    }\n  }\n\n// 이 메소드는 \"메인 날씨 조건\"에 따라 다른 \"이미지 경로\"를 문자열로 반환해줘요\n  String getWeatherIcon(String? maincondition) {\n    if (maincondition == null) return \"images/sunny.png\";\n\n    switch (maincondition.toLowerCase()) {\n      case \"clouds\":\n      case \"fog\":\n      case \"dust\":\n      case \"mist\":\n      case \"haze\":\n        return \"images/clouds.png\";\n\n      case \"rain\":\n      case \"drizzle\":\n      case \"shower rain\":\n        return \"images/rain.png\";\n\n      case \"thunderstand\":\n        return \"images/thunderstorm.png\";\n\n      case \"clear\":\n        return \"images/sunny.png\";\n\n      default:\n        return \"images/sunny.png\";\n    }\n  }\n\n  WeatherData data = WeatherData();\n\n  @override\n  void initState() {\n    // TODO: implement initState\n    super.initState();\n    fetchData();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    Size size = MediaQuery.of(context).size;\n    return Scaffold(\n      drawer: Drawer(\n        child: DrawerContent(),\n        width: size.width * 0.5,\n      ).animate().fadeIn(duration: 1.seconds),\n      appBar: AppBar(\n        actions: [\n          Padding(\n            padding: EdgeInsets.only(right: 10),\n            child: InkWell(\n              onTap: () {\n                fetchData();\n              },\n              child: Icon(\n                Icons.location_on_outlined,\n                size: 30,\n              ).animate().fadeIn(duration: 1.seconds),\n            ),\n          )\n        ],\n      ),\n      body: isLoading ? buildLoadingIndicator() : showUi(),\n    );\n  }\n\n  Widget buildLoadingIndicator() {\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          Text(\n            \"날씨 데이터를 불러오는 중..\",\n            style: TextStyle(\n              fontSize: 20,\n              fontWeight: FontWeight.w300,\n            ),\n          ),\n          SizedBox(\n            height: 10,\n          ),\n          CircularProgressIndicator(\n            color: Colors.black,\n            strokeWidth: 1.5,\n          )\n        ],\n      ),\n    );\n  }\n\n  Widget showUi() {\n    Size size = MediaQuery.of(context).size;\n    return Padding(\n      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),\n      child: SingleChildScrollView(\n        child: Column(\n          children: [\n            SizedBox(\n              height: 15,\n            ),\n            Image.asset(\"images/city.png\")\n                .animate()\n                .fadeIn(duration: 1.seconds),\n            SizedBox(\n              height: 10,\n            ),\n            Text(\n              city ?? \"\",\n              style: TextStyle(\n                fontSize: 25,\n                fontWeight: FontWeight.w300,\n              ),\n            ).animate().fadeIn(duration: 1.seconds),\n            Text(\n              country ?? \" \",\n              style: TextStyle(\n                fontSize: 15,\n                fontStyle: FontStyle.italic,\n                fontWeight: FontWeight.w300,\n              ),\n            ).animate().fadeIn(duration: 1.seconds),\n            SizedBox(\n              height: 15,\n            ),\n            Row(\n              children: [\n                Padding(\n                  padding: EdgeInsets.only(left: 20),\n                  child: Image.asset(\n                    getWeatherIcon(condition),\n                  ).animate().fadeIn(duration: 1.seconds),\n                ),\n                SizedBox(width: 40),\n                Column(\n                  children: [\n                    Row(\n                      children: [\n                        Text(\n                          temp?.toString() ?? \" \",\n            style: style,\n                        ).animate().fadeIn(duration: 1.seconds),\n                        Text(\n                          \" °C\",\n            style: style,\n                        ).animate().fadeIn(duration: 1.seconds),\n                      ],\n                    ),\n                    Text(\n                      condition ?? \" \",\n                      style: const TextStyle(\n                        fontSize: 15,\n                        fontStyle: FontStyle.italic,\n                        fontWeight: FontWeight.w300,\n                      ),\n                    ).animate().fadeIn(duration: 1.seconds),\n                  ],\n                ),\n              ],\n            ),\n            SizedBox(\n              height: size.height * 0.12,\n            ),\n            Text(\n              getWeatherMessage(temp),\n              style: TextStyle(\n                fontSize: 25,\n                fontWeight: FontWeight.w300,\n              ),\n            ).animate().fadeIn(duration: 1.seconds).then(delay: 1000.ms).slide(),\n            SizedBox(height: size.height * 0.06),\n            Image.asset(\"images/cities.png\").animate().fadeIn(duration: 1.seconds),\n            SizedBox(height: size.height * 0.07),\n            InkWell(\n              onTap: onTap,\n              child: Hero(\n                tag: \"search\",\n                child: Image.asset(\"images/search.png\"),\n              ),\n            ),\n            SizedBox(height: 5),\n            GestureDetector(\n              onTap: onTap,\n              child: Text(\n                '다른 도시 찾기',\n                style: TextStyle(\n                  fontSize: 20,\n                  fontStyle: FontStyle.italic,\n                  fontWeight: FontWeight.w300,\n                ),\n              ).animate().fadeIn(duration: 1.seconds),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n// 이 메소드는 다른 도시를 검색하기 위해 bottomModelSheet를 열어줘요.\n  void onTap() {\n    showModalBottomSheet(\n      context: context,\n      builder: (context) {\n        return SingleChildScrollView(\n          keyboardDismissBehavior: ScrollViewKeyboardDismissBehavior.onDrag,\n          child: Column(\n            children: [\n              SizedBox(\n                height: 40,\n              ),\n              Padding(\n                padding: EdgeInsets.symmetric(horizontal: 30),\n                child: TextField(\n                  controller: citycontroller,\n                  decoration: InputDecoration(\n                    hintStyle: TextStyle(\n                      color:","ogImage":{"url":"/assets/img/2024-06-30-Icodedanappafter25MONTH-BREAKanditactuallylookscool_0.png"},"coverImage":"/assets/img/2024-06-30-Icodedanappafter25MONTH-BREAKanditactuallylookscool_0.png","tag":["Tech"],"readingTime":13},{"title":"플러터 ToDo 애플리케이션 파트 1 인프라설정 방법","description":"","date":"2024-06-30 22:59","slug":"2024-06-30-FlutterToDoapplicationPart1Infrastructure","content":"\n\n이 시리즈의 기사에서는 Flutter를 활용하여 ToDo 애플리케이션을 만들고 여러 플랫폼에서 사용하는 방법을 살펴보겠습니다. (전체 소스 코드는 GitHub에서 확인할 수 있으며, 이 시리즈의 기사를 건너뛰고 언제든지 소스 코드를 다운로드할 수 있습니다.)\n\n우선, 이러한 모든 것을 이해하기 위해 몇 가지 요구 사항이 필요합니다:\n\n- Clean Architecture\n- Multi-language\n- Multi-theme\n- Bloc\n- Unit test\n- Relational Database\n\n어느 부분이 익숙하지 않다면 각 섹션에 대해 발행된 기사를 클릭하여 읽을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저 UI를 확인해야 해요. Bemani가 이 UI를 만들었고, 아래 링크에서 찾을 수 있어요.\n\n프로젝트 분석 후 코딩을 시작해요. 이 프로젝트 구조는 Clean Architecture를 기반으로 하고, 관련 기사를 참고하여 다국어 및 다테마를 추가했어요. (이 구조에 대한 더 자세한 내용은 관련 기사를 읽어보세요.)\n\n![이미지](/assets/img/2024-06-30-FlutterToDoapplicationPart1Infrastructure_0.png)\n\n# res 폴더 안에는 무엇이 있나요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로젝트에서 반복적으로 사용하는 도우미 클래스를 몇 개 만들었습니다. 아래는 일부 중요한 클래스의 소스 코드입니다.\n\n## Dimens\n\nUI의 모든 위젯에는 크기, 패딩, 둥근 모서리 등이 있습니다. 이러한 것들을 코드에 넣고 중앙에 배치하지 않으면 나중에 일부 치수를 변경할 때 문제가 발생할 수 있습니다. 그래서 이러한 값을 중앙에 정리하는 것이 좋습니다.\n\n## drawable\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n차원과 마찬가지로 아이콘, 카드 배경, 그림자 등과 같은 반복 가능한 드로어블을 사용합니다.\n\n## 스타일\n\n일부 텍스트 스타일과 애플리케이션 테마 클래스가 이 패키지 내에 있습니다.\n\n# src 폴더에는 무엇이 있나요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 폴더에서는 응용 프로그램의 src 코드를 작성합니다. 이 폴더는 깔끔한 아키텍처 역할을 따라 (더 자세한 내용은 이 기사를 읽어보세요) 흐릅니다. 우리의 src 코드에는 3개의 계층이 있습니다.\n\nApp, Domain, Data.\n\n![이미지](/assets/img/2024-06-30-FlutterToDoapplicationPart1Infrastructure_1.png)\n\n- app: 이 계층에는 UI 로직 및 다른 것들에 대한 UI와 관련된 모든 것이 의존하지 않고 포함되어 있습니다. 우리는 상태 관리자로 Bloc을 사용하고 UI를 간단한 재사용 가능한 위젯으로 분할했습니다. 각 블록 상태는 도메인 레이어에 있는 사용 사례에만 의존합니다.\n- domain: 이 계층에는 UI 데이터 모델, 리포지토리 및 사용 사례가 포함되어 있습니다. UI 계층은 사용 사례에만 의존하며 각 사용 사례는 하나 이상의 리포지토리에 의존합니다. 사용 사례는 항목이나 기능으로 분할될 수 있으며, 예를 들어, 모든 작업에 대한 모든 기능을 포함하는 TaskUseCase가 있을 수 있습니다. 또는 AddTaskUseCase, EditTaskUseCase, DeleteTaskUseCase 등과 같이 기능별로 분할할 수 있습니다. 이 프로젝트에서는 작업을 위한 하나의 사용 사례, TaskUseCase만 있지만, 재사용성과 SOLID를 위해 기능별로 분할하는 것이 좋습니다.\n- data: 이 계층은 도메인 레이어에 존재하는 리포지토리에 의존하며 데이터를 저장하거나 검색하는 데 필요한 모든 논리를 포함하고 있습니다. 도메인 레이어의 각 리포지토리에 대해 데이터 레이어에는 여러 데이터를 사용할 수 있는 하나의 구현이 있습니다. 각 데이터 제공자는 해당 구현에 데이터를 제공해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n왜 우리는 이러한 레이어를 사용하고 간단한 방법을 사용하지 않을까요?\n\n이 질문에 대한 답은 확장성 및 테스트 용이성으로 요약됩니다. 여러 레이어가 있고 서로 직접적으로 관련이 없는 경우 각 레이어와 클래스에 대해 독립적으로 테스트를 작성할 수 있습니다.\n\n애플리케이션을 개발할 때는 기능별로 코드를 작성해야 하며, 한꺼번에 모든 도메인 또는 데이터 레이어 클래스를 작성해서는 안 됩니다. 하지만 이 시리즈의 기사를 요약하면 이렇게 한다.\n\n이 프로젝트의 전체 소스 코드는 GitHub의 이 저장소에서 확인할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음은 저희 애플리케이션의 다음 단계입니다:\n\n도메인 레이어\n\n데이터 레이어\n\n애플리케이션 레이어","ogImage":{"url":"/assets/img/2024-06-30-FlutterToDoapplicationPart1Infrastructure_0.png"},"coverImage":"/assets/img/2024-06-30-FlutterToDoapplicationPart1Infrastructure_0.png","tag":["Tech"],"readingTime":3}],"page":"1","totalPageCount":29,"totalPageGroupCount":2,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"1"},"buildId":"9ddMoNNI_mr3kv4sKx3b_","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>