<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>uidev-css</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://uidev-css.github.io///posts/2" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="uidev-css" data-gatsby-head="true"/><meta property="og:title" content="uidev-css" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://uidev-css.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://uidev-css.github.io///posts/2" data-gatsby-head="true"/><meta name="twitter:title" content="uidev-css" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | uidev-css" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/873-1e1f6fb6fd3c8994.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-498da29379dd58dc.js" defer=""></script><script src="/_next/static/N-oSpECxE_fvEUVh5yP3h/_buildManifest.js" defer=""></script><script src="/_next/static/N-oSpECxE_fvEUVh5yP3h/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UIDEV CSS</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Flutter 검색바 궁극의 가이드" href="/post/2024-06-21-FlutterSearchBarAnUltimateGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter 검색바 궁극의 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-FlutterSearchBarAnUltimateGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter 검색바 궁극의 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Flutter 검색바 궁극의 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 21, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter에서 권한 요청 처리하는 방법" href="/post/2024-06-21-HowtohandlepermissionrequestsinFlutter"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter에서 권한 요청 처리하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-HowtohandlepermissionrequestsinFlutter_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter에서 권한 요청 처리하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Flutter에서 권한 요청 처리하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 21, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter로 처음부터 앱 작성 시 고려할 사항 7가지" href="/post/2024-06-21-FlutterconsiderationsforwritinganAppfromthescratch"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter로 처음부터 앱 작성 시 고려할 사항 7가지" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-FlutterconsiderationsforwritinganAppfromthescratch_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter로 처음부터 앱 작성 시 고려할 사항 7가지" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Flutter로 처음부터 앱 작성 시 고려할 사항 7가지</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 21, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Firebase로 Flutter 웹 앱 호스팅하기 단계별 가이드" href="/post/2024-06-21-HostingaFlutterWebApponFirebaseAStep-by-StepGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Firebase로 Flutter 웹 앱 호스팅하기 단계별 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-HostingaFlutterWebApponFirebaseAStep-by-StepGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Firebase로 Flutter 웹 앱 호스팅하기 단계별 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Firebase로 Flutter 웹 앱 호스팅하기 단계별 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 21, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="DropdownMenu  검색 가능한 드롭다운 Flutter 폼을 향상시키는 방법" href="/post/2024-06-21-DropdownMenuAsearchabledropdownSuperchargeyourFlutterforms"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="DropdownMenu  검색 가능한 드롭다운 Flutter 폼을 향상시키는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-DropdownMenuAsearchabledropdownSuperchargeyourFlutterforms_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="DropdownMenu  검색 가능한 드롭다운 Flutter 폼을 향상시키는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">DropdownMenu  검색 가능한 드롭다운 Flutter 폼을 향상시키는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 21, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter 백그라운드 작업 앱 성능 향상 방법" href="/post/2024-06-21-FlutterBackgroundTasksImprovingAppPerformance"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter 백그라운드 작업 앱 성능 향상 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-FlutterBackgroundTasksImprovingAppPerformance_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter 백그라운드 작업 앱 성능 향상 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Flutter 백그라운드 작업 앱 성능 향상 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 21, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Robot 패턴을 사용한 Flutter 통합 테스트 작성법  이제껏 경험하지 못한 방법" href="/post/2024-06-21-HowtowriteintegrationtestsinFlutterlikenootherusingtheRobotPattern"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Robot 패턴을 사용한 Flutter 통합 테스트 작성법  이제껏 경험하지 못한 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-HowtowriteintegrationtestsinFlutterlikenootherusingtheRobotPattern_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Robot 패턴을 사용한 Flutter 통합 테스트 작성법  이제껏 경험하지 못한 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Robot 패턴을 사용한 Flutter 통합 테스트 작성법  이제껏 경험하지 못한 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 21, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter 상태 관리 비교 Provider, BLoC, GetX, Riverpod, GetIt, 그리고 MobX" href="/post/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter 상태 관리 비교 Provider, BLoC, GetX, Riverpod, GetIt, 그리고 MobX" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter 상태 관리 비교 Provider, BLoC, GetX, Riverpod, GetIt, 그리고 MobX" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Flutter 상태 관리 비교 Provider, BLoC, GetX, Riverpod, GetIt, 그리고 MobX</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 21, 2024</span><span class="PostList_reading_time__6CBMQ">28<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter 프로젝트의 pubspecyaml에서 assets 추가하는 방법" href="/post/2024-06-21-pubspecyamlflutterassets"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter 프로젝트의 pubspecyaml에서 assets 추가하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-pubspecyamlflutterassets_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter 프로젝트의 pubspecyaml에서 assets 추가하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Flutter 프로젝트의 pubspecyaml에서 assets 추가하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 21, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter 앱 설정을 위한 Firebase 설정 방법  Android 및 Web" href="/post/2024-06-21-HowtosetupFirebaseforFlutterAppAndroidandWeb"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter 앱 설정을 위한 Firebase 설정 방법  Android 및 Web" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-HowtosetupFirebaseforFlutterAppAndroidandWeb_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter 앱 설정을 위한 Firebase 설정 방법  Android 및 Web" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Flutter 앱 설정을 위한 Firebase 설정 방법  Android 및 Web</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 21, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link posts_-active__YVJEi" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Flutter 검색바 궁극의 가이드","description":"","date":"2024-06-21 23:41","slug":"2024-06-21-FlutterSearchBarAnUltimateGuide","content":"\n\n# 소개\n\n모바일 앱 개발 분야에서 잘 설계된 검색 기능은 편의성뿐만 아니라 사용자 참여 및 접근성을 크게 향상시키는 중요한 구성 요소입니다. 특히 방대한 데이터를 다루는 애플리케이션의 경우에는 이러한 요소가 더욱 중요합니다. 모바일 개발자들 사이에서 인기를 끌고 있는 Flutter는 네이티브 컴파일된 애플리케이션을 구축하기 위한 훌륭한 프레임워크로 두드러집니다. 이 글에서는 Flutter에서 다양한 검색 위젯을 디자인하는 여정을 시작해 CustomSearchDelegate와 같은 범용 위젯을 생성하는 방법을 살펴보겠습니다. 우리는 검색을 구현하기 위해 showSearch 메서드를 활용할 것입니다. 먼저 기본 검색 바를 만들고, 이후에는 임의의 프로젝트에서 사용할 수 있는 방식으로 커스터마이징할 것입니다.\n\n결과물은 이렇게 보일 것입니다.\n\n# showSearch:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nShowSearch은 플러터의 머티리얼 라이브러리에 있는 메소드입니다. 따라서 위젯 트리 어디에서나 접근할 수 있습니다.\n\n```js\nFuture\u003cT?\u003e showSearch\u003cT\u003e({\n  required BuildContext context,\n  required SearchDelegate\u003cT\u003e delegate,\n  String? query = '',\n  bool useRootNavigator = false,\n})\n```\n\n이 메소드는 BuildContext와 SearchDelegate를 필요로 합니다. SearchDelegate는 T 타입의 파라미터를 받는 추상 클래스입니다.\n\n예시:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n showSearch(context: context, delegate: CustomSearchDelegate());\n```\n\n따라서 검색 기능을 구현하려면 SearchDelegate를 확장하는 클래스를 만들면 됩니다. 그것이 어떻게 이루어지는지 살펴봅시다.\n\n```js\nclass CustomSearchDelegate extends SearchDelegate {\n  @override\n  List\u003cWidget\u003e? buildActions(BuildContext context) {\n    // 할 일: buildActions 구현\n    throw UnimplementedError();\n  }\n\n  @override\n  Widget? buildLeading(BuildContext context) {\n    // 할 일: buildLeading 구현\n    throw UnimplementedError();\n  }\n\n  @override\n  Widget buildResults(BuildContext context) {\n    // 할 일: buildResults 구현\n    throw UnimplementedError();\n  }\n\n  @override\n  Widget buildSuggestions(BuildContext context) {\n    // 할 일: buildSuggestions 구현\n    throw UnimplementedError();\n  }\n\n}\n```\n\nSearchDelegate는 4개의 메소드를 구현하도록 요구합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- buildActions: 검색 쿼리를 지우는 작업과 같은 액션을 관리합니다. AppBar의 action 매개변수와 유사합니다.\n- buildLeading: 일반적으로 네비게이션을 위한 뒤로가기 버튼이 포함됩니다.\n- buildResults: 검색 결과를 표시합니다.\n- buildSuggestions: 사용자가 쿼리를 입력하는 동안 제안을 제공합니다.\n\n이 델리게이트를 사용하여 기본 검색을 구현해봅시다.\n\n```js\nclass CustomSearchDelegate extends SearchDelegate {\n  List\u003cString\u003e searchables = List.generate(100, (index) =\u003e '아이템 ${index + 1}');\n\n  @override\n  List\u003cWidget\u003e? buildActions(BuildContext context) {\n    return [\n      IconButton(\n        onPressed: () {\n          query = '';\n        },\n        icon: const Icon(Icons.clear),\n      ),\n    ];\n  }\n\n  @override\n  Widget? buildLeading(BuildContext context) {\n    return IconButton(\n      onPressed: () {\n        close(context, []);\n      },\n      icon: Icon(\n        Platform.isAndroid ? Icons.arrow_back : Icons.arrow_back_ios,\n        size: 22,\n      ),\n    );\n  }\n\n  @override\n  Widget buildResults(BuildContext context) {\n    return SuggestionOrResultWidget(searchables: searchables, query: query);\n  }\n\n  @override\n  Widget buildSuggestions(BuildContext context) {\n    return SuggestionOrResultWidget(searchables: searchables, query: query);\n  }\n}\n```\n\n```js\nclass SuggestionOrResultWidget extends StatelessWidget {\n  const SuggestionOrResultWidget({\n    key,\n    required this.searchables,\n    required this.query,\n  });\n\n  final List\u003cString\u003e searchables;\n  final String query;\n\n  @override\n  Widget build(BuildContext context) {\n    final List\u003cString\u003e suggestions = query.isEmpty\n        ? searchables\n        : searchables.where((element) =\u003e element.toLowerCase().contains(query.toLowerCase())).toList();\n\n    if (suggestions.isEmpty) return const NoResultWidget();\n\n    return ListView.separated(\n      itemBuilder: (context, index) =\u003e ListTile(\n        title: Text(suggestions[index]),\n      ),\n      separatorBuilder: (context, index) =\u003e const Divider(),\n      itemCount: suggestions.length,\n    );\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nclass NoResultWidget extends StatelessWidget {\n  const NoResultWidget({Key key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const Center(\n      child: Text('No Result Found'),\n    );\n  }\n}\n```\n\n결과는 다음과 같이 나타납니다\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:752/1*06CrNqmR7P5yqvzpGdtdXw.gif\" /\u003e\n\n# 검색 페이지 앱바의 ThemeData 사용자 정의하기\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하나 주목할 점은 검색 페이지를 표시할 때 앱의 테마와 동일하지 않다는 것입니다. 이는 특히 AppBar의 색상에서 확인할 수 있습니다. 아래 코드는 검색 페이지의 AppBar에 앱의 ThemeData를 직접 전달합니다.\n\n```js\nclass CustomSearchDelegate extends SearchDelegate {\n  List\u003cString\u003e searchables = List.generate(100, (index) =\u003e 'Item ${index + 1}');\n\n  @override\n  ThemeData appBarTheme(BuildContext context) {\n    return ThemeData(\n      // 앱바 테마를 사용자 정의합니다.\n      appBarTheme: const AppBarTheme(\n        backgroundColor: Colors.blue,\n        foregroundColor: Colors.white,\n      ),\n      // 입력 장식 테마를 사용자 정의합니다.\n      inputDecorationTheme: const InputDecorationTheme(\n        isDense: true,\n        isCollapsed: true,\n        contentPadding: EdgeInsets.only(left: 12, top: 6, bottom: 6),\n        enabledBorder: OutlineInputBorder(\n            borderSide: BorderSide(\n          color: Colors.white,\n        )),\n        focusedBorder: OutlineInputBorder(\n            borderSide: BorderSide(\n          color: Colors.white,\n        )),\n        border: OutlineInputBorder(\n          borderSide: BorderSide(\n            color: Colors.white,\n          ),\n        ),\n      ),\n    );\n  }\r\n```\n\n\u003cimg src=\"/assets/img/2024-06-21-FlutterSearchBarAnUltimateGuide_0.png\" /\u003e\n\n# 일반적인 검색 위젯 만들기:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더 고급 구현으로 나아가기 위해 CustomSearchDelegate를 자세히 살펴봅시다. 이 일반적인 위젯은 여러 데이터 유형에서 재사용성과 적응성을 가장합니다.\n\n```js\n/// 어디서나 사용할 수 있는 제네릭 검색 대리자입니다\nclass CustomSearchDelegate\u003cT\u003e extends SearchDelegate\u003cList\u003cT\u003e\u003e {\n  CustomSearchDelegate({\n    required this.searchables,\n    required this.suggestionOrResult,\n    required this.itemMatcher,\n    this.onTap,\n  });\n  \n  // 검색 대상 항목\n  final List\u003cT\u003e searchables;\n  \n  // 제안 또는 결과를 가져올 때 표시해야 하는 위젯입니다.\n  // 제안과 결과에 대해 별도의 위젯을 사용하려면 suggestionWidget 및 resultWidget을 추가하여 \n  // 다른 방식으로 빌드할 수 있습니다.\n  final Widget Function(List\u003cT\u003e, String) suggestionOrResult;\n\n  // 일치 실행에 대한 쿼리\n  final bool Function(T item, String query) itemMatcher;\n\n  // 항목이 탭될 때의 콜백\n  final ValueChanged\u003cT\u003e? onTap;\n\n  @override\n  List\u003cWidget\u003e? buildActions(BuildContext context) {\n    return [\n      IconButton(\n        onPressed: () {\n          query = '';\n        },\n        icon: const Icon(Icons.clear),\n      ),\n    ];\n  }\n\n  @override\n  Widget buildLeading(BuildContext context) {\n    return IconButton(\n      onPressed: () {\n        close(context, []);\n      },\n      icon: Icon(\n        Platform.isAndroid ? Icons.arrow_back : Icons.arrow_back_ios,\n        size: 22,\n      ),\n    );\n  }\n\n  @override\n  Widget buildResults(BuildContext context) {\n    return _buildSuggestionOrResult();\n  }\n\n  @override\n  Widget buildSuggestions(BuildContext context) {\n    if (searchables.isEmpty) return const SizedBox();\n    return _buildSuggestionOrResult();\n  }\n\n  Widget _buildSuggestionOrResult() {\n    final List\u003cT\u003e suggestionList =\n        query.isEmpty ? searchables : searchables.where((item) =\u003e itemMatcher(item, query)).toList();\n\n    if (suggestionList.isEmpty) {\n      return NoResultFoundWidget();\n    }\n\n    return suggestionOrResult(suggestionList, query);\n  }\n\n}\n```\n\n다음과 같이 이 일반 대리자를 사용할 수 있습니다:\n```js\nshowSearch(\n  context: context,\n  delegate: CustomSearchDelegate\u003cList\u003cString\u003e\u003e(\n    searchables: searchables,\n    suggestionOrResult: (List\u003cString\u003e suggestions, String query) =\u003e ListWidget(\n      suggestionsList: searchables,\n      query: query,\n    ),\n    itemMatcher: (String item, String query) =\u003e item.toLowerCase().contains(query.toLowerCase()),\n  ),\n)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 보너스:\n\n만일 입력된 글자를 제시 목록에서 강조하고 결과로 스크롤하고 싶다면 다음 위젯을 사용할 수 있습니다.\n\n```js\nclass ListWidget extends StatefulWidget {\n  const ListWidget({\n    super.key,\n    required this.suggestionsList,\n    required this.query,\n  });\n\n  final List\u003cString\u003e suggestionsList;\n  final String query;\n\n  @override\n  State\u003cListWidget\u003e createState() =\u003e _ListWidgetState();\n}\n\nclass _ListWidgetState extends State\u003cListWidget\u003e {\n  late List\u003cString\u003e filteredList;\n  final ScrollController scrollController = ScrollController();\n\n  @override\n  void initState() {\n    super.initState();\n    filterList();\n  }\n\n  @override\n  void didUpdateWidget(ListWidget oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    if (widget.query != oldWidget.query) {\n      filterList();\n    }\n  }\n\n  void filterList() {\n    filteredList =\n        widget.suggestionsList.where((item) =\u003e item.toLowerCase().contains(widget.query.toLowerCase())).toList();\n\n    if (filteredList.isNotEmpty) {\n      if (filteredList.isNotEmpty) {\n        WidgetsBinding.instance.addPostFrameCallback((_) =\u003e scrollToFirstMatch());\n      }\n    }\n  }\n\n  void scrollToFirstMatch() {\n    int index = widget.suggestionsList.indexOf(filteredList.first);\n    if (index != -1 \u0026\u0026 scrollController.hasClients) {\n      scrollController.animateTo(\n        index * 32.0, // 각 항목의 높이가 32로 가정\n        duration: const Duration(milliseconds: 100),\n        curve: Curves.easeInOut,\n      );\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return ListView.separated(\n      controller: scrollController,\n      itemCount: filteredList.length,\n      itemBuilder: (context, index) {\n        final String suggestionText = filteredList[index];\n        return ListTile(\n          title: RichText(\n            text: highlightMatch(suggestionText, widget.query),\n          ),\n          onTap: () {\n            // 여기에 탭 기능을 추가하세요\n          },\n        );\n      },\n      separatorBuilder: (context, index) =\u003e const Divider(),\n    );\n  }\n\n  TextSpan highlightMatch(String text, String query) {\n    if (query.isEmpty || !text.toLowerCase().contains(query.toLowerCase())) {\n      return TextSpan(\n        text: text,\n        style: const TextStyle(color: Colors.black),\n      );\n    }\n\n    List\u003cTextSpan\u003e spans = [];\n    int start = 0;\n    int indexOfHighlight = text.toLowerCase().indexOf(query.toLowerCase());\n\n    while (indexOfHighlight != -1) {\n      spans.add(TextSpan(\n        text: text.substring(start, indexOfHighlight),\n        style: const TextStyle(color: Colors.black),\n      ));\n      spans.add(TextSpan(\n        text: text.substring(indexOfHighlight, indexOfHighlight + query.length),\n        style: const TextStyle(backgroundColor: Colors.yellow, color: Colors.black),\n      ));\n\n      start = indexOfHighlight + query.length;\n      indexOfHighlight = text.toLowerCase().indexOf(query.toLowerCase(), start);\n    }\n\n    spans.add(TextSpan(\n      text: text.substring(start),\n      style: const TextStyle(color: Colors.black),\n    ));\n    return TextSpan(children: spans);\n  }\n}\n```\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:468/1*8xf8nCjiihJQ-XUSlLe5MA.gif\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론:\n\n모바일 앱 디자인에서 효과적인 검색 기능은 사용자 만족도와 참여도에 중요한 요소입니다. 이 CustomSearchDelegate은 플러터 앱에서 사용자 정의 및 다양한 검색 기능을 만들기 위한 템플릿을 제공합니다.\n\n독서해 주셔서 감사합니다. 즐거운 코딩 하세요 :)\n\n# Stackademic\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n끝까지 읽어주셔서 감사합니다. 떠나시기 전에:\n\n- 작가를 격려하고 팔로우해 주세요! 👏\n- 트위터(X), 링크드인, 그리고 유튜브에서 저희를 팔로우해 주세요.\n- 전세계에서 무료 프로그래밍 교육을 민주화하고 있는 Stackademic.com을 방문해보세요.","ogImage":{"url":"/assets/img/2024-06-21-FlutterSearchBarAnUltimateGuide_0.png"},"coverImage":"/assets/img/2024-06-21-FlutterSearchBarAnUltimateGuide_0.png","tag":["Tech"],"readingTime":11},{"title":"Flutter에서 권한 요청 처리하는 방법","description":"","date":"2024-06-21 23:39","slug":"2024-06-21-HowtohandlepermissionrequestsinFlutter","content":"\n\n\n![Screenshot](/assets/img/2024-06-21-HowtohandlepermissionrequestsinFlutter_0.png)\n\nFlutter에서 권한 요청 처리하는 방법— 이 강의에서는 Flutter에서 안드로이드와 IOS에서 권한을 요청하고 확인하는 방법을 살펴볼 것입니다.\n\n## 패키지\n\n- 권한 핸들러 (permission_handler)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 설치\n\n플러터 패키지를 설치하는 과정은 매우 간단합니다. pubspec.yaml 파일을 열고 해당 패키지를 의존성 블록 섹션에 추가하면 됩니다.\n\n```js\ndependencies:\n  permission_handler:\n```\n\n팁: caret 버전을 사용하여 패키지 버전을 특정 주 버전으로 제한할 수 있습니다. 예를 들어, permission_handler: ^11.0.0는 버전 11로 제한되지만 주 버전 업데이트와 보안 패치를 모두 받게 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 권한\n\n먼저, 앱이 필요로하는 권한을 결정해야 합니다. 앱은 필요한 권한을 공개적으로 선언해야 합니다. 인터넷과 같은 민감하지 않은 권한은 자동으로 허용됩니다. 그 외의 민감한 권한인 위치, 연락처 등은 사용 전 사용자 승인이 필요합니다.\n\n## iOS 권한\n\niOS에서는 필요한 권한과 그 이유를 함께 기재하는 정보 속성 목록 파일(info.plist)에 권한을 추가함으로써 이를 처리할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003ckey\u003eNSPhotoLibraryUsageDescription\u003c/key\u003e\n\u003cstring\u003e이 앱은 사용자 갤러리에 이미지를 저장해야 합니다\u003c/string\u003e\r\n```\n\n플러터의 경우, 프로젝트의 루트 디렉토리인 iOS/Runner 폴더의 info.plist에 해당합니다. info.plist에 대해 더 알아보려면 여기를 참고하세요.\n\n모든 권한 목록은 여기에서 찾을 수 있으며 iOS에서 권한을 요청하는 가이드라인은 여기에서 확인할 수 있습니다.\n\n## Android 권한요청\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안드로이드에서는 `uses-permission` 태그를 android manifest에 추가하여 동일한 결과를 얻을 수 있습니다. 이 파일은 android/src/main/AndroidManifest.xml 디렉토리에 있습니다.\n\n```js\n\u003cmanifest ...\u003e\n    \u003cuses-permission android:name=\"android.permission.SEND_SMS\"/\u003e\n    \u003capplication ...\u003e\n        ...\n    \u003c/application\u003e\n\u003c/manifest\u003e\n```\n\n여기서 안드로이드에서 권한에 대해 더 알아보고 최선의 방법을 알아볼 수 있습니다.\n\n## 권한 요청하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사용 권한을 요청하려면 먼저 패키지를 가져와야 합니다:\n\n```js\nimport 'package:permission_handler/permission_handler.dart';\n```\n\n그리고요, 연락처 권한을 요청하려면 다음과 같이 할 수 있어요. 한 번에 필요한 여러 권한을 요청할 수 있는 권한 목록을 전달합니다.\n\n## 사용 방법\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다양한 권한들이 있어요. 권한의 상태를 확인할 수 있는데, 그 상태는 허용됨(granted), 거부됨(denied), 제한(restricted), 영구적으로 거부됨(permanentlyDenied), 제한된(limited), 또는 임시적인(provisional) 상태 중 하나일 거예요.\n\n```js\nvar status = await Permission.camera.status;\nif (status.isDenied) {\n  // 아직 권한을 요청하지 않았거나 권한이 이전에 거부되었지만 영구적으로 거부되지는 않았어요.\n}\n\n// 권한 상태에 대해 직접 물어볼 수도 있어요.\nif (await Permission.location.isRestricted) {\n  // OS가 접근을 제한했어요. 예를 들어, 부모용 제어 설정 때문일 수도 있어요.\n}\n```\n\n요청하려는 권한에 request()를 호출해주세요. 이미 이전에 허용된 경우, 아무 일도 일어나지 않아요.\nrequest()는 권한의 새로운 상태를 반환할 거예요.\n\n```js\nif (await Permission.contacts.request().isGranted) {\n  // 권한이 이미 허용되었거나 사용자가 방금 허용한 경우일 수 있어요.\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 한 번에 여러 권한을 요청할 수 있습니다.\nMap\u003cPermission, PermissionStatus\u003e statuses = await [\n  Permission.location,\n  Permission.storage,\n].request();\nprint(statuses[Permission.location]);\n```\n\n일부 권한, 예를 들어 위치나 가속도 센서 권한과 같은 것들은 활성화 또는 비활성화할 수 있는 관련 서비스가 있습니다.\n\n```js\nif (await Permission.locationWhenInUse.serviceStatus.isEnabled) {\n  // 위치 사용\n}\n```\n\n앱 설정도 열 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n만약 (await Permission.speech.isPermanentlyDenied) {\n  // 사용자가 앱의 이 권한 요청 대화상자를 다시 보지 않기로 선택했습니다.\n  // 권한 상태를 변경하는 유일한 방법은 사용자가 시스템 설정에서 직접 활성화하는 것입니다.\n  openAppSettings();\n}\n```\n\nAndroid에서 권한을 사용하는 근거를 표시할 수 있습니다:\n\n```js\nbool isShown = await Permission.contacts.shouldShowRequestRationale;\n```\n\n일부 권한은 사용자에게 요청된 권한을 허용하거나 거부할 것을 요청하는 대화상자를 표시하지 않을 수 있습니다.\n이는 앱에 대한 OS 설정이 해당 권한에 대한 권한을 나타내는 경우입니다.\n설정의 상태가 권한을 허용할지 거부할지를 결정합니다.\n","ogImage":{"url":"/assets/img/2024-06-21-HowtohandlepermissionrequestsinFlutter_0.png"},"coverImage":"/assets/img/2024-06-21-HowtohandlepermissionrequestsinFlutter_0.png","tag":["Tech"],"readingTime":4},{"title":"Flutter로 처음부터 앱 작성 시 고려할 사항 7가지","description":"","date":"2024-06-21 23:37","slug":"2024-06-21-FlutterconsiderationsforwritinganAppfromthescratch","content":"\n\n## 앱을 작성할 때 고려해야 할 주제\n\n![image](/assets/img/2024-06-21-FlutterconsiderationsforwritinganAppfromthescratch_0.png)\n\n앱을 작성한 지 여러 해가 지났습니다. 다양한 앱 템플릿을 구축했고, 다양한 패키지를 사용했습니다. 많은 변화가 있었지만 고려 사항은 동일한 비율로 변하지는 않았습니다. 몇 가지 패턴을 감지했습니다.\n\n이 게시물에서는 내 생각을 체계적으로 정리하고, 처음부터 앱을 시작할 때 주의해야 할 사항 목록을 작성했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 귀하의 요구에 맞는 상태 관리 시스템을 선택하세요.\n- 개발을 시작하기 전에 응용 프로그램의 아키텍처를 정의하세요.\n- 미래에 쉽게 변경할 수 있도록 서드 파티 라이브러리를 래핑하세요.\n- 처음부터 다국어 지원에 대비하세요.\n- 응용 프로그램에 맞는 내비게이션 스키마를 선택하세요.\n- 오류를 효과적으로 처리하여 원활한 사용자 경험을 보장하세요.\n- 응용 프로그램을 활기차게 만들기 위해 뷰 레이아웃을 작성하세요.\n- 로컬 데이터를 영구히 보관하고 필요에 따라 데이터 스키마를 업그레이드하는 방법을 정의하세요.\n- 개발, 스테이징 및 프로덕션을 위한 다른 환경을 정의하세요.\n- 문제를 쉽게 추적하고 수정할 수 있는 로그 메커니즘과 정책을 정의하세요.\n\n# 상태 관리 선택\n\n이것은 꼭 해야 할 일 중에 첫 번째라고 생각해요. 상태 관리는 귀하가 할 가장 중요한 결정입니다. 앱을 작성하는 방식을 결정하며, 클래스를 구성하는 방법을 결정합니다. 따라서 상태 관리를 선택하는 것은 중요합니다. 선택하지 않을 수 없습니다. 상태 관리는 Flutter 앱의 핵심이 되므로 중요합니다. 저는 BLoC 패턴을 좋아합니다만, 여러 옵션이 있습니다:\n\n- Bloc\n- Provider\n- GetX\n- Riverpod\n- 기타\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제가 작성한 상태 관리에 관한 글을 확인해보세요:\n\n# 아키텍처 정의\n\n아키텍처는 코드를 구성합니다. 당신의 코드를 전문적으로 만들 뿐만 아니라 전문적으로 보이게 할 수 있습니다. 좋은 아키텍처는 재사용 가능하고 확장 가능하며 쉽게 유지 관리할 수 있는 코드를 제공해야 합니다. 현재 트렌드인 깔끔한 아키텍처를 선택할지라도, 응용 프로그램에 가장 적합한 것을 선택하되, SOLID 원칙을 무시하지 말아야 합니다.\n\n이에 대해 이야기한 글을 작성했습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 외부 라이브러리 래핑하기\n\n이거 좋아요. 이 방법은 외부 라이브러리를 자신의 코드에서 분리하는 쉬운 방법이에요.\n\n이렇게 하는 대신에:\n\n```js\nThirdPartyLibrary.doSomething();\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기 변경하세요:\n\n\nMyWrapperOfThirdPartyLibrary.doSomething();\n\n...\n\nclass MyWrapperOfThirdPary{\n  public void doSomething(){\n    ThirdPartyLibrary.doSomething();  \n  }\n}\n\n\n# 멀티 언어를 지원할 앱을 준비하세요\n\n이것은 여러 언어로 확장 가능한 앱으로 변화시키기 위해 시간을 소모하면서 낮은 노력으로 자원을 투자할 수 있는 한 가지 방법입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 네비게이션 스키마 선택\n\n네비게이션 흐름을 먼저 정의해야 합니다. 네비게이션은 앱을 조직하는 데 사용되며, 이를 해결하는 여러 패키지를 활용해야 합니다.\n\n저는 다양한 방식을 사용해왔지만, 최근 앱에서는 Go Router를 선택했습니다. 이는 깔끔하고 쉽습니다.\n\n# 에러 처리하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n에러를 어떻게 처리할지 정의해야 합니다. 에러는 발생할 수 있으며, 방치해서는 안 됩니다.\n\n저는 앱에서 에러를 처리하는 데 데코레이터를 정의했습니다:\n\n# 뷰를 위한 레이아웃 만들기\n\n뷰를 범주별이나 유형별로 구성하면 재사용성이 향상됩니다. 각 유형의 페이지를 위한 템플릿이나 레이아웃을 만들고 여러 뷰에서 사용할 수 있습니다. 이렇게 하면 변경 사항을 구현하기가 더 쉬워집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n레이아웃에 관한 내 게시물을 확인해보세요:\n\n# 로컬 데이터를 유지하는 방법 정의\n\n요즘에는 로컬 데이터를 관리하는 것이 매우 유용합니다. 사용자에게 오프라인 사용 가능성을 제공해야 하는 방법입니다. Shared Preferences와 같이 간단할 수도 있고, 데이터베이스와 같이 더 복잡할 수도 있습니다.\n\n데이터베이스를 사용해야 하는 경우에는 해당 로컬 데이터베이스의 스키마를 업그레이드하는 메커니즘을 정의해야 합니다. 상상할 수 있겠지만, 이미 이에 대해 글을 썼습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 다양한 환경을 정의하세요: 개발, 스테이징, 프로덕션\n\n앱을 개발할 때 유용하고 필수적입니다. 환경을 청결하게 관리할 수 있어야 합니다. 몇 가지 변수를 변경하면 스테이징 또는 프로덕션으로 전환할 수 있습니다.\n\n물론, 이에 대해 이야기한 포스트가 있습니다!\n\n# 로그 메커니즘 및 정책을 정의하세요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앱에 로그를 갖는 것이 매우 중요해요. 문제가 발생하고 문제가 있을 거에요. 이를 감지할 준비를 해야 해요. 처음부터 메커니즘을 정의하면 쉬울 거에요.\n\n여러 접근 방식과 앱 메시지를 로깅하는 다양한 패키지를 찾을 수 있어요.\n\n저는 그에 대해 이야기한 게시물이 있어요.\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 신선한 공기를 마시고 생각해보세요.\n- 미친 듯이 앱 작성을 시작하지 마세요.\n- 핵심 주제에 대해 생각하고 어떻게 관리할지 정의해보세요.\n\n읽어주셔서 감사합니다. 좋았다면 박수를 쳐주세요!\n\n![이미지](/assets/img/2024-06-21-FlutterconsiderationsforwritinganAppfromthescratch_1.png)\n\n아래에 의견을 남겨주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Stackademic 🎓\n\n끝까지 읽어 주셔서 감사합니다. 떠나시기 전에:\n\n- 클로밍하고 작가를 팔로우해주시면 감사하겠습니다! 👏\n- 다음 사이트도 팔로우해주세요: X | LinkedIn | YouTube | Discord\n- 다른 플랫폼도 방문해보세요: In Plain English | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠를 다루는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요.\n- Stackademic.com에서 더 많은 콘텐츠를 만나보세요.","ogImage":{"url":"/assets/img/2024-06-21-FlutterconsiderationsforwritinganAppfromthescratch_0.png"},"coverImage":"/assets/img/2024-06-21-FlutterconsiderationsforwritinganAppfromthescratch_0.png","tag":["Tech"],"readingTime":4},{"title":"Firebase로 Flutter 웹 앱 호스팅하기 단계별 가이드","description":"","date":"2024-06-21 23:36","slug":"2024-06-21-HostingaFlutterWebApponFirebaseAStep-by-StepGuide","content":"\n\n\u003cimg src=\"/assets/img/2024-06-21-HostingaFlutterWebApponFirebaseAStep-by-StepGuide_0.png\" /\u003e\n\nFlutter은 개발자가 크로스 플랫폼 애플리케이션을 만드는 방식을 혁신했습니다. 이는 모바일 및 웹 플랫폼 모두에 대해 원활한 경험을 제공합니다. 웹 개발자들에게는 다양한 호스팅 옵션을 고려할 때 플러터 웹 앱을 호스팅하는 것이 어려울 수 있습니다. 그 중에서도 Firebase는 견고하고 개발자 친화적인 선택지로 빛을 발합니다. 이 글에서는 Firebase에서 플러터 웹 앱을 호스팅하기 위한 단계를 안내하겠습니다. 이를 통해 원활하고 성공적인 배포를 보장합니다.\n\n# 단계 1: 플러터 웹 앱 설정하기\n\nFirebase로 진입하기 전에 플러터 웹 앱이 배포 준비가 되어 있는지 확인하세요. 즉, 앱을 철저히 테스트하여 버그가 없고 최상의 성능을 발휘하는지 확인해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 앱 개발하기: 먼저 플러터 웹 앱을 만들어 보세요. 플러터가 처음이라면 시작하는 데 도움이 되는 다양한 리소스가 있습니다.\n- 앱 테스트하기: 앱이 예상대로 원활하게 실행되는지 확인하세요. 플러터는 이 프로세스를 돕는 테스트 도구를 제공합니다.\n\n# 단계 2: Firebase 도구 설치하기\n\nFirebase 도구는 Firebase 프로젝트를 배포하고 관리하는 데 도움이 되는 명령줄 도구입니다.\n\n- Node.js 설치: Firebase 도구는 Node.js를 필요로 합니다. nodejs.org에서 다운로드하여 설치하세요.\n- Firebase 도구 설치: 명령 프롬프트 또는 터미널을 열고 npm install -g firebase-tools를 실행하세요. 이 명령은 Firebase 명령줄 도구를 전역적으로 설치합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 단계 3: Firebase 프로젝트 만들기\n\n- Firebase 콘솔로 이동: Firebase 콘솔로 이동합니다.\n- 새 프로젝트 만들기: 화면 안내에 따라 새 Firebase 프로젝트를 만듭니다. 이 프로젝트는 당신의 Flutter 웹 앱을 위한 홈이 될 것입니다.\n\n# 단계 4: Firebase 및 Flutter 설정\n\nFirebase 프로젝트를 만든 후에, Flutter 앱과 연결해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 프로젝트에서 Firebase를 초기화하세요: 프로젝트 디렉토리에서 firebase init를 실행하세요.\n- Hosting 선택: 안내를 받으면 'Hosting' 옵션을 선택하거나 아래의 두 호스팅 옵션 중 선택하세요:\n\n![이미지](/assets/img/2024-06-21-HostingaFlutterWebApponFirebaseAStep-by-StepGuide_1.png)\n\n- 기존 프로젝트 사용 또는 새 프로젝트를 만들려면 새로 만들어지는 새 프로젝트를 선택하고 나머지 지침을 따르세요.\n- 방금 Firebase 콘솔에서 만든 프로젝트를 지정하세요.\n- 그런 다음 다음과 같이 진행하세요:\n\n![이미지](/assets/img/2024-06-21-HostingaFlutterWebApponFirebaseAStep-by-StepGuide_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 그런 다음 `Set up automatic builds and deploys with GitHub?`이라는 옵션을 보고 만일 당신이 Github에 코드를 푸시할 때 자동으로 웹사이트를 재배포하고 싶다면 Y를 입력하고, 그렇지 않다면 N을 입력하세요.\n\n# 단계 5: Flutter 웹 앱 빌드하기\n\n배포하기 전에, Flutter 웹 앱의 릴리스 버전을 빌드해야 합니다.\n\n- 빌드 명령 실행: 터미널에서 flutter build web 명령을 실행하세요. 이 명령은 앱을 배포 가능한 웹 형식으로 컴파일합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 단계 6: Firebase로 배포하기\n\n앱을 구축하고 Firebase를 구성했으면 배포할 준비가 되었습니다.\n\n- 앱을 배포하세요: 프로젝트 디렉토리에서 firebase deploy를 실행하십시오. 이 명령은 구축된 앱을 Firebase Hosting에 업로드합니다.\n- 앱에 액세스하기: 배포가 완료되면 Firebase가 웹 앱에 액세스할 수 있는 URL을 제공합니다.\n\n# 단계 7: 앱 관리 및 업데이트하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n파이어베이스는 앱 사후 배포를 관리하기 위한 다양한 도구를 제공합니다.\n\n- 성능 모니터링: 파이어베이스의 분석 도구를 사용하여 사용자 참여 및 앱 성능을 추적합니다.\n- 앱 업데이트: 간단히 flutter build web로 앱을 다시 빌드하고 firebase deploy를 실행하여 업데이트할 수 있습니다.\n\n# 결론\n\n파이어베이스를 사용하면 Flutter 웹 앱을 호스팅하는 것이 직관적인 프로세스로 개발자들에게 다양한 기회를 제공합니다. 파이어베이스를 통해 앱을 호스팅할 뿐만 아니라 분석, 데이터베이스 관리 등의 기타 기능도 활용할 수 있습니다. 이러한 단계를 따라 Flutter 웹 앱을 파이어베이스에 호스팅하여 전세계 사용자가 액세스할 수 있도록 준비시킬 수 있습니다. 즐거운 코딩하세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nyawarosman.com","ogImage":{"url":"/assets/img/2024-06-21-HostingaFlutterWebApponFirebaseAStep-by-StepGuide_0.png"},"coverImage":"/assets/img/2024-06-21-HostingaFlutterWebApponFirebaseAStep-by-StepGuide_0.png","tag":["Tech"],"readingTime":3},{"title":"DropdownMenu  검색 가능한 드롭다운 Flutter 폼을 향상시키는 방법","description":"","date":"2024-06-21 23:34","slug":"2024-06-21-DropdownMenuAsearchabledropdownSuperchargeyourFlutterforms","content":"\n\n세 번째 파티 제약을 작별하고! 플러터에서 검색 가능한 드롭다운을 만들어보세요. 검색과 스타일이 적용된 여러분만의 드롭다운.\n\n플러터 DropdownMenu 마스터하기 - 아름답고 강력한 메뉴에 대한 안내\n\n![DropdownMenu](/assets/img/2024-06-21-DropdownMenuAsearchabledropdownSuperchargeyourFlutterforms_0.png)\n\n우리가 목표로 하고 있는 것은 아래와 같아요 👇🏻\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 마크다운 형식으로 변경한 코드입니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:530/1*7fLEf7WBv-qxlUx5vDYMPQ.gif)\n\n### 준비되셨나요? 코드 작성을 시작해봅시다!\n\n- 드롭다운 메뉴에 표시하고 싶은 항목 목록을 준비해봅시다. 이것은 문자열, 객체 또는 위젯의 리스트일 수 있습니다.\n\n```dart\nclass MenuItem {\n  final int id;\n  final String label;\n  final IconData icon;\n\n  MenuItem(this.id, this.label, this.icon);\n}\n\nList\u003cMenuItem\u003e menuItems = [\n  MenuItem(1, '홈', Icons.home),\n  MenuItem(2, '프로필', Icons.person),\n  MenuItem(3, '설정', Icons.settings),\n  MenuItem(4, '즐겨찾기', Icons.favorite),\n  MenuItem(5, '알림', Icons.notifications),\n];\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기 검색 가능한 DropdownMenu의 코드입니다.\n\n```js\nDropdownMenu\u003cMenuItem\u003e(\n                initialSelection: menuItems.first,\n                controller: menuController,\n                width: width,\n                hintText: \"메뉴 선택\",\n                requestFocusOnTap: true,\n                enableFilter: true,\n                label: const Text('메뉴 선택'),\n                onSelected: (MenuItem? menu) {\n                  selectedMenu = menu;\n                },\n                dropdownMenuEntries:\n                    menuItems.map\u003cDropdownMenuEntry\u003cMenuItem\u003e\u003e((MenuItem menu) {\n                  return DropdownMenuEntry\u003cMenuItem\u003e(\n                      value: menu,\n                      label: menu.label,\n                      leadingIcon: Icon(menu.icon));\n                }).toList(),\n              ),\n```\n\n요령있죠! DropdownMenuEntry는 각 메뉴 항목의 이름표처럼 동작하여 프로그램에 누구인지 알려주고 사용자에게 어떤 동작을 하는지 보여줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 Markdown 형식으로 변경해 주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n장점:\n\n- 내장: 추가 패키지가 필요하지 않으며, 플러터에서 쉽게 사용할 수 있습니다.\n- 사용하기 쉬움: 간단한 드롭다운 메뉴에 대한 기본 구현이 있습니다.\n- 사용자 정의 옵션: 메뉴 스타일, 초기 선택 및 필터링 동작을 제어할 수 있습니다.\n- 기본적인 요구에 적합: 기능이 제한된 간단한 드롭다운 메뉴에 적합합니다.\n\n단점:\n\n- 검색 기능이 제한적: 내장 필터링이 기본적이며, 레이블의 처음만 일치하는 것만 지원합니다.\n- 사용자 정의 제한: 개별 목록 항목을 사용자 정의하거나 복잡한 검색 로직을 구현할 수 없습니다.\n- 고급 기능 없음: 자동 완성, 제안 또는 다중 선택과 같은 기능이 없습니다.\n\n그래서, 여기가 함정입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n단순한 드롭다운 및 기본 필터링이 필요하다면, 내장된 DropdownMenu를 사용하세요! 고급 검색, 화려한 사용자 정의 또는 추가 기능이 필요하다면 강력한 dropdown_search 패키지를 선택하세요. 쉽죠!\n\n도움이 되었으면 좋겠네요!\n\n모한쿠마르\n\n중요한 질문이 있고 제가 놓치기를 원치 않으시면, mohan.smk23@gmail.com 으로 이메일 보내주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플러터에 대한 더 많은 콘텐츠를 보고 싶나요? 커피 한 잔 사주시면 글쓰기 열정에 불을 지킬 수 있어요!\n\n![이미지](/assets/img/2024-06-21-DropdownMenuAsearchabledropdownSuperchargeyourFlutterforms_1.png)\n\n다른 내용도 확인해보세요!","ogImage":{"url":"/assets/img/2024-06-21-DropdownMenuAsearchabledropdownSuperchargeyourFlutterforms_0.png"},"coverImage":"/assets/img/2024-06-21-DropdownMenuAsearchabledropdownSuperchargeyourFlutterforms_0.png","tag":["Tech"],"readingTime":3},{"title":"Flutter 백그라운드 작업 앱 성능 향상 방법","description":"","date":"2024-06-21 23:32","slug":"2024-06-21-FlutterBackgroundTasksImprovingAppPerformance","content":"\n\n요즘의 빠르게 변화하는 디지턈 세계에서 사용자들은 모바일 어플리케이션이 효율적이고 반응성이 있기를 원합니다. 개발자들은 이러한 요구를 충족시키기 위해 어플리케이션의 성능을 향상시키기 위한 다양한 전략을 사용해야 합니다. 그 중 하나는 백그라운드 작업을 실행하는 것인데, 이를 통해 Flutter 어플리케이션이 사용자 경험을 방해하지 않으면서 고통스러운 작업을 처리할 수 있습니다. 이 블로그 글에서 Flutter의 백그라운드 작업과 중요성을 살펴보고, 구현하는 방법을 보여줄 코딩 예제를 제공해보겠습니다.\n\n## 백그라운드 작업이 중요한 이유\n\n사용자 경험이 원활하고 끊김없이 유지되려면 백그라운드 프로세스가 필수적입니다. 이를 통해 프로그래머들은 동기화, 데이터 수집, 처리와 같이 자원 집약적인 작업을 주 UI 스레드를 방해하지 않고 백그라운드에서 처리할 수 있습니다. 이러한 작업들은 백그라운드 프로세스로 이동되어 어플리케이션이 반응적으로 유지되고 사용자들에게 원활한 경험을 제공합니다.\n\n## Flutter 백그라운드 작업 구현\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플러터는 배경 작업을 효과적으로 수행하기 위한 다양한 도구와 모듈을 제공합니다. 자주 사용되는 두 가지 방법을 살펴봅시다:\n\nIsolate를 기반으로 하는 배경 작업:\n\n메인 UI 스레드와 병렬로 작동하는 경량 별도 실행 스레드인 아이솔레이트는 배경 작업을 메인 스레드에 간섭하지 않고 수행할 수 있도록 합니다. 다음은 아이솔레이트가 배경 작업에 사용되는 예시입니다:\n\n```js\nimport 'dart:async';\nimport 'dart:isolate';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatefulWidget {\n  @override\n  _MyAppState createState() =\u003e _MyAppState();\n}\n\nclass _MyAppState extends State\u003cMyApp\u003e {\n  ReceivePort _port = ReceivePort();\n\n  @override\n  void initState() {\n    super.initState();\n    _startBackgroundTask();\n  }\n\n  void _startBackgroundTask() async {\n    await Isolate.spawn(_backgroundTask, _port.sendPort);\n    _port.listen((message) {\n      // 배경 작업 완료 처리\n      print('배경 작업 완료: $message');\n    });\n  }\n\n  static void _backgroundTask(SendPort sendPort) {\n    // 시간이 많이 소요되는 작업 수행\n    // ...\n\n    // 결과를 메인 UI 아이솔레이트로 전송\n    sendPort.send('작업 성공적으로 완료!');\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text('플러터의 배경 작업'),\n        ),\n        body: Center(\n          child: Text('배경 작업 실행 중...'),\n        ),\n      ),\n    );\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플러터의 배경 작업 가져오기:\n\n앱이 닫혀 있거나 사용 중이 아닌 경우에도, 개발자는 플러터 배경 작업 가져오기 플러그인을 사용하여 주기적인 배경 작업을 계획할 수 있습니다. 이는 데이터 동기화나 앱 컨텐츠 업데이트와 같은 상황에서 유용합니다. 플러터 배경 작업 가져오기 패키지를 사용하는 예제는 다음과 같습니다:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_background_fetch/flutter_background_fetch.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text('플러터에서 배경 작업 실행'),\n        ),\n        body: Center(\n          child: Text('배경 작업 실행 중...'),\n        ),\n      ),\n    );\n  }\n}\n\nvoid backgroundFetchHeadlessTask(String taskId) async {\n  // 여기에서 시간이 오래 걸리는 작업을 수행합니다\n  // ...\n\n  FlutterBackgroundFetch.finish(taskId);\n}\n\nvoid initBackgroundFetch() {\n  FlutterBackgroundFetch.configure(\n    minimumFetchInterval: 15,\n    stopOnTerminate: false,\n    startOnBoot: true,\n    enableHeadless: true,\n    requiresBatteryNotLow: false,\n    requiresCharging: false,\n    requiresStorageNotLow: false,\n    requiresDeviceIdle: false,\n    requiredNetworkType: NetworkType.NONE,\n  );\n  FlutterBackgroundFetch.registerHeadlessTask(backgroundFetchHeadlessTask);\n}\n```\n\n플랫폼 채널:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플랫폼 채널을 통해 Flutter는 네이티브 플랫폼 코드와 통신할 수 있습니다. 코틀린 또는 스위프트로 플랫폼별 코드를 작성하면 백그라운드 작업을 수행할 수 있는 플랫폼 채널을 사용할 수 있습니다. 필요한 작업은 그런 다음 네이티브 코드에서 백그라운드에서 수행될 수 있고, Flutter 앱에서 결과를 얻을 수 있습니다. 이 접근 방식으로 유연성과 플랫폼별 API에 접근할 수 있습니다.\n\n배경 작업을 실행하여 플랫폼별 코드를 사용하여 기기의 현재 위치를 획득하는 활동을 실행하려고 상상해보세요. 이렇게 플랫폼 채널이 사용되는 방법을 설명하기 위한 것입니다.\n\nFlutter 앱에서 플랫폼별 코드를 실행하는 메서드를 만들어보세요:\n\n```js\nimport 'package:flutter/services.dart';\n\nFuture\u003cString\u003e getCurrentLocation() async {\n  const platform = MethodChannel('your_channel_name');\n  try {\n    final String result = await platform.invokeMethod('getCurrentLocation');\n    return result;\n  } catch (e) {\n    return 'Failed to get location: $e';\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플랫폼별 언어로 위치 검색 기능을 구현해보세요:\n\n```js\nclass MainActivity : FlutterActivity() {\n    private val CHANNEL = \"your_channel_name\"\n\n    override fun configureFlutterEngine(flutterEngine: FlutterEngine) {\n        super.configureFlutterEngine(flutterEngine)\n        MethodChannel(flutterEngine.dartExecutor.binaryMessenger, CHANNEL).setMethodCallHandler { call, result -\u003e\n            if (call.method == \"getCurrentLocation\") {\n                // 백그라운드에서 위치를 검색합니다\n                val location = getLocation()\n                result.success(location)\n            } else {\n                result.notImplemented()\n            }\n        }\n    }\n\n    private fun getLocation(): String {\n        // 안드로이드 특화 API를 사용하여 위치를 가져옵니다\n        // ...\n        return \"위도: 20.5937, 경도: 78.9629\"\n    }\n}\n```\n\n```js\nimport UIKit\nimport Flutter\n\n@UIApplicationMain\n@objc class AppDelegate: FlutterAppDelegate {\n    let CHANNEL = \"your_channel_name\"\n\n    override func application(\n        _ application: UIApplication,\n        didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?\n    ) -\u003e Bool {\n        let controller = window?.rootViewController as! FlutterViewController\n        let channel = FlutterMethodChannel(name: CHANNEL, binaryMessenger: controller.binaryMessenger)\n        channel.setMethodCallHandler { [weak self] call, result in\n            if call.method == \"getCurrentLocation\" {\n                // 백그라운드에서 위치를 검색합니다\n                let location = self?.getLocation() ?? \"\"\n                result(location)\n            } else {\n                result(FlutterMethodNotImplemented)\n            }\n        }\n\n        GeneratedPluginRegistrant.register(with: self)\n        return super.application(application, didFinishLaunchingWithOptions: launchOptions)\n    }\n\n    private func getLocation() -\u003e String {\n        // iOS 특화 API를 사용하여 위치를 가져옵니다\n        // ...\n        return \"위도: 123.456, 경도: 78.901\"\n    }\n}\n```\n\nWorkManager(안드로이드) 및 BackgroundFetch(iOS)에서 사용하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n주어진 플랫폼에서 백그라운드 작업을 보다 효과적으로 처리하기 위해 WorkManager(안드로이드)와 BackgroundFetch(iOS)와 같은 플랫폼별 라이브러리를 사용할 수 있습니다. 이러한 라이브러리에는 작업 스케줄링, 반복 및 네트워크 의존 프로세스 관리, 그리고 작업이 완료되었을 때 Flutter 앱에 콜백을 제공하는 기능이 포함되어 있습니다.\n\n만약 이 방법을 보여주기 위해 서버에서 데이터를 정기적으로 다운로드하는 백그라운드 활동을 예약하려고 한다면 다음과 같이 할 수 있습니다.\n\nWorkManager를 사용하기 위해 android/app/build.gradle 파일에 필요한 종속성을 추가하세요:\n\n```js\ndependencies {\n    def work_version = \"2.6.0\"\n\n    implementation \"androidx.work:work-runtime:$work_version\"\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n워커 클래스를 만들어 백그라운드 작업을 설명해 보겠습니다:\n\n```js\n// 플러터 측\nimport 'package:flutter_background_fetch/flutter_background_fetch.dart';\n\nvoid initBackgroundFetch() {\n  FlutterBackgroundFetch.configure(\n    minimumFetchInterval: 15,\n    stopOnTerminate: false,\n    startOnBoot: true,\n    enableHeadless: true,\n    requiresBatteryNotLow: false,\n    requiresCharging: false,\n    requiresStorageNotLow: false,\n    requiresDeviceIdle: false,\n    requiredNetworkType: NetworkType.NONE,\n  );\n  FlutterBackgroundFetch.registerHeadlessTask(backgroundFetchHeadlessTask);\n}\n\nvoid backgroundFetchHeadlessTask(String taskId) async {\n  // 여기서 시간이 많이 소요되는 작업(예: 데이터 가져오기)을 수행합니다\n  // ...\n\n  FlutterBackgroundFetch.finish(taskId);\n}\n```\n\nBackgroundFetch를 사용하려면 pubspec.yaml 파일에 다음 종속성을 추가하세요:\n\n```js\ndependencies:\n  background_fetch: ^0.9.0\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 백그라운드 작업을 구현해보세요:\n\n```js\n// 플러터 측\nimport 'package:flutter/material.dart';\nimport 'package:background_fetch/background_fetch.dart';\n\nvoid main() {\n  runApp(MyApp());\n  initBackgroundFetch();\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text('Flutter에서 백그라운드 작업'),\n        ),\n        body: Center(\n          child: Text('백그라운드 작업 실행 중...'),\n        ),\n      ),\n    );\n  }\n}\n\nvoid initBackgroundFetch() {\n  BackgroundFetch.configure(\n    BackgroundFetchConfig(\n      minimumFetchInterval: 15,\n      stopOnTerminate: false,\n      startOnBoot: true,\n      enableHeadless: true,\n    ),\n    (String taskId) async {\n      // 여기서 시간이 많이 소요되는 작업(예: 데이터 가져오기) 수행하기\n      // ...\n\n      BackgroundFetch.finish(taskId);\n    },\n  );\n}\n```\n\n## 타이머:\n\n항상 번거로운 백그라운드 작업을 실행할 필요는 없을 수 있습니다. 대신 플러터 프로그램에 내장된 타이머를 활용할 수도 있습니다. Dart 프로그래밍 언어에는 백그라운드 작업을 계획하고 수행할 수 있는 Timer 클래스가 함께 제공되며, 플랫폼별 추가 기능이 필요하지 않은 프로젝트에 적합합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예시를 위해, 플러터 앱에서 매 시간마다 공지를 표시하고 싶다고 가정해 봅시다.\n\n```js\nimport 'dart:async';\nimport 'package:flutter/material.dart';\nimport 'package:flutter_local_notifications/flutter_local_notifications.dart';\n\nvoid main() {\n  runApp(MyApp());\n  scheduleNotifications();\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text('플러터에서 백그라운드 작업하기'),\n        ),\n        body: Center(\n          child: Text('백그라운드 작업 실행 중...'),\n        ),\n      ),\n    );\n  }\n}\n\nvoid scheduleNotifications() {\n  Timer.periodic(Duration(hours: 1), (Timer timer) {\n    showNotification();\n  });\n}\n\nvoid showNotification() {\n  FlutterLocalNotificationsPlugin flutterLocalNotificationsPlugin =\n      FlutterLocalNotificationsPlugin();\n  // 플러그인 설정 초기화\n  // ...\n\n  flutterLocalNotificationsPlugin.show(\n    0,\n    '매 시간 알림',\n    '매 시간 트리거되는 알림입니다.',\n    NotificationDetails(\n      android: AndroidNotificationDetails(\n        '채널 ID',\n        '채널 이름',\n        '채널 설명',\n      ),\n      iOS: IOSNotificationDetails(),\n    ),\n  );\n}\n```\n\n## Firebase Cloud Messaging (FCM):\n\nFirebase Cloud Messaging (FCM)은 서버 이벤트에 의해 유발된 경보를 보내거나 활동을 수행하는 백그라운드 활동에 도움이 될 수 있습니다. 플러터 앱이 열리지 않거나 사용되지 않아도 FCM을 통해 서버에서 메시지를 전송할 수 있습니다. 이 신호에 응답하고 필요한 백그라운드 작업을 수행할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예제를 기준으로 FCM 알림을 수신할 때마다 백그라운드 프로세스를 실행하려고 한다고 가정해 봅시다.\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:firebase_messaging/firebase_messaging.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text('Flutter에서 백그라운드 작업'),\n        ),\n        body: Center(\n          child: Text('백그라운드 작업 실행 중...'),\n        ),\n      ),\n    );\n  }\n}\n\nvoid initFirebaseMessaging() {\n  FirebaseMessaging messaging = FirebaseMessaging.instance;\n  messaging.configure(\n    onMessage: (message) {\n      // 메시지를 수신할 때 백그라운드 작업 수행\n      // ...\n      return;\n    },\n    onResume: (message) {\n      // 앱이 백그라운드에서 다시 활성화될 때 백그라운드 작업 수행\n      // ...\n      return;\n    },\n    onLaunch: (message) {\n      // 앱이 종료된 상태에서 다시 실행될 때 백그라운드 작업 수행\n      // ...\n      return;\n    },\n  );\n}\n```\n\n## 결론:\n\nFlutter 애플리케이션의 효율성을 향상시키는 중요한 구성 요소 중 하나는 백그라운드 활동입니다. 시간이 오래 걸리는 작업을 백그라운드에서 실행함으로써 원활한 사용자 경험을 제공하고 UI가 느려지는 것을 방지할 수 있습니다. 이 블로그 글에서는 아이솔레이트와 Flutter Background Fetch 패키지의 사용법을 살펴보았습니다. 이러한 전략을 Flutter 애플리케이션에 구현하여 앱의 속도를 향상시키고 우수한 사용자 경험을 제공할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앱 기능과 효율성을 균형 있게 유지하기 위해 백그라운드 작업을 구현할 때 장치 자원, 배터리 수명 및 네트워크 이용량과 같은 요소를 고려하는 것이 중요합니다.\n\n## 코딩 즐기세요!!!…","ogImage":{"url":"/assets/img/2024-06-21-FlutterBackgroundTasksImprovingAppPerformance_0.png"},"coverImage":"/assets/img/2024-06-21-FlutterBackgroundTasksImprovingAppPerformance_0.png","tag":["Tech"],"readingTime":11},{"title":"Robot 패턴을 사용한 Flutter 통합 테스트 작성법  이제껏 경험하지 못한 방법","description":"","date":"2024-06-21 23:30","slug":"2024-06-21-HowtowriteintegrationtestsinFlutterlikenootherusingtheRobotPattern","content":"\n\n플러터에서 통합 테스트를 작성하고 싶다면, 더 이상 찾을 필요가 없어요! 전문가처럼 로봇 패턴을 사용하여 통합 테스트를 작성하는 방법을 정확히 보여드릴 거예요.\n\n튜토리얼을 비디오 형식으로 따라가시길 원하신다면, 이 비디오를 확인해주세요.\n\n바로 시작해봅시다!\n\n통합 테스트를 작성하기 위해서는 먼저 무엇이 통합 테스트인지 배워야 해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n통합 테스트는 소프트웨어의 다른 모듈을 그룹으로 테스트하는 데 사용됩니다. 이러한 테스트는 종단 간 (End to End, E2E) 테스트로도 알려져 있습니다.\n\n우리의 경우, 앱의 두 모듈을 그룹으로 테스트할 것입니다. 로그인 모듈과 홈 모듈입니다.\n\n이것을 코드 따라하기 튜토리얼로 만들기로 했기 때문에, 여기에 템플릿을 업로드했습니다: [링크](https://github.com/Coffiie/personal_projects/tree/develop/code_along/robot_testing_flutter_gh)\n\n프로젝트를 클론하고 저와 함께 단계별로 통합 테스트를 구현해보세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 Medium에서 50명의 팔로워를 얻으면, GitHub에서 이를 위한 통합 플로우와 소스 코드를 모두 공개할 거에요!\n\n그러기 전에 시작하기 전에, 테스트를 작성할 앱과 테스트를 구현할 패턴에 대해 살펴봐요.\n\n저희 앱은 \"1234\" 앱이에요. 이 마법의 숫자로 홈페이지에 접속할 수 있어요.\n\n하지만 잘못된 자격 증명을 입력하면, 화면 하단에 \"잘못된 자격 증명\" 메시지가 표시되는 스낵 바가 나타나요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-21-HowtowriteintegrationtestsinFlutterlikenootherusingtheRobotPattern_0.png)\n\n로봇 패턴은 일반 사용자가 하는 것과 같은 동작을 로봇을 통해 수행하여 통합 테스트를 작성하는 방법입니다.\n\n이는 우리가 테스트하는 내용에 집중하도록 하며 어떻게 테스트하는지보다는 무엇을 테스트하는지에 중점을 두도록 합니다. 또한 코드를 더 읽기 쉽고 재사용 가능하도록 만듭니다.\n\n이제 통합 테스트, 앱 및 로봇 패턴에 대한 일반적인 이해가 생겼으므로 통합 테스트 작성을 시작할 수 있습니다!\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 단계 1: 통합 테스트 패키지 가져오기\n\n![이미지](/assets/img/2024-06-21-HowtowriteintegrationtestsinFlutterlikenootherusingtheRobotPattern_1.png)\n\n## 단계 2: 로그인 로봇 생성\n\nFlutter 프로젝트의 루트에 integration_test라는 폴더를 만든 다음 그 폴더 안에 robots라는 폴더를 만드세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리의 모든 통합 테스트 플로우는 integration_test 폴더의 하위로 이동하게 될 것이고, 우리의 로봇들은 robots 폴더의 하위로 이동하게 될 거에요.\n\n이제 robots 디렉토리 안에 robot을 만들어보고 login_robot.dart라고 이름 짓도록 해요.\n\n이 파일 안에는 LoginRobot 클래스를 구현할 거고, 이 클래스는 테스트 프레임워크와 상호 작용하며 사용자가 하는 동일한 작업을 수행하여 로그인 화면을 테스트할 것입니다.\n\n그래서 이제 우리는 이렇게 클래스에 WidgetTester 의존성을 추가할 수 있어요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image 1](/assets/img/2024-06-21-HowtowriteintegrationtestsinFlutterlikenootherusingtheRobotPattern_2.png)\n\n## Step 3: 분석 로그인 페이지\n\n소스 코드를 살펴보면, WidgetKeys 클래스에 할당된 여러 위젯을 볼 수 있습니다. 이러한 키는 테스트 프레임워크에서 위젯을 식별하는 데 유용하며, 테스트에서 위젯을 찾을 때 유리합니다.\n\n![Image 2](/assets/img/2024-06-21-HowtowriteintegrationtestsinFlutterlikenootherusingtheRobotPattern_3.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 단계 4: 로그인 로봇 구현\n\nLoginRobot 클래스에 다음 메서드를 추가합니다.\n\n![이미지](/assets/img/2024-06-21-HowtowriteintegrationtestsinFlutterlikenootherusingtheRobotPattern_4.png)\n\n- verify(): 로그인 화면에 존재하는지 테스트합니다.\n- enterPassword, enterUsername 및 tapLoginButton은 실명있는 메서드입니다.\n- verifyError(): 잘못된 자격 증명을 입력했을 때 나타나는 스낵 바를 테스트하는 데 사용됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 단계 5: 인증되지 않은 플로우 생성\n\n이 앱에는 2가지 주요 플로우가 있습니다.\n\n하나는 인증되지 않은 플로우이며, 여기서 사용자는 로그인할 수 없으며 잘못된 자격 증명을 입력한 사용자에게 스낵 바가 표시됩니다.\n\n다른 플로우는 올바른 자격 증명으로 인증하고 홈 화면으로 이동할 수 있는 플로우입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이번 튜토리얼은 간단하게 유지하기 위해 인증되지 않은 흐름에만 초점을 맞추겠습니다.\n\n구현을 시작하려면 integration_test 폴더에 e2e_unauth_test.dart라는 파일을 만들어주세요.\n\n먼저 main() 메서드를 생성해주세요. 그런 다음 IntegrationTestWidgetsFlutterBinding.ensureInitialized()를 호출하여 통합 테스트 프레임워크가 준비되었는지 확인해주세요.\n\n이 작업이 완료되면 LoginRobot 메서드를 호출하여 테스트 흐름을 신속하게 구현할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-21-HowtowriteintegrationtestsinFlutterlikenootherusingtheRobotPattern_5.png)\n\n3번째 줄에 import를 주목하세요. 라인 14에서 Myapp 생성자를 직관적으로 호출하여 개발한 실제 앱을 펌핑할 수 있습니다.\n\n## 단계 6: 테스트 실행\n\n타다! 실행 옵션을 누름으로써 테스트를 실행하고 통과하는 것을 관찰할 수 있습니다! \n앱을 더 견고하게 만들어줄 코드를 성공적으로 작성하였습니다!\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 명심해야 할 몇 가지 사항\n\n- 통합 테스트는 소프트웨어의 다른 모듈을 그룹으로 테스트하는 데 사용됩니다. 또한 엔드 투 엔드 (E2E) 테스트로도 알려져 있습니다.\n- 로봇 패턴에서는 각 화면에 대한 로봇을 작성하고 위젯 테스터를 사용하여 사용자가 하는 것과 유사한 테스트를 작성합니다.\n- 로봇을 구현한 후에는 모든 구현이 로봇 내부에 추상화되어 있으므로 특정 작업을 실행해야 할 때마다 그들의 메소드를 호출하기만 하면 복잡한 흐름을 쉽게 만들 수 있습니다.\n\n## 재미있는 활동\n\n인증된 흐름을 구현해야 할 마지막 흐름이 남아 있습니다. 이를 만들고 완료되면 LinkedIn에서 DM(Direct Message)을 보내주세요. 당신의 솔루션을 보는 것을 기대할게요! :)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 만약 튜토리얼이 마음에 드셨다면...\n\n저를 여기와 제 소셜 미디어 계정에서 팔로우해주세요!\n\n팔로우하기:\n\nYoutube: [링크](https://www.youtube.com/channel/UCD2BEqL0wC7leFKm4i9_aRg)\nLinkedIn: [링크](https://www.linkedin.com/in/rawahamuhammad/)\nGithub: [링크](https://github.com/coffiie)\nMedium: Rawaha Muhammad\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n런타임 스니펫(Runtime Snippets)을 따라하세요 (조각처럼 작은 플러터/다트 튜토리얼)\n\nYoutube: https://www.youtube.com/channel/UCD2BEqL0wC7leFKm4i9_aRg\nLinkedIn: https://www.linkedin.com/company/100042850\nTwitter: https://twitter.com/runtimesnippets","ogImage":{"url":"/assets/img/2024-06-21-HowtowriteintegrationtestsinFlutterlikenootherusingtheRobotPattern_0.png"},"coverImage":"/assets/img/2024-06-21-HowtowriteintegrationtestsinFlutterlikenootherusingtheRobotPattern_0.png","tag":["Tech"],"readingTime":5},{"title":"Flutter 상태 관리 비교 Provider, BLoC, GetX, Riverpod, GetIt, 그리고 MobX","description":"","date":"2024-06-21 23:25","slug":"2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX","content":"\n\n본 기사에서는 상태 관리의 일반적인 개요를 검토한 후 가장 흥미로운 상태 관리 방법인 Provider, BLoC, GetX, Riverpod, GetIt, 그리고 MobX를 살펴보겠습니다.\n\n![image](/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_0.png)\n\n# 일반적인 개요\n\n모바일 앱을 개발하는 동안, 화면 간이나 전체 앱을 통해 앱 상태를 공유해야 하는 시점이 찾아옵니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_1.png\" /\u003e\n\n이 예에서는 MyLoginScreen, MyCatalog 및 MyCart의 3 개 화면이 있습니다. MyCatalog에서는 제품이 이미 쇼핑 카트에 있는지 확인하기 위해 애플리케이션의 상태를 알아야 합니다. 그리고 MyCart에서는 추가된 모든 제품과 총 구매액을 보고 싶습니다. 두 화면 모두 카트의 상태를 알아야 합니다. 이것은 애플리케이션 상태의 예시이며, 나중에 자세히 검토할 예정입니다.\n\n- Android 또는 iOS 개발에서 추측할 수 있는 많은 가정이 Flutter에는 해당하지 않습니다. 예를 들어, Flutter에서 UI의 일부를 수정하는 대신 처음부터 다시 빌드하는 것은 괜찮습니다. Flutter는 이를 수행할 만큼 충분히 빠릅니다. 필요하다면 매 프레임마다 가능합니다.\n- Flutter는 선언적입니다. 이것은 Flutter가 현재 상태 애플리케이션을 반영하기 위해 UI를 빌드한다는 것을 의미합니다.\n- 예를 들어 앱 상태가 변경되면, 예를 들어 설정 화면이 있고 사용자가 스위치를 누르는 경우, 그것은 상태를 변경하고 이것은 UI 디자인을 트리거합니다. 이것은 명령형 UI 변경이 아니며, 변경되는 것은 상태이며 UI는 처음부터 다시 빌드됩니다.\n- UI 프로그래밍의 선언적 스타일에는 많은 이점이 있습니다. 모든 상태에 대해 UI가 어떻게 보이는지 설명하고 한 번만 설명하면 됩니다.\n\n\u003cimg src=\"/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_2.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Transient State와 앱 상태의 차이점\n\n![이미지](/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_3.png)\n\n앱 상태는 응용 프로그램이 실행 중일 때 메모리에 있는 모든 요소를 포함합니다. 이는 자산, 변수, 애니메이션 상태, 글ꔼ자 등을 포함합니다.\n\n우리가 관리하는 상태는 일시적인 상태와 앱 상태로 나뉠 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 일시적 상태\n\n단일 위젯을 포함할 수 있는 상태입니다. 예를 들어:\n\n- 위젯에서 현재 페이지\n- 애니메이션의 진행 상황\n- BottomNavigationBar에서 선택한 탭\n\n다시 말해, 이 유형의 상태에서는 상태 관리 기술을 사용할 필요가 없습니다. 필요한 것은 StatefulWidget뿐입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 앱 상태\n\n당연히, 이것은 일시적이지 않은 상태이며 응용 프로그램의 여러 부분에서 공유하고 사용자 세션 사이에서 유지하고 싶은 상태입니다. 응용 프로그램 상태의 예시:\n\n- 사용자의 선호도\n- 로그인 정보\n- 전자 상거래 응용 프로그램의 쇼핑 카트\n\n여기서 우리는 상태 관리가 필요할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희가 모든 상태 관리를 위해 개발할 예제를 보여드리겠습니다.\n\n![이미지](/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_4.png)\n\n# Provider\n\n만약 플러터를 처음 시작하시는 초보자이고 다른 접근 방식을 선택할 확실한 이유가 없다면, 아마도 이 접근 방식부터 시작하는 것이 좋을 것입니다. Provider 패키지는 이해하기 쉽고 코드 양이 많지 않습니다. 또한 다른 접근 방식에서 사용되는 개념을 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앱에는 MyCart 및 MyCatalog 위젯으로 나타낸 카탈로그 및 장바구니라는 두 개의 별도 화면이 있습니다. 카탈로그 화면에는 앱 바와 항목 목록이 포함되어 있습니다.\n\n우리는 몇 가지 위젯이 있습니다. 그 중 많은 위젯이 다른 위치에 \"소속된\" 상태에 액세스해야 합니다. 예를 들어, 카탈로그의 각 항목은 장바구니에 추가할 수 있습니다. 현재 표시된 항목이 이미 장바구니에 있는지 확인하려고 할 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이로써 첫 번째 질문으로 이어집니다: 장바구니의 현재 상태를 어디에 두어야 할까요?\n\n- 플러터에서는 상태를 사용하는 위젯 위에 상태를 두는 것이 합리적으로 보입니다. 왜 그럴까요? 플러터와 같은 선언형 프레임워크에서는 UI를 변경하려면 다시 생성해야 합니다. 다시 말해, 외부에서 메서드를 호출하여 위젯을 명령형으로 변경하는 것은 어렵습니다.\n- 현재 UI 상태를 고려하고 새 데이터를 적용해야 합니다. 이런 방식으로 버그를 피하기 어렵습니다.\n- 플러터에서는 컨텐츠가 변경될 때마다 새 위젯을 빌드합니다.\n\n이전 질문에 대한 답변은 앱 수준에 장바구니 상태를 두어야 합니다. 이렇게 하면 MyCart와 MyCatalog에서 상태에 액세스할 수 있습니다. MyCatalog 레벨에 상태를 둔다면 MyCart에서 액세스할 수 없습니다. 플러터에서는 불필요한 UI 다시 빌드를 피하기 위해 가능한 한 앱 상태를 위젯 트리의 낮은 위치에 두는 것이 좋은 실천법입니다.\n\n![이미지](/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_7.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 코드를 리뷰해 봅시다.\n\n먼저, 우리에게는 3가지 상태가 있습니다: 초기 상태, 로딩 상태, 성공 상태.\n\n```js\nenum Status {\n  initial,\n  loading,\n  success,\n}\n```\n\nProvider를 사용할 때 이해해야 할 3가지 개념이 있습니다: ChangeNotifier, ChangeNotifierProvider 및 Consumer.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## ChangeNotifier\n\nChangeNotifier은 Flutter SDK에 포함된 간단한 클래스로, 청취자에게 변경 알림을 제공합니다. 즉, 무언가가 ChangeNotifier이면 해당 변경 사항에 구독할 수 있습니다.\n\nprovider에서 ChangeNotifier는 응용 프로그램 상태를 캡슐화하는 한 가지 방법입니다. 매우 간단한 앱의 경우에는 하나의 ChangeNotifier로 작업할 수 있습니다. 복잡한 앱의 경우 여러 가지 모델이 있고, 따라서 여러 개의 ChangeNotifier가 있을 것입니다.\n\nChangeNotifier에 특정한 유일한 코드는 notifyListeners()를 호출하는 부분입니다. 이 메서드를 호출하여 모델에 변경 사항이 있을 때마다 UI가 변경될 수 있는지 확인하세요. CartModel에서의 나머지 코드는 모델 자체와 비즈니스 로직입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리의 DataProvider 클래스를 확인해주세요:\n\n```js\nclass DataProvider extends ChangeNotifier {\n  /// 데이터 공급자의 내부적인, 비공개 상태입니다.\n  Status _state = Status.initial;\n\n  /// 데이터 공급자의 상태입니다.\n  Status get state =\u003e _state;\n\n  /// 데이터 공급자의 상태를 업데이트합니다. 데이터 공급자를 외부에서 수정하는 유일한 방법입니다.\n  void fecthData() async {\n    _state = Status.loading;\n    // 이 호출은 해당 모델을 듣고 있는 위젯에게 rebuild해야 함을 알립니다.\n    notifyListeners();\n\n    await Future.delayed(const Duration(seconds: 2));\n\n    _state = Status.success;\n    notifyListeners();\n  }\n}\n```\n\n## ChangeNotifierProvider\n\nChangeNotifierProvider은 ChangeNotifier 인스턴스를 후손들에게 제공하는 위젯입니다. provider 패키지에서 제공됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nChangeNotifierProvider를 어디에 배치해야 하는지 이미 알고 계시네요: 액세스해야 하는 위젯들 위에요. CartModel의 경우, MyCart와 MyCatalog 둘 다 위쪽에 어딘가에 있어야 합니다.\n\n우리 예제에서 ChangeNotifierProvider와 HomeProvider (UI)를 자식으로 하는 ProviderPage가 있습니다.\n\n```js\nclass ProviderPage extends StatelessWidget {\n  static const route = 'provider-page';\n\n  const ProviderPage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return ChangeNotifierProvider(\n      create: (context) =\u003e DataProvider(),\n      child: const HomeProvider(),\n    );\n  }\n}\n```\n\n## Consumer\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n요소별로 Translation을 제공합니다:\n\n\nConsumer 위젯을 가능한 깊이까지 Tree 안에 두는 것이 최선의 방법입니다. 어딘가의 세부 사항이 변경되었을 때 UI의 큰 부분을 다시 빌드하고 싶지 않으니까요.\n\n```dart\nclass HomeProvider extends StatefulWidget {\n  const HomeProvider({super.key});\n\n  @override\n  State\u003cHomeProvider\u003e createState() =\u003e _HomeProviderState();\n}\n\nclass _HomeProviderState extends State\u003cHomeProvider\u003e {\n  late DataProvider provider;\n\n  @override\n  void initState() {\n    provider = Provider.of\u003cDataProvider\u003e(context, listen: false);\n    super.initState();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Provider Page')),\n      // Consumer 위젯을 가능한 깊이까지 Tree 안에 두는 것이 최선의 방법입니다.\n      // 어딘가의 세부 사항이 변경되었을 때 UI의 큰 부분을 다시 빌드하고 싶지 않으니까요.\n      body: Consumer\u003cDataProvider\u003e(\n        builder: (context, data, child) {\n          if (data.state == Status.initial) {\n            return const Center(child: Text('Press the Button'));\n          }\n          if (data.state == Status.loading) {\n            return const Center(child: CircularProgressIndicator());\n          }\n          if (data.state == Status.success) {\n            return const Center(child: Text('Success'));\n          }\n          return Container();\n        },\n      ),\n      floatingActionButton: Column(\n        crossAxisAlignment: CrossAxisAlignment.end,\n        mainAxisAlignment: MainAxisAlignment.end,\n        children: \u003cWidget\u003e[\n          FloatingActionButton(\n            child: const Icon(Icons.play_arrow),\n            onPressed: () =\u003e provider.fecthData(),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n그 결과는 다음과 같습니다:\n\n![이미지](/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_8.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 장점\n\n- Flutter를 처음 사용하는 경우 시작해야 할 접근 방식입니다. 이해하기 쉽고 많은 코드를 사용하지 않습니다.\n- Devtool 친화적 — Provider를 사용하면 애플리케이션의 상태가 Flutter devtool에서 볼 수 있습니다.\n- 데이터 할당 및 자원 (데이터) 해제를 간소화합니다.\n\n## 단점\n\n- 불필요한 업데이트를 실수로 호출할 수 있습니다. 객체의 상태가 변경되었을 때마다 업데이트를 트리거할 필요는 없습니다. 그러나 Provider를 사용하는 경우 변경이 발생할 때마다 항상 업데이트를 트리거합니다.\n- 확장성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# BLoC\n\n- 이 패키지의 목적은 UI와 비즈니스 로직을 분리하는 것을 용이하게 하는 것입니다.\n- 이 패키지는 패턴의 반응적 부분을 추상화하여 개발자가 비즈니스 로직 작성에 집중할 수 있도록 합니다.\n- Bloc은 이벤트를 기반으로 한 상태 변경을 트리거하는 메서드 대신 메서드 대신 사용하는 고급 클래스입니다. Bloc은 이벤트를 수신하고 수신된 이벤트를 발생한 이벤트로 변환합니다.\n\n![image](/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_9.png)\n\n이 부분을 좀 더 잘 이해하기 위해 이벤트가 UI에서 추가되고 BLoC에서 이를 처리하고 이러한 이벤트에 대한 상태 변경으로 응답합니다. bloc 라이브러리를 사용하면 Presentation, Business Logic 및 Data가 세 개의 레이어로 나뉘도록 응용 프로그램을 분리할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n상태 변경은 이벤트가 추가될 때 블록이 시작되며 onEvent을 트리거합니다. 그런 다음, 이벤트는 EventTransformer를 통해 흘러갑니다. 기본적으로 각 이벤트는 병렬로 처리되지만 사용자 정의 EventTransformer를 제공하여 들어오는 이벤트 스트림을 조작할 수 있습니다. 해당 이벤트 유형에 대해 등록된 모든 EventHandlers는 들어오는 이벤트와 함께 호출됩니다. 각 EventHandler는 이벤트에 대한 응답으로 제로 이상의 상태를 발행하는 책임이 있습니다. 마지막으로, 상태가 업데이트되기 직전에 onTransition이 호출되며 현재 상태, 이벤트 및 다음 상태를 포함합니다.\n\n![이미지](/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_10.png)\n\nBLoC 구현에서는 data_bloc, data_event 및 data_state 총 3개의 파일이 필요합니다.\n\n![이미지](/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_11.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n블록 상태에서는 세 가지 상태를 가질 것입니다: 초기, 로딩 및 성공.\n\n```js\npart of 'data_bloc.dart';\n\n\nabstract class DataState {}\n\nclass Initial extends DataState {}\n\nclass Loading extends DataState {}\n\nclass Success extends DataState {}\n```\n\n또한, 블록 이벤트에서는 FetchDataEvent만 사용할 것입니다.\n\n```js\npart of 'data_bloc.dart';\n\nabstract class DataEvent {}\n\nclass FetchDataEvent extends DataEvent {}\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nIn DataBloc, when the FetchDataEvent is added, the _onFetchDataEvent method is triggered.\n\nimport 'package:flutter_bloc/flutter_bloc.dart';\n\npart 'data_event.dart';\npart 'data_state.dart';\n\nclass DataBloc extends Bloc\u003cDataEvent, DataState\u003e {\n  DataBloc() : super(Initial()) {\n    on\u003cFetchDataEvent\u003e(_onFetchDataEvent);\n  }\n\n  void _onFetchDataEvent(\n    FetchDataEvent event,\n    Emitter\u003cDataState\u003e emit,\n  ) async {\n    emit(Loading());\n    await Future.delayed(const Duration(seconds: 2));\n    emit(Success());\n  }\n}\n\nIn this example, we have a BlocPage that includes a BlocProvider with HomeBloc as a child.\n\nclass BlocPage extends StatelessWidget {\n  static const route = 'bloc-page';\n\n  const BlocPage({Key key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return BlocProvider(\n      create: (context) =\u003e DataBloc(),\n      child: const HomeBloc(),\n    );\n  }\n}\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nclass HomeBloc extends StatefulWidget {\n  const HomeBloc({super.key});\n\n  @override\n  State\u003cHomeBloc\u003e createState() =\u003e _HomeBlocState();\n}\n\nclass _HomeBlocState extends State\u003cHomeBloc\u003e {\n  late DataBloc bloc;\n\n  @override\n  void initState() {\n    bloc = BlocProvider.of\u003cDataBloc\u003e(context);\n    super.initState();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('BLoC 페이지')),\n      body: BlocBuilder\u003cDataBloc, DataState\u003e(\n        builder: (context, state) {\n          if (state is Initial) {\n            return const Center(child: Text('버튼을 눌러주세요'));\n          }\n          if (state is Loading) {\n            return const Center(child: CircularProgressIndicator());\n          }\n          if (state is Success) {\n            return const Center(child: Text('성공'));\n          }\n          return Container();\n        },\n      ),\n      floatingActionButton: Column(\n        crossAxisAlignment: CrossAxisAlignment.end,\n        mainAxisAlignment: MainAxisAlignment.end,\n        children: \u003cWidget\u003e[\n          FloatingActionButton(\n            child: const Icon(Icons.play_arrow),\n            onPressed: () =\u003e bloc.add(FetchDataEvent()),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n그리고 Bloc 결과입니다:\n\n\u003cimg src=\"/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_12.png\" /\u003e\n\n## 장점\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 애플리케이션의 상태를 언제든지 파악할 수 있습니다.\n- 앱이 적절하게 응답하는지 확인하기 위해 모든 케이스를 쉽게 테스트할 수 있습니다.\n- 애플리케이션에서 모든 사용자 상호 작용을 기록하여 데이터 기반 결정을 내릴 수 있습니다.\n- 빠르고 반응성 있는 앱을 개발할 수 있습니다.\n- 대규모 데이터 크기에 대해 더 나은 성능을 제공합니다.\n\n## 단점\n\n- 대형 애플리케이션을 가지고 있을 때만 효과적입니다.\n- 두 방향으로 스트림을 사용해야 하므로 Provider보다 더 많은 보일러플레이트가 발생할 수 있습니다.\n- 복잡한 시나리오에서는 너무 제한적일 수 있으며 하나의 입력과 출력만 다루는 BLoC를 생성할 수 있습니다.\n- 특히 앱의 여러 부분에 유사한 비즈니스 로직을 구현해야할 경우 코드 중복으로 이어질 수 있습니다.\n\n# GetX\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 플러터에 대한 가벼우면서도 강력한 솔루션입니다. 고성능 상태 관리, 스마트한 의존성 주입, 라우트 관리를 빠르고 실용적으로 결합합니다.\n- 성능과 자원 최소 소비에 중점을 둡니다. GetX는 Streams나 ChangeNotifier를 사용하지 않습니다.\n- 사용하기 쉽고 즐거운 구문을 사용합니다.\n- 뷰, 표현 로직, 비즈니스 로직, 의존성 주입, 네비게이션의 완전한 분리를 허용합니다.\n\n다음 이미지에서 모든 GetX 기능을 확인할 수 있습니다:\n\n![GetX Functions](/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_13.png)\n\n하지만 우리에게 가장 중요한 것은 반응형 상태 관리자입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 반응성 상태 관리자\n\n반응형 프로그래밍은 복잡하다고 말리기 때문에 많은 사람들을 멀리하곤 합니다. GetX는 반응형 프로그래밍을 꽤 간단하게 만들어 줍니다:\n\n- StreamControllers를 만들 필요가 없습니다.\n- 각 변수마다 StreamBuilder를 만들 필요가 없습니다.\n- 각 상태마다 클래스를 만들 필요가 없습니다.\n- 초기 값에 대한 get을 만들 필요가 없습니다.\n\n이름 변수가 있고 이 변수를 변경할 때마다 사용하는 모든 위젯이 자동으로 변경되기를 원한다고 상상해 봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기 당신의 계수 변수가 있어요:\n\n```js\nvar name = 'Jonatas Borges';\n```\n\n이를 관찰 가능하도록 만들기 위해서는 그 뒤에 \".obs\"를 추가하기만 하면 돼요:\n\n```js\nvar name = 'Jonatas Borges'.obs;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nUI에서 해당 값이 표시되고 값이 변경될 때 화면을 업데이트하려면 다음과 같이 하면 됩니다:\n\n```js\nObx(() =\u003e Text(\"${controller.name}\"));\n```\n\n단순합니다.\n\n이제 코드로 넘어갑니다. GetX에서 Controller가 정의됩니다. 이 경우 GetxController를 확장한 Controller 클래스를 만듭니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\n열거형 Status {\n  초기,\n  로딩,\n  성공,\n}\n```\n\n```js\r\nclass Controller extends GetxController {\n  // GetX는 반응형이기 때문에 변수가 변경되면 자동으로 화면에서 변경됩니다.\n  // 변수 앞에 \".obs\"를 추가하기만 하면 이미 반응형입니다.\n  var state = Status.initial.obs;\n\n  /// 컨트롤러의 상태를 업데이트합니다. 이 방법이 컨트롤러를 외부에서 수정하는 유일한 방법입니다.\n  void fetchData() async {\n    state.value = Status.loading;\n    //update();\n\n    await Future.delayed(const Duration(seconds: 2));\n\n    state.value = Status.success;\n  }\n}\r\n```\n\nUI에서 우리는 GetXPage가 있습니다. 그 안에는 간단한 HomeGetX 위젯이 자식으로 있습니다. 이 방식으로 정의되었는데, Provider 및 Bloc과의 차이를 보려고 했습니다. Provider나 Bloc을 자식 위젯에 제공하기 위해 ChangeNotifierProvider나 BlocProvider의 부모 위젯을 정의해야 했던 과정과의 차이점을 볼 수 있습니다.\n\n```js\r\nclass GetXPage extends StatelessWidget {\n  static const route = 'getx-page';\n\n  const GetXPage({key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return const HomeGetX();\n  }\n}\r\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nclass HomeGetX extends StatefulWidget {\n  const HomeGetX({super.key});\n\n  @override\n  State\u003cHomeGetX\u003e createState() =\u003e _HomeGetXState();\n}\n\nclass _HomeGetXState extends State\u003cHomeGetX\u003e {\n  late Controller c;\n\n  @override\n  void initState() {\n    c = Get.put(Controller());\n    super.initState();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('GetX Page')),\n      //최상위에 Consumer 위젯을 가능한 깊게 두는 것이 가장 좋습니다.\n      //어딘가의 세부 사항이 변경되었기 때문에 UI의 큰 부분을 다시 빌드하고 싶지 않습니다.\n      body: GetX\u003cController\u003e(\n        builder: (context) {\n          if (c.state.value == Status.initial) {\n            return const Center(child: Text('Press the Button'));\n          }\n          if (c.state.value == Status.loading) {\n            return const Center(child: CircularProgressIndicator());\n          }\n          if (c.state.value == Status.success) {\n            return const Center(child: Text('Success'));\n          }\n          return Container();\n        },\n      ),\n      floatingActionButton: Column(\n        crossAxisAlignment: CrossAxisAlignment.end,\n        mainAxisAlignment: MainAxisAlignment.end,\n        children: \u003cWidget\u003e[\n          FloatingActionButton(\n            child: const Icon(Icons.play_arrow),\n            onPressed: () =\u003e c.fecthData(),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n결과는 다음과 같습니다:\n\n\u003cimg src=\"/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_14.png\" /\u003e\n\n## 장점\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 몇 줄의 코드로 작성된 간단한 상태 업데이터입니다. 최소한의 CPU 영향을 주도록 단순하게 만들었고, 단일 목적을 충족하고 가능한 한 최소한의 리소스를 사용하기 위해 제작되었습니다.\n- 강력한 상태 관리자이며 변수가 아닌 흐름(Flow)으로 작동하며, 내부적으로는 모든 것이 스트림(Stream)입니다.\n- 코드 생성기나 장식품(Decoration) 없이도 실제로 BLoC 접근 방식입니다. .obs를 사용하여 모든 것을 \"Observable\"로 변환할 수 있습니다.\n\n## 단점\n\n- 문제들이 많이 발생할 수 있으며 중복될 수도 있습니다. 문제 해결, 답변, 태깅, 중복 제거 등에 대해 아무도 관심을 가지지 않는 것이 분명합니다.\n- GetX가 너무 많은 작업을 수행하고 이 프로젝트가 단 한 사람에게는 너무 큽니다.\n- 핫 리로드 문제 - GetX는 자체 종속성 주입 시스템을 가지고 있으며, 이는 GetX 모듈의 거의 모든 곳에서 사용되지만 아직 안정적이지 않습니다.\n- GetX로 단위 및 위젯 테스트를 작성하는 것은 정말 어렵고 몇 가지 경우에는 일부 기능을 테스트하는 것이 불가능합니다.\n\n# Riverpod\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Provider와 유사하며 컴파일 안전성과 테스트 가능성을 갖추고 있습니다.\n- Riverpod은 Provider에서 영감을 받았지만 동일한 유형의 여러 공급자 지원; 비동기 공급자 대기; 어디서든 공급자 추가와 같은 주요 문제들을 해결합니다.\n- 이제 main.dart와 UI 파일 간에 이동할 필요가 없어졌습니다.\n- 공유 상태 코드를 필요한 곳에 배치하고, 별도의 패키지에 있든 위젯 옆에 있든 테스트 가능성을 잃지 않고 유지하세요.\n\nProviders는 Riverpod 앱의 가장 중요한 요소입니다. Provider는 상태 조각을 캡슐화하고 해당 상태를 청취할 수 있는 개체입니다.\n\n```js\nenum Status {\n  initial,\n  loading,\n  success,\n}\n```\n\n```js\nclass RiverpodProvider extends StateNotifier\u003cStatus\u003e {\n  RiverpodProvider() : super(Status.initial);\n\n  Future\u003cvoid\u003e fetchData() async {\n    state = Status.loading;\n\n    await Future.delayed(const Duration(seconds: 2));\n\n    state = Status.success;\n  }\n}\n\nfinal riverpodProvider =\n    StateNotifierProvider.autoDispose((ref) =\u003e RiverpodProvider());\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nUI에서 다음과 같이 하고 있습니다:\n\n```dart\nclass RiverpodPage extends StatelessWidget {\n  static const route = 'riverpod-page';\n\n  const RiverpodPage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const ProviderScope(\n      child: HomeRiverpod(),\n    );\n  }\n}\n```\n\n위젯이 프로바이더를 읽을 수 있도록 하려면 전체 애플리케이션을 \"ProviderScope\" 위젯으로 감싸야 합니다. 이곳에는 프로바이더의 상태가 저장됩니다.\n\n```dart\nclass HomeRiverpod extends ConsumerWidget {\n  const HomeRiverpod({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final data = ref.read(riverpodProvider.notifier);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Riverpod Page')),\n      // 소비자 위젯을 가능한 깊게 트리 안에 배치하는 것이 가장 좋습니다.\n      // 어딘가의 세부 사항이 변경되었을 때 UI의 큰 부분을 다시 빌드하고 싶지 않습니다.\n      body: Consumer(\n        builder: (context, ref, child) {\n          final state = ref.watch(riverpodProvider);\n          if (state == Status.initial) {\n            return const Center(child: Text('Press the Button'));\n          }\n          if (state == Status.loading) {\n            return const Center(child: CircularProgressIndicator());\n          }\n          if (state == Status.success) {\n            return const Center(child: Text('Success'));\n          }\n          return Container();\n        },\n      ),\n      floatingActionButton: Column(\n        crossAxisAlignment: CrossAxisAlignment.end,\n        mainAxisAlignment: MainAxisAlignment.end,\n        children: \u003cWidget\u003e[\n          FloatingActionButton(\n            child: const Icon(Icons.play_arrow),\n            onPressed: () =\u003e data.fetchData(),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 제공자들과 상호 작용하는 ref 사용하기\n\n\"ref\"를 사용하는 주요 용도는 다음과 같습니다:\n\n- ref.watch를 사용하여 제공자의 값을 얻고 변경 사항을 청취하는 것입니다. 값이 변경되면 해당 위젯이나 제공자가 다시 빌드되는 기능입니다.\n- ref.listen을 사용하여 제공자에서 리스너를 추가하여 해당 제공자가 변경될 때 새 페이지로 이동하거나 모달을 표시하는 등의 동작을 실행하는 것입니다.\n- ref.read를 사용하여 변경 사항을 무시하고 제공자의 값을 얻는 것입니다. \"클릭\"과 같은 이벤트에서 제공자의 값을 필요로 할 때 유용합니다.\n\n이 결과는 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n빠른 대답을 위해 노력중입니다! \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Riverpod은 앱에서 상태를 구현하는 데 너무 많은 자유를 제공합니다. 이는 새로운 개발자들에게 가장 좋은 접근 방식을 선택하는 데 어려움을 줄 수 있습니다.\n- 공유 상태를 위젯 트리 전체에 분산시키는 나쁜 안티패턴을 촉진합니다. 이는 코드가 매우 찾기 어렵도록 (중앙화되지 않음) 하고, Provider 간에 과도한 의존성 체인과 결합으로 디버깅을 추적하기 어렵게 만들 수 있습니다.\n\n# GetIt\n\nGetIt은 상태 관리 솔루션이 아닙니다! 객체의 로케이터이므로 스트림이나 ValueNotifiers와 같은 다른 방법을 사용하여 UI에 변경을 알릴 필요가 있습니다. 그러나 get_it_mixin과 함께 사용하면 get_it에 등록된 객체와 통합되는 완전한 기능의 쉬운 상태 관리 솔루션이 됩니다.\n\nGetIt은:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 극히 빠름\n- 배우고 사용하기 쉬움\n- Provider나 Redux처럼 데이터에 액세스하기 위해 특별한 위젯을 UI 트리에 추가하지 않음\n\n저희의 구현은 다음과 같습니다:\n\n```js\nenum Status {\n  initial,\n  loading,\n  success,\n}\n```\n\n```js\nclass GetItProvider extends ChangeNotifier {\n  /// GetItProvider의 내부 및 비공개 상태입니다.\n  Status _state = Status.initial;\n\n  /// GetItProvider의 상태입니다.\n  Status get state =\u003e _state;\n\n  /// GetItProvider의 상태를 업데이트합니다. 이는 외부에서 GetItProvider를 수정하는 유일한 방법입니다.\n  void fecthData() async {\n    _state = Status.loading;\n    // 이 호출은 이 모델을 듣고 있는 위젯에게 다시 빌드하도록 지시합니다.\n    notifyListeners();\n\n    await Future.delayed(const Duration(seconds: 2));\n\n    _state = Status.success;\n    notifyListeners();\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 주목했다면, GetItProvider가 Provider를 검토할 때 우리가 구현한 DataProvider와 동일하다는 것을 알 수 있어요.\n\n객체에 액세스하기 전에는 GetIt에 그들을 등록해야 합니다. 보통 initState 코드 내에서 직접 등록합니다.\n\n```js\nclass GetItPage extends StatefulWidget {\n  static const route = 'get-it-page';\n\n  const GetItPage({super.key});\n\n  @override\n  State\u003cGetItPage\u003e createState() =\u003e _GetItPageState();\n}\n\nclass _GetItPageState extends State\u003cGetItPage\u003e {\n  @override\n  void initState() {\n    //시작할 때 모든 객체를 등록합니다.\n    //나중에 액세스하려는 객체들을 이렇게 등록하세요:\n    GetIt.I.registerSingleton\u003cGetItProvider\u003e(GetItProvider());\n    super.initState();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return HomeGetIt();\n  }\n}\n```\n\nGetIt로 데이터를 읽는 것은 이미 간단합니다. 하지만 mixin을 추가하면 더욱 쉬워집니다. StatelessWidget에 GetItMixin을 추가하고 get`T`를 호출하면 됩니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\nclass HomeGetIt extends StatelessWidget with GetItMixin {\n  HomeGetIt({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // 보기 쉽게! view 가 rebuild 되기를 원할 때는 watchOnly 를 호출하여 상태가 변경될 때마다 알려줄 수 있습니다:\n    final state =\n        watchOnly((GetItProvider getItProvider) =\u003e getItProvider.state);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('GetIt 페이지')),\n      body: Builder(\n        builder: (context) {\n          if (state == Status.initial) {\n            return const Center(child: Text('버튼을 눌러보세요'));\n          }\n          if (state == Status.loading) {\n            return const Center(child: CircularProgressIndicator());\n          }\n          if (state == Status.success) {\n            return const Center(child: Text('성공'));\n          }\n          return Container();\n        },\n      ),\n      floatingActionButton: Column(\n        crossAxisAlignment: CrossAxisAlignment.end,\n        mainAxisAlignment: MainAxisAlignment.end,\n        children: \u003cWidget\u003e[\n          FloatingActionButton(\n            child: const Icon(Icons.play_arrow),\n            // 이후 아래와 같이 GetItProvider 클래스에 접근할 수 있습니다:\n            onPressed: () =\u003e get\u003cGetItProvider\u003e().fecthData(),\n          ),\n        ],\n      ),\n    );\n  }\n}\r\n```\n\n보통 데이터 원본 타입에 대한 다양한 watch 메서드가 있습니다. ChangeNotifier, ValueNotifier, Stream 및 Future를 포함합니다.\n\nwatch 메서드의 주요 이점은 ValueListenableBuilders, StreamBuilder 등을 사용하지 않아도 된다는 것입니다. 각 바인딩마다 한 줄만 사용되며 중첩이 없으므로 가독성이 좋습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![alt text](/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_16.png)\n\n## 장점\n\n- 간단하고 사용하기 쉽며, Flutter에 의존하지 않아서 모든 Dart 코드와 함께 사용할 수 있습니다.\n- 매우 빠르고 배우기/사용하기 쉽습니다. UI 트리를 특별한 위젯으로 엮지 않고 데이터에 액세스할 수 있습니다.\n\n## 단점\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 위젯 트리의 본질적인 부분이 아니기 때문에 항목을 수동으로 폐기하거나 등록 해제해야 할 수도 있습니다.\n- 동일한 형식의 인스턴스를 제공하는 문제가 있지만 등록할 때 이름 필드를 노출하기 때문에 문제에 대한 합리적인 해결책을 제공합니다.\n- GetIt 싱글톤의 전역적인 성격을 선호하지 않는 개발자들도 있을 수 있으며, 이는 riverpod나 Provider의 더 제한적인 스코핑 모델을 선호할 수도 있습니다. 다른 개발자들은 이것을 이점으로 생각할 수도 있습니다.\n\n# MobX\n\nMobX는 응용 프로그램의 반응형 데이터와 UI를 간단히 연결하는 상태 관리 라이브러리입니다. 이 연결은 완전히 자동적이며 매우 자연스럽게 느껴집니다. 응용 프로그램 개발자는 UI에서 (그리고 다른 곳에서) 소비해야 하는 반응형 데이터에 순수하게 집중할 뿐, 두 가지를 동기화할 필요없이 고민할 필요가 없습니다.\n\n실제로 마법은 아니지만, 소비되는 것(observable)과 어디에서(reactions) 소비되는지에 관한 지혜가 있으며, 이를 자동으로 추적합니다. observable이 변경되면 모든 reactions가 다시 실행됩니다. 흥미로운 점은 이러한 reactions가 간단한 콘솔 로그에서 네트워크 호출 또는 UI 다시 렌더링까지 모두 될 수 있다는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nMobX의 핵심에는 Observables, Actions 및 Reactions이라는 세 가지 중요한 개념이 있습니다.\n\n![image](/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_17.png)\n\n## Observables\n\n- Observables는 응용 프로그램의 반응형 상태를 나타냅니다. 단순 스칼라부터 복잡한 객체 트리까지 될 수 있습니다. 응용 프로그램의 상태를 Observables 트리로 정의함으로써, 반응형 상태 트리를 노출하여 UI(또는 응용 프로그램의 다른 관찰자)에서 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 작업\n\n- 작업은 옵저버를 변이시키는 방법입니다. 직접 변이시키는 대신 작업은 변이에 의미를 부여합니다. 예를 들어 value++를 하는 대신 increment() 작업을 실행하면 더 많은 의미가 전달됩니다. 또한, 작업은 모든 알림을 일괄 처리하고 변경 사항은 완료된 후에만 알림을 보내도록 보장합니다. 따라서 옵저버는 작업의 원자적 완료 후에만 알림을 받습니다.\n\n## 반응\n\n- 반응은 MobX의 옵저버, 작업 및 반응의 삼합체를 완성합니다. 이들은 반응형 시스템의 옵저버이며 추적 중인 옵저버가 변경될 때마다 알림을 받습니다. 반응에는 아래에 나열된 몇 가지 종류가 있습니다. 이들은 모두 ReactionDisposer를 반환하며, 이는 반응을 폐기하기 위해 호출할 수 있는 함수입니다. 반응의 두드러진 특징 중 하나는 옵저버를 명시적으로 연결하지 않아도 자동으로 모든 옵저버를 추적한다는 것입니다. 반응 내에서 옵저버를 읽는 행위만으로도 추적이 가능합니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nMobX의 스토어는 관련 observable 상태를 하나의 클래스 아래에 수집하는 방법입니다. 이 스토어를 사용하면 주석을 사용하고 코드를 간단하게 유지할 수 있습니다.\n\n```js\nenum Status {\n  initial,\n  loading,\n  success,\n}\n```\n\n```js\n// 이것은 코드베이스의 나머지 부분에서 사용되는 클래스입니다.\n// ignore: library_private_types_in_public_api\nclass DataStore = _DataStore with _$DataStore;\n\n// 스토어 클래스\nabstract class _DataStore with Store {\n  @observable\n  Status state = Status.initial;\n\n  @action\n  Future\u003cvoid\u003e fetchData() async {\n    state = Status.loading;\n\n    await Future.delayed(const Duration(seconds: 2));\n\n    state = Status.success;\n  }\n}\n```\n\n주석을 사용하여 클래스의 observable 속성을 표시하는 방법에 유의하십시오. 주석은 mobx_codgen 패키지를 통해 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기서 흥미로운 부분은:\n\n- Store mixin을 포함하는 추상 클래스 _DataStore입니다. 모든 스토어 관련 코드는 이 추상 클래스 내에 배치되어야 합니다. build_runner에서 코드를 조합하기 위해 DataStore 클래스를 생성합니다.\n- 생성된 코드는 part 파일인 data_store.g.dart에 포함됩니다. 이를 part 지시문으로 포함해야 build_runner가 출력물을 생성합니다. 생성된 파일에는 _$DataStore mixin이 포함됩니다.\n- 값을 observable로 표시하는 @observable 어노테이션.\n- increment() 메서드를 action으로 표시하기 위한 @action 사용.\n\n\u003cimg src=\"/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_18.png\" /\u003e\n\n프로젝트 폴더 내에서 다음 명령을 실행하세요. 이는 counter.g.dart에 코드를 생성하며, 이미 part 파일로 포함해 두었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nflutter pub run build_runner build\n```\n\n이제 UI를 살펴보겠습니다:\n\n```js\nfinal dataStore = DataStore(); // 스토어를 인스턴스화합니다.\n\nclass MobXPage extends StatelessWidget {\n  static const route = 'mobx-page';\n\n  const MobXPage({Key key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return const HomeMobX();\n  }\n}\n```\n\nObserver 위젯(flutter_mobx의 일부)은 빌더 함수에서 사용된 observables의 세부적인 옵저버를 제공합니다. 이러한 observables이 변경될 때마다 Observer가 다시 빌드되고 렌더링됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\nclass HomeMobX extends StatelessWidget {\n  const HomeMobX({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('MobX 페이지')),\n      // 가능한 깊은 곳에 Consumer 위젯을 배치하는 것이 가장 좋습니다.\n      // 어딘가의 세부 사항이 변경되어도 대규모 UI의 큰 부분을 다시 빌드하고 싶지 않을 것입니다.\n      body: Observer(\n        builder: (_) {\n          if (dataStore.state == Status.initial) {\n            return const Center(child: Text('버튼을 눌러주세요'));\n          }\n          if (dataStore.state == Status.loading) {\n            return const Center(child: CircularProgressIndicator());\n          }\n          if (dataStore.state == Status.success) {\n            return const Center(child: Text('성공'));\n          }\n          return Container();\n        },\n      ),\n      floatingActionButton: Column(\n        crossAxisAlignment: CrossAxisAlignment.end,\n        mainAxisAlignment: MainAxisAlignment.end,\n        children: \u003cWidget\u003e[\n          FloatingActionButton(\n            child: const Icon(Icons.play_arrow),\n            onPressed: () =\u003e dataStore.fecthData(),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n그 결과는:\n\n\u003cimg src=\"/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_19.png\" /\u003e\n\n## 장점\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 반응형 앱 데이터를 UI와 쉽게 연결할 수 있습니다.\n- 학습을 쉽게하는 친숙한 구문과 간단한 핵심 API를 사용하여 옵저버 패턴을 구현합니다.\n- 크고 복잡한 프로젝트에서 사용할 수 있으며 확장 가능합니다.\n- 성능이 좋고 테스트하기 쉽습니다.\n- 코드 생성 덕분에 보일러플레이트를 줄일 수 있습니다.\n\n## 단점\n\n- 코드 생성에 시간이 걸리고 상태 변경 시마다 코드 생성기를 실행해야 할 수도 있습니다.\n- 상태가 변경될 때 어떤 이벤트가 그것을 일으킨 것인지 파악하기 어려울 수 있습니다. 복잡한 앱에서 이러한 추적 불가능성은 디버깅과 상태 관리를 어렵게 만들 수 있습니다.\n- Mobx 생성기는 단순성을 높이는 데 좋지만 동시에 추상화 수준을 추가합니다. 이는 내부 작업을 실제로 보고 이해하기 어렵게 만듭니다.\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 상태 관리는 가장 중요한 측면 중 하나입니다. 이는 사용자가 UI에 가한 모든 변경 사항을 추적하는 방법입니다.\n- Flutter의 상태 관리 라이브러리들은 상태 변경의 유형과 상관없이 애플리케이션을 개발하고 관리하기 쉽게 만들어 줍니다.\n- 올바른 Flutter 상태 관리자를 선택하는 것은 사용하는 것만큼 중요합니다. 상태 관리자의 선택지는 다양하지만, 어떤 것을 사용할지 선택하는 것은 우리에게, 우리의 취향에, 편안한 느낌에, 또한 프로젝트 유형, 요구 사항에 달려 있습니다. 작은 프로젝트인 경우 한 가지 접근 방식을 사용할 수 있고, 확장 가능한 프로젝트를 만들고 싶다면 다른 접근 방식을 사용할 수 있습니다.\n\n마침내 기대하던 것, 여기에서 전체 예제를 찾을 수 있습니다:\n\n마음에 든다면 커피 한 잔 사주세요!\n\n![이미지](/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_20.png)","ogImage":{"url":"/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_0.png"},"coverImage":"/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_0.png","tag":["Tech"],"readingTime":28},{"title":"Flutter 프로젝트의 pubspecyaml에서 assets 추가하는 방법","description":"","date":"2024-06-21 23:22","slug":"2024-06-21-pubspecyamlflutterassets","content":"\n\n네, 저는 플러터(Flutter) 프로젝트용 `pubspec.yaml` 파일이 어떻게 구조화되어야 하는지 예시를 제공할 수 있어요. 여기서는 이미지, 폰트 및 기타 파일과 같은 에셋을 정의하는 데 초점을 맞추겠어요. 이 파일은 플러터 프로젝트에서 의존성 및 에셋을 관리하는 데 중요합니다.\n\n각 섹션을 자세하게 설명하는 주석이 포함된 예시 `pubspec.yaml` 파일은 다음과 같습니다:\n\n```yaml\nname: my_flutter_app\ndescription: A new Flutter project.\n\n# 애플리케이션의 버전\nversion: 1.0.0+1\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 환경 및 Flutter SDK 버전 제약사항 정의\n환경:\n  sdk: “`=2.12.0 ❤.0.0” \n  flutter: “`=2.0.0”\n\n# 응용 프로그램에서 사용하는 외부 패키지 의존성\n의존성:\n  flutter:\n    sdk: flutter\n\n# 앱에서 사용하는 추가 패키지\ncupertino_icons: ^1.0.2\nhttp: ^0.13.3\nprovider: ^6.0.0\n\n# 테스트 및 앱 빌드를 위한 개발 의존성\ndev_dependencies:\n  flutter_test:\n    sdk: flutter\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Dart용 Linter 규칙\nlint: ^1.5.0\n\n# Flutter에 특화된 설정\nflutter:\n\n# assets 섹션에는 앱과 번들로 제공되는 자산을 정의합니다\nassets:\n- assets/images/\n- assets/icons/\n- assets/audio/\n\n# 앱에서 사용되는 사용자 정의 글꼴 정의\nfonts:\n- family: Roboto\n  fonts:\n    - asset: assets/fonts/Roboto-Regular.ttf\n    - asset: assets/fonts/Roboto-Bold.ttf\n      weight: 700\n    - asset: assets/fonts/Roboto-Italic.ttf\n      style: italic\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 앱이 플러그인을 사용하는 경우 여기에 플러그인 구성을 지정할 수 있습니다.\nplugin:\nplatforms:\nandroid:\npackage: com.example.my_flutter_app\npluginClass: MyFlutterAppPlugin\n\n# 기타 구성 (선택 사항)\n# 빌드 대상 정의, 포함되거나 제외되어야 하는 파일 지정 등의 예시\n\n\n### `pubspec.yaml` 섹션 설명:\n\n1. **기본 정보**:\n— `name`: Flutter 애플리케이션의 이름\n— `description`: 앱에 대한 간단한 설명\n— `version`: 애플리케이션의 버전, 일반적으로 `major.minor.patch+build` 형식으로 되어 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. **환경**:\n- `sdk`: 앱에서 지원하는 Dart SDK 버전 범위를 지정합니다.\n- `flutter`: 앱에서 지원하는 Flutter SDK 버전 범위를 지정합니다.\n\n3. **의존성**:\n- `dependencies`: 앱이 의존하는 패키지를 나열합니다.\n- `dev_dependencies`: 테스트 또는 앱 빌드와 같은 개발 목적으로 사용되는 패키지를 나열합니다.\n\n4. **Flutter 구성**:\n- `flutter`: 이 섹션은 Flutter에 특화되어 있으며 에셋, 폰트 및 플러그인 구성을 포함합니다.\n- `assets`: 앱에 에셋으로 포함할 디렉터리나 파일을 나열합니다. 앱은 이후에 이러한 에셋을 실행 시점에로드할 수 있습니다.\n- `fonts`: 앱에서 사용되는 사용자 정의 폰트를 정의합니다. 각 폰트 패밀리는 서로 다른 무게와 스타일을 지정하는 여러 폰트 파일을 가질 수 있습니다.\n- `plugin`: 앱에서 사용 중인 플러그인에 대한 설정을 지정하여 플랫폼별 설정을합니다.\n\n### 에셋 관리 팁:\n- **에셋 구성**: 에셋을 하위 디렉터리에 구성하여 프로젝트 구조를 깔끔하게 유지하세요 (예: `images`, `icons`, `audio`).\n- **의미있는 이름 사용**: 에셋에 의미 있는 이름을 지어 코드에서 쉽게 식별하고 참조할 수 있도록 하세요.\n- **에셋 선언**: 모든 에셋 디렉토리 및 파일이 앱에서 접근할 수 있도록 `pubspec.yaml` 파일에 선언되었는지 확인하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n### 코드에서의 사용 예시:\n`pubspec.yaml` 파일에서 선언된 이미지 애셋을 사용하려면:\n```dart\nImage.asset(‘assets/images/my_image.png’)\n```\n\n`pubspec.yaml` 파일에서 선언된 사용자 지정 폰트를 사용하려면:\n```dart\nText(\n‘안녕, 세상!’,\nstyle: TextStyle(\nfontFamily: ‘Roboto’,\nfontWeight: FontWeight.bold,\n),\n)\n```\n\n이 구조를 따라가고 `pubspec.yaml` 파일을 적절히 구성함으로써 Flutter 프로젝트에서 의존성 및 애셋을 효율적으로 관리하고 개발 프로세스를 원할하게 진행할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-21-pubspecyamlflutterassets_0.png"},"coverImage":"/assets/img/2024-06-21-pubspecyamlflutterassets_0.png","tag":["Tech"],"readingTime":3},{"title":"Flutter 앱 설정을 위한 Firebase 설정 방법  Android 및 Web","description":"","date":"2024-06-21 23:21","slug":"2024-06-21-HowtosetupFirebaseforFlutterAppAndroidandWeb","content":"\n\n![이미지](/assets/img/2024-06-21-HowtosetupFirebaseforFlutterAppAndroidandWeb_0.png)\n\n소개:\n\nFirebase는 모바일 및 웹 응용 프로그램을위한 다양한 백엔드 서비스를 제공하는 강력하고 다재다능한 플랫폼입니다. Flutter 개발자들에게는 Firebase를 프로젝트에 통합하여 응용 프로그램의 기능을 향상시키고 사용자 참여를 개선할 수 있습니다. 이 블로그에서는 Android, iOS 및 웹 플랫폼에 Firebase를 연결하는 방법에 대한 단계별 매뉴얼 가이드를 안내해 드리겠습니다.\n\n단계 1: Firebase 프로젝트 설정하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n비디오 튜토리얼 \"Flutter용 Firebase 설정\"을 시청해보세요.\n\n1. Firebase 콘솔(https://console.firebase.google.com/)에 가서 Google 계정으로 로그인하세요.\n\n2. 새 Firebase 프로젝트를 생성하려면 '프로젝트 추가' 옵션을 클릭하세요.\n\n![이미지](/assets/img/2024-06-21-HowtosetupFirebaseforFlutterAppAndroidandWeb_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3- 프로젝트 이름을 입력하고 국가 또는 지역을 선택하세요. \"계속\"을 클릭하세요.\n\n![이미지](/assets/img/2024-06-21-HowtosetupFirebaseforFlutterAppAndroidandWeb_2.png)\n\n4- 다음 화면에서 프로젝트에 Google Analytics를 활성화하세요 (선택 사항이지만 더 나은 통찰력을 위해 추천됨). \"계속\"을 클릭하세요.\n\n![이미지](/assets/img/2024-06-21-HowtosetupFirebaseforFlutterAppAndroidandWeb_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n5 - Google Analytics를 구성하세요. \"계정 선택\"을 클릭한 후 \"Firebase의 기본 계정\"을 선택하세요. \"프로젝트 생성\"을 클릭하세요.\n\n![이미지](/assets/img/2024-06-21-HowtosetupFirebaseforFlutterAppAndroidandWeb_4.png)\n\n프로젝트를 생성한 후 Firebase 로딩 표시기가 나타날 것이며 5초가 소요될 것입니다. \"계속\"을 클릭하세요.\n\n![이미지](/assets/img/2024-06-21-HowtosetupFirebaseforFlutterAppAndroidandWeb_5.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nFirebase 프로젝트가 성공적으로 생성되었으니, 이제 Flutter 애플리케이션을 해당 Firebase 프로젝트에 추가할 차례입니다.\n\nStep 2: Firebase에 Flutter Android 앱 추가하기\n\n1- Firebase 프로젝트를 생성한 후 “Add app” 버튼(안드로이드 로고로 표시됨)을 클릭합니다.\n\n![이미지](/assets/img/2024-06-21-HowtosetupFirebaseforFlutterAppAndroidandWeb_6.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2- \"Android 패키지 이름\", \"앱 별명\" (선택 사항) 및 \"디버그 서명 인증서 SHA-1\" (선택 사항)을 제공하여 앱을 등록하세요.\n\n![이미지](/assets/img/2024-06-21-HowtosetupFirebaseforFlutterAppAndroidandWeb_7.png)\n\n3- \"Android 패키지 이름\"을 가져오려면 IDE (Android Studio 또는 Vs Code)를 열고 \"android\" 디렉토리에 있는 앱 레벨 \"build.gradle\" 파일을 엽니다.\n\n또한 기본 \"minSdkVersion\"을 \"21\"로 변경하세요. 왜냐하면 일부 Firebase 종속성이 더 높은 SDK 버전을 요구하기 때문입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-21-HowtosetupFirebaseforFlutterAppAndroidandWeb_8.png\" /\u003e\n\n'Android package name'을 얻은 후에 해당 필드에 붙여 넣고 \"앱 등록\"을 클릭합니다.\n\n단계 3: 구성 파일 다운로드\n\n\"google-services.json\" 파일을 다운로드하고 \"android/app\" 디렉토리에 붙여 넣습니다. 그런 다음 \"다음\"을 클릭하십시요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![How to set up Firebase for Flutter App Android and Web](/assets/img/2024-06-21-HowtosetupFirebaseforFlutterAppAndroidandWeb_9.png)\n\n이제 다음 단계는 Flutter 앱에 Firebase SDK를 추가하는 것입니다. Google services Gradle 플러그인을 사용하여 google-services.json 구성 값을 Firebase SDK가 액세스할 수 있도록 만들어야 합니다.\n\n![How to set up Firebase for Flutter App Android and Web](/assets/img/2024-06-21-HowtosetupFirebaseforFlutterAppAndroidandWeb_10.png)\n\n프로젝트 수준의 \"build.gradle\" 파일에 플러그인을 의존성으로 추가하세요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n루트 수준(프로젝트 수준) Gradle 파일 (`project`/build.gradle):\n\n“id ‘com.google.gms.google-services’ version ‘4.3.15’ apply false”를 “classpath “com.google.gms:google-services:4.3.15””로 대체하세요.\n\n![이미지](/assets/img/2024-06-21-HowtosetupFirebaseforFlutterAppAndroidandWeb_11.png)\n\n그런 다음, 앱 수준의 모듈 build.gradle 파일에서 앱에서 사용할 google-services 플러그인 및 Firebase SDK를 추가하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 Markdown 형식으로 테이블을 표현해 봅니다.\n\n\n| 이벤트 | 장소     | 날짜          |\n|--------|-----------|---------------|\n| A      | Seoul     | 2023년 12월 1일 |\n| B      | Busan     | 2024년 3월 15일  |\n| C      | Incheon   | 2024년 7월 8일   |\n\n\n위의 내용을 참고해 주세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGoogle-services.json 파일을 \"앱 수준\" 및 \"프로젝트 수준\" Gradle 파일에 추가한 후에 \"다음\"을 클릭하세요.\n\n이제 여기서 \"콘솔로 계속\"을 클릭하고 축하합니다! Android 앱이 Firebase와 성공적으로 연결되었습니다.\n\n\u003cimg src=\"/assets/img/2024-06-21-HowtosetupFirebaseforFlutterAppAndroidandWeb_14.png\" /\u003e\n\n단계 4- Firebase에 웹 앱 추가\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리의 Android 앱이 Firebase 콘솔에 성공적으로 추가되었으니 다음 앱인 Web을 추가할 차례입니다. 계속하려면 Firebase 콘솔에서 \"웹 아이콘\"을 클릭하세요.\n\n![웹 아이콘](/assets/img/2024-06-21-HowtosetupFirebaseforFlutterAppAndroidandWeb_15.png)\n\n여기서 \"앱 별명\"이 필요하며, 이 앱을 위한 Firebase 호스팅을 설정하려면 체크박스를 확인하세요. \"앱 등록\"을 클릭하세요.\n\n![앱 등록](/assets/img/2024-06-21-HowtosetupFirebaseforFlutterAppAndroidandWeb_16.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 단계에서 두 가지 방법을 적용할 수 있습니다. 하나는 \"npm\" (노드 패키지 관리자)를 사용하는 경우 다음 명령을 실행하고 다음 데이터를 추가할 수 있습니다.\n\n두 번째 방법은 모두 \"main.dart\"에 수동으로 데이터를 추가하는 것입니다. 저는 \"npm\"이 없어서 두 번째 방법을 사용할 것입니다 ㅋㅋ\n\n\u003cimg src=\"/assets/img/2024-06-21-HowtosetupFirebaseforFlutterAppAndroidandWeb_17.png\" /\u003e\n\nStep 5 — Firebase 종속성 추가\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"위 데이터를 'main.dart'에 추가하려면 먼저 'pubspec.ymal' 파일에 몇 가지 Firebase 종속성을 추가해야 합니다. 'cupertino_icons' 바로 아래에 'firebase_core' 패키지를 'pubspec.ymal'에 추가하세요.\n\n\u003cimg src=\"/assets/img/2024-06-21-HowtosetupFirebaseforFlutterAppAndroidandWeb_18.png\" /\u003e\n\n이 패키지를 통해 Firebase를 앱에 초기화할 수 있습니다. 이제 'main.dart'를 열고 이러한 변경 사항을 만들어보세요.\n\n단계 6: Firebase 초기화\"\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우선 \"firebase_core\" 라이브러리를 import 하겠습니다.\n\n```dart\nimport 'package:firebase_core/firebase_core.dart';\n```\n\n그리고 main() 메서드 안에서 Firebase를 초기화합니다. \"WidgetsFlutterBinding.ensureInitialized();\" 바로 아래에, 만약 앱이 Web인지 확인하고 해당 구성을 실행하거나 그렇지 않은 경우에는 \"await Firebase.initializeApp();\"을 초기화합니다.\n\n![Firebase 설정 이미지](/assets/img/2024-06-21-HowtosetupFirebaseforFlutterAppAndroidandWeb_19.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n7단계: Firebase 통합 테스트\n\n이제 모든 구성이 완료되었습니다. 모든 구성이 올바르게 작동하는지 확인할 때입니다. Firebase가 플러터 프로젝트와 올바르게 통합되었는지 확인하기 위해 Android 에뮬레이터 또는 실제 기기에서 앱을 실행하십시오. Firebase 초기화와 관련된 오류가 없는지 확인하기 위해 로그를 확인하십시오.\n\nFirebase 통합을 확인하기 위해 Web에 대해서도 동일한 프로세스를 반복하십시오.\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n축하합니다! Flutter 프로젝트를 안드로이드 및 웹 플랫폼에 수동으로 Firebase와 연결하는 데 성공했습니다. Firebase가 앱에 통합되었으므로 인증, Firestore, 클라우드 스토리지 등과 같은 다양한 Firebase 서비스를 활용하여 강력하고 확장 가능하며 매력적인 애플리케이션을 개발할 수 있습니다.\n\nFirebase SDK를 정기적으로 업데이트하고 특정 서비스 및 고급 구성에 대한 자세한 정보는 공식 Firebase 문서를 참조하십시오. 즐거운 코딩 되세요!","ogImage":{"url":"/assets/img/2024-06-21-HowtosetupFirebaseforFlutterAppAndroidandWeb_0.png"},"coverImage":"/assets/img/2024-06-21-HowtosetupFirebaseforFlutterAppAndroidandWeb_0.png","tag":["Tech"],"readingTime":6}],"page":"2","totalPageCount":20,"totalPageGroupCount":1,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"2"},"buildId":"N-oSpECxE_fvEUVh5yP3h","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>