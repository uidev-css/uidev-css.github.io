<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>uidev-css</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://uidev-css.github.io///posts/3" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="uidev-css" data-gatsby-head="true"/><meta property="og:title" content="uidev-css" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://uidev-css.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://uidev-css.github.io///posts/3" data-gatsby-head="true"/><meta name="twitter:title" content="uidev-css" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | uidev-css" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/873-1e1f6fb6fd3c8994.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-498da29379dd58dc.js" defer=""></script><script src="/_next/static/4HDhroK4kHnB5DAbbbGv3/_buildManifest.js" defer=""></script><script src="/_next/static/4HDhroK4kHnB5DAbbbGv3/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UIDEV CSS</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Flutter 상태 관리 비교 Provider, BLoC, GetX, Riverpod, GetIt, 그리고 MobX" href="/post/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter 상태 관리 비교 Provider, BLoC, GetX, Riverpod, GetIt, 그리고 MobX" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter 상태 관리 비교 Provider, BLoC, GetX, Riverpod, GetIt, 그리고 MobX" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Flutter 상태 관리 비교 Provider, BLoC, GetX, Riverpod, GetIt, 그리고 MobX</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 21, 2024</span><span class="PostList_reading_time__6CBMQ">28<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter 프로젝트의 pubspecyaml에서 assets 추가하는 방법" href="/post/2024-06-21-pubspecyamlflutterassets"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter 프로젝트의 pubspecyaml에서 assets 추가하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-pubspecyamlflutterassets_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter 프로젝트의 pubspecyaml에서 assets 추가하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Flutter 프로젝트의 pubspecyaml에서 assets 추가하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 21, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter 앱 설정을 위한 Firebase 설정 방법  Android 및 Web" href="/post/2024-06-21-HowtosetupFirebaseforFlutterAppAndroidandWeb"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter 앱 설정을 위한 Firebase 설정 방법  Android 및 Web" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-HowtosetupFirebaseforFlutterAppAndroidandWeb_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter 앱 설정을 위한 Firebase 설정 방법  Android 및 Web" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Flutter 앱 설정을 위한 Firebase 설정 방법  Android 및 Web</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 21, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter TextField 레벨업 디자인과 기능 팁 모음" href="/post/2024-06-21-ElevateYourFlutterTextFieldGameDesignandFunctionalityTips"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter TextField 레벨업 디자인과 기능 팁 모음" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-ElevateYourFlutterTextFieldGameDesignandFunctionalityTips_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter TextField 레벨업 디자인과 기능 팁 모음" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Flutter TextField 레벨업 디자인과 기능 팁 모음</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 21, 2024</span><span class="PostList_reading_time__6CBMQ">20<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter에서 PDF를 표시하는 방법" href="/post/2024-06-21-HowtoDisplayaPDFinFlutter"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter에서 PDF를 표시하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-HowtoDisplayaPDFinFlutter_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter에서 PDF를 표시하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Flutter에서 PDF를 표시하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 21, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="패키지 없이 Flutter에서 스크롤로 페이지네이션 하는 방법" href="/post/2024-06-21-FlutterPaginationOnScrollwithoutanypackages"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="패키지 없이 Flutter에서 스크롤로 페이지네이션 하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-FlutterPaginationOnScrollwithoutanypackages_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="패키지 없이 Flutter에서 스크롤로 페이지네이션 하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">패키지 없이 Flutter에서 스크롤로 페이지네이션 하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 21, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="flutter_background_service로 플러터 앱의 백그라운드 서비스 구현 방법" href="/post/2024-06-21-ElevateYourFlutterAppwithBackgroundServicesusingflutter_background_service"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="flutter_background_service로 플러터 앱의 백그라운드 서비스 구현 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-ElevateYourFlutterAppwithBackgroundServicesusingflutter_background_service_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="flutter_background_service로 플러터 앱의 백그라운드 서비스 구현 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">flutter_background_service로 플러터 앱의 백그라운드 서비스 구현 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 21, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Azure DevOps 파이프라인을 사용하여 Flutter iOS 앱을 빌드하고 배포하는 CICD 가이드" href="/post/2024-06-21-BuildandDeployCICDforFlutteriOSAppReleasewithAzureDevOpsPipelines"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Azure DevOps 파이프라인을 사용하여 Flutter iOS 앱을 빌드하고 배포하는 CICD 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-BuildandDeployCICDforFlutteriOSAppReleasewithAzureDevOpsPipelines_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Azure DevOps 파이프라인을 사용하여 Flutter iOS 앱을 빌드하고 배포하는 CICD 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Azure DevOps 파이프라인을 사용하여 Flutter iOS 앱을 빌드하고 배포하는 CICD 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">2 hours ago</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter FCM - 푸시 알림 탭 후 특정 화면으로 이동하는 방법" href="/post/2024-06-21-FlutterFCMHowtoNavigatetoaParticularScreenAfterTappingonPushNotification"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter FCM - 푸시 알림 탭 후 특정 화면으로 이동하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-FlutterFCMHowtoNavigatetoaParticularScreenAfterTappingonPushNotification_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter FCM - 푸시 알림 탭 후 특정 화면으로 이동하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Flutter FCM - 푸시 알림 탭 후 특정 화면으로 이동하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">2 hours ago</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="플러터에서 Cubit 상태 관리 사용하는 방법" href="/post/2024-06-21-CubitStateManagementinFlutter"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="플러터에서 Cubit 상태 관리 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-CubitStateManagementinFlutter_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="플러터에서 Cubit 상태 관리 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">플러터에서 Cubit 상태 관리 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">2 hours ago</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link posts_-active__YVJEi" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Flutter 상태 관리 비교 Provider, BLoC, GetX, Riverpod, GetIt, 그리고 MobX","description":"","date":"2024-06-21 23:25","slug":"2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX","content":"\n\n본 기사에서는 상태 관리의 일반적인 개요를 검토한 후 가장 흥미로운 상태 관리 방법인 Provider, BLoC, GetX, Riverpod, GetIt, 그리고 MobX를 살펴보겠습니다.\n\n![image](/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_0.png)\n\n# 일반적인 개요\n\n모바일 앱을 개발하는 동안, 화면 간이나 전체 앱을 통해 앱 상태를 공유해야 하는 시점이 찾아옵니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_1.png\" /\u003e\n\n이 예에서는 MyLoginScreen, MyCatalog 및 MyCart의 3 개 화면이 있습니다. MyCatalog에서는 제품이 이미 쇼핑 카트에 있는지 확인하기 위해 애플리케이션의 상태를 알아야 합니다. 그리고 MyCart에서는 추가된 모든 제품과 총 구매액을 보고 싶습니다. 두 화면 모두 카트의 상태를 알아야 합니다. 이것은 애플리케이션 상태의 예시이며, 나중에 자세히 검토할 예정입니다.\n\n- Android 또는 iOS 개발에서 추측할 수 있는 많은 가정이 Flutter에는 해당하지 않습니다. 예를 들어, Flutter에서 UI의 일부를 수정하는 대신 처음부터 다시 빌드하는 것은 괜찮습니다. Flutter는 이를 수행할 만큼 충분히 빠릅니다. 필요하다면 매 프레임마다 가능합니다.\n- Flutter는 선언적입니다. 이것은 Flutter가 현재 상태 애플리케이션을 반영하기 위해 UI를 빌드한다는 것을 의미합니다.\n- 예를 들어 앱 상태가 변경되면, 예를 들어 설정 화면이 있고 사용자가 스위치를 누르는 경우, 그것은 상태를 변경하고 이것은 UI 디자인을 트리거합니다. 이것은 명령형 UI 변경이 아니며, 변경되는 것은 상태이며 UI는 처음부터 다시 빌드됩니다.\n- UI 프로그래밍의 선언적 스타일에는 많은 이점이 있습니다. 모든 상태에 대해 UI가 어떻게 보이는지 설명하고 한 번만 설명하면 됩니다.\n\n\u003cimg src=\"/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_2.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Transient State와 앱 상태의 차이점\n\n![이미지](/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_3.png)\n\n앱 상태는 응용 프로그램이 실행 중일 때 메모리에 있는 모든 요소를 포함합니다. 이는 자산, 변수, 애니메이션 상태, 글ꔼ자 등을 포함합니다.\n\n우리가 관리하는 상태는 일시적인 상태와 앱 상태로 나뉠 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 일시적 상태\n\n단일 위젯을 포함할 수 있는 상태입니다. 예를 들어:\n\n- 위젯에서 현재 페이지\n- 애니메이션의 진행 상황\n- BottomNavigationBar에서 선택한 탭\n\n다시 말해, 이 유형의 상태에서는 상태 관리 기술을 사용할 필요가 없습니다. 필요한 것은 StatefulWidget뿐입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 앱 상태\n\n당연히, 이것은 일시적이지 않은 상태이며 응용 프로그램의 여러 부분에서 공유하고 사용자 세션 사이에서 유지하고 싶은 상태입니다. 응용 프로그램 상태의 예시:\n\n- 사용자의 선호도\n- 로그인 정보\n- 전자 상거래 응용 프로그램의 쇼핑 카트\n\n여기서 우리는 상태 관리가 필요할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희가 모든 상태 관리를 위해 개발할 예제를 보여드리겠습니다.\n\n![이미지](/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_4.png)\n\n# Provider\n\n만약 플러터를 처음 시작하시는 초보자이고 다른 접근 방식을 선택할 확실한 이유가 없다면, 아마도 이 접근 방식부터 시작하는 것이 좋을 것입니다. Provider 패키지는 이해하기 쉽고 코드 양이 많지 않습니다. 또한 다른 접근 방식에서 사용되는 개념을 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앱에는 MyCart 및 MyCatalog 위젯으로 나타낸 카탈로그 및 장바구니라는 두 개의 별도 화면이 있습니다. 카탈로그 화면에는 앱 바와 항목 목록이 포함되어 있습니다.\n\n우리는 몇 가지 위젯이 있습니다. 그 중 많은 위젯이 다른 위치에 \"소속된\" 상태에 액세스해야 합니다. 예를 들어, 카탈로그의 각 항목은 장바구니에 추가할 수 있습니다. 현재 표시된 항목이 이미 장바구니에 있는지 확인하려고 할 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이로써 첫 번째 질문으로 이어집니다: 장바구니의 현재 상태를 어디에 두어야 할까요?\n\n- 플러터에서는 상태를 사용하는 위젯 위에 상태를 두는 것이 합리적으로 보입니다. 왜 그럴까요? 플러터와 같은 선언형 프레임워크에서는 UI를 변경하려면 다시 생성해야 합니다. 다시 말해, 외부에서 메서드를 호출하여 위젯을 명령형으로 변경하는 것은 어렵습니다.\n- 현재 UI 상태를 고려하고 새 데이터를 적용해야 합니다. 이런 방식으로 버그를 피하기 어렵습니다.\n- 플러터에서는 컨텐츠가 변경될 때마다 새 위젯을 빌드합니다.\n\n이전 질문에 대한 답변은 앱 수준에 장바구니 상태를 두어야 합니다. 이렇게 하면 MyCart와 MyCatalog에서 상태에 액세스할 수 있습니다. MyCatalog 레벨에 상태를 둔다면 MyCart에서 액세스할 수 없습니다. 플러터에서는 불필요한 UI 다시 빌드를 피하기 위해 가능한 한 앱 상태를 위젯 트리의 낮은 위치에 두는 것이 좋은 실천법입니다.\n\n![이미지](/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_7.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 코드를 리뷰해 봅시다.\n\n먼저, 우리에게는 3가지 상태가 있습니다: 초기 상태, 로딩 상태, 성공 상태.\n\n```js\nenum Status {\n  initial,\n  loading,\n  success,\n}\n```\n\nProvider를 사용할 때 이해해야 할 3가지 개념이 있습니다: ChangeNotifier, ChangeNotifierProvider 및 Consumer.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## ChangeNotifier\n\nChangeNotifier은 Flutter SDK에 포함된 간단한 클래스로, 청취자에게 변경 알림을 제공합니다. 즉, 무언가가 ChangeNotifier이면 해당 변경 사항에 구독할 수 있습니다.\n\nprovider에서 ChangeNotifier는 응용 프로그램 상태를 캡슐화하는 한 가지 방법입니다. 매우 간단한 앱의 경우에는 하나의 ChangeNotifier로 작업할 수 있습니다. 복잡한 앱의 경우 여러 가지 모델이 있고, 따라서 여러 개의 ChangeNotifier가 있을 것입니다.\n\nChangeNotifier에 특정한 유일한 코드는 notifyListeners()를 호출하는 부분입니다. 이 메서드를 호출하여 모델에 변경 사항이 있을 때마다 UI가 변경될 수 있는지 확인하세요. CartModel에서의 나머지 코드는 모델 자체와 비즈니스 로직입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리의 DataProvider 클래스를 확인해주세요:\n\n```js\nclass DataProvider extends ChangeNotifier {\n  /// 데이터 공급자의 내부적인, 비공개 상태입니다.\n  Status _state = Status.initial;\n\n  /// 데이터 공급자의 상태입니다.\n  Status get state =\u003e _state;\n\n  /// 데이터 공급자의 상태를 업데이트합니다. 데이터 공급자를 외부에서 수정하는 유일한 방법입니다.\n  void fecthData() async {\n    _state = Status.loading;\n    // 이 호출은 해당 모델을 듣고 있는 위젯에게 rebuild해야 함을 알립니다.\n    notifyListeners();\n\n    await Future.delayed(const Duration(seconds: 2));\n\n    _state = Status.success;\n    notifyListeners();\n  }\n}\n```\n\n## ChangeNotifierProvider\n\nChangeNotifierProvider은 ChangeNotifier 인스턴스를 후손들에게 제공하는 위젯입니다. provider 패키지에서 제공됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nChangeNotifierProvider를 어디에 배치해야 하는지 이미 알고 계시네요: 액세스해야 하는 위젯들 위에요. CartModel의 경우, MyCart와 MyCatalog 둘 다 위쪽에 어딘가에 있어야 합니다.\n\n우리 예제에서 ChangeNotifierProvider와 HomeProvider (UI)를 자식으로 하는 ProviderPage가 있습니다.\n\n```js\nclass ProviderPage extends StatelessWidget {\n  static const route = 'provider-page';\n\n  const ProviderPage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return ChangeNotifierProvider(\n      create: (context) =\u003e DataProvider(),\n      child: const HomeProvider(),\n    );\n  }\n}\n```\n\n## Consumer\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n요소별로 Translation을 제공합니다:\n\n\nConsumer 위젯을 가능한 깊이까지 Tree 안에 두는 것이 최선의 방법입니다. 어딘가의 세부 사항이 변경되었을 때 UI의 큰 부분을 다시 빌드하고 싶지 않으니까요.\n\n```dart\nclass HomeProvider extends StatefulWidget {\n  const HomeProvider({super.key});\n\n  @override\n  State\u003cHomeProvider\u003e createState() =\u003e _HomeProviderState();\n}\n\nclass _HomeProviderState extends State\u003cHomeProvider\u003e {\n  late DataProvider provider;\n\n  @override\n  void initState() {\n    provider = Provider.of\u003cDataProvider\u003e(context, listen: false);\n    super.initState();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Provider Page')),\n      // Consumer 위젯을 가능한 깊이까지 Tree 안에 두는 것이 최선의 방법입니다.\n      // 어딘가의 세부 사항이 변경되었을 때 UI의 큰 부분을 다시 빌드하고 싶지 않으니까요.\n      body: Consumer\u003cDataProvider\u003e(\n        builder: (context, data, child) {\n          if (data.state == Status.initial) {\n            return const Center(child: Text('Press the Button'));\n          }\n          if (data.state == Status.loading) {\n            return const Center(child: CircularProgressIndicator());\n          }\n          if (data.state == Status.success) {\n            return const Center(child: Text('Success'));\n          }\n          return Container();\n        },\n      ),\n      floatingActionButton: Column(\n        crossAxisAlignment: CrossAxisAlignment.end,\n        mainAxisAlignment: MainAxisAlignment.end,\n        children: \u003cWidget\u003e[\n          FloatingActionButton(\n            child: const Icon(Icons.play_arrow),\n            onPressed: () =\u003e provider.fecthData(),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n그 결과는 다음과 같습니다:\n\n![이미지](/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_8.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 장점\n\n- Flutter를 처음 사용하는 경우 시작해야 할 접근 방식입니다. 이해하기 쉽고 많은 코드를 사용하지 않습니다.\n- Devtool 친화적 — Provider를 사용하면 애플리케이션의 상태가 Flutter devtool에서 볼 수 있습니다.\n- 데이터 할당 및 자원 (데이터) 해제를 간소화합니다.\n\n## 단점\n\n- 불필요한 업데이트를 실수로 호출할 수 있습니다. 객체의 상태가 변경되었을 때마다 업데이트를 트리거할 필요는 없습니다. 그러나 Provider를 사용하는 경우 변경이 발생할 때마다 항상 업데이트를 트리거합니다.\n- 확장성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# BLoC\n\n- 이 패키지의 목적은 UI와 비즈니스 로직을 분리하는 것을 용이하게 하는 것입니다.\n- 이 패키지는 패턴의 반응적 부분을 추상화하여 개발자가 비즈니스 로직 작성에 집중할 수 있도록 합니다.\n- Bloc은 이벤트를 기반으로 한 상태 변경을 트리거하는 메서드 대신 메서드 대신 사용하는 고급 클래스입니다. Bloc은 이벤트를 수신하고 수신된 이벤트를 발생한 이벤트로 변환합니다.\n\n![image](/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_9.png)\n\n이 부분을 좀 더 잘 이해하기 위해 이벤트가 UI에서 추가되고 BLoC에서 이를 처리하고 이러한 이벤트에 대한 상태 변경으로 응답합니다. bloc 라이브러리를 사용하면 Presentation, Business Logic 및 Data가 세 개의 레이어로 나뉘도록 응용 프로그램을 분리할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n상태 변경은 이벤트가 추가될 때 블록이 시작되며 onEvent을 트리거합니다. 그런 다음, 이벤트는 EventTransformer를 통해 흘러갑니다. 기본적으로 각 이벤트는 병렬로 처리되지만 사용자 정의 EventTransformer를 제공하여 들어오는 이벤트 스트림을 조작할 수 있습니다. 해당 이벤트 유형에 대해 등록된 모든 EventHandlers는 들어오는 이벤트와 함께 호출됩니다. 각 EventHandler는 이벤트에 대한 응답으로 제로 이상의 상태를 발행하는 책임이 있습니다. 마지막으로, 상태가 업데이트되기 직전에 onTransition이 호출되며 현재 상태, 이벤트 및 다음 상태를 포함합니다.\n\n![이미지](/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_10.png)\n\nBLoC 구현에서는 data_bloc, data_event 및 data_state 총 3개의 파일이 필요합니다.\n\n![이미지](/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_11.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n블록 상태에서는 세 가지 상태를 가질 것입니다: 초기, 로딩 및 성공.\n\n```js\npart of 'data_bloc.dart';\n\n\nabstract class DataState {}\n\nclass Initial extends DataState {}\n\nclass Loading extends DataState {}\n\nclass Success extends DataState {}\n```\n\n또한, 블록 이벤트에서는 FetchDataEvent만 사용할 것입니다.\n\n```js\npart of 'data_bloc.dart';\n\nabstract class DataEvent {}\n\nclass FetchDataEvent extends DataEvent {}\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nIn DataBloc, when the FetchDataEvent is added, the _onFetchDataEvent method is triggered.\n\nimport 'package:flutter_bloc/flutter_bloc.dart';\n\npart 'data_event.dart';\npart 'data_state.dart';\n\nclass DataBloc extends Bloc\u003cDataEvent, DataState\u003e {\n  DataBloc() : super(Initial()) {\n    on\u003cFetchDataEvent\u003e(_onFetchDataEvent);\n  }\n\n  void _onFetchDataEvent(\n    FetchDataEvent event,\n    Emitter\u003cDataState\u003e emit,\n  ) async {\n    emit(Loading());\n    await Future.delayed(const Duration(seconds: 2));\n    emit(Success());\n  }\n}\n\nIn this example, we have a BlocPage that includes a BlocProvider with HomeBloc as a child.\n\nclass BlocPage extends StatelessWidget {\n  static const route = 'bloc-page';\n\n  const BlocPage({Key key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return BlocProvider(\n      create: (context) =\u003e DataBloc(),\n      child: const HomeBloc(),\n    );\n  }\n}\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nclass HomeBloc extends StatefulWidget {\n  const HomeBloc({super.key});\n\n  @override\n  State\u003cHomeBloc\u003e createState() =\u003e _HomeBlocState();\n}\n\nclass _HomeBlocState extends State\u003cHomeBloc\u003e {\n  late DataBloc bloc;\n\n  @override\n  void initState() {\n    bloc = BlocProvider.of\u003cDataBloc\u003e(context);\n    super.initState();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('BLoC 페이지')),\n      body: BlocBuilder\u003cDataBloc, DataState\u003e(\n        builder: (context, state) {\n          if (state is Initial) {\n            return const Center(child: Text('버튼을 눌러주세요'));\n          }\n          if (state is Loading) {\n            return const Center(child: CircularProgressIndicator());\n          }\n          if (state is Success) {\n            return const Center(child: Text('성공'));\n          }\n          return Container();\n        },\n      ),\n      floatingActionButton: Column(\n        crossAxisAlignment: CrossAxisAlignment.end,\n        mainAxisAlignment: MainAxisAlignment.end,\n        children: \u003cWidget\u003e[\n          FloatingActionButton(\n            child: const Icon(Icons.play_arrow),\n            onPressed: () =\u003e bloc.add(FetchDataEvent()),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n그리고 Bloc 결과입니다:\n\n\u003cimg src=\"/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_12.png\" /\u003e\n\n## 장점\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 애플리케이션의 상태를 언제든지 파악할 수 있습니다.\n- 앱이 적절하게 응답하는지 확인하기 위해 모든 케이스를 쉽게 테스트할 수 있습니다.\n- 애플리케이션에서 모든 사용자 상호 작용을 기록하여 데이터 기반 결정을 내릴 수 있습니다.\n- 빠르고 반응성 있는 앱을 개발할 수 있습니다.\n- 대규모 데이터 크기에 대해 더 나은 성능을 제공합니다.\n\n## 단점\n\n- 대형 애플리케이션을 가지고 있을 때만 효과적입니다.\n- 두 방향으로 스트림을 사용해야 하므로 Provider보다 더 많은 보일러플레이트가 발생할 수 있습니다.\n- 복잡한 시나리오에서는 너무 제한적일 수 있으며 하나의 입력과 출력만 다루는 BLoC를 생성할 수 있습니다.\n- 특히 앱의 여러 부분에 유사한 비즈니스 로직을 구현해야할 경우 코드 중복으로 이어질 수 있습니다.\n\n# GetX\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 플러터에 대한 가벼우면서도 강력한 솔루션입니다. 고성능 상태 관리, 스마트한 의존성 주입, 라우트 관리를 빠르고 실용적으로 결합합니다.\n- 성능과 자원 최소 소비에 중점을 둡니다. GetX는 Streams나 ChangeNotifier를 사용하지 않습니다.\n- 사용하기 쉽고 즐거운 구문을 사용합니다.\n- 뷰, 표현 로직, 비즈니스 로직, 의존성 주입, 네비게이션의 완전한 분리를 허용합니다.\n\n다음 이미지에서 모든 GetX 기능을 확인할 수 있습니다:\n\n![GetX Functions](/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_13.png)\n\n하지만 우리에게 가장 중요한 것은 반응형 상태 관리자입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 반응성 상태 관리자\n\n반응형 프로그래밍은 복잡하다고 말리기 때문에 많은 사람들을 멀리하곤 합니다. GetX는 반응형 프로그래밍을 꽤 간단하게 만들어 줍니다:\n\n- StreamControllers를 만들 필요가 없습니다.\n- 각 변수마다 StreamBuilder를 만들 필요가 없습니다.\n- 각 상태마다 클래스를 만들 필요가 없습니다.\n- 초기 값에 대한 get을 만들 필요가 없습니다.\n\n이름 변수가 있고 이 변수를 변경할 때마다 사용하는 모든 위젯이 자동으로 변경되기를 원한다고 상상해 봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기 당신의 계수 변수가 있어요:\n\n```js\nvar name = 'Jonatas Borges';\n```\n\n이를 관찰 가능하도록 만들기 위해서는 그 뒤에 \".obs\"를 추가하기만 하면 돼요:\n\n```js\nvar name = 'Jonatas Borges'.obs;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nUI에서 해당 값이 표시되고 값이 변경될 때 화면을 업데이트하려면 다음과 같이 하면 됩니다:\n\n```js\nObx(() =\u003e Text(\"${controller.name}\"));\n```\n\n단순합니다.\n\n이제 코드로 넘어갑니다. GetX에서 Controller가 정의됩니다. 이 경우 GetxController를 확장한 Controller 클래스를 만듭니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\n열거형 Status {\n  초기,\n  로딩,\n  성공,\n}\n```\n\n```js\r\nclass Controller extends GetxController {\n  // GetX는 반응형이기 때문에 변수가 변경되면 자동으로 화면에서 변경됩니다.\n  // 변수 앞에 \".obs\"를 추가하기만 하면 이미 반응형입니다.\n  var state = Status.initial.obs;\n\n  /// 컨트롤러의 상태를 업데이트합니다. 이 방법이 컨트롤러를 외부에서 수정하는 유일한 방법입니다.\n  void fetchData() async {\n    state.value = Status.loading;\n    //update();\n\n    await Future.delayed(const Duration(seconds: 2));\n\n    state.value = Status.success;\n  }\n}\r\n```\n\nUI에서 우리는 GetXPage가 있습니다. 그 안에는 간단한 HomeGetX 위젯이 자식으로 있습니다. 이 방식으로 정의되었는데, Provider 및 Bloc과의 차이를 보려고 했습니다. Provider나 Bloc을 자식 위젯에 제공하기 위해 ChangeNotifierProvider나 BlocProvider의 부모 위젯을 정의해야 했던 과정과의 차이점을 볼 수 있습니다.\n\n```js\r\nclass GetXPage extends StatelessWidget {\n  static const route = 'getx-page';\n\n  const GetXPage({key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return const HomeGetX();\n  }\n}\r\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nclass HomeGetX extends StatefulWidget {\n  const HomeGetX({super.key});\n\n  @override\n  State\u003cHomeGetX\u003e createState() =\u003e _HomeGetXState();\n}\n\nclass _HomeGetXState extends State\u003cHomeGetX\u003e {\n  late Controller c;\n\n  @override\n  void initState() {\n    c = Get.put(Controller());\n    super.initState();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('GetX Page')),\n      //최상위에 Consumer 위젯을 가능한 깊게 두는 것이 가장 좋습니다.\n      //어딘가의 세부 사항이 변경되었기 때문에 UI의 큰 부분을 다시 빌드하고 싶지 않습니다.\n      body: GetX\u003cController\u003e(\n        builder: (context) {\n          if (c.state.value == Status.initial) {\n            return const Center(child: Text('Press the Button'));\n          }\n          if (c.state.value == Status.loading) {\n            return const Center(child: CircularProgressIndicator());\n          }\n          if (c.state.value == Status.success) {\n            return const Center(child: Text('Success'));\n          }\n          return Container();\n        },\n      ),\n      floatingActionButton: Column(\n        crossAxisAlignment: CrossAxisAlignment.end,\n        mainAxisAlignment: MainAxisAlignment.end,\n        children: \u003cWidget\u003e[\n          FloatingActionButton(\n            child: const Icon(Icons.play_arrow),\n            onPressed: () =\u003e c.fecthData(),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n결과는 다음과 같습니다:\n\n\u003cimg src=\"/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_14.png\" /\u003e\n\n## 장점\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 몇 줄의 코드로 작성된 간단한 상태 업데이터입니다. 최소한의 CPU 영향을 주도록 단순하게 만들었고, 단일 목적을 충족하고 가능한 한 최소한의 리소스를 사용하기 위해 제작되었습니다.\n- 강력한 상태 관리자이며 변수가 아닌 흐름(Flow)으로 작동하며, 내부적으로는 모든 것이 스트림(Stream)입니다.\n- 코드 생성기나 장식품(Decoration) 없이도 실제로 BLoC 접근 방식입니다. .obs를 사용하여 모든 것을 \"Observable\"로 변환할 수 있습니다.\n\n## 단점\n\n- 문제들이 많이 발생할 수 있으며 중복될 수도 있습니다. 문제 해결, 답변, 태깅, 중복 제거 등에 대해 아무도 관심을 가지지 않는 것이 분명합니다.\n- GetX가 너무 많은 작업을 수행하고 이 프로젝트가 단 한 사람에게는 너무 큽니다.\n- 핫 리로드 문제 - GetX는 자체 종속성 주입 시스템을 가지고 있으며, 이는 GetX 모듈의 거의 모든 곳에서 사용되지만 아직 안정적이지 않습니다.\n- GetX로 단위 및 위젯 테스트를 작성하는 것은 정말 어렵고 몇 가지 경우에는 일부 기능을 테스트하는 것이 불가능합니다.\n\n# Riverpod\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Provider와 유사하며 컴파일 안전성과 테스트 가능성을 갖추고 있습니다.\n- Riverpod은 Provider에서 영감을 받았지만 동일한 유형의 여러 공급자 지원; 비동기 공급자 대기; 어디서든 공급자 추가와 같은 주요 문제들을 해결합니다.\n- 이제 main.dart와 UI 파일 간에 이동할 필요가 없어졌습니다.\n- 공유 상태 코드를 필요한 곳에 배치하고, 별도의 패키지에 있든 위젯 옆에 있든 테스트 가능성을 잃지 않고 유지하세요.\n\nProviders는 Riverpod 앱의 가장 중요한 요소입니다. Provider는 상태 조각을 캡슐화하고 해당 상태를 청취할 수 있는 개체입니다.\n\n```js\nenum Status {\n  initial,\n  loading,\n  success,\n}\n```\n\n```js\nclass RiverpodProvider extends StateNotifier\u003cStatus\u003e {\n  RiverpodProvider() : super(Status.initial);\n\n  Future\u003cvoid\u003e fetchData() async {\n    state = Status.loading;\n\n    await Future.delayed(const Duration(seconds: 2));\n\n    state = Status.success;\n  }\n}\n\nfinal riverpodProvider =\n    StateNotifierProvider.autoDispose((ref) =\u003e RiverpodProvider());\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nUI에서 다음과 같이 하고 있습니다:\n\n```dart\nclass RiverpodPage extends StatelessWidget {\n  static const route = 'riverpod-page';\n\n  const RiverpodPage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const ProviderScope(\n      child: HomeRiverpod(),\n    );\n  }\n}\n```\n\n위젯이 프로바이더를 읽을 수 있도록 하려면 전체 애플리케이션을 \"ProviderScope\" 위젯으로 감싸야 합니다. 이곳에는 프로바이더의 상태가 저장됩니다.\n\n```dart\nclass HomeRiverpod extends ConsumerWidget {\n  const HomeRiverpod({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final data = ref.read(riverpodProvider.notifier);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Riverpod Page')),\n      // 소비자 위젯을 가능한 깊게 트리 안에 배치하는 것이 가장 좋습니다.\n      // 어딘가의 세부 사항이 변경되었을 때 UI의 큰 부분을 다시 빌드하고 싶지 않습니다.\n      body: Consumer(\n        builder: (context, ref, child) {\n          final state = ref.watch(riverpodProvider);\n          if (state == Status.initial) {\n            return const Center(child: Text('Press the Button'));\n          }\n          if (state == Status.loading) {\n            return const Center(child: CircularProgressIndicator());\n          }\n          if (state == Status.success) {\n            return const Center(child: Text('Success'));\n          }\n          return Container();\n        },\n      ),\n      floatingActionButton: Column(\n        crossAxisAlignment: CrossAxisAlignment.end,\n        mainAxisAlignment: MainAxisAlignment.end,\n        children: \u003cWidget\u003e[\n          FloatingActionButton(\n            child: const Icon(Icons.play_arrow),\n            onPressed: () =\u003e data.fetchData(),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 제공자들과 상호 작용하는 ref 사용하기\n\n\"ref\"를 사용하는 주요 용도는 다음과 같습니다:\n\n- ref.watch를 사용하여 제공자의 값을 얻고 변경 사항을 청취하는 것입니다. 값이 변경되면 해당 위젯이나 제공자가 다시 빌드되는 기능입니다.\n- ref.listen을 사용하여 제공자에서 리스너를 추가하여 해당 제공자가 변경될 때 새 페이지로 이동하거나 모달을 표시하는 등의 동작을 실행하는 것입니다.\n- ref.read를 사용하여 변경 사항을 무시하고 제공자의 값을 얻는 것입니다. \"클릭\"과 같은 이벤트에서 제공자의 값을 필요로 할 때 유용합니다.\n\n이 결과는 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n빠른 대답을 위해 노력중입니다! \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Riverpod은 앱에서 상태를 구현하는 데 너무 많은 자유를 제공합니다. 이는 새로운 개발자들에게 가장 좋은 접근 방식을 선택하는 데 어려움을 줄 수 있습니다.\n- 공유 상태를 위젯 트리 전체에 분산시키는 나쁜 안티패턴을 촉진합니다. 이는 코드가 매우 찾기 어렵도록 (중앙화되지 않음) 하고, Provider 간에 과도한 의존성 체인과 결합으로 디버깅을 추적하기 어렵게 만들 수 있습니다.\n\n# GetIt\n\nGetIt은 상태 관리 솔루션이 아닙니다! 객체의 로케이터이므로 스트림이나 ValueNotifiers와 같은 다른 방법을 사용하여 UI에 변경을 알릴 필요가 있습니다. 그러나 get_it_mixin과 함께 사용하면 get_it에 등록된 객체와 통합되는 완전한 기능의 쉬운 상태 관리 솔루션이 됩니다.\n\nGetIt은:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 극히 빠름\n- 배우고 사용하기 쉬움\n- Provider나 Redux처럼 데이터에 액세스하기 위해 특별한 위젯을 UI 트리에 추가하지 않음\n\n저희의 구현은 다음과 같습니다:\n\n```js\nenum Status {\n  initial,\n  loading,\n  success,\n}\n```\n\n```js\nclass GetItProvider extends ChangeNotifier {\n  /// GetItProvider의 내부 및 비공개 상태입니다.\n  Status _state = Status.initial;\n\n  /// GetItProvider의 상태입니다.\n  Status get state =\u003e _state;\n\n  /// GetItProvider의 상태를 업데이트합니다. 이는 외부에서 GetItProvider를 수정하는 유일한 방법입니다.\n  void fecthData() async {\n    _state = Status.loading;\n    // 이 호출은 이 모델을 듣고 있는 위젯에게 다시 빌드하도록 지시합니다.\n    notifyListeners();\n\n    await Future.delayed(const Duration(seconds: 2));\n\n    _state = Status.success;\n    notifyListeners();\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 주목했다면, GetItProvider가 Provider를 검토할 때 우리가 구현한 DataProvider와 동일하다는 것을 알 수 있어요.\n\n객체에 액세스하기 전에는 GetIt에 그들을 등록해야 합니다. 보통 initState 코드 내에서 직접 등록합니다.\n\n```js\nclass GetItPage extends StatefulWidget {\n  static const route = 'get-it-page';\n\n  const GetItPage({super.key});\n\n  @override\n  State\u003cGetItPage\u003e createState() =\u003e _GetItPageState();\n}\n\nclass _GetItPageState extends State\u003cGetItPage\u003e {\n  @override\n  void initState() {\n    //시작할 때 모든 객체를 등록합니다.\n    //나중에 액세스하려는 객체들을 이렇게 등록하세요:\n    GetIt.I.registerSingleton\u003cGetItProvider\u003e(GetItProvider());\n    super.initState();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return HomeGetIt();\n  }\n}\n```\n\nGetIt로 데이터를 읽는 것은 이미 간단합니다. 하지만 mixin을 추가하면 더욱 쉬워집니다. StatelessWidget에 GetItMixin을 추가하고 get`T`를 호출하면 됩니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\nclass HomeGetIt extends StatelessWidget with GetItMixin {\n  HomeGetIt({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // 보기 쉽게! view 가 rebuild 되기를 원할 때는 watchOnly 를 호출하여 상태가 변경될 때마다 알려줄 수 있습니다:\n    final state =\n        watchOnly((GetItProvider getItProvider) =\u003e getItProvider.state);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('GetIt 페이지')),\n      body: Builder(\n        builder: (context) {\n          if (state == Status.initial) {\n            return const Center(child: Text('버튼을 눌러보세요'));\n          }\n          if (state == Status.loading) {\n            return const Center(child: CircularProgressIndicator());\n          }\n          if (state == Status.success) {\n            return const Center(child: Text('성공'));\n          }\n          return Container();\n        },\n      ),\n      floatingActionButton: Column(\n        crossAxisAlignment: CrossAxisAlignment.end,\n        mainAxisAlignment: MainAxisAlignment.end,\n        children: \u003cWidget\u003e[\n          FloatingActionButton(\n            child: const Icon(Icons.play_arrow),\n            // 이후 아래와 같이 GetItProvider 클래스에 접근할 수 있습니다:\n            onPressed: () =\u003e get\u003cGetItProvider\u003e().fecthData(),\n          ),\n        ],\n      ),\n    );\n  }\n}\r\n```\n\n보통 데이터 원본 타입에 대한 다양한 watch 메서드가 있습니다. ChangeNotifier, ValueNotifier, Stream 및 Future를 포함합니다.\n\nwatch 메서드의 주요 이점은 ValueListenableBuilders, StreamBuilder 등을 사용하지 않아도 된다는 것입니다. 각 바인딩마다 한 줄만 사용되며 중첩이 없으므로 가독성이 좋습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![alt text](/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_16.png)\n\n## 장점\n\n- 간단하고 사용하기 쉽며, Flutter에 의존하지 않아서 모든 Dart 코드와 함께 사용할 수 있습니다.\n- 매우 빠르고 배우기/사용하기 쉽습니다. UI 트리를 특별한 위젯으로 엮지 않고 데이터에 액세스할 수 있습니다.\n\n## 단점\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 위젯 트리의 본질적인 부분이 아니기 때문에 항목을 수동으로 폐기하거나 등록 해제해야 할 수도 있습니다.\n- 동일한 형식의 인스턴스를 제공하는 문제가 있지만 등록할 때 이름 필드를 노출하기 때문에 문제에 대한 합리적인 해결책을 제공합니다.\n- GetIt 싱글톤의 전역적인 성격을 선호하지 않는 개발자들도 있을 수 있으며, 이는 riverpod나 Provider의 더 제한적인 스코핑 모델을 선호할 수도 있습니다. 다른 개발자들은 이것을 이점으로 생각할 수도 있습니다.\n\n# MobX\n\nMobX는 응용 프로그램의 반응형 데이터와 UI를 간단히 연결하는 상태 관리 라이브러리입니다. 이 연결은 완전히 자동적이며 매우 자연스럽게 느껴집니다. 응용 프로그램 개발자는 UI에서 (그리고 다른 곳에서) 소비해야 하는 반응형 데이터에 순수하게 집중할 뿐, 두 가지를 동기화할 필요없이 고민할 필요가 없습니다.\n\n실제로 마법은 아니지만, 소비되는 것(observable)과 어디에서(reactions) 소비되는지에 관한 지혜가 있으며, 이를 자동으로 추적합니다. observable이 변경되면 모든 reactions가 다시 실행됩니다. 흥미로운 점은 이러한 reactions가 간단한 콘솔 로그에서 네트워크 호출 또는 UI 다시 렌더링까지 모두 될 수 있다는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nMobX의 핵심에는 Observables, Actions 및 Reactions이라는 세 가지 중요한 개념이 있습니다.\n\n![image](/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_17.png)\n\n## Observables\n\n- Observables는 응용 프로그램의 반응형 상태를 나타냅니다. 단순 스칼라부터 복잡한 객체 트리까지 될 수 있습니다. 응용 프로그램의 상태를 Observables 트리로 정의함으로써, 반응형 상태 트리를 노출하여 UI(또는 응용 프로그램의 다른 관찰자)에서 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 작업\n\n- 작업은 옵저버를 변이시키는 방법입니다. 직접 변이시키는 대신 작업은 변이에 의미를 부여합니다. 예를 들어 value++를 하는 대신 increment() 작업을 실행하면 더 많은 의미가 전달됩니다. 또한, 작업은 모든 알림을 일괄 처리하고 변경 사항은 완료된 후에만 알림을 보내도록 보장합니다. 따라서 옵저버는 작업의 원자적 완료 후에만 알림을 받습니다.\n\n## 반응\n\n- 반응은 MobX의 옵저버, 작업 및 반응의 삼합체를 완성합니다. 이들은 반응형 시스템의 옵저버이며 추적 중인 옵저버가 변경될 때마다 알림을 받습니다. 반응에는 아래에 나열된 몇 가지 종류가 있습니다. 이들은 모두 ReactionDisposer를 반환하며, 이는 반응을 폐기하기 위해 호출할 수 있는 함수입니다. 반응의 두드러진 특징 중 하나는 옵저버를 명시적으로 연결하지 않아도 자동으로 모든 옵저버를 추적한다는 것입니다. 반응 내에서 옵저버를 읽는 행위만으로도 추적이 가능합니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nMobX의 스토어는 관련 observable 상태를 하나의 클래스 아래에 수집하는 방법입니다. 이 스토어를 사용하면 주석을 사용하고 코드를 간단하게 유지할 수 있습니다.\n\n```js\nenum Status {\n  initial,\n  loading,\n  success,\n}\n```\n\n```js\n// 이것은 코드베이스의 나머지 부분에서 사용되는 클래스입니다.\n// ignore: library_private_types_in_public_api\nclass DataStore = _DataStore with _$DataStore;\n\n// 스토어 클래스\nabstract class _DataStore with Store {\n  @observable\n  Status state = Status.initial;\n\n  @action\n  Future\u003cvoid\u003e fetchData() async {\n    state = Status.loading;\n\n    await Future.delayed(const Duration(seconds: 2));\n\n    state = Status.success;\n  }\n}\n```\n\n주석을 사용하여 클래스의 observable 속성을 표시하는 방법에 유의하십시오. 주석은 mobx_codgen 패키지를 통해 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기서 흥미로운 부분은:\n\n- Store mixin을 포함하는 추상 클래스 _DataStore입니다. 모든 스토어 관련 코드는 이 추상 클래스 내에 배치되어야 합니다. build_runner에서 코드를 조합하기 위해 DataStore 클래스를 생성합니다.\n- 생성된 코드는 part 파일인 data_store.g.dart에 포함됩니다. 이를 part 지시문으로 포함해야 build_runner가 출력물을 생성합니다. 생성된 파일에는 _$DataStore mixin이 포함됩니다.\n- 값을 observable로 표시하는 @observable 어노테이션.\n- increment() 메서드를 action으로 표시하기 위한 @action 사용.\n\n\u003cimg src=\"/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_18.png\" /\u003e\n\n프로젝트 폴더 내에서 다음 명령을 실행하세요. 이는 counter.g.dart에 코드를 생성하며, 이미 part 파일로 포함해 두었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nflutter pub run build_runner build\n```\n\n이제 UI를 살펴보겠습니다:\n\n```js\nfinal dataStore = DataStore(); // 스토어를 인스턴스화합니다.\n\nclass MobXPage extends StatelessWidget {\n  static const route = 'mobx-page';\n\n  const MobXPage({Key key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return const HomeMobX();\n  }\n}\n```\n\nObserver 위젯(flutter_mobx의 일부)은 빌더 함수에서 사용된 observables의 세부적인 옵저버를 제공합니다. 이러한 observables이 변경될 때마다 Observer가 다시 빌드되고 렌더링됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\nclass HomeMobX extends StatelessWidget {\n  const HomeMobX({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('MobX 페이지')),\n      // 가능한 깊은 곳에 Consumer 위젯을 배치하는 것이 가장 좋습니다.\n      // 어딘가의 세부 사항이 변경되어도 대규모 UI의 큰 부분을 다시 빌드하고 싶지 않을 것입니다.\n      body: Observer(\n        builder: (_) {\n          if (dataStore.state == Status.initial) {\n            return const Center(child: Text('버튼을 눌러주세요'));\n          }\n          if (dataStore.state == Status.loading) {\n            return const Center(child: CircularProgressIndicator());\n          }\n          if (dataStore.state == Status.success) {\n            return const Center(child: Text('성공'));\n          }\n          return Container();\n        },\n      ),\n      floatingActionButton: Column(\n        crossAxisAlignment: CrossAxisAlignment.end,\n        mainAxisAlignment: MainAxisAlignment.end,\n        children: \u003cWidget\u003e[\n          FloatingActionButton(\n            child: const Icon(Icons.play_arrow),\n            onPressed: () =\u003e dataStore.fecthData(),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n그 결과는:\n\n\u003cimg src=\"/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_19.png\" /\u003e\n\n## 장점\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 반응형 앱 데이터를 UI와 쉽게 연결할 수 있습니다.\n- 학습을 쉽게하는 친숙한 구문과 간단한 핵심 API를 사용하여 옵저버 패턴을 구현합니다.\n- 크고 복잡한 프로젝트에서 사용할 수 있으며 확장 가능합니다.\n- 성능이 좋고 테스트하기 쉽습니다.\n- 코드 생성 덕분에 보일러플레이트를 줄일 수 있습니다.\n\n## 단점\n\n- 코드 생성에 시간이 걸리고 상태 변경 시마다 코드 생성기를 실행해야 할 수도 있습니다.\n- 상태가 변경될 때 어떤 이벤트가 그것을 일으킨 것인지 파악하기 어려울 수 있습니다. 복잡한 앱에서 이러한 추적 불가능성은 디버깅과 상태 관리를 어렵게 만들 수 있습니다.\n- Mobx 생성기는 단순성을 높이는 데 좋지만 동시에 추상화 수준을 추가합니다. 이는 내부 작업을 실제로 보고 이해하기 어렵게 만듭니다.\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 상태 관리는 가장 중요한 측면 중 하나입니다. 이는 사용자가 UI에 가한 모든 변경 사항을 추적하는 방법입니다.\n- Flutter의 상태 관리 라이브러리들은 상태 변경의 유형과 상관없이 애플리케이션을 개발하고 관리하기 쉽게 만들어 줍니다.\n- 올바른 Flutter 상태 관리자를 선택하는 것은 사용하는 것만큼 중요합니다. 상태 관리자의 선택지는 다양하지만, 어떤 것을 사용할지 선택하는 것은 우리에게, 우리의 취향에, 편안한 느낌에, 또한 프로젝트 유형, 요구 사항에 달려 있습니다. 작은 프로젝트인 경우 한 가지 접근 방식을 사용할 수 있고, 확장 가능한 프로젝트를 만들고 싶다면 다른 접근 방식을 사용할 수 있습니다.\n\n마침내 기대하던 것, 여기에서 전체 예제를 찾을 수 있습니다:\n\n마음에 든다면 커피 한 잔 사주세요!\n\n![이미지](/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_20.png)","ogImage":{"url":"/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_0.png"},"coverImage":"/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_0.png","tag":["Tech"],"readingTime":28},{"title":"Flutter 프로젝트의 pubspecyaml에서 assets 추가하는 방법","description":"","date":"2024-06-21 23:22","slug":"2024-06-21-pubspecyamlflutterassets","content":"\n\n네, 저는 플러터(Flutter) 프로젝트용 `pubspec.yaml` 파일이 어떻게 구조화되어야 하는지 예시를 제공할 수 있어요. 여기서는 이미지, 폰트 및 기타 파일과 같은 에셋을 정의하는 데 초점을 맞추겠어요. 이 파일은 플러터 프로젝트에서 의존성 및 에셋을 관리하는 데 중요합니다.\n\n각 섹션을 자세하게 설명하는 주석이 포함된 예시 `pubspec.yaml` 파일은 다음과 같습니다:\n\n```yaml\nname: my_flutter_app\ndescription: A new Flutter project.\n\n# 애플리케이션의 버전\nversion: 1.0.0+1\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 환경 및 Flutter SDK 버전 제약사항 정의\n환경:\n  sdk: “`=2.12.0 ❤.0.0” \n  flutter: “`=2.0.0”\n\n# 응용 프로그램에서 사용하는 외부 패키지 의존성\n의존성:\n  flutter:\n    sdk: flutter\n\n# 앱에서 사용하는 추가 패키지\ncupertino_icons: ^1.0.2\nhttp: ^0.13.3\nprovider: ^6.0.0\n\n# 테스트 및 앱 빌드를 위한 개발 의존성\ndev_dependencies:\n  flutter_test:\n    sdk: flutter\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Dart용 Linter 규칙\nlint: ^1.5.0\n\n# Flutter에 특화된 설정\nflutter:\n\n# assets 섹션에는 앱과 번들로 제공되는 자산을 정의합니다\nassets:\n- assets/images/\n- assets/icons/\n- assets/audio/\n\n# 앱에서 사용되는 사용자 정의 글꼴 정의\nfonts:\n- family: Roboto\n  fonts:\n    - asset: assets/fonts/Roboto-Regular.ttf\n    - asset: assets/fonts/Roboto-Bold.ttf\n      weight: 700\n    - asset: assets/fonts/Roboto-Italic.ttf\n      style: italic\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 앱이 플러그인을 사용하는 경우 여기에 플러그인 구성을 지정할 수 있습니다.\nplugin:\nplatforms:\nandroid:\npackage: com.example.my_flutter_app\npluginClass: MyFlutterAppPlugin\n\n# 기타 구성 (선택 사항)\n# 빌드 대상 정의, 포함되거나 제외되어야 하는 파일 지정 등의 예시\n\n\n### `pubspec.yaml` 섹션 설명:\n\n1. **기본 정보**:\n— `name`: Flutter 애플리케이션의 이름\n— `description`: 앱에 대한 간단한 설명\n— `version`: 애플리케이션의 버전, 일반적으로 `major.minor.patch+build` 형식으로 되어 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. **환경**:\n- `sdk`: 앱에서 지원하는 Dart SDK 버전 범위를 지정합니다.\n- `flutter`: 앱에서 지원하는 Flutter SDK 버전 범위를 지정합니다.\n\n3. **의존성**:\n- `dependencies`: 앱이 의존하는 패키지를 나열합니다.\n- `dev_dependencies`: 테스트 또는 앱 빌드와 같은 개발 목적으로 사용되는 패키지를 나열합니다.\n\n4. **Flutter 구성**:\n- `flutter`: 이 섹션은 Flutter에 특화되어 있으며 에셋, 폰트 및 플러그인 구성을 포함합니다.\n- `assets`: 앱에 에셋으로 포함할 디렉터리나 파일을 나열합니다. 앱은 이후에 이러한 에셋을 실행 시점에로드할 수 있습니다.\n- `fonts`: 앱에서 사용되는 사용자 정의 폰트를 정의합니다. 각 폰트 패밀리는 서로 다른 무게와 스타일을 지정하는 여러 폰트 파일을 가질 수 있습니다.\n- `plugin`: 앱에서 사용 중인 플러그인에 대한 설정을 지정하여 플랫폼별 설정을합니다.\n\n### 에셋 관리 팁:\n- **에셋 구성**: 에셋을 하위 디렉터리에 구성하여 프로젝트 구조를 깔끔하게 유지하세요 (예: `images`, `icons`, `audio`).\n- **의미있는 이름 사용**: 에셋에 의미 있는 이름을 지어 코드에서 쉽게 식별하고 참조할 수 있도록 하세요.\n- **에셋 선언**: 모든 에셋 디렉토리 및 파일이 앱에서 접근할 수 있도록 `pubspec.yaml` 파일에 선언되었는지 확인하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n### 코드에서의 사용 예시:\n`pubspec.yaml` 파일에서 선언된 이미지 애셋을 사용하려면:\n```dart\nImage.asset(‘assets/images/my_image.png’)\n```\n\n`pubspec.yaml` 파일에서 선언된 사용자 지정 폰트를 사용하려면:\n```dart\nText(\n‘안녕, 세상!’,\nstyle: TextStyle(\nfontFamily: ‘Roboto’,\nfontWeight: FontWeight.bold,\n),\n)\n```\n\n이 구조를 따라가고 `pubspec.yaml` 파일을 적절히 구성함으로써 Flutter 프로젝트에서 의존성 및 애셋을 효율적으로 관리하고 개발 프로세스를 원할하게 진행할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-21-pubspecyamlflutterassets_0.png"},"coverImage":"/assets/img/2024-06-21-pubspecyamlflutterassets_0.png","tag":["Tech"],"readingTime":3},{"title":"Flutter 앱 설정을 위한 Firebase 설정 방법  Android 및 Web","description":"","date":"2024-06-21 23:21","slug":"2024-06-21-HowtosetupFirebaseforFlutterAppAndroidandWeb","content":"\n\n![이미지](/assets/img/2024-06-21-HowtosetupFirebaseforFlutterAppAndroidandWeb_0.png)\n\n소개:\n\nFirebase는 모바일 및 웹 응용 프로그램을위한 다양한 백엔드 서비스를 제공하는 강력하고 다재다능한 플랫폼입니다. Flutter 개발자들에게는 Firebase를 프로젝트에 통합하여 응용 프로그램의 기능을 향상시키고 사용자 참여를 개선할 수 있습니다. 이 블로그에서는 Android, iOS 및 웹 플랫폼에 Firebase를 연결하는 방법에 대한 단계별 매뉴얼 가이드를 안내해 드리겠습니다.\n\n단계 1: Firebase 프로젝트 설정하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n비디오 튜토리얼 \"Flutter용 Firebase 설정\"을 시청해보세요.\n\n1. Firebase 콘솔(https://console.firebase.google.com/)에 가서 Google 계정으로 로그인하세요.\n\n2. 새 Firebase 프로젝트를 생성하려면 '프로젝트 추가' 옵션을 클릭하세요.\n\n![이미지](/assets/img/2024-06-21-HowtosetupFirebaseforFlutterAppAndroidandWeb_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3- 프로젝트 이름을 입력하고 국가 또는 지역을 선택하세요. \"계속\"을 클릭하세요.\n\n![이미지](/assets/img/2024-06-21-HowtosetupFirebaseforFlutterAppAndroidandWeb_2.png)\n\n4- 다음 화면에서 프로젝트에 Google Analytics를 활성화하세요 (선택 사항이지만 더 나은 통찰력을 위해 추천됨). \"계속\"을 클릭하세요.\n\n![이미지](/assets/img/2024-06-21-HowtosetupFirebaseforFlutterAppAndroidandWeb_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n5 - Google Analytics를 구성하세요. \"계정 선택\"을 클릭한 후 \"Firebase의 기본 계정\"을 선택하세요. \"프로젝트 생성\"을 클릭하세요.\n\n![이미지](/assets/img/2024-06-21-HowtosetupFirebaseforFlutterAppAndroidandWeb_4.png)\n\n프로젝트를 생성한 후 Firebase 로딩 표시기가 나타날 것이며 5초가 소요될 것입니다. \"계속\"을 클릭하세요.\n\n![이미지](/assets/img/2024-06-21-HowtosetupFirebaseforFlutterAppAndroidandWeb_5.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nFirebase 프로젝트가 성공적으로 생성되었으니, 이제 Flutter 애플리케이션을 해당 Firebase 프로젝트에 추가할 차례입니다.\n\nStep 2: Firebase에 Flutter Android 앱 추가하기\n\n1- Firebase 프로젝트를 생성한 후 “Add app” 버튼(안드로이드 로고로 표시됨)을 클릭합니다.\n\n![이미지](/assets/img/2024-06-21-HowtosetupFirebaseforFlutterAppAndroidandWeb_6.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2- \"Android 패키지 이름\", \"앱 별명\" (선택 사항) 및 \"디버그 서명 인증서 SHA-1\" (선택 사항)을 제공하여 앱을 등록하세요.\n\n![이미지](/assets/img/2024-06-21-HowtosetupFirebaseforFlutterAppAndroidandWeb_7.png)\n\n3- \"Android 패키지 이름\"을 가져오려면 IDE (Android Studio 또는 Vs Code)를 열고 \"android\" 디렉토리에 있는 앱 레벨 \"build.gradle\" 파일을 엽니다.\n\n또한 기본 \"minSdkVersion\"을 \"21\"로 변경하세요. 왜냐하면 일부 Firebase 종속성이 더 높은 SDK 버전을 요구하기 때문입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-21-HowtosetupFirebaseforFlutterAppAndroidandWeb_8.png\" /\u003e\n\n'Android package name'을 얻은 후에 해당 필드에 붙여 넣고 \"앱 등록\"을 클릭합니다.\n\n단계 3: 구성 파일 다운로드\n\n\"google-services.json\" 파일을 다운로드하고 \"android/app\" 디렉토리에 붙여 넣습니다. 그런 다음 \"다음\"을 클릭하십시요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![How to set up Firebase for Flutter App Android and Web](/assets/img/2024-06-21-HowtosetupFirebaseforFlutterAppAndroidandWeb_9.png)\n\n이제 다음 단계는 Flutter 앱에 Firebase SDK를 추가하는 것입니다. Google services Gradle 플러그인을 사용하여 google-services.json 구성 값을 Firebase SDK가 액세스할 수 있도록 만들어야 합니다.\n\n![How to set up Firebase for Flutter App Android and Web](/assets/img/2024-06-21-HowtosetupFirebaseforFlutterAppAndroidandWeb_10.png)\n\n프로젝트 수준의 \"build.gradle\" 파일에 플러그인을 의존성으로 추가하세요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n루트 수준(프로젝트 수준) Gradle 파일 (`project`/build.gradle):\n\n“id ‘com.google.gms.google-services’ version ‘4.3.15’ apply false”를 “classpath “com.google.gms:google-services:4.3.15””로 대체하세요.\n\n![이미지](/assets/img/2024-06-21-HowtosetupFirebaseforFlutterAppAndroidandWeb_11.png)\n\n그런 다음, 앱 수준의 모듈 build.gradle 파일에서 앱에서 사용할 google-services 플러그인 및 Firebase SDK를 추가하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 Markdown 형식으로 테이블을 표현해 봅니다.\n\n\n| 이벤트 | 장소     | 날짜          |\n|--------|-----------|---------------|\n| A      | Seoul     | 2023년 12월 1일 |\n| B      | Busan     | 2024년 3월 15일  |\n| C      | Incheon   | 2024년 7월 8일   |\n\n\n위의 내용을 참고해 주세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGoogle-services.json 파일을 \"앱 수준\" 및 \"프로젝트 수준\" Gradle 파일에 추가한 후에 \"다음\"을 클릭하세요.\n\n이제 여기서 \"콘솔로 계속\"을 클릭하고 축하합니다! Android 앱이 Firebase와 성공적으로 연결되었습니다.\n\n\u003cimg src=\"/assets/img/2024-06-21-HowtosetupFirebaseforFlutterAppAndroidandWeb_14.png\" /\u003e\n\n단계 4- Firebase에 웹 앱 추가\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리의 Android 앱이 Firebase 콘솔에 성공적으로 추가되었으니 다음 앱인 Web을 추가할 차례입니다. 계속하려면 Firebase 콘솔에서 \"웹 아이콘\"을 클릭하세요.\n\n![웹 아이콘](/assets/img/2024-06-21-HowtosetupFirebaseforFlutterAppAndroidandWeb_15.png)\n\n여기서 \"앱 별명\"이 필요하며, 이 앱을 위한 Firebase 호스팅을 설정하려면 체크박스를 확인하세요. \"앱 등록\"을 클릭하세요.\n\n![앱 등록](/assets/img/2024-06-21-HowtosetupFirebaseforFlutterAppAndroidandWeb_16.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 단계에서 두 가지 방법을 적용할 수 있습니다. 하나는 \"npm\" (노드 패키지 관리자)를 사용하는 경우 다음 명령을 실행하고 다음 데이터를 추가할 수 있습니다.\n\n두 번째 방법은 모두 \"main.dart\"에 수동으로 데이터를 추가하는 것입니다. 저는 \"npm\"이 없어서 두 번째 방법을 사용할 것입니다 ㅋㅋ\n\n\u003cimg src=\"/assets/img/2024-06-21-HowtosetupFirebaseforFlutterAppAndroidandWeb_17.png\" /\u003e\n\nStep 5 — Firebase 종속성 추가\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"위 데이터를 'main.dart'에 추가하려면 먼저 'pubspec.ymal' 파일에 몇 가지 Firebase 종속성을 추가해야 합니다. 'cupertino_icons' 바로 아래에 'firebase_core' 패키지를 'pubspec.ymal'에 추가하세요.\n\n\u003cimg src=\"/assets/img/2024-06-21-HowtosetupFirebaseforFlutterAppAndroidandWeb_18.png\" /\u003e\n\n이 패키지를 통해 Firebase를 앱에 초기화할 수 있습니다. 이제 'main.dart'를 열고 이러한 변경 사항을 만들어보세요.\n\n단계 6: Firebase 초기화\"\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우선 \"firebase_core\" 라이브러리를 import 하겠습니다.\n\n```dart\nimport 'package:firebase_core/firebase_core.dart';\n```\n\n그리고 main() 메서드 안에서 Firebase를 초기화합니다. \"WidgetsFlutterBinding.ensureInitialized();\" 바로 아래에, 만약 앱이 Web인지 확인하고 해당 구성을 실행하거나 그렇지 않은 경우에는 \"await Firebase.initializeApp();\"을 초기화합니다.\n\n![Firebase 설정 이미지](/assets/img/2024-06-21-HowtosetupFirebaseforFlutterAppAndroidandWeb_19.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n7단계: Firebase 통합 테스트\n\n이제 모든 구성이 완료되었습니다. 모든 구성이 올바르게 작동하는지 확인할 때입니다. Firebase가 플러터 프로젝트와 올바르게 통합되었는지 확인하기 위해 Android 에뮬레이터 또는 실제 기기에서 앱을 실행하십시오. Firebase 초기화와 관련된 오류가 없는지 확인하기 위해 로그를 확인하십시오.\n\nFirebase 통합을 확인하기 위해 Web에 대해서도 동일한 프로세스를 반복하십시오.\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n축하합니다! Flutter 프로젝트를 안드로이드 및 웹 플랫폼에 수동으로 Firebase와 연결하는 데 성공했습니다. Firebase가 앱에 통합되었으므로 인증, Firestore, 클라우드 스토리지 등과 같은 다양한 Firebase 서비스를 활용하여 강력하고 확장 가능하며 매력적인 애플리케이션을 개발할 수 있습니다.\n\nFirebase SDK를 정기적으로 업데이트하고 특정 서비스 및 고급 구성에 대한 자세한 정보는 공식 Firebase 문서를 참조하십시오. 즐거운 코딩 되세요!","ogImage":{"url":"/assets/img/2024-06-21-HowtosetupFirebaseforFlutterAppAndroidandWeb_0.png"},"coverImage":"/assets/img/2024-06-21-HowtosetupFirebaseforFlutterAppAndroidandWeb_0.png","tag":["Tech"],"readingTime":6},{"title":"Flutter TextField 레벨업 디자인과 기능 팁 모음","description":"","date":"2024-06-21 23:16","slug":"2024-06-21-ElevateYourFlutterTextFieldGameDesignandFunctionalityTips","content":"\n\n![image](/assets/img/2024-06-21-ElevateYourFlutterTextFieldGameDesignandFunctionalityTips_0.png)\n\n플러터에서 가장 자주 사용되는 텍스트 입력 위젯은 TextField입니다. 이 위젯은 사용자가 키보드로 앱 내의 입력을 수집할 수 있게 합니다. 텍스트 필드를 사용하면 사용자가 앱에 텍스트를 입력할 수 있습니다. 이들은 양식을 작성하고 메시지를 보내며 검색 경험을 만드는 데 사용됩니다. 이 레시피에서는 텍스트 필드를 생성하고 스타일링하는 방법을 살펴보겠습니다.\n\n플러터는 두 가지 텍스트 필드를 제공합니다: TextField와 TextFormField.\n\n이 문서에서는 TextField에 대해서만 다루고, TextFormField에 대해서는 다른 시간에 다루겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 기본 TextField 생성하기\n\n시간을 낭비하지 않고 직접 기본 TextField를 만드는 방법을 살펴보겠습니다.\n\n```js\nTextField()\n```\n\n네, 그렇습니다! 이렇게 간단합니다. 다음과 같이 새로운 TextField가 생성됩니다 :-\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-21-ElevateYourFlutterTextFieldGameDesignandFunctionalityTips_1.png)\n\n정보 검색\n\n텍스트 필드에서 정보를 검색하는 것은 중요한 부분 중 하나입니다. 이를 수행하는 방법은 2가지가 있습니다.\n\n- 이 작업을 수행하는 가장 쉬운 방법은 onChanged 메서드를 사용하여 현재 값을 간단한 변수에 저장하는 것입니다. 아래는 그에 대한 샘플 코드입니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nString value = \"\"; \nTextField(\n  onChanged: (text) {\n    value = text;\n  },\n)\n```\n\n두 번째 방법은 TextEditingController를 사용하는 것입니다. 제가 항상 이 방법을 선호하는 이유는 필요에 따라 텍스트를 설정할 수 있는 유연성을 제공하기 때문입니다. (Flutter에서도 권장됩니다..) 컨트롤러는 TextField에 첨부되어 텍스트를들을 수 있게 해주며 텍스트를 제어할 수도 있습니다.\n\n```js\nTextEditingController controller = TextEditingController(); \nTextField(\n  controller: controller,\n)\n```\n\n변화를 감지할 수 있습니다.  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ncontroller.addListener(() {\n  // 여기에 무엇이든 입력하세요.\n});\n```\n\n그리고 다음을 사용하여 값을 가져오거나 설정하세요.\n\n```js\ndebugPrint(controller.text); // 문자열이 표시됩니다\ncontroller.text = \"원하는 문자열으로 설정\"; \n```\n\ntextField의 FocusMode\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"포커스\"가 TextField에 있다는 것은 해당 TextField가 활성화되어 있고 키보드로부터의 입력이 해당 TextField에 입력되는 것을 의미합니다. 텍스트 필드가 선택되어 입력을 받을 때 \"포커스\"를 가지고 있다고 말합니다. 일반적으로 사용자들은 탭을 통해 텍스트 필드로 포커스를 이동시킵니다.\n\n# 1. autofocus 사용하기\n\n위젯이 생성될 때 TextField에 자동 포커스를 맞추려면 autofocus 필드를 true로 설정하세요.\n\n```dart\nTextField(\n  autofocus: true,\n),\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 코드는 기본적으로 TextField에 초점을 맞춥니다.\\TextField에서 초점 사용하기\n\nTextField에 \"초점\"을 맞춘다는 것은 해당 TextField가 활성화되어 있고 키보드로부터의 입력이 초점이 맞춰진 TextField에 입력되는 것을 의미합니다.\n\n# 1. 자동 초점 설정하기\n\n위젯이 생성될 때 TextField에 자동 초점을 맞추려면 autofocus 필드를 true로 설정하십시오.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nTextField(\n  autofocus: true,\n),\n```\n\n기본적으로 이것은 TextField에 포커스를 설정합니다.\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/0*On1n1k1VJNmk3VwG.gif\" /\u003e\n\n기본적으로 TextField로 포커스가 이동합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 2. 사용자 지정 포커스 변경 작업\n\n자동 초점이 아니라 필요에 맞게 초점을 변경하려면 어떻게 해야 할까요? 다음에 어떤 TextField에 포커스를 맞출지를 참조할 수 있는 방법이 필요하기 때문에 TextField에 FocusNode를 부착하고 이를 사용하여 포커스를 전환합니다.\n\n```js\n// 빌드 메서드 외부에서 초기화\nFocusNode nodeOne = FocusNode();\nFocusNode nodeTwo = FocusNode();// 빌드 메서드 내부에서 수행\nTextField(\n  focusNode: nodeOne,\n),\nTextField(\n  focusNode: nodeTwo,\n),\nRaisedButton(\n  onPressed: () {\n    FocusScope.of(context).requestFocus(nodeTwo);\n  },\n  child: Text(\"Next Field\"),\n),\n```\n\n우리는 두 개의 포커스 노드를 생성하고 이를 TextFields에 부착합니다. 버튼을 누르면 FocusScope를 사용하여 다음 TextField에 포커스를 요청합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](https://miro.medium.com/v2/resize:fit:1400/0*n8F5Z1LUpUIloga9.gif)\n\nWhen you press the button, the focus changes.\n\n# Changing Keyboard Properties for TextFields\n\nIn Flutter, you can customize properties related to the keyboard for a TextField.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 1. 키보드 타입\n\nTextField를 사용하면 TextField이 포커스를 얻을 때 나타나는 키보드의 유형을 사용자 정의할 수 있습니다. 이를 위해 keyboardType 속성을 변경합니다.\n\n```js\nTextField(\n  keyboardType: TextInputType.number,\n),\n```\n\n유형은 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- TextInputType.text (기본 완전 키보드)\n- TextInputType.number (숫자 키보드)\n- TextInputType.emailAddress (\"@\"가 포함된 일반 키보드)\n- TextInputType.datetime (\"/\" 및 \":\"이 포함된 숫자 키보드)\n- TextInputType.numberWithOptions (부호 및 소수 모드를 활성화할 수 있는 숫자 키보드)\n- TextInputType.multiline (여러 줄 정보에 최적화된 키보드)\n\n# 2. TextInputAction\n\nTextField의 textInputAction을 변경하면 키보드 자체의 작업 버튼을 변경할 수 있습니다.\n\n예를 들어:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nTextField(\n  textInputAction: TextInputAction.continueAction,\n),\n```\n\n이렇게 하면 \"완료\" 버튼이 \"계속\" 버튼으로 대체됩니다:\n\n![이미지](/assets/img/2024-06-21-ElevateYourFlutterTextFieldGameDesignandFunctionalityTips_2.png)\n\n또는\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```js\nTextField(\n  textInputAction: TextInputAction.send,\n),\n```\n\n원인\n\n\u003cimg src=\"/assets/img/2024-06-21-ElevateYourFlutterTextFieldGameDesignandFunctionalityTips_3.png\" /\u003e\n\n전체 목록은 여기에 표시하기에 너무 많지만 꼭 확인해보세요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해당 TextField에 대해 자동 수정을 활성화 또는 비활성화합니다. 이를 설정하기 위해 autocorrect 필드를 사용하세요.\n\n```js\nTextField(\n  autocorrect: false,\n),\n```\n\n이렇게 하면 제안 기능이 비활성화됩니다.\n\n# 4. 텍스트 대문자화\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nTextField는 사용자 입력에서 글자 대문자화하는 몇 가지 옵션을 제공합니다.\n\n```js\nTextField(\n  textCapitalization: TextCapitalization.sentences,\n),\n```\n\n타입은 다음과 같습니다:\n\n- TextCapitalization.sentences\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이것은 우리가 기대하는 일반적인 대문자화 유형입니다. 모든 문장의 첫 글자가 대문자로 쓰여 있습니다.\n\n![image](/assets/img/2024-06-21-ElevateYourFlutterTextFieldGameDesignandFunctionalityTips_4.png)\n\n2. TextCapitalization.characters\n\n문장의 모든 문자를 대문자로 바꿉니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image](/assets/img/2024-06-21-ElevateYourFlutterTextFieldGameDesignandFunctionalityTips_5.png)\n\n3. TextCapitalization.words\n\nCapitalizes the first letter of each word.\n\n![Image](/assets/img/2024-06-21-ElevateYourFlutterTextFieldGameDesignandFunctionalityTips_6.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 텍스트 스타일, 정렬 및 커서 옵션\n\nFlutter를 사용하면 TextField 내부 텍스트의 스타일 및 정렬과 TextField 내부 커서에 대한 사용자 정의가 가능합니다.\n\n# TextField 내부의 텍스트 정렬\n\n텍스트 정렬을 조정하려면 textAlign 속성을 사용하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nTextField(\n  textAlign: TextAlign.center,\n),\n\n\n이로 인해 커서와 텍스트가 TextField의 중간에서 시작됩니다.\n\n\u003cimg src=\"/assets/img/2024-06-21-ElevateYourFlutterTextFieldGameDesignandFunctionalityTips_7.png\" /\u003e\n\n이것은 일반적인 정렬 속성을 갖고 있습니다: start, end, left, right, center, justify.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 텍스트 필드 내의 텍스트 스타일링\n\n텍스트 필드 내의 텍스트를 변경하려면 style 속성을 사용합니다. 색상, 글꼴 크기 등을 변경하는 데 사용됩니다. 이는 Text 위젯의 style 속성과 유사하므로 이에 대해 너무 많은 시간을 들이지는 않겠습니다.\n\n```js\nTextField(\n  style: TextStyle(color: Colors.red, fontWeight: FontWeight.w300),\n),\n```\n\n\u003cimg src=\"/assets/img/2024-06-21-ElevateYourFlutterTextFieldGameDesignandFunctionalityTips_8.png\" /\u003e \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 텍스트 필드에서 커서 변경하기\n\n텍스트 필드 위젯에서 커서를 사용자 정의할 수 있어요.\n\n커서의 색상, 너비 및 모서리의 반지름을 변경할 수 있습니다. 예를 들어, 여기서는 아무 이유없이 빨간색 동그란 커서를 만들었어요.\n\n```js\nTextField(\n  cursorColor: Colors.red,\n  cursorRadius: Radius.circular(16.0),\n  cursorWidth: 16.0,\n),\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-21-ElevateYourFlutterTextFieldGameDesignandFunctionalityTips_9.png)\n\n## TextField 안에서 크기 및 최대 길이 제어하기\n\nTextField는 안에 입력된 문자의 최대 수, 최대 줄 수를 제어하고 텍스트가 입력됨에 따라 확장될 수 있습니다.\n\n## 최대 문자 수 제어하기\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nTextField(\n  maxLength: 4,\n),\n```\n\n![이미지](/assets/img/2024-06-21-ElevateYourFlutterTextFieldGameDesignandFunctionalityTips_10.png)\n\nmaxLength 속성을 설정하면 최대 길이가 강제되며 기본적으로 TextField에 카운터가 추가됩니다.\n\n# 확장 가능한 TextField 만들기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가끔 한 줄이 끝나면 확장되는 TextField가 필요합니다. 플러터에서 이것을 조금 이상하게 (하지만 쉽게) 할 수 있습니다. 이를 위해 기본적으로 1인 maxLines를 null로 설정합니다. null로 설정하는 것은 익숙하지 않겠지만, 그래도 쉽게 할 수 있습니다.\n\n![이미지](/assets/img/2024-06-21-ElevateYourFlutterTextFieldGameDesignandFunctionalityTips_11.png)\n\n참고: maxLines를 직접 값으로 설정하면 해당 줄 수로 자동 확장됩니다.\n\n```js\nTextField(\n  maxLines: 3,\n)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-21-ElevateYourFlutterTextFieldGameDesignandFunctionalityTips_12.png\" /\u003e\n\n# 텍스트 숨기기\n\nTextField에서 텍스트를 숨기려면 obscureText를 true로 설정하세요.\n\n```js\nTextField(\n  obscureText: true,\n  obscuringCharacter: \"*\",\n),\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 마크다운 형식으로 변경해보세요.\n\n\nWe can also change what should we visible instead of character we typed using obsuringCharacter Property.\n\n\n![TextField](/assets/img/2024-06-21-ElevateYourFlutterTextFieldGameDesignandFunctionalityTips_13.png)\n\n# 마지막으로, 텍스트 필드 꾸미기\n\n지금까지 텍스트 필드의 기능에 대해 이야기했습니다. 이제 우리는 앱 UI가 기능만큼 중요하다는 것을 알아볼 것입니다. 그래서 먼저 간단한 것부터 시작해봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 힌트와 레이블\n\n힌트와 레이블은 사용자가 텍스트 필드에 입력할 정보를 이해하는 데 도움이 되는 문자열입니다. 두 가지의 차이점은 사용자가 입력을 시작하면 힌트가 사라지지만 레이블은 텍스트 필드 위에 떠다닙니다.\n\n![이미지](/assets/img/2024-06-21-ElevateYourFlutterTextFieldGameDesignandFunctionalityTips_14.png)\n\n힌트\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](/assets/img/2024-06-21-ElevateYourFlutterTextFieldGameDesignandFunctionalityTips_15.png)\n\nLabel\n\n# You can add icons using “icon”, “prefixIcon” and “suffixIcon”\n\nYou can add icons directly to TextFields. You can also use prefixText and suffixText for Text instead.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```js\r\nTextField(\n  decoration: InputDecoration(\n    icon: Icon(Icons.print)\n  ),\n),\r\n```\r\n\r\n![Image](/assets/img/2024-06-21-ElevateYourFlutterTextFieldGameDesignandFunctionalityTips_16.png)\r\n\r\nIcon using the icon property\r\n\r\n```js\r\nTextField(\n  decoration: InputDecoration(\n    prefixIcon: Icon(Icons.print)\n  ),\n),\r\n```\r\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image](/assets/img/2024-06-21-ElevateYourFlutterTextFieldGameDesignandFunctionalityTips_17.png)\n\nIcon using the `prefixIcon` property\n\n# Similarly for any other widget, use \"prefix\" instead of \"prefixIcon\"\n\nTo use a generic widget instead of an icon, use the `prefix` field. Again for no apparent reason, let's add a circular progress indicator in a TextField.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nTextField(\n  decoration: InputDecoration(\n    prefix: CircularProgressIndicator(),\n  ),\n),\n```\n\n\u003cimg src=\"/assets/img/2024-06-21-ElevateYourFlutterTextFieldGameDesignandFunctionalityTips_18.png\" /\u003e\n\n# 각 속성인 힌트, 레이블 등에는 각각의 스타일 필드가 있습니다.\n\n힌트를 스타일링하려면 hintStyle을 사용하세요. 레이블을 스타일링하려면 labelStyle을 사용하세요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\nTextField(\n  decoration: InputDecoration(\n    hintText: \"데모 텍스트\",\n    hintStyle: TextStyle(fontWeight: FontWeight.w300, color: Colors.red)\n  ),\n),\n```\n\n![2024-06-21-ElevateYourFlutterTextFieldGameDesignandFunctionalityTips_19.png](/assets/img/2024-06-21-ElevateYourFlutterTextFieldGameDesignandFunctionalityTips_19.png)\n\n참고: 이 예시에서는 한 색으로 힌트 색을 변경했지만 일반적으로는 사용자에게 혼란을 줄 수 있으니 힌트 색을 변경하지 않는 것이 좋습니다.\n\n# 레이블을 원하지 않지만 사용자에게 계속 나타낼 메시지가 필요한 경우 “helperText”를 사용하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nTextField(\n  decoration: InputDecoration(\n    helperText: \"안녕하세요\"\n  ),\n),\n```\n\n\u003cimg src=\"/assets/img/2024-06-21-ElevateYourFlutterTextFieldGameDesignandFunctionalityTips_20.png\" /\u003e\n\n# “decoration: null” 또는 InputDecoration.collapsed를 사용하여 TextField의 기본 밑줄을 제거하세요\n\n이를 사용하여 TextField의 기본 밑줄을 제거하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\nTextField(\n  decoration: InputDecoration.collapsed(hintText: \"\")\n),\n```\n\n\u003cimg src=\"/assets/img/2024-06-21-ElevateYourFlutterTextFieldGameDesignandFunctionalityTips_21.png\" /\u003e\n\n# 텍스트 필드에 테두리를 주려면 “border”를 사용하세요\n\n```dart\nTextField(\n  decoration: InputDecoration(\n    border: OutlineInputBorder()\n  )\n),\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더 많은 장식을 넣을 수 있지만, 한 기사에 모든 것을 다 다룰 수는 없습니다. 그래도 이 내용이 Flutter TextFields를 쉽게 사용자 정의하는 방법을 이해하는 데 도움이 됐으면 좋겠네요.\n\n# TextFields에서 포커스 다루기\n\nTextField에 \"포커스\"가 있다는 것은 TextField가 활성화되어 있고, 키보드로부터 입력을 받을 때 해당 TextField에 데이터가 입력된다는 것을 의미합니다.\n\n# 1. autofocus 사용하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위젯이 생성될 때 TextField에 자동 초점이 맞추어지도록 하려면 autofocus 필드를 true로 설정하십시오.\n\n```dart\nTextField(\n  autofocus: true,\n),\n```\n\n기본적으로 이렇게 TextField에 초점이 설정됩니다.\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/0*qcE5ix5ik3ma0S8m.gif\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기본적으로 TextField로 초점이 이동됩니다.\n\n# 2. 사용자 정의 초점 변경 작업\n\n만약 우리가 포커스를 원하는 대로 변경하고 싶다면 어떻게 해야 할까요? 자동 초점 설정뿐만 아니라 필요에 따라 포커스를 변경할 방법이 필요합니다. 다음에 초점을 맞출 TextField를 지칭하기 위해 TextField에 FocusNode를 첨부하고 이를 사용하여 포커스를 전환합니다.\n\n```js\n// build 메서드 외부에 초기화\nFocusNode nodeOne = FocusNode();\nFocusNode nodeTwo = FocusNode();// 빌드 메서드 내에서 수행\nTextField(\n  focusNode: nodeOne,\n),\nTextField(\n  focusNode: nodeTwo,\n),\nRaisedButton(\n  onPressed: () {\n    FocusScope.of(context).requestFocus(nodeTwo);\n  },\n  child: Text(\"다음 필드로\"),\n),\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n두 개의 포커스 노드를 생성하고 TextFields에 연결합니다. 버튼을 누르면 FocusScope를 사용하여 다음 TextField로 포커스를 요청합니다.\n\n![example image](https://miro.medium.com/v2/resize:fit:1400/0*9tzzhPOL9PWuXv7v.gif)\n\n버튼을 누를 때 포커스가 변경됩니다.\n\n# 텍스트 필드를 위한 키보드 속성 변경\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플러터의 TextField를 사용하면 키보드와 관련된 속성을 사용자가 맞춤 설정할 수 있어요.\n\n### 1. 키보드 유형\n\nTextField를 사용하면 TextField가 포커스를 맞추면 표시되는 키보드 유형을 맞춤 설정할 수 있어요. 이를 위해 keyboardType 속성을 변경할 수 있어요.\n\n```dart\nTextField(\n  keyboardType: TextInputType.number,\n),\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 내용을 친근하게 번역해 드리겠습니다.\n\n다양한 종류가 있습니다:\n\n- TextInputType.text (일반 완전한 키보드)\n- TextInputType.number (숫자 키보드)\n- TextInputType.emailAddress (\"@\"이 포함된 일반 키보드)\n- TextInputType.datetime (\"/\"와 \":\"이 포함된 숫자 키보드)\n- TextInputType.numberWithOptions (부호 및 십진 모드를 활성화할 수 있는 숫자 키보드)\n- TextInputType.multiline (여러 줄 정보에 최적화된 키보드)\n\n# 2. TextInputAction\n\nTextField의 textInputAction을 변경하면 키보드의 동작 버튼을 변경할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어:\n\n```js\nTextField(\n  textInputAction: TextInputAction.continueAction,\n),\n```\n\n이렇게 하면 \"완료\" 버튼이 \"계속\" 버튼으로 바뀝니다:\n\n\u003cimg src=\"/assets/img/2024-06-21-ElevateYourFlutterTextFieldGameDesignandFunctionalityTips_22.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nMarkdown 형식으로 변경해보면 다음과 같습니다.\n\n\n```js\nTextField(\n  textInputAction: TextInputAction.send,\n),\n```\n\nCauses\n\n\u003cimg src=\"/assets/img/2024-06-21-ElevateYourFlutterTextFieldGameDesignandFunctionalityTips_23.png\" /\u003e\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n전체 목록은 여기에 표시하기에 너무 크지만 꼭 확인해보세요.\n\n특정 텍스트 필드의 자동 교정 기능을 활성화 또는 비활성화합니다. 이를 설정하려면 autocorrect 필드를 사용하세요.\n\n```js\nTextField(\n  autocorrect: false,\n),\n```\n\n이렇게 하면 제안도 비활성화됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 4. 텍스트 대문자화\n\nTextField는 사용자 입력에서 글자를 대문자로 표시하는 몇 가지 옵션을 제공합니다.\n\n```js\nTextField(\n  textCapitalization: TextCapitalization.sentences,\n),\n```\n\n이 유형은 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- TextCapitalization.sentences\n\n우리가 기대하는 일반적인 대소문자 표기입니다. 각 문장의 첫 글자가 대문자로 쓰입니다.\n\n![이미지](/assets/img/2024-06-21-ElevateYourFlutterTextFieldGameDesignandFunctionalityTips_24.png)\n\n2. TextCapitalization.characters\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이미지 태그를 마크다운 형식으로 변경해주세요.\n\n\n![이미지](/assets/img/2024-06-21-ElevateYourFlutterTextFieldGameDesignandFunctionalityTips_25.png)\n\n\n3. TextCapitalization.words\n\n각 단어의 첫 글자를 대문자로 씁니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-21-ElevateYourFlutterTextFieldGameDesignandFunctionalityTips_26.png\" /\u003e\n\n# 텍스트 스타일, 정렬 및 커서 옵션\n\nFlutter는 TextField 안의 텍스트 스타일링 및 정렬 및 TextField 내부의 커서에 대한 사용자 정의를 허용합니다.\n\n# TextField 내부의 텍스트 정렬\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n텍스트 필드 안에 커서가 있는 위치를 조정하려면 textAlign 속성을 사용하세요.\n\n```js\nTextField(\n  textAlign: TextAlign.center,\n),\n```\n\n이렇게 하면 커서와 텍스트가 텍스트 필드의 중앙에서 시작됩니다.\n\n\u003cimg src=\"/assets/img/2024-06-21-ElevateYourFlutterTextFieldGameDesignandFunctionalityTips_27.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n표 태그를 Markdown 형식으로 변경해 주세요.\n\n# TextField 내의 텍스트 스타일링\n\nTextField 내부 텍스트의 모양을 변경하려면 style 속성을 사용합니다. 이를 통해 색상, 글꼴 크기 등을 변경할 수 있습니다. Text 위젯의 style 속성과 유사하며, 자세히 살펴볼 시간이 부족하기 때문에 간단히 설명하겠습니다.\n\n```js\nTextField(\n  style: TextStyle(color: Colors.red, fontWeight: FontWeight.w300),\n),\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-21-ElevateYourFlutterTextFieldGameDesignandFunctionalityTips_28.png\" /\u003e\n\n# 텍스트 필드에서 커서 변경하기\n\n커서는 TextField 위젯에서 직접 사용자 정의할 수 있습니다.\n\n커서의 색상, 너비 및 꼭지점의 반지름을 변경할 수 있습니다. 예를 들어, 여기서는 아무 이유없이 원형의 빨간색 커서를 만들어보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nTextField(\n  cursorColor: Colors.red,\n  cursorRadius: Radius.circular(16.0),\n  cursorWidth: 16.0,\n),\n```\n\n\u003cimg src=\"/assets/img/2024-06-21-ElevateYourFlutterTextFieldGameDesignandFunctionalityTips_29.png\" /\u003e\n\n# 텍스트 필드의 크기 및 최대 길이 제어\n\n텍스트 필드는 내부에 작성된 문자 수를 제어하고, 최대 라인 수 및 글자가 입력됨에 따라 확장할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 최대 글자 수 제어하기\n\n```js\nTextField(\n  maxLength: 4,\n),\n```\n\n![이미지](/assets/img/2024-06-21-ElevateYourFlutterTextFieldGameDesignandFunctionalityTips_30.png)\n\nmaxLength 속성을 설정하면 최대 길이가 강제되며 TextField에는 기본적으로 카운터가 추가됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 확장 가능한 TextField 만들기\n\n가끔, 한 줄이 끝나면 확장되는 TextField가 필요할 때가 있습니다. Flutter에서는 이를 조금 이상하게 (하지만 쉽게) 할 수 있습니다. 이를 위해 maxLines를 기본값인 1로 설정된 null로 설정해야 합니다. 우리가 익숙하지 않은 값으로 설정하지만 그럼에도 쉽게 할 수 있습니다.\n\n![이미지](/assets/img/2024-06-21-ElevateYourFlutterTextFieldGameDesignandFunctionalityTips_31.png)\n\n참고: maxLines를 직접값으로 설정하면 기본적으로 해당 수의 줄로 확장됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\nTextField(\n  maxLines: 3,\n)\n```\n\n![Image](/assets/img/2024-06-21-ElevateYourFlutterTextFieldGameDesignandFunctionalityTips_32.png)\n\n# 텍스트 가리기\n\n텍스트를 가리려면 TextField에서 obscureText를 true로 설정하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nTextField(\n  obscureText: true,\n),\n\n\n![Image](/assets/img/2024-06-21-ElevateYourFlutterTextFieldGameDesignandFunctionalityTips_33.png)\n\n# 그리고 마지막으로, TextField 장식하기\n\n지금까지는 입력을 위해 Flutter에서 제공하는 기능에 중점을 두었습니다. 이제는 실제로 화려한 TextField를 디자인하고 디자이너의 의견을 거부하지 않을 것입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n텍스트 필드를 꾸미려면 InputDecoration을 취하는 decoration 속성을 사용합니다. InputDecoration 클래스가 방대하기 때문에 중요한 속성 대부분을 빠르게 살펴보겠습니다.\n\n# 사용자에게 정보를 제공하기 위해 힌트와 라벨 속성 사용\n\n힌트(hint)와 라벨(label)은 텍스트 필드에 입력해야 할 정보를 사용자에게 이해시켜주는 문자열입니다. 차이점은 힌트는 사용자가 입력을 시작하면 사라지지만 라벨은 텍스트 필드 위를 떠다닙니다.\n\n![이미지](/assets/img/2024-06-21-ElevateYourFlutterTextFieldGameDesignandFunctionalityTips_34.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n힌트\n\n\n![Hint](/assets/img/2024-06-21-ElevateYourFlutterTextFieldGameDesignandFunctionalityTips_35.png)\n\n\n라벨\n\n# \"아이콘\", \"prefixIcon\", \"suffixIcon\"을 사용하여 아이콘을 추가할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nTextFields에 아이콘을 직접 추가할 수 있습니다. 또한 Text에 대해 prefixText와 suffixText를 사용할 수도 있습니다.\n\n```js\nTextField(\n  decoration: InputDecoration(\n    icon: Icon(Icons.print)\n  ),\n),\n```\n\n\u003cimg src=\"/assets/img/2024-06-21-ElevateYourFlutterTextFieldGameDesignandFunctionalityTips_36.png\" /\u003e\n\nicon 속성을 사용한 아이콘\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\nTextField(\n  decoration: InputDecoration(\n    prefixIcon: Icon(Icons.print)\n  ),\n),\n```\n\n![Image](/assets/img/2024-06-21-ElevateYourFlutterTextFieldGameDesignandFunctionalityTips_37.png)\n\n`prefixIcon` 속성을 사용한 아이콘\n\n# 다른 위젯에 대해서도 “prefixIcon” 대신에 “prefix”를 사용하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일반 위젯 대신 아이콘 대신에 prefix 필드를 사용하려면 이렇게 해보세요. 아무 이유없이 TextField에 원형 진행 표시기를 추가해보겠습니다.\n\n```js\nTextField(\n  decoration: InputDecoration(\n    prefix: CircularProgressIndicator(),\n  ),\n),\n```\n\n\u003cimg src=\"/assets/img/2024-06-21-ElevateYourFlutterTextFieldGameDesignandFunctionalityTips_38.png\" /\u003e\n\n# hint, label 등 각 속성은 각각의 스타일 필드를 가지고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n힌트를 수정하려면 hintStyle을 사용하세요. 라벨을 스타일링하려면 labelStyle을 사용하세요.\n\n```js\nTextField(\n  decoration: InputDecoration(\n    hintText: \"데모 텍스트\",\n    hintStyle: TextStyle(fontWeight: FontWeight.w300, color: Colors.red)\n  ),\n),\n```\n\n![이미지](/assets/img/2024-06-21-ElevateYourFlutterTextFieldGameDesignandFunctionalityTips_39.png)\n\n참고: 이 예시에서는 했지만, 일반적으로 힌트의 색상을 변경하지 마세요. 사용자에게 혼란스러울 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 사용자에게 계속 보이는 메시지를 표시하고 싶지만 라벨은 필요하지 않은 경우 \"helperText\"를 사용해보세요.\n\n```js\nTextField(\n  decoration: InputDecoration(\n    helperText: \"안녕하세요\"\n  ),\n),\n```\n\n\u003cimg src=\"/assets/img/2024-06-21-ElevateYourFlutterTextFieldGameDesignandFunctionalityTips_40.png\" /\u003e\n\n# TextField의 기본 밑줄을 제거하려면 \"decoration: null\" 또는 InputDecoration.collapsed를 사용하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\nTextField(\n  decoration: InputDecoration.collapsed(hintText: \"\")\n),\n```\n\n![이미지](/assets/img/2024-06-21-ElevateYourFlutterTextFieldGameDesignandFunctionalityTips_41.png)\n\n# 텍스트 필드에 경계선을 주려면 \"border\"를 사용하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nTextField(\n  decoration: InputDecoration(\n    border: OutlineInputBorder()\n  )\n),\n\n\n![image](/assets/img/2024-06-21-ElevateYourFlutterTextFieldGameDesignandFunctionalityTips_42.png)\n\n더 많은 꾸밈 작업이 가능하지만, 한 기사로는 모든 것을 다 다룰 수 없습니다. 그러나 플러터 텍스트필드를 사용자 정의하는 것이 얼마나 쉬운지 이해하는 데 도움이 되었으면 합니다.\n\nAryan Bisht님으로부터 더 많은 내용을 확인하세요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n당신은 커피를 사줄 수 있어:- [여기](https://www.buymeacoffee.com/aryanbisht)\n\n# 코딩과 개발 여정을 함께 레벨업해요\n\n우리 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n- 👏 만약 도움이 되셨다면 이야기에 박수를 치고 저자를 팔로우해주세요 👉\n- 🔔 팔로우하기: LinkedIn","ogImage":{"url":"/assets/img/2024-06-21-ElevateYourFlutterTextFieldGameDesignandFunctionalityTips_0.png"},"coverImage":"/assets/img/2024-06-21-ElevateYourFlutterTextFieldGameDesignandFunctionalityTips_0.png","tag":["Tech"],"readingTime":20},{"title":"Flutter에서 PDF를 표시하는 방법","description":"","date":"2024-06-21 23:11","slug":"2024-06-21-HowtoDisplayaPDFinFlutter","content":"\n\n플러터는 iOS 및 Android용 모바일 앱을 구축하기 위한 강력한 프레임워크입니다. 다양한 플러그인과 패키지를 활용하여 플러터를 사용하면 앱에서 PDF 문서를 표시할 수 있습니다. 이 튜토리얼에서는 flutter_pdfview 패키지를 사용하여 Flutter 앱에서 PDF를 표시하는 방법을 알아보겠습니다.\n\n# 필요한 패키지 설치\n\n먼저, 앱에 flutter_pdfview 패키지를 추가해야 합니다. 이를 위해 pubspec.yaml 파일의 종속성 섹션에 다음 라인을 추가해주세요:\n\n```yaml\ndependencies:\n  flutter_pdfview: ^1.2.5\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\npubspec.yaml 파일을 업데이트한 후에는 다음 명령을 실행하여 패키지를 설치하실 수 있어요:\n\n```js\nflutter pub get\n```\n\n# 앱에 PDF 파일 추가하기\n\n앱에서 PDF를 표시하려면 프로젝트에 PDF 파일을 추가해야 해요. 기존 PDF를 사용하거나 Adobe Acrobat이나 Google 문서와 같은 도구를 사용하여 새로운 PDF를 만들 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nPDF 파일이 준비되었으면 Flutter 프로젝트 자산에 추가하세요. 이를 위해 다음 줄을 pubspec.yaml 파일의 자산 섹션에 추가해주세요:\n\n```js\nassets:\n  - assets/my_document.pdf\n```\n\nPDF 파일이 프로젝트 루트의 assets라는 디렉토리에 추가되었다고 가정합니다. 프로젝트 내의 위치에 따라 PDF 파일의 경로를 변경할 수 있습니다.\n\n# 앱에서 PDF 표시하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리 앱에서 PDF를 표시하기 위해 flutter_pdfview 패키지의 PDFView 위젯을 사용하는 새 위젯을 생성할 것입니다. 이 위젯을 사용하는 방법 예시가 있습니다:\n\n```js\nimport 'package:flutter/material.dart';\nimport 'package:flutter_pdfview/flutter_pdfview.dart';\n```\n\n```js\nclass MyPdfViewer extends StatefulWidget {\n  final String pdfPath;\n  MyPdfViewer({required this.pdfPath});\n  @override\n  _MyPdfViewerState createState() =\u003e _MyPdfViewerState();\n}\nclass _MyPdfViewerState extends State\u003cMyPdfViewer\u003e {\n  late PDFViewController pdfViewController;\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(\"My PDF Document\"),\n      ),\n      body: PDFView(\n        filePath: widget.pdfPath,\n        autoSpacing: true,\n        enableSwipe: true,\n        pageSnap: true,\n        swipeHorizontal: true,\n        onError: (error) {\n          print(error);\n        },\n        onPageError: (page, error) {\n          print('$page: ${error.toString()}');\n        },\n        onViewCreated: (PDFViewController vc) {\n          pdfViewController = vc;\n        },\n        onPageChanged: (int page, int total) {\n          print('page change: $page/$total');\n        },\n      ),\n    );\n  }\n}\n```\n\n이 예시에서는 pdfPath 매개변수를 가지는 MyPdfViewer라는 새 위젯을 생성했습니다. 이 매개변수는 프로젝트 자산에 추가한 PDF 파일의 경로를 지정합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 flutter_pdfview 패키지에서 PDFView 위젯을 사용하여 PDF를 표시했습니다. 이 위젯의 여러 속성을 설정했는데, 예를 들어 autoSpacing, enableSwipe, swipeHorizontal 등을 설정하여 PDF가 어떻게 표시되는지 제어했습니다.\n\n또한 onError, onPageError, onViewCreated, onPageChanged 이벤트를 위한 여러 콜백 함수도 설정했습니다. 이러한 함수들은 PDF를 로딩하거나 표시하는 동안 오류가 발생할 때, 페이지별 오류가 발생할 때, PDF 컨트롤러가 생성될 때, 사용자가 PDF의 현재 페이지를 변경할 때와 같은 각종 이벤트 발생 시 호출됩니다.\n\n# 앱에서 PDF 뷰어 사용하기\n\n이제 MyPdfViewer 위젯을 생성했으니, 앱에서 다른 화면으로부터 해당 위젯으로 이동하여 사용할 수 있습니다. 이를 수행하는 방법의 예시는 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport 'package:flutter/material.dart';\nimport 'my_pdf_viewer.dart';\n```\n\n```js\nvoid main() {\n  runApp(MyApp());\n}\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'My App',\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text('Home'),\n        ),\n        body: Center(\n          child: ElevatedButton(\n            onPressed: () {\n              Navigator.push(\n                context,\n                MaterialPageRoute(\n                  builder: (context) =\u003e MyPdfViewer(pdfPath: 'assets/my_document.pdf'),\n                ),\n              );\n            },\n            child: Text('View PDF'),\n          ),\n        ),\n      ),\n    );\n  }\n}\n```\n\n이 예제에서는 버튼이 포함된 단일 화면이 있는 새로운 Flutter 앱을 만들었습니다. 사용자가 버튼을 탭하면 MyPdfViewer 화면으로 이동하고 PDF 파일의 경로를 전달합니다. \n\n# 파일이 Base64인 경우:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플러터 앱에서 flutter_pdfview 패키지를 사용하여 PDF 파일을 base64 형식으로 표시할 수 있어요.\n\n# flutter_pdfview 패키지 추가하기\n\n먼저, Flutter 프로젝트에 flutter_pdfview 패키지를 추가해야 해요. 이를 위해 pubspec.yaml 파일에 다음 줄을 추가하세요:\n\n```yaml\ndependencies:\n  flutter_pdfview: ^1.2.5\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 줄을 추가한 후 터미널에서 flutter pub get 명령을 실행하여 패키지를 다운로드하고 설치하세요.\n\n# MyPdfViewer 위젯 생성\n\n다음으로 MyPdfViewer라는 새 위젯을 생성하세요. 이 위젯은 flutter_pdfview 패키지에서 제공하는 PDFView 위젯을 사용하여 PDF 파일을 표시합니다.\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_pdfview/flutter_pdfview.dart';\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\nclass MyPdfViewer extends StatefulWidget {\n  final String base64Pdf;\n  MyPdfViewer({@required this.base64Pdf});\n  @override\n  _MyPdfViewerState createState() =\u003e _MyPdfViewerState();\n}\nclass _MyPdfViewerState extends State\u003cMyPdfViewer\u003e {\n  PDFViewController pdfViewController;\n  int currentPage = 0;\n  int totalPages = 0;\n  bool isReady = false;\n  String errorMessage = '';\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('PDF Viewer'),\n      ),\n      body: Stack(\n        children: [\n          PDFView(\n            filePath: null,\n            fitEachPage: true,\n            fitPolicy: FitPolicy.BOTH,\n            onRender: (_pages) {\n              setState(() {\n                totalPages = _pages;\n              });\n            },\n            onError: (error) {\n              setState(() {\n                errorMessage = error.toString();\n              });\n            },\n            onPageError: (page, error) {\n              setState(() {\n                errorMessage = '$error';\n              });\n            },\n            onViewCreated: (PDFViewController vc) {\n              setState(() {\n                pdfViewController = vc;\n              });\n              _loadPdf();\n            },\n          ),\n          errorMessage.isEmpty\n              ? !isReady\n                  ? Center(\n                      child: CircularProgressIndicator(),\n                    )\n                  : Container()\n              : Center(\n                  child: Text(errorMessage),\n                ),\n        ],\n      ),\n    );\n  }\n  _loadPdf() async {\n    try {\n      setState(() {\n        isReady = false;\n      });\n      final data = base64Decode(widget.base64Pdf);\n      final directory = await getApplicationDocumentsDirectory();\n      final file = File('${directory.path}/my_file.pdf');\n      await file.writeAsBytes(data);\n      setState(() {\n        isReady = true;\n      });\n      await pdfViewController.loadFile(file.path);\n    } catch (e) {\n      setState(() {\n        errorMessage = e.toString();\n      });\n    }\n  }\n}\n```\n\n위젯은 이전 예제와 매우 유사하지만 몇 가지 차이가 있습니다. 첫째, 일반 파일 경로 대신 base64로 인코딩된 문자열을 인수로 사용합니다. 둘째, _loadPdf() 함수가 수정되어 PDFViewController로 로드하기 전에 디코딩된 데이터를 파일에 작성합니다. 마지막으로, 오류가 발생할 때 PDF를 로드하거나 표시하는 동안 발생한 모든 오류를 표시하는 errorMessage 상태 변수가 추가되었습니다.\n\n# URL에서 파일을 가져오는 경우:\n\n플러터(Flutter)에서 flutter_pdfview 패키지를 사용하여 URL로부터 PDF 파일을 표시할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# flutter_pdfview 패키지 추가하기\n\n먼저, Flutter 프로젝트에 flutter_pdfview 패키지를 추가해야 합니다. 이를 위해 pubspec.yaml 파일에 다음 줄을 추가해주세요:\n\n```js\ndependencies:\n  flutter_pdfview: ^1.2.5\n```\n\n이 줄을 추가한 후 터미널에서 flutter pub get 명령을 실행하여 패키지를 다운로드하고 설치해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# MyPdfViewer 위젯 생성\n\n이제 MyPdfViewer라는 새로운 위젯을 생성하세요. 이 위젯은 flutter_pdfview 패키지에서 제공하는 PDFView 위젯을 사용하여 PDF 파일을 표시합니다.\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_pdfview/flutter_pdfview.dart';\n```\n\n```dart\nclass MyPdfViewer extends StatefulWidget {\n  final String pdfUrl;\n  MyPdfViewer({@required this.pdfUrl});\n  @override\n  _MyPdfViewerState createState() =\u003e _MyPdfViewerState();\n}\nclass _MyPdfViewerState extends State\u003cMyPdfViewer\u003e {\n  PDFViewController pdfViewController;\n  int currentPage = 0;\n  int totalPages = 0;\n  bool isReady = false;\n  String errorMessage = '';\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('PDF Viewer'),\n      ),\n      body: Stack(\n        children: [\n          PDFView(\n            filePath: null,\n            fitEachPage: true,\n            fitPolicy: FitPolicy.BOTH,\n            onRender: (_pages) {\n              setState(() {\n                totalPages = _pages;\n              });\n            },\n            onError: (error) {\n              setState(() {\n                errorMessage = error.toString();\n              });\n            },\n            onPageError: (page, error) {\n              setState(() {\n                errorMessage = '$error';\n              });\n            },\n            onViewCreated: (PDFViewController vc) {\n              setState(() {\n                pdfViewController = vc;\n              });\n              _loadPdf();\n            },\n          ),\n          errorMessage.isEmpty\n              ? !isReady\n                  ? Center(\n                      child: CircularProgressIndicator(),\n                    )\n                  : Container()\n              : Center(\n                  child: Text(errorMessage),\n                ),\n        ],\n      ),\n    );\n  }\n  _loadPdf() async {\n    try {\n      setState(() {\n        isReady = false;\n      });\n      final data = await http.get(Uri.parse(widget.pdfUrl)).then((res) =\u003e res.bodyBytes);\n      final directory = await getApplicationDocumentsDirectory();\n      final file = File('${directory.path}/my_file.pdf');\n      await file.writeAsBytes(data);\n      setState(() {\n        isReady = true;\n      });\n      await pdfViewController.loadFile(file.path);\n    } catch (e) {\n      setState(() {\n        errorMessage = e.toString();\n      });\n    }\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위젯은 이전 예제와 매우 유사하지만 몇 가지 차이가 있습니다. 첫째, 파일 경로나 base64로 인코딩된 문자열 대신 URL을 인수로 사용합니다. 둘째, _loadPdf() 함수가 수정되어 http 패키지를 사용하여 URL에서 PDF를 다운로드하고 파일로 쓴 후 PDFViewController로 로드되도록 변경되었습니다. 마지막으로 PDF를로드하거나 표시하는 동안 발생한 오류를 표시하는 errorMessage 상태 변수가 추가되었습니다.\n\n# 결론\n\n이 튜토리얼에서는 flutter_pdfview 패키지를 사용하여 Flutter 앱에서 PDF를 표시하는 방법을 살펴보았습니다. PDFView 위젯을 사용하는 MyPdfViewer라는 새 위젯을 생성했습니다. 또한이 위젯을 다른 화면에서 이동하여 앱에서 사용하는 방법을 살펴보았습니다.\n\nflutter_pdfview 패키지는 초기 페이지 설정, 줌 레벨 제어, 텍스트 강조 표시 등 PDF 뷰어를 사용자 정의하는 다양한 옵션을 제공합니다. Flutter 앱에서 PDF를 표시해야하는 경우, flutter_pdfview 패키지는 고려할 가치가 있는 좋은 옵션입니다.","ogImage":{"url":"/assets/img/2024-06-21-HowtoDisplayaPDFinFlutter_0.png"},"coverImage":"/assets/img/2024-06-21-HowtoDisplayaPDFinFlutter_0.png","tag":["Tech"],"readingTime":10},{"title":"패키지 없이 Flutter에서 스크롤로 페이지네이션 하는 방법","description":"","date":"2024-06-21 23:10","slug":"2024-06-21-FlutterPaginationOnScrollwithoutanypackages","content":"\n\n안녕하세요 여러분! 이 기사는 플러터에서 어떠한 패키지를 사용하지 않고 동적 인피니티 스크롤 페이징을 구현하는 방법에 대해 소개하고 있어요.\n여기서 '동적' 이라는 용어는 스크롤 시 새로운 데이터를 로드하는 것을 의미합니다. maxScrollExtent 위치에 도달했을 때가 아니라는 거죠.\n\n페이징은 항상 앱 개발에서 가장 싫어하는 부분 중 하나였어요. 무시할 수 없지만 제대로 구현할만한 방법을 찾지 못했어요. 저는 무한 스크롤 페이징 패키지를 선호하지 않아요. 왜냐하면 특별한 ListView를 사용하도록 강요하고 때로는 화면의 모든 로직과 레이아웃을 다시 만들어야 할 수도 있기 때문이에요.\n\n그래서 이제 저는 스크롤 중에 페이징을 구현하는 방법을 나누려고 해요. 최적화되었고 데이터가 올바른 횟수만큼 로드되도록 노력했어요.\n\n1) 먼저 PaginationScrollController 클래스를 작성해야 해요. 이 클래스는 loadAction 함수와 scrollController 자체를 저장할 거에요.\nboundaryOffset은 데이터를 로드해야 하는 시점을 계산하는 데 사용돼요. 첫 번째로 화면의 반을 넘어가는 시점에 로드를 시작합니다. 그리고 그 다음에는 화면의 0.75 지점을 넘어갈 때 로드합니다. 수식은 다음과 같아요: boundaryOffset = 1-1/(currentPage*2)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\nclass PaginationScrollController {\n  late ScrollController scrollController;\n  bool isLoading = false;\n  bool stopLoading = false;\n  int currentPage = 1;\n  double boundaryOffset = 0.5;\n  late Function loadAction;\n\n  void init({Function? initAction, required Function loadAction}) {\n    if (initAction != null) {\n      initAction();\n    }\n    this.loadAction = loadAction;\n    scrollController = ScrollController()..addListener(scrollListener);\n  }\n\n  void dispose() {\n    scrollController.removeListener(scrollListener);\n    scrollController.dispose();\n  }\n\n  void scrollListener() {\n    if (!stopLoading) {\n      //load more data\n      if (scrollController.offset \u003e=\n              scrollController.position.maxScrollExtent * boundaryOffset \u0026\u0026\n          !isLoading) {\n        isLoading = true;\n        loadAction().then((shouldStop) {\n          isLoading = false;\n          currentPage++;\n          boundaryOffset = 1 - 1 / (currentPage * 2);\n          if (shouldStop == true) {\n            stopLoading = true;\n          }\n        });\n      }\n    }\n  }\n}\r\n```\n\n2) 다음으로 로딩 함수를 작성해야 합니다. 다음과 같이 작성될 것입니다:\n\n```js\r\n  Future getNewRequests() async {\n    int lastPage = pagination.lastPage;\n    int currentPage = pagination.currentPage;\n    if (lastPage \u003e currentPage) {\n      // 여기서 데이터를 가져옵니다. 예를 들어\n      getRequests(currentPage + 1);\n    } else if (lastPage == currentPage) {\n      return true;\n    }\n  }\r\n```\n\n이 함수는 페이지네이션의 마지막 페이지에 도달하면 true를 반환합니다. 이것은 최적화를 위해 페이지네이션 컨트롤러에서 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3) 마지막 단계는 컨트롤러를 SingleChildScrollView에 연결하는 것입니다. 따라서 우리가 할 일은:\n\n3.1 컨트롤러 초기화 (그리고 dispose를 잊지 마세요)\n\n```dart\nclass _MyScreenState extends State\u003cMyScreen\u003e {\n  PaginationScrollController paginationScrollController =\n      PaginationScrollController();\n\n  @override\n  void initState() {\n    paginationScrollController.init(\n        loadAction: () =\u003e context.read\u003cRequestCubit\u003e().getNewRequests());\n    super.initState();\n  }\n\n  @override\n  void dispose() {\n    paginationScrollController.dispose();\n    super.dispose();\n  }\n}\n```\n\n3.2 scrollController를 ListView에 연결하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\n  @override\n  Widget build(BuildContext context) {\n      return Scaffold(\n        body: SingleChildScrollView(\n          controller: paginationScrollController.scrollController,\n          child: Column(\n            children: [\n              // 필요한 데이터를 포함한 위젯\n            ],\n          ),\n        )\n      );\n    \n  }\n```\n\n다음은 구현한 예시입니다 (여기서는 10개의 요소가 있는 5페이지가 있습니다):\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1200/1*D-AaGGdptQ426UvWV7uNUw.gif\" /\u003e\n\n그게 다입니다! 동적 페이징이 구현되었습니다. 데이터가 항상 신선하게 유지되며 사용자는 로딩이나 지연을 전혀 눈치채지 못할 것입니다 (물론 안정적인 인터넷 연결이 있는 경우).","ogImage":{"url":"/assets/img/2024-06-21-FlutterPaginationOnScrollwithoutanypackages_0.png"},"coverImage":"/assets/img/2024-06-21-FlutterPaginationOnScrollwithoutanypackages_0.png","tag":["Tech"],"readingTime":4},{"title":"flutter_background_service로 플러터 앱의 백그라운드 서비스 구현 방법","description":"","date":"2024-06-21 23:09","slug":"2024-06-21-ElevateYourFlutterAppwithBackgroundServicesusingflutter_background_service","content":"\n\n플러터 애플리케이션을 개발할 때는 데이터 가져오기, 업데이트 처리, 또는 알림 처리와 같이 백그라운드에서 작업을 수행해야 하는 시나리오를 자주 마주하게 됩니다. 백그라운드 서비스를 효과적으로 관리하는 강력한 솔루션으로는 flutter_background_service 플러그인이 있습니다. 이 글에서는 해당 기능을 활용하고 Android 및 iOS 플랫폼에서 백그라운드 서비스를 초기화하고 구성하는 세부 사항을 살펴보겠습니다.\n\n# 소개:\n\n플러터에는 백그라운드 서비스용 다양한 플러그인과 패키지가 있으며 각각의 장점이 있습니다. flutter_background_service는 간편성과 사용 편의성으로 눈에 띕니다. 플러그인을 초기화하여 시작해 봅시다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\nfinal service = FlutterBackgroundService();\n```\n\n코드 가독성을 높이기 위해 초기화 과정을 함수 내에 캡슐화하는 것이 좋습니다. initializeBackgroundService()라는 함수를 만들어보겠습니다:\n\n```dart\nvoid initializeBackgroundService() async {\n try {\n // 백그라운드 서비스 초기화\n await service.initialize(onDataReceived: onDataReceivedFromBackground);\n// iOS에 필요한 설정 수행\n configureIOSBackgroundService();\n// 백그라운드 서비스 시작\n service.start(onStart: () {\n print('백그라운드 서비스 시작됨');\n }, onBackgroundTask: (String data) {\n // 여기에 백그라운드 작업 코드를 작성하세요\n print('백그라운드 작업이 데이터와 함께 시작됨: $data');\n service.sendData('백그라운드 작업 완료됨');\n });\n } catch (e) {\n print('백그라운드 서비스 초기화 오류: $e');\n }\n}\n```\n\n# iOS 구성 :\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n백그라운드 서비스의 한 가지 주목할만한 측면은 플랫폼별 구성에 관한 것입니다. Android는 일반적으로 추가 권한이 필요하지 않지만, iOS는 특정 설정이 필요할 수 있습니다. iOS 구성을 위한 플레이스홀더 함수를 여기에 제공합니다:\n\n```js\nvoid configureIOSBackgroundService() {\n // iOS에 특정 구성이 필요한 경우 수행\n // (예: 권한 요청, 백그라운드 모드 설정 등)\n // 이는 추가 플러그인 또는 네이티브 코드 사용이 포함될 수 있습니다.\n}\n```\n\n# 네이티브 측면에서 서비스 호출하기:\n\n전경 및 배경에서 네이티브 측면의 서비스를 활용하기 위해 제공된 함수를 사용할 수 있습니다. 서비스를 호출하는 방법을 보여주는 코드 조각을 여기에 제공합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 화면용 서비스 호출\nservice.invokeForegroundService();\n// 배경용 서비스 호출\nservice.invokeBackgroundService();\n// 서비스 중지\nservice.stopService();\n```\n\n이 호출을 귀하의 특정 요구 사항에 맞게 조정해 주세요.\n\n# 백그라운드 작업: 날짜 및 시간 업데이트:\n\n이제 우리의 주요 작업인 백그라운드에서 매 10초마다 날짜 및 시간 업데이트에 대해 다루어 보겠습니다. 이를 위해 타이머를 사용하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// onStart 함수 내부에서\nTimer.periodic(const Duration(seconds: 10), (timer) async {\n  if (service is AndroidServiceInstance) {\n    service.setForegroundNotificationInfo(\n      title: \"백그라운드 앱...\",\n      content: \"${DateTime.now()} 업데이트\",\n    );\n  }\n  service.invoke(\n    'update',\n    {\n      \"current_date\": DateTime.now().toIso8601String(),\n    },\n  );\n});\n```\n\n이 코드 조각은 10초마다 작업을 트리거하는 타이머를 설정합니다. 이 작업은 DateTime을 업데이트하고 백그라운드 서비스에 알립니다. 필요에 따라 특정 사용 사례에 맞게 이 로직을 사용자 정의할 수 있습니다.\n\n# 백그라운드 서비스 활용:\n\n이제 백그라운드 서비스를 초기화했으니, 플러터 앱에서 이를 활용해보세요. 실제 구현 세부 정보로 플레이스홀더를 교체해야 합니다. 플러그인은 onDataReceived 리스너를 제공하여 백그라운드로부터 수신된 데이터를 처리할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nservice.onDataReceived.listen((event) {\n  print('백그라운드 데이터 수신됨: $event');\n});\n```\n\n앱이 dispose될 때 백그라운드 서비스를 중지하는 것을 잊지 마세요:\n\n```js\n@override\nvoid dispose() {\n  service.stop();\n  super.dispose();\n}\n```\n\n# 마무리:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nflutter_background_service을 사용하면 Flutter에서 백그라운드 작업을 처리하는 것이 매끄럽게 이루어집니다. onStart 함수를 이해하고 DartPluginRegistrant를 초기화하며 네이티브 측에서 서비스를 호출함으로써 Flutter 앱의 기능을 향상시킬 수 있습니다. 특히, 타이머 기반 작업을 탐구한 것은 백그라운드 서비스에 동적인 요소를 추가하여 앱이 백그라운드에 있을 때도 주기적인 업데이트를 가능케 합니다.\n\nflutter_background_service와 백그라운드 서비스의 힘을 받아 Flutter 앱의 성능과 사용자 경험을 향상시켜 보세요.\n\n코딩 즐기세요!","ogImage":{"url":"/assets/img/2024-06-21-ElevateYourFlutterAppwithBackgroundServicesusingflutter_background_service_0.png"},"coverImage":"/assets/img/2024-06-21-ElevateYourFlutterAppwithBackgroundServicesusingflutter_background_service_0.png","tag":["Tech"],"readingTime":4},{"title":"Azure DevOps 파이프라인을 사용하여 Flutter iOS 앱을 빌드하고 배포하는 CICD 가이드","description":"","date":"2024-06-21 23:07","slug":"2024-06-21-BuildandDeployCICDforFlutteriOSAppReleasewithAzureDevOpsPipelines","content":"\n\n인디 소프트웨어 개발자로서, 내 Flutter 앱을 App Store에 고객에게 제공하는 것은 불가능한 일처럼 보였어요. 인증서를 관리하고, App Store Connect를 탐색하고, 테스트 릴리스를 구성하는 사이에, 진전이 없이 몇 일 동안 좌절했죠.\n\nAzure 파이프라인을 활용하여, 제가 iOS 배포를 위한 신뢰할 수 있고 반복 가능한 CI/CD 워크플로우를 설정할 수 있었어요. 더 이상 주말을 낭비하여 앱 업데이트를 수동으로 빌드, 테스트, 발행할 필요가 없어요.\n\n이제 매번 커밋이 자동 빌드와 테스트 통과, 그리고 TestFlight로 피드백을 받는 릴리스를 발생시켜요. \n\n이 가이드는 얻어온 경험, 시행착오, 여러 번의 반복을 토대로 작성했어요. 제 목표는 동료 iOS 개발자들이 겪은 고통을 덜어드리는 거예요. 여기서 상세하고 실행 가능한 단계를 제시함으로써, 여러분은 iOS 애플리케이션을 위한 간소화된 CI/CD 파이프라인을 세우는 데 필요한 도구를 갖추게 될 거예요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 전제 조건\n\n- 활성화된 Apple 개발자 계정과 ​​App Store Connect 액세스\n- XCode에서의 iOS 앱 프로젝트\n- Azure DevOps 조직에 대한 액세스\n- IOS 앱 서명 프로세스를 시작하기 위한 p12 및 모바일 Provisional 인증서에 대한 액세스\n\nAzure DevOps Marketplace\n\n- Apple App Store 확장 프로그램https://marketplace.visualstudio.com/items?itemName=ms-vsclient.app-store을 설치하십시오. 이를 통해 App Store API와 통합할 수 있습니다.\n- Azure DevOps Marketplace에서 Flutter https://marketplace.visualstudio.com/items?itemName=Hey24sheep.flutter 확장 프로그램을 설치하십시오. 이를 통해 Flutter 앱을 빌드할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# iOS 서명 인증서 설정하기\n\nP12 인증서 생성하기\n\niOS 앱에 서명하기 위해 필요한 P12 인증서를 생성하는 방법에 대한 자세한 설명은 다음 문서를 활용해주세요: [iOS 앱을 서명하기 위한 CSR 및 P12 인증서 생성 방법](https://www.cheapsslsecurity.com).\n\n해당 문서는 iOS 앱을 서명하기 위해 필요한 p12 인증서를 생성하는 방법에 대한 상세한 지침을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로비저닝 프로필 생성하기\n\n애플 개발자 페이지에서 Certificates, Identifiers \u0026 Profiles(`아이덴티파이어`) 섹션으로 이동하세요.\n\n- Profiles에서 새 프로필을 추가하려면 클릭하세요.\n- 앱을 앱 스토어에 제출하기 위한 배포용 프로비저닝 프로필을 생성하려면 App Store를 선택하세요.\n- 계속해서 `Your_APP_ID` 앱 식별자를 선택하세요.\n- 계속해서 프로비저닝 프로필을 생성하고 저장하고 다운로드하세요.\n\n# Azure 파이프라인 설정하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Azure DevOps 프로젝트에서, 파이프라인 `라이브러리` 보안 파일로 이동해 \"mobileProvisional\" 및 \"p12\" 인증서를 추가하세요. 이전에 생성한 인증서입니다.\n\n![이미지](/assets/img/2024-06-21-BuildandDeployCICDforFlutteriOSAppReleasewithAzureDevOpsPipelines_0.png)\n\n2. Pipelines로 이동하여 `새 파이프라인 생성` 을 클릭하세요.\n\n![이미지](/assets/img/2024-06-21-BuildandDeployCICDforFlutteriOSAppReleasewithAzureDevOpsPipelines_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 옵션으로 \"전통적인 편집기 사용\"을 선택합니다\n\n![이미지](/assets/img/2024-06-21-BuildandDeployCICDforFlutteriOSAppReleasewithAzureDevOpsPipelines_2.png)\n\n3. Azure 저장소를 선택합니다\n\n![이미지](/assets/img/2024-06-21-BuildandDeployCICDforFlutteriOSAppReleasewithAzureDevOpsPipelines_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n4. \"빈 작업\"을 선택합니다.\n\n![이미지](/assets/img/2024-06-21-BuildandDeployCICDforFlutteriOSAppReleasewithAzureDevOpsPipelines_4.png)\n\n5. \"+\" 버튼을 클릭하고 파이프라인에 다음과 같은 라이트 그레이 작업을 추가하고 각 작업의 세부 정보를 모두 입력합니다. 아래의 YAML 파일을 참조로 사용해주세요.\n\n- 에이전트에서 실행을 선택하고 에이전트 풀을 \"Azure Pipelines\"로 지정하고 에이전트 사양을 \"macos-latest\"로 지정합니다.\n- 파이프라인을 준비한 후에 \"저장 및 대기열\"을 클릭하여 파이프라인을 트리거합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-21-BuildandDeployCICDforFlutteriOSAppReleasewithAzureDevOpsPipelines_5.png)\n\n아래는 참고용 yaml 코드입니다.\n\n```js\npool:\n  name: Azure Pipelines\n  demands: xcode\n\nsteps:\n- task: JavaToolInstaller@0\n  displayName: 'Java 11 사용'\n  inputs:\n    versionSpec: 11\n    jdkArchitectureOption: x64\n    jdkSourceOption: PreInstalled\n\n- task: InstallAppleCertificate@2\n  displayName: 'P12 인증서 설치'\n  inputs:\n    certSecureFile: '\u003c인증서_파일\u003e'\n    certPwd: '\u003c비밀번호\u003e'\n    setUpPartitionIdACLForPrivateKey: false\n\n- task: InstallAppleProvisioningProfile@1\n  displayName: '프로비저닝 프로필 설치'\n  inputs:\n    provProfileSecureFile: '\u003c프로비저닝_파일\u003e'\n\n- task: Hey24sheep.flutter.flutter-install.FlutterInstall@0\n  displayName: 'Flutter 설치'\n  inputs:\n    version: custom\n    customVersion: 3.7.9\n\n- task: Hey24sheep.flutter.flutter-command.FlutterCommand@0\n  displayName: 'Flutter Clean'\n  inputs:\n    arguments: clean\n\n- task: Hey24sheep.flutter.flutter-build.FlutterBuild@0\n  displayName: 'Flutter iOS 빌드'\n  inputs:\n    target: ios\n    buildFlavour: prod\n    buildNumber: '$(Build.BuildNumber)'\n    entryPoint: 'lib/main_prod.dart'\n    iosCodesign: false\n\n- task: Xcode@5\n  displayName: 'Xcode 빌드 prod'\n  inputs:\n    configuration: 'Release-prod'\n    sdk: iphoneos\n    xcWorkspacePath: '**/Runner.xcworkspace'\n    scheme: prod\n    packageApp: true\n    archivePath: ./build/ios/iphoneos/Runner.xcarchive\n    exportPath: ./build/ios/iphoneos/Runner.ipa\n    exportOptions: plist\n    exportOptionsPlist: ./ios/ExportOptions.plist\n    signingOption: manual\n    signingIdentity: '$(APPLE_CERTIFICATE_SIGNING_IDENTITY)'\n    provisioningProfileUuid: '$(APPLE_PROV_PROFILE_UUID)'\n\n- task: CopyFiles@2\n  displayName: '파일 복사'\n  inputs:\n    SourceFolder: .\n    Contents: '**/*.ipa'\n    TargetFolder: '$(Build.ArtifactStagingDirectory)'\n\n- task: PublishBuildArtifacts@1\n  displayName: 'Prod Artifact 게시'\n  inputs:\n    ArtifactName: 'ios ipa'\n```\n\n상기 파이프라인은 여러분의 파이프라인 내에서 아티팩트를 게시하며, 이를 이후 배포 파이프라인에서 사용할 것입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](/assets/img/2024-06-21-BuildandDeployCICDforFlutteriOSAppReleasewithAzureDevOpsPipelines_6.png)\n\n# Azure 서비스 연결 생성하기\n\nAzure 앱 스토어 익스텐션을 사용하려면 앱 스토어에 앱을 게시할 수 있는 액세스 권한이 있는 서비스 자격 증명이 필요합니다. 계정에는 '앱 관리자 또는 관리자' 역할이 설정되어야 합니다.\n\n- DevOps 프로젝트에서 프로젝트 설정으로 이동합니다.\n- 서비스 연결 탭을 선택합니다.\n- 새 서비스 연결을 추가하고 Apple App Store를 선택합니다.\n- 새 연결에 이름을 지정하고 Apple 계정의 자격 증명을 입력합니다.\n- 앱별 패스워드를 제공합니다 (계정이 2단계 인증을 사용 중인 경우). 계정이 2단계 인증을 사용하지 않는 경우 이 값을 전달할 필요가 없습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 서비스 연결 이름은 파이프라인 릴리스 단계에서 사용할 수 있습니다.\n\n## 이중 인증 프로세스\n\n게시 계정에서 특정 응용 프로그램 비밀번호를 만들어야 합니다.\n\n- http://appleid.apple.com/account/manage에 방문\n- 새로운 응용 프로그램별 비밀번호를 생성\n- 위 단계에서 사용할 이 비밀번호를 메모하세요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 앱 스토어 릴리스 파이프라인 설정\n\n- Azure DevOps 프로젝트에서 파이프라인으로 이동하여 `릴리스` 새 릴리스 파이프라인을 만들고 템플릿을 \"빈 작업\"으로 선택합니다.\n- \"아티팩트 추가\"를 선택한 다음 위에서 만든 파이프라인을 선택합니다. (이 아티팩트는 App Store Connect에 업로드하는 데 사용됩니다)\n\n![이미지](/assets/img/2024-06-21-BuildandDeployCICDforFlutteriOSAppReleasewithAzureDevOpsPipelines_7.png)\n\n- 스테이지에 빈 작업을 추가하고 아래의 작업 \"Apple App Store 릴리스\"를 추가합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 에이전트에서 실행을 선택하고 에이전트 풀을 \"Azure 파이프라인\"으로 지정하고 에이전트 사양을 \"macos-latest\"로 지정합니다.\n- 위에서 만든 서비스 연결을 선택합니다.\n- 작업에서 빌드 처리 대기를 건너뜁니다.\n- 앱 정보 내부에있는 번들 ID 및 App 특정 Apple ID를 추가합니다. 번들 ID 및 App 특정 Apple ID는 https://appstoreconnect.apple.com/ 에서 찾을 수 있습니다.\n- 세 점을 클릭하여 아티팩트의 이진 경로를 선택합니다.\n\n![이미지](/assets/img/2024-06-21-BuildandDeployCICDforFlutteriOSAppReleasewithAzureDevOpsPipelines_8.png)\n\n4. 새 릴리스를 생성하면 로그에서 다음과 같은 성공 메시지가 표시됩니다. 이것은 아티팩트가 앱 스토어 커넥트 'Test Flight'에 업로드되었음을 확인합니다.\n\n![이미지](/assets/img/2024-06-21-BuildandDeployCICDforFlutteriOSAppReleasewithAzureDevOpsPipelines_9.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 앱 스토어 테스트 플라이트 확인\n\n![이미지](/assets/img/2024-06-21-BuildandDeployCICDforFlutteriOSAppReleasewithAzureDevOpsPipelines_10.png)\n\n그리고 이것으로 iOS 앱을 위한 CI/CD를 구현하는 시작부터 끝까지의 가이드를 마무리합니다! 제 경험을 경험하면서 유용한 통찰을 얻을 수 있기를 바랍니다. 개발 단계에서 적용할 수 있도록 도움이 되기를 바랍니다.","ogImage":{"url":"/assets/img/2024-06-21-BuildandDeployCICDforFlutteriOSAppReleasewithAzureDevOpsPipelines_0.png"},"coverImage":"/assets/img/2024-06-21-BuildandDeployCICDforFlutteriOSAppReleasewithAzureDevOpsPipelines_0.png","tag":["Tech"],"readingTime":7},{"title":"Flutter FCM - 푸시 알림 탭 후 특정 화면으로 이동하는 방법","description":"","date":"2024-06-21 23:04","slug":"2024-06-21-FlutterFCMHowtoNavigatetoaParticularScreenAfterTappingonPushNotification","content":"\n\n이 게시물에서는 FCM 푸시 알림을 수신하고 사용자가 푸시 알림을 탭했을 때 특정 페이지로 이동하는 방법에 대해 Flutter에서 설명하겠습니다 (서버 측 코드 없음).\n\n![Flutter FCM How to Navigate to a Particular Screen After Tapping on Push Notification](/assets/img/2024-06-21-FlutterFCMHowtoNavigatetoaParticularScreenAfterTappingonPushNotification_0.png)\n\n## iOS 설정\n\nApple의 플랫폼에서 개발하는 것은 때로 어려울 수 있습니다. 예를 들어 Android와는 달리, 푸시 알림을 테스트하려면 실제 기기가 필요하며 Apple 개발자 프로그램에 관리자 또는 계정 보유자로 등록해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Xcode에서 Targets ` Runner ` Signing \u0026 Capabilities로 이동하여 푸시 알림을 추가하려면 +를 눌러주세요. 그리고 Background Modes에 Background fetch와 Remote notification도 추가해주세요.\n\n2. Apple Developer Member Center에서 Certificates, Identifiers \u0026 Profile로 이동하여 `Keys`에서 Apple Push Notification service (APN) 키를 추가해주세요. 그런 다음, 해당 키를 Firebase Console `Project Settings` Cloud Messaging `Apple app configuration`에 추가해주세요.\n\n3. 나머지는 매우 간단합니다 — 공식 문서를 참조해주세요.\n\n## Android 설정\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nForeground Notification(푸시 알림이 일시적으로 화면 상단에 팝업되는 경우)을 사용하려면 AndroidManifest.xml에 아래의 메타데이터가 필요합니다. 'high_importance_channel'에 대한 고급 중요도 채널은 Firebase 공식 문서에서 제공된 이름을 사용했으며 platformChannelSpecifics에서 (아래에서 자세히 설명함) 채널 이름을 지정할 수 있습니다.\n\n```js\n\u003cmeta-data\n android:name=\"com.google.firebase.messaging.default_notification_channel_id\"\n android:value=\"high_importance_channel\" /\u003e\n```\n\n## Firebase 초기화\n\n먼저 필요한 모든 패키지를 추가해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nflutter pub add firebase_messaging\nflutter pub add firebase_core\nflutter pub add flutter_local_notifications\n```\n\n파일들을 프로바이더와 서비스 파일로 분리하는 것에 익숙하지만, 그렇게 하는 것이 필요하지는 않습니다. Firebase 초기화에 대해 말씀드리면 main 함수에서 해야 합니다.\n\n```js\nvoid main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n  await FirebaseService.initializeFirebase();\n  runApp(const MyApp());\n}\n```\n\n```js\nimport 'dart:async';\n\nimport 'package:firebase_core/firebase_core.dart';\nimport 'package:firebase_messaging/firebase_messaging.dart';\nimport 'package:flutter_local_notifications/flutter_local_notifications.dart';\n\nclass FirebaseService {\n  static FirebaseMessaging? _firebaseMessaging;\n  static FirebaseMessaging get firebaseMessaging =\u003e FirebaseService._firebaseMessaging ?? FirebaseMessaging.instance;\n\n  static Future\u003cvoid\u003e initializeFirebase() async {\n    await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);\n    FirebaseService._firebaseMessaging = FirebaseMessaging.instance;\n    await FirebaseService.initializeLocalNotifications();\n    await FCMProvider.onMessage();\n    await FirebaseService.onBackgroundMsg();\n  }\n\n  Future\u003cString?\u003e getDeviceToken() async =\u003e await FirebaseMessaging.instance.getToken();\n\n  static FlutterLocalNotificationsPlugin _localNotificationsPlugin = FlutterLocalNotificationsPlugin();\n  \n  static Future\u003cvoid\u003e initializeLocalNotifications() async {\n    final InitializationSettings _initSettings = InitializationSettings(\n      android: AndroidInitializationSettings(\"icon_name\"),\n      iOS: DarwinInitializationSettings()\n    );\n    /// on did receive notification response = for when app is opened via notification while in foreground on android\n    await FirebaseService.localNotificationsPlugin.initialize(_initSettings, onDidReceiveNotificationResponse: FCMProvider.onTapNotification);\n    /// need this for ios foregournd notification\n    await FirebaseService.firebaseMessaging.setForegroundNotificationPresentationOptions(\n      alert: true, // Required to display a heads up notification\n      badge: true,\n      sound: true,\n    );\n  }\n  \n  static NotificationDetails platformChannelSpecifics = NotificationDetails(\n    android: AndroidNotificationDetails(\n      \"high_importance_channel\", \"High Importance Notifications\", priority: Priority.max, importance: Importance.max,\n    ),\n  );\n  \n  // for receiving message when app is in background or foreground\n  static Future\u003cvoid\u003e onMessage() async {\n    FirebaseMessaging.onMessage.listen((RemoteMessage message) async {\n      if (Platform.isAndroid) {\n        // if this is available when Platform.isIOS, you'll receive the notification twice \n        await FirebaseService._localNotificationsPlugin.show(\n          0, message.notification!.title, message.notification!.body, FirebaseService.platformChannelSpecifics,\n          payload: message.data.toString(),\n        );\n      }\n    });\n  }\n\n  static Future\u003cvoid\u003e onBackgroundMsg() async {\n    FirebaseMessaging.onBackgroundMessage(FCMProvider.backgroundHandler);\n  }\n\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nFirebaseService.initializeFirebase 메서드 내의 모든 메서드를 살펴보겠습니다.\n\n_firebaseMessaging: 이전 FCM 포스트를 작성하던 중 한국 어딘가에서 FirebaseMessaging.instance를 한 번만 호출하는 것이 좋다는 글을 읽은 적이 있어요. 그래서 이를 initialize 메서드에서 초기화하고, _firebaseMessaging이 null인 경우 적절한 값을 제공해주는 getter를 만들었어요.\n\ninitializeLocalNotifications: Foreground Notification을 활용하려면 이 메서드가 필요해요. Android에서는 반드시 전달해야 하는 인자 중 하나가 android/app/src/main/res/drawable에 있어야 하는 아이콘 로고 파일 이름이에요.\n\n전달된 두 번째 인자는 onSelectNotification으로, 사용자가 푸시 알림을 탭했을 때 (앱이 포그라운드에 있을 때) 실행되는 콜백입니다. 이런 처리가 없으면 앱이 열리고 더 이상의 작업이 발생하지 않아요. 이 메서드는 onMessage의 FirebaseMessaging.onMessage.listen(안드로이드용)로부터 페이로드를 받습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`onMessage`: 앱이 활성 상태인 경우에 알림을 받을 때 호출됩니다.\n\n`onBackgroundMsg`: 앱이 백그라운드에 있거나 종료된 상태일 때 알림을 받을 때 호출됩니다.\n\n## 디바이스 토큰 받기/확인\n\n```js\nFuture\u003cString?\u003e getDeviceToken() async =\u003e await FirebaseService.firebaseMessaging.getToken();\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기기 토큰을 관리하는 올바른 방법은 없지만 Firebase가 권장하는 방법이 있습니다. 제가 선택한 방법은 sqflite를 사용하여 사용자 기기에 타임스탬프와 함께 기기 토큰을 저장하고 서버로 보내는 것입니다. 앱이 열릴 때마다 기기에 저장된 토큰이 있다면 서버로 전송됩니다. 타임스탬프가 한 달 이상 경과했다는 것을 나타내는 경우, 토큰이 새로 고침되고 새 토큰이 서버로 전송됩니다. (아래 코드는 sqflite를 사용하는 제 sql 파일을 기반으로 합니다.)\n\n```js\nFuture\u003cString?\u003e checkDeviceToken() async {\n    String? _deviceToken;\n    final bool _exists = await this._sqlService.tableExists(this._tableName);\n    if (_exists) {\n        final List\u003cJson\u003e _data = await this._sqlService.readData(this._tableName);\n        final DateTime _timeStamp = DateTime.parse(_data[0][\"timeStamp\"]);\n        if (_timeStamp.difference(DateTime.now()).inDays \u003e 30) {\n            _deviceToken = await this._getDeviceToken();\n            if (_deviceToken == null) return null; // todo error handling\n            await this._updateDeviceToken(_deviceToken);\n        } else {\n            _deviceToken = _data[0][\"deviceToken\"];\n        }\n    } else {\n        _deviceToken = await this._getDeviceToken();\n        if (_deviceToken == null) return null; // todo error handling\n        await this._saveDeviceToken(_deviceToken);\n    }\n    return _deviceToken;\n}\n\nFuture\u003cString?\u003e _getDeviceToken() async =\u003e await FirebaseService.firebaseMessaging.getToken();\n  \nFuture\u003cvoid\u003e _saveDeviceToken(String deviceToken) async {\n    final String _createSql = \"CREATE TABLE ${this._tableName}(deviceToken TEXT PRIMARY KEY NOT NULL, timeStamp TEXT NOT NULL)\";\n    final List\u003cObject\u003e _values = [deviceToken, DateTime.now().toIso8601String()];\n    final String _insertSql = \"INSERT INTO ${this._tableName}(deviceToken, timeStamp) VALUES(?, ?)\";\n    await this._sqlService.saveData(tableName: this._tableName, createSql: _createSql, insertSql: _insertSql, values: _values);\n}\n\nFuture\u003cvoid\u003e _updateDeviceToken(String deviceToken) async {\n    final String _updateSql = \"UPDATE ${this._tableName} SET deviceToken = ?, timeStamp = ?\";\n    final List\u003cObject\u003e _values = [deviceToken, DateTime.now().toIso8601String()];\n    await this._sqlService.updateData(tableName: this._tableName, updateSql: _updateSql, values: _values);\n}\n```\n\n## 알림 수신\n\n불행히도 저는 서버 측 코드를 만들지 않아 message.data가 어떻게 작동하는지를 보여줄 수 없습니다. 왜냐하면 Firebase의 테스트 알림은 message.notification.body와 message.notification.title만 허용하기 때문입니다. 더 구체적인 알림을 테스트하려면 백엔드 개발자와 협력해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n푸시 알림을 받고 앱을 열 수 있는 세 가지 방법이 있습니다:\n\n- 앱이 화면에 표시될 때\n- 앱이 백그라운드에 있을 때\n- 앱이 종료되었을 때\n\n## 앱이 화면에 표시될 때 (Android)\n\n사용자가 알림을 탭하면 기본적으로 앱이 열리게 됩니다. 그러나 때로는 사용자가 특정 페이지를 볼 수 있기를 원할 수도 있습니다. 백엔드 개발자는 이러한 정보를 메시지.data에 제공할 수 있습니다. 해당 정보를 가져오기 위해 제공자를 만들었고, Navigator.of(context).push를 사용하기 위해 첫 화면에서 제공자의 BuildContext 변수를 초기화했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n@override\nvoid init() {\n  super.initState();\n  WidgetsBinding.instance.addPostFrameCallback((_) {\n    FCMProvider.setContext(context);\n  });\n}\n\n\n\nimport 'package:firebase_messaging/firebase_messaging.dart' show FirebaseMessaging, RemoteMessage;\nimport 'package:flutter/widgets.dart';\nimport 'package:pops/helpers/custom_types.dart';\n\nimport '../views/store_detail/store_detail_page.dart';\n\nclass FCMProvider with ChangeNotifier {\n  static BuildContext? _context;\n\n  static void setContext(BuildContext context) =\u003e FCMProvider._context = context;\n\n  /// when app is in the foreground\n  static Future\u003cvoid\u003e onTapNotification(NotificationResponse? response) async {\n    if (FCMProvider._context == null || response?.payload == null) return;\n    final Json _data = FCMProvider.convertPayload(response!.payload!);\n    if (_data.containsKey(...)){\n      await Navigator.of(FCMProvider._context!).push(...);\n    }\n  }\n\n  static Json convertPayload(String payload){\n    final String _payload = payload.substring(1, payload.length - 1);\n    List\u003cString\u003e _split = [];\n    _payload.split(\",\")..forEach((String s) =\u003e _split.addAll(s.split(\":\")));\n    Json _mapped = {};\n    for (int i = 0; i \u003c _split.length + 1; i++) {\n      if (i % 2 == 1) _mapped.addAll({_split[i-1].trim().toString(): _split[i].trim()});\n    }\n    return _mapped;\n  }\n  \n  static Future\u003cvoid\u003e onMessage() async {\n    FirebaseMessaging.onMessage.listen((RemoteMessage message) async {\n      if (FCMProvider._refreshNotifications != null) await FCMProvider._refreshNotifications!(true);\n      // if this is available when Platform.isIOS, you'll receive the notification twice \n      if (Platform.isAndroid) {\n        await FirebaseService.localNotificationsPlugin.show(\n          0, message.notification!.title,\n          message.notification!.body,\n          FirebaseService.platformChannelSpecifics,\n          payload: message.data.toString(),\n        );\n      }\n    });\n  }\n\n  static Future\u003cvoid\u003e backgroundHandler(RemoteMessage message) async {\n\n  }\n}\n\n\n앱이 화면에 보일 때 onTapNotification 메서드가 실행되며, localNotificationsPlugin.initialize의 onSelectNotification에 콜백 메서드로 설정됩니다. onTapNotification은 message.data.toString()을 페이로드로 받고(페이로드는 문자열로만 넣을 수 있기 때문에) 페이로드를 다시 맵으로 변환합니다.\n\n## 앱이 백그라운드에 있을 때 (Android) 및 앱이 포그라운드 / 백그라운드에 있을 때(iOS)\r\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n첫 번째 페이지에서 initState에 다음 코드를 넣었는데, 안드로이드에서 앱이 백그라운드에 있을 때 작동하는 것으로 보이며, iOS에서는 앱이 포그라운드/백그라운드에 있을 때 작동합니다.\n\n```js\nStream\u003cRemoteMessage\u003e _stream = FirebaseMessaging.onMessageOpenedApp;\n_stream.listen((RemoteMessage event) async {\n  if (event.data != null) {\n    await Navigator.of(context).push(...);\n  }\n});\n```\n\n## 앱이 종료된 경우\n\n앱이 종료된 경우 main.dart의 main 메소드에서 메시지를 받아와야 하며, 다른 곳에서 시도하면 실패할 것입니다. 저는 이 메시지를 첫 번째 페이지로 전달하고, initState에서 적절한 조치를 취했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\n// main.dart\nvoid main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n  await FirebaseService.initializeFirebase();\n  final RemoteMessage? _message = await FirebaseService.firebaseMessaging.getInitialMessage();\n  runApp(const MyApp(message: _message));\n}\n\n// 앱이 켜졌을 때 열리는 첫 번째 페이지\n@override\nvoid initState() {\n  super.initState();\n  WidgetsBinding.instance.addPostFrameCallback((_) async {\n    if (this.widget.message != null) {\n      Future.delayed(const Duration(milliseconds: 1000), () async {\n        await Navigator.of(context).pushNamed(...);\n      });\n    }\n  });\n}\n```\n\n## Backend\n\niOS에서 소리가 포함된 알림을 받으려면 Cloud 콘솔에 다음이 필요합니다: (깃헙 참조)\n\n```js\n\"apns: { \n  \"payload\": {\n    \"aps\": {\n      \"sound\": default\n    }\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n도움이 되길 바라요! 즐거운 코딩하세요.","ogImage":{"url":"/assets/img/2024-06-21-FlutterFCMHowtoNavigatetoaParticularScreenAfterTappingonPushNotification_0.png"},"coverImage":"/assets/img/2024-06-21-FlutterFCMHowtoNavigatetoaParticularScreenAfterTappingonPushNotification_0.png","tag":["Tech"],"readingTime":12},{"title":"플러터에서 Cubit 상태 관리 사용하는 방법","description":"","date":"2024-06-21 23:02","slug":"2024-06-21-CubitStateManagementinFlutter","content":"\n\n\n![Cubit State Management in Flutter](/assets/img/2024-06-21-CubitStateManagementinFlutter_0.png)\n\n상태 관리는 모바일 앱 개발에서 중요한 요소이며, 특히 UI가 반응적인 Flutter와 같은 프레임워크에서는 더욱 중요합니다. Flutter에서 다양한 상태 관리 기술 중 하나인 BLoC (Business Logic Component) 패턴이 상당한 인기를 얻었습니다. BLoC의 영역 내에서 두 가지 주요 접근 방식이 있습니다: Bloc State Management과 Cubit State Management.\n\n# Cubit이란?\n\nCubit은 BLoC 패턴의 일부인 간단하고 직관적인 상태 관리 솔루션입니다. \"Business Logic Component\"의 약자입니다. 전통적인 BLoC와는 달리, Cubit은 더 가벼우며 더 간단한 API를 가지고 있어 더 작은 프로젝트나 간단한 상태 관리 필요에 쉽게 사용할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플러터에서 Cubit 상태 관리를 시작하려면 flutter_bloc 패키지를 설치해야 합니다:\n\n```js\ndependencies: \n   flutter_bloc: ^8.1.3\n```\n\n# Cubit을 사용한 카운터 앱\n\n더 나은 이해를 위해 Cubit을 사용하여 간단한 카운터 앱을 구현해 봅시다. 단계별로 진행하겠습니다. 함께 따라와 주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n친구야, Cubit 폴더를 만들어 그 안에 counter_cubit.dart 파일을 생성해보세요.\n\n![이미지](/assets/img/2024-06-21-CubitStateManagementinFlutter_1.png)\n\n파일 안에 Cubit을 확장한 클래스를 만들어주세요.\n\n```dart\nclass CounterCubit extends Cubit {}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제: 하지만 이렇게 하면 오류가 발생합니다. 수퍼 클래스 'Cubit`dynamic`'에는 인수가 없는 생성자가 없습니다.\n\n그래서 생성자를 만들어 초기 상태를 전달해야 합니다.\n\n```js\nclass CounterCubit extends Cubit {\n  CounterCubit():super(0);\n}\n```\n\n여기서 '0'은 초기 상태이지만 문자열, 클래스 등이 될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 이제 초기 상태를 화면에 표시해야 합니다\n\n카운터 큐빗 클래스의 인스턴스를 만듭니다.\n\n이제 이 객체를 사용하여 다양한 것에 액세스할 수 있습니다:\n\n![Cubit State Management in Flutter](/assets/img/2024-06-21-CubitStateManagementinFlutter_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금은 .state를 필요로 합니다.\n\n```js\nfinal counter = CounterCubit().state;\n```\n\n필요한 곳에서 사용할 수 있습니다.\n\n```js\nText(\n '$counter',\n)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제: 작은 문제가 있습니다. 이 카운터는 동적 타입이므로 코드를 망가뜨리지는 않지만, 동적 타입을 피해야 합니다.\n\n![이미지](/assets/img/2024-06-21-CubitStateManagementinFlutter_3.png)\n\n그래서 카운터 cubic 클래스에 타입을 지정해 주세요.\n\n```js\nclass CounterCubit extends Cubit\u003cint\u003e {\n  CounterCubit() : super(0);\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 초기 상태를 성공적으로 표시했어요.\n\n## 값 증가, 상태 변경\n\n이를 위해 카운터 커빗 클래스에 값을 증가시키는 함수를 만들고 모든 청취자에게 알립니다. 상태를 변경하기 위해 emit 함수를 사용합니다.\n\nemit(state) // 제공된 [state]로 상태를 업데이트합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nclass CounterCubit extends Cubit\u003cint\u003e {\n  CounterCubit() : super(0);\n\n  void increment() {\n    emit(state + 1);\n  }\n}\n```\n\n이제 이 함수를 버튼 클릭에 사용하세요\n\n```js\nonPressed: () =\u003e CounterCubit().increment(),\n```\n\n문제: 그러나 버튼을 클릭해도 상태가 변경되지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이는 우리가 cubit의 두 개체를 생성하고 있기 때문입니다. 두 번째 cubit의 값을 업데이트하고 있습니다. 이것을 제거하려면 하나의 cubit만 사용해야 합니다.\n\n단일 객체 생성\n\n```js\nfinal counterCubit = CounterCubit();\n```\n\n그리고 이것을 모두에서 사용하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nfinal counter = counterCubit.state; // 빌드 내부\n\n```\n버튼을 누르면\n\n```js\nonPressed: () =\u003e counterCubit.increment(),\n```\n\n문제점: 그러나 한 가지 더 빠진 것이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n한 번만 값을 받아서 상태를 업데이트하고 emit이 청취자에게 통지하지만 우리는 상태를 청취하고 있지 않습니다.\n\n이제 BlocBuilder를 사용해야 합니다. 이는 flutter_bloc에서 제공하는 위젯이며 bloc과 builder라는 두 인수가 필요합니다.\n\n```js\nBlocBuilder\u003cCounterCubit, int\u003e(\n      bloc: counterCubit, // 선택 사항\n      builder: (context, counter) {\n         return Text(\n           '$counter',\n         );\n}),\n```\n\n# 완료 단계\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 Markdown 형식으로 변경해주세요.\n\n\nCreate a separate class extend with cubit, give the initial state and a function to change the state.\n\n```dart\nimport 'package:flutter_bloc/flutter_bloc.dart';\n\nclass CounterCubit extends Cubit\u003cint\u003e {\n  CounterCubit() : super(0);\n\n  void increment() {\n    emit(state + 1);\n  }\n}\n```\n\nUse the state by making a single object of the cubit class and use BlocBuilder where you need the changing state\n\n```dart\nclass _MyHomePageState extends State\u003cMyHomePage\u003e {\n  final counterCubit = CounterCubit(); // (1: object)\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: Column(\n          children: \u003cWidget\u003e[\n            const Text(\n              'You have pushed the button this many times:',\n            ),\n            // (2: state value)\n            BlocBuilder\u003cCounterCubit, int\u003e(\n              bloc: counterCubit, // optional\n              builder: (context, counter) {\n                return Text(\n                  '$counter',\n                );\n              }\n            ),\n          ],\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () =\u003e counterCubit.increment(), // (3: increment)\n        tooltip: 'Increment',\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}\n``` \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 감소 기능 추가\n\n```js\n void decrement() {\n    if (state == 0) {\n      return;\n    }\n    emit(state - 1);\n  }\n```\n\n```js\nonPressed: () =\u003e counterCubit.decrement(),\n```\n\n참고: emit() 함수는 Cubit 외부에서 사용할 수 없습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 질문: 두 개의 별도 페이지가 있는 경우\n\n두 개의 별도 페이지가 있는 경우에는 상태를 표시하는 페이지와 그 상태를 변경하는 버튼이 있는 페이지가 따로 있는 것을 의미합니다.\n\n그런데 앞서 언급한 대로 cubit 클래스의 두 개의 다른 객체를 사용할 수 없습니다.\n\n![이미지](/assets/img/2024-06-21-CubitStateManagementinFlutter_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 icc_dec_page에 버튼이 있고 home_page.dart에서 카운터를 표시하고 있습니다.\n\n카운터 Cubit의 두 인스턴스를 만들 수 없기 때문에 작동하지 않습니다. 하나의 인스턴스만 사용해야 합니다. 이 문제를 해결하기 위해 BlocProvider를 사용합니다. BlocProvider는 블록의 인스턴스를 전달하는 데 사용됩니다.\n\n따라서 main.dart에서 Material app을 BlocProvider로 래핑하고 cubit/bloc을 함수의 인수로 전달합니다.\n\nMarkdown 형식의 표로 변경:\n\nWidget build(BuildContext context) {\n    return BlocProvider( // \u003c-- 이 부분\n      create: (_) =\u003e CounterCubit(),\n      child: MaterialApp(\n        title: 'Flutter Demo',\n        theme: ThemeData(\n          colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple),\n          useMaterial3: true,\n        ),\n        home: const MyHomePage(title: 'Flutter Demo Home Page'),\n      ),\n    );\n  }\n}\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 앱 어디에서든 이 카운터 cubit 인스턴스에 액세스할 수 있습니다. 이전에 생성한 cubit 인스턴스를 제거하고 다음을 사용할 수 있습니다.\n\n```js\nfinal counterCubit = BlocProvider.of\u003cCounterCubit\u003e(context);\n```\n\nhome_page.dart에서\n\n```js\n  Widget build(BuildContext context) {\n    final counterCubit = BlocProvider.of\u003cCounterCubit\u003e(context);\n    return Scaffold(\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: \u003cWidget\u003e[\n           \n            BlocBuilder\u003cCounterCubit, int\u003e(\n                bloc: counterCubit, // optional\n                builder: (context, counter) {\n                  return Text(\n                    '$counter',\n                  );\n                }),\n          ],\n        ),\n      ),\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\ninc_dec_page.dart 파일에서\n\n```js\n @override\n  Widget build(BuildContext context) {\n    final counterCubit = BlocProvider.of\u003cCounterCubit\u003e(context);\n    return Scaffold(\n      floatingActionButton: Column(\n        mainAxisAlignment: MainAxisAlignment.end,\n        children: [\n          IconButton(\n            onPressed: () =\u003e counterCubit.increment(),\n            tooltip: '증가',\n            icon: const Icon(Icons.add),\n          ),\n          const SizedBox(\n            height: 10,\n          ),\n          IconButton(\n            onPressed: () =\u003e counterCubit.decrement(),\n            tooltip: '감소',\n            icon: const Icon(Icons.minimize),\n          ),\n        ],\r\n```\n\n이 예시의 전체 코드는 제 GitHub 저장소에서 확인할 수 있습니다:\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n요약하자면, Cubit은 bloc 및 provider 패키지의 장점을 결합하여 상태를 관리하는 간단한 방법을 제공하며 이벤트의 복잡성 없이 상태를 관리할 수 있습니다. Cubit은 메서드 중심의 접근 방식과 최소한의 보일러플레이트 코드로 상태 관리를 간소화하므로 Flutter 개발자들에게 효율성과 구현 용이성을 위한 탁월한 선택지가 됩니다.\n\n- 👔 LinkedIn: muhammadnaqeeb\n- 💻 GitHub: muhammadnaqeeb","ogImage":{"url":"/assets/img/2024-06-21-CubitStateManagementinFlutter_0.png"},"coverImage":"/assets/img/2024-06-21-CubitStateManagementinFlutter_0.png","tag":["Tech"],"readingTime":8}],"page":"3","totalPageCount":21,"totalPageGroupCount":2,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"3"},"buildId":"4HDhroK4kHnB5DAbbbGv3","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>