<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>uidev-css</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://uidev-css.github.io///posts/3" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="uidev-css" data-gatsby-head="true"/><meta property="og:title" content="uidev-css" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://uidev-css.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://uidev-css.github.io///posts/3" data-gatsby-head="true"/><meta name="twitter:title" content="uidev-css" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | uidev-css" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-b7042cf2308ecd1e.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/ckvP8zvWyPnScUqpsTElP/_buildManifest.js" defer=""></script><script src="/_next/static/ckvP8zvWyPnScUqpsTElP/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UIDEV CSS</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Git 브랜치 명령어를 마스터하는 방법 전문가처럼 Git 브랜치 다루기" href="/post/2024-06-23-NavigatingGitBranchesLikeaProTheGitBranchCommand"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Git 브랜치 명령어를 마스터하는 방법 전문가처럼 Git 브랜치 다루기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-NavigatingGitBranchesLikeaProTheGitBranchCommand_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Git 브랜치 명령어를 마스터하는 방법 전문가처럼 Git 브랜치 다루기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Git 브랜치 명령어를 마스터하는 방법 전문가처럼 Git 브랜치 다루기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="모든 개발자가 즐겨찾기에 추가해야 할 6개의 최고의 웹사이트" href="/post/2024-06-23-6BestWebsitesforEveryDevelopersBookmarkBar"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="모든 개발자가 즐겨찾기에 추가해야 할 6개의 최고의 웹사이트" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-6BestWebsitesforEveryDevelopersBookmarkBar_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="모든 개발자가 즐겨찾기에 추가해야 할 6개의 최고의 웹사이트" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">모든 개발자가 즐겨찾기에 추가해야 할 6개의 최고의 웹사이트</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter GetX 상태 관리 쉽게 이해하기" href="/post/2024-06-23-FlutterGetXStateManagement"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter GetX 상태 관리 쉽게 이해하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-FlutterGetXStateManagement_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter GetX 상태 관리 쉽게 이해하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Flutter GetX 상태 관리 쉽게 이해하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Keystore를 사용하여 Flutter 앱 서명하는 방법" href="/post/2024-06-23-SigningyourflutterappwithKeystore"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Keystore를 사용하여 Flutter 앱 서명하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-SigningyourflutterappwithKeystore_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Keystore를 사용하여 Flutter 앱 서명하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Keystore를 사용하여 Flutter 앱 서명하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter를 클라우드에 연결하는 방법 2024 최신 가이드" href="/post/2024-06-23-FluttertoCloud"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter를 클라우드에 연결하는 방법 2024 최신 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-FluttertoCloud_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter를 클라우드에 연결하는 방법 2024 최신 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Flutter를 클라우드에 연결하는 방법 2024 최신 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter 카드 위젯 완벽 가이드 고급 기능을 활용한 아름다운 카드 만들기 방법" href="/post/2024-06-23-CompleteGuidetoCardWidgetinFlutterCreatingBeautifulCardswithAdvancedFeatures"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter 카드 위젯 완벽 가이드 고급 기능을 활용한 아름다운 카드 만들기 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-CompleteGuidetoCardWidgetinFlutterCreatingBeautifulCardswithAdvancedFeatures_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter 카드 위젯 완벽 가이드 고급 기능을 활용한 아름다운 카드 만들기 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Flutter 카드 위젯 완벽 가이드 고급 기능을 활용한 아름다운 카드 만들기 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter 앱 테마 커스터마이즈 라이트와 다크 모드 전환 및 익스텐션 사용 방법" href="/post/2024-06-23-CustomizeFlutterAppThemesSwappingBetweenLightDarkModesandUsingExtensions"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter 앱 테마 커스터마이즈 라이트와 다크 모드 전환 및 익스텐션 사용 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-CustomizeFlutterAppThemesSwappingBetweenLightDarkModesandUsingExtensions_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter 앱 테마 커스터마이즈 라이트와 다크 모드 전환 및 익스텐션 사용 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Flutter 앱 테마 커스터마이즈 라이트와 다크 모드 전환 및 익스텐션 사용 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter와 SocketIO 실시간 통합 방법" href="/post/2024-06-23-FlutterandSocketIOReal-timeIntegration"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter와 SocketIO 실시간 통합 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-FlutterandSocketIOReal-timeIntegration_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter와 SocketIO 실시간 통합 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Flutter와 SocketIO 실시간 통합 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter에서 동적으로 앱 아이콘 변경하는 방법" href="/post/2024-06-23-DynamicchangeAppIconFlutter"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter에서 동적으로 앱 아이콘 변경하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-DynamicchangeAppIconFlutter_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter에서 동적으로 앱 아이콘 변경하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Flutter에서 동적으로 앱 아이콘 변경하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">22<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="VSCode를 사용하여 Android Studio 대신 Windows 환경에서 Flutter 프로그래밍하는 방법" href="/post/2024-06-23-FlutterprogrammingforandroidwithVSCodeinsteadofusingAndroidStudioinWindows"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="VSCode를 사용하여 Android Studio 대신 Windows 환경에서 Flutter 프로그래밍하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-FlutterprogrammingforandroidwithVSCodeinsteadofusingAndroidStudioinWindows_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="VSCode를 사용하여 Android Studio 대신 Windows 환경에서 Flutter 프로그래밍하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">VSCode를 사용하여 Android Studio 대신 Windows 환경에서 Flutter 프로그래밍하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link posts_-active__YVJEi" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Git 브랜치 명령어를 마스터하는 방법 전문가처럼 Git 브랜치 다루기","description":"","date":"2024-06-23 15:01","slug":"2024-06-23-NavigatingGitBranchesLikeaProTheGitBranchCommand","content":"\n\n\u003cimg src=\"/assets/img/2024-06-23-NavigatingGitBranchesLikeaProTheGitBranchCommand_0.png\" /\u003e\n\n프로 페셔널 소프트웨어 개발자로서, 코드베이스와 mapaches 🦝 커뮤니티 사이에 몇 가지 유사성을 알아차릴 수 있습니다. 이 둘 모두 복잡하게 조직되어 있고 이해하는 데 인내가 필요하며, 발견해야 할 숨겨진 보물이 많습니다.\n\n이 기사에서는 명령줄과 GitHub Desktop을 사용하여 Git 브랜치의 숲 속 길을 안내하겠습니다. 네, 이 모험을 안내해 줄 가이드는 코드 mapache입니다, 왜냐하면 (히싱)! \n\n# Git에서 브랜치의 기초\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n브랜치는 Git 버전 관리의 중요한 부분입니다. 이를 통해 개발자들은 주로 메인 브랜치(또는 때로는 develop 브랜치)를 방해하지 않고 동시에 다른 기능을 작업할 수 있습니다.\n\n\n# 새로운 mapache 브랜치를 만들어봅시다!\ngit branch \"new_mapache_branch\"\n\n# 새로운 브랜치로 이동해봅시다.\ngit checkout \"new_mapache_branch\"\n\n\n이 새로운 브랜치에서 작업을 수행한 후에는 명령줄이나 PR에서 메인(또는 develop) 브랜치로 다시 병합할 수 있습니다.\n\n\n# develop 브랜치로 변경합니다.\ngit checkout \"develop\"\n\n# mapache 브랜치를 develop에 병합합니다.\ngit merge \"new_mapache_branch\"\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 이미 알고 계시죠? 그러니 마치 우리의 mapache 친구들처럼 앞으로 달려가 더 많은 브랜치 관리 팁과 트릭에 대해 이야기해봅시다.\n\n# 초보를 넘어서: Git을 활용한 브랜치 관리\n\ngit branch 명령어의 일부 기능 중 명확하지 않은 기능들은 브랜치를 쉽게 나열, 이름 변경 및 삭제할 수 있는 기능을 제공합니다.\n\n```js\n# 모든 브랜치 나열:\ngit branch\n\n# 브랜치 이름 변경:\ngit branch -m \"old_mapache_branch\" \"new_mapache_branch\"\n\n# 로컬 mapache 브랜치 삭제:\ngit branch -d \"mapache_branch_to_delete\"\n\n# 원격 mapache 브랜치 삭제:\ngit branch -d -r \"remote_mapache_branch_to_delete\"\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n-m 옵션은 브랜치의 이름을 변경할 때 사용되며, -d 옵션은 브랜치를 삭제할 때 사용됩니다. 하지만 주의해서 사용해주세요! 한 번 브랜치가 삭제되면 쉽게 되돌릴 수 없습니다.\n\n게다가, 새로운 브랜치를 만들고 동시에 전환할 수도 있는데, git branch를 사용하지 않고 git checkout -b을 시도해보세요:\n\n```js\n# 새로운 브랜치를 생성하고 동시에 전환하기:\ngit checkout -b \"another_mapache_branch\"\n```\n\n나무를 빠르게 오르는 맵라체와 같이, 이 명령어는 땀 흘리지 않고 새로운 브랜치에서 작업을 시작할 수 있도록 도와줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# GitHub Desktop을 사용하여 브랜치 보기 및 삭제하기\n\n명령 줄은 훌륭하지만 때로는 시각적 인터페이스가 모든 차이를 만들어 줍니다. 여기 GitHub Desktop이 나의 가장 좋아하는 Git GUI입니다.\n\nGitHub Desktop에서 레파지토리를 열고 GUI의 상단 작업 행의 중간에 있는 Current Branch 버튼을 클릭하세요. 여기서 모든 브랜치 목록이 표시됩니다. 브랜치를 클릭하면 해당 브랜치가 자동으로 체크아웃되며 새 브랜치를 생성하는 것도 매우 쉽습니다.\n\nGitHub Desktop에서 새 브랜치를 생성하려면 상단의 Branch 메뉴를 클릭한 후 New branch... 메뉴 옵션을 선택하세요. 기본 브랜치(일반적으로 main)에 있지 않은 경우 현재 브랜치에서 분기를 만들 것인지 기본(main)에서 분기를 만들 것인지 선택할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 새 브랜치 이름을 입력란에 작성하고 \"브랜치 생성\" 버튼을 클릭하세요. 그러면 자동으로 체크아웃됩니다. 마치 git checkout -b처럼요.\n\n브랜치를 삭제하려면 다시 맨 위의 현재 브랜치 버튼을 클릭하여 모든 브랜치 목록으로 돌아가세요. 특정 브랜치에서 마우스 오른쪽 버튼을 클릭한 후 삭제...를 선택하고 확인하면 브랜치가 삭제됩니다. 마치 수풀 속에서 사라지는 맵라체나 git branch -d 명령어처럼요.\n\n# 코드 협업을 위한 원격 Git 브랜치 사용\n\n우리의 Git 모험에서 원격 브랜치를 관리하는 개념은 중요합니다. 우리는 로컬에서 Git을 사용할 수 있지만 코드를 원격 \"origin\" 서버에 공유하지 않는 한, 우리는 일반적으로 다른 전문 개발자들과 협업하고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n원격 브랜치는 원격 저장소인 \"origin 서버\"에 있는 브랜치의 상태를 가리키는 참조(포인터)를 제공합니다. 원격 브랜치는 마치 북마크처럼 작동하여 원격 저장소의 브랜치가 마지막으로 연결된 시점을 상기시킵니다.\n\n다음과 같이 원격 브랜치를 가져올 수 있습니다:\n\n```js\n# \"origin 서버\"로부터 원격 브랜치 가져오기\ngit fetch origin \"remote_mapache_branch\"\n```\n\n해당 원격 브랜치에서 작업을 시작하려면 이전과 같이 git checkout -b 명령을 사용하여 해당 원격 브랜치를 확인하고 로컬 브랜치를 생성해야합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# \"tracking branch\"을 사용하여 원격 브랜치를 로컬 브랜치로 체크아웃하기\ngit checkout -b \"local_mapache_branch\" origin/\"remote_mapache_branch\"\n```\n\n그러면 Git은 로컬 브랜치와 해당 원격 브랜치를 연결하는 \"tracking branch\" 또는 \"upstream branch\"를 설정합니다.\n\n로컬 브랜치를 원격 저장소로 푸시하려면 다음을 사용합니다:\n\n```js\n# 로컬 브랜치를 원격 저장소인 origin에 푸시하기\ngit push origin \"local_mapache_branch\"\n\n# \"tracking branch\"로 설정되어 있으므로 origin/\"remote_mapache_branch\"가 업데이트됩니다\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이것은 다른 사람들에게 당신이 거기에 있었고 변경 사항을 만들 수도 있다는 것을 알리는 코드 mapache가 표시된 것과 비슷합니다. 🦝\n\nGitHub 데스크톱에서 브랜치를 삭제하는 주제로 돌아가면, 로컬 브랜치를 삭제하려고 시도하면 원격 브랜치를 추적하는 경우 로컬 브랜치만 삭제할지 원격 브랜치도 삭제할지 물어보게 됩니다.\n\n# 오래된 브랜치 정리: Git Fetch 대 브랜치 삭제\n\n좋은 mapache가 하루 종일 쓰레기를 먹은 후에 서식지를 청소하는 것과 마찬가지로, Git은 오래된 사용되지 않는 브랜치를 정리할 수 있도록 해줍니다. 🧹\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n협업자가 원격 저장소에서 브랜치를 삭제할 때, 로컬 저장소는 이러한 브랜치에 대한 참조를 제거하지 않습니다.\n\n시간이 지남에 따라 이러한 구식된 참조(또한 \"둥근 브랜치\"라고도 함)가 저장소를 메우기 시작합니다.\n\n이러한 참조를 제거하기 위해 Git은 --prune 옵션을 제공합니다.\n\n```js\n# 브랜치 정리\ngit fetch --prune\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n--prune 옵션은 삭제된 원격 브랜치에 대한 로컬 저장소의 원격 추적 참조를 제거합니다.\n\n또한 \"마스터에 병합된 로컬 브랜치에서 지난 한 달 이내의 마지막 커밋이 있는 경우 삭제 명령만 표시하는 안전한 방법을 공유하고 싶습니다\":\n\n```js\nfor k in $(git branch --format=\"%(refname:short)\" --merged master); do \n  if (($(git log -1 --since='1 month ago' -s $k|wc -l)==0)); then\n    echo git branch -d $k\n  fi\ndone\n```\n\n이는 estani의 스택 오버플로 응답에서 나온 내용으로, 엔지니어링 팀을 관리하는 업무에서 유용하게 사용했던 내용입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해당 명령은 git branch -d 명령어를 화면에 출력하기 때문에 실행하기 전에 명령어를 미리 확인하는 안전한 방법입니다.\n\n댓글러인 Asaf Pinhassi라는 사람이 이 명령에 -r을 추가하여 원격 브랜치를 나열할 수 있다는 팁을 제시했는데, 이것을 여기에 추가하는 것은 좋은 팁입니다!\n\n# 그럼 이만 해요! 여러분! 전 다 브랜치로 이루어진 상태입니다.\n\n우리는 쥐너구리처럼 유연하게 Git 브랜치의 덤불을 탐험했습니다. 브랜치를 만들고, 이름을 바꾸고, 삭제하는 방법을 보았으며, 시각적 브랜치 관리를 위해 GitHub Desktop을 사용하는 방법과 오래된 브랜치를 정리하는 방법을 살펴보았습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGit 브랜치 습득은 지도처럼 이해해야 한다는 걸 기억해두세요: 인내와 시간이 필요합니다. 그러나 한 번 이해하면, 브랜치는 개발과 협업을 원할하게 돕는 다재다능한 도구임을 깨닫게 될 거에요.\n\n코딩 즐기세요! 🌲\n\n이 글을 좋아하셨다면, 제 다른 인기 글 몇 개도 좋아하실 거에요:\n\n![2024-06-23-NavigatingGitBranchesLikeaProTheGitBranchCommand_1.png](/assets/img/2024-06-23-NavigatingGitBranchesLikeaProTheGitBranchCommand_1.png)","ogImage":{"url":"/assets/img/2024-06-23-NavigatingGitBranchesLikeaProTheGitBranchCommand_0.png"},"coverImage":"/assets/img/2024-06-23-NavigatingGitBranchesLikeaProTheGitBranchCommand_0.png","tag":["Tech"],"readingTime":5},{"title":"모든 개발자가 즐겨찾기에 추가해야 할 6개의 최고의 웹사이트","description":"","date":"2024-06-23 14:59","slug":"2024-06-23-6BestWebsitesforEveryDevelopersBookmarkBar","content":"\n\n![이미지](/assets/img/2024-06-23-6BestWebsitesforEveryDevelopersBookmarkBar_0.png)\n\n웹은 놀라운 정글이에요. 파란만장한 정글이에요. 사실, 무료 요리 레시피(필요한 이유!)와 머리가 돌아가도록 하는 충분한 스택 오버플로우 이야기로 가득 차 있어요.\n\n그러나 디지털 정글 속을 es 선택된 것이 항상 완벽하지는 않아요. CSS 버그를 디버깅 하거나 이상한 JavaScript 함수에 고심 중이더라도요.\n\n즐겨 찾는 웹사이트 모음은 코딩 도중 겪는 폭풍우 속에서 개인적인 휴식처 역할을 할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n친구처럼, 시간과 스트레스를 절약하고 소중한 정신적 안정을 위한 길잡이로 상상해보세요.\n\n일반적인 어려움에 대한 답변을 찾아다니느라 시간을 낭비하지 말고, 한 번의 클릭으로 쉽게 해결책을 찾을 수 있습니다.\n\n그러니 커피를 가져와서, 몇 가지 필수 웹사이트를 시작해 봅시다.\n\n# SitePoint\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSitePoint은 웹 개발 지식을 얻을 수 있는 최고의 자원이에요.\n\nSitePoint은 최신 프레임워크에 대한 깊은 강좌부터 일상적인 코딩 과제를 극복하는 실용적인 조언까지 모두 제공해요.\n\nReact 컴포넌트에서 막히셨나요? 그들의 다양한 자습서를 통해 코딩 프로처럼 컴포넌트를 손쉽게 다룰 수 있을 거예요.\n\n# CSS-Tricks\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nCSS-Tricks은 어떤 CSS에 관한 것이든 찾아볼 수 있는 최고의 자료입니다.\n\n그들의 기사들은 쉬운 설명과 실용적인 코드 예제, 그리고 많은 유머(누가 CSS 학습을 즐기지 않을 수 있겠어요?)가 훌륭하게 조합돼 있습니다.\n\n환상적인 애니메이션 버튼을 디자인하거나 Flexbox의 가능한 사용 방법을 이해해야 한다면? CSS-Tricks가 CSS 선생님 역할을 해줄 것입니다. 전문가처럼 스타일의 복잡성을 도와줄 거예요.\n\n# CodePen.io\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nCodePen.io는 코드 편집기 이상의 기능을 제공합니다. 모든 배경을 가진 개발자들이 실험하고 작업물을 보여주고 협업할 수 있는 활성 온라인 커뮤니티입니다.\n\n새로운 코드 스니펫을 시도해보기에 안성맞춤이며, 다른 개발자들의 작업물에 영감을 받고, 코딩 작업물을 공유하기에 이상적인 장소입니다.\n\n디자인 아이디어를 시험하고 똑똑한 개발자들의 큰 커뮤니티에서 배울 수 있는 디지털 sandbox로 활용해보세요.\n\n# Coolors\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모두가 프로젝트에 적합한 색상 팔레트를 선택하는 데 어려움을 겪어본 적이 있을 것입니다.\n\nCoolors를 소개합니다. 몇 초 만에 사랑스러우면서 조화로운 색상 조합을 만들 수 있는 색상 팔레트 생성기입니다.\n\n항상 사용하는 같은 녹색과 파란색이 지루하다고 느낄 때가 있나요? Coolors는 예상치 못한데도 놀라운 색상을 제공해, 상상력을 자극할 것입니다.\n\n우리 웹사이트의 원하는 분위기와 느낌을 만들어낼 수 있는 정확한 매치를 찾을 때까지 다양한 색상 조합을 실험해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Can I Use\n\n여러 브라우저에서 웹 사이트가 성공적으로 작동하는 것은 중요합니다.\n\nCan I Use은 CSS 기능과 JavaScript 전략이 다양한 브라우저에서 지원되는지 보여주는 호환성 확인 도구입니다.\n\n이 도구를 사용하면 웹 사이트가 최신 Chrome 업데이트, Firefox 업데이트 및 Internet Explorer를 포함한 모든 기기에서 정확하게 표시됨이 보장됩니다. (저는 심판하지 않아요!)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Netlify\n\n네틀리파이는 웹 애플리케이션의 배포를 향상시킵니다.\n\n네틀리파이를 사용하면 GitHub에서 코드를 빠르게 업로드하여 웹 사이트를 즉시 실행할 수 있습니다.\n\n복잡한 서버 설정을 작별하고 효율적인 배포 프로세스로 환영하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNetlify는 인프라 관리를 줄여주어 여러분이 최고의 작품에 집중할 수 있도록 도와줍니다.\n\n## 마지막으로\n\n모든 웹 개발자의 즐겨찾기 바는 문제 해결, 창의력 향상, 그리고 워크플로우 가속을 위해 준비된 무한한 리소스여야 합니다.\n\n이 웹사이트들 각각은 CSS Tricks를 통해 CSS를 배우는 것부터 Netlify를 사용하여 속도를 높여 배포하는 것까지, 개발 프로세스에서 다양한 목적을 갖고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제는 당신의 차례입니다. 이 웹사이트들을 즐찾 목록에 추가하고, 좋아하는 자료들을 공유해보세요. 그리고 빠뜨린 보석 같은 것이 있는지 알려주세요.\n\n당신의 코멘트들이 필요할 때 다른 개발자를 돕는 데 도움이 될 수 있습니다!\n\n만약 이 목록이 유용하다고 느끼신다면, 비슷한 업데이트와 콘텐츠를 위해 저를 팔로우해보는 것도 고려해보세요.","ogImage":{"url":"/assets/img/2024-06-23-6BestWebsitesforEveryDevelopersBookmarkBar_0.png"},"coverImage":"/assets/img/2024-06-23-6BestWebsitesforEveryDevelopersBookmarkBar_0.png","tag":["Tech"],"readingTime":3},{"title":"Flutter GetX 상태 관리 쉽게 이해하기","description":"","date":"2024-06-23 14:58","slug":"2024-06-23-FlutterGetXStateManagement","content":"\n\u003cimg src=\"/assets/img/2024-06-23-FlutterGetXStateManagement_0.png\" /\u003e\n\nGetX는 가벼우면서 뛰어난 성능을 제공하는 Flutter 패키지입니다. 상태 관리에 국한되지 않고 네비게이션, 의존성 주입 및 국제화 기능도 포함하고 있어 Flutter 개발자를 위한 다목적 도구상자입니다. GetX는 그 간결함, 성능 및 다양한 기능으로 알려져 있습니다. Flutter 개발에서 일반적인 작업을 위한 추가적인 유틸리티와 함께 가벼우면서 반응적인 상태 관리 솔루션을 선호하는 개발자들에게 적합한 선택입니다. 이 패키지의 유연성과 사용 편의성은 Flutter 커뮤니티 내에서 인기를 끌고 있습니다.\n\n## GetX 상태 관리의 주요 기능:\n\n\u003cimg src=\"/assets/img/2024-06-23-FlutterGetXStateManagement_1.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nReactive State Management:\n\n```js\nfinal count = 0.obs;\n\n// In the UI:\nObx(() =\u003e Text('Count: ${controller.count}'));\n```\n\n의존성 주입:\n\n```js\nGet.lazyPut \u003c MyService \u003e (() =\u003e MyService());\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n경로 관리:\n\n```js\nGet.toNamed(\"/next\");\n```\n\n스낵바 및 대화상자:\n\n```js\nGet.snackbar(\"제목\", \"이것은 스낵바입니다\");\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nStateMixin:\n\n```js\nclass MyController extends GetxController with StateMixin\u003cString\u003e {\n  @override\n  void onInit() {\n    super.onInit();\n    change('Initial Data', status: RxStatus.success());\n  }\n}\n```\n\nGetX Service:\n\n```js\nclass MyService extends GetxService {\n  // ...\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n국제화 (i18n):\n\n```js\n\"hello\".tr;\n```\n\nGetX 빌더:\n\n```js\nGetBuilder\u003cMyController\u003e(\nbuilder: (_) {\nreturn Text('Value: ${_.myValue}');\n},\n)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# GetX 설정하기\n\nGetX를 Flutter 프로젝트에서 사용하려면, 다음 종속성을 `pubspec.yaml` 파일에 추가해주세요:\n\n```yaml\ndependencies:\n  get: ^4.6.6\n```\n\nget install | Flutter 패키지 (pub.dev)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# GetX를 사용한 간단한 카운터 예제\n\n```js\nimport 'package:flutter/material.dart';\nimport 'package:get/get.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass CounterController extends GetxController {\n  // observable 변수 선언 (RxInt)\n  RxInt count = 0.obs;\n\n  // 카운터 증가 함수\n  void increment() {\n    count++;\n  }\n}\n\nclass MyApp extends StatelessWidget {\n  // 카운터 컨트롤러 인스턴스화\n  final CounterController controller = CounterController();\n\n  @override\n  Widget build(BuildContext context) {\n    return GetMaterialApp(\n      title: 'GetX 카운터 앱',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text('GetX 카운터 앱'),\n        ),\n        body: Center(\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: [\n              // Obx 위젯은 observable 변수의 변경 사항을 감지\n              Obx(() =\u003e Text(\n                '카운트: ${controller.count}',\n                style: TextStyle(fontSize: 24),\n              )),\n              SizedBox(height: 20),\n              ElevatedButton(\n                onPressed: () {\n                  // 버튼을 눌렀을 때 increment 함수 호출\n                  controller.increment();\n                },\n                child: Text('증가'),\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n```\n","ogImage":{"url":"/assets/img/2024-06-23-FlutterGetXStateManagement_0.png"},"coverImage":"/assets/img/2024-06-23-FlutterGetXStateManagement_0.png","tag":["Tech"],"readingTime":3},{"title":"Keystore를 사용하여 Flutter 앱 서명하는 방법","description":"","date":"2024-06-23 14:57","slug":"2024-06-23-SigningyourflutterappwithKeystore","content":"\n\n파이널?에서 플러터는 기본적으로 앱이 디버그 키스토어로 서명됩니다. 이를 디버그 키스토어라고 합니다. 이 키스토어는 기본적으로 다음 위치에 있습니다.\n\nC:\\Users\\LENOVO\\.android\\debug.keystore\n\n기본/default SHA-1 및 다른 서명을 (C:\\Users\\LENOVO\\.android\\debug.keystore)에서 가져오려면\n\n- 터미널 또는 명령 프롬프트를 엽니다.\n- Flutter 프로젝트의 `android` 디렉터리로 이동합니다.\n- 다음 명령을 실행하여 SHA-1 지문을 가져옵니다:\n```bash\n…..\\android` ./gradlew signingReport\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 코드에서 SHA-1과 다른 지문을 찾아보세요.\n\n![이미지](/assets/img/2024-06-23-SigningyourflutterappwithKeystore_0.png)\n\n이 SHA-1 및 다른 키는 PC마다 항상 같습니다. 이 서명 키는 주로 디버깅 용도로만 사용할 것입니다.\n\n예를 들어 Firebase에서 Google 기능에 로그인하기 위해 SHA-1 키가 필요한 경우가 있습니다. 앱이 개발 중인 동안 기본 서명을 Firebase에 추가할 수 있습니다. 동일한 앱에 여러 명의 개발자가 있을 수 있기 때문에 모든 앱이 Firebase 기능에 액세스해야 하므로 각 개발자가 생성한 여러 개의 SHA-1 키를 Firebase에 추가해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 키스토어의 적절한 관리 및 사용\n\n다음 단계에서는 키스토어를 사용하여 APK에 서명하여 앱을 배포하는 방법 및 기타 여러 용도에 적절하게 논의할 것입니다.\n\nAPK에 서명하려면 signingConfigs에서 코드를 작성해야 합니다.\n\n이것이 디버그 APK 및 프로덕션 APK용 app\\build.gradle에서 signingConfigs를 설정하는 방법입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n참고: 디버그 APK에 서명할 필요가 없습니다. 그것은 자체적으로 진행되며 아무것도 손대지 않아도 됩니다. 여기서 디버그 APK에 서명하는 것은 학습 목적으로 진행됩니다.\n\n- 자체 디버그용 및 제품용 키스토어(1개씩 총 2개)를 생성하세요.\n\n![image](/assets/img/2024-06-23-SigningyourflutterappwithKeystore_1.png)\n\n키툴(`keytool`) 유틸리티를 사용하여 자바 개발 키트(JDK)에 함께 제공되는 만큼 많은 수의 키스토어를 생성할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\na. 터미널이나 명령 프롬프트를 열고 다음 명령을 실행하세요:\n\n```bash\nkeytool -genkeypair -v -keystore your_keystore_name.keystore -alias your_alias_name -keyalg RSA -keysize 2048 -validity 10000\n```\n\nb. 정보 입력:\n\n이름, 조직 및 위치와 같은 정보를 입력하라는 메시지가 표시됩니다. 필수 정보를 입력해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nc. 비밀번호 설정:\n키스토어 및 키 쌍에 대한 비밀번호를 설정하라는 프롬프트가 표시됩니다. 나중에 이 비밀번호가 필요하므로 기억해 두세요.\n\n2. 키스토어 이동:\n생성된 키스토어 파일을 프로젝트 디렉토리의 안전하고 접근 가능한 위치로 이동하세요. 보안상의 이유로 프로젝트의 버전 관리 시스템 외부에 보관하는 것이 좋은 관행입니다.\n\n![이미지](/assets/img/2024-06-23-SigningyourflutterappwithKeystore_2.png)\n\n3. key.properties 파일 생성하기:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안녕하세요! `android` 폴더 안에 `key.properties` 파일을 추가해주세요.\n\n기억해주세요: `storePassword`와 `keyPassword`는 앞에서 입력한 비밀번호와 동일하니 `storePassword`는 항상 `keyPassword`와 동일할 겁니다. 그리고 `keyAlias`는 앞에서 입력한 `your_alias_name`과 동일해야 합니다.\n\n\u003cimg src=\"/assets/img/2024-06-23-SigningyourflutterappwithKeystore_3.png\" /\u003e\n\n4. app/build.gradle 안의 `signingConfig`를 사용하여 APK에 서명하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지1](/assets/img/2024-06-23-SigningyourflutterappwithKeystore_4.png)\n\n![이미지2](/assets/img/2024-06-23-SigningyourflutterappwithKeystore_5.png)\n\n프로덕션 APK의 SHA-1 키를 생성하려면 아래 단계를 따르세요.\n\n1. Keystore 파일 찾기: 먼저, 앱을 위해 생성한 릴리스 keystore 파일을 찾으세요. 이 파일은 일반적으로 .jks 또는 .keystore 확장자를 가지고 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. SHA-1 키 생성: SHA-1 키를 생성하려면 Java 개발 킷(JDK)과 함께 제공되는 keytool 명령줄 유틸리티를 사용할 수 있습니다. 터미널이나 명령 프롬프트를 열고 keystore 파일이 있는 디렉토리로 이동하세요.\n\n3. keytool 명령 실행: 다음 명령을 사용하여 SHA-1 키를 생성하세요:\n\n```js\nkeytool -list -v -keystore your_keystore_filename.jks -alias your_alias_name\n```\n\nyour_keystore_filename.jks를 사용자의 keystore 파일 이름으로, your_alias_name을 keystore를 생성할 때 사용한 별칭으로 대체하세요(별칭을 지정하지 않았다면, 디버그 keystore에는 androiddebugkey를 사용하거나 릴리스 keystore 생성 시 사용한 별칭을 사용하세요).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n4. **Keystore 비밀번호 입력:** Keystore 비밀번호를 입력하라는 메시지가 표시됩니다. Keystore를 생성할 때 사용한 비밀번호를 입력하세요.\n\n5. **SHA-1 키 가져오기:** 비밀번호를 입력한 후에는 도구가 Keystore에 대한 여러 정보를 표시합니다. 이 중 'SHA-1 key'를 찾아보세요. 'Certificate fingerprints' 섹션 하단에 있는 SHA1 항목을 확인해보세요.\n\n6. **Firebase에 SHA-1 키 추가하기:**\n\n![이미지](/assets/img/2024-06-23-SigningyourflutterappwithKeystore_6.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSHA-1 키를 복사하여 Firebase 콘솔에 프로젝트를 추가해 주세요.\n\nFirebase 프로젝트로 이동하시고, \"Project Overview\" 근처에 있는 설정 아이콘을 클릭한 후 \"프로젝트 설정\"을 클릭해주세요. 여기에서 SHA-1 키를 추가할 수 있습니다.\n\n플러터와 모바일 앱 개발에 대해 더 알고 싶다면 도움이 될 겁니다.","ogImage":{"url":"/assets/img/2024-06-23-SigningyourflutterappwithKeystore_0.png"},"coverImage":"/assets/img/2024-06-23-SigningyourflutterappwithKeystore_0.png","tag":["Tech"],"readingTime":4},{"title":"Flutter를 클라우드에 연결하는 방법 2024 최신 가이드","description":"","date":"2024-06-23 14:55","slug":"2024-06-23-FluttertoCloud","content":"\n\n# 소개\n\n본 문서 시리즈의 목표는 AWS Amplify를 사용하여 Flutter 모바일 애플리케이션을 개발하고 필요에 따라 다른 방법으로 전환할 수 있는 환경을 구축하는 것입니다. 이 과정에서 발생하는 모든 문제에 대해 다룰 것입니다.\n\n본 애플리케이션은 언어 학습용 간단한 플래시카드 애플리케이션이며, 개발하는 과정을 계속해서 업데이트할 예정입니다.\n\n본 시리즈는 실시간 여정으로, 각 단계를 문서화하고 직면한 도전과정 및 그에 따른 결정 사항을 기록할 것입니다. 구조는 프로젝트의 요구에 따라 발전할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기 이 시리즈에서 다룰 내용입니다:\n\n- 파트 1: 아키텍처\n- 파트 2: Flutter 및 Amplify 설정\n- 파트 3: GraphQL 스키마 정의\n- 파트 4: 인증 구현\n- 파트 5: 핵심 기능 개발\n- 파트 6: UI 개발 및 상태 관리\n- 파트 7: 추가 서비스 통합\n- 파트 8: 배포 및 모니터링\n- 파트 9: 대안 및 이전 이주 표 평가\n- 파트 10: 반성 및 향후 방향\n\n# 파트 1\n\n## 아키텍처\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n어떤 일을 하기 전에 먼저 해야 할 질문은 아키텍처에 관한 것입니다. 한쪽에서는 필요할 경우 클라우드 제공 업체를 변경할 유연성을 가지고 싶지만, 다른 한쪽에서는 BaaS가 내 요구사항을 충족시키지 못하는 경우, 최소한의 비용과 노력으로 나만의 백엔드를 구현할 수 있기를 원합니다. 이것은 제 첫 번째 BaaS 경험이며, 이 과정 중에 필요한 변경에 대비하고자 합니다. 이를 위해 간단한 플래시카드 앱을 만들 것입니다.\n\nClean Architecture는 소프트웨어 응용 프로그램에서 관심사 분리, 유지 관리 가능성 및 확장성을 보장하는 견고한 아키텍처 패턴입니다. 백엔드 개발자로서 이 아키텍처는 종종 올바른 선택입니다. 클린 아키텍처의 주요 아이디어는 로버트 C. 마틴이 “Clean Architecture” 책에서 쓴 것처럼, 비즈니스 규칙은 UI, 프레임워크, 데이터베이스 및 다른 외부 응용 프로그램과 쉽게 테스트할 수 있고 독립적이어야 한다는 것입니다.\n\n클린 아키텍처를 컨셉으로 경험을 쌓는 과정에서 헥사고널 아키텍처를 탐구했습니다 (Alistair Cockburn, “Hexagonal Architecture”, and Tom Hombergs, “Get Your Hands Dirty on Clean Architecture”). 이 아키텍처는 소프트웨어를 유연하게 만들고 개발 비용을 줄입니다. 그러나 작은 애플리케이션의 경우, 헥사고널 아키텍처가 과도하게 복잡할 수 있다는 것을 발견했습니다.\n\nFlutter로 새로운 모바일 애플리케이션을 시작할 때, 올바른 아키텍처와 코드 구조를 정의하는 것이 첫 번째 도전이었습니다. 모바일 애플리케이션을 위한 다양한 아키텍처와 디자인을 찾아보면 Model-View-Controller (MVC), Model-View-Presenter (MVP), Model-View-ViewModel (MVVM), Provider, Riverpod 및 Bloc과 같은 결과가 나오며, 각각 장단점이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n목표는 깨끗한 아키텍처 개념을 따르는 구조를 찾는 것이었습니다. UI와 비즈니스 로직을 분리하고 BaaS 제공업체를 쉽게 교체하거나 사용자 지정 백엔드로 이전할 수 있도록 하는 것이 목표였습니다. 본 문서에서는 Flutter 애플리케이션에서 Clean Architecture를 Riverpod를 사용하여 구현한 내용을 다루며, 해당 방법이 어떤 이점을 제공하며 클라우드 제공자 간 또는 사용자 지정 백엔드로 전환하는 것을 간단하게 만드는 방법에 대해 살펴보겠습니다.\n\n다음 다이어그램에서 깨끗한 아키텍처의 주요 아이디어를 고려해 봅시다:\n\n핵심은 엔티티이며, 다른 종속성과 독립적입니다. 프레임워크, 데이터베이스, UI 등에서 최대한 분리되어 유연하고 테스트 가능한 소프트웨어를 개발할 수 있습니다.\n\n나는 육각형 아키텍처를 시도해 보기로 결정했지만, 소규모 애플리케이션에 대해 과도하게 설계된 것으로 간주될 수 있는 기업 앱이 아니기 때문에 곧 포기했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여러 가지 아키텍처 패턴을 고려하며, Clean Architecture와 일치하는 아키텍처를 찾고, UI와 비즈니스 로직을 분리하는 것뿐만 아니라 BaaS 접근 방식을 다른 제공 업체로 교체하거나 BaaS에서 클라우드의 백엔드로 쉽게 이동할 수 있도록 해줍니다.\n\n이 부분은 Riverpod를 상태 관리에 사용하는 Flutter 애플리케이션에서 Clean Architecture의 사용에 대해 설명합니다. 이 아키텍처의 장점을 살펴보고, 클라우드 제공 업체 간 전환이나 UI 레이어에 영향을 미치지 않고 사용자 정의 백엔드로 이동하는 것을 어떻게 간소화하는지 살펴볼 것입니다.\n\nClean Architecture로 진입하기 전에 다른 옵션을 간단히 살펴볼까요? 모바일 애플리케이션을 위한 아키텍처를 찾다 보면 다양한 용어가 등장합니다.\n\n주로 Model–view–controller, Model-view-Presenter, MVVM, Provider, Riverpod, Bloc이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 모델 뷰 컨트롤러\n\nMVC는 응용 프로그램을 세 가지 주요 구성 요소로 분리합니다:\n\n모델: 응용 프로그램의 데이터와 비즈니스 로직을 나타냅니다.\n뷰: UI 구성 요소와 프레젠테이션 로직을 나타냅니다.\n컨트롤러: 모델과 뷰 사이의 중개자 역할을 하며 사용자 입력을 처리하고 둘 다 업데이트합니다.\n\n![image](/assets/img/2024-06-23-FluttertoCloud_0.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n뷰와 로직을 분리하는 데 장점이 있지만, 일부 구현에서 컨트롤러가 뷰와 긴밀하게 결합되어 수정 또는 교체하기 어려워질 수 있습니다. 대부분의 핵심 비즈니스 로직은 컨트롤러에 있기 때문에 파일이 커져서 코드를 유지보수하기 힘들어지는 문제가 발생할 수 있습니다.\n\n# 모델 뷰 프레젠터\n\nMVP는 MVC의 문제를 해결하기 위해 나왔습니다. 세 가지 부분으로 구성되어 있습니다:\n모델: 도메인 로직, 데이터베이스 및 네트워크 통신을 처리합니다.\n뷰: UI 및 사용자 작업을 관리합니다.\n프레젠터: 모델에서 데이터를 가져와 UI 로직을 적용하고 뷰 상태를 관리합니다.\n\n이는 더 나은 모듈성을 제공하며 프로젝트 코드를 보다 쉽게 구조화하고 유닛 테스트 능력을 향상시킵니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-06-23-FluttertoCloud_1.png)\n\n# Model View ViewModel\n\nMVVM은 다음 구성 요소를 갖추고 있습니다:\n\nModel: 데이터 소스를 추상화하고 ViewModel과 함께 데이터 작업을 처리합니다.\n\nView: ViewModel을 관찰하고 비즈니스 로직을 포함하지 않고 사용자 작업을 알립니다.\n\nViewModel: Model과 View를 연결하여 관련 데이터 스트림을 View에 노출합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nMPV와 비교하여 MVVM은 다음과 같은 점들이 개선되었습니다:\n\n- Tight Coupling Issue: MVVM은 UI와 비즈니스 로직 간의 강한 결합을 줄여 업데이트와 유지보수를 쉽게 할 수 있습니다.\n- 향상된 테스트 용이성: MVVM은 Android SDK 구성 요소에 대한 의존성을 최소화하여 단위 테스트를 더 간편하게 만들어줍니다.\n- 관심사의 분리가 더 잘 이루어집니다: MVVM은 데이터 표현 로직과 핵심 비즈니스 로직을 더 명확하게 분리하여 더 조직적이고 유지보수가 쉬운 코드베이스를 제공합니다.\n\n![사진](/assets/img/2024-06-23-FluttertoCloud_2.png)\n\n더 자세한 비교는 https://www.geeksforgeeks.org/difference-between-mvp-and-mvvm-architecture-pattern-in-android/에서 확인할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# BLOC 구조\n\nBLOC은 MVVM과 많은 유사성을 가지고 있지만 ViewModel은 Bloc으로 대체됩니다. BLOC에서 상태를 관리하는 핵심 메커니즘은 스트림 또는 반응형 접근 방식의 사용입니다. 기본적으로 데이터는 BLOC과 UI 사이를 스트림으로 흐릅니다.\n\n이는 데이터가 BLOC에서 UI로 지속적으로 전송되고, UI에서 다시 BLOC으로 돌아가는 것을 의미하며, 상태가 효율적이고 일관되게 관리되도록 보장합니다.\n\n![이미지](/assets/img/2024-06-23-FluttertoCloud_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 클린 아키텍처 개요\n\n클린 아키텍처는 응용 프로그램을 다음과 같이 명확하게 계층으로 나눕니다:\n\n- 프리젠테이션 계층: UI 및 사용자 상호작용을 관리합니다.\n- 응용 계층: 비즈니스 로직과 서비스를 포함합니다.\n- 도메인 계층: 핵심 비즈니스 모델과 로직을 정의합니다.\n- 데이터 계층: 데이터 검색 및 지속성을 처리합니다.\n\n각 계층은 특정한 책임을 가지며 다른 계층과 명확한 인터페이스를 통해 통신하여 관심사의 명확한 분리를 보장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 깨끗한 아키텍처의 장점\n\n- 관심사 분리\n각 계층은 애플리케이션의 특정 측면에 집중하여 단일 책임을 촉진합니다:\n\n- 프레젠테이션 계층: 사용자 인터페이스 및 상호 작용 로직을 관리합니다.\n- 응용 계층: 애플리케이션별 비즈니스 규칙을 관리합니다.\n- 도메인 계층: 핵심 비즈니스 로직 및 엔티티를 포함합니다.\n- 데이터 계층: 데이터 원본 및 저장소를 관리합니다.\n\n이러한 분리로 코드베이스를 이해, 테스트 및 유지보수하기 쉬워집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 확장성\n\n시스템 구조는 확장이 가능하여, 새로운 기능을 추가할 때 기존 코드에 최소한의 영향을 미치게 합니다. 각 계층은 독립적으로 개발 및 테스트할 수 있어 병렬 개발을 용이하게 합니다.\n\n3. 유지보수성\n\n각 계층 사이에 명확한 경계가 존재함으로써 코드베이스를 유지하고 업데이트하는 것이 간단해집니다. 각 계층은 다른 계층에 영향을 주지 않고 수정할 수 있어 새로운 기능을 도입하거나 버그를 수정하기가 더 쉬워집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-FluttertoCloud_4.png\" /\u003e\n\n# 코드 구조 예시\n\n플래시 카드와 덱을 모델로 하는 예시에서 코드 구조는 다음과 같을 수 있습니다. 각 패키지는 Riverpod 구조의 하나의 레이어를 나타냅니다:\n\n```js\nib/\n|-- presentation/\n|   |-- widgets/\n|   |   |-- flashcard_widget.dart\n|   |   |-- deck_widget.dart\n|   |-- states/\n|   |   |-- flashcard_state.dart\n|   |   |-- deck_state.dart\n|   |-- controllers/\n|       |-- flashcard_controller.dart\n|       |-- deck_controller.dart\n|-- application/\n|   |-- services/\n|       |-- flashcard_service.dart\n|       |-- deck_service.dart\n|       |-- transformation_utils.dart\n|-- domain/\n|   |-- models/\n|       |-- flashcard.dart\n|       |-- deck.dart\n|       |-- domain_deck.dart\n|       |-- domain_flashcard.dart\n|       |-- ideck.dart\n|       |-- iflashcard.dart\n|       |-- model_provider.dart\n|-- data/\n|   |-- repositories/\n|   |   |-- flashcard_repository_impl.dart\n|   |   |-- deck_repository_impl.dart\n|   |   |-- ideck_repository.dart\n|   |   |-- iflashcard_repository.dart\n|   |   |-- mappers.dart\n|   |-- dtos/\n|   |   |-- flashcard_dto.dart\n|   |   |-- deck_dto.dart\n|   |-- data_sources/\n|       |-- deck_aws_data_source.dart\n|       |-- flashcard_aws_data_source.dart\n|-- amplifyconfiguration.dart\n|-- main.dart\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 아키텍처 선언\n\n인터페이스와 구조 설명\n인터페이스와 계층 구조를 사용하면 아키텍처에 여러 가지 이점이 있습니다:\n\n- 추상화를 위한 인터페이스: 인터페이스(IDeck, IFlashcard, IDeckRepository, IFlashcardRepository)를 정의함으로써, 아키텍처는 구현 세부 정보를 비즈니스 로직과 분리합니다. 이를 통해 다른 구현을 동일한 인터페이스를 구현하여 상호 교환 가능하게 만들 수 있으며, 응용 프로그램의 나머지 부분에 영향을 미치지 않고 사용할 수 있습니다. 예를 들어, AWS Amplify를 다른 클라우드 제공 업체로 또는 사용자 지정 백엔드로 대체할 수 있습니다.\n\n2. 표시 계층: UI 구성 요소를 포함하며 사용자 상호 작용을 관리합니다. 이 계층은 데이터를 표시하고 사용자 작업을 응용 프로그램 계층으로 전달하는 것에만 책임이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. Application Layer: 비즈니스 로직과 사용 사례를 포함하고 있습니다. 도메인 레이어와 상호 작용하여 데이터를 검색하고 조작한 후 표현 레이어를 업데이트합니다. UI와 비즈니스 로직을 분리함으로써 애플리케이션은 유지보수 가능하고 테스트 가능해집니다.\n\n4. Domain Layer: 핵심 비즈니스 모델과 로직을 정의합니다. 이러한 모델은 다른 레이어에 의존성이 없는 간단한 Dart 클래스들로 구성되어 있어 독립적이고 재사용 가능하도록 보장합니다. 도메인 레이어에는 데이터 레이어에서 구현된 저장소에 대한 인터페이스가 포함되어 있습니다.\n\n5. Data Layer: 데이터 검색 및 지속성을 관리합니다. 이 레이어에는 저장소 인터페이스의 구현이 포함되어 있으며, 이것들은 데이터 원본 (예: AWS Amplify)과 상호 작용합니다. 맵퍼를 사용하여 이 레이어는 도메인 모델과 데이터 전송 객체(DTO) 간에 데이터를 변환합니다.\n\n# Riverpod이 아키텍처에 미치는 영향\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nRiverpod은 Clean Architecture를 향상시키는 상태 관리 라이브러리로 다음을 제공합니다:\n\n- 확장성: 복잡한 사용 사례를 지원하며 전체 응용 프로그램에서 상태를 쉽게 관리합니다.\n- 테스트 용이성: Riverpod은 상태 관리의 쉬운 모의 및 테스트를 가능하게 합니다.\n- 유연성: UI 구성 요소에서 상태 관리를 분리하여 Clean Architecture의 원칙을 준수합니다.\n\nRiverpod을 사용하면 상태 관리 논리가 응용 프로그램 계층 내에 있어 관심사를 구분하고 표현 계층이 UI 관련 논리에 집중할 수 있습니다.\n\nBloc을 사용할 때 상태 변경은 데이터의 스트림으로 일관되게 표현됩니다. 반면에 Riverpod은 Streams, Futures, StateNotifiers, ChangeNotifiers를 비롯한 다양한 유형의 데이터를 감시할 수 있는 유연성을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 다양성은 Riverpod가 다른 상태 메커니즘을 매끄럽게 관리할 수 있도록 합니다.\n\n# 클라우드 제공 업체를 변경하거나 사용자 정의 백엔드로 이동하는 유연성\n\n이 깔끔한 아키텍처 접근 방식을 따르면, 다른 BaaS(Backend as a Service)를 다른 것으로 교체하거나 심지어 사용자 정의 백엔드로 마이그레이션하는 것이 쉬워집니다.\n\n이 아키텍처는 UI와 비즈니스 로직이 데이터 접근 레이어와 완전히 분리되어 있음을 보장합니다. 이 느슨한 결합은 마이그레이션 프로세스를 크게 용이하게 만듭니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기능 분리: 아키텍처는 프레젠테이션, 도메인 및 데이터와 같이 잘 정의된 인터페이스를 통해 통신하는 주요 레이어로 응용 프로그램을 분리합니다. 이 분리는 한 레이어의 변경이 다른 레이어에 영향을 미치지 않도록 보장합니다.\n\n느슨한 결합: 인터페이스와 의존성 주입 (우리의 경우 Riverpod 프로바이더를 통해)의 사용은 데이터 소스의 다양한 구현을 쉽게 교체할 수 있게 합니다. 예를 들어, AWS Amplify에서 사용자 정의 백엔드로 전환하는 경우 데이터 레이어에서만 변경이 필요합니다.\n\n유지 관리성: 데이터 액세스 로직을 비즈니스 로직 및 UI에서 격리시킴으로써 응용 프로그램을 더 유지 보수 가능하고 이해하기 쉽게 만듭니다. 각 레이어에는 특정 책임이 있어 변경 사항을 할 때 우발적인 부작용의 위험을 줄입니다.\n\n확장성: 이 아키텍처는 확장 가능하도록 설계되었습니다. 백엔드의 새로운 기능이나 변경 사항을 기존 코드베이스를 크게 수정하지 않고 수용할 수 있습니다. 이 확장성은 시간이 지남에 따라 다른 서비스와 통합해야 하는 진화하는 응용 프로그램에 필수적입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음에는 Flutter 및 Amplify를 설정한 다음 스키마를 정의할 것입니다.\n\n소스:\nhttps://codewithandrea.com/articles/flutter-app-architecture-riverpod-introduction/\nhttps://www.thenifemi.com/articles/ddd-series-part-2\nhttps://codewithandrea.com/articles/comparison-flutter-app-architectures/#comparison-with-bloc-architecture\nhttps://medium.com/@nikilapi/i-found-the-perfect-architecture-for-flutter-apps-59fc2dc8f00f\nhttps://github.com/Uuttssaavv/flutter-clean-architecture-riverpod\nhttps://codewithandrea.com/articles/flutter-presentation-layer/","ogImage":{"url":"/assets/img/2024-06-23-FluttertoCloud_0.png"},"coverImage":"/assets/img/2024-06-23-FluttertoCloud_0.png","tag":["Tech"],"readingTime":10},{"title":"Flutter 카드 위젯 완벽 가이드 고급 기능을 활용한 아름다운 카드 만들기 방법","description":"","date":"2024-06-23 14:54","slug":"2024-06-23-CompleteGuidetoCardWidgetinFlutterCreatingBeautifulCardswithAdvancedFeatures","content":"\n![Card Widget](/assets/img/2024-06-23-CompleteGuidetoCardWidgetinFlutterCreatingBeautifulCardswithAdvancedFeatures_0.png)\n\n플러터 프레임워크의 Card 위젯은 그림자와 둥근 모서리를 가진 표면을 만들 수 있어서 기사, 목록 및 다른 UI 섹션에 정보를 표시하는 데 적합합니다. 이 위젯에는 카드의 모양을 사용자 지정할 수 있는 다양한 속성이 있습니다.\n\n1. 자식 위젯 지정:\n   Card 위젯은 카드의 내용으로 작동하는 자식 위젯을 허용합니다. 다음 예제는 카드 안에 텍스트를 배치하는 방법을 보여줍니다:\n\n```js\nCard(\n  child: Text('This is a card'),\n)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 색상 설정\n   `color` 속성을 사용하여 카드의 배경색을 변경할 수 있습니다. 아래 예시는 다채로운 카드를 표시합니다:\n\n```js\nCard(\n  color: Colors.blue,\n  child: Text('Colored Card'),\n)\n```\n\n# 3. 고도 증가\n\n`elevation` 속성은 카드의 그림자 높이를 제어합니다. 이 속성에 더 큰 값이 할당되면 더 높은 그림자가 생성됩니다. 아래는 고도가 증가된 카드 예시입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nCard(\n  elevation: 8,\n  child: Text('Elevated Card'),\n)\n```\n\n# 4. 모양\n\n모양 속성을 사용하여 카드의 모서리 모양을 변경할 수 있습니다. 예를 들어, 모서리를 둥글게 만들 수 있습니다:\n\n```js\nCard(\n  shape: RoundedRectangleBorder(\n    borderRadius: BorderRadius.circular(15.0),\n  ),\n  child: Text('Rounded Corners Card'),\n)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 5. 여백\n\n카드의 여백은 margin 속성을 사용하여 설정할 수 있습니다:\n\n```js\nCard(\n  margin: EdgeInsets.all(16.0),\n  child: Text('여백 카드'),\n)\n```\n\n# 6. 전경 제어에 대한 테두리\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`borderOnForeground` 속성을 사용하면 카드의 테두리가 전경에 배치되는지 여부를 제어할 수 있습니다:\n\n```js\nCard(\n  borderOnForeground: false,\n  child: Text('테두리가 전경에 표시되지 않는 카드'),\n)\n```\n\n# 7. 클립 동작\n\n`clipBehavior` 속성을 사용하면 카드 내부 콘텐츠가 어떻게 클립되는지 결정할 수 있습니다. 가능한 값으로 Clip.none, Clip.hardEdge 및 Clip.antiAlias가 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nCard(\n  clipBehavior: Clip.antiAlias,\n  child: Text('Anti-aliased Clip Card'),\n)\n```\n\n# 8. 시맨틱 컨테이너\n\n만약 이 속성이 true이면, 카드는 시맨틱 컨테이너로 정의되며, 그렇지 않으면 자식 요소의 의미론이 가장 가까운 둘러싸는 시맨틱 컨테이너와 병합됩니다.\n\n```js\nCard(\n  semanticContainer: true,\n  child: Text('Semantic Container Card'),\n)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 9. 그림자 색상\n\n그림자 색상을 설정하려면 shadowColor 속성을 사용할 수 있습니다:\n\n```js\nCard(\n  shadowColor: Colors.red,\n  child: Text('그림자 색상 카드'),\n)\n```\n\n# 10. 테두리 반지름\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nborderRadius 속성을 사용하여 카드의 모서리의 반지름을 설정할 수 있습니다.\n\n```js\nCard(\n  shape: RoundedRectangleBorder(\n    borderRadius: BorderRadius.circular(30.0),\n  ),\n  child: Text('사용자 정의 보더 반경 카드'),\n)\n```\n\n\u003cimg src=\"/assets/img/2024-06-23-CompleteGuidetoCardWidgetinFlutterCreatingBeautifulCardswithAdvancedFeatures_1.png\" /\u003e\n\n플러터의 Card 위젯의 다양한 기능을 활용하여, Material Design 표준에 부합하는 다양한 외관의 카드를 생성할 수 있습니다. 이러한 기능을 통해 시각적으로 매력적이며 이해하기 쉽고 직관적인 사용자 인터페이스를 만들 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-23-CompleteGuidetoCardWidgetinFlutterCreatingBeautifulCardswithAdvancedFeatures_0.png"},"coverImage":"/assets/img/2024-06-23-CompleteGuidetoCardWidgetinFlutterCreatingBeautifulCardswithAdvancedFeatures_0.png","tag":["Tech"],"readingTime":3},{"title":"Flutter 앱 테마 커스터마이즈 라이트와 다크 모드 전환 및 익스텐션 사용 방법","description":"","date":"2024-06-23 14:53","slug":"2024-06-23-CustomizeFlutterAppThemesSwappingBetweenLightDarkModesandUsingExtensions","content":"\n플러터는 테마 지원을 통해 개발자들이 다양한 테마 기능으로 애플리케이션을 사용자 정의할 수 있도록 훌륭한 지원을 제공합니다. 이 글에서는 두 가지 핵심 테마 기능에 중점을 두겠습니다:\n\nA) 다크 테마와 라이트 테마 간 전환하기.\n\nB) 테마 확장을 사용하여 추가 테마 데이터 클래스를 생성하여 더 많은 사용자 정의를 할 수 있습니다.\n\n完전한 작동하는 샘플 코드에 대한 접근은 동봉된 GitHub 저장소를 참조해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![image](/assets/img/2024-06-23-CustomizeFlutterAppThemesSwappingBetweenLightDarkModesandUsingExtensions_0.png)\n\n# 다크 테마와 라이트 테마 사이를 전환하세요\n\n다크 테마와 라이트 테마 사이를 전환하는 것은 다음 예시에서 알 수 있듯이 매우 간단합니다:\n\n```js\nreturn MaterialApp(\n  ...\n  themeMode: themeMode,\n  darkTheme: ThemeData.dark(),\n  theme: ThemeData.light(),\n  ...\n);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 세 가지 필드는 앱이 적용해야 하는 테마의 유형을 지정할 수 있습니다. 기본적으로 themeMode는 darkTheme 또는 theme을 사용할지를 결정합니다.\n\nThemeMode에는 세 가지 값이 있습니다:\n\n- ThemeMode.light: 앱에 밝은 테마를 사용하도록 지시합니다.\n- ThemeMode.dark: 앱에 어두운 테마를 사용하도록 지시합니다.\n- ThemeMode.system: 앱이 시스템의 테마와 일치하도록 지시합니다.\n\n애플리케이션의 테마를 동적으로 변경하려면 코드가 반응해야 합니다. 실제적이고 효율적인 방법은 변경 사항에 응답할 수 있는 상태를 App 위젯 위에 배치하는 것입니다. 이 상태는 원하는 방식으로 관리할 수 있습니다. 현재, 저는 애플리케이션의 상태 관리에 플러터 프로바이더를 사용하고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nreturn Solid(\n  providers: [\n    Provider\u003cSignal\u003cThemeMode\u003e\u003e(create: () =\u003e Signal(ThemeMode.system)),\n  ],\n  builder: (context) {\n    final themeMode = context.observe\u003cThemeMode\u003e();\n    return MaterialApp(\n      ...\n      themeMode: themeMode,\n      darkTheme: ThemeData.dark(),\n      theme: ThemeData.light(),\n      ...\n    );\n  },\n);\n```\n\n그 후, 애플리케이션 어디서든 메서드를 호출하여 프로바이더에게 값을 변경하도록 지시할 수 있습니다. 이는 애플리케이션을 그에 맞게 다시 빌드합니다:\n\n```js\ncontext.get\u003cSignal\u003cThemeMode\u003e\u003e().value = newThemeMode;\n```\n\n앱이 시작할 때마다 ThemeMode를 저장하고 가져와서 사용자의 테마 선호도를 유지해야 합니다. 이렇게 하면 사용자의 선택사항이 기억되고 일관되게 적용됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 테마 확장 사용하기\n\n다크 테마와 라이트 테마를 전환하는 것만으로도 좋지만, Flutter를 사용하면 테마 확장을 통해 더 많은 사용자 정의가 가능합니다. 테마 확장은 표준 ThemeData를 넘어 사용자 정의 속성과 스타일을 정의할 수 있게 해줍니다.\n\n다음은 ThemeExtension을 확장한 클래스의 일부 코드입니다:\n\n```js\nclass MyCustomThemeExtension extends ThemeExtension\u003cMyCustomThemeExtension\u003e {\n  const MyCustomThemeExtension({\n    required this.customColor,\n  });\n\n  MyCustomThemeExtension.light() : customColor = Colors.yellow.shade900;\n\n  MyCustomThemeExtension.dark() : customColor = Colors.green.shade900;\n\n  final Color customColor;\n\n  @override\n  ThemeExtension\u003cMyCustomThemeExtension\u003e copyWith({\n    Color? customColor,\n  }) {\n    return MyCustomThemeExtension(customColor: customColor ?? this.customColor);\n  }\n\n  @override\n  ThemeExtension\u003cMyCustomThemeExtension\u003e lerp(\n    covariant ThemeExtension\u003cMyCustomThemeExtension\u003e? other,\n    double t,\n  ) {\n    if (other is! MyCustomThemeExtension) return this;\n    return MyCustomThemeExtension(\n      customColor: Color.lerp(customColor, other.customColor, t)!,\n    );\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저는 이 클래스를 매우 간단하게 유지하여 효과적으로 사용하는 방법을 보여주기 위해 노력했습니다.\n\n먼저, 이 클래스를 ThemeData에 추가하여 확장하고 해당 확장을 서브트리 내에서 접근할 수 있도록 해야 합니다:\n\n```js\nreturn ThemeData(\n  ...\n  extensions: [MyCustomThemeExtension.light()],\n  ...\n);\n```\n\n우리가 이전에 선언한 customColor를 활용하기 위해서는 해당 확장에 접근하면 됩니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n마지막 색상 = Theme.of(context)\n                        .extension\u003cMyCustomThemeExtension\u003e()!\n                        .customColor;\n```\n\nThemeExtension의 사용은 특히 Material 사양과 긴밀히 연결되지 않은 디자인 시스템을 코딩할 때 특히 유용하다고 생각합니다. 이러한 경우에는 ThemeData의 기본 필드가 충분하지 않거나 디자인 시스템의 요구 사항과 의미적으로 일치하지 않을 수 있습니다.\n\n# 결론\n\n테마 전환을 통해 개발자는 더 동적이고 현대적인 애플리케이션을 만들 수 있을 뿐만 아니라 사용자의 요구를 존중할 수 있다고 생각합니다. 저는 개인적으로 다크 모드를 많이 사용하고 애플리케이션이 그것을 지원하지 않을 때 약간 긴장을 느낍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 Markdown 형식으로 변경해 드렸어요.\n\n좋은 하루 보내세요!\n\n## 참고문헌\n","ogImage":{"url":"/assets/img/2024-06-23-CustomizeFlutterAppThemesSwappingBetweenLightDarkModesandUsingExtensions_0.png"},"coverImage":"/assets/img/2024-06-23-CustomizeFlutterAppThemesSwappingBetweenLightDarkModesandUsingExtensions_0.png","tag":["Tech"],"readingTime":4},{"title":"Flutter와 SocketIO 실시간 통합 방법","description":"","date":"2024-06-23 14:53","slug":"2024-06-23-FlutterandSocketIOReal-timeIntegration","content":"\n![Socket.IO package for Flutter](/assets/img/2024-06-23-FlutterandSocketIOReal-timeIntegration_0.png)\n\n## Socket.IO는 무엇인가요?\n\nSocket.IO는 실시간 이중방향 및 이벤트 주도 통신을 가능하게 하는 JavaScript 라이브러리입니다. 모든 플랫폼, 브라우저 또는 디바이스에서 작동하여 클라이언트와 서버 간의 원활한 연결을 보장합니다. Socket.IO는 WebSocket 프로토콜을 기반으로 작동하지만 다시 연결 지원, 멀티플렉싱 및 채널 지원과 같은 추가 기능을 제공합니다. 이는 즉각적인 데이터 업데이트 및 동적 상호작용이 필요한 애플리케이션에 이상적인 선택이 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSocket.IO를 Flutter와 통합하기 위해서는, 개발자들이 socket_io_client 패키지를 활용합니다. 이 패키지는 Socket.IO 클라이언트의 Dart 구현을 제공하여 Flutter 애플리케이션이 Socket.IO 서버와 원활하게 연결할 수 있도록 합니다.\n\n# Flutter 프로젝트 설정하기:\n\n- 의존성 추가: pubspec.yaml 파일을 열고 다음 종속성을 추가하세요:\n\n```yaml\ndependencies:\n  socket_io_client: ^2.0.3+1\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 로컬호스트에 연결하기:\n\n- 로컬에서 Socket.IO 서버가 실행 중인지 확인하세요.\n- `socketUrl` 함수는 에뮬레이터(IOS 또는 Android)에 적합한 로컬호스트 URL을 반환합니다.\n\n```js\nString socketUrl() {\n  if (Platform.isAndroid) {\n    return \"http://10.0.2.2:3000\";  // 안드로이드 에뮬레이터의 기본 IP 주소\n  } else {\n    return \"http://localhost:3000\"; // iOS 시뮬레이터용\n  }\n}\n```\n\n# 온라인 서버에 연결하기:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n온라인 Socket.IO 서버에 연결하려면:\n\n- Socket.IO 서버를 온라인으로 배포하거나 기존 서버를 사용합니다.\n- socketUrl 함수를 업데이트하여 온라인 서버 URL을 반환하세요.\n\n```js\nString socketUrl() {\n  return \"https://your-online-server-url.com\";\n}\n```\n\n사용자가 HomeScreen을 열자마자 소켓 서버에 연결을 설정하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n@override\nvoid initState() {\n  super.initState();\n\n  // 소켓 서버에 연결\n  socket = IO.io(socketUrl(), \u003cString, dynamic\u003e{\n    'transports': ['websocket'],\n  });\n\n  // 'connect' 이벤트에 대한 이벤트 리스너\n  socket.on('connect', (_) {\n    print('서버에 연결되었습니다');\n  });\n\n  // 서버로부터 메시지 수신\n  socket.on('message', (data) {\n    _streamController.add(data);\n  });\n}\n```\n\n## 메시지 전송:\n\n```js\nvoid sendMessage(String message) {\n  socket.emit('sendMessage', message);\n}\n```\n\nsendMessage 메서드는 제공된 메시지와 함께 `sendMessage` 이벤트를 서버로 전송합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 정리 작업 시 Dispose:\n\n```js\n@override\nvoid dispose() {\n  socket.disconnect();\n  _streamController.close();\n  super.dispose();\n}\n```\n\n- dispose()은 위젯이 제거될 때 호출되며, 소켓을 연결 해제하고 스트림을 닫습니다.\n\n# 출력:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![Socket.IO Flutter Demo](https://miro.medium.com/v2/resize:fit:1200/1*fdjqKbSJXfSqS_13uHvy9g.gif)\n\n# 전체 코드:\n\n```js\nimport 'dart:async';\nimport 'dart:io';\n\nimport 'package:flutter/material.dart';\nimport 'package:socket_io_client/socket_io_client.dart' as IO;\n\nclass HomeScreen extends StatefulWidget {\n  const HomeScreen({Key? key});\n\n  @override\n  HomeScreenState createState() =\u003e HomeScreenState();\n}\n\nclass HomeScreenState extends State\u003cHomeScreen\u003e {\n  late IO.Socket socket;\n  final StreamController\u003cString\u003e _streamController = StreamController\u003cString\u003e();\n  Stream\u003cString\u003e get messagesStream =\u003e _streamController.stream;\n\n  TextEditingController controller = TextEditingController();\n\n  //This will give platofrm specific url for ios and android emulator\n  String socketUrl() {\n    if (Platform.isAndroid) {\n      return \"http://10.0.2.2:3000\";\n    } else {\n      return \"http://localhost:3000\";\n    }\n  }\n\n  @override\n  void initState() {\n    super.initState();\n    // Connect to the Socket.IO server\n    socket = IO.io(socketUrl(), \u003cString, dynamic\u003e{\n      'transports': ['websocket'],\n    });\n\n    socket.on('connect', (_) {\n      print('Connected to server');\n    });\n\n    // Listen for messages from the server\n    socket.on('message', (data) {\n      _streamController.add(data);\n    });\n  }\n\n  @override\n  void dispose() {\n    // Disconnect from the Socket.IO server when the app is disposed\n    socket.disconnect();\n\n    //close stream\n    _streamController.close();\n    super.dispose();\n  }\n\n  void sendMessage(String message) {\n    // Send a message to the server\n    socket.emit('sendMessage', message);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Socket.IO Flutter Demo'),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: \u003cWidget\u003e[\n            Padding(\n              padding: const EdgeInsets.symmetric(horizontal: 40),\n              child: TextFormField(\n                onChanged: (value) {\n                  if (socket.connected) {\n                    sendMessage(value);\n                  }\n                },\n                controller: controller,\n                decoration: const InputDecoration(hintText: \"Enter Message\"),\n              ),\n            ),\n            const SizedBox(height: 40),\n            StreamBuilder\u003cString\u003e(\n              stream: messagesStream,\n              builder: (context, snapshot) {\n                if (snapshot.hasError) {\n                  return Text('Error: ${snapshot.error}');\n                }\n                return Padding(\n                  padding: const EdgeInsets.symmetric(horizontal: 25),\n                  child: ListTile(\n                    title: Text(\"Received Message: ${snapshot.data ?? \"\"}\"),\n                  ),\n                );\n              },\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n```\n","ogImage":{"url":"/assets/img/2024-06-23-FlutterandSocketIOReal-timeIntegration_0.png"},"coverImage":"/assets/img/2024-06-23-FlutterandSocketIOReal-timeIntegration_0.png","tag":["Tech"],"readingTime":6},{"title":"Flutter에서 동적으로 앱 아이콘 변경하는 방법","description":"","date":"2024-06-23 14:51","slug":"2024-06-23-DynamicchangeAppIconFlutter","content":"\n안녕하세요! 이번 기사에서는 앱 아이콘을 동적으로 변경하는 방법을 구성하고 코딩하는 방법을 살펴보겠습니다. 안드로이드에서는 원하는 경우 라벨도 변경할 수 있습니다.\n\n우선, 새로운 Flutter 프로젝트를 만들어보세요. 저희 예시에서는 dynamic_icon_example이라는 프로젝트를 만들었습니다. 너무 많은 코딩 시간을 낭비하지 않도록 미리 만들어둔 예시 코드를 사용하겠습니다.\n\n시작해봅시다. 첫 번째로 이해해야 할 것은 MethodChannel입니다. 이 클래스를 사용하면 Flutter 애플리케이션 내에서 네이티브 코드를 작성할 수 있으며 (iOS의 경우 Swift, Android의 경우 Kotlin), 이 코드를 호출할 수 있습니다. 실용적인 예시를 살펴보겠습니다.\n\n앱 폴더 내에서 android → app → src → main → kotlin → MainActivity.kt 파일을 열어보세요. 다음과 같은 내용을 볼 수 있을 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![Dynamic Change App Icon](/assets/img/2024-06-23-DynamicchangeAppIconFlutter_0.png)\n\n프로젝트를 생성할 때 생성된 이름이 첫 번째 줄입니다. 이제 Flutter 측에서 메소드를 호출하기 위한 코드를 작성해야 합니다. 여기에서 호출할 채널을 구성할 것인데, 그 채널의 이름은 \"com.example.dynamic_icon_example/icon\"으로 지정할 것입니다. 또한 몇 가지 import 문을 추가해야 합니다. 여기에 있습니다:\n\n```js\npackage com.example.com.example.dynamic_icon_example\n\nimport androidx.annotation.NonNull\nimport io.flutter.embedding.android.FlutterFragmentActivity\nimport io.flutter.embedding.engine.FlutterEngine\nimport io.flutter.plugin.common.MethodChannel\nimport io.flutter.embedding.android.FlutterActivity\nimport io.flutter.plugins.GeneratedPluginRegistrant\n```\n\n이제 도움이 될 몇 가지 속성을 만들 수 있습니다. MainActivity 클래스 내부에 두 개의 변수를 추가할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n    private val CHANNEL = \"app.com.get.number\"\n    var methodChannelResult: MethodChannel.Result? = null\n```\n\nCHANNEL 변수는 호출할 채널의 이름입니다; 원하는 이름을 넣을 수 있어요. 이후에 configureFlutterEngine을 오버라이드하고 우리의 메소드를 생성할 수 있어요.\n\n```js\n@Override\n    override fun configureFlutterEngine(@NonNull flutterEngine: FlutterEngine) {\n        GeneratedPluginRegistrant.registerWith(flutterEngine)\n        super.configureFlutterEngine(flutterEngine)\n\n        MethodChannel(flutterEngine.dartExecutor, CHANNEL).setMethodCallHandler { call, result -\u003e\n            try {\n                methodChannelResult = result\n                if (call.method.equals(\"odd\")) {\n                    result.success(1)\n                } else if (call.method.equals(\"even\")) {\n                    result.success(2)\n                } else {\n                    result.success(-1)\n                }\n            } catch (e: Exception) {\n                print(e)\n            }\n        }\n    }\n```\n\n이렇게 하면 Flutter 측에서 우리의 메소드를 호출할 수 있어요. 마지막으로, 완전한 코드는 다음과 같아요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\npackage com.example.dynamic_icon_example\n\nimport androidx.annotation.NonNull\nimport io.flutter.embedding.android.FlutterFragmentActivity\nimport io.flutter.embedding.engine.FlutterEngine\nimport io.flutter.plugin.common.MethodChannel\nimport io.flutter.embedding.android.FlutterActivity\nimport io.flutter.plugins.GeneratedPluginRegistrant\n\nclass MainActivity: FlutterActivity() {\n\n    private val CHANNEL = \"app.com.get.number\"\n    var methodChannelResult: MethodChannel.Result? = null\n\n    @Override\n    override fun configureFlutterEngine(@NonNull flutterEngine: FlutterEngine) {\n        GeneratedPluginRegistrant.registerWith(flutterEngine)\n        super.configureFlutterEngine(flutterEngine)\n\n        MethodChannel(flutterEngine.dartExecutor, CHANNEL).setMethodCallHandler { call, result -\u003e\n            try {\n                methodChannelResult = result\n                if (call.method.equals(\"odd\")) {\n                    result.success(1)\n                } else if (call.method.equals(\"even\")) {\n                    result.success(2)\n                } else {\n                    result.success(-1)\n                }\n            } catch (e: Exception) {\n                print(e)\n            }\n        }\n    }\n}\n```\n\n우리의 Android에서의 MethodChannel 설정이 완료되었습니다. 이제 iOS로 넘어갑시다. ios 폴더로 이동하여 `Runner` -\u003e `AppDelegate.swift`로 이동해주세요.\n![앱 아이콘을 동적으로 변경하는 플러터 앱의 스크린샷](/assets/img/2024-06-23-DynamicchangeAppIconFlutter_1.png)\n\n여기가 iOS 측의 코드입니다. 코드는 다음과 같이 보일 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport UIKit\nimport Flutter\n\n@UIApplicationMain\n@objc class AppDelegate: FlutterAppDelegate {\n  override func application(\n    _ application: UIApplication,\n    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?\n  ) -\u003e Bool {\n\n    let controller: FlutterViewController = window?.rootViewController as! FlutterViewController\n    let appIconChannel = FlutterMethodChannel(\n      name: \"com.example.dynamic_icon_example.get.number\", binaryMessenger: controller.binaryMessenger)\n\n    appIconChannel.setMethodCallHandler({\n      [weak self] (call: FlutterMethodCall, result: FlutterResult) -\u003e Void in\n      if call.method == \"odd\" {\n       result(1)\n      } else if call.method == \"even\" {\n        result(2)\n      } else {\n       result(-1)\n        return\n      }\n    })\n\n    GeneratedPluginRegistrant.register(with: self)\n    return super.application(application, didFinishLaunchingWithOptions: launchOptions)\n  }\n}\n```\n\n위 코드를 설명하자면, 이 함수는 화면에서 선택한 홀수나 짝수에 따라 홀수나 짝수를 반환합니다. 이제 main.dart 파일로 돌아가서 코드를 작성할 수 있습니다. 소스 코드에서 모든 주석을 제거하고 \\_incrementCounter라는 함수를 찾습니다. 이 함수를 비동기식으로 만듭니다. 상태(State) 내부에 채널을 호출할 변수를 만들 수 있습니다. 다음과 같이 채널을 호출하는 변수를 생성합니다:\n\n```js\nclass _MyHomePageState extends State\u003cMyHomePage\u003e {\n  int _counter = 0;\n  final MethodChannel channel = const MethodChannel('com.example.dynamic_icon_example.get.number');\n```\n\n그리고 \\_incrementCounter 함수 내부에서 메소드를 호출할 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n  Future\u003cvoid\u003e _incrementCounter() async {\n    final int number =\n        await channel.invokeMethod(_counter % 2 == 0 ? 'even' : 'odd');\n    print(number);\n    setState(() {\n      _counter++;\n    });\n  }\n```\n\n그리고 디버그 콘솔에서 값들을 확인할 수 있습니다:\n\n![이미지](/assets/img/2024-06-23-DynamicchangeAppIconFlutter_2.png)\n\n이제 앱 아이콘을 동적으로 변경하는 방법에 대해 이야기해보겠습니다. 먼저 Android 및 iOS 앱을 구성해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nANDROID\n\n안녕하세요! 안드로이드 개발자 여러분!\n\nandroid/app/src/main 폴더 안의 AndroidManifest.xml 파일을 열어주세요. `activity` 태그를 찾은 후, 그 안에 다음 코드를 추가해주세요:\n\n```js\nandroid: enabled = \"false\";\n```\n\n이후, 각 아이콘 변형에 대해 activity-alias를 생성할 건데요. 각 activity-alias 코드는 다음과 같이 보일 거에요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003cactivity-alias\n    android:name=\".launcherAlias.one\"\n    android:enabled=\"false\"\n    android:icon=\"@mipmap/icon_launch\"\n    android:label=\"One\"\n    android:targetActivity=\".MainActivity\"\n    android:exported=\"true\"\u003e\n    \u003cintent-filter\u003e\n        \u003caction android:name=\"android.intent.action.MAIN\" /\u003e\n        \u003ccategory android:name=\"android.intent.category.LAUNCHER\" /\u003e\n    \u003c/intent-filter\u003e\n    \u003cintent-filter\u003e\n        \u003caction android:name=\"android.intent.action.VIEW\" /\u003e\n        \u003ccategory android:name=\"android.intent.category.DEFAULT\" /\u003e\n        \u003ccategory android:name=\"android.intent.category.BROWSABLE\" /\u003e\n    \u003c/intent-filter\u003e\n\u003c/activity-alias\u003e\n\n\u003cactivity-alias\n    android:name=\".launcherAlias.two\"\n    android:enabled=\"false\"\n    android:icon=\"@mipmap/icon_launch\"\n    android:label=\"Two\"\n    android:targetActivity=\".MainActivity\"\n    android:exported=\"true\"\u003e\n    \u003cintent-filter\u003e\n        \u003caction android:name=\"android.intent.action.MAIN\" /\u003e\n        \u003ccategory android:name=\"android.intent.category.LAUNCHER\" /\u003e\n    \u003c/intent-filter\u003e\n    \u003cintent-filter\u003e\n        \u003caction android:name=\"android.intent.action.VIEW\" /\u003e\n        \u003ccategory android:name=\"android.intent.category.DEFAULT\" /\u003e\n        \u003ccategory android:name=\"android.intent.category.BROWSABLE\" /\u003e\n    \u003c/intent-filter\u003e\n\u003c/activity-alias\u003e\n\n\u003cactivity-alias\n    android:name=\".launcherAlias.default\"\n    android:enabled=\"true\"\n    android:icon=\"@mipmap/icon_launch\"\n    android:label=\"Dynamic\"\n    android:targetActivity=\".MainActivity\"\n    android:exported=\"true\"\u003e\n    \u003cintent-filter\u003e\n        \u003caction android:name=\"android.intent.action.MAIN\" /\u003e\n        \u003ccategory android:name=\"android.intent.category.LAUNCHER\" /\u003e\n    \u003c/intent-filter\u003e\n    \u003cintent-filter\u003e\n        \u003caction android:name=\"android.intent.action.VIEW\" /\u003e\n        \u003ccategory android:name=\"android.intent.category.DEFAULT\" /\u003e\n        \u003ccategory android:name=\"android.intent.category.BROWSABLE\" /\u003e\n    \u003c/intent-filter\u003e\n\u003c/activity-alias\u003e\n```\n\n2개의 추가 구성을 만들어 Android 앱 아이콘 및 앱 레이블을 변경할 것입니다. 아이콘만 변경하려면 각 activity-alias 정의에서 android:label 줄을 삭제하면 됩니다. 이제 이미지를 생성해야 합니다. 이미지를 생성하려면 이 사이트를 사용할 수 있습니다: AppIcon. 이제 각 activity-alias의 android:icon 속성을 mipmap 폴더 내의 이미지 이름과 일치하도록 변경하십시오. AndroidManifest.xml은 다음과 같아야 합니다:\n\n```js\n\u003cmanifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\u003e\n    \u003capplication\n        android:label=\"Dynamic\"\n        android:name=\"${applicationName}\"\n        android:icon=\"@mipmap/ic_launcher\"\u003e\n        \u003cactivity\n            android:name=\".MainActivity\"\n            android:exported=\"true\"\n            android:enabled=\"false\"\n            android:launchMode=\"singleTop\"\n            android:theme=\"@style/LaunchTheme\"\n            android:configChanges=\"orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode\"\n            android:hardwareAccelerated=\"true\"\n            android:windowSoftInputMode=\"adjustResize\"\u003e\n            \u003c!-- Specifies an Android theme to apply to this Activity as soon as\n                 the Android process has started. This theme is visible to the user\n                 while the Flutter UI initializes. After that, this theme continues\n                 to determine the Window background behind the Flutter UI. --\u003e\n            \u003cmeta-data\n                android:name=\"io.flutter.embedding.android.NormalTheme\"\n                android:resource=\"@style/NormalTheme\"\n            /\u003e\n            \u003cintent-filter\u003e\n                \u003caction android:name=\"android.intent.action.MAIN\" /\u003e\n                \u003ccategory android:name=\"android.intent.category.LAUNCHER\" /\u003e\n            \u003c/intent-filter\u003e\n        \u003c/activity\u003e\n        \u003c!-- Don't delete the meta-data below.\n             This is used by the Flutter tool to generate GeneratedPluginRegistrant.java --\u003e\n        \u003cmeta-data\n            android:name=\"flutterEmbedding\"\n            android:value=\"2\" /\u003e\n\n        \u003c!-- 여기에 위의 activity-alias 코드를 붙여넣으세요 --\u003e\n    \u003c/application\u003e\n\u003c/manifest\u003e\n\nMainActivity.kt 파일이 있는 폴더로 이동하면, 각 alias에 대한 이름으로 파일을 생성해야 합니다. \".launcherAlias.\" 이후의 마지막 이름만 사용하면 됩니다. 제 경우에는 파일 이름이 Default.kt, One.kt, Two.kt 여야 합니다. 각 파일에 아래 코드를 복사하여 붙여넣고 이름만 변경하시면 됩니다.\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\npackage com.example.dynamic_icon_example.launcherAlias\n\nimport io.flutter.embedding.android.FlutterActivity\n// 각 alias의 이름을 변경합니다.\nclass Default: FlutterActivity() {\n}\n```\n\nMainActivity에서는 앱의 아이콘과 라벨을 변경하는 코드를 만들 것입니다. CHANNEL의 이름을 변경하여 아이콘 변경을 나타내는 의미 있는 이름으로 바꿔주세요. 예를 들어, \"app.com.get.change.icon\"과 같은 이름을 사용했습니다.\n\n다음은 사용할 주석이 달린 코드입니다:\n\n```kotlin\npackage com.example.dynamic_icon_example\n\nimport android.content.ComponentName\nimport android.content.pm.PackageManager\nimport androidx.annotation.NonNull\nimport io.flutter.embedding.android.FlutterFragmentActivity\nimport io.flutter.embedding.engine.FlutterEngine\nimport io.flutter.plugin.common.MethodChannel\nimport io.flutter.embedding.android.FlutterActivity\nimport io.flutter.plugins.GeneratedPluginRegistrant\n\nclass MainActivity: FlutterActivity() {\n\n    // 채널의 이름\n    private val CHANNEL = \"app.com.get.change.icon\"\n    var methodChannelResult: MethodChannel.Result? = null\n    // 초기 점을 제외한 모든 alias를 추가합니다.\n    val aliases = listOf(\"launcherAlias.Default\", \"launcherAlias.One\", \"launcherAlias.Two\")\n\n    @Override\n    override fun configureFlutterEngine(@NonNull flutterEngine: FlutterEngine) {\n        GeneratedPluginRegistrant.registerWith(flutterEngine)\n        super.configureFlutterEngine(flutterEngine)\n\n        MethodChannel(flutterEngine.dartExecutor, CHANNEL).setMethodCallHandler { call, result -\u003e\n            try {\n                methodChannelResult = result\n                // 우리가 호출할 메소드\n                if (call.method.equals(\"changeIcon\")) {\n                    // 전달된 이름을 복구합니다\n                    val targetIcon = call.argument\u003cString\u003e(\"targetIcon\") as String\n                    // 변경을 수행할 함수를 호출합니다.\n                    // 여기서 이미 \"launcherAlias\"를 추가했습니다.\n                    setIcon(\"launcherAlias.$targetIcon\")\n                } else {\n                    result.success(-1)\n                }\n            } catch (e: Exception) {\n                print(e)\n            }\n        }\n    }\n\n    private fun setIcon(targetIcon: String) {\n        try {\n            // 사용할 패키지 이름을 포함하는 String을 작성합니다.\n            val packageManager: PackageManager = applicationContext!!.packageManager\n            val packageName = applicationContext!!.packageName\n            val className = StringBuilder()\n            className.append(packageName)\n            className.append(\".\")\n            className.append(targetIcon)\n\n            aliases.forEach { alias -\u003e\n                // 모든 목록을 실행하고 설정할 것 외에는 모두 비활성화합니다.\n                val state =\n                    if (alias == targetIcon) PackageManager.COMPONENT_ENABLED_STATE_ENABLED\n                    else PackageManager.COMPONENT_ENABLED_STATE_DISABLED\n\n                // 새로운 아이콘과 라벨을 설정합니다.\n                packageManager.setComponentEnabledSetting(\n                    ComponentName(packageName, \"com.example.dynamic_icon_example.$alias\"),\n                    state,\n                    PackageManager.DONT_KILL_APP\n                )\n            }\n        } catch (e: Exception) {\n            print(e)\n        }\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플러터 쪽에서 main.dart의 \\_incrementCounter 함수 내부에서:\n\n```js\n  Future\u003cvoid\u003e _incrementCounter() async {\n// 네이티브 메서드를 호출하여 아이콘을 변경할 예정\n// 아이콘의 최종 이름만 전달하면 \"launcherAlias\"는 kotlin 쪽에서 설정됨\n    final dynamic number =\n        await channel.invokeMethod('changeIcon', \u003cString, dynamic\u003e{'targetIcon': 'One'});\n    print(number);\n    setState(() {\n      _counter++;\n    });\n  }\n```\n\n이제 테스트할 수 있습니다.\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*eICX4eVobzz-tyLme9W4Hg.gif\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n본글에 나온 코드는 앱이 아이콘을 변경할 때 종료되는 문제를 해결하는 코드입니다. MainActivity 폴더로 돌아가 \"SharedPref.kt\"라는 다른 파일을 만들어 아래 코드를 붙여넣으세요:\n\n```js\npackage com.example.dynamic_icon_example.helper\n\nimport android.content.Context\nimport android.content.Context.MODE_PRIVATE\nimport android.content.SharedPreferences\n\nopen class AppSharedPref {\n\n    companion object {\n        const val CONFIGURATION_PREF = \"configurationPreference\"\n\n        /*런처 아이콘*/\n        private const val KEY_LAUNCHER_IMAGE = \"launcherIcon\"\n        private const val KEY_LAUNCHER_COUNT = \"count\"\n        private const val KEY_LAUNCHER_SAVED_COUNT = \"savedCount\"\n\n        fun getSharedPreference(context: Context, preferenceFile: String): SharedPreferences {\n            return context.getSharedPreferences(preferenceFile, MODE_PRIVATE)\n        }\n\n        fun getSharedPreferenceEditor(\n            context: Context,\n            preferenceFile: String\n        ): SharedPreferences.Editor {\n            return context.getSharedPreferences(preferenceFile, MODE_PRIVATE).edit()\n        }\n\n        /* 설정 관련 함수 */\n\n        fun getLauncherIcon(context: Context): String? {\n            return getSharedPreference(context, CONFIGURATION_PREF)\n                .getString(KEY_LAUNCHER_IMAGE, \"launcherAlias.DefaultLauncherAlias\")\n        }\n\n        fun setLauncherIcon(context: Context, launcherIcon: String) {\n            getSharedPreferenceEditor(context, CONFIGURATION_PREF)\n                .putString(KEY_LAUNCHER_IMAGE, launcherIcon)\n                .apply()\n        }\n\n        fun getCount(context: Context): Int {\n            return getSharedPreference(context, CONFIGURATION_PREF).getInt(KEY_LAUNCHER_COUNT, 0)\n        }\n\n        fun setCount(context: Context, count: Int) {\n            getSharedPreferenceEditor(context, CONFIGURATION_PREF)\n                .putInt(KEY_LAUNCHER_COUNT, count)\n                .apply()\n        }\n\n        fun getSavedCount(context: Context): Int {\n            return getSharedPreference(context, CONFIGURATION_PREF)\n                .getInt(KEY_LAUNCHER_SAVED_COUNT, 0)\n        }\n\n        fun setSavedCount(context: Context, count: Int) {\n            getSharedPreferenceEditor(context, CONFIGURATION_PREF)\n                .putInt(KEY_LAUNCHER_SAVED_COUNT, count)\n                .apply()\n        }\n    }\n}\n```\n\n이 코드는 공유 설정을 사용하여 메모리에 아이콘 변경 정보를 저장합니다. 이제 MainActivity로 돌아가 일부 변경사항을 가해봅시다.\n\n```js\npackage com.example.dynamic_icon_example\n\nimport android.content.ComponentName\nimport android.content.pm.PackageManager\nimport androidx.annotation.NonNull\nimport io.flutter.embedding.android.FlutterFragmentActivity\nimport io.flutter.embedding.engine.FlutterEngine\nimport io.flutter.plugin.common.MethodChannel\nimport io.flutter.embedding.android.FlutterActivity\nimport io.flutter.plugins.GeneratedPluginRegistrant\nimport com.example.dynamic_icon_example.helper.AppSharedPref\n\nclass MainActivity: FlutterActivity() {\n\n    private val CHANNEL = \"app.com.get.change.icon\"\n    var methodChannelResult: MethodChannel.Result? = null\n    // initial dot을 뺀 모든 별칭을 추가하세요\n    val aliases = listOf(\"launcherAlias.Default\", \"launcherAlias.One\", \"launcherAlias.Two\")\n\n    @Override\n    override fun configureFlutterEngine(@NonNull flutterEngine: FlutterEngine) {\n        GeneratedPluginRegistrant.registerWith(flutterEngine)\n        super.configureFlutterEngine(flutterEngine)\n\n        MethodChannel(flutterEngine.dartExecutor, CHANNEL).setMethodCallHandler { call, result -\u003e\n            try {\n                methodChannelResult = result\n                if (call.method.equals(\"changeIcon\")) {\n                    val targetIcon = call.argument\u003cString\u003e(\"targetIcon\") as String\n                    // 여기에서 정보를 저장하여 앱을 닫은 후 적용할 것입니다\n                    AppSharedPref.setLauncherIcon(this, \"launcherAlias.$targetIcon\")\n                    AppSharedPref.setCount(this, 0)\n                } else {\n                    result.success(-1)\n                }\n            } catch (e: Exception) {\n                print(e)\n            }\n        }\n    }\n\n    // 우리 앱이 종료될 때 아이콘 및 레이블 변경을 호출할 메소드입니다\n    override fun onDestroy() {\n        setIcon(AppSharedPref.getLauncherIcon(this).toString())\n        super.onDestroy()\n    }\n\n    private fun setIcon(targetIcon: String) {\n        try {\n            val packageManager: PackageManager = applicationContext!!.packageManager\n            val packageName = applicationContext!!.packageName\n            val className = StringBuilder()\n            className.append(packageName)\n            className.append(\".\")\n            className.append(targetIcon)\n\n            aliases.forEach { alias -\u003e\n                val state =\n                    if (alias == targetIcon) PackageManager.COMPONENT_ENABLED_STATE_ENABLED\n                    else PackageManager.COMPONENT_ENABLED_STATE_DISABLED\n\n                packageManager.setComponentEnabledSetting(\n                    ComponentName(packageName, \"com.example.dynamic_icon_example.$alias\"),\n                    state,\n                    PackageManager.DONT_KILL_APP\n                )\n            }\n        } catch (e: Exception) {\n            print(e)\n        }\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n결과를 확인해봅시다:\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*yIABZsLhcIv84MjkGh1cWA.gif\" /\u003e\n\nIOS\n\niOS로 이동하여 Xcode로 열어주세요. Runner 디렉토리 내에 AlternativeIcons라는 폴더를 생성해주세요. 여기에 이미지를 저장하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지_이름](/assets/img/2024-06-23-DynamicchangeAppIconFlutter_3.png)\n\n이제 Xcode의 Info.plist로 이동하여 \"Icon files (iOS 5)\"라는 매개변수를 Dictionary으로 추가하십시오. 이 매개변수 내에서 \"CFBundleAlternateIcons\"를 Dictionary로 추가하십시오. 그런 다음 사용하려는 각 새 이미지에 대해(예: \"Default\", \"One\", \"Two\") 새 항목을 만드십시오. 각 항목 내에서 \"CFBundleIconFiles\" 매개변수를 Array로 추가하십시오. 배열의 첫 번째 위치에는 이미지 이름을 @2x 또는 @3x 없이, .png 없이 사용하십시오.\n\n최종적으로 아래와 같이 보여야 합니다:\n\n![이미지_이름](/assets/img/2024-06-23-DynamicchangeAppIconFlutter_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAppDelegate.swift 파일에 함수를 만들어 봅시다.\n\n```js\nimport UIKit\nimport Flutter\n\n@UIApplicationMain\n@objc class AppDelegate: FlutterAppDelegate {\n  override func application(\n    _ application: UIApplication,\n    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?\n  ) -\u003e Bool {\n\n    let controller: FlutterViewController = window?.rootViewController as! FlutterViewController\n    //우리 채널 이름이 업데이트됐어요\n    let appIconChannel = FlutterMethodChannel(\n      name: \"app.com.get.change.icon\", binaryMessenger: controller.binaryMessenger)\n\n    appIconChannel.setMethodCallHandler({\n      [weak self] (call: FlutterMethodCall, result: FlutterResult) -\u003e Void in\n      if call.method == \"changeIcon\" {\n        // 변경을 수행하는 함수\n       self?.changeAppIcon(call: call, result: result)\n      } else {\n       result(-1)\n        return\n      }\n    })\n\n    GeneratedPluginRegistrant.register(with: self)\n    return super.application(application, didFinishLaunchingWithOptions: launchOptions)\n  }\n\n  private func changeAppIcon(call: FlutterMethodCall, result: FlutterResult) {\n    // 10.3 이상에서만 작동\n    if #available(iOS 10.3, *) {\n      guard UIApplication.shared.supportsAlternateIcons else {\n        result(false)\n        return\n      }\n      // 전달된 이름 복원\n      guard let args = call.arguments as? [String : Any] else {return}\n      let arguments: String = args[\"targetIcon\"] as! String\n\n      var iconName: String?\n\n      // 현재 아이콘의 이름 확인\n      if let currentIconName = UIApplication.shared.alternateIconName {\n        iconName = currentIconName\n      } else {\n        iconName = \"Normal\"\n      }\n      // 두 번 변경하지 않도록하는 조건 설정\n      if iconName == arguments {\n        result(false)\n        return\n      }\n      // 새 아이콘 적용\n      UIApplication.shared.setAlternateIconName(arguments)\n      result(true)\n\n    } else {\n      result(false)\n    }\n  }\n\n  private func getIcon(call: FlutterMethodCall, result: FlutterResult) {\n    result(UIApplication.shared.alternateIconName)\n  }\n}\n```\n\n작동 방식을 확인해 봅시다. 앱 아이콘을 \"Default\"로 변경해 보겠습니다:\n\n\u003cimg src=\"/assets/img/2024-06-23-DynamicchangeAppIconFlutter_5.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*siJRg9-s1ba9LwJfuvvscQ.gif)\n\n여기에서 소스 코드를 찾을 수 있습니다.\n\n이 글이 도움이 되었기를 바랍니다. 읽어 주셔서 감사합니다!\n","ogImage":{"url":"/assets/img/2024-06-23-DynamicchangeAppIconFlutter_0.png"},"coverImage":"/assets/img/2024-06-23-DynamicchangeAppIconFlutter_0.png","tag":["Tech"],"readingTime":22},{"title":"VSCode를 사용하여 Android Studio 대신 Windows 환경에서 Flutter 프로그래밍하는 방법","description":"","date":"2024-06-23 14:50","slug":"2024-06-23-FlutterprogrammingforandroidwithVSCodeinsteadofusingAndroidStudioinWindows","content":"\n\n\u003cimg src=\"/assets/img/2024-06-23-FlutterprogrammingforandroidwithVSCodeinsteadofusingAndroidStudioinWindows_0.png\" /\u003e\n\n# 윈도우에서 VSCode로 새 Flutter 프로젝트를 만드는 단계별 지침서\n\n## 단계 1: VSCode 설치하기\n\nVSCode를 공식 링크(https://code.visualstudio.com/download)에서 다운로드하고 설치하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-FlutterprogrammingforandroidwithVSCodeinsteadofusingAndroidStudioinWindows_1.png\" /\u003e\n\n## 단계 2: Flutter 확장 프로그램 설치\n\n비주얼 스튜디오 코드용 Flutter 확장 프로그램을 설치하세요. 이를 위해 비주얼 스튜디오 코드에서 Extension Marketplace를 열고 \"Flutter\"를 검색한 다음 Flutter 확장 프로그램을 설치하기 위해 \"설치\"를 클릭하세요.\n\n## 단계 3: Java 11 SDK 설치\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래 링크에서 Java 11 SDK를 다운로드하고 설치해주세요. https://www.oracle.com/in/java/technologies/javase/jdk11-archive-downloads.html\n\n![image](/assets/img/2024-06-23-FlutterprogrammingforandroidwithVSCodeinsteadofusingAndroidStudioinWindows_2.png)\n\n- 시스템 변수 아래에 새로운 변수를 생성해주세요.\n\n이름: JAVA_HOME, 값: C:\\Program Files\\Java\\jdk-11.0.12\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nJAVA_HOME=C:\\Program Files\\Java\\jdk-11.0.12\n```\n\n![Image](/assets/img/2024-06-23-FlutterprogrammingforandroidwithVSCodeinsteadofusingAndroidStudioinWindows_3.png)\n\n2. PATH에 %JAVA_HOME%\\bin 추가\n\n```js\n%JAVA_HOME%\\bin\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 단계 4: 명령 줄 도구를 사용하여 Android SDK 설치하기\n\n공식 링크인 https://developer.android.com/studio 에서 명령 줄 도구를 사용하여 Android SDK를 다운로드하세요.\n\n![이미지](/assets/img/2024-06-23-FlutterprogrammingforandroidwithVSCodeinsteadofusingAndroidStudioinWindows_4.png)\n\n- C:\\Android\\ 안에 android-sdk라는 이름의 폴더를 생성하세요.\n- 다운로드한 zip 파일을 C:\\Android\\android-sdk\\cmdline-tools\\latest\\ 경로에 압축 해제하세요. 참고: 경로는 동일해야 합니다.\n- 시스템 변수 아래에 새 변수를 만드세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nANDROID_HOME=C:\\Android\\android-sdk\nANDROID_SDK_ROOT=C:\\Android\\android-sdk\n```\n\n`ANDROID_HOME`의 이름과 값은 `C:\\Android\\android-sdk`입니다.\n\n![이미지](/assets/img/2024-06-23-FlutterprogrammingforandroidwithVSCodeinsteadofusingAndroidStudioinWindows_5.png)\n\n`ANDROID_SDK_ROOT`의 이름과 값은 `C:\\Android\\android-sdk`입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image 1](/assets/img/2024-06-23-FlutterprogrammingforandroidwithVSCodeinsteadofusingAndroidStudioinWindows_6.png)\n\n4. Variable After added like this.\n\n![Image 2](/assets/img/2024-06-23-FlutterprogrammingforandroidwithVSCodeinsteadofusingAndroidStudioinWindows_7.png)\n\n4. Add C:\\Android\\android-sdk\\cmdline-tools\\latest\\bin to PATH\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n%ANDROID_HOME%\\cmdline-tools\\latest\\bin\n```\n\n5. cmd sdkmanager — update 명령을 사용하여 SDK 관리자 업데이트\n\n```js\nsdkmanager --update\n```\n\n6. 다음 명령을 사용하여 시스템 이미지, 플랫폼, 플랫폼 도구, 에뮬레이터 및 빌드 도구 다운로드하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nsdkmanager emulator platform-tools\nsdkmanager \"system-images;android-29;google_apis;x86\"\nsdkmanager \"platforms;android-29\"\nsdkmanager \"build-tools;29.0.2\"\n```\n\n7. 그리고 최종적으로 다음 경로들이 시스템 변수 아래 PATH에 추가됩니다\n\n![image](/assets/img/2024-06-23-FlutterprogrammingforandroidwithVSCodeinsteadofusingAndroidStudioinWindows_8.png)\n\n## 단계 5: Flutter SDK 설치\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n공식 링크인 https://docs.flutter.dev/get-started/install/windows 에서 플러터의 최신 버전을 다운로드 받을 수 있어요.\n\n![이미지](/assets/img/2024-06-23-FlutterprogrammingforandroidwithVSCodeinsteadofusingAndroidStudioinWindows_9.png)\n\n- C:\\ 안에 Android란 이름의 폴더를 만들어주세요.\n- 다운로드한 zip 파일을 C:\\Android\\flutter 경로에 압축 해제해주세요.\n- C:\\Android\\flutter\\bin를 PATH에 추가해주세요\n\n```js\nC:\\Android\\flutter\\bin\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n4. 프로젝트가 저장된 드라이브에 Pubcache를위한 폴더를 만듭니다. D:\\Program Data\\.pubcache 및 PATH에 추가합니다.\n\n```js\nD:\\Program Data\\.pubcache\n```\n\n## 단계 6: Flutter가 작동하는지 확인합니다.\n\ncmd를 사용하여 flutter doctor -v를 실행하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nflutter doctor -v\n```\n\n\u003cimg src=\"/assets/img/2024-06-23-FlutterprogrammingforandroidwithVSCodeinsteadofusingAndroidStudioinWindows_10.png\" /\u003e\n\n## Step 7: Create new flutter project\n\nCreate a new flutter project using cmd `flutter create projectname`\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이미지를 참고해주세요!\n\n```js\nflutter create testpro\ncd testpro\ncode .\n```\n\nVSCode에서 폴더를 열기 위해 코드를 실행하세요.\n\n## 단계 8: 에뮬레이터 시작하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n에뮬레이터를 시작하기 위한 전제 조건입니다.\n\n- 가상화가 활성화되어 있어야 합니다.\n\n![이미지](/assets/img/2024-06-23-FlutterprogrammingforandroidwithVSCodeinsteadofusingAndroidStudioinWindows_12.png)\n\n3. Windows 10 Home에서 Hyper-v를 설치하고 활성화하려면 Windows Hypervisor 플랫폼 확인란을 선택하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](https://www.example.com/assets/img/2024-06-23-FlutterprogrammingforandroidwithVSCodeinsteadofusingAndroidStudioinWindows_13.png)\n\n4. 새로운 Android 가상 장치를 만들고 디바이스를 실행하려면 키 Ctrl+Shift+P를 눌러 명령 팔레트를 열고 select device를 입력하세요.\n\n![image](https://www.example.com/assets/img/2024-06-23-FlutterprogrammingforandroidwithVSCodeinsteadofusingAndroidStudioinWindows_14.png)\n\nAndroid 에뮬레이터를 만들어보세요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 단계 9: VSCode에서 프로젝트 디버그 모드 실행\n\n디버그 모드로 플러터 프로젝트를 실행하려면 메뉴에서 Run-` Start Debugging을 선택하거나 F5 키를 누르세요.\n\n![이미지](/assets/img/2024-06-23-FlutterprogrammingforandroidwithVSCodeinsteadofusingAndroidStudioinWindows_15.png)\n\n## 단계 10: 터미널에서 실행\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n터미널을 열려면 Ctrl + ` 키를 누르세요. 터미널에서 cmd flutter run을 입력하여 실행을 시작하세요.\n\n```js\nflutter run\n```\n\n## 단계 11: 프로덕션용 빌드\n\n터미널을 열려면 Ctrl + ` 키를 눌러주세요. 빌드 후 플레이스토어에 배포하려면 .abb 파일을 얻으려면 터미널에서 cmd flutter build appbundle을 입력하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\n플러터 앱 번들을 빌드하려면 다음 명령어를 실행하세요.\r\n```","ogImage":{"url":"/assets/img/2024-06-23-FlutterprogrammingforandroidwithVSCodeinsteadofusingAndroidStudioinWindows_0.png"},"coverImage":"/assets/img/2024-06-23-FlutterprogrammingforandroidwithVSCodeinsteadofusingAndroidStudioinWindows_0.png","tag":["Tech"],"readingTime":6}],"page":"3","totalPageCount":28,"totalPageGroupCount":2,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"3"},"buildId":"ckvP8zvWyPnScUqpsTElP","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>