<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>uidev-css</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://uidev-css.github.io///posts/5" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="uidev-css" data-gatsby-head="true"/><meta property="og:title" content="uidev-css" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://uidev-css.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://uidev-css.github.io///posts/5" data-gatsby-head="true"/><meta name="twitter:title" content="uidev-css" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | uidev-css" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/873-1e1f6fb6fd3c8994.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-498da29379dd58dc.js" defer=""></script><script src="/_next/static/Is-d56jDFXkc1ZfN4DhBP/_buildManifest.js" defer=""></script><script src="/_next/static/Is-d56jDFXkc1ZfN4DhBP/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UIDEV CSS</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="플러터에서 BloC 패턴으로 Fetch API 사용 방법" href="/post/2024-06-21-FetchAPIWithBloCinFlutter"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="플러터에서 BloC 패턴으로 Fetch API 사용 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-FetchAPIWithBloCinFlutter_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="플러터에서 BloC 패턴으로 Fetch API 사용 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">플러터에서 BloC 패턴으로 Fetch API 사용 방법</strong><div class="PostList_meta__VCFLX"><span class="date">2 hours ago</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="플러터에서 네이티브 코드와의 양방향 통신을 위한 메소드 채널 사용 방법" href="/post/2024-06-21-MethodChannelinFlutterBridgingNativeCodeandFlutterwithTwo-WayCommunication"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="플러터에서 네이티브 코드와의 양방향 통신을 위한 메소드 채널 사용 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-MethodChannelinFlutterBridgingNativeCodeandFlutterwithTwo-WayCommunication_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="플러터에서 네이티브 코드와의 양방향 통신을 위한 메소드 채널 사용 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">플러터에서 네이티브 코드와의 양방향 통신을 위한 메소드 채널 사용 방법</strong><div class="PostList_meta__VCFLX"><span class="date">2 hours ago</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter에서 백그라운드 서비스와 포어그라운드 서비스 사용 방법" href="/post/2024-06-21-BackgroundandForegroundservicesinFlutter"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter에서 백그라운드 서비스와 포어그라운드 서비스 사용 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-BackgroundandForegroundservicesinFlutter_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter에서 백그라운드 서비스와 포어그라운드 서비스 사용 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Flutter에서 백그라운드 서비스와 포어그라운드 서비스 사용 방법</strong><div class="PostList_meta__VCFLX"><span class="date">2 hours ago</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter로 작성된 모바일 앱인지 확인하는 방법" href="/post/2024-06-21-HowtoDetermineifaMobileAppisWritteninFlutter"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter로 작성된 모바일 앱인지 확인하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-HowtoDetermineifaMobileAppisWritteninFlutter_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter로 작성된 모바일 앱인지 확인하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Flutter로 작성된 모바일 앱인지 확인하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">2 hours ago</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter로 코드 생성하기  source_gen과 build_runner 사용 방법" href="/post/2024-06-21-CodeGenerationusingFluttersource_genbuild_runner"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter로 코드 생성하기  source_gen과 build_runner 사용 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-CodeGenerationusingFluttersource_genbuild_runner_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter로 코드 생성하기  source_gen과 build_runner 사용 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Flutter로 코드 생성하기  source_gen과 build_runner 사용 방법</strong><div class="PostList_meta__VCFLX"><span class="date">2 hours ago</span><span class="PostList_reading_time__6CBMQ">22<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="IntelliJ에서 Flutter 사용하는 방법" href="/post/2024-06-21-FlutterinIntelliJ"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="IntelliJ에서 Flutter 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-FlutterinIntelliJ_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="IntelliJ에서 Flutter 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">IntelliJ에서 Flutter 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">2 hours ago</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter 웹에서 캐시를 방지하는 방법" href="/post/2024-06-21-HowtopreventcacheinFlutterWeb"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter 웹에서 캐시를 방지하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-HowtopreventcacheinFlutterWeb_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter 웹에서 캐시를 방지하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Flutter 웹에서 캐시를 방지하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">2 hours ago</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Firebase로 Flutter 프로젝트에 애플 패스 추가하는 방법" href="/post/2024-06-21-HowtoaddApplePassonaFlutterprojectwithFirebase"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Firebase로 Flutter 프로젝트에 애플 패스 추가하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-HowtoaddApplePassonaFlutterprojectwithFirebase_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Firebase로 Flutter 프로젝트에 애플 패스 추가하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Firebase로 Flutter 프로젝트에 애플 패스 추가하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">2 hours ago</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="2024년 Flutter에서 GraphQL 사용법 쿼리, 뮤테이션, 서브스크립션 구현 완벽 가이드" href="/post/2024-06-21-GraphQLinFlutterAComprehensiveGuidetoQueryMutationandSubscriptionImplementations"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="2024년 Flutter에서 GraphQL 사용법 쿼리, 뮤테이션, 서브스크립션 구현 완벽 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-GraphQLinFlutterAComprehensiveGuidetoQueryMutationandSubscriptionImplementations_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="2024년 Flutter에서 GraphQL 사용법 쿼리, 뮤테이션, 서브스크립션 구현 완벽 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">2024년 Flutter에서 GraphQL 사용법 쿼리, 뮤테이션, 서브스크립션 구현 완벽 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">2 hours ago</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter에서 Stripe를 사용하여 결제 통합하는 방법" href="/post/2024-06-21-IntegratePaymentinFlutterwithStripe"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter에서 Stripe를 사용하여 결제 통합하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-21-IntegratePaymentinFlutterwithStripe_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter에서 Stripe를 사용하여 결제 통합하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Flutter에서 Stripe를 사용하여 결제 통합하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">2 hours ago</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link posts_-active__YVJEi" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"플러터에서 BloC 패턴으로 Fetch API 사용 방법","description":"","date":"2024-06-21 22:39","slug":"2024-06-21-FetchAPIWithBloCinFlutter","content":"\n\n이 문서에서는 블록 라이브러리를 사용하여 HTTP 요청을 수행하고 애플리케이션의 상태를 관리하는 방법을 살펴보겠습니다. 최종 애플리케이션은 다음과 같습니다:\n\n![애플리케이션 데모](https://miro.medium.com/v2/resize:fit:576/1*amzYfYKgiZ8zpehBTVcx4w.gif)\n\n앱이 처음 실행될 때, 서버에서 데이터를 가져올 때 로딩 표시기가 표시됩니다. 데이터를 가져온 후에는 목록에 표시됩니다.\n\n이를 위해 몇 가지 패키지를 사용하겠습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```yaml\ndependencies:\n  flutter_bloc: ^8.1.1\n  http: ^0.13.5\n  equatable: ^2.0.5\n```\n\n이제 API를 사용하여 서버에서 데이터를 가져오는 메커니즘을 만들어 보겠습니다. http 작업을 수행하기 위해 lib 내부에 폴더를 생성하고 repo라는 이름으로 지정합니다. 이 repo 내부에 repositories.dart라는 새 파일을 생성합니다.\n\n```dart\nimport 'dart:convert';\n\nimport 'package:bloc_example/models/user_model.dart';\nimport 'package:http/http.dart';\n\nclass UserRepository {\n  String userUrl = 'https://reqres.in/api/users?page=2';\n\n  Future\u003cList\u003cUserModel\u003e\u003e getUsers() async {\n    Response response = await get(Uri.parse(userUrl));\n   \n    if (response.statusCode == 200) {\n      final List result = jsonDecode(response.body)['data'];\n      return result.map((e) =\u003e UserModel.fromJson(e)).toList();\n    } else {\n      throw Exception(response.reasonPhrase);\n    }\n  }\n}\n```\n\nhttp 요청을 수행하려면 http 패키지를 사용할 것입니다. 이제 json 내용을 살펴봅시다. 우리는 이 링크의 API를 사용하고 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 링크에서 제공되는 JSON을 보면 모델이 어떻게 보일지에 대한 아이디어를 얻을 수 있습니다. 이 JSON에서는 데이터 태그의 속성을 갖게 될 것입니다. 여기서 우리는 firstname, lastname, email, 그리고 avatar에 초점을 맞출 것입니다.\n\n이제 모델 클래스를 만들어 봅시다.\n\n```js\nclass UserModel {\n  int? id;\n  String? email;\n  String? firstName;\n  String? lastName;\n  String? avatar;\n\n  UserModel({this.id, this.email, this.firstName, this.lastName, this.avatar});\n\n  UserModel.fromJson(Map\u003cString, dynamic\u003e json) {\n    id = json['id'];\n    email = json['email'];\n    firstName = json['first_name'];\n    lastName = json['last_name'];\n    avatar = json['avatar'];\n  }\n}\n```\n\n계속해서, 이제 우리의 블록이 어떻게 작동하는지에 대해 알아보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-21-FetchAPIWithBloCinFlutter_0.png\" /\u003e\n\n위의 그림을 보면\n\n- 먼저 UI가 있고 UI에서 블록으로 요청을 합니다.\n- 블록에는 이벤트와 상태 두 가지가 있습니다. 먼저 UI가 블록에 연결되면 이벤트를 생성하고 트리거합니다.\n- 이벤트는 최종적으로 엔드포인트를 통해 서버에 저장소를 호출합니다.\n- 서버에서 데이터를 가져와 블록에 다시 전달합니다. 데이터가 있으므로 상태를 트리거합니다.\n- 상태가 변경되었으므로 UI는 Bloc 패턴에서 알고 UI를 업데이트합니다.\n\n새 폴더 blocs를 만들고 app_states.dart라는 새 파일을 생성합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```dart\nimport 'package:bloc_example/models/user_model.dart';\nimport 'package:equatable/equatable.dart';\nimport 'package:flutter/material.dart';\n\n@immutable\nabstract class UserState extends Equatable {}\n\nclass UserLoadingState extends UserState {\n  @override\n  List\u003cObject?\u003e get props =\u003e [];\n}\n\nclass UserLoadedState extends UserState {\n  final List\u003cUserModel\u003e users;\n  UserLoadedState(this.users);\n  @override\n  List\u003cObject?\u003e get props =\u003e [users];\n}\n\nclass UserErrorState extends UserState {\n  final String error;\n  UserErrorState(this.error);\n  @override\n  List\u003cObject?\u003e get props =\u003e [error];\n}\n```\n\nEquatable를 사용하면 값들을 비교할 수 있습니다. 두 변수가 동일한 값을 갖고 있다면 UI를 변경하거나 업데이트하지 않을 것입니다.\n\n먼저 상태를 생성하려면 equatable을 확장해야 하는 추상 클래스를 생성해야 합니다.\n\nBloc에서 x.obs를 통해 변수를 반응형으로 만들 수 있는 Getx와 달리 Bloc에서는 이와 같이 작동하지 않습니다. Bloc을 사용할 때는 모든 상태가 클래스임을 염두에 두어야 합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 프로젝트에서는 세 가지 상태가 있습니다.\n\n- 데이터를 불러올 때의 상태\n- 데이터를 불러왔을 때의 상태\n- 데이터를 가져오는 데 오류가 발생했을 때의 상태\n\n그리고 Equatable 내부에 get props라는 속성이 있습니다. 이를 재정의해야 합니다. UserState 클래스가 Equatable을 확장했으므로 UserLoadingState, UserLoadedState 및 UserErrorState 상태 클래스가 get props 속성에 액세스할 수 있게 됩니다. 이를 얻기 위해 재정의하고 해당 값을 설정해야 합니다.\n\n상태 이후, Flutter 블록에서는 각 상태마다 이벤트가 있습니다. 지금 app_events.dart라는 파일을 만들어야 합니다. 상태와 마찬가지로 이벤트를 위한 클래스를 생성해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport 'package:equatable/equatable.dart';\nimport 'package:flutter/material.dart';\n\n@immutable\nabstract class UserEvent extends Equatable {\n  const UserEvent();\n}\n\nclass LoadUserEvent extends UserEvent {\n  @override\n  List\u003cObject?\u003e get props =\u003e [];\n}\n```\n\n상태처럼 이벤트도 Equatable 클래스를 확장해야 합니다. 각 이벤트를 위한 전용 클래스를 만들어야 합니다. 이벤트 클래스는 기본 클래스를 확장해야 합니다. 여기서 기본 클래스는 UserEvent입니다. 그리고 이벤트는 LoadUserEvent입니다. 그리고 get props를 재정의해야 합니다.\n\n@immutable은 클래스의 속성을 변경하고 싶지 않다는 것을 나타냅니다.\n\n상태와 이벤트를 생성한 후에는 그들을 연결하는 방법을 찾아야 합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러려면 새 클래스를 만들고 방금 만든 상태와 이벤트를 삽입해야 해요. 이제 Bloc 라이브러리를 사용하여 이것들을 연결해 보죠.\n\nblocs 폴더 안에 app_blocs라는 새 파일을 만들어주세요.\n\n```dart\nimport 'package:bloc_example/blocs/app_events.dart';\nimport 'package:bloc_example/blocs/app_states.dart';\nimport 'package:bloc_example/repos/repositories.dart';\nimport 'package:flutter_bloc/flutter_bloc.dart';\n\nclass UserBloc extends Bloc\u003cUserEvent, UserState\u003e {\n  final UserRepository _userRepository;\n\n  UserBloc(this._userRepository) : super(UserLoadingState()) {\n    on\u003cLoadUserEvent\u003e((event, emit) async {\n      emit(UserLoadingState());\n      try {\n        final users = await _userRepository.getUsers();\n        emit(UserLoadedState(users));\n      } catch (e) {\n        emit(UserErrorState(e.toString()));\n      }\n    });\n  }\n}\n```\n\n여기엔 UserBloc이라는 클래스가 있습니다. 이 클래스는 Bloc을 확장합니다. 이 Bloc은 이벤트와 상태를 가져와야 합니다. 저희 경우에는 UserEvent와 UserState입니다. 이곳에서 사용하는 Bloc은 실제로 Bloc 라이브러리에서 제공됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 UserBloc에는 리포지토리를 전달하는 생성자가 있어요. UI에서 이것을 호출할 거거든요. 이 클래스를 호출하는 동안 UserRepository를 전달합니다. Bloc을 사용했기 때문에 초기 상태를 슈퍼 생성자에 전달해야해요. 초기값을 호출한 후에는 on 메소드를 호출하게 됩니다.\n\n이제 on 메소드는 이벤트 유형을 가져와서 LoadUserEvent를 여기에 전달합니다. 이 이벤트를 사용하여 어떤 작업을 수행할 수 있어요. 이 이벤트가 호출되면 일부 상태를 방출하도록 지정합니다. 이 경우에는 UserLoadingState를 UI에서 변경 사항을 확인하려고 해요.\n\nBLoc에서 상태, 이벤트를 연결하여 상태를 트리거하고 작업할 수 있도록 하려면 lib 폴더에 homepage.dart라는 새 파일을 만들어요.\n\n```js\nclass HomePage extends StatelessWidget {\n  const HomePage({Key key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MultiBlocProvider(\n      providers: [\n        BlocProvider\u003cUserBloc\u003e(\n          create: (BuildContext context) =\u003e UserBloc(UserRepository()),\n        ),\n      ],\n      child: Scaffold(\n          appBar: AppBar(title: const Text('The BloC App')),\n          body: blocBody()),\n    );\n  }\n\nWidget blocBody() {\n    return BlocProvider(\n      create: (context) =\u003e UserBloc(\n        UserRepository(),\n      )..add(LoadUserEvent()),\n      child: BlocBuilder\u003cUserBloc, UserState\u003e(\n        builder: (context, state) {\n          if (state is UserLoadingState) {\n            return const Center(\n              child: CircularProgressIndicator(),\n            );\n          }\n           if (state is UserErrorState) {\n            return const Center(child:  Text(\"Error\"));\n          }\n          if (state is UserLoadedState) {\n            List\u003cUserModel\u003e userList = state.users;\n            return ListView.builder(\n                itemCount: userList.length,\n                itemBuilder: (_, index) {\n                  return Padding(\n                    padding:\n                        const EdgeInsets.symmetric(vertical: 4, horizontal: 8),\n                    child: Card(\n                        color: Theme.of(context).primaryColor,\n                        child: ListTile(\n                            title: Text(\n                              '${userList[index].firstName}  ${userList[index].lastName}',\n                              style: const TextStyle(color: Colors.white),\n                            ),\n\n                            subtitle: Text(\n                              '${userList[index].email}',\n                              style: const TextStyle(color: Colors.white),\n                            ),\n                            \n                            leading: CircleAvatar(\n                              backgroundImage: NetworkImage(\n                                  userList[index].avatar.toString()),\n                            ))),\n                  );\n                });\n          }\n\n          return Container();\n        },\n      ),\n    );\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n보시다시피 'MultiBlocProvider'가 제공되는 우리의 bloc 라이브러리에서 온 것을 확인할 수 있어요. 서버에서 데이터를로드하고 한 번만 로드하려고하기 때문에 빌드 방법에서 UserRepository를 주입합니다. bloc 형식의 MultiBlocProvider에서는 클래스에 여러 Bloc을 추가하여 전체 클래스에서 사용할 수 있습니다. 또한이 리포지토리를 배치할 위치에는 클래스가 있어야합니다. 우리의 경우에는 Scaffold입니다.\n\n그래서 MultiBlocProvider가 하는 일은 서버에서 데이터를 이동시키고 이를 만들어서 데이터와 상태를 모든 하위 요소에서 사용할 수 있게하는 것입니다.\n\nblocBody 내부에서 BlocProvider를 볼 수 있습니다. Getx에 익숙하다면 Get.put와 비슷합니다. BlocProvider 내부에서는 리포지토리와 함께 bloc 즉 UserBloc을 주입합니다. 위에서 이미 bloc을 주입했으므로 blocBody 내에서 이벤트에 액세스 할 수 있습니다.\n\n리포지토리와 함께 bloc을 주입 한 후에는 이벤트 즉 LoadUserEvent를 추가하고 이를 사용하여 UserBloc에서 UserLoadingState를 트리거하는 캐스캐이딩 연산자를 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 빌더 내부의 상태를 확인할 수 있습니다. 세 가지 상태가 있으므로 각각을 확인하여 다른 작업을 수행하고 다른 UI를 반환합니다.\n\n다음과 같이 확인할 수 있습니다.\n\n- `UserLoadingState`일 때는 데이터를 불러오고 있다는 의미로 CircularProgressIndicator를 표시합니다.\n- `UserLoadedState`일 때는 데이터 목록을 반환합니다.\n- `UserErrorState`일 때는 오류 메시지를 반환합니다.\n\n이제 애플리케이션을 실행하면 bloc 라이브러리를 사용하여 데이터가 검색될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n단점을 확인하려면 잘못된 종단점을 만들어 보실 수 있습니다.\n\n# 결론\n\n이 글에서 Bloc 및 Bloc 작업 메커니즘에 대해 설명했습니다. 필요에 맞게 코드를 조정하여 사용해 보세요. 새 페이지를 만들어 보는 것도 좋은 방법입니다. Bloc 아키텍처는 대규모 프로젝트에 매우 유용할 수 있습니다.\n\n이 블로그 게시물이 앞으로의 프로젝트에서 bloc 라이브러리와 아키텍처를 사용하는 데 충분한 중요한 정보를 제공해 줄 것을 바랍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n❤ ❤ 이 글 읽어주셔서 감사합니다 ❤ ❤\n\n만약 이 글을 좋아하셨다면 👏 두 번 치세요.\n\n또한, 업데이트되는 흥미로운 글과 프로젝트를 확인하려면 팔로우하세요.\n\n무엇인가 잘못된 점이 있다면? 댓글로 알려주세요. 개선해나가겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 함께 연결해요\n\n우리 친구가 되어요. 페이스북, 링크드인, 깃허브, 유튜브, BuyMeACoffee, 그리고 인스타그램에서 찾아요.\n\n방문하기: Flutter Junction\n\n기여하기: BuyMeACoffee\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 링크에서 전체 코드를 확인하세요:","ogImage":{"url":"/assets/img/2024-06-21-FetchAPIWithBloCinFlutter_0.png"},"coverImage":"/assets/img/2024-06-21-FetchAPIWithBloCinFlutter_0.png","tag":["Tech"],"readingTime":10},{"title":"플러터에서 네이티브 코드와의 양방향 통신을 위한 메소드 채널 사용 방법","description":"","date":"2024-06-21 22:37","slug":"2024-06-21-MethodChannelinFlutterBridgingNativeCodeandFlutterwithTwo-WayCommunication","content":"\n\n플러터의 메소드 채널은 플러터와 플랫폼별 코드 간에 원활한 통신을 제공하는 강력한 메커니즘을 제공합니다. 이 블로그 포스트에서는 플러터에서 메소드 채널을 설정하고 네이티브 MainActivity.kt(Android) 및 AppDelegate.swift(iOS) 코드에서 데이터를 플러터 애플리케이션으로 반환하는 과정을 살펴보겠습니다. 함께 알아보겠습니다!\n\n플러터에서 메소드 채널 설정하기: 먼저, 플러터 프로젝트에 메소드 채널을 설정해 봅시다.\n\n- 의존성 추가: 플러터 프로젝트의 pubspec.yaml 파일에 flutter/services 패키지를 의존성으로 추가하세요:\n\n```js\ndependencies:\n  flutter:\n    sdk: flutter\n  flutter/services:\n    ^2.0.0\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Method Channel 정의하기: 플러터 Dart 코드에서 Method Channel을 정의하세요:\n\n```js\nimport 'package:flutter/services.dart';\n\n// MethodChannel의 인스턴스 생성\nfinal MethodChannel platformChannel = MethodChannel('your_channel_name');\n```\n\nAndroid에서 Method Channel 통신 구현하기: 이제 Android 플랫폼에서 Method Channel 통신을 구현해 봅시다.\n\n- MainActivity.kt에서 메소드 호출 수신하기: MainActivity.kt 파일에서 onMethodCall 메소드를 오버라이드하여 Flutter로부터의 메소드 호출을 처리하고 데이터를 반환하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\nimport io.flutter.embedding.android.FlutterActivity\nimport io.flutter.embedding.engine.FlutterEngine\nimport io.flutter.plugin.common.MethodChannel\n\nclass MainActivity : FlutterActivity() {\n    private val CHANNEL = \"your_channel_name\"\n\n    override fun configureFlutterEngine(flutterEngine: FlutterEngine) {\n        super.configureFlutterEngine(flutterEngine)\n\n        // Set up the MethodChannel with the same name as defined in Dart\n        MethodChannel(flutterEngine.dartExecutor.binaryMessenger, CHANNEL).setMethodCallHandler { call, result -\u003e\n            if (call.method == \"getDataFromNative\") {\n                // Perform platform-specific operations and obtain the result\n                val data = getDataFromNative()\n\n                // Send the result back to Flutter\n                result.success(data)\n            } else {\n                result.notImplemented()\n            }\n        }\n    }\n\n    private fun getDataFromNative(): String {\n        // Perform platform-specific operations to fetch the data\n        return \"Data from Native\"\n    }\n}\n```\n\niOS에서 Method Channel 통신 구현하기: 이제 iOS 플랫폼에서 메서드 채널 통신을 구현해봅시다.\n\n- AppDelegate.swift에서 메서드 호출 받기: AppDelegate.swift 파일에 아래 코드를 추가하여 Flutter에서의 메서드 호출을 처리하고 데이터를 반환합니다:\n\n```swift\nimport UIKit\nimport Flutter\n\n@UIApplicationMain\n@objc class AppDelegate: FlutterAppDelegate {\n    private let CHANNEL = \"your_channel_name\"\n\n    override func application(\n        _ application: UIApplication,\n        didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?\n    ) -\u003e Bool {\n        // Set up the MethodChannel with the same name as defined in Dart\n        if let flutterViewController = window?.rootViewController as? FlutterViewController {\n            let methodChannel = FlutterMethodChannel(name: CHANNEL, binaryMessenger: flutterViewController.binaryMessenger)\n            methodChannel.setMethodCallHandler { [weak self] (call: FlutterMethodCall, result: FlutterResult) in\n                if call.method == \"getDataFromNative\" {\n                    // Perform platform-specific operations and obtain the result\n                    let data = self?.getDataFromNative()\n\n                    // Send the result back to Flutter\n                    result(data)\n                } else {\n                    result(FlutterMethodNotImplemented)\n                }\n            }\n        }\n\n        return super.application(application, didFinishLaunchingWithOptions: launchOptions)\n    }\n\n    private func getDataFromNative() -\u003e String {\n        // Perform platform-specific operations to fetch the data\n        return \"Data from Native\"\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플러터에서 네이티브로 데이터 전달 및 결과 반환하기: 이제 플러터에서 네이티브에 데이터를 전달하고 결과를 다시 플러터에서 받는 방법을 살펴봅시다.\n\n- 플러터에서 메소드 호출: 플러터 Dart 코드에서 플랫폼별 코드에서 메소드를 호출하고 결과를 처리하세요.\n\n```js\nvoid fetchDataFromNative() async {\n  try {\n    final String result = await platformChannel.invokeMethod('getDataFromNative');\n    print('Result from Native: $result');\n  } on PlatformException catch (e) {\n    print('Error: ${e.message}');\n  }\n}\n```\n\n결론: 축하합니다! 이제 플러터에서 메서드 채널을 성공적으로 설정했습니다. 이를 통해 플러터와 플랫폼별 코드 간의 양방향 통신이 가능해졌습니다. 이 블로그 포스트에서 안내된 단계와 코드 예제를 따라 하시면, 네이티브 기능을 쉽게 통합하고 네이티브 측에서 플러터 응용 프로그램으로 데이터를 반환할 수 있습니다. 실험하고 탐색하며, 메서드 채널의 강력한 기능을 활용하여 플러터 프로젝트의 무한한 가능성을 발견하세요. 즐거운 코딩되세요!","ogImage":{"url":"/assets/img/2024-06-21-MethodChannelinFlutterBridgingNativeCodeandFlutterwithTwo-WayCommunication_0.png"},"coverImage":"/assets/img/2024-06-21-MethodChannelinFlutterBridgingNativeCodeandFlutterwithTwo-WayCommunication_0.png","tag":["Tech"],"readingTime":5},{"title":"Flutter에서 백그라운드 서비스와 포어그라운드 서비스 사용 방법","description":"","date":"2024-06-21 22:36","slug":"2024-06-21-BackgroundandForegroundservicesinFlutter","content":"\n\n\n![그림](/assets/img/2024-06-21-BackgroundandForegroundservicesinFlutter_0.png)\n\n플러터의 백그라운드 및 포그라운드 서비스를 사용하면 앱이 활발히 실행되거나 활성화되어 있지 않을 때에도 백그라운드에서 작업을 수행할 수 있습니다. 이는 음악 재생, 인터넷에서 데이터 가져오기, 또는 사용자 경험을 방해하지 않고 장기간 실행되는 계산과 같은 작업을 포함합니다.\n\n패키지 추가: Flutter Background Service 문서 읽기를 클릭\n\n```js\n  flutter_background_service: 5.0.2\n  flutter_background_service_android: 6.1.0\n  flutter_background_service_ios: ^5.0.0\n``` \n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n매니페스트에 다음 항목 추가해주세요.\n\n```js\n    \u003cuses-permission android:name=\"android.permission.FOREGROUND_SERVICE\"/\u003e\n    \u003cuses-permission android:name=\"android.permission.FOREGROUND_SERVICE_LOCATION\"/\u003e\n    \u003cuses-permission android:name=\"android.permission.FOREGROUND_SERVICE_DATA_SYNC\"/\u003e\n\n    \u003cuses-permission android:name=\"android.permission.RECEIVE_BOOT_COMPLETED\"/\u003e\n    \u003cuses-permission android:name=\"android.permission.WAKE_LOCK\"/\u003e\n```\n\n애플리케이션 태그 안에 다음을 추가해주세요.\n\n```js\n\u003cservice\n    android:name=\"id.flutter.flutter_background_service.BackgroundService\"\n    android:foregroundServiceType=\"location\"\n/\u003e\n\n\u003cservice\n    android:enabled=\"true\"\n    android:exported=\"true\"\n    android:name=\".BackgroundService\"\n    android:stopWithTask=\"false\"\n/\u003e\n\n\u003creceiver\n    android:name=\".WatchdogReceiver\"\n    android:enabled=\"true\"\n    android:exported=\"true\"\n/\u003e\n\n\u003creceiver\n    android:name=\".BootReceiver\"\n    android:enabled=\"true\"\n    android:exported=\"true\"\u003e\n    \u003cintent-filter\u003e\n        \u003caction android:name=\"android.intent.action.BOOT_COMPLETED\"/\u003e\n        \u003caction android:name=\"android.intent.action.QUICKBOOT_POWERON\"/\u003e\n    \u003c/intent-filter\u003e\n\u003c/receiver\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음은 main.dart에서 사용하세요:\n\n```js\nFuture\u003cvoid\u003e main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n  await initializeService();\n  runApp(const MyApp());\n}\n```\n\n```js\n/// Foreground 및 Background\nFuture\u003cvoid\u003e initializeService() async {\n  final service = FlutterBackgroundService();\n\n  await service.configure(\n    androidConfiguration: AndroidConfiguration(\n      onStart: onStart,\n      autoStart: false,\n      isForegroundMode: true,\n      // notificationChannelId: 'my_foreground',\n      // initialNotificationContent: 'running',\n      foregroundServiceNotificationId: 888,\n    ),\n    iosConfiguration: IosConfiguration(\n      autoStart: true,\n      onForeground: onStart,\n      onBackground: onIosBackground,\n    ),\n  );\n}\n```\n\nIOS용:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\n@pragma('vm:entry-point')\nFuture\u003cbool\u003e onIosBackground(ServiceInstance service) async {\n  WidgetsFlutterBinding.ensureInitialized();\n  DartPluginRegistrant.ensureInitialized();\n  return true;\n}\n```\n\nAndroid용:\n\n```dart\n@pragma('vm:entry-point')\nvoid onStart(ServiceInstance service) async {\n  DartPluginRegistrant.ensureInitialized();\n  if (service is AndroidServiceInstance) {\n    service.on('setAsForeground').listen((event) {\n      service.setAsForegroundService();\n    });\n    service.on('setAsBackground').listen((event) {\n      service.setAsBackgroundService();\n    });\n  }\n  service.on('stopService').listen((event) {\n    service.stopSelf();\n  });\n\n  final FlutterLocalNotificationsPlugin flutterLocalNotificationsPlugin =\n      FlutterLocalNotificationsPlugin();\n\n  // // bring to foreground\n  Timer.periodic(const Duration(seconds: 1), (timer) async {\n    if (service is AndroidServiceInstance) {\n      if (await service.isForegroundService()) {\n        flutterLocalNotificationsPlugin.show(\n          0, 'This is foreground', '${DateTime.now()}',\n          const NotificationDetails(\n            android: AndroidNotificationDetails(\n              \"notificationChannelId\",\n              'MY FOREGROUND SERVICE',\n              icon: 'ic_bg_service_small',\n              ongoing: true,\n            ),\n          ),\n        );\n      }\n    }\n  });\n}\n```\n\n이 메서드는 어디서든 사용할 수 있습니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\nvoid backgroundService()async{\r\n  final service = FlutterBackgroundService();\r\n  var isRunning = await service.isRunning();\r\n  if (isRunning) {\r\n    Timer.periodic(const Duration(seconds: 1), (timer) async {\r\n      if (mounted) {\r\n        setState(() {\r\n          debugPrint(\"runningSanjay\");\r\n          CustomLoader.message(\"runningSanjay\");\r\n        });\r\n      }\r\n    });\r\n  } else {\r\n    service.startService();\r\n  }\r\n  setState(() {});\r\n}\r\n```\r\n\r\n전체 코드:\r\n\r\n```js\r\nimport 'dart:async';\r\nimport 'dart:convert';\r\nimport 'dart:io';\r\nimport 'dart:ui';\r\nimport 'package:flutter_background_service/flutter_background_service.dart';\r\nimport 'package:flutter_background_service_android/flutter_background_service_android.dart';\r\n\r\nFuture\u003cvoid\u003e main() async {\r\n  WidgetsFlutterBinding.ensureInitialized();\r\n  await initializeService(); \r\n  runApp(const MyApp());\r\n}\r\n\r\n/// Foreground and Background\r\nFuture\u003cvoid\u003e initializeService() async {\r\n  final service = FlutterBackgroundService();\r\n  await service.configure(\r\n    androidConfiguration: AndroidConfiguration(\r\n      onStart: onStart,\r\n      autoStart: false,\r\n      isForegroundMode: true,\r\n      // notificationChannelId: 'my_foreground',\r\n      // initialNotificationContent: 'running',\r\n      foregroundServiceNotificationId: 888,\r\n    ),\r\n    iosConfiguration: IosConfiguration(\r\n      autoStart: true,\r\n      onForeground: onStart,\r\n      onBackground: onIosBackground,\r\n    ),\r\n  );\r\n}\r\n\r\n@pragma('vm:entry-point')\r\nFuture\u003cbool\u003e onIosBackground(ServiceInstance service) async {\r\n  WidgetsFlutterBinding.ensureInitialized();\r\n  DartPluginRegistrant.ensureInitialized();\r\n  return true;\r\n}\r\n\r\n@pragma('vm:entry-point')\r\nvoid onStart(ServiceInstance service) async {\r\n  DartPluginRegistrant.ensureInitialized();\r\n  if (service is AndroidServiceInstance) {\r\n    service.on('setAsForeground').listen((event) {\r\n      service.setAsForegroundService();\r\n    });\r\n    service.on('setAsBackground').listen((event) {\r\n      service.setAsBackgroundService();\r\n    });\r\n  }\r\n  service.on('stopService').listen((event) {\r\n    service.stopSelf();\r\n  });\r\n\r\n  final FlutterLocalNotificationsPlugin flutterLocalNotificationsPlugin = \r\n  FlutterLocalNotificationsPlugin();\r\n  // bring to foreground\r\n  Timer.periodic(const Duration(seconds: 1), (timer) async {\r\n    if (service is AndroidServiceInstance) {\r\n      if (await service.isForegroundService()) {\r\n        CustomLoader.message(\"foreground\");\r\n        flutterLocalNotificationsPlugin.show(\r\n          0, 'COOL SERVICE', 'Awesome ${DateTime.now()}',\r\n          const NotificationDetails(\r\n            android: AndroidNotificationDetails(\r\n              \"notificationChannelId\",\r\n              'MY FOREGROUND SERVICE',\r\n              icon: 'ic_bg_service_small',\r\n              ongoing: true,\r\n            ),\r\n          ),\r\n        );\r\n      }\r\n    }\r\n  });\r\n}\r\n\r\nclass MyApp extends StatefulWidget {\r\n  const MyApp({Key key}) : super(key: key);\r\n  @override\r\n  State\u003cMyApp\u003e createState() =\u003e _MyAppState();\r\n}\r\n\r\nclass _MyAppState extends State\u003cMyApp\u003e{\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return MaterialApp(\r\n      debugShowCheckedModeBanner: false,\r\n      theme: ThemeData(\r\n          scaffoldBackgroundColor: Colors.white,\r\n          inputDecorationTheme: const InputDecorationTheme(\r\n            focusedBorder: UnderlineInputBorder(\r\n                borderSide: BorderSide(color: Colors.blue)\r\n            ),\r\n          )),\r\n      home:  Container(\r\n        color: Colors.white,\r\n        child:  Center(\r\n            child: Text(\"This is foreground service app\"),\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n\u003cimg src=\"/assets/img/2024-06-21-BackgroundandForegroundservicesinFlutter_1.png\" /\u003e\r\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기사를 즐겁게 읽으셨기를 바랍니다! 제공된 정보를 감사히 여기신다면 'Buy Me A Coffee'로 저를 지원할 수 있습니다! 여러분의 제스처에 감사드립니다!","ogImage":{"url":"/assets/img/2024-06-21-BackgroundandForegroundservicesinFlutter_0.png"},"coverImage":"/assets/img/2024-06-21-BackgroundandForegroundservicesinFlutter_0.png","tag":["Tech"],"readingTime":8},{"title":"Flutter로 작성된 모바일 앱인지 확인하는 방법","description":"","date":"2024-06-21 22:34","slug":"2024-06-21-HowtoDetermineifaMobileAppisWritteninFlutter","content":"\n\n안녕하세요, Flutter 팬 여러분들! 오늘은 모바일 앱이 Flutter로 작성되었는지 확인하는 방법에 대해 이야기해보겠습니다. 이 지식은 경쟁 조사를 위해 개발자와 매니저들에게 유용하며, 자신이 좋아하는 앱의 내부를 더 알고 싶어하는 기술 애호가들에게도 도움이 될 수 있습니다. 그래서, 더 이상 말뿐인 소리는 그만하고 시작해봅시다.\n\n# 부드러운 인터페이스와 복잡한 애니메이션\n\n- 복잡성: 1\n- 정확성: 2\n\nFlutter는 부드럽고 아름다운 인터페이스를 만들어내는 능력으로 유명합니다. 만약 예상치 못한 아름다움과 부드러움을 발견한다면, 그것이 Flutter 앱일 수 있습니다. 그러나, 좋은 디자인과 애니메이션 부드러움은 다른 프레임워크로도 구현할 수 있기 때문에 이것은 단지 많은 조직 중 하나에 불과합니다. 반면, 앱이 끊기는 애니메이션과 오랜 응답 시간을 보인다면, 그 또한 Flutter 앱일 수 있습니다. 대부분, 개발자들이 이 앱에 큰 노력을 기울이지 않았거나, 클라이언트가 비용을 줄이기로 결정했을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 두 손가락 스크롤링 속도가 두 배 빨라졌어요\n\n- 복잡도: 1\n- 정확도: 3\n\nFlutter 앱에서는 네이티브 앱과 비교했을 때 두 손가락으로 스크롤링 하는 것이 두 배 빨라집니다. 게다가, 세 손가락 스크롤링은 세 배 빠릅니다. 그러나 Flutter 개발자들은 항상 개선해 나가는 중이며, 최근에 이 \"버그\"를 수정했기 때문에 이 방법은 이전만큼 신뢰할 수 없을 수도 있습니다.\n\n# 공식 Flutter 페이지에 피처된 앱들\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 복잡도: 1\n- 정확성: 5\n\n가장 신뢰할 수 있는 방법은 공식 플러터 페이지를 확인하는 것입니다. 그곳에는 플러터로 개발된 앱들의 모음을 볼 수 있습니다.\n\n![이미지](/assets/img/2024-06-21-HowtoDetermineifaMobileAppisWritteninFlutter_0.png)\n\n# 온라인 서비스 플러터헌트\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 복잡도: 1\n- 정확도: 4\n\nFlutterHunt은 Flutter로 개발된 앱에 대한 정보를 수집하는 온라인 데이터베이스입니다. 그런데 이 서비스의 제작자와 채팅할 수도 있어요.\n\n![이미지](/assets/img/2024-06-21-HowtoDetermineifaMobileAppisWritteninFlutter_1.png)\n\n# 플러터 상어 앱\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 복잡성: 1\n- 정확성: 4\n\n네, 다른 앱이 플러터를 사용하는지 여부를 결정하는 데 전용 앱이 있습니다! 기기에 설치된 앱을 분석하고 해당 앱이 플러터로 개발되었는지 식별합니다. 신기하게도, 플러터 Shark는 플러터로 작성되었습니까?\n\n![이미지](/assets/img/2024-06-21-HowtoDetermineifaMobileAppisWritteninFlutter_2.png)\n\n# 개발 속도 및 통합 코드베이스\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 복잡도: 3\n- 정확성: 2\n\n플러터를 사용하면 Android와 iOS용 앱을 생성하는 데 동일한 코드를 사용할 수 있어 개발 프로세스를 크게 가속화할 수 있습니다. 한 회사가 새로운 기능을 두 플랫폼에서 동시에 빠르게 출시한다면, 그들은 플러터를 사용하고 있을 수도 있습니다.\n\n# 개발자 메뉴에서 \"레이아웃 경계 표시\" 활성화하기\n\n- 복잡도: 4\n- 정확성: 4\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 방법은 강력한 중급 개발자를 대상으로 합니다. 안드로이드 개발자 설정에서 \"레이아웃 경계 표시\" 옵션을 활성화하여 인터페이스 요소의 경계를 볼 수 있습니다. 플러터 앱은 자체 렌더링 메커니즘이 있기 때문에 네이티브 앱과 달리 인터페이스 요소에는 경계가 없습니다.\n\n## 안드로이드 개발자 메뉴에서 \"레이아웃 경계 표시\"를 활성화하는 방법:\n\n단계 1: 개발자 모드 활성화\n\n- 안드로이드 기기의 설정을 엽니다.\n- 아래로 내려 \"휴대폰 정보\"를 찾습니다.\n- 빌드 번호를 찾습니다 (소프트웨어 정보 또는 휴대폰 정보 섹션에 있을 수 있습니다).\n- 빌드 번호를 7번 탭합니다. \"개발자가 되고 있습니다\"라는 메시지가 표시됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n**단계 2: 레이아웃 바운드 보기 활성화**\n\n- 메인 설정 메뉴로 돌아갑니다.\n- 개발자 모드를 활성화한 후 나타난 \"개발자용\" 또는 \"개발자 옵션\" 항목으로 스크롤합니다.\n- \"개발자 옵션\"을 선택합니다.\n- \"디버깅\" 또는 \"시각화\" 섹션으로 스크롤합니다.\n- \"레이아웃 바운드 보기\" 또는 \"레이아웃 테두리 표시\" 옵션을 찾아 활성화합니다.\n\n# 디버깅 정보 및 개발자 도구\n\n- 복잡성: 5\n- 정확도: 5\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n진짜 고급 사용자를 위한 방법을 찾아왔어요. Flutter 앱은 작동 방식과 시스템과의 상호 작용에 따라 구별될 수 있는 특정 특성이 있어요. 디버깅 중에 접근할 수 있어요. Android Studio와 Visual Studio Code를 사용하면 애플리케이션의 라이프사이클, 시스템과의 상호 작용 및 기타 기술적 측면을 관찰할 수 있어요.\n\n## 다음은 방법이에요:\n\n- 기기를 컴퓨터에 연결하세요. 기기의 개발자 모드가 활성화되어 있고 USB 디버깅이 허용되어 있는지 확인하세요.\n- 즐겨 사용하는 코드 편집기를 열어주세요. Flutter와 Dart 플러그인이 설치된 Android Studio 또는 Visual Studio Code를 시작하세요.\n- ADB (Android Debug Bridge)를 시작하세요. 터미널이나 명령 프롬프트를 열고 adb devices 명령을 입력하여 기기가 연결되어 있는지 확인하세요.\n- 애플리케이션을 기기에서 시작하세요. 기기에서 원하는 Flutter 앱을 열어주세요.\n- Android Studio에서 Logcat을 엽니다. Android Studio에서는 화면 하단의 \"Logcat\" 탭을 선택하세요. Visual Studio Code에서는 통합 터미널을 사용하여 해당 명령을 실행하여 로그를 볼 수 있어요.\n- 로그 출력을 애플리케이션 식별자로 필터링하세요.\n- Flutter 및 Dart VM에 대한 언급을 찾아보세요. Flutter 앱을 시작하고 실행할 때, 로그에 Dart VM 또는 Flutter Engine과 관련된 메시지가 표시될 수 있어요.\n- 이 방법은 Flutter를 사용하여 개발된 앱을 확인하는 가장 신뢰할 수 있는 방법 중 하나에요.\n\n# APK 파일 분석\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 복잡성: 666\n- 정확도: 5\n\n이전 방법들이 만족스럽지 않다면, APK를 언패킹하여 애플리케이션을 심층적으로 탐색해볼 수 있습니다.\n\n## 단계별로:\n\n- 애플리케이션의 APK를 다운로드합니다. 다양한 온라인 서비스나 도구를 사용하여 Google Play Store에서 APK를 직접 다운로드할 수 있습니다.\n- APK를 \"언팩\"할 도구를 사용합니다. 이 작업에 대한 인기 있는 도구 중 하나는 APKTool이며, APK를 디컴파일하고 내용을 확인할 수 있는 다른 유사한 도구도 사용할 수 있습니다.\n- libflutter.so 및 kernel_blob.bin 파일을 찾습니다. 디컴파일된 APK를 열고 ./lib/ 및 ./assets/flutter_assets/ 디렉토리를 찾아봅니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 왜 이것이 동작하는지:\n\n- libflutter.so는 안드로이드에서 Dart 코드를 로드하고 실행하는 데 사용되는 Flutter 전용 라이브러리입니다.\n- kernel_blob.bin은 애플리케이션의 컴파일된 Dart 코드를 포함하고 있습니다.\n\n이 방법은 좀 더 기술적인 지식이 필요하며, 진정한 엔지니어를 위한 것입니다.\n\n이 방법은 Alexandra Kovaleva가 제안했으며, 그녀에게 특별한 감사의 말씀을 전합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n그게 다야! 이 방법들이 플러터의 세계에 대해 더 많이 알게 해주고 당신에게 자극을 주어 여러분만의 프로젝트를 만들게 하는 데 도움이 되길 바랍니다.\n\n흥미롭고 유용하다면, 링크드인과 X(트위터)에서 저와 함께하세요.","ogImage":{"url":"/assets/img/2024-06-21-HowtoDetermineifaMobileAppisWritteninFlutter_0.png"},"coverImage":"/assets/img/2024-06-21-HowtoDetermineifaMobileAppisWritteninFlutter_0.png","tag":["Tech"],"readingTime":5},{"title":"Flutter로 코드 생성하기  source_gen과 build_runner 사용 방법","description":"","date":"2024-06-21 22:30","slug":"2024-06-21-CodeGenerationusingFluttersource_genbuild_runner","content":"\n\n![2024-06-21-CodeGenerationusingFluttersource_genbuild_runner_0.png](/assets/img/2024-06-21-CodeGenerationusingFluttersource_genbuild_runner_0.png)\n\n최근에는 전문적인 플러터 개발자로서 매일 개발 프로세스 중에 시간이 오래 걸리고 실수할 가능성이 있는 일상적인 반복 작업을 더 나은 방법과 안전한 방법으로 수행하고 싶었을 것입니다. 그러한 프로세스는 코드 생성입니다. 진보를 이루는 데 핵심은 효율성을 극대화하는 데 있습니다. 반복적인 작업은 지루하고 단조로운 성질 때문에 보편적으로 싫어하는데, 이러한 활동에서 사람들은 주목할 만큼 비효율적이며 종종 오류를 범합니다.\n\n코드 생성은 특정 입력 데이터나 규칙을 기반으로 자동으로 코드를 생성하는 기술입니다. Flutter에서 코드 생성은 JSON 데이터, 데이터베이스 및 웹 서비스와 같은 다양한 목적으로 사용됩니다. 코드 생성은 반복적인 작업을 자동화하고 필요한 수동 코딩량을 줄임으로써 코드 작성과 유지를 쉽게 할 수 있습니다.\n\n코드 생성기를 사용하는 많은 패키지들이 있습니다. json_serializable과 같은 패키지의 예시를 살펴보겠습니다. 이 패키지는 우리에게 fromJson, toJson과 같은 메서드를 생성하는 데 사용되는 일련의 주석을 제공하여, 해당 함수를 생성하려는 행에 주석을 넣기만 하면 이러한 메서드를 자동으로 생성합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예시:\n\n\n| First Header  | Second Header |\n| ------------- | ------------- |\n| Content Cell  | Content Cell  |\n| Content Cell  | Content Cell  |\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 글에서는 사용자 정의 주석 및 생성기를 생성하여 주석이 달린 클래스에 대해 fromJson, toJson 및 copyWith 메서드를 생성하는 방법을 배우겠습니다.\n\n우리가 자체 코드 생성기를 만들기 위해 필요한 패키지는 무엇인가요?\n\n- source_gen | Dart 패키지 (pub.dev)\n- build_runner | Dart 패키지 (pub.dev)\n\n## source_gen\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAPI는 낮은 수준의 빌드 또는 분석기 패키지와 상호 작용 없이 코드를 생성하는 데 도움이 되는 다양한 유틸리티를 제공합니다. 이는 여러분의 삶을 훨씬 쉽게 만들어 줄 것입니다.\n\nsource_gen 패키지는 build 패키지의 확장판입니다. Dart 소스 코드 생성을 더 쉽게 만드는 일련의 유틸리티가 포함되어 있습니다.\n\n## build_runner\n\n이 패키지를 사용하면 생성기를 실행할 수 있습니다. 이는 개발 단계에서만 사용되는 dev_dependency 영역에 있을 것이므로 개발 단계에서만 사용할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 다음 명령어를 실행하여 코드를 생성할 수 있어요:\n\n```dart\ndart run build_runner `command`\n```\n\n사용할 수 있는 명령어는 다음과 같아요:\n\n- build: 하나의 빌드를 실행하고 종료합니다.\n- watch: 파일 시스템을 감시하는 지속적인 빌드 서버를 실행하며 필요 시 다시 빌드합니다.\n- serve: watch와 동일하지만 개발 서버도 실행합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 예시\n\nGitHub에서 스타터 프로젝트를 다운로드하거나 수동으로 생성할 수 있습니다.\n\n스타터 프로젝트에는 세 개의 프로젝트가 포함되어 있습니다:\n\n- 예시: 이는 플러터 애플리케이션입니다. 이 애플리케이션은 생성기 코드를 테스트하는 데 사용됩니다.\n- 어노테이션: 이는 플러터 패키지입니다. 이는 어노테이션을 포함하고 있으며, 생성기는 이를 사용하여 처리할 클래스를 인식합니다.\n- 생성기: 이는 플러터 패키지입니다. 이 패키지에는 우리의 어노테이션에 의해 주석 처리된 코드를 방문하고 이를 위해 코드를 생성하는 코드 생성기가 포함되어 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n시작해보세요. Custom Gen이라는 디렉토리를 만들고 터미널에서 열어서 다음을 입력하세요:\n\ncode .\n\n그럼 VS Code가 열릴 거에요.\n\n## 예제 프로젝트\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nCtrl + Shift + p를 눌러 Flutter: New Project를 선택한 다음 Application을 선택하고 example로 이름을 지어주세요.\n\n## annotations 프로젝트\n\n터미널에서 Custom Gen 폴더를 열기 위해 이전과 같은 단계를 따라주세요.\n\nCtrl + Shift + p를 눌러 Flutter: New Project를 선택한 다음 Package를 선택하고 annotation으로 이름을 지어주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## generators 프로젝트\n\n터미널에서 이미지와 같이 'Custom Gen' 폴더를 열기 위해 이전과 같은 단계를 수행합니다.\n\nCtr + Shift + p를 눌러 Flutter: New Project를 선택하고 Package를 선택한 후 generator라고 이름을 지정하세요.\n\n이제 이미지와 같이 세 개의 프로젝트가 생성됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-21-CodeGenerationusingFluttersource_genbuild_runner_1.png\" /\u003e\n\n# 주석 프로젝트\n\n주석이 무엇인가요?\n\nFlutter에서 주석은 Dart 코드에 포함하여 도구나 라이브러리에 추가 정보를 전달하는 특별한 표식이거나 지시문입니다. 주석은 build_runner 및 코드 생성기와 같은 도구에 대한 힌트로 작용하여 주석이 달린 코드와 관련된 특정 작업이나 동작을 나타냅니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nannotations/lib에 src 폴더를 만들어서 생성자에 의해 사용될 주석 파일을 포함시킬 것입니다.\n\nannotations/lib/annotations.dart와 annotations/test/annotations_test.dart의 예제 코드를 제거할 것입니다.\n\nsrc 폴더에 acustom_annotation.dart 파일을 생성하여 주석을 작성할 것입니다. 이 주석은 CustomAnnotation으로 명명되었습니다.\n\n```dart\n// 우리의 주석\nclass CustomAnnotation {\n  const CustomAnnotation();\n}\n\n// 이 변수는 코드를 생성하기 위한 주석으로 사용될 것입니다.\nconst customAnnotation = CustomAnnotation();\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nannotations.dart 파일에서 CustomAnnotation을 export할 것입니다:\n\n```js\nlibrary annotations;\n\nexport 'src/custom_annotation.dart';\n```\n\n다른 곳에서 이 주석 라이브러리를 사용하려면 각 파일을 개별적으로 호출하는 대신 annotations.dart를 import하기만 하면 됩니다.\n\n좋아요! 이제 당신은 당신의 어노테이션을 만들었습니다. 축하해요. 🎉🎉\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 제너레이터 프로젝트\n\n먼저 generators/generators.dart 파일과 generators/test/generators_test.dart 파일의 초기 코드를 제거하세요.\n\n그런 다음 generators/pubspec.yaml 파일에 몇 가지 종속성을 추가해야 합니다:\n\n```js\ndependencies:\n  flutter:\n    sdk: flutter\n  \n  build:\n  source_gen:\n\n  # Our annotation\n  annotations:\n    path: ../annotations/\n\ndev_dependencies:\n  flutter_test:\n    sdk: flutter\n\n  build_runner:\n  flutter_lints: ^2.0.0\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n태그를 Markdown 형식으로 변경하고 다음 명령을 실행하세요: flutter pub get.\n\n- build: 이 패키지는 변수, 메소드 및 생성자와 같은 다양한 클래스 구성요소에 액세스하여 클래스를 검사하는 것을 가능하게 합니다.\n- source_gen: analyzer 또는 build와 같은 하위 수준 패키지 위에 있는 API입니다. source_gen을 사용하여 소스 코드를 생성할 필요는 없습니다. 또한 제너레이터에 유용할 수 있는 일련의 라이브러리 API를 노출합니다.\n- annotations: 이전에 작성된 annotation입니다.\n- build_runner: 주석이 달린 클래스에서 코드를 생성합니다.\n\nflutter pub get을 실행하는 중에 이와 같은 오류가 발생할 수 있습니다:\n\nPublishable packages can’t have ‘path’ dependencies.\nTry adding a publish_to: none entry to mark the package as not for publishing or remove the path dependency.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 작업은 필요합니다. 왜냐하면 패키지를 Dart Dev에 업로드할 계획이라면 경로가 올바르지 않을 수 있습니다. 따라서 pubspec.yaml에서 이 예제가 실제 업로드된 패키지가 아닌 것을 명시해야 합니다. 다음 코드를 pubspec.yaml에 추가해주세요:\n\n```js\nname: generator\ndescription: A new Flutter package project.\nversion: 0.0.1\nhomepage:\npublish_to: none # \u003c- 이 코드를 추가하여 이 패키지가 Dart Dev에 게시되지 않도록 설정\n```\n\n## build.yaml 구성하기\n\nbuild.yaml 파일은 build_runner에 의해 수행되는 코드 생성 프로세스의 설정과 구성을 지정하는 구성 파일입니다. 이 파일은 build_runner에 의해 호출되어 모든 생성기 구성을 읽기 전에 기능을 설정하며 Dart 빌드 시스템의 일부이며 Flutter 프로젝트에서 코드 생성 라이브러리를 사용할 때 생성기를 구성하는 용도로 사용됩니다. 생성된 파일의 확장자, 생성된 메서드, 생성기의 경로와 같은 설정을 지정하는 중요한 파일입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금, 제너레이터 패키지 루트에 build.yaml 파일을 만들어서 다음 코드를 입력해주세요:\n\n```js\ntargets:\n  $default:\n    builders:\n      generators|annotations: # generators|annotations: 주석이 달린 파일을 다룰 때 simple_generator 빌더를 사용한다는 것을 의미합니다.\n        enabled: true\n\nbuilders:\n  generators:\n    target: \":generators\" # 제너레이터 이름\n    import: \"package:generators/generators.dart\"\n    builder_factories: [\"generateJsonMethods\"] # 빌더 이름(BuilderOption)의 정의입니다.\n    build_extensions: { \".dart\": [\".g.dart\"] }\n    auto_apply: dependents\n    build_to: cache\n    applies_builders: [\"source_gen|combining_builder\"]\n```\n\n1- import: 제너레이터 경로를 결정합니다.\n\n2- builder_factories: 빌더 메서드의 이름을 나열합니다. 이 경우, \"generateJsonMethods\"라는 단일 팩토리를 포함하며 빌더를 반환합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3- build_extensions: 빌더의 입력 및 출력 파일 확장자를 정의합니다. 이는 빌더가 .dart 파일을 처리하고 .g.part '(.g.part) 파일을 생성함을 나타냅니다. 이는 build.yaml 파일의 auto_apply 키에 기반하여 파일의 가시성을 제어합니다.\n\n4- auto_apply: 특정 빌더가 빌드 프로세스 중 자동으로 적용되어야 하는 시점을 지정하는 데 사용됩니다.\n\nauto_apply 옵션에는 여러 가지 가능한 값이 있습니다:\n\n- none: 빌더가 자동으로 적용되지 않습니다. 빌더를 명시적으로 builders 섹션에 지정하거나 build_runner 명령을 --build-filter 옵션과 함께 사용해야 합니다.\n- dependents: 빌더가 build.yaml 파일을 포함하는 패키지에 의존하는 패키지에 자동으로 적용됩니다. 이는 다른 패키지가 귀하의 패키지에 의존하는 경우 해당 빌더가 해당 의존 패키지에도 적용됨을 의미합니다.\n- all_packages: 의존성 여부에 관계없이 모든 패키지에 빌더가 자동으로 적용됩니다. 이 옵션은 드물며, 모든 패키지에 빌더가 필요하지 않은 경우 빌드 시간이 증가할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n5- build_to: 코드 생성에서 생성된 파일이 배치되어야 하는 디렉토리를 지정합니다.\n\n다음은 build_to에 대한 일반적인 값들입니다:\n\n- source: 이는 생성된 파일이 소스 파일과 동일한 디렉토리에 배치됨을 의미합니다. 소스 파일이 lib/src에 있으면 생성된 파일도 lib/src에 배치됩니다.\n- cache: 이는 생성된 파일이 빌드 캐시 디렉토리에 배치됨을 의미합니다. 빌드 캐시는 빌드 성능을 향상시키기 위해 build_runner가 관리하는 디렉토리입니다.\n\n# 생성기 생성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 build.yaml 파일을 구성한 후, 코드 생성을 위한 모든 파일 및 구현체를 생성할 것입니다.\n\n이 단계에서는 방문자(visitor) 클래스를 만들 것입니다; 이는 생성된 코드를 위해 생성자, 필드, 함수 등 모든 클래스 요소에 액세스하는 데 도움을 줍니다.\n\n## 모델 방문자\n\nlib/src 에 model_visitor.dart 파일을 만든 후, 다음 import 문을 사용할 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```dart\nimport 'package:analyzer/dart/element/element.dart';\nimport 'package:analyzer/dart/element/visitor.dart';\n```\n\nThe first import comes from analyzer because both source_gen and build export it.\n\nCreate a ModelVisitor class and extend from SimpleElementVisitor:\n\n```dart\nclass ModelVisitor extends SimpleElementVisitor\u003cvoid\u003e{\n\n}\n```\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSimpleElementVisitor에는 클래스를 검사하는 데 도움이 되는 여러 메서드가 포함되어 있습니다:\n\n- visitFieldElement 메서드.\n- visitConstructorElement 메서드.\n- visitFunctionElement 메서드.\n\nSimpleElementVisitor 클래스로 이동하여 클래스를 검사하는 데 유용한 모든 메서드를 살펴볼 수 있지만, 우리의 경우 visitConstructorElement 메서드를 사용하여 클래스 이름을 가져오고 visitFunctionElement 메서드를 사용하여 클래스의 모든 필드를 가져올 것입니다.\n\nmodel_visitor.dart 파일의 전체 코드:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\nimport 'package:analyzer/dart/element/element.dart';\nimport 'package:analyzer/dart/element/visitor.dart';\n\n// 단계 1\nclass ModelVisitor extends SimpleElementVisitor\u003cvoid\u003e {\n// 단계 2\n  String className = '';\n  Map\u003cString, dynamic\u003e fields = {};\n\n// 단계 3\n  @override\n  void visitConstructorElement(ConstructorElement element) {\n    final String returnType = element.returnType.toString();\n// 단계 4\n    className = returnType.replaceAll(\"*\", \"\"); // ClassName* -\u003e ClassName\n  }\n\n// 단계 5\n  @override\n  void visitFieldElement(FieldElement element) {\n    /*\n    {\n      name: String,\n      price: double\n    }\n     */\n\n// 단계 6\n    String elementType = element.type.toString().replaceAll(\"*\", \"\");\n    fields[element.name] = elementType;\n\n  }\n}\n```\n\n단계 1: SimpleElementVisitor 클래스를 상속받은 ModelVisitor 클래스로 확장함으로써 클래스 필드, 생성자 및 함수에 대한 다양한 유용한 메서드에 액세스할 수 있습니다.\n\n단계 2: className 변수를 정의하여 클래스 이름을 저장하고, fields 변수를 정의하여 모든 클래스 필드를 저장합니다.\n\n단계 3: 이 오버라이드된 메서드는 클래스 생성자를 방문하고 element.returnType을 통해 클래스 이름을 검색할 수 있도록 합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n단계 4: element.returnType은 원소 유형 뒤에 '*'을 반환하므로 이를 제거합니다.\n\n단계 5: 이 방법은 클래스의 각 필드에 대해 호출되며, 필드 이름과 필드 유형에 모두 액세스할 수 있습니다.\n\n또한 더 많은 속성에 액세스할 수 있습니다.\n\n단계 6: element.type은 원소 유형 뒤에 '*'을 반환하므로 이를 제거합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 생성기\n\nlib/src에 json_generator.dart라는 파일을 생성하세요:\n\n```dart\nimport 'package:annotations/annotations.dart';\nimport 'package:source_gen/source_gen.dart';\n\nclass JsonGenerator extends GeneratorForAnnotation\u003cCustomAnnotation\u003e {\n  // 이곳에 코드를 생성하는 메서드를 작성하세요!\n}\n```\n\n이 파일은 생성기의 진입점을 나타냅니다. dart run build_runner build 명령을 실행한 후, build_runner은 먼저 build.yaml 파일을 확인합니다. 이후 예제 파일을 모두 스캔하고, 어노테이션이 존재하면 이 클래스가 인지하고, 상기 생성기 클래스의 재정의된 기능을 실행하도록 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\ngenerateForAnnotatedElement을 오버라이드할 거에요. 이 메서드는 element를 인자로 받아요. 이 경우에는 클래스가 될 거예요. 이 간단한 예시에서는 다른 매개변수가 필요하지 않아요. 이 메서드는 생성된 코드를 나타내는 String 타입을 반환할 거에요.\n\n```js\nclass JsonGenerator extends GeneratorForAnnotation\u003cCustomAnnotation\u003e {\n  @override\n  String generateForAnnotatedElement(\n    Element element, // 이 경우에는 클래스를 나타냅니다.\n    ConstantReader annotation,\n    BuildStep buildStep,\n  ) {\n  }\n}\n```\n\n이 클래스가 생성기의 진입점이므로 ModelVisitor 클래스를 활용하여 주석이 달린 클래스의 모든 필드와 생성자를 가져올 거에요.\n\n```js\nclass JsonGenerator extends GeneratorForAnnotation\u003cCustomAnnotation\u003e {\n  @override\n  String generateForAnnotatedElement(\n    Element element,\n    ConstantReader annotation,\n    BuildStep buildStep,\n  ) {\n    final ModelVisitor visitor = ModelVisitor();\n    // 클래스의 필드와 생성자를 방문한 후, visitor의 className과 fields 변수에 값이 들어갈 거에요.\n    element.visitChildren(visitor);\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n클래스 이름과 필드를 가져온 후에는, `fromJson`, `toJson`, 그리고 `copyWith` 메서드를 생성하는 코드를 작성해봅시다.\n\n## fromJson 메서드\n\n- 생성된 메서드 예시:\n\n```js\n// From Json Method\nProduct _$ProductFromJson(Map\u003cString, dynamic\u003e json) =\u003e Product(\n      name: json['name'],\n      price: json['price'],\n    );\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 위 예시를 생성하는 함수:\n\n```js\n// fromJSon 메소드를 생성하는 메서드\nString generateFromJsonMethod(ModelVisitor visitor) {\n  // 모델 방문자로부터 클래스 이름을 받아옴\n  String className = visitor.className;\n\n  // 생성된 클래스의 각 부분을 쓰기 위한 버퍼\n  final buffer = StringBuffer();\n\n  // --------------------fromJson 생성 코드 시작--------------------//\n  buffer.writeln('// From Json 메소드');\n  buffer.writeln(\n      '$className _\\$${className}FromJson(Map\u003cString, dynamic\u003e json) =\u003e ');\n  buffer.write('$className(');\n\n  for (int i = 0; i \u003c visitor.fields.length; i++) {\n    String fieldName = visitor.fields.keys.elementAt(i);\n    String mapValue = \"json['$fieldName']\";\n\n    buffer.writeln(\n      \"${visitor.fields.keys.elementAt(i)}: $mapValue,\",\n    );\n  }\n  buffer.writeln(');');\n  buffer.toString();\n  return buffer.toString();\n  // --------------------fromJson 생성 코드 종료--------------------//\n}\n```\n\n## toJson 메소드\n\n- 생성된 메소드 예시:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// JSON으로 변환하는 메소드\nMap\u003cString, dynamic\u003e _$ProductToJson(Product instance) =\u003e \u003cString, dynamic\u003e{\n      'name': instance.name,\n      'price': instance.price,\n    };\n```\n\n- 위 예시를 생성하는 함수:\n\n```js\n// fromJSon 메소드를 생성하는 메소드\nString generateToJsonMethod(ModelVisitor visitor) {\n  // 모델 비지터에서 클래스 이름 가져오기\n  String className = visitor.className;\n\n  // 생성된 클래스 각 부분을 작성할 버퍼\n  final buffer = StringBuffer();\n\n  // --------------------toJson 생성 코드 시작--------------------//\n  buffer.writeln('// JSON으로 변환하는 메소드');\n  buffer.writeln(\n      'Map\u003cString, dynamic\u003e _\\$${className}ToJson($className instance) =\u003e ');\n  buffer.write('\u003cString, dynamic\u003e{');\n  for (int i = 0; i \u003c visitor.fields.length; i++) {\n    String fieldName = visitor.fields.keys.elementAt(i);\n    buffer.writeln(\n      \"'$fieldName': instance.$fieldName,\",\n    );\n  }\n  buffer.writeln('};');\n  return buffer.toString();\n  // --------------------toJson 생성 코드 끝--------------------//\n}\n```\n\n## copyWith 메소드\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 생성된 메서드 예시:\n\n```js\n// Product 클래스에 'copyWith' 메서드를 제공하기 위한 확장\nextension $ProductExtension on Product {\n  Product copyWith({\n    String? name,\n    double? price,\n  }) {\n    return Product(\n      name: name ?? this.name,\n      price: price ?? this.price,\n    );\n  }\n```\n\n- 위 예제를 생성하는 함수:\n\n```js\n// fromJSon 메서드를 생성하는 함수\nString generateCopyWithMethod(ModelVisitor visitor) {\n  // 모델 방문자로부터 클래스 이름 가져오기\n  String className = visitor.className;\n\n  // 생성된 클래스 각 부분을 작성할 버퍼\n  final buffer = StringBuffer();\n\n  // --------------------copyWith 생성 코드 시작--------------------//\n  buffer.writeln(\n      \"// $className 클래스에 'copyWith' 메서드를 제공하기 위한 확장\");\n  buffer.writeln('extension \\$${className}Extension on $className {');\n  buffer.writeln('$className copyWith({');\n  for (int i = 0; i \u003c visitor.fields.length; i++) {\n    String dataType =\n        visitor.fields.values.elementAt(i).toString().replaceAll(\"?\", \"\");\n    String fieldName = visitor.fields.keys.elementAt(i);\n    buffer.writeln(\n      '$dataType? $fieldName,',\n    );\n  }\n  buffer.writeln('}) {');\n  buffer.writeln('return $className(');\n  for (int i = 0; i \u003c visitor.fields.length; i++) {\n    buffer.writeln(\n      \"${visitor.fields.keys.elementAt(i)}: ${visitor.fields.keys.elementAt(i)} ?? this.${visitor.fields.keys.elementAt(i)},\",\n    );\n  }\n  buffer.writeln(');');\n  buffer.writeln('}');\n  buffer.writeln('}');\n  buffer.toString();\n  return buffer.toString();\n  // --------------------copyWith 생성 코드 종료--------------------//\n}\n```  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\njson_generator.dart 파일의 전체 코드:\n\n```js\nimport 'package:analyzer/dart/element/element.dart';\nimport 'package:annotations/annotations.dart';\nimport 'package:build/build.dart';\nimport 'package:build/src/builder/build_step.dart';\nimport 'package:generators/src/model_visitor.dart';\nimport 'package:source_gen/source_gen.dart';\n\nclass JsonGenerator extends GeneratorForAnnotation\u003cCustomAnnotation\u003e {\n  @override\n  String generateForAnnotatedElement(\n    Element element,\n    ConstantReader annotation,\n    BuildStep buildStep,\n  ) {\n    final ModelVisitor visitor = ModelVisitor();\n    // 클래스 필드 및 생성자 방문\n    element.visitChildren(visitor);\n\n    // 생성된 클래스의 각 부분을 작성할 버퍼\n    final buffer = StringBuffer();\n\n    // fromJson\n    String generatedFromJSon = generateFromJsonMethod(visitor);\n    buffer.writeln(generatedFromJSon);\n\n    // toJson\n    String generatedToJSon = generateToJsonMethod(visitor);\n    buffer.writeln(generatedToJSon);\n\n    // copyWith\n    String generatedCopyWith = generateCopyWithMethod(visitor);\n    buffer.writeln(generatedCopyWith);\n\n    return buffer.toString();\n  }\n\n  // fromJSon 메서드 생성하는 메소드\n  String generateFromJsonMethod(ModelVisitor visitor) {\n    // 모델 방문자로부터 클래스 이름 가져오기\n    String className = visitor.className;\n\n    // 생성된 클래스의 각 부분을 작성할 버퍼\n    final buffer = StringBuffer();\n\n    // --------------------fromJson 생성 코드 시작--------------------//\n    buffer.writeln('// From Json Method');\n    buffer.writeln(\n        '$className _\\$${className}FromJson(Map\u003cString, dynamic\u003e json) =\u003e ');\n    buffer.write('$className(');\n\n    for (int i = 0; i \u003c visitor.fields.length; i++) {\n      String fieldName = visitor.fields.keys.elementAt(i);\n      String mapValue = \"json['$fieldName']\";\n\n      buffer.writeln(\n        \"${visitor.fields.keys.elementAt(i)}: $mapValue,\",\n      );\n    }\n    buffer.writeln(');');\n    buffer.toString();\n    return buffer.toString();\n    // --------------------fromJson 생성 코드 끝--------------------//\n  }\n\n  // toJson 메서드 생성하는 메소드\n  String generateToJsonMethod(ModelVisitor visitor) {\n    // 모델 방문자로부터 클래스 이름 가져오기\n    String className = visitor.className;\n\n    // 생성된 클래스의 각 부분을 작성할 버퍼\n    final buffer = StringBuffer();\n\n    // --------------------toJson 생성 코드 시작--------------------//\n    buffer.writeln('// To Json Method');\n    buffer.writeln(\n        'Map\u003cString, dynamic\u003e _\\$${className}ToJson($className instance) =\u003e ');\n    buffer.write('\u003cString, dynamic\u003e{');\n    for (int i = 0; i \u003c visitor.fields.length; i++) {\n      String fieldName = visitor.fields.keys.elementAt(i);\n      buffer.writeln(\n        \"'$fieldName': instance.$fieldName,\",\n      );\n    }\n    buffer.writeln('};');\n    return buffer.toString();\n    // --------------------toJson 생성 코드 끝--------------------//\n  }\n\n  // copyWith 메서드 생성하는 메소드\n  String generateCopyWithMethod(ModelVisitor visitor) {\n    // 모델 방문자로부터 클래스 이름 가져오기\n    String className = visitor.className;\n\n    // 생성된 클래스의 각 부분을 작성할 버퍼\n    final buffer = StringBuffer();\n\n    // --------------------copyWith 생성 코드 시작--------------------//\n    buffer.writeln(\n        \"// $className 클래스에 'copyWith' 메소드를 제공하는 확장\");\n    buffer.writeln('extension \\$${className}Extension on $className {');\n    buffer.writeln('$className copyWith({');\n    for (int i = 0; i \u003c visitor.fields.length; i++) {\n      String dataType =\n          visitor.fields.values.elementAt(i).toString().replaceAll(\"?\", \"\");\n      String fieldName = visitor.fields.keys.elementAt(i);\n      buffer.writeln(\n        '$dataType? $fieldName,',\n      );\n    }\n    buffer.writeln('}) {');\n    buffer.writeln('return $className(');\n    for (int i = 0; i \u003c visitor.fields.length; i++) {\n      buffer.writeln(\n        \"${visitor.fields.keys.elementAt(i)}: ${visitor.fields.keys.elementAt(i)} ?? this.${visitor.fields.keys.elementAt(i)},\",\n      );\n    }\n    buffer.writeln(');');\n    buffer.writeln('}');\n    buffer.writeln('}');\n    buffer.toString();\n    return buffer.toString();\n    // --------------------copyWith 생성 코드 끝--------------------//\n  }\n}\n```\n\n이미 귀하는 프로페셔널하고 훌륭한 개발자이십니다. 🎉🎉\n\n마지막 단계에서는 build.yaml 파일에서 builder_factories: [\"generateJsonMethods\"]를 볼 수 있습니다. 이는 최상위 수준 함수를 포함하고 있으며, build.yaml 파일을 확인한 후 build_runner가 호출하게 될 것이며, 그 다음에는 이전에 생성된 생성기(JsonGenerator)를 호출하게 될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 정의는 다음과 같이 되어야 합니다:\n\n```js\nBuilder 이름(BuilderOption) \n```\n\nlib/generators.dart 파일에서:\n\n```js\nlibrary generators;\n\nimport 'package:build/build.dart';\nimport 'package:generators/src/json_generator.dart';\nimport 'package:source_gen/source_gen.dart';\n\nBuilder generateJsonMethods(BuilderOptions options) {\n  // Step 1\n  return SharedPartBuilder(\n    [JsonGenerator()], // Step 2\n    'json_generator', // Step 3\n  );\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n**단계 1:** [Builder]는 파일의 일부로 생성된 콘텐츠를 생성하는데 사용됩니다. 생성된 파일은 partId로 접두사가 붙어 있어 여러 [SharedPartBuilder]가 충돌하지 않고 일부 파일을 생성할 수 있습니다.\n\n**단계 2:** 이것은 우리의 생성기 클래스입니다.\n\n**단계 3:** partId 매개변수가 있습니다. 각 .dart 입력에 대해 어떤 파일이 생성될지 나타냅니다. 이 확장자는 다른 [SharedPartBuilder]와 충돌하지 않도록 고유해야 합니다.\n\n좋아요! 이제 생성기를 만들었네요, 축하합니다. 🎉🎉\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 사용자 정의 주석 및 빌더를 테스트해 봅시다.\n\n# 예제 프로젝트\n\npubspec.yaml 파일을 열어 주석 및 빌더 패키지의 종속성을 추가하세요.\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n\n  # 우리의 주석 패키지\n  annotations:\n    path: ../annotations/\n\ndev_dependencies:\n  flutter_test:\n    sdk: flutter\n\n  build_runner:\n  # 우리의 생성기 패키지\n  generators:\n    path: ../generators/\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 명령어를 실행하십시오: flutter pub get.\n\nlib 폴더로 이동하여 새로운 클래스를 생성하십시오. 예를 들어 Product라는 이름의 클래스를 생성하십시오:\n\n```js\nimport 'package:annotations/annotations.dart';\n\n// 스텝 1\npart 'product.g.dart'; // 파일 이름과 동일해야 함\n\n// 스텝 2\n@customAnnotation\nclass Product{\n  final String name;\n  final double price;\n\n  const Product({required this.name, required this.price});\n\n  /// 생성된 [_$ProductFromJson] 함수를 `fromJson` 팩토리와 연결합니다.\n  factory Product.fromJson(Map\u003cString, dynamic\u003e json) =\u003e _$ProductFromJson(json);\n\n  /// 생성된 [_$ProductToJson] 함수를 `toJson` 메소드와 연결합니다.\n  Map\u003cString, dynamic\u003e toJson() =\u003e _$ProductToJson(this);\n}\n```\n\n스텝 1: 파일 상단에 part `파일이름.g.dart`라는 줄을 추가하여 이 파일이 생성된 코드의 일부임을 지정하십시오. part `파일이름.g.dart`의 파일 이름이 Dart 파일 이름과 일치하는지 확인하십시오.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n스텝 2: 제품 클래스에 우리의 주석을 추가하세요.\n\n예제 프로젝트 터미널에서 다음 명령을 실행해보세요:\n\ndart run build_runner build\n\n예제 프로젝트 터미널에서 명령을 실행한 후 다음 출력이 표시됩니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Code Generation using Flutter](/assets/img/2024-06-21-CodeGenerationusingFluttersource_genbuild_runner_2.png)\n\nOutput/Generated file:\n\n```js\n// GENERATED CODE - DO NOT MODIFY BY HAND\n\npart of 'product.dart';\n\n// **************************************************************************  \n// JsonGenerator  \n// **************************************************************************\n\n// From Json Method\nProduct _$ProductFromJson(Map\u003cString, dynamic\u003e json) =\u003e Product(\n    name: json['name'],\n    price: json['price'],\n);\n\n// To Json Method\nMap\u003cString, dynamic\u003e _$ProductToJson(Product instance) =\u003e \u003cString, dynamic\u003e{\n    'name': instance.name,\n    'price': instance.price,\n};\n\n// Extension for a Product class to provide 'copyWith' method\nextension $ProductExtension on Product {\n    Product copyWith({\n        String? name,\n        double? price,\n    }) {\n        return Product(\n            name: name ?? this.name,\n            price: price ?? this.price,\n        );\n    }\n}\n```\n\nNow you can build your annotation with more customization 🎉😎\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 글을 읽어주셔서 감사합니다. 도움이 되셨으면 좋겣습니다. 궁금한 점이 있으면 언제든지 연락주세요.\n\n소스 코드\n\n질문이 있으면 LinkedIn 계정을 통해 연락주세요.","ogImage":{"url":"/assets/img/2024-06-21-CodeGenerationusingFluttersource_genbuild_runner_0.png"},"coverImage":"/assets/img/2024-06-21-CodeGenerationusingFluttersource_genbuild_runner_0.png","tag":["Tech"],"readingTime":22},{"title":"IntelliJ에서 Flutter 사용하는 방법","description":"","date":"2024-06-21 22:27","slug":"2024-06-21-FlutterinIntelliJ","content":"\n\n## 완전 초보자를 위한 \"플러터 시작하기\" 시리즈의 3부\n\nTiger가 묻습니다... 선호하는 IDE를 계속 사용하는 방법은 무엇인가요?\n\nVS Code는 플러터 프로젝트에서 인기 있는 선택지입니다. 그리고 그것이 그렇게 나쁜 선택은 아닙니다.\n\n하지만 나는 연령이다 유지하려는 것을 좋아하는 Jetbrain의 IntelliJ를 업무에서나 개인적으로 여러 해 동안 사용해 왔습니다. 그것을 좋아하기 때문에, 그리고 필요 없는 경우에는 그것을 포기하기를 꺼리는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n정 테이블 기호(Markdown 형식)로 변경해야 할 것 같습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 더 자세한 지침에 관심이 없고 빠른 \"이것을 해야 한다\" 체크리스트를 원하신다면, 문서 맨 아래의 요약 부분으로 건너뛰세요.\n\n# 플러터 플러그인 설치\n\n그게 플러터의 \"에디터 설정\" 페이지에 언급된 유일한 항목이에요, 그래서 우리는 그것을 해볼 거에요.\n\n- Ctrl+Alt+S - Plugins 찾기\n- marketplace 탭 열고, flutter로 검색하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플러터 플러그인이 많다고 하는데, 예를 들어 Bloc 등이 있습니다. 하지만 지금은 플러터 플러그인만 설치할 예정이에요. 그리고 이에 필요한 Dart 플러그인도 설치해야 한다고 알려줍니다.\n\n![이미지](/assets/img/2024-06-21-FlutterinIntelliJ_0.png)\n\n그런 다음 플러그인을 활성화하기 위해 IDE를 다시 시작하세요.\n\n# 플러터 SDK 설치하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 IntelliJ는 Flutter를 사용하는 방법을 알고 있지만, Flutter 자체가 필요합니다.\n\n- https://docs.flutter.dev/get-started/install\n\n제 경우에는 Linux에 설치하고 Snap을 사용할 것입니다:\n\n```js\nsudo snap install flutter --classic\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 --classic에 대해 헷갈린다면, 스택익스체인지에 훌륭한 답변이 있으니 참고하세요. 요약하면, 이것은 플러터와는 아무 상관이 없으며 플러터에 부여된 액세스 권한에 대한 것입니다.\n\n그럼, 설치가 유효한지 확인해봅시다.\n\n```js\nflutter doctor\n```\n\n이 명령을 실행하여 많은 정보를 확인할 수 있습니다. 먼저, 실행하길 원합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nflutter --disable-analytics\n```\n\n이것은 선택 사항이지만, 나는 텔레메트리를 싫어해요.\n\n다음으로, flutter doctor는 정확히 무엇이 부족한지 알려줍니다:\n\n![FlutterinIntelliJ_1](/assets/img/2024-06-21-FlutterinIntelliJ_1.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안녕하세요! 안드로이드 애플리케이션을 개발할 때 플러터를 사용하기 위해 안드로이드 SDK가 필요합니다. 큰 놀라움이 아니에요. 안드로이드 에뮬레이터를 어떻게 가져올까요?\n\n실제 애플리케이션을 실행할 때 그 다리를 건너가면서 알아보도록 하겠습니다.\n\n# 플러터 프로젝트 생성\n\n![Flutter in IntelliJ](/assets/img/2024-06-21-FlutterinIntelliJ_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nIntelliJ는 플러터 SDK 경로를 인식해야 합니다. 그렇지 않을 경우,\n\n```js\nflutter sdk-path\n```\n\n를 입력하여 확인할 수 있습니다. 거기서 새 프로젝트를 설정하는 일반적인 단계를 거치면 됩니다. 저는 이 시리즈의 개요 포스트에서 설명된 프로젝트를 설정할 것이며, iOS를 대상으로 하지는 않을 것입니다.\n\n![이미지](/assets/img/2024-06-21-FlutterinIntelliJ_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n한 번의 git init과 커밋 후에, 우리는 출발할 준비가 되었어요.\n\n제 개인적인 의견으로는, gitignore.io에서 더 포괄적인 .gitignore 파일을 생성하여 IntelliJ가 자동으로 생성하는 것과 교체하는 것을 선호합니다. 하지만 이 작업을 할 때 주의할 점이 있습니다: 이 글을 쓰는 시점에서, gitignore.io는 *.iws 파일만 무시하지만 IntelliJ가 생성하는 것은\n\n\n# 파일 기반 프로젝트 형식\n*.iml\n*.ipr\n*.iws\n.idea/\n\n\n이렇게 추가해야 할 부분이 있을 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 에뮬레이터에서 앱 실행하기\n\n새로운 플러터 프로젝트에는 \"Hello world\" 보일러플레이트 애플리케이션이 자동으로 포함되어 있습니다. 놀랍게도, 플러터에 대한 미니 튜토리얼을 제공하는 유용한 주석도 포함되어 있습니다. 편리하네요.\n\n지금은 어쨌든, 일단 애플리케이션을 가상 플러터 장치에서 실행하여 모든 것이 작동하는지 확인하고 싶습니다. IntelliJ가 표시하는 경고에서 알 수 있듯이, 그렇게 되지는 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n참고로, IDE 오른쪽 상단의 '장치 선택 없음' 드롭다운을 보는 것을 좋아해요. 안드로이드 스튜디오에 신경을 쓰지 않은 것이 옳은 선택이었다고 느끼게 해줍니다.\n\n## 안드로이드 SDK 설치\n\n경고에서 Configure...을 누를 수도 있지만, 경고 없이 어디에서 무엇을 찾을 수 있는지 알아둘 때를 선호하기 때문에 다음으로 이동합니다.\n\n파일 - 프로젝트 구조 - +\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n수정해주셔서 감사합니다. 단 … 현재 버그가 있어서 원하는 곳이 아닙니다.\n\n![image](/assets/img/2024-06-21-FlutterinIntelliJ_5.png)\n\nAndroid SDK 다운로드를 선택하면 IntelliJ가 다운로드할 JDK 버전을 묻습니다. 제가 원하는 것이 아닙니다.\n\n언젠가는 패치될 것 같지만 그동안 Shift를 두 번 눌러 android를 검색하면 Android SDK 관리자라는 유용한 기능이 있다는 것을 알게 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 우리가 그것을 열면, 그것이 우리가 찾고 있는 것과 더 닮아 보입니다.\n\n![Flutter in IntelliJ image 6](/assets/img/2024-06-21-FlutterinIntelliJ_6.png)\n\n여기서 '편집'을 누르면 SDK 설정을 마칠 수 있습니다.\n\n![Flutter in IntelliJ image 7](/assets/img/2024-06-21-FlutterinIntelliJ_7.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러면 우리에게 다음을 설치할 것입니다:\n\n- 안드로이드 에뮬레이터\n- SDK 빌드 도구\n- SDK 플랫폼과 해당 도구\n- 안드로이드 소스\n\n유용합니다. 한 번의 라이센스 동의 화면을 거치고 나면, 마침내 SDK를 설치했습니다.\n\n## 올바른 Android 플랫폼 설치하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 조심해, 아직 Fig.5에서의 경고가 남아 있네. 왜냐하면 방금 실행한 SDK 설정은 최신 플랫폼만 설치하도록 했기 때문이야... 이는 생성된 프로젝트가 구성된 API 레벨이 아니기 때문이야.\n\n나는 API를 최신 것으로 변경할 수 있지만, 대신 앱이 기대하는 API를 설치해보자:\n\n![이미지](/assets/img/2024-06-21-FlutterinIntelliJ_8.png)\n\nApply를 누르면... 여전히 Fig.5의 경고가 남아 있어.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAPI 29를 설치했지만 프로젝트가 아직 그것을 사용하도록 설정되지 않았기 때문입니다.\n\n그래서 Project Structure 대화상자에서 Android API의 빌드 대상을 29로 변경해봅시다.\n\n![이미지](/assets/img/2024-06-21-FlutterinIntelliJ_9.png)\n\n그리고... 경고 메시지가 여전히 있네요. -.-\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그래, 저희는 이 오해불쏙 끝나는 '구성...' 버튼을 사용할 거에요:\n\n![image](/assets/img/2024-06-21-FlutterinIntelliJ_10.png)\n\nFigure 11에서 안드로이드 API는 프로젝트 구조에서 SDK로 이름을 변경한 것입니다. 내 의견으로는, IntelliJ가 그것에 만족해야 하는 것이었어야 했는데, 그러나 확실히 우리에게 그것을 사용할 수 있다는 것을 알려줄 때 만족했다고 해야 할까요... 대신에 우리가 설치했으므로 이제 추가할 수 있다는 IntelliJ가 감지한 Android API 29 플랫폼 Android SDK 옵션을 선택할 겁니다.\n\n그리고 경고가 없어졌어요. 프로젝트 구조를 간략히 살펴보면, IntelliJ가 새 API를 별도의 항목으로 추가했음을 알 수 있어요. 그래서 첫 번째를 제거하기로 결정할게요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 안드로이드 가상 장치 (AVD) 만들기\n\n당신의 IntelliJ 오른쪽 가장자리, 세 개의 플러터 아이콘(플러터 인스펙터, 플러터 성능 및 플러터 아웃라인 도구) 위에 장치 관리자가 있습니다:\n\n![Device Manager](/assets/img/2024-06-21-FlutterinIntelliJ_11.png)\n\n만약 어떤 이유로 그곳에 없다면, 다시 두 번 Shift를 누르세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이미 미리 설정된 장치가 있어서 시스템 이미지를 다운로드하여 사용할 수 있습니다. 대신 나는 그것을 무시하고 + 버튼을 눌러 내 장치를 스스로 설정할 것입니다.\n\n과정은 매우 간단합니다. 먼저 전화기 크기를 선택하세요:\n\n![전화기 크기 선택](/assets/img/2024-06-21-FlutterinIntelliJ_12.png)\n\n그런 다음 장치가 실행 중이어야하는 시스템 이미지를 선택하세요. 이 이미지를 사용하는 것이 처음이라면, 다운로드해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-21-FlutterinIntelliJ_13.png\" /\u003e\n\n마지막으로 이름을 지어주면 끝입니다. (고급 옵션은 일단 건너 뜁니다.)\n\n## AVD에서 애플리케이션 실행\n\n장치 드롭다운에서 장치 목록을 새로 고침한 후, 이제 우리가 에뮬레이터에서 생성한 AVD를 시작할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\u003cimg src=\"/assets/img/2024-06-21-FlutterinIntelliJ_14.png\" /\u003e\n\nIntelliJ에서 기기를 부팅하는 데 시간이 걸릴 수 있지만 결국 AVD가 준비되고 IntelliJ에서 `no device selected`이라고 표시된 이전 기기가 표시될 것입니다.\n\n만약 Android Emulator를 열 때 \"아무 일도 일어나지 않는\" 것에 혼란스러워한다면, 기본적으로 IntelliJ의 Android 에뮬레이터가 Running Devices 도구 창에서 실행되기 때문입니다. 그 창은 새로운 기기를 시작할 때 자동으로 열리지 않습니다.\n\n\u003cimg src=\"/assets/img/2024-06-21-FlutterinIntelliJ_15.png\" /\u003e\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 동작은 Android 에뮬레이터 설정에서 변경할 수 있어요 (찾으려면 double Shift를 누르세요), 그리고 Launch in a tool window 옵션을 선택하세요.\n\n![이미지](/assets/img/2024-06-21-FlutterinIntelliJ_16.png)\n\n여기에는 \"앱을 실행할 때 Running Devices 도구 창을 열기\"라는 옵션이 있다고 적혀 있지만, 제 경우에는 그렇게 되지 않았어요.\n\n![이미지](/assets/img/2024-06-21-FlutterinIntelliJ_17.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n메인.dart 드롭다운 옆의 초록색 플레이 버튼 또는 버그 버튼으로 어플리케이션을 실행할 수 있습니다.\n\n# 실제 기기에서 앱 실행하기\n\n가끔은 실제 기기에서 앱을 실행하는 것이 필요할 때가 있습니다.\n\n상당히 간단한 과정입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 기기에서 개발자 모드를 활성화하세요 (특정 기기에 대해 하는 방법을 구글에서 검색해보세요).\n- USB 디버깅을 켜세요.\n- 안드로이드 기기를 개발용 컴퓨터에 연결하고, 기기에서 USB 디버깅을 허용하세요.\n- 이전에 AVD를 선택했던 드롭다운 메뉴에서 기기를 선택하세요.\n- IntelliJ에서 애플리케이션을 실행하세요.\n\n# Flutter doctor를 성공적으로 완료하기\n\n애플리케이션이 실행되지만, flutter 설치를 확인하기 위해 flutter doctor를 실행하면 여전히 flutter가 불평합니다:\n\n![이미지](/assets/img/2024-06-21-FlutterinIntelliJ_18.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우선, Command Line 도구에 대해 이야기해볼게요. IntelliJ에서 다시 설치할 수 있는 도구입니다. Android SDK 매니저에서 SDK Tools 탭에는 CLI 도구를 설치할 수 있는 옵션이 있습니다.\n\n이제 새 터미널에서 아래 명령어를 실행해봅시다.\n\n```js\nflutter doctor --android-licenses\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Flutter doctor](/assets/img/2024-06-21-FlutterinIntelliJ_20.png)\n\nAnd if we run flutter doctor again,\n\n![Android Studio warning](/assets/img/2024-06-21-FlutterinIntelliJ_21.png)\n\nFlutter warns that it cannot find Android Studio, but that’s ok, we don’t care about that anyway.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 요약\n\n다시 한 번 강조하자면, 안드로이드 에뮬레이터에서 플러터 앱을 성공적으로 시작하기 위해 해야 할 단계는 다음과 같습니다:\n\n- 머신에 Flutter 설치하기\n\n```js\nsudo snap install flutter --classic\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- IntelliJ를 설치해주세요 (아직 설치하지 않았다면)\n- IntelliJ에 Flutter 및 Dart 플러그인을 설치해주세요\n- IntelliJ에서 새로운 Flutter 프로젝트 생성하기 (이 과정에서 데모 앱이 만들어집니다)\n- IntelliJ에서 Android SDK 매니저 열기\n- SDK 매니저에서 편집 옵션을 눌러 Android SDK를 설치해주세요\n- SDK 플랫폼 탭에서 데모 앱이 요구하는 API 레벨의 Android SDK를 추가로 설치해주세요\n- 프로젝트가 방금 설치한 Android SDK를 사용하도록 구성해주세요\n- 프로젝트 구조에서 오래된 것(들)은 제거하고 Android SDK가 하나만 추가되어 있는지 확인해주세요\n- Device Manager를 사용하여 새로운 안드로이드 가상 장치를 만들어주세요\n- IntelliJ에서 생성한 AVD를 선택하여 앱을 실행해주세요\n- Running Devices 탭에서 안드로이드 에뮬레이터를 찾아주세요\n- 선택적으로 IntelliJ를 구성하여 에뮬레이터를 별도의 창에서 열도록 설정해주세요\n\n그러면 flutter doctor에서 완전히 만족스러운 결과를 얻을 수 있을 것입니다:\n\n- IntelliJ의 Android SDK 매니저의 SDK 도구 탭에서 android SDK 명령줄 도구를 설치해주세요\n- 새 터미널에서 flutter가 받아들이기를 원하는 모든 라이선스를 수락해주세요\n\n```js\nflutter doctor --android-licenses\n```","ogImage":{"url":"/assets/img/2024-06-21-FlutterinIntelliJ_0.png"},"coverImage":"/assets/img/2024-06-21-FlutterinIntelliJ_0.png","tag":["Tech"],"readingTime":9},{"title":"Flutter 웹에서 캐시를 방지하는 방법","description":"","date":"2024-06-21 22:25","slug":"2024-06-21-HowtopreventcacheinFlutterWeb","content":"\n\n![이미지](/assets/img/2024-06-21-HowtopreventcacheinFlutterWeb_0.png)\n\n안녕하세요, 개발자님. 잘 지내시나요? 오늘의 주제는 조금 복잡할 수 있지만 걱정하지 마세요, 5분 안에 해결할 수 있을 거예요 :) 항상처럼 우리의 해결책은 간단하고 효과적입니다!\n\n## 질문 1: 캐시란 무엇이며 브라우저가 캐시를 저장하는 이유는 무엇인가요?\n\n- 브라우저 캐시는 웹 페이지, 이미지, 스크립트 등이 임시로 저장되는 장소로, 웹 브라우저가 여러분의 기기에 저장합니다. 웹 사이트를 방문하면 브라우저가 HTML, CSS, JavaScript 및 이미지와 같은 파일을 다운로드합니다. 매번 다운로드하는 대신 브라우저는 그 사본을 캐시에 저장합니다. 사이트를 재방문하면 브라우저가 파일 확인을 캐시에서 합니다. 그 파일들이 존재하고 유효 기간이 지나지 않았다면, 브라우저는 캐시에서 그 파일을 검색하여 페이지 로딩 속도를 높입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 질문 2: 사람들이 캐시를 막거나 비활성화하려는 이유는 무엇인가요?\n\n- 때로는 모든 콘텐츠(이미지 및 스타일 시트와 같은 리소스)가 매번 새로 고쳐져야 하는 중요성이 커질 수 있습니다. 놀랍게도 이러한 요소들은 특정 시나리오에서 중요할 수 있습니다.\n\n이제 캐시에 대해 알았으니, 이어서 Flutter Web의 해결책을 살펴보겠습니다.\n\n해결책은 간단합니다. Flutter Web에서 캐시 문제는 web/index.html 파일에 있는 main.dart.js라는 스크립트에서 발생합니다. 이를 해결하기 위해 이 스크립트 끝에 숫자나 변수를 추가하면 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우연히 손으로 매번 값 변경하거나 증가시키는 것을 피하기 위해 플러터는 index.html 파일에 \"serviceWorkerVersion\"이라는 미리 정의된 값을 제공합니다. 이 값을 수동으로 수정하는 대신 이 값을 사용할 수 있습니다.\n\n플러터가 제공하는 \"serviceWorkerVersion\"을 사용하면 버전을 수동으로 갱신하는 대신 자동으로 증가되는 동적 해결책을 얻을 수 있습니다.\n\n먼저 프로젝트로 이동하여 web/index.html 파일을 찾아보세요. 파일을 찾았다면, 이 페이지로 돌아와 다음 중 하나의 해결책을 적용하세요.\n\n## Case 1: Flutter의 새로운 버전\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 새로운 Flutter 버전에서 캐시 문제를 방지해야 한다면, 몇 가지 스크립트를 수정해야 합니다. \"main.dart.js\" 스크립트는 기본적으로 존재하지 않기 때문에 직접 추가해야 합니다.\n\n\" _flutter.loader.loadEntrypoint\"를 수정하고 추가 매개변수를 넣어야 합니다: \"entrypointUrl: \"main.dart.js?v=\" + serviceWorkerVersion\" \n\n최종적으로는 아래와 같이 스크립트 부분이 보여야 합니다:\n\n```js\n\u003cscript\u003e\n    window.addEventListener('load', function (ev) {\n      // Download main.dart.js\n      _flutter.loader.loadEntrypoint({\n        entrypointUrl: \"main.dart.js?v=\" + serviceWorkerVersion,\n        serviceWorker: {\n          serviceWorkerVersion: serviceWorkerVersion,\n        }\n      }).then(function (engineInitializer) {\n        return engineInitializer.initializeEngine();\n      }).then(function (appRunner) {\n        return appRunner.runApp();\n      });\n    });\n  \u003c/script\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 작은 추가로 문제가 해결되었습니다! :)\n\n## 케이스 2: Flutter의 이전 버전\n\n이전 버전의 Flutter에서 캐시 문제를 방지해야하는 경우, web/index.html의 “scriptTag.src” 값이 다음과 같이 수정되어야 합니다: “scriptTag.src = ‘main.dart.js?v=’ + serviceWorkerVersion;”.\n\n결국, 스크립트 섹션은 다음과 같이 보여야 합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003cscript\u003e\n    var serviceWorkerVersion = null;\n    var scriptLoaded = false;\n    function loadMainDartJs() {\n      if (scriptLoaded) {\n        return;\n      }\n      scriptLoaded = true;\n      var scriptTag = document.createElement('script');\n      scriptTag.src = 'main.dart.js?v=' + serviceWorkerVersion;\n      scriptTag.type = 'application/javascript';\n      document.body.append(scriptTag);\n    }\n\n    if ('serviceWorker' in navigator) {\n      // Service workers are supported. Use them.\n      window.addEventListener('load', function () {\n        // Wait for registration to finish before dropping the \u003cscript\u003e tag.\n        // Otherwise, the browser will load the script multiple times,\n        // potentially different versions.\n        var serviceWorkerUrl = 'flutter_service_worker.js?v=' + serviceWorkerVersion;\n        navigator.serviceWorker.register(serviceWorkerUrl)\n          .then((reg) =\u003e {\n            function waitForActivation(serviceWorker) {\n              serviceWorker.addEventListener('statechange', () =\u003e {\n                if (serviceWorker.state == 'activated') {\n                  console.log('Installed new service worker.');\n                  loadMainDartJs();\n                }\n              });\n            }\n            if (!reg.active \u0026\u0026 (reg.installing || reg.waiting)) {\n              // No active web worker and we have installed or are installing\n              // one for the first time. Simply wait for it to activate.\n              waitForActivation(reg.installing || reg.waiting);\n            } else if (!reg.active.scriptURL.endsWith(serviceWorkerVersion)) {\n              // When the app updates the serviceWorkerVersion changes, so we\n              // need to ask the service worker to update.\n              console.log('New service worker available.');\n              reg.update();\n              waitForActivation(reg.installing);\n            } else {\n              // Existing service worker is still good.\n              console.log('Loading app from service worker.');\n              loadMainDartJs();\n            }\n          });\n\n        // If service worker doesn't succeed in a reasonable amount of time,\n        // fallback to plaint \u003cscript\u003e tag.\n        setTimeout(() =\u003e {\n          if (!scriptLoaded) {\n            console.warn(\n              'service worker disabled...',\n            );\n            loadMainDartJs();\n          }\n        }, 4000);\n      });\n    } else {\n      // Service workers not supported. Just drop the \u003cscript\u003e tag.\n      loadMainDartJs();\n    }\n  \u003c/script\u003e\n```\n\nWith this small change, the problem is solved! :)\n\nIn this way, we have seen how to prevent the \"Cache\" problem in Flutter with simple solutions. I hope these solutions have been helpful to you.\n\nIf you have read this article and would like to support me, don't be shy — buy me a coffee! :) ☕☕☕\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n커피 사줄래?\n\n제가 이 글을 쓰는 데 도움이 된 몇 가지 링크가 있어요. 꼭 확인해 보세요!\n\n- 문제 1 (반드시 확인해보세요!)\n- 스택 오버플로우 1\n- 스택 오버플로우 2\n- 스택 오버플로우 3\n\n이 글을 읽어 주셔서 감사합니다. 추가 질문이 있으시면 언제든지 댓글을 남겨 주세요. 그리고 박수 버튼 꾹 눌러주세요 :) 다음에 또 봐요, 개발자님 :)","ogImage":{"url":"/assets/img/2024-06-21-HowtopreventcacheinFlutterWeb_0.png"},"coverImage":"/assets/img/2024-06-21-HowtopreventcacheinFlutterWeb_0.png","tag":["Tech"],"readingTime":6},{"title":"Firebase로 Flutter 프로젝트에 애플 패스 추가하는 방법","description":"","date":"2024-06-21 22:23","slug":"2024-06-21-HowtoaddApplePassonaFlutterprojectwithFirebase","content":"\n\n\u003cimg src=\"/assets/img/2024-06-21-HowtoaddApplePassonaFlutterprojectwithFirebase_0.png\" /\u003e\n\n이 글에서는 Firebase 함수를 사용하여 Flutter 프로젝트에 Apple Pass를 통합하는 방법을 설명하겠습니다.\n\n저는 백엔드 개발과 Apple Pass 디자인에 대한 전문가가 아니기 때문에 정보가 부족하거나 부정확할 수 있습니다. 더 자세한 내용은 문서를 참조해주세요.\n\n# 단계 1: 인증서 준비하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가장 먼저 할 일은 인증서를 준비하는 것입니다. 세 가지 요소를 다운로드해야 합니다:\n\n- 서명자 인증서 (개발자)\n- 서명자 인증서 키 (개발자)\n- WWDR (애플 월드와이드 개발자 관계) G4 인증서\n\n- 새로운 패스 유형 식별자(직접 링크)를 생성하고 설명 및 역도메인 식별자(“pass.”로 시작)를 제공하세요. pass.json 파일 또는 프로퍼티 값으로 이 식별자를 passTypeIdentifier에 넣어야 합니다.\n- Keychain Access를 열고 파일 `인증서 보조도구` `인증서 요청`으로 이동하여 양식을 작성한 후 “디스크에 저장” 옵션을 선택하고 계속하세요. 새 파일이 생성됩니다.\n- 패스 유형 식별자 목록(필터링)에서 새 패스 ID를 클릭하여 편집합니다.\n- “인증서 생성”을 클릭하세요. 패스 인증서 이름을 입력하고 Keychain Access로 방금 생성된 파일을 업로드하세요. 그런 다음 인증서를 다운로드하고 두 번 클릭하여(Keychain Access에 추가하는) 열어주세요.\n- Keychain Access로 돌아가서 “패스 유형ID: xxxx”를 마우스 오른쪽 버튼으로 클릭하고 “패스 유형ID: xxxx”를 내보내세요. 마음에 드는 곳에 저장하고(.p12 확장자와 함께) 암호를 생성해야 합니다. 이것은 나중에 필요할 것입니다.\n- 이 .p12 파일을 저장한 위치에서 터미널을 열고 다음 명령어를 입력하세요:\n\n```js\n# -passin용 \u003cyour-password\u003e는 P12의 비밀번호입니다.\n$ openssl pkcs12 -in \u003ccert-name\u003e.p12 -clcerts -nokeys -out signerCert.pem -passin pass:\u003cyour-password\u003e\n\n# -passin용 \u003cyour-password\u003e는 P12의 비밀번호입니다. \u003csecret-passphrase\u003e는 passkit-generator에 전달할 privateKey를 복호화하는 데 사용할 암호입니다.\n$ openssl pkcs12 -in \u003ccert-name\u003e.p12 -nocerts -out signerKey.pem -passin pass:\u003cyour-password\u003e -passout pass:\u003csecret-passphrase\u003e\r\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n에러가 발생하면 명령 끝에 \"-legacy\"를 추가하거나 이 링크를 따르세요.\n\n암호구절을 저장해두세요. 나중에 필요할 겁니다.\n\n필요한 3개 인증서 중 2개가 생성되었습니다.\n\n마지막 인증서를 위해서는 이 링크를 열어보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 단계 2: 서버 측 준비\n\n우리가 말했듯이, 우리는 Firebase 함수를 사용하여 우리의 패스 생성기를 호스팅할 것입니다.\n\n주의: 이 작업을 위해 Blaze 요금제가 필요합니다 (무료가 아닌 \"사용한 만큼 지불\" 형태입니다). Firebase를 사용하지 않으려면 우리가 만들 백엔드를 원하는 곳에 호스팅하시면 됩니다.\n\n우리의 패스를 생성하기 위해 passkit-generator를 사용할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n시작해봅시다:\n\n- 터미널에서 Firebase CLI를 설치하세요.\n- 새 Firebase 프로젝트 생성하기\n- \"pass-generator-be\"라는 폴더를 만들고 여기서 터미널을 열고 다음을 실행하세요.\n\n```js\nflutter login\n```\n\n- 명령어를 입력하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nfirebase init\n```\n\n“Functions: Configure a Cloud Functions directory and its files”을 선택하고 방금 만든 프로젝트를 선택하세요. 그런 다음 \"JavaScript\"를 선택하고 \"Y\"로 모든 질문에 답하십시오. 단, \"가능한 버그를 잡고 스타일을 강제하기 위해 ESLint를 사용하시겠습니까?\"에서는 (배포할 때 Lint 예외가 발생하지 않도록 하기 위해) \"N\"을 선택하시면 됩니다. 이것이 괜찮다면 그대로 두셔도 됩니다.\n\n- 이제 코드 에디터와 함께 생성된 \"functions\" 폴더를 열어보세요.\n- 프로젝트 내부의 터미널을 열고 아래 의존성을 설치하세요.\n\n```js\nyarn add passkit-generator\nyarn add path\nyarn add file-system\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 프로젝트 내부에 \"certs\" 폴더를 만들어서 우리가 생성한 3개의 인증서를 붙여넣으세요.\n- 또한 \"model\" 폴더를 만들어서 패스 모델을 넣을 것입니다.\n\n간단한 패스 모델을 사용할 예정이며, 레이블과 이미지만 포함됩니다. 다른 모델에 관심이 있다면, 이 링크를 따라가서 사용자 정의 JSON 파일을 만들어보세요. 여기서 샘플을 찾을 수 있습니다.\n\n- 패스 폴더를 준비했다면 (예: \"auditor.pass\", JSON 파일과 이미지가 포함된), 이를 프로젝트 내부의 \"model\" 폴더에 복사하세요.\n\n프로젝트 구조는 다음과 같이 보일 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](/assets/img/2024-06-21-HowtoaddApplePassonaFlutterprojectwithFirebase_1.png)\n\nMy pass.json file is:\n\nWarnings:\n\n- passTypeIdentifier: has to be the same as the one we registered at the beginning\n- teamIdentifier: has to be your team identifier\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"index.js\"로 이동해보세요:\n\n- 의존성 가져오기\n\n```js\nconst functions = require(\"firebase-functions\");\nconst { PKPass } = require(\"passkit-generator\");\nvar fs = require(\"file-system\");\nvar path = require(\"path\");\n```\n\nPKPass를 사용하여 패스를 생성하세요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nPKPass.from({\n        model: \"./model/auditor.pass\",\n        certificates: {\n            wwdr: fs.readFileSync(\"./certs/wwdr.pem\"),\n            signerCert: fs.readFileSync(\"./certs/signerCert.pem\"),\n            signerKey: fs.readFileSync(\"./certs/signerKey.pem\"),\n            signerKeyPassphrase: \"YOUR PASSPHRASE\"\n        }\n\n    },{})\n```\n\n모두 함께\n\n흐름은 매우 간단합니다:\n\n- 새 요청이 도착하면 패스가 생성됩니다\n- 그런 다음 요청 내의 정보를 사용하여 패스를 채웁니다\n- 패스가 클라이언트로 되돌아갑니다\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n알림: 주석 처리된 “fs.writeFileSync(“auditor.pkpass”, bufferData)”는 개발 중에 생성된 .pkpass 파일을 프로젝트 폴더에 저장하는 데 유용합니다. 에뮬레이터에서 결과를 확인하기 쉽게 할 수 있습니다.\n\n백엔드를 로컬에서 실행하려면 다음 명령어를 입력하세요.\n\n```js\nfirebase emulators:start    \n```\n\n그러면 “http://127.0.0.1:5001/XXXX/us-central1/pass”와 같은 URL을 제공해줄 겁니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n로컬 개발을 마치고 프로덕션 환경으로 이동하려면 다음 명령어를 사용하여 서버를 배포하세요.\n\n```js\nfirebase deploy\n```\n\n# 단계 3: 플러터 앱\n\n우리 앱에서 할 일이 매우 적습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 먼저 flutter_wallet_card와 dio(또는 다른 http 클라이언트)를 가져와주세요.\n- 제안된 이미지를 사용하여 \"Apple Wallet에 추가\" 기능을 제공해주세요.\n- onTap 동작을 처리하는 함수를 작성해주세요.\n\n그러고 나서 XCode로 iOS 모듈을 열고 Runner 아래에서 'Signing \u0026 Capabilities'를 클릭한 후 \"+ Capability\"를 클릭해주세요. 마지막으로 \"특정 종류의 패스 허용\"을 선택하고 처음에 생성한 패스를 선택해주세요.\n\n![이미지](/assets/img/2024-06-21-HowtoaddApplePassonaFlutterprojectwithFirebase_2.png)\n\n그리고...... 이게 전부에요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n당신의 앱은 이제 \"Apple Wallet에 추가\" 기능을 구현하고 있습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:600/1*CSrT10rYaB124vi-MuXDFw.gif)","ogImage":{"url":"/assets/img/2024-06-21-HowtoaddApplePassonaFlutterprojectwithFirebase_0.png"},"coverImage":"/assets/img/2024-06-21-HowtoaddApplePassonaFlutterprojectwithFirebase_0.png","tag":["Tech"],"readingTime":5},{"title":"2024년 Flutter에서 GraphQL 사용법 쿼리, 뮤테이션, 서브스크립션 구현 완벽 가이드","description":"","date":"2024-06-21 22:20","slug":"2024-06-21-GraphQLinFlutterAComprehensiveGuidetoQueryMutationandSubscriptionImplementations","content":"\n\n![이미지](/assets/img/2024-06-21-GraphQLinFlutterAComprehensiveGuidetoQueryMutationandSubscriptionImplementations_0.png)\n\n이 기사는 플러터(Flutter)에서 GraphQL을 마스터하는 데 필수적인 가이드입니다! 기본 개념 이해부터 쿼리(query), 뮤테이션(mutation), 구독(subscription)의 핵심 개념까지 모두 다룹니다. 뿐만 아니라 Flutter 앱에 GraphQL을 원활하게 통합하는 방법을 단계별 지침과 코드 샘플을 제공하면서 안내해드립니다.\n\n# GraphQL이란?\n\nGraphQL을 주문하듯이 생각해보세요. 일반 레스토랑(전통적인 API와 같은)에서는 특정 토핑이 올라간 고정된 피자를 주문합니다. 원하는 거랑 다르면 완전히 새로운 피자를 주문해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금은 GraphQL을 사용하면 피자에 원하는 대로 말하는 것과 같아요 — 크러스트, 소스, 토핑 종류를 정확하게 말하는 것과 같아요. 당신을 위해 특별히 만들어진 피자를 받게 되는거죠. 딱 필요한 만큼만요. 데이터에 대한 맞춤 주문처럼 생각해보세요 — 필요한 것을 요청하면 정확히 그것을 받게 되어 매우 효율적이고 요구 사항에 맞게 제작됩니다.\n\n그 외에도, GraphQL은 데이터와 상호 작용하는 방법을 간소화하여 세 가지 주요 작업을 제공합니다: 쿼리, 뮤테이션, 그리고 구독.\n\n- 쿼리: GraphQL에서 쿼리는 특정 데이터를 요청하는 것입니다. 서버에서 정보를 요청하는 것과 같이 특정 데이터와 그 구조를 명시합니다. 당신이 원하는 토핑과 크러스트 유형을 주문하는 것과 같은 거죠.\n- 뮤테이션: GraphQL에서 뮤테이션은 데이터 수정을 다루는 작업들입니다. 새 데이터 추가, 기존 레코드 업데이트, 혹은 정보 삭제와 같은 작업을 할 수 있습니다. 피자 비유에서는 셰프에게 선호에 따라 토핑을 추가하거나 제거하도록 지시하는 것과 같아요.\n- 구독: 구독은 GraphQL에서 실시간 업데이트를 가능하도록 합니다. 클라이언트(당신)와 서버(셰프) 사이에 지속적인 연결을 설정하여 서버가 가능한 즉시 새 정보를 클라이언트에게 푸시할 수 있게 합니다. 피자 준비 과정을 알려주는 셰프와 같이 데이터 변경 사항에 대한 실시간 알림을 받는 것과 같아요.\n\n그래서, GraphQL은 주문을 맞춤 제작하는 것 이상이에요; 당신이 요구하는 대로 데이터를 조회, 수정하고 최신 상태를 유지할 수 있도록 효율적이고 요구 사항에 정확히 맞게 제작된 방법을 제공하는겁니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 플러터에서 GraphQL 구현하기\n\n먼저, 다음 패키지를 pubspec.yaml 파일에 추가하고 flutter pub get을 실행하세요:\n\n```js\n  graphql_flutter: latest\n  graphql: latest\n```\n\n이제 다음과 같이 GraphQL 클라이언트를 생성하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n  final HttpLink _httpLink = HttpLink(\n    \"\u003cYOUR-BASE-URL\u003e\",\n    defaultHeaders: {\n      'Authorization': 'Bearer \u003cYOUR_PERSONAL_ACCESS_TOKEN\u003e',\n      'AuthorizationSource': 'API',\n    },\n  );\n\n\n  final ValueNotifier\u003cGraphQLClient\u003e client = ValueNotifier(GraphQLClient(\n    link: _httpLink,\n    cache: GraphQLCache(),\n  ));\n```\n\n앱을 GraphQL 위젯을 사용하기위한 GraphQLProvider 상속 위젯으로 감싸세요:\n\n```js\n  Widget build(BuildContext context) {\n    return GraphQLProvider(\n      client: client,\n      child: MaterialApp(\n        title: 'App',\n        home: HomeScreen(),\n      ),\n    );\n  }\n```\n\n그럼 GraphQL API를 소비해봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 쿼리\n\n먼저 쿼리 문서를 정의해보겠습니다.\n\n```js\nfinal getUserQuery = gql(r'''\n    query getUser($id: ID) {\n      user(id: $id) {\n        id\n        first_name\n        last_name\n      }\n    }\n''');\n```\n\n쿼리 정의:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- query getUser($id: ID): 이 줄은 getUser라는 GraphQL 쿼리의 정의를 시작합니다. $id는 쿼리에 전달할 수 있는 ID 유형의 변수입니다.\n\n쿼리 본문:\n\n- ' user(id: $id) ' ... ' ': 쿼리의 본문은 우리가 원하는 데이터를 지정합니다. 이 경우 주어진 id를 가진 사용자에 대한 정보를 요청하고 있습니다. 요청된 세 가지 필드는 id, first_name 및 last_name입니다.\n\n변수 사용:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 쿼리 내에서 $id 변수는 요청을 매개변수화하는 데 사용됩니다. 이는 쿼리가 실행될 때 특정 ID로 동적으로 채워지는 자리 표시자입니다.\n\n## 쿼리 위젯\n\n이제 이 문서를 사용하여 GraphQL API에 요청을 보냅니다.\n\n```js\nQuery(\n  options: QueryOptions(\n    document: getUserQuery,\n    variables: const {\n      \"id\": \"1\",\n    },\n  ),\n  builder: (\n    QueryResult result, {\n    Future\u003cQueryResult\u003e Function(FetchMoreOptions)? fetchMore,\n    Future\u003cQueryResult?\u003e Function()? refetch,\n  }) {\n    if (result.hasException) {\n      return const Text(\"에러\");\n    }\n    if (result.isLoading) {\n      return const CircularProgressIndicator();\n    }\n    final user = result.data?[\"user\"];\n    return ListTile(\n      title: Text(user[\"first_name\"]),\n      subtitle: Text(user[\"last_name\"]),\n    );\n  },\n)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n쿼리 위젯:\n\n- 이 문구는 graphql_flutter 패키지에서 제공하는 Query 위젯의 일부분입니다. Query 위젯은 GraphQL 쿼리를 실행하는 데 사용됩니다.\n\n쿼리의 옵션:\n\n- 옵션 매개변수는 GraphQL 쿼리 실행에 필요한 세부 정보를 제공하는 데 사용됩니다.\n- 문서: getUserQuery: 실행할 GraphQL 쿼리는 getUserQuery 변수를 사용하여 지정됩니다. 이 변수는 코드의 이전 부분에서 정의된 쿼리입니다.\n- 변수: const '\"id\": \"1\"': 이는 쿼리에 필요한 변수를 제공합니다. 이 경우 \"id\" 변수를 \"1\"로 설정하고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nBuilder 함수:\n\n- builder는 GraphQL 쿼리의 결과로 호출되는 콜백 함수입니다.\n- QueryResult result: GraphQL 쿼리 실행의 결과를 보유합니다.\n- 빌더 안에서:\n- result.hasException을 사용하여 예외를 확인합니다. 예외가 발생하면 \"Error\"를 표시하는 Text 위젯을 반환합니다.\n- result.isLoading을 사용하여 쿼리가 여전히 로딩 중인지 확인합니다. true인 경우 CircularProgressIndicator를 반환합니다.\n- 쿼리가 성공하고 로딩 중이 아닌 경우, 결과에서 사용자 데이터를 추출하고 ListTile에 표시합니다. ListTile에는 사용자의 성과 이름이 각각 제목과 부제목으로 나타납니다.\n\n## 쿼리 메소드\n\n응답을 그릴 때 더 많은 제어를 위해 GraphQL 클라이언트의 query 메소드를 사용하여 GraphQL API를 소비하는 다른 방법이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n# Mutation\n\n이제 먼저 변이 문서를 정의해 봅시다.\n\n```js\n final updateUserMutation = gql(r'''\n    mutation updateUser($id: ID, $first_name: String, $last_name: String) {\n    updateUser(\n    input: {id: $id, first_name: $first_name, last_name: $last_name,}\n      ) {\n    user {\n      id\n      first_name\n      last_name\n    }\n    messages {\n      field\n      message\n    }\n  }\n}\n''');\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 문서를 사용하여 GraphQL 클라이언트 객체를 사용하여 사용자 데이터를 업데이트해 봅시다.\n\n```js\nfinal result = await client.mutate(\n        MutationOptions(\n          document: updateUserMutation,\n          variables: {\n            \"id\": \"1\",\n            \"first_name\": \"John\",\n            \"last_name\": \"Doe\"\n          },\n        ),\n```\n\nGraphQL Mutation 실행:\n\n- client.mutate: 이것은 GraphQL 클라이언트에서 mutate 메소드를 호출하는 것입니다. 클라이언트 객체는 GraphQL 클라이언트의 인스턴스입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n돌변에 대한 옵션:\n\n- 돌변 옵션은 GraphQL 돌변 실행에 대한 세부 정보를 제공하는 데 사용됩니다.\n- 변수: '\"id\": \"1\", \"first_name\": \"John\", \"last_name\": \"Doe\"': 이는 돌변에 필요한 변수를 제공합니다. 사용자의 id와 함께 업데이트할 새로운 이름 및 성 값을 포함합니다.\n\n결과 처리:\n\n- 돌변 작업의 결과는 결과 변수에 저장됩니다.\n- 결과의 실제 구조는 사용되는 GraphQL 클라이언트에 따라 다르지만 일반적으로 돌변에 의해 반환된 데이터, 오류 및 추가 메타데이터와 같은 정보를 포함합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 구독\n\n먼저 웹소켓을 위한 graphQL 클라이언트를 만들겠습니다.\n\n```js\nfinal WebSocketLink websocketLink = WebSocketLink(\n    url: '\u003cYOUR-GRAPHQL-SUBSCRIPTION-ENDPOINT\u003e',\n    config: SocketClientConfig(\n    autoReconnect: true,\n    inactivityTimeout: Duration(seconds: 30),\n  ),\n);\n\nwebsocketClient = GraphQLClient(\n  link: websocketLink,\n  cache: GraphQLCache(),\n);\n```\n\n웹소켓 링크 설정:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- WebSocketLink은 GraphQL 구독용 WebSocket 전송의 구현체입니다. 지정된 GraphQL 서버 엔드포인트로 WebSocket 연결을 설정합니다.\n- URL: `YOUR-GRAPHQL-SUBSCRIPTION-ENDPOINT`: 실제 웹소켓 엔드포인트로 대체합니다. 이는 GraphQL 서버에서 제공하는 실제 웹소켓 엔드포인트로 구독을 처리합니다. 이 URL은 일반적으로 ws:// 또는 wss://로 시작합니다.\n- config: SocketClientConfig(...): WebSocket 연결에 대한 구성 옵션을 제공합니다.\n- autoReconnect: true: 연결이 끊긴 경우 자동 재연결을 활성화합니다.\n- inactivityTimeout: Duration(seconds: 30): 활동이 없거나 해당 시간 내에 통신이 발생하지 않을 경우 웹소켓 연결을 닫기 위한 타임아웃 기간을 설정합니다.\n\nGraphQLClient 설정:\n\n- GraphQLClient는 구독을 위한 통신 링크로 WebSocketLink를 사용하여 인스턴스화됩니다. 또한 캐싱을 위해 GraphQLCache를 사용합니다.\n- link: websocketLink: GraphQL 클라이언트의 통신 링크로 WebSocketLink를 지정합니다. 이는 구독이 WebSocket 연결을 통해 처리되도록 합니다.\n- cache: GraphQLCache(): GraphQL 클라이언트의 로컬 상태 및 쿼리 결과를 저장하고 관리하기 위한 캐시를 초기화합니다.\n\n이제 GraphQL 구독 문서를 작성해 봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```javascript\n  static final userUpdatedMutation = gql(r'''\nsubscription userUpdatedSubscription($id: String) {\n        userUpdatedSubscription(id: $id) {\n            ...UserFragment\n        }\n    }\n    fragment UserFragment on User {\n        id\n        first_name\n        last_name\n    }\n    ''');\n```\n\nGraphQL Subscription:\n\n- userUpdatedMutation은 사용자가 업데이트될 때 업데이트를 청취하는 GraphQL 구독(subscription)입니다. 사용자관련 정보를 관심 있는 사용자로 지정하기 위해 String 타입의 $id 매개변수를 가져옵니다.\n- subscription userUpdatedSubscription($id: String): id 변수를 허용하는 userUpdatedSubscription이라는 이름의 구독을 선언합니다.\n- userUpdatedSubscription(id: $id): 이 구독은 지정된 id를 가진 사용자에 대한 업데이트에 관심이 있다는 것을 나타냅니다.\n- ' ...UserFragment ': 이 구독에는 fragment spread, ...UserFragment가 포함되어 있어서 UserFragment에서 지정된 필드를 수신하려는 것을 나타냅니다.\n\nGraphQL Fragment:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- GraphQL 프래그먼트 (UserFragment)는 여러 쿼리, 뮤테이션 또는 구독에서 사용할 수 있는 재사용 가능한 필드 세트를 정의합니다.\n- UserFragment on User ' ... '의 프래그먼트는 User 유형에서 UserFragment라는 이름의 프래그먼트를 선언합니다.\n- 이 프래그먼트에는 id, first_name, last_name과 같은 필드가 포함되어 있습니다. ...UserFragment 스프레드를 포함하는 모든 작업은 이러한 필드를 자동으로 포함합니다.\n- 프래그먼트는 필드 정의의 중복을 피하고 코드 재사용성을 촉진하는 데 도움이 됩니다. 여러 작업이 공통 필드를 공유할 때 특히 유용합니다.\n\n이제 이 구독을 들어보겠습니다\n\n```js\nvoid _subscribe() async {\n  final subscription = await websocketClient.subscribe(\n    SubscriptionOptions(\n      document: userUpdatedMutation,\n    ),\n  );\n\n  subscription.listen((result) {\n    final userData = result.data?['user'];\n    print('이름: ${userData[\"first_name\"]}');\n    print('성: ${userData[\"last_name\"]}');\n    // 실시간 업데이트 처리, 예를 들어 UI 업데이트\n  });\n}\n```\n\nSubscription Widget도 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nbody: Subscription(\n        options: SubscriptionOptions(\n        document: userUpdatedMutation,\n        ),\n        builder: (result) {\n          final user = result.data?[\"user\"];\n          return ListTile(\n            title: Text(user[\"first_name\"]),\n            subtitle: Text(user[\"last_name\"]),\n          );\n        },\n      ),\n```\n\n# 결론\n\n이 가이드를 통해 플러터에서 GraphQL 구현에 대한 포괄적인 이해를 제공했습니다. 쿼리, 뮤테이션 및 구독의 기본 사항부터 실제 통합 단계에 이르기까지의 내용이 담겨 있습니다. 실시간 업데이트를 통한 GraphQL 구독에 중점을 두고 뮤테이션 작업을 시연함으로써, 개발자들은 이제 플러터 프로젝트에 GraphQL을 원활하게 통합할 수 있습니다. 이 포괄적인 리소스는 모든 수준의 개발자가 데이터 검색을 최적화하고 앱의 효율성을 향상시키며, 플러터에서 GraphQL의 강력함을 통해 동적 사용자 경험을 제공할 수 있는 기술을 제공합니다.","ogImage":{"url":"/assets/img/2024-06-21-GraphQLinFlutterAComprehensiveGuidetoQueryMutationandSubscriptionImplementations_0.png"},"coverImage":"/assets/img/2024-06-21-GraphQLinFlutterAComprehensiveGuidetoQueryMutationandSubscriptionImplementations_0.png","tag":["Tech"],"readingTime":9},{"title":"Flutter에서 Stripe를 사용하여 결제 통합하는 방법","description":"","date":"2024-06-21 22:19","slug":"2024-06-21-IntegratePaymentinFlutterwithStripe","content":"\n\n![이미지](/assets/img/2024-06-21-IntegratePaymentinFlutterwithStripe_0.png)\n\n안녕하세요 여러분, 제가 최근에 글을 올린 지 꽤 오랜 시간이 지났죠. 지난 몇 달 동안 저는 많은 새로운 경험들로 가득했고, 그 모든 것을 해내려고 노력했습니다. 하지만 글을 오랫동안 쓰지 않았다는 것을 깨달았고, 이번 11월에 적어도 두 개의 글을 쓰기로 다짐하고 앞으로는 더 꾸준해지기로 결심했습니다. 제가 이를 통해 모든 독자들에게 책임감을 느끼도록 허락해주세요.\n\n오늘의 글은 플러터(Flutter)에서 Stripe를 이용한 결제 처리에 관한 것입니다. 최근에 어느 회사에서 나에게 모바일 앱의 여러 기능을 매우 짧은 기간 내에 작업하도록 계약을 맺었습니다. 그 기능 중 하나가 결제 기능이었고, 물론 그들은 Stripe를 사용하길 원했습니다. 저는 반면에 플러터에 Stripe를 통합한 경험이 전혀 없었지만, 도전에서 도망가는 걸 절대 못 볼 것 같아 이 일을 받아들이고 조사에 착수했습니다. 이 지식을 여러 곳에서 모았지만, 이 글을 최대한 정보성 있게 만드는 데 노력하겠습니다. 이 주제에 대한 답변을 찾기 위해 다른 곳을 더 이상 찾아다니지 않아도 되도록 하겠습니다. 긴 이야기는 여기까지, 이제 시작해보죠.\n\n## Stripe:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저, 이 멋진 결제 플랫폼인 Stripe에 대해 간단히 소개할게요. Stripe는 Shopify, Instacart 같은 수백만 개의 기업에서 사용하는 결제 게이트웨이로, Google, Amazon과 같은 대규모 기술 기업도 사용하고 있어요. 이들은 전 세계 기업 및 그들의 고객들이 결제를 받고 보내는 간단하고 편리한 프로세스를 제공해요. 가상 및 실물 카드 발급, 반복 결제 처리, 재무에 대한 지능적이고 다이어그래틱한 분석 및 보고서, 송장 생성 등과 같은 추가 서비스도 제공하고 있어요.\n\nStripe를 개발자로서 흥미롭게 느낀 점 중 하나는 다양한 스택에 쉽게 통합되며 이를 지원하는 라이브러리, 그리고 Apple 및 Google 페이와 같은 네이티브 결제를 지원한다는 것이에요.\n\n## 시작하기\n\n시작하려면, 먼저 Stripe에서 API 키를 생성해야 해요. 이를 위해 Stripe 계정을 생성해야 해요. 그러고 나서 대시보드에 로그인하여 테스트 모드를 활성화하고 통합 및 테스트를 위해 개발자 `API Keys`로 이동하여 API 키(공개 및 비밀 키)를 확인하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-21-IntegratePaymentinFlutterwithStripe_1.png)\n\n## 환경 설정하기\n\n의존성에 다음 패키지들을 추가하세요:\n\n```yaml\nflutter_stripe: ^5.0.0\nflutter_dotenv: ^5.0.2\nhttp: ^0.13.5\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 마크다운 형식으로 변경해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-21-IntegratePaymentinFlutterwithStripe_2.png)\n\nStripe 비밀 키를 .env 파일에 다음과 같이 넣어주세요:\n\n```js\nSTRIPE_SECRET = sk_test_39Aops3ZvLRexxxxxxxxxxx\n```\n\npubspec.yaml에 .env 경로를 자산에 추가해주세요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nassets:\n- assets/.env\n\n\n귀하의 .env 파일을 .gitignore에 추가하십시오.\n\n\n#Dotenv\n.env\n\n\nmain.dart\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희 앱은 단순한 홈 페이지와 결제 모달이 표시되는 버튼이 있는 페이지가 있어요.\n\n이곳은 우리의 결제 기능입니다:\n\n세 가지 간단한 단계로 나누어 보겠습니다.\n\n1단계: 결제 의도 생성 - 우리는 지불할 금액과 통화를 정의하는 createPaymentIntent 함수로 지불 의도를 만들어 시작합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 화폐와 금액을 100으로 곱한 후 Flutter_stripe에 의해 double로 변환될 때 값이 유지되도록 몸체를 포함한 Stripe에 POST 요청을 보냅니다. 그에 대한 응답으로 Stripe는 결제 의도를 다시 보내줍니다. STEP 2에서 이를 사용하여 우리의 지불 시트를 초기화할 것입니다.\n\n## STEP 2: 지불 시트 초기화\n\n7~15행에서 makePayment 함수에서 지불 시트를 초기화합니다. 여기에는 우리가 카드 세부 정보를 기입하고 지불할 지불 시트 모달을 생성할 것입니다.\n\n우리는 이전 단계에서 결제 의도로부터 얻은 client_secret를 전달합니다. 여기에서는 스타일을 포함한 다양한 매개변수에 액세스할 수 있습니다. 이를 통해 우리는 어두운 테마를 선택할 수 있습니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 단계 3: 결제 시트 표시하기\n\n마지막 단계는 모달 시트를 표시하는 것입니다.\n\n이것으로 세 번째이자 마지막 단계가 끝났습니다.\n\n팁: 결제가 성공하였을 때 또는 결제 처리 중에 오류가 발생한 경우와 같이 사용자에게 추가 응답을 알림 대화상자 형식으로 추가할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n끝났어요! 플러터 애플리케이션에 Stripe 통합이 완료되었습니다.\n\n앱을 론칭할 준비가 되셨다면 대시보드에서 테스트 모드에서 라이브 모드로 전환하고 Stripe의 지시에 따라 진행하면 됩니다.\n\n질문이나 의견이 있으시면 언제든지 알려주세요 💬, 이 기사가 유용했다면 👏👏을 눌러주시기를 잊지 마세요.\n\n여기서 전체 소스 코드를 구할 수 있어요.","ogImage":{"url":"/assets/img/2024-06-21-IntegratePaymentinFlutterwithStripe_0.png"},"coverImage":"/assets/img/2024-06-21-IntegratePaymentinFlutterwithStripe_0.png","tag":["Tech"],"readingTime":3}],"page":"5","totalPageCount":21,"totalPageGroupCount":2,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"5"},"buildId":"Is-d56jDFXkc1ZfN4DhBP","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>