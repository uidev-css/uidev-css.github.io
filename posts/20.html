<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>uidev-css</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://uidev-css.github.io///posts/20" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="uidev-css" data-gatsby-head="true"/><meta property="og:title" content="uidev-css" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://uidev-css.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://uidev-css.github.io///posts/20" data-gatsby-head="true"/><meta name="twitter:title" content="uidev-css" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | uidev-css" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/873-1e1f6fb6fd3c8994.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-498da29379dd58dc.js" defer=""></script><script src="/_next/static/-8k4Xu2rlgTZWfP5qtaGa/_buildManifest.js" defer=""></script><script src="/_next/static/-8k4Xu2rlgTZWfP5qtaGa/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UIDEV CSS</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="옵저버 디자인 패턴 - Dart" href="/post/2024-06-19-ObserverDesignPatternDart"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="옵저버 디자인 패턴 - Dart" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-ObserverDesignPatternDart_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="옵저버 디자인 패턴 - Dart" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">옵저버 디자인 패턴 - Dart</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="State Management in Flutter  외부 라이브러리 종속성 없이" href="/post/2024-06-19-StateManagementinFlutterNoThirdPartyDependencies"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="State Management in Flutter  외부 라이브러리 종속성 없이" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-StateManagementinFlutterNoThirdPartyDependencies_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="State Management in Flutter  외부 라이브러리 종속성 없이" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">State Management in Flutter  외부 라이브러리 종속성 없이</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="플러터에서 이미지를 다루는 일반적인 실수들" href="/post/2024-06-19-CommonmistakeswithImagesinFlutter"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="플러터에서 이미지를 다루는 일반적인 실수들" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-CommonmistakeswithImagesinFlutter_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="플러터에서 이미지를 다루는 일반적인 실수들" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">플러터에서 이미지를 다루는 일반적인 실수들</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Xcode 정리해서 MacBook을 빠르게 만들기" href="/post/2024-06-19-CleanYourXcodeandFreeUpHardDriveSpacetoMakeYourMacBookRunFaster"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Xcode 정리해서 MacBook을 빠르게 만들기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-CleanYourXcodeandFreeUpHardDriveSpacetoMakeYourMacBookRunFaster_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Xcode 정리해서 MacBook을 빠르게 만들기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Xcode 정리해서 MacBook을 빠르게 만들기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="플러터를 인정하지 않는 구글" href="/post/2024-06-19-GoogleDoesntAppreciateFlutter"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="플러터를 인정하지 않는 구글" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-GoogleDoesntAppreciateFlutter_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="플러터를 인정하지 않는 구글" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">플러터를 인정하지 않는 구글</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Firestore와 NoSQL - 데이터 구조화의 어려움" href="/post/2024-06-19-FirestoreandNoSQLThechallengesofstructuringourdata"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Firestore와 NoSQL - 데이터 구조화의 어려움" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-FirestoreandNoSQLThechallengesofstructuringourdata_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Firestore와 NoSQL - 데이터 구조화의 어려움" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">Firestore와 NoSQL - 데이터 구조화의 어려움</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="포괄적인 미디어 쿼리 안내" href="/post/2024-06-19-AComprehensiveMediaQueryGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="포괄적인 미디어 쿼리 안내" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-AComprehensiveMediaQueryGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="포괄적인 미디어 쿼리 안내" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">포괄적인 미디어 쿼리 안내</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="4월에는 거래소와 사기로 인해 25백만의 피해를 입었다고 합니다 이는 역사적으로 최저치를 기록했습니다 CertiK가 밝혔습니다" href="/post/2024-05-01-Aprilsees25MinexploitsandscamsmarkinghistoriclowCertiK"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="4월에는 거래소와 사기로 인해 25백만의 피해를 입었다고 합니다 이는 역사적으로 최저치를 기록했습니다 CertiK가 밝혔습니다" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-01-Aprilsees25MinexploitsandscamsmarkinghistoriclowCertiK_thumbnail.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="4월에는 거래소와 사기로 인해 25백만의 피해를 입었다고 합니다 이는 역사적으로 최저치를 기록했습니다 CertiK가 밝혔습니다" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">4월에는 거래소와 사기로 인해 25백만의 피해를 입었다고 합니다 이는 역사적으로 최저치를 기록했습니다 CertiK가 밝혔습니다</strong><div class="PostList_meta__VCFLX"><span class="date">May 1, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link posts_-active__YVJEi" href="/posts/20">20</a></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"옵저버 디자인 패턴 - Dart","description":"","date":"2024-06-19 00:11","slug":"2024-06-19-ObserverDesignPatternDart","content":"\n\n\n\u003cimg src=\"/assets/img/2024-06-19-ObserverDesignPatternDart_0.png\" /\u003e\n\n옵저버는 행동 디자인 패턴입니다. 우리는 데이터를 변경할 때 객체에 알리는 관찰자 패턴을 사용할 수 있습니다. 객체에게 \"앗, 데이터가 변경되었어. 할 일을 해라\"고 알립니다. 이는 플러터의 ChangeNotifier와 비슷합니다. 옵저버 패턴에는 Subject와 Observer 두 가지 타입의 클래스가 있습니다. Observer 클래스는 데이터 업데이트를 기다리고 우리의 사용자 정의 로직을 실행할 것입니다. Subject 클래스는 옵저버를 저장하고 데이터를 알림하기 위해 사용됩니다.\n\n# 시작해보죠\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1000/1*MRIUs1xCFX0PjO88wG1AxQ.gif\" /\u003e\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저, Observer 클래스와 update 메서드를 생성할 겁니다. 이 메서드에 대해 구체적인 옵저버들이 알림을 받겠죠.\n\n```js\nabstract class Observer {\n  void update(bool atHome);\n}\n```\n\n이제 Observer 추상 클래스를 구현하는 구체적인 옵저버들을 만들 수 있어요.\n\n```js\nclass Kettle implements Observer {\n  @override\n  void update(bool atHome) {\n    /// 여기에 사용자 정의 로직을 작성할 수 있어요\n    if (atHome) {\n      print('물 끓이는 중');\n    } else {\n      print('주전자가 꺼졌어요');\n    }\n  }\n}\n\nclass Lights implements Observer {\n  @override\n  void update(bool atHome) {\n    /// 여기에 사용자 정의 로직을 작성할 수 있어요\n    if (atHome) {\n      print('조명 켜짐');\n    } else {\n      print('모두 조명 끔');\n    }\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 Subject 클래스를 만들어 보겠습니다. 이것을 HomeManager라고 이름 짓겠습니다.\n\n```js\nclass HomeManager {\n  final List\u003cObserver\u003e _observersList = [];\n\n  /// 변경 가능한 데이터 (상태 데이터)\n  bool _atHome = false;\n\n  /// 새로운 옵서버를 목록에 추가합니다\n  void addListener(Observer observer) {\n    _observersList.add(observer);\n  }\n\n  /// 옵서버를 목록에서 제거합니다\n  void removeListener(Observer observer) {\n    _observersList.remove(observer);\n  }\n\n  /// 데이터 업데이트\n  void setData(bool atHome) {\n    _atHome = atHome;\n  }\n  \n  /// 추가된 모든 옵서버들에게 알립니다\n  void notify() {\n    for (var element in _observersList) {\n      element.update(_atHome);\n    }\n  }\n}\n```\n\n중요한 부분은 notify 메서드입니다. _observersList를 통해 반복하면서 각 옵서버 객체에 대해 update 메서드를 호출합니다. 따라서 각 옵서버는 그 데이터 변경 사항을 인식하게 됩니다. 모든 클래스를 함께 사용합시다. 주석과 함께 설명해 드렸습니다.\n\n```js\nimport 'package:observer_design_pattern/observer.dart';\n\nvoid main(List\u003cString\u003e arguments) {\n  HomeManager homeManager = HomeManager();\n\n  Lights lights = Lights();\n  Kettle kettle = Kettle();\n\n  /// 옵서버들을 목록에 추가합니다\n  homeManager.addListener(lights);\n  homeManager.addListener(kettle);\n\n  /// 데이터 업데이트\n  homeManager.setData(true);\n\n  /// 모든 옵서버에게 알림\n  ///\n  /// Kettle과 Lights가 트리거됩니다\n  homeManager.notify();\n\n  print('------옵서버 제거------');\n\n  /// Lights 옵서버를 제거합니다\n  homeManager.removeListener(lights);\n\n  homeManager.setData(false);\n\n  /// Kettle만 트리거됩니다\n  homeManager.notify();\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기 결과입니다:\n\n![옵저버 디자인 패턴](/assets/img/2024-06-19-ObserverDesignPatternDart_1.png)\n\n그게 다에요. 간단한 예제를 활용하여 옵저버 디자인 패턴을 설명해보았어요. 마음에 드셨으면 좋겠네요... 의견 주시면 감사하겠어요! 아래에서 작동하는 예제(소스 코드)를 찾을 수 있어요.\n\n![옵저버 패턴 예제](https://miro.medium.com/v2/resize:fit:1000/1*ufNPsZPqqgunmv1Bd2JrzQ.gif)","ogImage":{"url":"/assets/img/2024-06-19-ObserverDesignPatternDart_0.png"},"coverImage":"/assets/img/2024-06-19-ObserverDesignPatternDart_0.png","tag":["Tech"],"readingTime":3},{"title":"State Management in Flutter  외부 라이브러리 종속성 없이","description":"","date":"2024-06-19 00:11","slug":"2024-06-19-StateManagementinFlutterNoThirdPartyDependencies","content":"\n\n\n\u003cimg src=\"/assets/img/2024-06-19-StateManagementinFlutterNoThirdPartyDependencies_0.png\" /\u003e\n\n저희가 네이티브 안드로이드 앱을 플러터로 이꟮리는 작업을 시작한 이후로, 프로젝트에 관한 많은 어럽한 결정을 내려야 했습니다. 네이티브 앱을 개발할 때 한 실수를 반복하지 않기 위해서였죠.\n\nFlutter 환경에서 제공되는 모든 상태 관리 솔루션을 다뤄보고 어떤 것을 사용할지 결정해야 했습니다. 이 일은 실제로 힘들었습니다. Provider, Riverpod, Bloc, Cubit, MobX, GetX, Redux 등 다양한 옵션들이 있었기 때문이죠. 각각을 이해하는 데 많은 노력이 필요했고, 다양한 솔루션들을 읽고 시도한 뒤에 우리는 내부에서 너무 많은 마술이 일어나고 있다고 더 확신을 얻을 수 있었습니다.\n\n조사를 진행하다가, 서드파티 라이브러리 없이 상태 관리를 하는 방법을 사용하는 많은 앱들이 상점에 있다는 것을 알게되는 기사를 찾았습니다. 좀 더 조사해보니, 플러터에서 상태 관리를 아주 멋지게 구현한 다른 기사도 찾았습니다. 이러한 콘텐츠에서 영감을 받아 우리는 서드파티 라이브러리 없이 솔루션을 찾기 위해 조사를 시작했습니다. 이어서 저희가 어떻게 앱에서 플러터의 네이티브 자원만을 사용하여 상태 관리를 구현했는지 알려드릴게요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 앱 패턴\n\n저희는 Flutter 앱의 아키텍처로 MVVM (Model-View-ViewModel) 패턴을 선택했습니다. 네이티브 안드로이드 앱에서 편안하게 사용했던 이 패턴을 Flutter 프로젝트에도 충분히 적용할 수 있다고 확신했기 때문입니다.\n\nMVVM 패턴은 주로 세 가지 클래스로 구성됩니다:\n\n- Model: 화면에 표시할 데이터를 보유하는 클래스입니다.\n- View: Flutter에서는 이것이 화면을 나타내는 위젯입니다.\n- ViewModel: 여기에는 로직이 포함됩니다. 화면(View)과의 모든 상호작용은 ViewModel에서 메소드 호출을 일으켜야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-StateManagementinFlutterNoThirdPartyDependencies_1.png\" /\u003e\n\n## MVVM과 플러터 네이티브 리소스 병합하기\n\n우선적으로, 우리 예제를 구축하는 데 도움이 되는 몇 개의 클래스를 생성해야 합니다. 아래에는 우리 예제를 재현하기 위해 만들어야 하는 클래스들이 나와 있습니다:\n\n- user_dto.dart: 이 파일에는 DTO(Data Transfer Object)를 나타내는 클래스가 포함됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\nclass UserDto {\n  final String name;\n\n  UserDto({required this.name});\n}\n```\n\n2. user_repository.dart: 이 파일은 HTTP 페치 요청을 담당하는 클래스가 위치할 것입니다.\n\n```dart\nimport 'package:teste_artigo/user_dto.dart';\n\nclass UserRepository {\n  Future\u003cUserDto\u003e getUserData() async {\n    // 사용자 데이터를 가져오는 시뮬레이션, API 호출일 수도 있습니다. 리포지토리 파일에 위치할 것입니다.\n    await Future.delayed(const Duration(seconds: 2), () {});\n    return UserDto(name: 'John Doe');\n  }\n}\n```\n\n그런 다음 우리는 MVVM 구조를 마칠 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nValueNotifier과 ValueListenableBuilder를 사용하여 Model, View 및 ViewModel 간의 연결을 설정했어요.\n\n먼저 home_screen_state.dart 파일을 만들어볼게요. 각 화면에는 로딩 상태, 오류 상태, 성공 상태 등이 있습니다. 이러한 상태를 클래스 유형을 사용하여 구분할 거에요:\n\n```js\nabstract class HomeScreenState {}\n\nclass HomeScreenLoadingState extends HomeScreenState {}\n\nclass HomeScreenSuccessfulState extends HomeScreenState {\n  final String userName;\n\n  HomeScreenSuccessfulState(this.userName);\n}\n\nclass HomeScreenErrorState extends HomeScreenState {\n  final String errorMessage;\n\n  HomeScreenErrorState(this.errorMessage);\n}\n```\n\n우리는 원하는 만큼 많은 상태를 가질 수 있으며 각 상태는 필요한 변수를 가질 수 있어요. 심지어 abstract HomeScreenState 클래스 내에 공통 변수를 가질 수도 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음으로, ViewModel 클래스를 생성해야 합니다:\n\n```js\nimport 'package:flutter/cupertino.dart';\nimport 'package:teste_artigo/home_screen_state.dart';\nimport 'package:teste_artigo/user_repository.dart';\n\nclass HomeScreenViewModel {\n  var state = ValueNotifier\u003cHomeScreenState\u003e(HomeScreenLoadingState());\n  final userRepository = UserRepository();\n\n  Future\u003cvoid\u003e onInit() async {\n    _tryToFetchUserData();\n  }\n\n  Future\u003cvoid\u003e onRefreshUserData() async {\n    _tryToFetchUserData();\n  }\n\n  Future\u003cvoid\u003e _tryToFetchUserData() async {\n    try {\n      state.value = HomeScreenLoadingState();\n      final response = await userRepository.getUserData();\n      state.value = HomeScreenSuccessfulState(response.name);\n    } catch (e) {\n      state.value = HomeScreenErrorState('An error occurred');\n    }\n  }\n}\n```\n\n이 클래스에서 우리는 공개 메서드 이름이 UI 클래스에 대한 콜백을 나타내는 것을 확인할 수 있습니다. 메서드 이름에서 사용자 데이터를 가져올 것이라는 것을 명시적으로 명시하지 않습니다.\n대신, UI가 초기화되거나 사용자 데이터를 새로 고침하길 요청할 때 특정 메서드가 호출되어야 함을 간단히 나타냅니다. 로직은 UI에서 숨어 있는 비공개 메서드인 `_tryToFetchUserData` 메서드 내부에 있습니다.\n\n또한, 데이터를 업데이트해야 할 때 적절한 상태 유형 및 매개변수와 함께 state 변수의 값을 업데이트해야 함을 알 수 있습니다.\n이 변수는 스트림입니다. 이미 변경되면 청취자에게 알리는 책임을 지고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마지막으로 UI가 있습니다:\n\n```js\nimport 'package:flutter/material.dart';\nimport 'package:teste_artigo/home_screen_view_model.dart';\n\nimport 'home_screen_state.dart';\n\nclass HomeScreen extends StatefulWidget {\n  const HomeScreen({key});\n\n  @override\n  State\u003cHomeScreen\u003e createState() =\u003e _MyHomePageState();\n}\n\nclass _MyHomePageState extends State\u003cHomeScreen\u003e {\n  late final HomeScreenViewModel _vm;\n\n  @override\n  void initState() {\n    super.initState();\n    _vm = HomeScreenViewModel();\n    _vm.onInit();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        backgroundColor: Theme.of(context).colorScheme.inversePrimary,\n        title: const Text('상태 관리'),\n      ),\n      floatingActionButton: _buildFloatingActionButton(),\n      body: _buildBody(),\n    );\n  }\n\n  Widget _buildFloatingActionButton() {\n    return FloatingActionButton(\n      onPressed: () =\u003e _vm.onRefreshUserData(),\n      tooltip: '새로 고침',\n      child: const Icon(Icons.refresh),\n    );\n  }\n\n  Widget _buildBody() {\n    return Column(\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: [\n        ValueListenableBuilder(\n          valueListenable: _vm.state,\n          builder: (context, state, _) {\n            switch (state.runtimeType) {\n              case HomeScreenLoadingState:\n                return const Center(child: CircularProgressIndicator());\n              case HomeScreenSuccessfulState:\n                final successfulState = state as HomeScreenSuccessfulState;\n                return Center(child: Text(successfulState.userName));\n              case HomeScreenErrorState:\n                final errorState = state as HomeScreenErrorState;\n                return Center(child: Text(errorState.errorMessage));\n              default:\n                return Container();\n            }\n          },\n        )\n      ],\n    );\n  }\n}\n```\n\nValueListenableBuilder 내에서 \"마법\"이 일어납니다: 상태의 유형에 따라 특정 위젯을 렌더링하여 표시합니다.\n\n빌더 함수는 ViewModel에서 상태 변수가 변경될 때마다 호출되므로 setState를 호출하거나 다른 작업을 걱정할 필요가 없습니다. 코드의 더 깊은 부분에서 ValueListenableBuilder를 사용하여 전체 화면을 다시 렌더링하는 것을 피할 수도 있습니다. 그러나 중요한 점은 그것이 필요하지 않다는 것입니다: Flutter는 이미 전체 화면을 렌더링하도록 최적화되어 있으며, setState를 사용하여 화면을 업데이트하도록 만들어졌기 때문에 기존에 렌더링 된 것을 다시 렌더링하는 방법을 알고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 결론\n\n이게 다에요!  별도의 외부 의존성이 없어 매우 간단해요.\n\n이것은 아주 간단한 예시라는 것을 이해합니다. 더 복잡한 화면을 만들기 시작하면 더 많은 질문이 생겨나고, 이렇게 간단한 해결책을 유지하는 것이 더 어려워질 수도 있습니다. 그러나 저희는 이 방법을 성공적으로 사용하여 매우 복잡한 화면을 만들고 있습니다 (실제로 회사의 주요 제품인 전체 앱을 Flutter로 이주 중이기도 합니다), 그리고 이 방법이 저희에게 아주 잘 작동하고 있어요.\n\n의문이 있거나 의견을 주고 싶다면, 언제든지 LinkedIn에서 제게 직접 메시지를 남겨주세요. 언제든지 대화를 나누기 위해 친절히 준비되어 있을게요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예제의 코드는 이 저장소에서 찾을 수 있어요.","ogImage":{"url":"/assets/img/2024-06-19-StateManagementinFlutterNoThirdPartyDependencies_0.png"},"coverImage":"/assets/img/2024-06-19-StateManagementinFlutterNoThirdPartyDependencies_0.png","tag":["Tech"],"readingTime":7},{"title":"플러터에서 이미지를 다루는 일반적인 실수들","description":"","date":"2024-06-19 00:09","slug":"2024-06-19-CommonmistakeswithImagesinFlutter","content":"\n\n이미지는 대부분의 앱에서 사용하는 핵심 기능 중 하나입니다. 그러나 많은 사용자들은 간단히 피할 수 있는 실수로 응용 프로그램 성능에 부정적인 영향을 줄 수 있습니다. 몇 가지 주요 사례를 살펴보겠습니다.\n\n# 1. 대형 이미지 자산\n\n이는 많은 메모리와 처리 시간을 차지할 수 있습니다. 메모리에 디코딩된 비트맵 크기는 그들의 해상도에 직접적으로 의존하며, 이는 앱 성능에 큰 영향을 미칠 수 있습니다.\n\n## 번들화된 이미지 자산의 크기를 줄이세요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n대부분의 스마트폰은 화면 너비가 1200 픽셀 이하이므로 자산을 그에 맞게 조절하는 것이 좋습니다. 예를 들어, 7500x5000 픽셀의 사진을 살펴보겠습니다. 이러한 크기의 비트맵을 저장하는 데 사용되는 RAM 양은 112 Mb로, 이는 Flutter의 이미지 캐시의 기본 크기를 초과합니다. 여기서의 규칙은 비트맵 크기의 합이 단일 앱 세션에 100 Mb를 초과해서는 안 된다는 것입니다. 그렇지 않으면 이미지가 다시 디코딩되어 부드럽지 않은 사용자 경험으로 이어질 수 있습니다.\n\n이미지 해상도를 1200x800으로 줄이면 비트맵 크기가 2.8 Mb로 줄어듭니다. 이러한 계산은 이 도구를 사용하여 수행됩니다.\n\n그러나 파일을 통제할 수 있는 경우에만 이렇게 할 수 있습니다. 원격 소스에서 이미지가 오는 경우에는 어떻게 해야 할까요? 또는 동일한 이미지가 다른 크기의 레이아웃에 사용될 수 있는 경우엔 어떻게 해야 할까요?\n\n## cacheWidth 및 cacheHeight 사용하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 매개변수를 제공함으로써 이미지의 디코딩 크기를 지정할 수 있어요. 계산에 MediaQuery.of(context).devicePixelRatio를 포함하는 것을 잊지 마세요. 같은 이미지 자산이라도 cacheHeight/cacheWidth가 다르면 캐시에서 서로 다른 이미지로 간주될 거예요.\n\n```js\n    Image.asset(\n      \"assets/6392956.jpg\",\n      height: 100,\n      width: 300,\n      cacheHeight: (100 * MediaQuery.of(context).devicePixelRatio).toInt(),\n    );\n```\n\n캐시에 미치는 영향을 테스트해보려면 몇 가지 측정을 해봐요. 현재 캐시 크기에는 PaintingBinding 클래스를 통해 액세스할 수 있어요:\n\n```js\nPaintingBinding.instance.imageCache.currentSizeBytes;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n크기가 큰 이미지는 예상대로 캐시 크기가 증가합니다. 그러나 원본 이미지가 너무 크기 때문에 전혀 캐시에 추가되지 않았고, 결과적으로 이미지를 표시할 때마다 디코딩하는 문제가 발생했습니다. 어떻게 보이는지 살펴봅시다:\n\n![image](https://miro.medium.com/v2/resize:fit:576/1*HXRzZzdr7z5qeMwa4IFV6g.gif)\n\n위 동영상에서는 캐시 크기 제한을 초과하는 이미지가 포함된 화면이 열릴 때마다 지연이 발생하며, 크기가 조정된 이미지의 경우에는 화면이 처음 열릴 때만 지연이 발생합니다.\n\n# 2. WebP 자산을 사용하지 않기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n번들된 에셋을 최적화하는 또 다른 방법은 WebP 형식을 사용하는 것입니다. 이를 이용하면 이미지 파일 크기를 크게 줄일 수 있습니다. 무료 온라인 변환 도구가 많이 있고, Flutter는 기본적으로 WebP를 지원합니다.\n\n# 3. Opacity 위젯 사용 시 필요하지 않은 경우에\n\nOpacity 위젯은 매우 유용하고 편리하지만, 우리가 원할 때마다 사용해서는 안 됩니다. 왜냐하면 사용할 때마다 새 렌더링 레이어를 생성하기 때문입니다. 이 위젯이 화면에 여러 번 포함되어 있는 경우 어떻게 되는지 살펴봅시다:\n\n```js\n    Opacity(\n      opacity: 0.5, // \u003c- 가능한 경우 이런식으로 하지 말기\n      child: Image.asset(\n        \"assets/6392956.jpg\",\n        height: 100,\n        width: 300,\n      ),\n    );\n```  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그럼 개발 도구를 열어서 렌더 레이어를 확인해보세요:\n\n![image0](/assets/img/2024-06-19-CommonmistakeswithImagesinFlutter_0.png)\n\n![image1](/assets/img/2024-06-19-CommonmistakeswithImagesinFlutter_1.png)\n\n각 레이어는 독립적으로 렌더링되므로 많은 계산이 발생합니다. Opacity 위젯 대신 이미지와 색상을 혼합하는 것이 권장되는 방법이니 문서를 참고해주세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\nImage.asset(\n  \"assets/6392956.jpg\",\n  height: 100,\n  width: 300,\n  color: Colors.white.withOpacity(0.5), // \u003c- 이 부분\n  colorBlendMode: BlendMode.modulate, // \u003c- 그리고 이 부분\n  cacheHeight: (100 * MediaQuery.of(context).devicePixelRatio).toInt(),\n),\n```\n\n이렇게 하면 모든 이미지를 동일한 렌더링 레이어에 표시할 수 있습니다:\n\n![Image](/assets/img/2024-06-19-CommonmistakeswithImagesinFlutter_2.png)\n\n# 4. 이미지 에셋을 미리 로드하지 않기\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플러터는 이미지를 ImageCache에 수동으로 푸시할 수 있는 기능을 제공합니다. 한 가지 이전 이미지로 시도해 봅시다:\n\n```js\nTextButton(\n  child: const Text(\"이미지 미리 캐시\"),\n  onPressed: () async {\n    cacheSize() =\u003e PaintingBinding.instance.imageCache.currentSizeBytes.toString();\n    print(cacheSize());\n    final asset = Image.asset(\n      \"assets/6392956.jpg\",\n      height: 100,\n      width: 300,\n      cacheHeight: (100 * MediaQuery.of(context).devicePixelRatio).toInt(),\n    );\n    await precacheImage(asset.image, context); // \u003c- 이미지 미리 캐싱\n    print(cacheSize());\n  },\n)\n```\n\n출력:\n\n\u003cimg src=\"/assets/img/2024-06-19-플러터에서이미지와관련된일반적인실수_3.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n따라서 동일한 디코딩 크기를 갖는 이미지가 포함된 화면을 열 때 결과가 즉시 열리며 캐시에서 제거되지 않는 한 사용됩니다. 이 기술을 사용할 때 캐시의 크기가 제한되어 있음을 주의해야 합니다.\n\n# 5. 네트워크 이미지 캐싱하지 않기\n\n앱이 네트워크에서 이미지를 가져오는 경우, 매번 이러한 이미지를 로드하는 것은 의미가 없을 것입니다. 대신 cached_network_image 라이브러리나 다른 대안을 사용할 수 있습니다. 라이브러리 문서는 매우 설명이 자세히 되어 있습니다.\n\n본 글이 유용하게 읽으셨기를 바랍니다. 새로운 유익한 기술을 발견할 때마다 이를 업데이트할 것이며, 최신 정보를 얻으려면 트위터에서 저를 팔로우해주세요. 전체 코드를 읽고 싶다면 리포지토리를 확인해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![2024-06-19-CommonmistakeswithImagesinFlutter_4.png](/assets/img/2024-06-19-CommonmistakeswithImagesinFlutter_4.png)","ogImage":{"url":"/assets/img/2024-06-19-CommonmistakeswithImagesinFlutter_0.png"},"coverImage":"/assets/img/2024-06-19-CommonmistakeswithImagesinFlutter_0.png","tag":["Tech"],"readingTime":5},{"title":"Xcode 정리해서 MacBook을 빠르게 만들기","description":"","date":"2024-06-19 00:08","slug":"2024-06-19-CleanYourXcodeandFreeUpHardDriveSpacetoMakeYourMacBookRunFaster","content":"\n\n\u003cimg src=\"/assets/img/2024-06-19-CleanYourXcodeandFreeUpHardDriveSpacetoMakeYourMacBookRunFaster_0.png\" /\u003e\n\niOS 앱을 개발하고 Xcode가 MacBook을 느리게 만드는 걸 느끼고 있나요? 걱정 마세요! 유료 소프트웨어에 의존하지 않는 완벽한 기사를 찾았습니다. 이 안내서를 마치면 Xcode 환경을 정리하고 가치 있는 하드 드라이브 공간을 확보하여 개발 프로세스를 훨씬 빠르게 만들 수 있습니다.\n\nXcode는 iOS 앱을 개발하는 데 훌륭한 도구이지만 시간이 지남에 따라 많은 불필요한 파일을 축적하기 마련입니다. 이는 시스템을 느리게 만들고 소중한 디스크 공간을 소비할 수 있습니다. 이 기사에서는 내장된 도구와 명령어만을 사용하여 Xcode 환경을 정리하는 중요한 단계를 안내해 드리겠습니다. 유료 소프트웨어가 필요하지 않습니다!\n\n시작해보고 공간을 확보하고 성능을 개선하기 위해 안전하게 제거할 수 있는 일부 폴더를 살펴보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 1: Xcode 로그\n\n경로: ~/Library/Developer/Xcode/iOS Device Logs\n\n시간이 지남에 따라 Xcode 로그도 많은 디스크 공간을 차지할 수 있습니다. 이 로그는 디버깅에 유용하지만 필요하지 않은 경우 안전하게 삭제할 수 있습니다. 로그 디렉토리로 이동하여 모든 로그를 삭제하세요:\n\n```js\ncd ~/Library/Developer/Xcode/iOS Device Logs\nrm -rf *\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이는 깔끔한 개발 환경을 유지하는 데 도움이 됩니다.\n\n## 2: 앱 캐시 빌드\n\n경로: ~/Library/Developer/Xcode/DerivedData\n\n프로젝트를 빌드할 때 Xcode가 파생 데이터를 많이 생성합니다. 이 데이터는 안전하게 삭제할 수 있으며 다음 프로젝트 빌드 시 다시 생성됩니다. DerivedData 디렉토리로 이동하여 모든 하위 디렉터리를 제거하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```sh\ncd ~/Library/Developer/Xcode/DerivedData\nrm -rf *\n```\n\n이 방법을 사용하면 상당한 공간을 확보할 수 있습니다.\n\n## 3: 사용하지 않는 디바이스\n\n경로: ~/Library/Developer/CoreSimulator/Devices\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nXcode를 사용하면서 시간이 지남에 따라 테스트 목적으로 많은 시뮬레이터 장치가 생성됩니다. 이러한 시뮬레이터 중 많은 것들이 더 이상 사용되지 않으며 안전하게 삭제할 수 있습니다. 사용되지 않는 시뮬레이터를 삭제하려면 터미널을 열고 다음 명령어를 실행하십시오:\n\n```js\nxcrun simctl delete unavailable\n```\n\n이 명령어를 실행하면 더 이상 필요하지 않은 시뮬레이터를 삭제하여 하드 드라이브 공간을 확보할 수 있습니다.\n\n## 4: 오래된 장치 지원 파일\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n경로: ~/Library/Developer/Xcode/iOS DeviceSupport\n\niOS 기기를 MacBook에 연결하면 Xcode가 해당 기기의 지원 파일을 저장합니다. 이러한 파일은 여러 기기를 연결하거나 iOS 버전을 업데이트한 경우 특히 빠르게 증가할 수 있습니다. 지정된 경로로 이동하여 더 이상 필요하지 않은 이전 iOS 버전과 관련된 디렉토리를 수동으로 삭제하세요.\n\n예를 들어, 더 이상 해당 iOS 버전을 대상으로 하지 않는 경우 9.0.0과 같이 명명된 폴더를 안전하게 삭제할 수 있습니다.\n\n## 5: 불필요한 캐시 파일\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 Markdown 형식으로 변경해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 6: 불필요한 아카이브\n\n경로: ~/Library/Developer/Xcode/Archives\n\nXcode에서 빌드를 아카이브할 때마다, 해당 아카이브는 Archives 디렉토리에 저장됩니다. 이러한 아카이브는 빠르게 누적되어 많은 공간을 차지할 수 있습니다. 이를 정리하려면, Archives 디렉토리로 이동하여 더 이상 필요하지 않은 이전 아카이브를 모두 또는 선택적으로 삭제하십시오:\n\n```bash\ncd ~/Library/Developer/Xcode/Archives\nrm -rf *\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 작업을 수행하면 빌드를 자주 아카이브하는 경우 상당한 공간을 절약할 수 있습니다.\n\n## 7: 기타 불필요한 파일\n\n경로: ~/Library/Caches/..\n\n캐시 디렉토리에는 Xcode를 포함한 다양한 애플리케이션의 캐시된 파일이 저장됩니다. 이러한 파일을 지우려면 캐시 디렉토리로 이동하여 모든 하위 디렉토리를 제거하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```sh\ncd ~/Library/Caches\nrm -rf *\n```\n\n이 단계를 따르면 MacBook에서 중요한 공간을 확보할 수 있고 Xcode를 원할하게 실행할 수 있습니다. 이 방법들은 모두 무료이며 기본 도구를 사용하기 때문에 별도의 소프트웨어를 다운로드할 필요가 없습니다. 유료 소프트웨어가 필요하지 않습니다. 이미 Mac에서 사용할 수 있는 도구들만 있으면 됩니다! 즐겁게 코딩하고 더 빠르고 효율적인 개발 경험을 즐기세요!","ogImage":{"url":"/assets/img/2024-06-19-CleanYourXcodeandFreeUpHardDriveSpacetoMakeYourMacBookRunFaster_0.png"},"coverImage":"/assets/img/2024-06-19-CleanYourXcodeandFreeUpHardDriveSpacetoMakeYourMacBookRunFaster_0.png","tag":["Tech"],"readingTime":3},{"title":"플러터를 인정하지 않는 구글","description":"","date":"2024-06-19 00:06","slug":"2024-06-19-GoogleDoesntAppreciateFlutter","content":"\n\n또 하루, 또 하나의 \"Google이 Flutter를 제거할까?\" 글이 올라왔어요. 이젠 거의 유쾌하다고 해야하나요?\n\n이전에 Flutter에 대한 생각을 표현한 적이 있습니다. 그것은 단순히 실패하기에는 너무 크다고 생각해요. 하지만 구글이 정말 Flutter를 제대로 인정해주는지는 장담하기 어렵네요.\n\n요게 좀 어이없는 글인데요, 제가 거의 홍보글 같다고 생각할 정도거든요. 왜냐하면 Google IO는 여러 개의 키노트로 이루어져 있으며 Flutter만큼 Google이 진지하게 다뤄야 할 프로젝트는 아니기 때문이죠.\n\n하지만 눈에 띈 것은 이 부분이었어요: \"Gemini Flash 1.5 통합 예제를 본 결과, JavaScript, Python, Kotlin, Swift 예제는 있었지만 Dart나 심지어 Go는 없었어요\"\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n얼마 전에 Firebase가 너무 비싸다고 말한 글을 썼었죠. 대안을 찾고 있었어요. Firebase 글에서는 Supabase에 대해 이야기했어요. 그리고, 네, Supabase는 정말 흥미로운 대안이에요. 하지만 저는 PocketBase도 살펴보고 있어요.\n\nPocketBase를 사용하는 사람들이 정말 좋아하는 것 같아요. 그리고 이 프로젝트는 정말 작고 효율적이에요. PocketBase의 전체 실행 파일은 13MB밖에 안 됩니다. 13MB보다 큰 글꼴도 많이 있죠. 이렇게 작은 크기에 전체 백엔드를 얻을 수 있다는 게 정말 놀랍네요. 그리고 다른 백엔드에 비해 아주 적은 메모리를 차지하고 있어요.\n\n어쨌든, 내 요구 사항을 충족하는 백엔드를 찾는 평가 과정 중에 이 백엔드가 무엇을 할 수 있는지 확인해봐야 해요. 제가 주로 필요로 하는 것은 다음과 같아요: 인증, 클라우드 함수, 실시간 리스너, 그리고 오프라인 기능입니다. 실시간 리스너와 오프라인 기능을 모두 지원하는 데이터베이스를 찾는 건 의외로 힘들어요. 아마 제가 오프라인을 직접 구현해야 할 것 같아요. 그러면 인증, 실시간 리스너, 그리고 클라우드 함수만 있으면 충분할 것 같아요.\n\n아, 그리고 충돌 보고와 푸시 알림도 있지만, 무료로 사용할 수 있는 Crashlytics와 Firebase Messaging을 계속 사용해야 할 것 같아요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저는 Supabase와 PocketBase 둘 다 살펴봤어요. 둘 다 제가 원하는 기능을 갖추고 있더라구요. 오프라인을 지원하지 않는다는 게 좀 아쉽긴 한데, 아마 제가 직접 구현해야할 것 같아요. 근데 문서를 살펴보니 흥미로운 점이 있더라구요. Supabase는 이렇고요:\n\n![Supabase image](/assets/img/2024-06-19-GoogleDoesntAppreciateFlutter_0.png)\n\n그리고 PocketBase는 이렇습니다:\n\n![PocketBase image](/assets/img/2024-06-19-GoogleDoesntAppreciateFlutter_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n코드 예시에 Dart가 포함되어 있다는 건 놀라운 일이에요. 왜냐하면 제가 예전에는 Flutter 개발자만이 중요하게 여기는 작은 언어로만 알고 있었거든요. Flutter 개발자 수가 많지 않다고 생각했거든요. 사실, Flutter를 배우기 전까지는 Dart라는 언어를 들어본 적이 없었어요.\n\n다른 회사들도 자사의 문서에서 Dart를 언급한다는 소문을 들었어요. 대기업인 RevenueCat와 Google 등이 말이에요. 두 개나 세 개의 코드 예시만 나열된 페이지에서 Dart가 포함되어 있다는 건 예상 밖인 일이었어요.\n\n아니면, Dart를 사용하는 프레임워크가 생각보다 많았거나 Flutter가 놀랍도록 인기가 많은 것일지도 몰라요.\n\n저는 Flutter가 절대 멸망하지 않을 거라고 의심스러웠거든요... 제트팩 컴포즈가 인기를 얻기 전까진요. 왜냐하면 제트팩 컴포즈는 Flutter에서 많이 영감을 받았거든요. 사실, 코틀린을 사용하는 Flutter 정도라고 할 수 있어요. 근데 문서엔 코틀린이나 자바라는 언어가 언급되지 않는 거죠. 양쪽 모두 없다니까요. 겨루기 보단 함께 성장하는 게 좋죠. 좀은 경쟁이 되겠네요. 😉\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n음, 그리고 'Appwrite'라는 세 번째 백엔드도 있더라구요. 이상한 가격 정책 때문에 사용할 계획은 없고 많이 언급되지 않는 것 같아요. 하지만 그 문서에서 플러터(Flutter)와 코틀린(Kotlin)도 언급한다고 해요.\n\n![이미지](/assets/img/2024-06-19-GoogleDoesntAppreciateFlutter_2.png)\n\n그런데 플러터에 모든 주목을 받는 것에도 불구하고, 구글이 그들이 손에 쥔 것을 정말로 가치 있게 여기지 않는 것 같아요. 개발자 기조를 보는데, 그들은 플러터에 대해 이야기하기 시작한 건 45분 정도가 지난 후였어요. 그리고 이야기를 시작하자마자 2분도 안 되어 씩 간단히 소개하고 그 이후에 새로운 파이어베이스 로고가 얼마나 멋지다고 말하기 시작했어요.\n\n![이미지](/assets/img/2024-06-19-GoogleDoesntAppreciateFlutter_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플러터가 계속해서 코틀린 멀티플랫폼에 대해 이야기할 때 플러터가 충분한 시간을 얻지 못한 것 같아요. 계속해서 그 내용을 살펴보고 있었는데, “코틀린 멀티플랫폼에 대해 아직도 이야기를 다 끝내지 않았나요?”라고 생각했어요. 그 내용을 다루는데 더 많은 주목을 받은 것은 Gemini 뿐이에요.\n\n그래, Gemini는 멋지긴 한데, 이에 대해 많은 시간을 할애해야 한다고는 생각하지 않아요. 특히 Gemini가 하는 대부분의 것들이 그다지 인상적이지 않다는 점에서요.\n\nGemini가 Firebase Cloud Functions 로그를 설명하도록 하는 버튼이 있는 건 알고 계시나요? 그리 유용하지 않아요. 제가 경고를 설명하도록 요청했는데, 경고에 대한 정보를 알려줄 줄 알았는데 아니었어요. 대신 그 경고를 발생시킨 IP 주소만 알려주더라구요.\n\n그리고 Gemini는 아직도 주요 환각 문제를 가지고 있어요. 심지어 AI 환각으로 인한 취약점까지 생겼다고 하더라구요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아마 그렇게 나쁘지는 않았습니다. 지난 해에 플러터에 더 많은 시간을 할애했고, 플러터 3.22의 변경 사항은 그다지 놀라운 것이 아닙니다. 대부분 웹 어셈블리와 성능 개선 뿐이에요. 하지만 그 성능 개선은 상당히 인상적입니다. iOS의 GPU 사용량과 전력 소비가 50% 감소했다고요? 그렇죠.\n\n그리고 웹 어셈블리? 저는 웹 어셈블리에 대해 진지한 우려가 있어서 여기서 논의했습니다. 또한 플러터 문서를 찾다가 이것을 보았어요:\n\n![이미지](/assets/img/2024-06-19-GoogleDoesntAppreciateFlutter_4.png)\n\niOS에서 무슨 문제인지 잘 모르겠네요. 모바일 Safari는 웹 어셈블리를 지원해야할 텐데 말이죠. 아마도 웹 GC(가비지 컬렉션) 관련 문제일까요? 어쨌든, iOS에서 지원하지 않는다면 큰 문제가 될 겁니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그래도 Flutter는 더 많은 관심을 받아야 한다고 생각해요. 특히 개발자 키노트 전체에서 가장 큰 반응을 얻었을 때에. 구글 I/O 전체에 이루어진 것 같아요, 비록 전부 다는 보지 않았지만 말이에요.\n\n그냥 구글이 Flutter를 충분히 인정하지 않는 것 같아요.\n\n사람들은 종종 묻곤 해요, \"만약 구글이 Flutter를 포기한다면 어떻게 될까?\" 제 의견은 이미 알려졌죠. 그렇게 될 것 같진 않다고 생각해요. 하지만 구글이 Flutter를 포기한다 해도 그것은 Flutter를 없애지 않을 거에요. 그만큼 Flutter는 크고 이미 많은 팬들을 가지고 있거든요. 이렇게 말이에요.\n\n개발자 커뮤니티에 이미 너무 깊게 뿌리내린 것 같아요. 도큐먼트가 어디서든 찾아볼 수 있어요. Swift나 Kotlin, Java 도큐먼트보다 더 많은 Dart 도큐먼트가 있어요. Flutter는 이미 인정받았어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGoogle이 Flutter를 계속 추구할 가치가 없다고 결정하더라도 다른 누군가가 계속해서 작업을 이어나갈 것이라고 확신해요. 많은 사람들에게 너무 중요한 프로젝트이기 때문이죠.","ogImage":{"url":"/assets/img/2024-06-19-GoogleDoesntAppreciateFlutter_0.png"},"coverImage":"/assets/img/2024-06-19-GoogleDoesntAppreciateFlutter_0.png","tag":["Tech"],"readingTime":5},{"title":"Firestore와 NoSQL - 데이터 구조화의 어려움","description":"","date":"2024-06-19 00:03","slug":"2024-06-19-FirestoreandNoSQLThechallengesofstructuringourdata","content":"\n\n\u003cimg src=\"/assets/img/2024-06-19-FirestoreandNoSQLThechallengesofstructuringourdata_0.png\" /\u003e\n\n여러분은 오랜 시간 동안 Firebase 도구를 사용하여 푸시 알림부터 인증, Firestore 데이터베이스까지 더 빨리 앱을 구축할 수 있었습니다. 올해의 Google I/O에서 Firestore가 이제 데이터 연결을 통해 SQL을 지원한다는 발표가 있었습니다. 이제 개발자들은 NoSQL과 SQL 중에서 선택할 수 있습니다.\n\nSQL에서는 테이블을 만들기 위한 구조가 정의되어 있습니다. 열과 행을 가진 엑셀 스프레드시트와 유사합니다. 사용자가 새 속성(열)을 추가할 때마다 모든 요소(행)에 해당 속성을 포함해야 합니다. 데이터를 검색하기 위해 SQL 언어를 사용하여 테이블에서 데이터를 가져오거나 다중 열에서 데이터를 결합하거나 데이터베이스를 편집, 삭제, 업데이트할 수 있습니다.\n\n반면에 NoSQL은 JSON 형식으로 모든 유형의 데이터를 추가할 수 있습니다. Firestore에서는 문서와 컬렉션이 있습니다. 문서는 데이터베이스의 개별 객체로 SQL의 행과 해당되며, 컬렉션은 다른 문서를 그룹화하여 SQL의 테이블과 유사합니다. 그러나 컬렉션 내에서는 다른 매개변수가 있는 문서를 가질 수 있습니다. 특정 문서에 hungerMeter를 추가하고 다른 문서에 favoriteDrink를 추가하려면 이렇게 할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNoSQL은 데이터를 관리하는 방법에 대해 다르게 생각하도록 격려합니다. 중요한 문제 중 하나는 서로 다른 컬렉션의 문서가 관계를 가지고 있을 때, 우리는 어떻게 그를 관리해야 하는지에 대한 문제입니다. 예를 들어, 프로그래머를 위한 컬렉션이 있고 언어를 위한 컬렉션이 있는 경우에는 어떻게 프로그래머를 favoriteLanguage 필드와 함께 모델링해야 할까요? 우리는 SQL에서와 같이 언어의 ID를 참조해야 할까요, 아니면 언어 컬렉션에서 값을 복사해야 할까요?\n\n이것은 Firestore NoSQL 데이터베이스에서 데이터의 정규화와 비정규화 주변의 주요 논의입니다. 바로 살펴보겠습니다.\n\n# Firebase에서 정규화를 사용하는 데 어려움이 있는 이유\n\n장난감 공장의 관리를 용이하게 하는 앱을 만들어야 합니다. 첫 번째 작업은 다음과 같은 디자인을 가진 장난감 제조 목록을 표시하는 간단한 대시보드를 만드는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-FirestoreandNoSQLThechallengesofstructuringourdata_1.png\" /\u003e\n\n각 장난감에는 소재를 포함한 여러 속성이 있을 것입니다. 이 속성은 카드 위젯에 표시됩니다. SQL과 유사한 방식으로, 우리는 두 개의 컬렉션을 만듭니다: toys와 materials. 이 컬렉션들의 속성은 다음 다이어그램에 표시되어 있습니다.\n\n\u003cimg src=\"/assets/img/2024-06-19-FirestoreandNoSQLThechallengesofstructuringourdata_2.png\" /\u003e\n\nSQL에서는 외래 키를 사용하여 테이블 간의 관계를 생성합니다. 그러나 Firestore에는 외래 키가 없습니다. 대신 DocumentReference를 사용할 수 있습니다. DocumentReference는 다른 문서를 참조하는 데 사용할 수 있는 값 타입입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이젠 모든 장난감을 나열하고 싶으면 어떻게 될까요?\n\n장난감 컬렉션에서 모든 문서를 가져오면, 소재에 대한 정보가 없을 것이고 DocumentReference 목록만 있을 겁니다. 해당 정보를 검색하려면 각 레퍼런스별로 get을 사용하고 그 정보를 사용하여 Card UI를 만들기 위해 장난감 객체를 생성해야 합니다.\n\n![이미지](/assets/img/2024-06-19-FirestoreandNoSQLThechallengesofstructuringourdata_3.png)\n\n만약 공장에 1,000종류의 장난감이 있다면, Firebase에서 1,001번의 읽기가 필요할 수 있습니다: 장난감 컬렉션에서 모든 문서를 검색하고, 각 DocumentReference를 읽기 위해 한 번씩이요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n또한, 모든 쿼리 로직 및 데이터 병합이 클라이언트 앱에서 이루어지기 때문에, 다음 코드 스니펫에서 보여지는 것처럼 더 복잡한 클라이언트 측 코드를 가질 수 있습니다:\n\n```js\nFuture\u003cList\u003cToy\u003e\u003e fetchToysAndMaterials() async {\n  final firestore = FirebaseFirestore.instance;\n\n  // 단계 1: 모든 장난감 가져오기\n  final toySnapshot = await firestore.collection('toys').get();\n  final toyDocs = toySnapshot.docs;\n\n  // 단계 2: 장난감 ID와 재료 문서 레퍼런스 맵 생성\n  final toyToMaterialReference = \u003cString, DocumentReference\u003e{};\n  final toyToMaterial = \u003cString, Material\u003e{};\n  for (final doc in toyDocs) {\n    toyToMaterialReference[doc.id] = doc[\"material\"] as DocumentReference;\n  }\n\n  // 단계 3: 재료를 위한 일괄 읽기\n  for (final key in toyToMaterialReference.keys) {\n    final materialSnapshot = await toyToMaterialReference[key]!.get();\n    toyToMaterial[key] = Material.fromFirebase(materialSnapshot);\n  }\n  \n  // 단계 4: 재료 정보를 포함한 Toy 객체 생성\n  final toys = toyDocs.map((doc) {\n    Material material = toyToMaterial[doc.id];\n    return Toy.fromFirebase(doc, material);\n  }).toList();\n\n  return toys;\n}\n```\n\n여러 장난감이 동일한 재료를 가질 수 있는지 확인하기 위해 코드를 개선할 수 있습니다. 이를 위해 Map`Toy, Material`을 Map`Material, List`Toy`로 변경할 수 있습니다. 또한 문서를 수정하여 특정 ID를 노출시킨 후 whereIn 조건으로 where 연산자를 사용하는 쿼리를 만들 수 있습니다. 그러나 whereIn은 검색할 수 있는 문서 수에 제한이 있습니다. Firebase 레퍼런스 문서에 명시되어 있듯이, 이는 페이지네이션을 다뤄야 함을 의미합니다.\n\n그러므로, 쿼리를 최적화할 간편한 옵션을 찾을 수 없지만, Firebase에서 재미있는 무료 티어를 제공하기 때문에 우리 솔루션이 요구하는 읽기 작업 수에 대해 어느 정도 타협할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러나 어느 날 우리 매니저가 들어와서, 그녀가 우리에게 Card 위젯에서 Toy의 Color도 출력하라는 작업을 부여합니다.\n\n![이미지](/assets/img/2024-06-19-FirestoreandNoSQLThechallengesofstructuringourdata_4.png)\n\n같은 방식을 따라, 우리는 colors라는 새로운 컬렉션을 만들어 이제 다음과 같은 데이터베이스 다이어그램을 가지게 되었습니다:\n\n![이미지](/assets/img/2024-06-19-FirestoreandNoSQLThechallengesofstructuringourdata_5.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nToy 객체를 만들어 이 카드 위젯을 구축하기 위해 자료 및 색상 컬렉션으로부터 DocumentReference를 모두 검색하고 적절한 맵을 만들어 그들 간의 관계를 캐시해야 합니다.\n\n![image](/assets/img/2024-06-19-FirestoreandNoSQLThechallengesofstructuringourdata_6.png)\n\n1,000개의 Toy 목록에 대한 읽기 작업에 대해, 최악의 경우, 모든 Toy 문서를 검색하기 위해 1번 읽기, 자료 문서를 1,000번 읽기, 색상 문서를 1,000번 읽기 해야 하며, 이로 인해 목록 하나를 만들기 위해 2,001번 읽기를 수행해야 합니다. 현재 기록된 시간에 따르면 하루에 무료로 50,000회 읽기가 가능한데, 이 목록이 하루에 25회 검색되면 이 한도가 달성되어 나머지 시간에는 각 새로고침마다 비용을 지불해야 합니다.\n\n우리는 \"사용자에게 1,000개의 항목을 절대로 표시하지 않을 것이며, 항상 무한한 페이지로 나눠진 목록을 사용할 것이다.\" 라고 이를 정당화할 수 있을지 모르지만, 여전히 남아있는 문제점이 있습니다: 필터링.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n특정 색상을 가진 모든 장난감을 검색하려면 객체를 검색할 때 정반대 과정을 수행해야 합니다. 쿼리와 일치하는 모든 색상을 찾은 다음 해당 색상을 포함하는 모든 재료를 찾고, 마지막으로 해당 재료를 가진 모든 장난감을 찾아야 합니다.\n\n![이미지](/assets/img/2024-06-19-FirestoreandNoSQLThechallengesofstructuringourdata_7.png)\n\n게다가, 특정 색상 및 재료 속성으로 필터링하려면 각 사용 사례에 맞게 필터링 방법을 변경해야 합니다.\n\n마지막으로, 가장 중요한 것은 응용 프로그램에 다양한 유형의 사용자가 있다면 재료와 색상의 특정 속성에 액세스할 수 없도록하려는 경우가 있을 수 있지만, 이름과 유형에는 액세스 권한을 허용하려는 경우입니다. Firestore에서 문서의 일부만 검색하는 것은 불가능합니다. 항상 문서의 모든 정보를 검색해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n요약하자면, NoSQL Firestore에 SQL과 유사한 접근 방식을 적용하면 세 가지 문제가 발생합니다:\n\n- 조금 더 많은 읽기 작업이 발생할 수 있음;\n- 복잡한 필터링;\n- 문서 내 모든 정보 노출, 포함하여 민감한 정보까지.\n\n그 대신에 우리가 할 수 있는 것은 무엇인가요?\n\n# Firestore 데이터의 정규화 해제\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리의 원래 문제에서는 사용자에게 재료 이름과 색상 이름이 나와있는 카드를 보여주고 싶었습니다. 이 쿼리는 자주 수행할 것으로 예상되므로 데이터를 결합하는 것이 어떨까요? 이것이 바로 비정규화의 개념입니다 - 데이터를 모델링하기 위해 서로 다른 테이블/컬렉션에서 필드를 복사하여 하나의 객체로 만들어 정보를 검색하고 필터링하기 쉽게 하는 전략입니다.\n\n그 질문은 - 장난감에 Material 및 Color에서 어떤 데이터를 추가해야 할까요? 답은 우리가 보여주고 싶은 것이나 수행하려는 작업에 따라 다릅니다. 따라서 UI를 검토해봅시다.\n\n![UI 이미지](/assets/img/2024-06-19-FirestoreandNoSQLThechallengesofstructuringourdata_8.png)\n\n이 시점에서는 사용자에게 자세한 내용이 없이 다른 카드를 보여주기만 하면 되므로, Color와 Material 이름만을 보여줍니다. 그래서 우리는 Toy 문서에 두 속성을 모두 추가할 수 있습니다. 여전히 DocumentReference를 유지하거나, 원한다면 ID를 사용하여 신속하게 이름을 식별할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![FirestoreandNoSQLThechallengesofstructuringourdata](/assets/img/2024-06-19-FirestoreandNoSQLThechallengesofstructuringourdata_9.png)\n\n이제 1,000개 요소로 구성된 목록을 표시하려면, 이 카드를 구성하는 데 필요한 모든 데이터를 가져오기 위해 Firestore에서 하나의 읽기만 필요합니다. 이는 Flutter에서 클라이언트 측 코드를 간단하게 만들어줍니다:\n\n```dart\nFuture\u003cList\u003cToy\u003e\u003e fetchToysAndMaterials() async {\n  final firestore = FirebaseFirestore.instance;\n\n  // 1단계: 모든 장난감 가져오기\n  final toySnapshot = await firestore.collection('toys').get();\n  final toyDocs = toySnapshot.docs;\n\n  // 2단계: [Toy] 클래스로 매핑\n  return toyDocs.map((doc) =\u003e Toy.fromFirebase(doc)).toList();\n}\n```\n\nColor 및 Material에서 추가해야 할 다른 속성이 있습니까? 이는 두 가지 질문에 달려 있습니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 만약 Toy에 대한 상세보기를 보여주면, 모든 공통 속성을 추가하고 싶을 수 있습니다.\n- 소재 모양이나 색상 값과 같은 특정 속성을 필터링하는 경우, Toy 문서에 추가하는 것을 고려할 수 있습니다.\n\n우리는 이제 애플리케이션의 요구사항을 고려하여 적절한 문서 구조를 작성하여 앱이 이 데이터를 쉽게 소비할 수 있도록 하려고 합니다.\n\n이로 인해 중요한 문제가 발생합니다: 만약 어느 날 소재 이름이 변경된다면 어떻게 될까요? Toy에서 해당 속성을 어떻게 업데이트할까요? 이것은 비정규화된 데이터베이스를 사용하는 것의 단점 중 하나입니다. 그러나 우리에게 해결책이 있습니다.\n\n# Firebase Functions을 사용하여 데이터 업데이트하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n한 가지 해결책은 클라이언트 애플리케이션을 사용하여 모든 데이터베이스 업데이트를 관리하는 것입니다. 사용자가 Material 객체를 변경하면 모든 Toys도 업데이트됩니다. 그러나 이로 인해 문제가 발생합니다:\n\n- Material을 관리하는 사용자가 Toy 컬렉션에 대한 충분한 권한을 갖고 있지 않을 수 있기 때문에 해당에 대한 사용자 지정 규칙을 만들어야 합니다.\n\n이 문제에 대한 해결책으로는 Firebase Cloud Functions을 사용하는 것입니다. 클라이언트 앱이 민감한 정보에 액세스하지 못하도록 막고 싶을 때 Firebase Cloud Functions을 사용하여 이러한 작업을 클라우드에서 실행할 수 있습니다. Firebase Functions은 클라이언트 애플리케이션에서 호출할 수 있는 API 형식의 엔드포인트를 제공하며 컬렉션 내의 문서 변경과 같은 변경에 반응할 수 있는 기능을 제공합니다.\n\nToy 애플리케이션의 경우 materialscollection 내의 문서 변경에 반응하고 해당 Material을 사용하는 모든 Toy를 찾아 필요한 속성을 업데이트하는 새로운 Firebase Function을 작성해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-FirestoreandNoSQLThechallengesofstructuringourdata_10.png\" /\u003e\n\n이 글에서는 Firebase Functions 프로젝트를 생성하는 방법에 대해 다루지 않겠습니다. 시작 안내서에 문서화된 내용입니다. 바로 Python 코드로 넘어가겠습니다.\n\n먼저, on_document_updated 주석이 달린 새 함수를 만듭니다. 이를 통해 변경 사항을 감시하는 컬렉션을 명시할 수 있습니다. 이 함수는 이전 및 현재 문서 상태를 볼 수 있도록 Event[Change[DocumentSnapshot]]를 받습니다.\n\n```js\nfrom firebase_functions.firestore_fn import (\n    on_document_updated,\n    Event,\n    Change,\n    DocumentSnapshot,\n)\nfrom firebase_admin import initialize_app, credentials, firestore\n\ncred = credentials.Certificate(\"credentials/service_account.json\")\napp = initialize_app(cred)\ndb = firestore.client()\n\n@on_document_updated(document=\"/materials/{materialId}\")\ndef on_toy_material_update(event: Event[Change[DocumentSnapshot]]) -\u003e None:\n    # 할 일: 구현하기\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음으로, 변경 내용을 찾아보겠습니다. 예를 들어, 이름과 같은 필드로:\n\n```js\n@on_document_updated(document=\"/materials/{materialId}\")\ndef on_toy_material_update(event: Event[Change[DocumentSnapshot]]) -\u003e None:\n    # 새 문서 스냅샷에서 업데이트된 데이터를 추출합니다.\n    new_data = event.data.after.to_dict()\n    old_data = event.data.before.to_dict()\n\n    # 업데이트를 보관할 딕셔너리를 만듭니다 (변경 사항이 있는 경우에만)\n    updates = {}\n    if new_data.get(\"name\") != old_data.get(\"name\"):\n        updates[\"materialName\"] = new_data.get(\"name\")\r\n```\n\n이제 재료 ID를 사용하여 장난감 컬렉션을 살펴보고,이 재료를 사용하는 모든 장난감을 찾기 위해 쿼리하고 업데이트 함수를 사용하여 업데이트합니다.\n\n```js\n@on_document_updated(document=\"/materials/{materialId}\")\ndef on_toy_material_update(event: Event[Change[DocumentSnapshot]]) -\u003e None:\n    \"\"\"\n    특정 재료를 사용하는 장난감을 업데이트하는 함수.\n\n    Args:\n        event (Event[Change[DocumentSnapshot]]): 재료 업데이트로 트리거되는 이벤트.\n\n    Returns:\n        None\n    \"\"\"\n\n    # 새 문서 스냅샷에서 업데이트된 데이터를 추출합니다.\n    new_data = event.data.after.to_dict()\n    old_data = event.data.before.to_dict()\n\n    # 업데이트를 보관할 딕셔너리를 만듭니다 (변경 사항이 있는 경우에만)\n    updates = {}\n    if new_data.get(\"name\") != old_data.get(\"name\"):\n        updates[\"materialName\"] = new_data.get(\"name\")\n\n    material_id = event.data.after.id\n    \n    # 업데이트해야 할 필드가 있는지 확인합니다\n    if updates:\n        # 장난감 컬렉션에서이 재료를 사용하는 모든 장난감을 쿼리합니다\n        toys_ref = db.collection(\"toy\").where(\"materialId\", \"==\", material_id)\n        toys = toys_ref.get()\n\n        # 필요한 경우 각 장난감 문서를 업데이트합니다\n        for toy in toys:\n            toy_ref = db.collection(\"toy\").document(toy.id)\n            toy_ref.update(updates)\n\n        print(f\"새 재료 데이터로 장난감이 업데이트되었습니다: {updates}\")\n    else:\n        print(\"재료 속성이 변경되지 않았습니다. 업데이트가 수행되지 않았습니다.\")\r\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n업데이트 변수에 딕셔너리를 사용하면 더 많은 필드를 업데이트하고 싶을 때 추가 속성 변경을 더 확인할 수 있어요.\n\n이제 Firebase를 통해 함수를 업로드할 수 있어요:\n\n```js\nfirebase deploy --only functions\n```\n\n업로드하고 나면 Firebase 콘솔에서 확인할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Firestore Image](/assets/img/2024-06-19-FirestoreandNoSQLThechallengesofstructuringourdata_11.png)\n\nYou can test it by directly editing the Firestore values in the console:\n\n![Console Image](https://miro.medium.com/v2/resize:fit:1400/1*rKjYRyElLGAOW2EiWY-2zw.gif)\n\nTo debug, go to Log Explorer in the Google Cloud Console. Here, you can find all logs for our app, including the print statements added in our Function.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-19-FirestoreandNoSQLThechallengesofstructuringourdata_12.png)\n\n# 결론\n\n프로젝트가 성장함에 따라 사이드 이펙트를 관리하기 위해 추가적인 Firebase 함수를 생성해야 할 것입니다. 색상 컬렉션을 변경하면 해당 변경 사항을 소재 및 장난감에 전파해야 할 필요가 있습니다. 주문 컬렉션에서 주문을 처리할 때 소재와 장난감의 재고를 확인하고 주문을 처리하기 전에 필요한 항목을 재고에서 빼야 할 수도 있습니다.\n\n이러한 사이드 이펙트는 비정규화된 데이터베이스를 사용함으로 인한 결과입니다. 앱의 기능을 중심으로 데이터를 모델링한다면 SQL과 유사한 구조 대신 데이터베이스를 동기화하는 방법이 필요합니다. Firebase Functions를 활용함으로써 데이터베이스를 클라이언트 애플리케이션으로부터 격리시키고 민감한 데이터를 안전하게 보호하며 무단 수정을 방지할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 문서를 통해 Firestore 데이터베이스에서 데이터 정규화 및 비정규화를 탐구해보았습니다:\n\n- 정규화된 데이터는 데이터 무결성을 보장하지만 더 많은 읽기와 복잡한 쿼리로 이어질 수 있습니다.\n- 비정규화된 데이터는 데이터베이스를 앱의 요구에 따라 모델링하여 클라이언트 앱의 필터링 및 가져오기 작업을 간소화하지만 데이터 무결성을 유지하기 위해 Firebase Functions를 통한 추가적인 코드가 필요합니다.\n\n어떤 경우에 이름 변경과 같은 절대 변경 사항이 전파되지 않을 수 있지만, 제품의 재고와 같이 값의 증가 또는 감소와 같은 경우가 있습니다. 이 경우 트랜잭션을 사용하여 한 문서의 값을 읽고 다른 문서에서 변경 사항을 처리할 수 있습니다. Firebase가 읽은 문서에서 변경 사항을 감지하면 트랜잭션을 다시 시도하여 가장 최신 데이터를 사용할 수 있도록 보장합니다.\n\n추가로 Firebase Function에서 데이터 유효성 검사를 하도록 노력해야 합니다. 이를 통해 사용자가 예를 들어 문자열에서 불리언으로 값을 변경하거나 특정 규칙을 따르도록 강제할 수 없게 됩니다. Firebase Function이 오류를 감지하면 변경 사항을 전파 중지하고 재료 문서를 원래 상태로 수정할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마지막으로, 무단 액세스나 정보 수정을 방지하기 위해 적절한 Firestore 규칙이 설정되어 있는지 확인해야 합니다. 이를 통해 Firebase 함수만이 이를 수행할 수 있도록 합니다.\n\nFirebase 앱에 원활하게 더 많은 기능을 추가하고 싶다면 Firebase Extensions를 사용해보는 것은 어떨까요? Firebase Extensions를 활용하여 AI 요약 기능을 쉽게 추가할 수 있는 방법을 확인하려면 이 문서를 참고해보세요.","ogImage":{"url":"/assets/img/2024-06-19-FirestoreandNoSQLThechallengesofstructuringourdata_0.png"},"coverImage":"/assets/img/2024-06-19-FirestoreandNoSQLThechallengesofstructuringourdata_0.png","tag":["Tech"],"readingTime":13},{"title":"포괄적인 미디어 쿼리 안내","description":"","date":"2024-06-19 00:00","slug":"2024-06-19-AComprehensiveMediaQueryGuide","content":"\n\n\u003cimg src=\"/assets/img/2024-06-19-AComprehensiveMediaQueryGuide_0.png\" /\u003e\n\n반응형 디자인은 현대 앱 개발의 중요한 측면입니다. 이는 UI가 다양한 화면 크기, 해상도 및 방향에 매끄럽게 적응하여 모든 기기에서 최적의 사용자 경험을 제공함을 보장합니다. Flutter에서 반응형 디자인을 달성하는 것은 지원하는 다양한 기기와 화면 크기로 인해 중요합니다.\n\n다양한 화면 크기 및 방향에 대해 UI를 적응시키는 것은 중요한데요:\n\n- 사용자 경험: 잘 적응된 UI는 사용 중인 기기에 관계없이 일관된 즐거운 사용자 경험을 제공합니다.\n- 접근성: 모든 사람, 특히 장애를 가진 사람들이 사용하는 데 도움이 되도록 큰 텍스트나 특정 화면 레이아웃에 의존하는 경우를 포함하여 앱이 사용 가능하도록 보장합니다.\n- 시장 점유: 반응형 앱은 다양한 기기에서 실행될 수 있어 잠재적 사용자 기반 및 시장 점유율을 증가시킬 수 있습니다.\n- 전문성: 전문성 및 세부사항에 대한 주의가 반영되어 앱의 전체 품질 및 사용자 만족도에 기여합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nMediaQuery는 현재 화면의 크기와 방향에 대한 정보를 제공하는 플러터(Flutter)에서 강력한 유틸리티입니다. 이를 이용하여 개발자들은 현재 기기의 크기를 쿼리하고 UI를 그에 맞게 적응시켜 반응형 레이아웃을 구성할 수 있습니다. MediaQuery는 화면 크기, 기기의 픽셀 비율, 텍스트 스케일링 팩터, 패딩, 방향 등 다양한 속성에 접근할 수 있습니다.\n\nMediaQuery를 사용하면 개발자들은 다음과 같은 작업을 수행할 수 있습니다:\n\n- 위젯의 크기와 레이아웃을 동적으로 조절할 수 있습니다.\n- 다양한 화면 방향 (세로 및 가로)을 처리할 수 있습니다.\n- UI를 다른 텍스트 스케일링 팩터에 맞게 조정할 수 있습니다.\n- UI 구성 요소가 안전 영역 안에 맞게끔 하여 노치와 기타 가로막음을 피할 수 있습니다.\n\n# MediaQuery란 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nMediaQuery는 현재 화면의 크기, 방향 및 디스플레이의 기타 특성에 대한 정보를 제공하는 Flutter 위젯입니다. 이를 통해 개발자는 화면 크기와 기타 특성을 쿼리하고 대응하여 적응적이고 반응형 사용자 인터페이스를 더 쉽게 만들 수 있습니다.\n\nMediaQuery의 목적은 Flutter 앱 내에서 디스플레이 정보를 검색하고 활용할 수 있는 중앙화된 방법을 제공하는 것입니다. 이를 통해 개발자는 장치의 속성에 기반하여 동적으로 UI를 조정하는 것이 가능하며, 다양한 장치와 화면 크기에 걸쳐 일관된 최적화된 경험을 보장할 수 있습니다.\n\nMediaQuery는 다음과 같은 방법으로 반응형 UI를 구축하는 데 도움이 됩니다:\n\n- 화면 크기에 접근하기:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- MediaQuery는 화면의 너비와 높이를 제공하여 개발자가 사용 가능한 공간에 따라 위젯의 레이아웃과 크기를 조정할 수 있습니다.\n- 예시: MediaQuery.of(context).size.width는 화면 너비를 반환하며, 이를 사용하여 컨테이너의 너비를 동적으로 설정할 수 있습니다.\n\n2. 화면 방향 처리:\n\n- MediaQuery는 화면의 방향 (세로 또는 가로)에 관한 정보를 제공합니다. 현재 방향에 따라 적응하는 레이아웃을 디자인하는 데 도움이 됩니다.\n- 예시: MediaQuery.of(context).orientation은 현재 방향을 반환하며, 세로 및 가로 모드에서 다른 레이아웃을 적용할 수 있습니다.\n\n3. 텍스트 크기 조절에 적응하기:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- MediaQuery는 사용자의 선호하는 텍스트 크기를 나타내는 textScaleFactor를 제공합니다. 이를 통해 개발자는 앱 내에서 텍스트 크기를 조정하여 모든 사용자가 편리하게 볼 수 있도록 할 수 있습니다.\n- 예시: MediaQuery.of(context).textScaleFactor를 사용하면 텍스트 스케일 팩터를 반환할 수 있으며, 이를 텍스트 위젯에 적용하여 확장 가능하게 만들 수 있습니다.\n\n4. 디바이스의 화소 비율 고려:\n\n- MediaQuery는 물리적 픽셀 수 대비 논리적 픽셀 수를 고려하여 날카롭고 선명한 시각적 효과를 만드는 데 도움이 되는 장치 픽셀 비율을 제공합니다.\n- 예시: MediaQuery.of(context).devicePixelRatio를 사용하면 화소 비율을 반환할 수 있으며, 고해상도 이미지 및 그래픽을 렌더링하는 데 유용합니다.\n\n5. 안전 영역 관리하기:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- MediaQuery는 패딩 및 viewInsets 속성을 제공하여 노치, 상태 표시줄 및 키보드 영역과 같은 화면의 안전 영역을 관리하는 데 도움을 줍니다.\n- 예시: MediaQuery.of(context).padding는 안전 영역 보정값을 반환하여 시스템 UI 요소에 의해 중요한 UI 요소가 가려지지 않도록 합니다.\n\n# MediaQuery 속성\n\n![그림](/assets/img/2024-06-19-AComprehensiveMediaQueryGuide_1.png)\n\n- 설명: size 속성은 화면의 너비와 높이를 논리적인 픽셀 단위로 제공합니다.\n- 사용법: 다양한 화면 크기에 적응하는 레이아웃을 생성하는 데 도움이 됩니다.\n- 예시:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\nvar screenSize = MediaQuery.of(context).size;\nvar screenWidth = screenSize.width;\nvar screenHeight = screenSize.height;\n```\n\n- 설명: devicePixelRatio는 Flutter에서 사용하는 논리적 픽셀과 기기의 물리적 픽셀 간의 비율을 나타냅니다.\n- 사용법: 고해상도 이미지와 그래픽을 렌더링하는 데 유용합니다.\n- 예시:\n\n```dart\nvar devicePixelRatio = MediaQuery.of(context).devicePixelRatio;\n```\n\n- 설명: textScaleFactor는 사용자 기호를 존중하기 위해 텍스트에 적용된 스케일링 팩터를 나타냅니다.\n- 사용법: 텍스트 크기가 사용자의 접근성 설정과 일치하도록 보장합니다.\n- 예시:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\nvar textScaleFactor = MediaQuery.of(context).textScaleFactor;\n```\n\n![Image](/assets/img/2024-06-19-AComprehensiveMediaQueryGuide_2.png)\n\n- 설명: platformBrightness 속성은 현재 기기가 밝은 모드인지 어두운 모드인지를 나타냅니다.\n- 사용법: 앱이 테마를 이에 맞게 조절할 수 있습니다.\n- 예시:\n\n```dart\nvar brightness = MediaQuery.of(context).platformBrightness;\nbool isDarkMode = brightness == Brightness.dark;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image](/assets/img/2024-06-19-AComprehensiveMediaQueryGuide_3.png)\n\n- 설명: 패딩 속성은 시스템 UI가 차지할 수 있는 영역에 대한 여백을 제공합니다. 예를 들어, 상태 표시줄, 노치 또는 특정 기기의 하단 영역 등이 포함됩니다.\n- 사용법: 시스템 오버레이에 의해 중요한 UI 요소가 가려지지 않도록 합니다.\n- 예시:\n\n```js\nvar padding = MediaQuery.of(context).padding;\nvar topPadding = padding.top;\nvar bottomPadding = padding.bottom;\n```\n\n![Image](/assets/img/2024-06-19-AComprehensiveMediaQueryGuide_4.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 설명: viewInsets 속성은 화면 키보드와 같은 시스템 UI 요소로 완전히 가려진 디스플레이 영역을 나타냅니다.\n- 사용법: 이러한 요소가 존재할 때 레이아웃을 조정하는 데 도움이 됩니다.\n- 예시:\n\n```js\nvar viewInsets = MediaQuery.of(context).viewInsets;\nvar bottomInset = viewInsets.bottom;\n```\n\n- 설명: viewPadding 속성은 뷰 주위의 패딩을 제공합니다. 패딩과 유사하지만, 화면 키보드가 표시될 때 변경되지 않습니다.\n- 사용법: 키보드 상태에 관계없이 레이아웃이 일관되게 유지되도록합니다.\n- 예시:\n\n```js\nvar viewPadding = MediaQuery.of(context).viewPadding;\nvar topViewPadding = viewPadding.top;\nvar bottomViewPadding = viewPadding.bottom;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-19-AComprehensiveMediaQueryGuide_5.png)\n\n- 설명: orientation 속성은 기기가 현재 세로 모드 또는 가로 모드인지를 나타냅니다.\n- 사용법: 화면 방향에 따라 레이아웃을 조정할 수 있습니다.\n- 예시:\n\n```javascript\nvar orientation = MediaQuery.of(context).orientation;\nbool isPortrait = orientation == Orientation.portrait;\n```\n\n# MediaQuery와 LayoutBuilder의 결합\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nLayoutBuilder는 부모 위젯의 제약 조건을 기반으로 위젯 트리를 구성하는 Flutter 위젯입니다. 빌더 함수에 BoxConstraints 객체를 제공하여 사용 가능한 공간에 맞게 레이아웃을 작성할 수 있습니다.\n\n- 목적: 위젯의 빌드 컨텍스트 내에서 현재 제약 조건을 제공하여 유연하고 반응형 UI를 쉽게 구축하는 데 도움을 줍니다.\n- 주요 이점: 위젯이 다양한 크기와 제약 조건에 동적으로 적응할 수 있으며, 이는 반응형 레이아웃 구축에 특히 유용합니다.\n\nMediaQuery와 결합하면 LayoutBuilder를 사용하여 부모 위젯의 제약 조건과 전체 화면 속성을 모두 활용하여 반응형 디자인을 향상시킬 수 있습니다. MediaQuery는 전체 화면에 대한 정보를 제공하는 반면, LayoutBuilder는 위젯의 특정 제약 조건에 초점을 맞춤으로써 더 세밀한 제어가 가능합니다.\n\n- 세밀한 제어: 화면 크기 뿐만 아니라 부모 위젯이 제공하는 크기 제약 조건에도 반응할 수 있습니다.\n- 최적화된 레이아웃: 전체 화면 크기와 특정 위젯 제약 조건에 모두 적응하는 더 최적화된 레이아웃을 구축할 수 있습니다.\n- 유연성: 이 조합을 사용하면 더 창의적이고 유연한 UI 디자인을 가능케 하여 위젯이 다양한 화면 크기와 방향에 매끄럽게 적응할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 LayoutBuilder와 MediaQuery를 함께 사용하여 반응형 위젯을 구축하는 방법을 보여주는 예제입니다:\n\n```js\nimport 'package:flutter/material.dart';\n\nclass ResponsiveWidget extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    var screenSize = MediaQuery.of(context).size;\n    var screenWidth = screenSize.width;\n    var screenHeight = screenSize.height;\n\n    return Scaffold(\n      appBar: AppBar(title: Text('반응형 디자인 예시')),\n      body: LayoutBuilder(\n        builder: (BuildContext context, BoxConstraints constraints) {\n          if (constraints.maxWidth \u003c 600) {\n            // 모바일 레이아웃\n            return _buildMobileLayout();\n          } else {\n            // 태블릿/데스크톱 레이아웃\n            return _buildTabletDesktopLayout();\n          }\n        },\n      ),\n    );\n  }\n\n  Widget _buildMobileLayout() {\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: \u003cWidget\u003e[\n          Container(\n            color: Colors.blue,\n            width: 200,\n            height: 200,\n            child: Center(child: Text('모바일 레이아웃', style: TextStyle(color: Colors.white))),\n          ),\n        ],\n      ),\n    );\n  }\n\n  Widget _buildTabletDesktopLayout() {\n    return Center(\n      child: Row(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: \u003cWidget\u003e[\n          Container(\n            color: Colors.green,\n            width: 300,\n            height: 300,\n            child: Center(child: Text('태블릿/데스크톱 레이아웃', style: TextStyle(color: Colors.white))),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\nvoid main() {\n  runApp(MaterialApp(home: ResponsiveWidget()));\n}\n```\n\n- MediaQuery: 전체 화면 크기 및 기타 속성을 검색하는 데 사용됩니다. 이를 통해 전체 화면 크기를 결정하는 데 도움이 됩니다.\n- LayoutBuilder: 부모 위젯이 제공하는 제한에 따라 레이아웃을 동적으로 조정하는 데 사용됩니다.\n- _buildMobileLayout \u0026 _buildTabletDesktopLayout: 모바일 및 태블릿/데스크톱 뷰에 대한 두 가지 다른 레이아웃이 정의되어 있습니다.\n- 모바일 레이아웃: 모바일 화면에 적합한 작은 컨테이너를 표시합니다.\n- 태블릿/데스크톱 레이아웃: 큰 화면용으로 더 큰 컨테이너를 표시합니다.\n\nFlutter 애플리케이션 내에서 반응형 디자인에 큰 역할을 하는 MediaQuery입니다. 화면 크기, 방향, 픽셀 밀도, 텍스트 확장, 안전 영역 등에 대한 중요한 정보를 제공하여 개발자가 적응적이고 유연한 UI를 생성할 수 있도록 합니다. MediaQuery를 활용하면 앱이 다양한 장치 및 화면 크기에서 일관되고 최적화된 사용자 경험을 제공할 수 있습니다. 특히 오늘날의 다양한 장치 환경에서 사용자가 다양한 차원과 특성의 폰, 태블릿, 데스크톱에서 앱을 이용하는 맥락에서 이는 특히 중요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n미디어쿼리를 활용한 실험은 매우 반응성 높고 사용자 친화적인 애플리케이션을 만드는 데 많은 가능성을 제공할 수 있어요. 미디어쿼리가 제공하는 다양한 속성을 이해하고 활용함으로써, 개발자들은 모든 기기의 제약 사항과 설정에 동적으로 적응하는 UI를 만들 수 있어요. 화면 크기에 따라 레이아웃을 조정하거나 가독성을 높이기 위해 텍스트 크기를 조절하거나 다양한 방향을 수용하는 등, 미디어쿼리는 효과적인 반응형 디자인을 위한 필수 도구를 제공해요. 미디어쿼리에 뛰어들어서, LayoutBuilder와 같은 다른 Flutter 도구와 결합해보세요. 여러분의 앱의 적응성과 사용성을 향상시키는 방법을 살펴보세요.\n\n이제 미디어쿼리와 그 기능을 확실하게 이해했으니, 지식을 실전에 적용할 때입니다. 제공된 예제를 시도해보고, 다양한 미디어쿼리 속성을 실험하며 프로젝트에 어떻게 적용할 수 있는지 살펴보세요. 여러분의 경험과 피드백을 Flutter 커뮤니티와 공유하여 다른 사람들이 학습하고成長할 수 있도록 도와주세요.\n\n- LinkedIn 팔로우하기\n\n더 궁금한 점이나 추가 도움이 필요한 경우 언제든지 연락해주세요. 즐거운 코딩 되세요!","ogImage":{"url":"/assets/img/2024-06-19-AComprehensiveMediaQueryGuide_0.png"},"coverImage":"/assets/img/2024-06-19-AComprehensiveMediaQueryGuide_0.png","tag":["Tech"],"readingTime":9},{"title":"4월에는 거래소와 사기로 인해 25백만의 피해를 입었다고 합니다 이는 역사적으로 최저치를 기록했습니다 CertiK가 밝혔습니다","description":"","date":"2024-05-01 18:18","slug":"2024-05-01-Aprilsees25MinexploitsandscamsmarkinghistoriclowCertiK","content":"\n\n![CertiK Thumbnail](/assets/img/2024-05-01-Aprilsees25MinexploitsandscamsmarkinghistoriclowCertiK_thumbnail.png)\n\n2022년 이래 최저 수준까지 감소한 해킹과 사기로 인한 손실이 CertiK가 데이터를 기록하기 시작한 이후로 낮아졌습니다. 4월 30일에 Cointelegraph에 공개된 CertiK의 보고서에 따르면, 이번 달에는 약 25.7백만 달러의 공격으로 인한 손실만이 있었는데, 이는 지난 2021년 이후로 최저액입니다.\n\n이 보고서에 따르면, 해킹, 악용 및 사기로 인한 손실이 지난 달에 비해 141% 줄었습니다. 이 감소의 주요 이유는 개인 키의 침해가 없었기 때문입니다. 3월에는 개인 키 침해로 인한 프로토콜에 대한 11차 공격이 있었지만, 4월에는 이보다 적은 3차 공격만 있었습니다.\n\n\n\n![image](/assets/img/2024-05-01-Aprilsees25MinexploitsandscamsmarkinghistoriclowCertiK_0.png)\n\n암호화폐 사용자들에게 좋은 소식이 있는 가운데, 이번 달 동안 몇 가지 주목할 만한 해킹과 사기 사건이 손실을 야기했습니다. Memecoin Condom은 \"솔라나 네트워크에 프리세일 주소를 광고했었는데,\" 이는 알지 못하는 사용자들로부터 자금을 빼앗는 데 사용되었습니다. 이 공격으로 약 933,000달러의 암호화폐가 손실되었습니다.\n\n비트코인 라이트닝 네트워크 거래소인 FixedFloat는 4월 1일 큰 해킹 사고를 당해 약 3백만 달러가 탈취당했습니다. 이는 FixedFloat가 2024년에 공격을 받는 두 번째 경우였습니다. 이전 사건은 2월에 발생했습니다.\n\n이번 달에 보고된 총 25.7백만 달러의 손실 가운데 상당 부분인 21백만 달러가 exploits에 속했으며, 이 가운데 3건의 공격은 각각 1백만 달러 이상의 피해를 야기했습니다. 플래시 대출 공격으로 인한 손실은 12만 9천 달러로, 가장 큰 한 건은 5천 5백 달러의 피해를 발생시켰습니다. CertiK에 따르면, 이는 2022년 2월 이후 플래시 대출 공격 발생 건수가 가장 적은 것을 의미합니다. 또한, 13건의 종료 사기 사건이 있었는데, 이는 3월 대비 40% 감소한 수치입니다.\n\n\n\nCertiK는 이러한 숫자에 ZKasino를 포함시키지 않았다고 밝혔습니다. 해당 프로젝트는 투자자가 예금한 자금을 인출할 수 없도록 막은 사례입니다. 보고서는 이 프로젝트를 \"논란의 중심\"으로 보지만 아직 사기로 지칭하진 않았습니다. 보안 플랫폼은 ZKasino가 악의적인 행동을 한다는 것이 확인되면 수치를 업데이트할 것이라고 주장했습니다. ZKasino는 4월 22일 자금을 Lido 프로토콜로 옮겼으며, 많은 사용자들을 분노시켰습니다.\n\nCertiK의 보고서 발표 직후, 탈중앙화 금융 앱 Yield Protocol이 18만 1,000달러에 이르는 금액으로 공격을 받았습니다. 개발자가 공식적으로 폐쇄한 Yield이지만, 스마트 계약의 변경할 수 없는 특성으로 일부 사용자는 여전히 상호 작용할 수 있습니다.\n\n매거진: DeFi의 10억 달러 비밀: 해킹에 책임 있는 내부자들","ogImage":{"url":"/assets/img/2024-05-01-Aprilsees25MinexploitsandscamsmarkinghistoriclowCertiK_thumbnail.png"},"coverImage":"/assets/img/2024-05-01-Aprilsees25MinexploitsandscamsmarkinghistoriclowCertiK_thumbnail.png","tag":["Tech"],"readingTime":2}],"page":"20","totalPageCount":20,"totalPageGroupCount":1,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"20"},"buildId":"-8k4Xu2rlgTZWfP5qtaGa","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>