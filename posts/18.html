<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>uidev-css</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://uidev-css.github.io///posts/18" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="uidev-css" data-gatsby-head="true"/><meta property="og:title" content="uidev-css" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://uidev-css.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://uidev-css.github.io///posts/18" data-gatsby-head="true"/><meta name="twitter:title" content="uidev-css" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | uidev-css" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/873-1e1f6fb6fd3c8994.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-498da29379dd58dc.js" defer=""></script><script src="/_next/static/fyfGyRz00q80ZdkogiVCt/_buildManifest.js" defer=""></script><script src="/_next/static/fyfGyRz00q80ZdkogiVCt/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UIDEV CSS</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="2024년 기준으로 한 단계씩 따라 하는 플러터 웹뷰 예제" href="/post/2024-06-19-FlutterWebviewExampleStepbyStepin2024"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="2024년 기준으로 한 단계씩 따라 하는 플러터 웹뷰 예제" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-FlutterWebviewExampleStepbyStepin2024_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="2024년 기준으로 한 단계씩 따라 하는 플러터 웹뷰 예제" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">2024년 기준으로 한 단계씩 따라 하는 플러터 웹뷰 예제</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="API 통합 및 상태 관리를 위한 Flutter BLoC 라이브러리" href="/post/2024-06-19-APIIntegrationandStateManagementwithFlutterBLoCLibrary"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="API 통합 및 상태 관리를 위한 Flutter BLoC 라이브러리" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-APIIntegrationandStateManagementwithFlutterBLoCLibrary_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="API 통합 및 상태 관리를 위한 Flutter BLoC 라이브러리" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">API 통합 및 상태 관리를 위한 Flutter BLoC 라이브러리</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="플러터플로우 Low-Code 앱 개발을 위한 빠른 프로토타이핑 좋은 점, 나쁜 점 및 플로우" href="/post/2024-06-19-FlutterFlowRapidPrototypingforLow-CodeAppDevelopmentTheGoodtheBadandtheFlow"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="플러터플로우 Low-Code 앱 개발을 위한 빠른 프로토타이핑 좋은 점, 나쁜 점 및 플로우" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-FlutterFlowRapidPrototypingforLow-CodeAppDevelopmentTheGoodtheBadandtheFlow_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="플러터플로우 Low-Code 앱 개발을 위한 빠른 프로토타이핑 좋은 점, 나쁜 점 및 플로우" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">플러터플로우 Low-Code 앱 개발을 위한 빠른 프로토타이핑 좋은 점, 나쁜 점 및 플로우</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="플러터를 배워야 하는 이유" href="/post/2024-06-19-WhyYouShouldLearnFlutter"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="플러터를 배워야 하는 이유" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-WhyYouShouldLearnFlutter_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="플러터를 배워야 하는 이유" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">플러터를 배워야 하는 이유</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="2024년 소셜 앱에서 사용할 5가지 플러터 패키지" href="/post/2024-06-19-5Flutterpackagestouseinyour2024SocialApp"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="2024년 소셜 앱에서 사용할 5가지 플러터 패키지" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-5Flutterpackagestouseinyour2024SocialApp_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="2024년 소셜 앱에서 사용할 5가지 플러터 패키지" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">2024년 소셜 앱에서 사용할 5가지 플러터 패키지</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="노선 정의하기" href="/post/2024-06-19-DefiningRoutes"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="노선 정의하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-DefiningRoutes_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="노선 정의하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">노선 정의하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="디폴트js" href="/post/2024-06-19-defaultjs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="디폴트js" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-defaultjs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="디폴트js" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">디폴트js</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="코틀린 멀티 플랫폼 모바일이 플러터를 대체하고 있을까요" href="/post/2024-06-19-IsKotlinMultiplatformMobileReplacingFlutter"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="코틀린 멀티 플랫폼 모바일이 플러터를 대체하고 있을까요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-IsKotlinMultiplatformMobileReplacingFlutter_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="코틀린 멀티 플랫폼 모바일이 플러터를 대체하고 있을까요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">코틀린 멀티 플랫폼 모바일이 플러터를 대체하고 있을까요</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="9 JS를 사용하여 웹에서 Whatsapp 공유하기 고급 기능 UriBaba" href="/post/2024-06-19-9WhatsappShareintheWebUsingJSAdvancedFeatureUriBaba"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="9 JS를 사용하여 웹에서 Whatsapp 공유하기 고급 기능 UriBaba" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-9WhatsappShareintheWebUsingJSAdvancedFeatureUriBaba_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="9 JS를 사용하여 웹에서 Whatsapp 공유하기 고급 기능 UriBaba" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">9 JS를 사용하여 웹에서 Whatsapp 공유하기 고급 기능 UriBaba</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="시니어 프론트엔드 개발자 인터뷰를 위한 나쁜 질문" href="/post/2024-06-19-BadquestionsforSeniorFrontendDevInterview"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="시니어 프론트엔드 개발자 인터뷰를 위한 나쁜 질문" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-BadquestionsforSeniorFrontendDevInterview_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="시니어 프론트엔드 개발자 인터뷰를 위한 나쁜 질문" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UIDEV CSS</span></div><strong class="PostList_title__loLkl">시니어 프론트엔드 개발자 인터뷰를 위한 나쁜 질문</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link posts_-active__YVJEi" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"2024년 기준으로 한 단계씩 따라 하는 플러터 웹뷰 예제","description":"","date":"2024-06-19 08:09","slug":"2024-06-19-FlutterWebviewExampleStepbyStepin2024","content":"\n\n이 블로그에서는 2024년에 단계별로 플러터 웹뷰 예제를 통합하는 방법을 탐색할 것입니다. 이 코드를 안드로이드 스튜디오에서 쉽게 사용할 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-FlutterWebviewExampleStepbyStepin2024_0.png)\n\n# 2024년 플러터 웹뷰 예제 단계별 통합 방법\n\n## 단계 1: “pubspec.yaml” 파일에 웹뷰 종속성 추가하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"스튜디오\"로 이동 - \"프로젝트\" 폴더 열기 - \"pubspec.yaml\" 파일 열기 - \"pubspec.yaml\" 파일에 \"webview_flutter: ^4.8.0\" 추가\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n\n  # The following adds the Cupertino Icons font to your application.\n  # Use with the CupertinoIcons class for iOS style icons.\n  cupertino_icons: ^1.0.2\n  webview_flutter: ^4.8.0\n```\n\n## 단계 2: “AndroidManifest.xml” 파일에서 인터넷 연결 권한 추가\n\n\"스튜디오\"로 이동 - \"프로젝트\" 폴더 열기 - \"android\" 폴더 열기 - \"app\" 폴더 열기 - \"src\" 폴더 열기 - \"main\" 폴더 열기 - \"AndroidManifest.xml\" 파일 열기 - 아래 인터넷 권한을 \"AndroidManifest.xml\" 파일에 추가\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003cuses-permission android:name=\"android.permission.INTERNET\"/\u003e\n```\n\n## 단계 3 : Lib 폴더에 \"WebViewContainer.dart\" 파일을 생성하세요\n\n\"Studio\"로 이동 - ` \"프로젝트\" 폴더 열기 -` \"lib\" 폴더 열기 -` \"WebViewContainer.dart\" 파일 만들기\n\n```js\nimport 'package:flutter/material.dart';\nimport 'package:webview_flutter/webview_flutter.dart';\n\nclass WebViewContainer extends StatefulWidget {\n  const WebViewContainer({Key key});\n\n  @override\n  State\u003cWebViewContainer\u003e createState() =\u003e _WebViewContainerState();\n}\n\nclass _WebViewContainerState extends State\u003cWebViewContainer\u003e {\n  final controller = WebViewController()\n    ..setJavaScriptMode(JavaScriptMode.unrestricted)\n    ..loadRequest(Uri.parse(\"https://www.oversimplifiedcoding.com\"));\n\n  @override\n  Widget build(BuildContext context) {\n    return SafeArea(child: WebView(\n      controller: controller,\n    ));\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 단계 4: Lib 폴더에 \"main.dart\" 파일을 생성하세요\n\n\"스튜디오\"에 가서 -` \"프로젝트\" 폴더 열기 -` \"lib\" 폴더 열기 -` \"main.dart\" 파일을 생성하세요\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:my_test_app/WebViewContainer.dart';\n\nvoid main() {\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Flutter Demo',\n      debugShowCheckedModeBanner: false,\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n        textTheme: TextTheme(\n          headlineLarge: TextStyle(\n              color: Colors.white, fontSize: 25, fontFamily: 'MainFont'),\n          headlineMedium: TextStyle(color: Colors.black, fontSize: 20),\n          titleMedium: TextStyle(color: Colors.red, fontSize: 16),\n        ),\n        useMaterial3: true,\n      ),\n      home: const WebViewContainer(),\n    );\n  }\n}\n```\n\n## 참고\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기는 2024년에 하나씩 따라 할 수 있는 완전한 Flutter 웹뷰 예제 튜토리얼 비디오 참조 정보입니다. 손쉽게 배우고 코드에서 사용할 수 있습니다.\n\n자세히 보기: Jetpack Compose에서 Mvvm Dagger Hilt를 사용한 로그인 API 호출\n\n## 결론\n\n이 블로그에서는 2024년에 하나씩 따라 할 수 있는 Flutter 웹뷰 예제를 만드는 방법을 안내했습니다. 이 코드를 쉽게 사용하고 필요에 맞게 수정할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-19-FlutterWebviewExampleStepbyStepin2024_0.png"},"coverImage":"/assets/img/2024-06-19-FlutterWebviewExampleStepbyStepin2024_0.png","tag":["Tech"],"readingTime":3},{"title":"API 통합 및 상태 관리를 위한 Flutter BLoC 라이브러리","description":"","date":"2024-06-19 08:08","slug":"2024-06-19-APIIntegrationandStateManagementwithFlutterBLoCLibrary","content":"\n\nFlutter Bloc 라이브러리는 잘 정의된 아키텍처를 통해 응용 프로그램 상태를 효과적으로 관리하는 방법을 제공합니다.\n\n![image](/assets/img/2024-06-19-APIIntegrationandStateManagementwithFlutterBLoCLibrary_0.png)\n\nFlutter Bloc Library를 사용하면 다양한 응용 프로그램 상태를 명시적으로 관리할 수 있습니다.\n\n이전에 작성한 기사에서 Flutter Bloc 아키텍처 및 이벤트 및 상태 이해에 대해 설명했습니다. setState를 사용하여 상태 관리의 기본 개념을 이미 알고 계시다면, 이 기사를 참고하시면 이해하기 쉬울 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n통합 데이터 소스: 전자 상거래 또는 쇼핑 웹사이트용 가짜 상점 REST API 테스트 API는 네트워크 데이터 소스로 사용됩니다.\n\n더미 JSON URL: https://dummyjson.com/products\n\n본 문서에서는 하나의 엔드포인트(GET: 모든 제품 가져 오기: https://dummyjson.com/products)가 통합될 것입니다\n\n![이미지](/assets/img/2024-06-19-APIIntegrationandStateManagementwithFlutterBLoCLibrary_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 엔드포인트를 통합하기 위해서는 Flutter BLoC 아키텍처를 구현하여 응용 프로그램을 세 개의 계층으로 분리해야 합니다.\n\n- 데이터: 데이터 제공자, 도메인 (저장소, 모델)\n- 비즈니스 로직: 비즈니스 로직 계층의 책임은 프리젠테이션 계층에서 발생하는 이벤트에 새로운 상태로 응답하는 것입니다. 이 계층은 응용 프로그램 상태를 구축하는 데 필요한 데이터를 검색하기 위해 하나 이상의 저장소에 의존할 수 있습니다.\n- 프리젠테이션: 프리젠테이션 계층의 책임은 하나 이상의 블록 상태에 기반하여 자신을 렌더링하는 방법을 결정하는 것입니다. 또한 사용자 상호 작용 및 응용 프로그램 라이프사이클 이벤트를 처리해야 합니다.\n\n이 3개의 계층 중에서 어떤 계층부터 시작해야 할까요?\n\n그래, 데이터 계층부터 시작하겠습니다. 왜냐하면 데이터 계층에서 비즈니스 로직으로 순차적인 통신이 이루어지고, 비즈니스 로직에서 프리젠테이션으로 이어지기 때문이죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n특수한 경우에는 네트워크 및 데이터 시뮬레이션에 더 적합한 방법을 따를 수 있습니다.\n\n데이터 레이어 구현으로 넘어가기 전에 필요한 종속성을 추가해 봅시다:\n\n\n![Dependency](/assets/img/2024-06-19-APIIntegrationandStateManagementwithFlutterBLoCLibrary_2.png)\n\n\nHTTP: HTTP 요청을 만들기 위한 구성 가능한 미래 기반 라이브러리입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플러터 Bloc: 빠르고 반응성 있는 모바일 애플리케이션을 구축하기 위해 bloc과 함께 작동하는 강력한 플러터 위젯\n\nEquatable: == 및 hashCode를 명시적으로 재정의할 필요 없이 값을 기반으로 한 등가성을 구현하는 데 도움이 되는 Dart 패키지입니다. Flutter Bloc에서는 동일한 상태가 발생하는 경우 상태 재구성을 방지하거나 결정하는 데 도움이 됩니다.\n\nIntl: 숫자 형식 지정에 사용됩니다.\n\n실행: `flutter pub get` 명령을 실행하여 종속성을 프로젝트에 추가하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 1. 데이터 레이어\n\n데이터 제공자: 데이터 제공자는 원시 데이터, 즉 HTTP 요청의 원시 응답을 받습니다.\n\n대규모 애플리케이션을 구축할 때 모든 HTTP 메서드를 포함하는 단일 데이터 제공자를 사용할 수 있습니다. 이는 모든 원시 데이터가 HTTP 응답임을 고려한 것입니다.\n\n데이터 제공자는 HTTP 메서드(PUT, GET, POST, DELETE)와 리포지토리에 의해 관리되는 다른 원시 데이터 소스(예: 로컬 저장소)를 포함할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 구현의 예는 데이터를 가져 오기 때문에 HTTP Get 요청만 수행됩니다.\n\nHTTP 요청은 try-catch 블록 내에 있어 이 요청에서 발생할 수 있는 모든 예외를 잡아내고 해당 예외를 다시 던집니다. 이 예외는 데이터 제공자 클래스에서 처리되지 않고 리포지토리로 던져집니다.\n\n모델\n\n모델은 데이터 구조를 결정하는 데 도움이 되는 클래스입니다. 모델은 데이터베이스나 HTTP 응답을 반영하도록 작성될 수 있으며 이 경우 제품 JSON 응답을 얻는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 모델에는 데이터 제공자로부터 JSON 형식의 HTTP 응답을 특정 모델(Dart 객체)로 디코딩하는 데이터 역직렬화 방법도 포함됩니다.\n\n데이터를 전송할 때(e.g. POST, PUT, PATCH 요청 등)는 인코딩된 json이 필요한 경우 요청 본문을 인코딩하기 위한 직렬화 방법을 추가할 수 있습니다.\n\n저장소\n\n저장소는 도메인으로서 우리의 데이터 계층을 추상화하고 블록 계층과의 통신을 용이하게 합니다. 이를 통해 우리 코드베이스의 나머지 부분은 특정 데이터 제공자가 아닌 저장소 계층에서 노출된 함수에만 의존하게 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`getProducts` 메서드는 List of Product (List`Product`)을 데이터 타입으로 반환하는 비동기 메서드입니다. Product는 product_model.dart에서 생성된 모델입니다. (Line: 6)\n\n(Line: 5) 데이터 공급 업체는 get products 엔드포인트(“https://dummyjson.com/products”)를 파싱하는 getRequest 메서드를 호출하기 위해 인스턴스화됩니다.\n\n데이터 공급 업체는 응답 본문, 응답 상태 코드 등에 액세스할 수 있는 raw HTPP 응답을 반환합니다. 상태 코드 200은 요청이 성공적이고 제품이 반환되었음을 나타내며, 요청이 성공적이지 않으면 예외(“Error loading product”)가 던져져 Bloc Layer에서 처리됩니다 (Line: 15).\n\n또한 레포지토리에서 getRequest는 예외를 블록 레이어에서 처리하도록 다시 던지기 위한 try-catch 블록 내에 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 2. BLOC\n\nBLOC 레이어를 관리할 때, 우리는 이벤트 및 상태를 생성합니다. 이것이 응용 프로그램 상태를 우아하게 관리하는 Flutter Bloc의 핵심 부분입니다.\n\n선호하는 IDE에서 Flutter Bloc 확장 프로그램을 사용하면 bloc을 더 빨리 생성할 수 있습니다. (이벤트, 상태, bloc을 포함하는) 보일러플레이트입니다.\n\nBloc 확장 프로그램 사용하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Bloc을 extension에 설치하세요.\n- Bloc 디렉토리를 만드세요.\n- 이 디렉토리를 마우스 오른쪽 클릭하고 New `Bloc Class`를 선택하세요.\n- 이름을 product으로 지정하면 _bloc, _event, _state가 클래스 이름에 추가됩니다. 또한 equatable를 확장할 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-APIIntegrationandStateManagementwithFlutterBLoCLibrary_3.png)\n\n세 개의 bloc 파일(클래스)을 살펴봅시다. 먼저 고려해야 할 것은 product state 입니다.\n\nproduct_state\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제품 상태는 원격 데이터 소스에서 제품을 가져오는 동안 애플리케이션이 있을 수있는 상태를 정의합니다.\n\n- 제품 초기 상태: 이름 그대로 어떠한 프로세스도 시작되기 전에 애플리케이션의 초기 상태입니다.\n\n```js\nclass ProductInitial extends ProductState {}\n```\n\n- 제품 로딩 상태: 원격 데이터 소스에서 제품을 가져오기 위한 요청이 시작됐을 때, 애플리케이션은 제품 로딩 상태를 나타내며, 이 상태는 Flutter Bloc 위젯을 통해 확인할 수 있습니다. 이 상태는 BlocListener, BlocConsumer, BlocBuilder를 통해 듣을 수 있으며, 사용자에게 요청 프로세스가 진행 중임을 보여줄 수 있도록 애플리케이션을 로딩 상태로 설정할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nclass ProductLoadingState extends ProductState {}\n```\n\n- Product Loaded State: 제품이 원격 데이터 소스에서 로드되어 화면에 표시될 수 있는 상태입니다.\n- ProductLoadedState에는 생성자에서 제품 목록(List\u003cProduct\u003e products)이 필요하며, 이는 이 상태가 가져온 제품을 화면에 표시하기 위해 발생시킵니다. (라인 13)\n\n```js\nclass ProductLoadedState extends ProductState {\n  const ProductLoadedState({required this.products});\n  final List\u003cProduct\u003e products;\n  @override\n  List\u003cObject\u003e get props =\u003e [products];\n}\n```\n\n- Product Empty State: 명시적이고 표현 계층에 로직을 줄이기 위해 상품 조회가 성공했지만 제품 데이터가 비어 있는 상태를 관리합니다. (라인 20)\n- Product Loading Failed State: 제품을 로드하는 중에 오류가 발생한 상태입니다. 이 오류는 HTTP 오류이거나 예외일 수 있습니다. 사용자 경험을 향상시키기 위해 페이지에 친절한 메시지를 표시하여 오류의 원인 또는 요청이 완료되지 않은 이유를 설명하는 것이 좋습니다. 이로 인해 ProductLoadingFailedState는 생성자에서 오류 메시지를 요구합니다. (라인 22)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플러터 Bloc을 사용할 때 애플리케이션에서 모든 것은 이벤트와 상태에 기반합니다. 단일 이벤트 초기화는 애플리케이션의 여러 상태와 관련될 수 있습니다.\n\n이 시나리오에서 단일 이벤트인 GetProductEvent를 선언합니다. 이 단일 이벤트의 초기화는 다양한 애플리케이션 상태(ProductLoadingState, ProductLoadedState, ProductEmptyState, ProductLoadingFailedState)를 발생시킬 수 있습니다.\n\n```dart\npart of 'product_bloc.dart';\n\nabstract class ProductEvent extends Equatable {\n  const ProductEvent();\n  // TODO: implement props\n  @override\n  List\u003cObject?\u003e get props =\u003e [];\n}\n\nclass GetProductEvent extends ProductEvent {}\n```\n\n그 다음, 이벤트를 상태로 매핑합니다. 이전 Bloc 클래스에서 최근 업데이트 이전에 사용된 용어로 (mapEventToState)를 사용하여 이벤트를 상태로 기본적으로 매핑하는 것이 매우 좋다고 생각합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이벤트와 상태 간의 매핑이 구현되어 있습니다. Bloc은 새로운 상태를 발생시킬 수 있는 Emitter를 사용합니다.\n\n아래 Bloc은 단순히 이벤트의 초기화를 보여줍니다. Emitter는 Product State를 확장하여 다른 상태를 발생시킬 수 있습니다. 이 경우 GetProductEvent에서 Emitter`ProductState`를 사용합니다.\n\nBloc은 저장소로부터 디코딩된 응답과 통신하며, 저장소는 원시 데이터를 제공하는 데이터 제공자와 통신합니다.\n\nProductRepository는 BlocProvider 래퍼를 통해 프레젠테이션 레이어(위젯)에 주입되거나 제공될 것입니다. 그러나 먼저 Bloc에 집중해 보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 블록 파일은 이벤트를 상태에 매핑하는 것을 관리합니다:\n\n- getProducts()는 제품 목록을 반환합니다 (17번 라인)\n- getProducts()가 성공적으로 반환되면 제품이 비어 있는지 확인합니다 (18번 라인)\n- 제품이 비어 있다면 ProductEmptyState를 발생시키고, 그렇지 않으면 제품 데이터로 getProducts()가 성공적입니다.\n- ProductLoadedState를 발생시키면 반환된 제품이 ProductLoadedState에 의해 발생합니다 (21번 라인)\n- 우리는 여기서 try-catch 메서드를 사용하는데, 예외는 handleExceptionWithMessage() 메서드로 처리됩니다. 이 함수는 예외를 캡처하고 친숙한 메시지를 반환하여 관리합니다. FormatException, SocketException, NetworkImageLoadException의 스택 추적을 사용자에게 보여주고 싶지 않을 것입니다.\n\n예외 처리기\n\n참고: 예외를 관리하는 더 많은 방법이 있습니다. 본 문서는 주로 예외 처리에 중점을 둔 것이 아니지만, 이 방법을 사용하여 Kosher!를 반복할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\nimport 'dart:async';\nimport 'dart:io';\n\nString handleExceptionWithMessage(dynamic error) {\n  if (error is SocketException) {\n    return \"인터넷에 연결되지 않은 것 같습니다.\";\n  } else if (error is TimeoutException) {\n    return \"요청 시간이 초과되었습니다. 안정적인 인터넷 연결이 있는지 확인해주세요.\";\n  } else {\n    return \"오류가 발생했습니다. 다시 시도해주세요.\";\n  }\n}\n```\n\nhandleExceptionWithMessage() 함수는 발생한 예외에 대한 설명을 반환합니다. 이 경우에는 두 가지 종류의 예외 유형(SocketException; 인터넷 연결이 없을 때 발생, TimeoutException; HTTP 요청의 설정된 시간 초과할 때 발생)만 확인합니다.\n\n# 3. 프레젠테이션\n\n데이터와 블록 레이어가 준비되어 있으며, 프레젠테이션에는 데이터를 표시하는 위젯이 포함되어 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nBloc 이벤트 또는 상태에 액세스하기 전에는 애플리케이션에 이 Bloc을 제공해야 합니다.\n\nBlocProvider 및 Repository Provider를 사용한 의존성 주입(DI)\n\nBlocProvider는 Flutter 위젯으로, BlocProvider.of` T`(context)를 통해 자식 위젯에 bloc을 제공합니다. 이는 의존성 주입(DI) 위젯으로 사용되어 서브트리 내에서 여러 위젯에 대해 단일 bloc 인스턴스를 제공할 수 있도록 합니다.\n\n대부분의 경우 BlocProvider는 서브트리의 나머지 부분에서 사용할 새로운 bloc을 생성하는 데 사용되어야 합니다. 이 경우 BlocProvider는 bloc을 생성하는 것에 대한 책임이 있으므로 자동으로 그것을 닫아 줄 것입니다. (출처: Flutter Bloc 문서)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 Bloc을 main.dart의 최상위 부모 위젯 (MaterialApp)에 제공합니다.\n\nBloc 이벤트를 초기화하고 상태를 관리합니다\n\n제품을 표시하는 페이지가 생성되었을 때 (initState) 이 페이지의 초기화에서 Bloc 이벤트 (GetProductEvent)를 호출하거나 추가합니다.\n\n```dart\n@override\nvoid initState() {\n  context.read\u003cProductBloc\u003e().add(GetProductEvent());\n  super.initState();\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGetProductEvent이 호출될 때, BlocBuilder는 상태를 통해 생성되는 위젯(제품 로딩 위젯, 제품 로딩 오류 위젯 등)을 관리할 수 있는 Bloc 위젯으로 추가됩니다.\n\n만세! 위 예제를 통해 Flutter Bloc을 사용한 API 통합 및 상태 관리의 기본 개념이 설명되었습니다.\n\n이 예제의 전체 프로젝트 코드는 GitHub에서 확인할 수 있습니다: https://github.com/waleajepe/flutter_bloc_api\n\n이 개념을 더 잘 이해하기 위해 Flutter Bloc 라이브러리 팀 (Very Good Ventures 팀)이 제공하는 더 많은 예제를 읽고 확인하는 것이 좋습니다: https://bloclibrary.dev/getting-started/\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 이 기사가 도움이 되었다면 👏 몇 개 클랩(claps)도 부탁드려요. 댓글 섹션에 기여와 수정 사항을 남겨주셔도 됩니다. 건배! 👊😊","ogImage":{"url":"/assets/img/2024-06-19-APIIntegrationandStateManagementwithFlutterBLoCLibrary_0.png"},"coverImage":"/assets/img/2024-06-19-APIIntegrationandStateManagementwithFlutterBLoCLibrary_0.png","tag":["Tech"],"readingTime":9},{"title":"플러터플로우 Low-Code 앱 개발을 위한 빠른 프로토타이핑 좋은 점, 나쁜 점 및 플로우","description":"","date":"2024-06-19 08:06","slug":"2024-06-19-FlutterFlowRapidPrototypingforLow-CodeAppDevelopmentTheGoodtheBadandtheFlow","content":"\n\n플러터플로우는 로우코드 앱 개발 분야에서 중요한 역할을 하는 기업으로 떠오르고 있어요. 와이컴비네이터의 지원을 받은 플러터플로우는 구글 클라우드와 협력하여 1,250,000명 이상의 사용자로 이루어진 활발한 커뮤니티를 자랑해요. 그런데 무엇이 이렇게 매력적으로 만드는 걸까요? 그리고 여러분의 프로젝트에 정말로 적합한 도구일까요? 함께 알아봐요.\n\n![이미지](/assets/img/2024-06-19-FlutterFlowRapidPrototypingforLow-CodeAppDevelopmentTheGoodtheBadandtheFlow_0.png)\n\n# 플러터플로우란 무엇인가요?\n\n플러터플로우는 플러터(Flutter)를 활용한 비주얼 앱 빌더로, 구글의 오픈소스 UI 소프트웨어 개발 키트입니다. 이를 통해 광범위한 코딩 지식 없이도 모바일 및 웹용 고품질의 크로스 플랫폼 앱을 만들 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 개발 가속화를 위한 핵심 기능\n\nFlutterFlow는 앱 개발 프로세스를 간소화하기 위해 설계된 다양한 기능을 제공합니다:\n\n- 테마 설정 및 드래그 앤 드롭 UI: FlutterFlow의 디자인 시스템을 활용해 앱에 일관되고 반응형 비주얼 스타일을 생성할 수 있습니다. 몇 번의 클릭으로 색상, 글꼴 및 위젯 테마를 정의하고 다크 모드를 구현할 수 있습니다. 맞춤형 테마로 시각적으로 매력적인 인터페이스를 구축하기 쉽습니다. 미리 제작된 UI 구성 요소(버튼, 텍스트 필드, 이미지 등)를 앱 캔버스에 직접 끌어다 놓아 크기, 색상, 정렬 등의 속성을 시각적 편집기를 통해 조정할 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-FlutterFlowRapidPrototypingforLow-CodeAppDevelopmentTheGoodtheBadandtheFlow_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 액션 플로우 편집기: 이 플로우차트 형식의 시스템은 단순한 UI 디자인을 넘어서며 복잡한 앱 동작을 정의하는 데 활용할 수 있습니다. 화면 간 이동, 사용자 입력 처리, 애니메이션 트리거 등을 코드를 작성하지 않고도 정의할 수 있습니다. 액션은 시각적 다이어그램으로 연결되어 있어 기본 프로그래밍 지식만 갖춘 사람들도 직관적으로 작업할 수 있습니다.\n\n![image](/assets/img/2024-06-19-FlutterFlowRapidPrototypingforLow-CodeAppDevelopmentTheGoodtheBadandtheFlow_2.png)\n\n- 맞춤화: 내장되지 않은 기능도 플러터플로우를 통해 상당히 맞춤화할 수 있습니다. 고유한 UI 요소를 추가하거나 서드파티 라이브러리와 통합하기 위해 사용자 정의 위젯을 생성할 수 있습니다. 사용자 정의 함수를 사용하여 특정 로직을 처리할 JavaScript 스니펫을 작성할 수 있습니다. 사용자 정의 액션은 기본적으로 액션 플로우 편집기 내에서 재사용 가능한 로직으로 작동하는 함수로, 패키지화된 로직을 만들 수 있습니다.\n- AI 기반 생성: 플러터플로우는 개발 가속화를 위해 두 가지 다른 방식으로 AI를 활용합니다: 1. 페이지 및 구성 요소 생성: 필요한 페이지 또는 구성 요소의 유형을 설명하면(예: \"이미지 캐러셀과 '장바구니에 추가' 버튼이 있는 제품 세부정보 페이지\"), AI가 코드 제안이나 완전한 레이아웃을 생성해줍니다. 아이디어 프로토타입을 신속히 만들거나 디자인 장벽을 극복하는 데 특히 유용합니다. 2. 코딩 코파일럿: 이 AI 기반 어시스턴트는 사용자 정의 기능과 액션을 작성하는 데 도움을 줍니다. 원하는 기능을 자연어로 설명하면 코파일럿이 코드 스니펫이나 완전한 함수를 제안해줍니다. 의도를 이해하고 지능적인 제안을 해주는 코딩 파트너가 있는 것처럼 동작합니다.\n\n# 백엔드 통합: Firebase 대 Supabase\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nFlutterFlow은 Firebase와 Supabase와의 완벽한 통합을 제공하여 강력한 백엔드 서비스를 선택할 수 있도록 합니다.\n\n- Firebase: 구글이 후원하는 이 플랫폼은 실시간 데이터베이스, 인증, 클라우드 함수, 저장소 및 호스팅으로 유명합니다. FlutterFlow의 통합은 앱을 이러한 서비스에 연결하여 사용자 로그인, 파일, 이미지 및 비디오 업로드, 클라우드 기반 로직과 같은 기능을 쉽게 활성화할 수 있도록 합니다.\n\n![image](/assets/img/2024-06-19-FlutterFlowRapidPrototypingforLow-CodeAppDevelopmentTheGoodtheBadandtheFlow_3.png)\n\n- Supabase: PostgreSQL을 기반으로 한 Firebase의 오픈 소스 대안을 제공합니다. 관계형 데이터베이스와 실시간 기능을 갖추며 인증, 저장소 및 엣지 함수를 제공합니다. FlutterFlow의 통합은 Firebase보다 성숙도가 낮지만 SQL 데이터베이스를 선호하거나 더 많은 유연성을 원하는 사용자에게는 좋은 선택지입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image](/assets/img/2024-06-19-FlutterFlowRapidPrototypingforLow-CodeAppDevelopmentTheGoodtheBadandtheFlow_4.png)\n\n# 광범위한 통합\n\nFlutterFlow는 다음과 같은 기능을 위한 사용 준비 완료 통합 라이브러리를 제공합니다:\n\n- Google Maps: 상호 작용하는 지도 및 위치 기반 서비스를 앱에 포함시킵니다.\n- 푸시 알림: 대상 메시지를 사용자 장치로 전송합니다.\n- OneSignal: 이메일 및 SMS를 보낼 수 있는 강력한 플랫폼.\n- Mux Livestream: 앱에 라이브 스트리밍 기능을 추가합니다.\n- Gemini AI: 챗봇 및 이미지 인식과 같은 AI 기능을 추가합니다.\n- API 통합 및 클라우드 함수: 외부 서비스 또는 사용자 정의 백엔드 로직과 통합합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 발행, 분석 및 수익화\n\nFlutterFlow은 Play Store와 App Store와의 직접 통합을 통해 앱 게시를 간단하게 합니다. Google Analytics와 Firebase 충돌 보고를 사용하여 사용자의 행동을 추적하고, AdMob, Stripe 또는 RevenueCat으로 수익을 창출할 수 있습니다.\n\n# 내 평가: 장단점\n\n장점:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 빠른 프로토타입 및 개발.\n- MVP 및 간단한 앱에 탁월함.\n- 포괄적인 기본 기능 및 통합.\n- 플러터 라이브러리의 사용자 정의 및 활용 가능.\n- 지원하는 커뮤니티가 활발함.\n\n단점:\n\n- 브랜치 병합이 어려울 수 있음 (지속적으로 개선 중).\n- 고객 지원 시간은 영업일과 미국 시간대에 고정되어 있음.\n- 클라우드 기능 버그 해결이 어려울 수 있음.\n- 코드는 내보낼 수 있지만 다시 가져올 수는 없음.\n- 생성된 코드는 FlutterFlow 외부에서 편집할 수 없지만 FlutterFlow 외부에서 사용자 정의 코드를 테스트하고 다시 FlutterFlow로 복사할 수 있음.\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플러터플로우는 깊은 코딩 지식 없이 빠르게 기능이 있는 앱을 만들고 싶은 개인 및 소규모 팀에게 훌륭한 도구입니다. 그러나 코드베이스 브랜치 및 병합, 플러터 상태 관리 및 사용자 지정 코드 유지보수와 관련된 부분에서는 기능이 제한될 수 있어서, 요구 사항이 복잡한 대규모 팀이나 프로젝트에는 맞지 않을 수 있습니다.\n\n아이디어를 검증하거나 비교적 간단한 앱을 만들고자 하는 경우에는 플러터플로우를 살펴볼 가치가 있습니다. 그러나 규모 확장이나 코드베이스에 세밀한 제어가 필요한 경우에는 플러터를 직접 사용하는 것을 고려해보세요.\n\n플러터 애플리케이션을 만들고 싶은 창업자이신가요?\n\ncto@ctoforstartups.com으로 연락주시거나 여기에 메시지를 남기시면 저희가 연락드리겠습니다. 앱 아이디어를 실현하는 방법에 대해 함께 논의해봐요!","ogImage":{"url":"/assets/img/2024-06-19-FlutterFlowRapidPrototypingforLow-CodeAppDevelopmentTheGoodtheBadandtheFlow_0.png"},"coverImage":"/assets/img/2024-06-19-FlutterFlowRapidPrototypingforLow-CodeAppDevelopmentTheGoodtheBadandtheFlow_0.png","tag":["Tech"],"readingTime":5},{"title":"플러터를 배워야 하는 이유","description":"","date":"2024-06-19 08:05","slug":"2024-06-19-WhyYouShouldLearnFlutter","content":"\n\n그 '플러터가 죽고 있는가?' 글을 또 읽었어요. 거의 우스워요. 왜 그렇게 많은 사람들이 이에 대해 포스팅하는지 이해가 안 가네요.\n\n아마도 플러터가 너무 쉽다는 심금을 닫고 있는 믿음 때문인가요? \"플러터가 진짜일 리가 없어. 너무 간단하니까. 꿈꾸고 있는 거예요, 그렇죠?\"\n\n저는 플러터가 사라질 위험이 있는 것 같지 않아요. 저번 포스트에서 주장했던 것처럼 많은 사람들이 사용하고 있고, 구글도 포함되어 있으니까요. 그래서 '플러터가 죽고 있는가'라는 글을 또 보면 실로 우습다는 생각이 들어요. 하지만 읽었던 글 중에서 정확히 동의하진 않는 부분이 있어요.\n\n그 댓글이 진짜 짜증나요. 곰곰이 생각해 보니 언어를 배우는 이유는 다양한데 'XYZ 언어는 배우지 마세요'라고 말하는 건 단순해서 어떤 맥락도 고려하지 않고 이야기하는 안 좋은 조언이에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n언어를 배우는 가장 중요한 이유는 취업이라고 생각해요. 그리고 언어를 배우는 이유가 단지 취업 때문이라면, 그렇죠, 플러터를 배우지 않아도 돼요. 사실 여기서도 그렇게 언급했어요.\n\n플러터는 아직 너무 새로운 기술이라서 많은 사람들이 사용하고 있지 않아요. 앞으로 플러터 포지션의 잠재력을 볼 수는 있지만, 지금은 수요가 충분하지 않아요.\n\n다만 저는 개인적으로 취업을 위해 언어를 배우는 건 강력한 이유라고 보지 않아요. 취업을 목적으로 임의의 언어를 배우는 게 좋지 않아요. 채용 공고를 보고, 충분히 많이 Go를 언급하는 채용 공고를 보면 Go를 배우게 되고요. 충분히 많이 C#을 언급하는 채용 공고를 보면 C#을 배우게 되는 거죠. 실제로 Flutter를 언급하는 채용 공고를 몇 개 보았어요. 하지만 다른 프로그래밍 언어들보다는 훨씬 적었어요. 그동안 오랜 시간 동안 사용되어온 다른 프로그래밍 언어들만큼 많지 않았어요.\n\n또한, 저는 Go 프로그래밍 여정에서 Go에 대해 왜 이렇게 많은 어리석은 일을 하는지 궁금해했어요. 그 결론은 2007년에 발명되었기 때문에, 현대 프로그래밍 아이디어가 많이 나오기 전이었기 때문이에요. 그저 시대 문제일 뿐이에요. Dart는 2017년에 출시된 Flutter 이후에야 인기를 얻었기 때문에, 그저 시간 문제일 뿐이에요. 더 기다리세요. 10년 후면 누구나 플러터 개발자를 찾을 거예요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로그래밍 언어에 동기부여를 받는 가장 좋은 방법 중 하나는 사이드 프로젝트를 진행하는 것입니다. 많은 프로그래머가 사이드 프로젝트를 갖고 있지 않다는 것을 알고 있습니다. 사이드 프로젝트가 없어도 전혀 괜찮아요. 하지만 많은 프로그래머들이 사이드 프로젝트를 가지고 있죠. 자신이 더 잘할 수 있는 부분을 발견하고 스스로 해결해나가는 것이 쉬운 방법이기 때문입니다. 제가 개발한 RSS 리더 Stratum(iOS, Android)와 언어 학습 앱 Litany(iOS, Android) 역시 그런 아이디어에서 출발되었습니다.\n\n사이드 프로젝트를 진행해보고 싶다면 Flutter를 강력히 고려해보세요. 왜냐하면 Flutter에는 여러 가지 이유가 있기 때문이에요. 일단, 이 프레임워크는 믿을만하고 직관적입니다. 또한, Windows, Mac, Linux, Android, iOS, 웹에 대해 빌드할 수 있습니다. 그리고 제가 이전 글에서 언급한 대로 Dart와 Flutter에 대한 풍부한 문서가 있습니다. 하지만 아마도 가장 중요한 점은 Flutter를 구동하는 언어인 Dart가 사용하기 아주 쉽다는 점입니다.\n\nDart는 C 스타일의 객체 지향 언어입니다. 멋진 언어죠. COOL이란 말은 원래 C#의 이름이었지만 마이크로소프트가 상표 문제로 결정하지 않았습니다. 하지만 이러한 분류인 'C 스타일 객체 지향 언어'라는 용어를 좋아합니다. 이는 모두 객체 지향적인 C 스타일의 언어들이라는 것을 잘 알려주거든요.\n\n한 가지 COOL 언어를 알고 있다면 다른 언어를 쉽게 배우실 수 있습니다. 특히 비슷한 언어일수록 더욱 쉽게 배우실 수 있습니다. 그리고 Dart는 자바나 C#과 매우 유사합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사실, 플러터를 사용하기 전에 Unity(C#을 사용)에서 프로그래밍을 하고 있었는데, C#과 Dart가 얼마나 비슷한지 놀랐습니다. 가장 큰 차이점은 Dart가 조금 더 간결하다는 것입니다. 그래서 public 또는 private는 없고 언더스코어로 처리됩니다. 그리고 factory 생성자와 foo(this.x, this.y)와 같은 생성자가 있습니다.\n\n저는 null 안전성이 도입되기 전에 Dart를 사용하기 시작했지만, null 안전성은 몇 가지를 변경했습니다. 많이는 아닙니다. 다른 C 스타일 객체지향 언어를 알고 있다면 Dart를 매우 빠르게 익힐 수 있습니다. 아마도 하루만에도 가능할 정도로 간단합니다.\n\nFlutter를 배우지 않겠다고 말했던 것을 되돌릴 수도 있을 것 같습니다. 일자리가 매우 적다는 것을 고려해야 하기 때문입니다. 또한 언어를 실제로 배우는 난이도도 고려해야 합니다.\n\n많은 언어는 매우 지루한 프로젝트를 중심으로 돌아가기 때문에 쉽게 익히기가 어려울 수 있습니다. 그러나 Flutter를 사용하면 앱을 만들 수 있습니다. 그리고 굉장히 쉽게 만들 수도 있습니다. 그리고 그 앱은 이제 Windows, Mac, Linux, iOS, Android, 웹에서도 실행할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플러터는 매년 더욱 인기를 끌 것입니다. 결국 플러터 관련 직업이 많이 나올 것이라고 생각해요.\n\n그래서 원래 글이 전부 틀린 것은 아닐 수도 있어요. '놀기만 하고 싶다면 그렇게 해도 괜찮을 거야' 라는 말이 맞았군요. 그렇다면, 진지하게 배우고 싶지 않다면 '언어를 배운다'는게 무슨 뜻인가요? 진지하게 공부하고 싶다면 면접 질문들을 많이 읽어보세요.\n\n저는 그 글의 말대로 '진지한 전문 개발자'는 아니에요. 언어를 배우는 것을 즐기는 것을 더 좋아해요. 플러터는 재미있어요. 그리고 정말 멋진 것을 만들어낼 수 있어요.\n\n그겼 초보자에게는 자바스크립트와 비슷합니다. 다만, 플러터는 언어 자체가 좋다는 것이 다릅니다. 자바스크립트를 사용하면 물론 웹을 만들 수 있고, Electron으로 데스크톱 앱을 만들 수 있고, React Native로 모바일 앱을 만들 수 있어요. 하지만 플러터를 사용하면 세 가지를 한 번에 간단한 코드베이스로 만들 수 있어요. 이것과 유사한 기술이 없어요. 그래서 플러터를 배워야 하는 이유죠.","ogImage":{"url":"/assets/img/2024-06-19-WhyYouShouldLearnFlutter_0.png"},"coverImage":"/assets/img/2024-06-19-WhyYouShouldLearnFlutter_0.png","tag":["Tech"],"readingTime":4},{"title":"2024년 소셜 앱에서 사용할 5가지 플러터 패키지","description":"","date":"2024-06-19 08:03","slug":"2024-06-19-5Flutterpackagestouseinyour2024SocialApp","content":"\n\n패키지에 대한 다른 기사가 나왔네요. 이번에는 소셜 앱을 만들 때 선호하는 패키지를 공유하려고 해요. 회사에서는 사용자 간 상호 작용이 최소한인 작은 앱부터 완전한 소셜 네트워크까지 다양한 소셜 앱을 개발했어요. 소셜 앱을 만드는 것은 도전적일 수 있지만 사용자 사이의 직접적인 상호 작용을 항상 즐기며 앱이 어떻게 발전하는지 바뀌는 것을 관찰하는 것을 즐겨요.\n\n그런 의미에서, 소셜 앱을 만들 때 선호하는 패키지를 살펴보겠어요.\n\n- getstream.io — 활동 피드\n\n![2024-06-19-5Flutterpackagestouseinyour2024SocialApp_0.png](/assets/img/2024-06-19-5Flutterpackagestouseinyour2024SocialApp_0.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n많은 사람들이 이 멋진 라이브러리/서비스를 이미 알고 있을 것이라고 확신합니다. 이 라이브러리는 몇 가지 인기있는 Flutter 앱에서 사용되고 있습니다. Stream (또는 getstream)은 모든 것을 처음부터 만들 필요 없이 앱용 소셜 피드/활동 피드를 구축하는 데 도움이 되는 패키지를 제공합니다. 이 패키지에는 좋아요, 댓글, 반응, 게시된 링크에 대한 자동 미리보기, 알림 및 앱에 필요한대로 피드를 표시하기 위한 사용자 정의 랭킹 시스템도 포함되어 있습니다.\n피드에 대한 시스템은 일반적으로 직접 만듭니다. 그러나 getstream을 빠른 대안으로 사용할 수 있는 옵션을 갖는 것은 매우 환영할 만한 일입니다. 더욱 좋은 점은, 앱이 소규모이고 수익이 적다면, 서비스 전체가 무료*입니다(신청 후 며칠 후에 연락이 옵니다).\n패키지를 확인하려면 여기를 클릭하세요.\n\n---\n\n마크다운 형식으로 변환된 텍스트입니다.너와 나는 getstream과 전혀 관련이 없다. 저는 앱을 개발할 때 사용하는 도구에 대한 솔직한 의견을 전하고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. flutter_reaction_button\n\n![flutter_reaction_button](/assets/img/2024-06-19-5Flutterpackagestouseinyour2024SocialApp_1.png)\n\nFlutter Reaction Button은 여러분이 직접 만든 Activity 피드(스트림을 사용하지 않고 모든 것을 처음부터 만든 경우)에서 Reactions을 제공할 수 있게 해주는 패키지입니다. 사용자 정의가 가능하며 여러분의 반응 이모티콘을 사용하여 버튼을 만들 수 있습니다.\n\n사용법은 매우 간단합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nReactionButton\u003cString\u003e(\n    onReactionChanged: (Reaction\u003cString\u003e? reaction) {\n        debugPrint('선택된 값: ${reaction?.value}');\n    },\n    reactions: \u003cReaction\u003cString\u003e\u003e[\n        Reaction\u003cString\u003e(\n            value: 'like',\n            icon: widget,\n        ),\n        Reaction\u003cString\u003e(\n            value: 'love',\n            icon: widget,\n        ),\n        ...\n    ],\n    initialReaction: Reaction\u003cString\u003e(\n        value: 'like',\n        icon: widget,\n    ),\n    selectedReaction: Reaction\u003cString\u003e(\n        value: 'like_fill',\n        icon: widget,\n    ),\n)\n```\n\n해당 패키지를 확인할 수 있습니다.\n\n4. chat_bubbles\n\ngetstream을 사용하여 채팅/메시징 시스템을 구축할 수 있지만, 많은 사람들(저 포함, 앱에 따라 다름)은 자체 시스템을 구축하는 것을 선호할 수 있습니다. chat_bubbles 위젯은 Whatsapp 및 다른 인기있는 앱과 유사한 메시징 시스템을 위한 간단한 Bubble UI를 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이는 텍스트, 이미지, 오디오 및 날짜를 위한 버블을 포함하고 있습니다. 그뿐만 아니라, 사용할 준비가 끝난 메시지 바도 제공되어서 만들고 싶은 채팅 UI에 신경 쓸 필요 없이 다른 작업에 집중할 수 있습니다. Firebase Firestore와 함께 빠른 메시지 시스템으로 사용할 수 있습니다.\n\n이 패키지를 여기에서 확인할 수 있습니다.\n\n5. any_link_preview\n\nAny Link Preview는 이름에서 알 수 있듯이 정확히 그 역할을 합니다. URL이 게시된 경우(예: 사용자 활동 피드나 메시지 시스템 등), 앱은 Medium, Facebook 또는 기타 앱에서 발생하는 것과 동일한 미리보기를 생성합니다. 이 패키지는 Open Graph, Twitter Cards, JSON 등에서 메타데이터를 가져오는 것을 지원하며, 이전에 설명한 linkfy_text 패키지와 동일한 방식으로 사용됩니다. Text()를 AnyLinkPreview()로 대체하십시오. 위젯도 매우 사용자 정의가 가능하여 UI 요구 사항에 맞게 조정할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예시:\n\n```js\nAnyLinkPreview(\n    link: \"https://vardaan.app/\",\n    displayDirection: UIDirection.uiDirectionHorizontal,\n    showMultimedia: false,\n    errorBody: '내 맞춤 오류 본문 표시',\n    errorTitle: '내 맞춤 오류 제목 표시',\n    errorWidget: Container(\n        color: Colors.grey[300],\n        child: Text('앗싸!'),\n    ),\n    errorImage: \"https://google.com/\",\n    cache: Duration(days: 7),\n    onTap: (){}, // 탭 이벤트 비활성화\n)\n```\n\n5+1. insta_image_viewer\n\n이 플러그인은 소셜 앱에 엄격히 제한되지는 않지만 많은 앱에서 사용되었습니다. 이를 사용하면 인스타그램과 같이 이미지를 전체 화면에 표시하는 간단한 위젯에 액세스할 수 있습니다. 이미지를 확대 및 축소하고 닫기를 스와이프할 수 있습니다. 사용자 아바타, 갤러리 이미지 또는 기타 용도로 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예시:\n\n```js\nSizedBox(\n  width: 100,\n  height: 140,\n  child: InstaImageViewer(\n    child: Image(\n      image: Image.network(\"https://picsum.photos/id/507/1000\").image,\n    ),\n  ),\n),\n```\n\n우리 팀이 소셜 앱을 개발할 때 가장 일반적으로 사용하는 패키지들입니다. 기존 앱에서 이미 사용자가 알고 있는 기능을 제공하기 때문에 사용하기 편리합니다. 여러분이 소셜 앱 개발에 사용하는 패키지가 있다면 댓글로 알려주세요.\n\n다음 글에서는 코드를 구성하는 방법에 대한 시리즈를 이어가며, 다음 글에서는 스타일과 에셋을 구성하는 방법에 대해 이야기할 예정이니 많은 기대 부탁드립니다. 아직 이 내용을 읽지 않으셨다면, 이전 이야기를 방문해보세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음에 또 만나요! Flutter를 즐기세요.","ogImage":{"url":"/assets/img/2024-06-19-5Flutterpackagestouseinyour2024SocialApp_0.png"},"coverImage":"/assets/img/2024-06-19-5Flutterpackagestouseinyour2024SocialApp_0.png","tag":["Tech"],"readingTime":4},{"title":"노선 정의하기","description":"","date":"2024-06-19 06:52","slug":"2024-06-19-DefiningRoutes","content":"\n# 루트 정의\n\n\u003e 계속하기 전에 라우팅 기본 사항 페이지를 읽기를 권장합니다.\n\n이 페이지에서는 Next.js 어플리케이션에서 루트를 정의하고 구성하는 방법을 안내해 드립니다.\n\n## 루트 생성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNext.js(넥스트.제이에스)는 파일 시스템을 기반으로 하는 라우터를 사용합니다. 여기서 폴더는 경로를 정의하는 데 사용됩니다.\n\n각 폴더는 URL 세그먼트에 매핑되는 경로 세그먼트를 나타냅니다. 중첩 된 경로를 만들려면 서로에게 폴더를 중첩시킬 수 있습니다.\n\n이미지 파일\n![이미지](/assets/img2024-06-19-DefiningRoutes_0.png)\n\n특별한 page.js 파일을 사용하여 경로 세그먼트를 공개적으로 접근할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img2024-06-19-DefiningRoutes_1.png)\n\n이 예시에서 /dashboard/analytics URL 경로는 공개적으로 접근할 수 없습니다. 왜냐하면 해당 페이지에 대응하는 page.js 파일이 없기 때문입니다. 이 폴더는 컴포넌트, 스타일시트, 이미지 또는 다른 동료 파일을 저장하는 데 사용될 수 있습니다.\n\n\u003e 참고: 특별한 파일에는 .js, .jsx 또는 .tsx 파일 확장자를 사용할 수 있습니다.\n\n## UI 생성\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n특별 파일 규칙을 사용하여 각 경로 세그먼트에 UI를 생성합니다. 가장 흔한 것은 경로에 고유한 UI를 보여주는 페이지이고, 여러 경로에서 공유되는 UI를 보여주는 레이아웃입니다.\n\n예를 들어, 첫 번째 페이지를 만들기 위해 앱 디렉토리 내에 page.js 파일을 추가하고 React 컴포넌트를 내보냅니다:\n\n```js\nexport default function Page() {\n  return \u003ch1\u003e안녕, Next.js!\u003c/h1\u003e;\n}\n```\n","ogImage":{"url":"/assets/img/2024-06-19-DefiningRoutes_0.png"},"coverImage":"/assets/img/2024-06-19-DefiningRoutes_0.png","tag":["Tech"],"readingTime":1},{"title":"디폴트js","description":"","date":"2024-06-19 00:56","slug":"2024-06-19-defaultjs","content":"\n# default.js\n\ndefault.js 파일은 Next.js에서 전체 페이지 로드 후 슬롯의 활성 상태를 복구할 수 없을 때 병렬 경로 내에서 폴백을 렌더링하는 데 사용됩니다.\n\n소프트 네비게이션 중에 Next.js는 각 슬롯에 대한 활성 상태(하위 페이지)를 추적합니다. 그러나 전체 페이지 로드 시 하드 네비게이션의 경우 Next.js는 활성 상태를 복구할 수 없습니다. 이 경우 현재 URL과 일치하지 않는 하위 페이지에 대해 default.js 파일을 렌더링할 수 있습니다.\n\n다음과 같은 폴더 구조를 고려해보세요. @team 슬롯에는 설정 페이지가 있지만 @analytics에는 없습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img2024-06-19-defaultjs_0.png\" /\u003e\n\n/settings으로 이동하면 @team 슬롯은 설정 페이지를 렌더링하면서 @analytics 슬롯의 현재 활성 페이지를 유지합니다.\n\n새로고침하면 Next.js가 @analytics에 default.js를 렌더링합니다. default.js가 없는 경우 404가 대신 렌더링됩니다.\n\n추가로 children이 암시적인 슬롯인데, 부모 페이지의 활성 상태를 복원할 수 없을 때 Next.js가 대체 화면을 렌더링하기 위해 default.js 파일을 만들어야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## Props\n\n### params (선택사항)\n\n루트 세그먼트부터 슬롯 하위 페이지까지의 동적 라우트 매개변수가 포함된 객체입니다. 예를 들어:\n\n\n| Example                                  | URL        | params                            |\n| ---------------------------------------- | ---------- | --------------------------------- |\n| app/@sidebar/[artist]/default.js         | /zack      | { artist: 'zack' }                |\n| app/@sidebar/[artist]/[album]/default.js | /zack/next | { artist: 'zack', album: 'next' } |\n\n","ogImage":{"url":"/assets/img/2024-06-19-defaultjs_0.png"},"coverImage":"/assets/img/2024-06-19-defaultjs_0.png","tag":["Tech"],"readingTime":2},{"title":"코틀린 멀티 플랫폼 모바일이 플러터를 대체하고 있을까요","description":"","date":"2024-06-19 00:39","slug":"2024-06-19-IsKotlinMultiplatformMobileReplacingFlutter","content":"\n\n\u003cimg src=\"/assets/img/2024-06-19-IsKotlinMultiplatformMobileReplacingFlutter_0.png\" /\u003e\n\n요즘들어 Kotlin Multiplatform (KMM)과 Flutter에 대한 논쟁이 격화되고 있습니다. 일부는 KMM이 Flutter을 대체할 수도 있다고 제안하고 있지만, 이게 진실일까요?\n\nKMM과 Flutter는 Android와 iOS용 모바일 앱을 하나의 코드베이스로 개발하는 강력한 도구로 자리매김했습니다. 그러나 두 도구는 서로 다른 필요와 개발 접근 방식을 충족시키고 있습니다. 본 글은 KMM과 Flutter의 장단점을 분석하여 균형 잡힌 시각을 제공하고, 다음 프로젝트에 가장 적합한 프레임워크를 결정하는 데 도움이 되도록 하고 있습니다.\n\n# 크로스 플랫폼 모바일 개발 이해하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n크로스 플랫폼 앱 개발은 iOS와 Android와 같은 여러 운영 체제에서 실행할 수 있는 모바일 애플리케이션을 빌드하는 접근 방식입니다. 이는 개발자가 앱의 핵심 기능을 한 번 작성한 다음 작은 조정만으로 다양한 플랫폼에 배포할 수 있다는 것을 의미합니다.\n\n아래는 크로스 플랫폼 개발이 점점 인기를 얻는 이유입니다:\n\n- 개발 시간 단축: 코드를 한 번 작성함으로써 여러 플랫폼을 대상으로 할 수 있으므로 Android 및 iOS용 별도의 앱을 빌드하는 것과 비교하여 개발 프로세스를 크게 가속화할 수 있습니다.\n- 더 넓은 시장 접근: 단일 코드베이스로 앱을 App Store와 Google Play Store에 동시에 출시하여 잠재적 사용자의 광범위한 관객에 접근할 수 있습니다.\n- 비용 효율성: 단일 코드베이스를 활용하여 별도의 네이티브 앱을 빌드하고 유지하는 비용을 줄일 수 있습니다.\n- 더 쉬운 유지 관리: 앱을 업데이트하는 경우 공유 코드베이스만 변경하면 되므로 유지 관리가 단순해집니다.\n\n하지만 크로스 플랫폼 개발은 어떻게 작동할까요? 여기에 간단히 설명드리겠습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 코드 공유: KMM 및 Flutter와 같은 프레임워크를 사용하면 개발자들이 비즈니스 로직 및 데이터 액세스와 같은 핵심 기능을 플랫폼 간에 공유할 수 있습니다. 이 공유 코드베이스는 중복을 줄이고 개발을 간소화합니다.\n- 네이티브 기능: 핵심 로직은 공유되지만 사용자 인터페이스(UI)는 일반적으로 플랫폼별 도구를 사용하여 구축됩니다. 예를 들어, Flutter의 경우 UI 개발에는 Dart를 사용하고, KMM은 안드로이드용 Kotlin 및 iOS용 Swift와 같은 네이티브 언어를 사용합니다. 이는 각 플랫폼에 친숙하고 최적화된 사용자 경험을 보장합니다.\n\n요컨대, 크로스 플랫폼 개발은 효율성을 위한 코드 재사용성과 원활한 사용자 경험을 위한 네이티브 기능을 모두 제공합니다.\n\n# 코틀린 멀티플랫폼 (KMM): 심층적으로 알아보기\n\n코틀린 멀티플랫폼은 크로스 플랫폼 모바일 개발에 매력적인 옵션으로 부상했습니다. 여기에는 주요 기능과 고려 사항에 대한 내용이 포함되어 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](/assets/img/2024-06-19-IsKotlinMultiplatformMobileReplacingFlutter_1.png)\n\n## Shared Powerhouse\n\nKMM shines in its ability to share code across Android and iOS platforms. This shared codebase typically handles functionalities like:\n\n- Business Logic: The core logic of your app, like data processing and calculations, can be written in Kotlin and used on both platforms.\n- Data Access: KMM allows you to implement shared code for accessing and managing data, ensuring consistency across platforms.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 플랫폼별 다듬기\n\nKMM은 공유 로직에서 뛰어난 성과를 보이지만, 사용자 인터페이스(UI)는 플랫폼별 도구를 사용하여 개발됩니다:\n\n- Android: KMM 내에서 Android UI 개발을 위해 개발자들은 Kotlin을 활용하여 작업하며, 이미 언어에 익숙한 사람들에게 친숙한 경험을 제공합니다.\n- iOS: iOS UI 개발에는 KMM이 Swift를 활용하여 Apple의 iOS 앱을 구축하는 데 사용되는 고유 언어를 활용합니다. 이를 통해 iPhone과 iPad에서 최적의 UI 성능과 네이티브한 느낌을 제공합니다.\n\n## 코틀린 멀티플랫폼의 장점:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 개발 속도 향상: 핵심 기능을 위한 코드 공유는 별도의 네이티브 앱을 빌드하는 것에 비해 개발 시간을 단축시킵니다.\n- 유지 관리 간소화: 핵심 로직에 대한 단일 코드베이스를 사용하면 업데이트와 버그 수정이 더욱 효율적으로 이루어집니다.\n- 네이티브 성능: UI 개발을 위해 플랫폼별 언어를 활용함으로써 KMM은 앱이 각 플랫폼에서 원활하고 최적화된 사용자 경험을 제공합니다.\n\n## Kotlin Multiplatform의 단점:\n\n- 학습 곡선: KMM은 순수한 플러터 개발보다 높은 학습 곡선을 갖을 수 있습니다. Kotlin과 플랫폼별 언어의 지식이 필요하기 때문입니다.\n- 프로젝트 설정: 다중 플랫폼 성격 때문에 플러터보다 KMM 프로젝트 설정이 더 복잡할 수 있습니다.\n\n전반적으로, KMM은 핵심 기능에 대한 코드 재사용성을 활용하고 각 플랫폼에서 네이티브 성능 및 UI 경험을 유지하고자 하는 개발자들에게 강력한 도구입니다. 그러나 뛰어들기 전에 학습 곡선과 프로젝트 설정 복잡성을 고려하는 것이 중요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Flutter: 포괄적인 살펴보기\n\n한편, Flutter는 크로스 플랫폼 모바일 개발에 간소한 방식으로 접근하는 인기 있는 선택지로 자리잡았습니다. Flutter가 제공하는 것을 알아보겠습니다:\n\n\u003cimg src=\"/assets/img/2024-06-19-IsKotlinMultiplatformMobileReplacingFlutter_2.png\" /\u003e\n\n## 단일 코드베이스, 큰 영향\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nFlutter은 Dart라는 현대적이고 표현력 있는 프로그래밍 언어로 작성된 단일 코드베이스를 사용하여 Android 및 iOS용 모바일 앱을 만들 수 있게 해줍니다. 이는 별도로 네이티브 앱을 처음부터 만드는 것과 비교하여 개발 시간을 크게 단축시킵니다.\n\n## 효율적인 선언형 UI\n\nFlutter는 개발자가 UI 상태를 설명하는 방식으로 선언적 UI 접근 방식을 활용합니다. 이를 통해 개발을 간소화하고 UI 디자인에 대한 빠른 반복을 가능케 합니다.\n\n## 다양한 위젯과 플러그인의 풍부한 생태계\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플러터는 다양한 기능을 제공하는 사전 제작 위젯과 플러그인이 풍부한 라이브러리를 자랑합니다. 이러한 구성 요소들은 버튼, 텍스트 필드 및 내비게이션 드로어와 같은 일반적인 UI 요소에 대한 레디메이드 컴포넌트를 제공하므로 개발을 간편하게 합니다. 게다가 플러그인은 카메라 액세스, 지리 위치 및 소셜 미디어 공유와 같은 기기 기능을 사용할 수 있도록 플러터의 기능을 확장시킵니다.\n\n## 플러터의 장점:\n\n- 신속한 개발: 단일 코드베이스, 코드 변경을 즉시 반영하는 핫 리로드 기능 및 다양한 위젯 라이브러리의 조합으로 빠른 개발 주기를 가능하게 합니다.\n- UI 중심 개발: 플러터는 시각적으로 멋지고 상호작용적인 사용자 인터페이스를 만드는 데 뛰어나며, 디자인과 사용자 경험에 중점을 둔 앱 개발자에게 좋은 선택지입니다.\n- 큰 개발자 커뮤니티: 플러터는 활기찬 개발자 커뮤니티가 있어 모든 수준의 개발자를 위한 방대한 자원, 튜토리얼 및 지원을 제공합니다.\n\n## 플러터 사용 시 고려해야 할 사항:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 제한된 네이티브 액세스: KMM과 비교했을 때, Flutter는 각 플랫폼에서 매우 특정한 네이티브 기능에 약간 더 제한된 액세스를 가질 수 있습니다. 복잡한 네이티브 통합의 경우에는 KMM이 더 적합할 수 있습니다.\n- 잠재적인 성능 오버헤드: Flutter 내에서 복잡한 UI 요소나 애니메이션을 널리 사용하는 경우 드물게, 완전히 네이티브 앱에 비해 약간의 성능 오버헤드가 발생할 수 있습니다. 그러나 대부분의 모바일 애플리케이션에 대해서 Flutter의 성능은 훌륭합니다.\n\nFlutter는 사용 편의성, 신속한 개발 능력, 아름다운 사용자 인터페이스 구축에 중점을 두어 빛을 발합니다. 그러나 매우 특정한 기능에 대한 네이티브 액세스에 대한 잠재적인 제한사항을 인지하는 것이 중요합니다.\n\n# Kotlin Multiplatform vs. Flutter: 적절한 도구 선택\n\n![Kotlin Multiplatform vs. Flutter](/assets/img/2024-06-19-IsKotlinMultiplatformMobileReplacingFlutter_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 KMM과 Flutter의 강점과 고려 사항을 탐색했으니, 다음 프로젝트에 어떤 프레임워크가 완벽한 선택인지 백만 달러 질문에 답해볼 시간입니다! 대부분의 개발과 마찬가지로, 답은 당신의 특정 요구사항과 우선 순위에 따라 다릅니다. 신중한 결정을 내릴 수 있도록 다음을 살펴보겠습니다:\n\n## Kotlin Multiplatform은 다음과 같은 경우에 이상적일 수 있습니다:\n\n- 네이티브 기능이 중요한 경우: 귀하의 앱이 Android와 iOS의 네이티브 기능과 깊은 통합이 필요한 기능에 많이 의존하는 경우 KMM의 플랫폼별 UI 개발 기능을 활용하여 Kotlin (Android) 및 Swift (iOS)를 사용하여 세밀한 제어가 가능합니다.\r\n- 팀원이 Kotlin 전문 지식을 갖고 있는 경우: 팀이 Kotlin에 대한 기존 지식을 활용하면 KMM 개발과 관련된 학습 곡선을 크게 줄일 수 있습니다.\r\n- 앱에 복잡한 공유 로직이 있는 경우: 애플리케이션이 플랫폼 간에 상당한 양의 공유 비즈니스 로직 및 데이터 액세스를 포함하는 경우 KMM의 코드 재사용성에 중점을 둠으로써 개발 및 유지보수를 간소화할 수 있습니다.\n\n## Flutter는 다음과 같은 경우에 더 좋은 선택일 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 신속한 개발과 시장 진입 시간을 우선시합니다: 플러터의 단일 코드베이스, 핫 리로드 기능 및 다양한 위젯 라이브러리는 빠른 개발 주기를 가능하게 하며 앱을 신속하게 시장에 출시할 수 있습니다.\n- 앱이 UI 중심입니다: 앱의 핵심 가치가 시각적으로 매력적이고 상호 작용이 많은 사용자 인터페이스에 있다면, 플러터의 풍부한 UI 기능과 선언적 접근 방식은 원활한 사용자 경험을 구축하기에 탁월한 선택입니다.\n- 팀원이 Dart나 유사한 언어에 익숙합니다: Dart나 Javascript와 같은 언어에 능숙한 팀은 Kotlin을 배우는 것보다 플러터 개발로의 전환이 더 원할할 수 있습니다.\n- 네이티브 기능 접근 요구가 보통 수준입니다: 플러터는 대부분의 일반적인 기기 기능에 접근할 수 있지만, 매우 구체적이고 심층적인 네이티브 통합이 필요한 프로젝트의 경우에는 KMM이 보다 유연성을 제공할 수 있습니다.\n\n결정을 내릴 때 도움이 될 수 있는 두 프레임워크의 핵심 측면을 요약한 표입니다:\n\n![표](/assets/img/2024-06-19-IsKotlinMultiplatformMobileReplacingFlutter_4.png)\n\n이 표는 일반적인 가이드라인일 뿐입니다. 결정을 내리기 전에 프로젝트 요구사항, 팀 전문성 및 원하는 결과를 신중히 평가하는 것이 가장 좋은 방법입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 크로스 플랫폼 모바일 개발의 미래\n\n크로스 플랫폼 모바일 개발 분야는 지속적으로 발전하고 있습니다. KMM과 Flutter는 각각 해당 커뮤니티에 의해 적극적으로 유지 및 개선되고 있습니다. 여기에는 미래에 무엇이 될지에 대한 예상이 담겨 있습니다:\n\n## 1. 네이티브 기능의 발전\n\nKMM과 Flutter 둘 다 공유 코드와 네이티브 기능 간의 격차를 좁히기 위한 발전이 예상됩니다. 이는 장치별 기능에 대한 개선된 액세스 및 플랫폼 간 사용자 경험을 위한 최적화를 포함할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 2. 향상된 개발자 도구 및 자원\n\n두 프레임워크가 성숙해지면서, 개발자들이 사용할 수 있는 도구, 라이브러리, 그리고 튜토리얼이 계속해서 늘어날 것으로 예상됩니다. 이를 통해 개발자들이 이러한 기술을 채택하고 견고한 크로스 플랫폼 애플리케이션을 구축하는 것이 더욱 쉬워질 것입니다.\n\n## 3. 성능 및 사용자 경험에 집중\n\n특별한 성능과 완벽한 사용자 경험을 추구하는 노력은 최우선 과제로 남을 것입니다. KMM과 Flutter는 코드 최적화, UI 렌더링, 그리고 네이티브 기능과의 통합과 같은 영역에서 개선이 있을 것으로 예상되며, 앱이 모든 기기에서 부드럽고 반응이 뛰어난 경험을 제공할 수 있도록 보장할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\nKMM이 Flutter를 \"대체\"할 수 있는지에 대한 논란은 과장되었을 수 있습니다. 대신, 두 프레임워크는 서로 다른 프로젝트 요구 사항과 개발 방법에 맞는 교차 플랫폼 모바일 앱 개발에 대한 독특한 이점을 제공합니다.\n\nKMM은 코드 재사용성과 원시 성능에 중점을 둬서, 플랫폼별 기능과 깊은 통합이 필요한 애플리케이션에 적합한 강력한 선택지입니다.\n\n한편, Flutter는 단일 코드베이스와 풍부한 UI 기능으로 빠른 개발에 뛰어나며, 시장 진입 속도와 시각적으로 멋진 사용자 경험을 최우선으로 하는 프로젝트에 이상적입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n주요 포인트는 프로젝트 요구 사항과 팀 전문성과 가장 일치하는 프레임워크를 선택하는 것입니다. KMM과 Flutter의 강점과 고려 사항을 이해함으로써, 모바일 앱 개발 프로젝트를 성공으로 이끄는 결정을 내릴 수 있습니다.\n\n크로스 플랫폼 모바일 개발의 미래는 밝습니다. KMM과 Flutter가 지속적으로 진화하여 최고의 모바일 애플리케이션을 구축할 수 있는 강력한 도구를 제공합니다. 호기심을 가져라, 가능성을 탐구하라, 즐거운 코딩하세요!","ogImage":{"url":"/assets/img/2024-06-19-IsKotlinMultiplatformMobileReplacingFlutter_0.png"},"coverImage":"/assets/img/2024-06-19-IsKotlinMultiplatformMobileReplacingFlutter_0.png","tag":["Tech"],"readingTime":8},{"title":"9 JS를 사용하여 웹에서 Whatsapp 공유하기 고급 기능 UriBaba","description":"","date":"2024-06-19 00:38","slug":"2024-06-19-9WhatsappShareintheWebUsingJSAdvancedFeatureUriBaba","content":"\n\n## 고급 JavaScript 기능에 대한 심층 탐구\n\n![이미지](/assets/img/2024-06-19-9WhatsappShareintheWebUsingJSAdvancedFeatureUriBaba_0.png)\n\nJavaScript는 많이 발전해 왔고 전 세계에서 널리 사용되는 언어 중 하나입니다. 이 기사에서는 JavaScript의 고급 기능을 사용하여 웹에서 Whatsapp 공유 기능을 논의하고 있습니다. 이를 통해 휴대폰에서 Whatsapp이 열리고 사용자가 직접 Whatsapp에서 데이터를 공유할 수 있습니다. 코드와 함께 놀아 봅시다.\n\n우리는 사용자 장치가 모바일인지 확인합니다. 모바일인 경우 공유할 휴대폰 번호나 메시지가 있어야 합니다. 둘 다 없는 경우에는 Whatsapp을 직접 열 수 없습니다. 웹의 경우 다른 URL로 리디렉션합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nif (navigator.userAgent.match(/iPhone|Android/i)) {\n  if (mobile) {\n    window.location.href = `https://wa.me/${mobile}/?text=${msg}`;\n    console.log('성공적');\n  } else if (msg) {\n    window.location.href = `https://wa.me/?text=${msg}`;\n    console.log('성공적');\n  } else {\n    console.log('에러');\n  }\n} else {\n  window.location.href = `https://web.whatsapp.com/send?text=${msg}\u0026phone=${mobile}`;\n}\n```\n\n이제 봐요. 정말 멋지죠. window.location 리다이렉트를 사용하여 웹에서 Whatsapp 공유 기능을 사용할 수 있습니다(JavaScript의 고급 기능).\n\n![이미지](/assets/img/2024-06-19-9WhatsappShareintheWebUsingJSAdvancedFeatureUriBaba_1.png)\n\nfe-pilot npm 패키지로 웹 개발을 한 단계 높여보세요! https://github.com/opensrc0/fe-pilot\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 혁신적인 JavaScript 라이브러리는 React로 제작되었으며, 웹 애플리케이션을 더욱 발전시키는 고급 기능을 제공합니다. fe-pilot는 일반적으로 상당한 코딩 노력이 필요한 고급 기능을 쉽게 통합하는 프로세스를 간소화합니다.\n\n# 유용한 링크:\n\n8. 공유: https://medium.com/@opensrc0/8-share-in-the-web-using-js-advanced-feature-uribaba-4bd0c7a1b210\n\n9. 현재 당신은 Whatsapp 공유 기능을 읽고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n10. 곧 출시합니다.","ogImage":{"url":"/assets/img/2024-06-19-9WhatsappShareintheWebUsingJSAdvancedFeatureUriBaba_0.png"},"coverImage":"/assets/img/2024-06-19-9WhatsappShareintheWebUsingJSAdvancedFeatureUriBaba_0.png","tag":["Tech"],"readingTime":2},{"title":"시니어 프론트엔드 개발자 인터뷰를 위한 나쁜 질문","description":"","date":"2024-06-19 00:36","slug":"2024-06-19-BadquestionsforSeniorFrontendDevInterview","content":"\n\n\n![image](https://miro.medium.com/v2/resize:fit:1000/1*lvenLl3-ZZJ06pgkJkhnNg.gif)\n\n# 아래에 설명된 모든 것은 내 주관적인 의견입니다\n\n본 이야기는 후보자들을 위한 직접적인 안내서가 아니며 현재 기술 면접에 대한 반성으로 기능합니다. 이 정보를 활용하는 방법은 여러분이 결정해야 합니다.\n\n일반적으로 검색 결과에서 자유롭게 찾을 수 있는 유명한 면접 질문들이 어떤 실용적인 적용도가 없다는 점을 말하고, 나에게는 회사가 후보자를 선발함에 있어 태만한 조직의 조짐이 있다고 생각합니다. 이렇게 함으로써 어떤 팀이든 관련된 질문을 하지 않아 모든 시니어 개발자를 상실할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n대규모 기업에서 기술 면접관이 대상 팀이나 프로젝트의 일원이 아닐 수도 있고 기술 면접이 큰 선정 프로세스 중 하나일 수 있어서 면접이 추상적일 수 있다는 것을 이해합니다.\n\n이러한 질문들은 소규모부터 중간 규모의 기업의 채용 프로세스에 더 적합합니다\n\n- 인사 면접 (0.5–1시간) — 기술 면접 (1.5–2시간) — 매니저 면접 (선택사항) — 제안\n\n나는 제시한 질문들이 항상 나만 해당되었거나 내가 면접에 참여하기에 고르지 못한 기업을 선택했다는 것은 배제하지 않습니다. 나는 질문들 중 일부만을 언급하고 있지만 면접 자체나 접근 방식에 대해서는 언급하지 않았습니다. 또한 특정 주제에 대한 대안적인 질문들을 제안합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 이벤트 루프는 어떻게 동작할까요?\n\n어떤 수준의 구직 면접에서든 가장 성가신 질문 중 하나입니다. 하지만 매번 이 질문에 대답하는 것에 지치지 않았나요?\n\n물론, 성경의 구절처럼 답을 외워 곧은 미소로 대답할 수 있습니다. \"어떤 이벤트가 발생하면, 이를 콜 스택에 넣고, 그 다음에는 콜백 큐로 이동하며, 이러이러한 절차를 거칩니다.\"\n\n이벤트 루프에 대해 성공적으로 설명하고 소중한 체크 표시를 받았습니다 ✅. 다음 질문 또는 이지금.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## JS가 이 메커니즘을 필요로 하는 이유를 이해하고 계신가요?\n\n이벤트 루프에 대한 기본적인 이해는 \"JS에서 비동기성이 어떻게 제공되는가?\"라는 질문에 답하는 것이 아니라 \"JS에서 왜 이벤트 루프를 통해 비동기성이 제공되는가?\"에 대한 것입니다.\n\n이 두 가지는 근본적으로 다른 질문들입니다. 차이를 느끼시나요? 두 번째 질문은 당신의 경험, 인식, 그리고 개발에 대한 전망에 기초하며, 당신의 답변에서 핵심이 될 키워드는 \"싱글 스레드\"일 것입니다.\n\n인터넷의 기본 인터뷰 가이드와 프론트엔드 개발의 보급화로 인해 원하는 지식을 실제 지식으로 속이려는 주요한 포인트가 포멀하게 제시되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-BadquestionsforSeniorFrontendDevInterview_0.png\" /\u003e\n\n\"자바스크립트의 '싱글 스레드성' 제한을 우회하고 별도의 스레드에서 계산을 수행하는 방법은 무엇일까요?\"라고 물어보는 것을 시도해보세요.\n\n\"콜 스택(Call Stack)\"이나 \"콜백 큐(Callback Queue)\"를 알고 있는 것이 도움이 되나요? - 아니요. 아마 고려할 만한 사항이라고 생각해요.\n\n# 마이크로태스크와 매크로태스크 실행 큐\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 Markdown 형식으로 변경하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 작업의 답변은 브라우저에서의 렌더링에 미치는 영향을 이해하는 데도 책임이 있습니다.\n\nconsole.log에서 실행 우선 순위의 지식으로 이 질문에 답할 수 있을까요?:\n\n- 여러 동시 이벤트가 발생해도 인터페이스가 빠르고 부드럽게 유지되도록 하는 방법은 무엇인가요?\n- requestAnimationFrame을 사용하는 것의 목적은 무엇인가요?\n- 클릭 시 전체 인터페이스와 상호작용을 차단하고, 이를 피하는 방법은 무엇인가요?\n\n# 화살표 함수 대 일반 함수\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 질문에는 아무런 문제가 없지만, 누가 묻는지에 따라 다를 수 있어요. 만약 \"이 맥락의 외부 접근성과 함수 실행 가능성에 대해\"라는 답을 하면 괜찮아요. (네, 매개변수 사용에 대해 언급해도 괜찮아요)\n\n하지만 이 질문은 단순한 면접관이 아니라, 당신의 답에 충분히 얻어 말이 안되는 \"학교 교사 꼬꼬댁\"가 하는 질문입니다. 당신은 어색한 침묵 속에서 앉아 있고, 그는 함수 선언의 두 가지 방법 사이의 차이를 기다리고 있으며, \"시니어 개발자는 모든 것을 알아야 한다!\"라고 생각하기 때문에 힌트조차 주지 않아요.\n\n그가 무엇을 기다리고 있는 걸까요? — 그가 일반 함수에서 생성자 사용에 대해 이야기하길 기다리고 있어요. 네, 맞아요, 2024년이라고 해도 ES5 구문에 대해 이야기해야 할 때가 왔어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 구성을 얼마나 자주 사용하시나요?\n\n```js\nfunction RegularFuncBird(name, color) {\n  this.name = name\n  this.species = color\n  console.log(this)\n}\n\nnew RegularFuncBird(\"앵무새\", \"파란색\")\n```\n\n클래스? — 이게 뭐에요?! — 함수들이 필요해요.\n\n네, 당신은 \"JS의 클래스들은 '구문적 설탕'이라고 할 수 있고 이는 옛날을 기리는 방법이라고 말할 수 있어요\".\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 솔직히 말하자면, 이 지식은 오늘날 더 이상 관련이 없어요. 지원자가 실용적인 방법과 사용법의 차이를 말했다면, 그건 일하기에 충분하다고 봐야 해요.\n\n서로 다를 필요가 없어요. 당신의 역사 지식은 오직 당신을 위한 것뿐이에요. 진보는 멈추지 않고 새로운 지식으로 대체돼요.\n\n# Var vs const \u0026 let\n\nES5 구문에 관해 이야기를 시작했으니 계속해보겠어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n인기 있는 면접 질문 중 하나예요. 여러분께 물어보면서 대화가 시작되죠. 어떤 `var`가 나쁜 것인지부터 논의하게 되고, 스스로 생각하고 있는 것, 그리고 `const`와 `let`이 좋은 것이라고 합니다.\n\n![이미지](/assets/img/2024-06-19-BadquestionsforSeniorFrontendDevInterview_3.png)\n\n이 질문의 실용적 가치는 미미합니다.\n\n회사가 `var`를 사용하는 프로젝트를 진행하고 있을까요? — 네\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 var이 얼마나 나쁜지에 대해 오랜 시간 논의할 수 있지만, 정말 변수에 대한 이 질문을 신경쓴다면:\n\n- 객체와 배열과 함께 동작하는 const에 대해\n- 지원자가 \"const 먼저\" 원칙을 어떻게 이해하는지에 대해 물어보는 것이 나을 겁니다.\n\n내 의견으로는, 지원자의 답변은 많은 사용 사례를 다룰 것이며, 이 문법이 어떻게 작동하는지에 대한 지원자의 이해를 명확하게 보여줄 것입니다.\n\n# 메모리 누수 감지\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저의 한 직무 면접 중에 흥미로운 질문을 받았어요 — \"프로젝트에 참여하게 되면 즉시 애플리케이션에서 메모리 누수를 찾으려고 하는 상황에서 주어진 업무는 아닌데 QA가 그 작업을 할 것입니다. 이때 어떻게 메모리 누수를 찾는 프로세스를 그에게 설명하겠습니까?\"\n\n어쨌든, 상황을 추상화하여 질문을 이해해보면, 이는 결과에 대한 해결책과 탐색을 묘사하지만 원인의 방지에 대해서는 이야기하지 않는 것 같아요.\n\n![이미지](/assets/img/2024-06-19-BadquestionsforSeniorFrontendDevInterview_4.png)\n\n네, 시간이 지남에 따라 증가하는 메모리 단편을 발견했고, 누출된 코드 영역을 찾아냈지만, 이후에 무엇을 해야 할지 모르겠죠. 단지 프로파일러를 실행하는 방법만 알 뿐이에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n내 의견으로는 더 나은 질문은 \"메모리 누수를 발생시키지 않는 안전한 코드를 어떻게 작성하나요?\"입니다.\n\n다루어져야 할 주요 포인트들:\n\n- addEventListener(`이벤트`, 핸들러) -` removeEventListener(`이벤트`, 핸들러)\n- const interval_Id = setInterval() -` cleanInterval(interval_Id)\n- \"가비지 콜렉터\"와 장기 레퍼런스의 이해\n\n문제의 원인을 찾고 고치는 방법은 모르더라도, 문제를 발생시키지 않는 방법을 안다면 꼭 알 필요가 없어요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 자바스크립트의 타입\n\n쓸모 없는 질문들에 대한 내가 가장 좋아하는 섹션입니다:\n\n- JS의 주요 타입은 무엇인가요?\n- 왜 null이 객체인가요?\n- Symbol은 무엇이며 어떻게 사용하나요?\n- 프로토타입이란 무엇인가요?\n- Number(num)과 new Number(num)의 차이는 무엇인가요?\n- 소수를 더할 때 나머지에 유물이 있는 이유는 무엇인가요?\n- a == 1 \u0026\u0026 a == 2 \u0026\u0026 a == 3를 어떻게 만들 수 있을까요?\n\n당신은 시니어 프론트엔드 개발자로서 이런 면접에 앉아 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-BadquestionsforSeniorFrontendDevInterview_5.png\" /\u003e\n\n이 목록은 계속해서 나열될 수 있지만, 이러한 질문에 대한 답변은 신뢰할 수 있고 기능적인 프론트엔드 애플리케이션을 개발하는 데 필수적이지 않습니다.\n\n만약 후보자가 \"타입(types)\"과 관련된 이해력을 확인하고 싶다면, 이와 비슷한 질문들을 하면 좋을 것입니다:\n\n- 어떻게 값이 배열인지 확인하나요?\n- 값을 boolean 타입으로 캐스팅하는 몇 가지 방법은 무엇인가요?\n- toString() 및 toJSON() 메서드는 어디에서 오는가요?\n- obj.key 대신 obj.hasOwnProperty(key)를 사용하는 것이 더 나은 이유는 무엇인가요?\n- 소수점 숫자와 결과 표시와 관련된 특이사항은 무엇인가요?\n- 왜 NaN.isNaN()를 사용해야 하나요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# CORS\n\n어떤 서비스와 통합된 애플리케이션을 개발한 적이 있는 사람이라면 이 오류를 받았을 것입니다. CORS 메커니즘에 대해 꼭 알아야 할 것은 브라우저가 서비스를 호출하는 허용된 도메인과 현재 도메인 간의 일치 여부를 확인한다는 점입니다.\n\n이곳에서 CORS 메커니즘의 역사적 부분과 출현 이유를 찾을 수 있습니다.\n\n## 여기서 무엇이 잘못될 수 있을까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 텍스트를 친절한 톤으로 한국어로 번역해 드리겠습니다:\n\nHTTP OPTIONS 요청이 사용되는 이유는 무엇인가요?\n\nHTTP OPTIONS를 호출하는 것은 서비스로부터 해당 서비스에 대한 요청을 허용하는 HTTP 메서드를 브라우저 논리적으로 가져오는 것입니다. 이를 사용자의 최종 빌드에서 직접 제어할 수 없으며, 직접 구성할 수 없는 방법입니다.\n\n## CORS에 관한 올바른 질문\n\n개발 중에 브라우저에서 CORS 정책을 우회하는 방법은 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 질문은 당신이 이 오류에 익숙하다는 것을 보여주고 동료들에게 해결책을 제안할 수 있다는 것을 보여 줄 수 있습니다. 아래와 같은 해결책을 제안할 수 있습니다:\n\n- 프록시 구성\n- 특수 브라우저 확장 프로그램\n- 브라우저 정책 비활성화\n\nHTTP OPTIONS 요청이 사용되는 이유를 알면 프런트 엔드 앱을 통합할 때 발생할 수 있는 블로킹 문제를 제거할 수는 없습니다. 이는 백엔드 부분을 개발하지 않기 때문입니다.\n\n# 마무리\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기술 면접은 서로에게 어떤 미래 작업 및 경험을 어떻게 최대한 상호간의 이점으로 활용할 수 있는지 이해하기 위한 양방향 프로세스입니다. 현실에서 떨어져 있는 이론 시험을 2시간 동안 보는 대신, 서로의 경험을 바탕으로 최고의 이점을 얻을 수 있습니다.\n\n주니어 및 중간 개발자 선발에 필요한 기본 사항을 확인하는 것은 시니어 개발자에게는 적용되지 않습니다. 시니어 개발자는 주로 실수를 통해 경험을 쌓는 것입니다.\n\n제가 제안하는 질문을 기반으로 자신에게 물어보세요 — \"어떤 유형의 지원자를 원하십니까? 이론에 대답하는 사람인가요 아니면 이를 적용하는 사람인가요?\" 이 결정은 모든 이해관계자들에게 이점을 줄 것입니다. 프로젝트에는 단순히 \"지식 집합\"이 아닌 경험을 갖춘 사람들이 진정으로 참여하게 될 것입니다.\n\n하지만 제 제안은 주요 문제를 해결하지 못할 것입니다 — 시니어 프론트엔드 개발자 역할을 위한 기술 면접이 단 한 번만 진행됩니다. 2시간 동안의 면접에서 후보자의 시스템 설계 기술을 배울 수 없을뿐더러 \"실시간 코딩\"에 많은 시간을 할애하거나 이론에 시간을 쏟을 수 없을 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 부가 정보\n\n이 글이 마음에 들 경우 CSS 질문에 관한 두 번째 부분도 작성할 예정이에요","ogImage":{"url":"/assets/img/2024-06-19-BadquestionsforSeniorFrontendDevInterview_0.png"},"coverImage":"/assets/img/2024-06-19-BadquestionsforSeniorFrontendDevInterview_0.png","tag":["Tech"],"readingTime":7}],"page":"18","totalPageCount":20,"totalPageGroupCount":1,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"18"},"buildId":"fyfGyRz00q80ZdkogiVCt","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>