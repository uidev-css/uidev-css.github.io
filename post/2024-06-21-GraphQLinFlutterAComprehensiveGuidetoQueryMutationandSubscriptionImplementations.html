<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>2024년 Flutter에서 GraphQL 사용법 쿼리, 뮤테이션, 서브스크립션 구현 완벽 가이드 | uidev-css</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://uidev-css.github.io///post/2024-06-21-GraphQLinFlutterAComprehensiveGuidetoQueryMutationandSubscriptionImplementations" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="2024년 Flutter에서 GraphQL 사용법 쿼리, 뮤테이션, 서브스크립션 구현 완벽 가이드 | uidev-css" data-gatsby-head="true"/><meta property="og:title" content="2024년 Flutter에서 GraphQL 사용법 쿼리, 뮤테이션, 서브스크립션 구현 완벽 가이드 | uidev-css" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-21-GraphQLinFlutterAComprehensiveGuidetoQueryMutationandSubscriptionImplementations_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://uidev-css.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://uidev-css.github.io///post/2024-06-21-GraphQLinFlutterAComprehensiveGuidetoQueryMutationandSubscriptionImplementations" data-gatsby-head="true"/><meta name="twitter:title" content="2024년 Flutter에서 GraphQL 사용법 쿼리, 뮤테이션, 서브스크립션 구현 완벽 가이드 | uidev-css" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-21-GraphQLinFlutterAComprehensiveGuidetoQueryMutationandSubscriptionImplementations_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | uidev-css" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-21 22:20" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b75a4bf98ee956a8.js" defer=""></script><script src="/_next/static/4HDhroK4kHnB5DAbbbGv3/_buildManifest.js" defer=""></script><script src="/_next/static/4HDhroK4kHnB5DAbbbGv3/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UIDEV CSS</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">2024년 Flutter에서 GraphQL 사용법 쿼리, 뮤테이션, 서브스크립션 구현 완벽 가이드</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="2024년 Flutter에서 GraphQL 사용법 쿼리, 뮤테이션, 서브스크립션 구현 완벽 가이드" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UIDEV CSS</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 21, 2024</span><span class="posts_reading_time__f7YPP">9<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-21-GraphQLinFlutterAComprehensiveGuidetoQueryMutationandSubscriptionImplementations&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-06-21-GraphQLinFlutterAComprehensiveGuidetoQueryMutationandSubscriptionImplementations_0.png" alt="이미지"></p>
<p>이 기사는 플러터(Flutter)에서 GraphQL을 마스터하는 데 필수적인 가이드입니다! 기본 개념 이해부터 쿼리(query), 뮤테이션(mutation), 구독(subscription)의 핵심 개념까지 모두 다룹니다. 뿐만 아니라 Flutter 앱에 GraphQL을 원활하게 통합하는 방법을 단계별 지침과 코드 샘플을 제공하면서 안내해드립니다.</p>
<h1>GraphQL이란?</h1>
<p>GraphQL을 주문하듯이 생각해보세요. 일반 레스토랑(전통적인 API와 같은)에서는 특정 토핑이 올라간 고정된 피자를 주문합니다. 원하는 거랑 다르면 완전히 새로운 피자를 주문해야 합니다.</p>
<p>지금은 GraphQL을 사용하면 피자에 원하는 대로 말하는 것과 같아요 — 크러스트, 소스, 토핑 종류를 정확하게 말하는 것과 같아요. 당신을 위해 특별히 만들어진 피자를 받게 되는거죠. 딱 필요한 만큼만요. 데이터에 대한 맞춤 주문처럼 생각해보세요 — 필요한 것을 요청하면 정확히 그것을 받게 되어 매우 효율적이고 요구 사항에 맞게 제작됩니다.</p>
<p>그 외에도, GraphQL은 데이터와 상호 작용하는 방법을 간소화하여 세 가지 주요 작업을 제공합니다: 쿼리, 뮤테이션, 그리고 구독.</p>
<ul>
<li>쿼리: GraphQL에서 쿼리는 특정 데이터를 요청하는 것입니다. 서버에서 정보를 요청하는 것과 같이 특정 데이터와 그 구조를 명시합니다. 당신이 원하는 토핑과 크러스트 유형을 주문하는 것과 같은 거죠.</li>
<li>뮤테이션: GraphQL에서 뮤테이션은 데이터 수정을 다루는 작업들입니다. 새 데이터 추가, 기존 레코드 업데이트, 혹은 정보 삭제와 같은 작업을 할 수 있습니다. 피자 비유에서는 셰프에게 선호에 따라 토핑을 추가하거나 제거하도록 지시하는 것과 같아요.</li>
<li>구독: 구독은 GraphQL에서 실시간 업데이트를 가능하도록 합니다. 클라이언트(당신)와 서버(셰프) 사이에 지속적인 연결을 설정하여 서버가 가능한 즉시 새 정보를 클라이언트에게 푸시할 수 있게 합니다. 피자 준비 과정을 알려주는 셰프와 같이 데이터 변경 사항에 대한 실시간 알림을 받는 것과 같아요.</li>
</ul>
<p>그래서, GraphQL은 주문을 맞춤 제작하는 것 이상이에요; 당신이 요구하는 대로 데이터를 조회, 수정하고 최신 상태를 유지할 수 있도록 효율적이고 요구 사항에 정확히 맞게 제작된 방법을 제공하는겁니다.</p>
<h1>플러터에서 GraphQL 구현하기</h1>
<p>먼저, 다음 패키지를 pubspec.yaml 파일에 추가하고 flutter pub get을 실행하세요:</p>
<pre><code class="hljs language-js">  <span class="hljs-attr">graphql_flutter</span>: latest
  <span class="hljs-attr">graphql</span>: latest
</code></pre>
<p>이제 다음과 같이 GraphQL 클라이언트를 생성하세요:</p>
<pre><code class="hljs language-js">  final <span class="hljs-title class_">HttpLink</span> _httpLink = <span class="hljs-title class_">HttpLink</span>(
    <span class="hljs-string">"&#x3C;YOUR-BASE-URL>"</span>,
    <span class="hljs-attr">defaultHeaders</span>: {
      <span class="hljs-string">'Authorization'</span>: <span class="hljs-string">'Bearer &#x3C;YOUR_PERSONAL_ACCESS_TOKEN>'</span>,
      <span class="hljs-string">'AuthorizationSource'</span>: <span class="hljs-string">'API'</span>,
    },
  );


  final <span class="hljs-title class_">ValueNotifier</span>&#x3C;<span class="hljs-title class_">GraphQLClient</span>> client = <span class="hljs-title class_">ValueNotifier</span>(<span class="hljs-title class_">GraphQLClient</span>(
    <span class="hljs-attr">link</span>: _httpLink,
    <span class="hljs-attr">cache</span>: <span class="hljs-title class_">GraphQLCache</span>(),
  ));
</code></pre>
<p>앱을 GraphQL 위젯을 사용하기위한 GraphQLProvider 상속 위젯으로 감싸세요:</p>
<pre><code class="hljs language-js">  <span class="hljs-title class_">Widget</span> <span class="hljs-title function_">build</span>(<span class="hljs-params">BuildContext context</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">GraphQLProvider</span>(
      <span class="hljs-attr">client</span>: client,
      <span class="hljs-attr">child</span>: <span class="hljs-title class_">MaterialApp</span>(
        <span class="hljs-attr">title</span>: <span class="hljs-string">'App'</span>,
        <span class="hljs-attr">home</span>: <span class="hljs-title class_">HomeScreen</span>(),
      ),
    );
  }
</code></pre>
<p>그럼 GraphQL API를 소비해봅시다.</p>
<h1>쿼리</h1>
<p>먼저 쿼리 문서를 정의해보겠습니다.</p>
<pre><code class="hljs language-js">final getUserQuery = <span class="hljs-title function_">gql</span>(r<span class="hljs-string">''</span><span class="hljs-string">'
    query getUser($id: ID) {
      user(id: $id) {
        id
        first_name
        last_name
      }
    }
'</span><span class="hljs-string">''</span>);
</code></pre>
<p>쿼리 정의:</p>
<ul>
<li>query getUser($id: ID): 이 줄은 getUser라는 GraphQL 쿼리의 정의를 시작합니다. $id는 쿼리에 전달할 수 있는 ID 유형의 변수입니다.</li>
</ul>
<p>쿼리 본문:</p>
<ul>
<li>' user(id: $id) ' ... ' ': 쿼리의 본문은 우리가 원하는 데이터를 지정합니다. 이 경우 주어진 id를 가진 사용자에 대한 정보를 요청하고 있습니다. 요청된 세 가지 필드는 id, first_name 및 last_name입니다.</li>
</ul>
<p>변수 사용:</p>
<ul>
<li>쿼리 내에서 $id 변수는 요청을 매개변수화하는 데 사용됩니다. 이는 쿼리가 실행될 때 특정 ID로 동적으로 채워지는 자리 표시자입니다.</li>
</ul>
<h2>쿼리 위젯</h2>
<p>이제 이 문서를 사용하여 GraphQL API에 요청을 보냅니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Query</span>(
  <span class="hljs-attr">options</span>: <span class="hljs-title class_">QueryOptions</span>(
    <span class="hljs-attr">document</span>: getUserQuery,
    <span class="hljs-attr">variables</span>: <span class="hljs-keyword">const</span> {
      <span class="hljs-string">"id"</span>: <span class="hljs-string">"1"</span>,
    },
  ),
  <span class="hljs-attr">builder</span>: (
    <span class="hljs-title class_">QueryResult</span> result, {
    <span class="hljs-title class_">Future</span>&#x3C;<span class="hljs-title class_">QueryResult</span>> <span class="hljs-title class_">Function</span>(<span class="hljs-title class_">FetchMoreOptions</span>)? fetchMore,
    <span class="hljs-title class_">Future</span>&#x3C;<span class="hljs-title class_">QueryResult</span>?> <span class="hljs-title class_">Function</span>()? refetch,
  }) {
    <span class="hljs-keyword">if</span> (result.<span class="hljs-property">hasException</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Text</span>(<span class="hljs-string">"에러"</span>);
    }
    <span class="hljs-keyword">if</span> (result.<span class="hljs-property">isLoading</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">CircularProgressIndicator</span>();
    }
    final user = result.<span class="hljs-property">data</span>?[<span class="hljs-string">"user"</span>];
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">ListTile</span>(
      <span class="hljs-attr">title</span>: <span class="hljs-title class_">Text</span>(user[<span class="hljs-string">"first_name"</span>]),
      <span class="hljs-attr">subtitle</span>: <span class="hljs-title class_">Text</span>(user[<span class="hljs-string">"last_name"</span>]),
    );
  },
)
</code></pre>
<p>쿼리 위젯:</p>
<ul>
<li>이 문구는 graphql_flutter 패키지에서 제공하는 Query 위젯의 일부분입니다. Query 위젯은 GraphQL 쿼리를 실행하는 데 사용됩니다.</li>
</ul>
<p>쿼리의 옵션:</p>
<ul>
<li>옵션 매개변수는 GraphQL 쿼리 실행에 필요한 세부 정보를 제공하는 데 사용됩니다.</li>
<li>문서: getUserQuery: 실행할 GraphQL 쿼리는 getUserQuery 변수를 사용하여 지정됩니다. 이 변수는 코드의 이전 부분에서 정의된 쿼리입니다.</li>
<li>변수: const '"id": "1"': 이는 쿼리에 필요한 변수를 제공합니다. 이 경우 "id" 변수를 "1"로 설정하고 있습니다.</li>
</ul>
<p>Builder 함수:</p>
<ul>
<li>builder는 GraphQL 쿼리의 결과로 호출되는 콜백 함수입니다.</li>
<li>QueryResult result: GraphQL 쿼리 실행의 결과를 보유합니다.</li>
<li>빌더 안에서:</li>
<li>result.hasException을 사용하여 예외를 확인합니다. 예외가 발생하면 "Error"를 표시하는 Text 위젯을 반환합니다.</li>
<li>result.isLoading을 사용하여 쿼리가 여전히 로딩 중인지 확인합니다. true인 경우 CircularProgressIndicator를 반환합니다.</li>
<li>쿼리가 성공하고 로딩 중이 아닌 경우, 결과에서 사용자 데이터를 추출하고 ListTile에 표시합니다. ListTile에는 사용자의 성과 이름이 각각 제목과 부제목으로 나타납니다.</li>
</ul>
<h2>쿼리 메소드</h2>
<p>응답을 그릴 때 더 많은 제어를 위해 GraphQL 클라이언트의 query 메소드를 사용하여 GraphQL API를 소비하는 다른 방법이 있습니다.</p>
<h1>Mutation</h1>
<p>이제 먼저 변이 문서를 정의해 봅시다.</p>
<pre><code class="hljs language-js"> final updateUserMutation = <span class="hljs-title function_">gql</span>(r<span class="hljs-string">''</span><span class="hljs-string">'
    mutation updateUser($id: ID, $first_name: String, $last_name: String) {
    updateUser(
    input: {id: $id, first_name: $first_name, last_name: $last_name,}
      ) {
    user {
      id
      first_name
      last_name
    }
    messages {
      field
      message
    }
  }
}
'</span><span class="hljs-string">''</span>);
</code></pre>
<p>이제 문서를 사용하여 GraphQL 클라이언트 객체를 사용하여 사용자 데이터를 업데이트해 봅시다.</p>
<pre><code class="hljs language-js">final result = <span class="hljs-keyword">await</span> client.<span class="hljs-title function_">mutate</span>(
        <span class="hljs-title class_">MutationOptions</span>(
          <span class="hljs-attr">document</span>: updateUserMutation,
          <span class="hljs-attr">variables</span>: {
            <span class="hljs-string">"id"</span>: <span class="hljs-string">"1"</span>,
            <span class="hljs-string">"first_name"</span>: <span class="hljs-string">"John"</span>,
            <span class="hljs-string">"last_name"</span>: <span class="hljs-string">"Doe"</span>
          },
        ),
</code></pre>
<p>GraphQL Mutation 실행:</p>
<ul>
<li>client.mutate: 이것은 GraphQL 클라이언트에서 mutate 메소드를 호출하는 것입니다. 클라이언트 객체는 GraphQL 클라이언트의 인스턴스입니다.</li>
</ul>
<p>돌변에 대한 옵션:</p>
<ul>
<li>돌변 옵션은 GraphQL 돌변 실행에 대한 세부 정보를 제공하는 데 사용됩니다.</li>
<li>변수: '"id": "1", "first_name": "John", "last_name": "Doe"': 이는 돌변에 필요한 변수를 제공합니다. 사용자의 id와 함께 업데이트할 새로운 이름 및 성 값을 포함합니다.</li>
</ul>
<p>결과 처리:</p>
<ul>
<li>돌변 작업의 결과는 결과 변수에 저장됩니다.</li>
<li>결과의 실제 구조는 사용되는 GraphQL 클라이언트에 따라 다르지만 일반적으로 돌변에 의해 반환된 데이터, 오류 및 추가 메타데이터와 같은 정보를 포함합니다.</li>
</ul>
<h1>구독</h1>
<p>먼저 웹소켓을 위한 graphQL 클라이언트를 만들겠습니다.</p>
<pre><code class="hljs language-js">final <span class="hljs-title class_">WebSocketLink</span> websocketLink = <span class="hljs-title class_">WebSocketLink</span>(
    <span class="hljs-attr">url</span>: <span class="hljs-string">'&#x3C;YOUR-GRAPHQL-SUBSCRIPTION-ENDPOINT>'</span>,
    <span class="hljs-attr">config</span>: <span class="hljs-title class_">SocketClientConfig</span>(
    <span class="hljs-attr">autoReconnect</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">inactivityTimeout</span>: <span class="hljs-title class_">Duration</span>(<span class="hljs-attr">seconds</span>: <span class="hljs-number">30</span>),
  ),
);

websocketClient = <span class="hljs-title class_">GraphQLClient</span>(
  <span class="hljs-attr">link</span>: websocketLink,
  <span class="hljs-attr">cache</span>: <span class="hljs-title class_">GraphQLCache</span>(),
);
</code></pre>
<p>웹소켓 링크 설정:</p>
<ul>
<li>WebSocketLink은 GraphQL 구독용 WebSocket 전송의 구현체입니다. 지정된 GraphQL 서버 엔드포인트로 WebSocket 연결을 설정합니다.</li>
<li>URL: <code>YOUR-GRAPHQL-SUBSCRIPTION-ENDPOINT</code>: 실제 웹소켓 엔드포인트로 대체합니다. 이는 GraphQL 서버에서 제공하는 실제 웹소켓 엔드포인트로 구독을 처리합니다. 이 URL은 일반적으로 ws:// 또는 wss://로 시작합니다.</li>
<li>config: SocketClientConfig(...): WebSocket 연결에 대한 구성 옵션을 제공합니다.</li>
<li>autoReconnect: true: 연결이 끊긴 경우 자동 재연결을 활성화합니다.</li>
<li>inactivityTimeout: Duration(seconds: 30): 활동이 없거나 해당 시간 내에 통신이 발생하지 않을 경우 웹소켓 연결을 닫기 위한 타임아웃 기간을 설정합니다.</li>
</ul>
<p>GraphQLClient 설정:</p>
<ul>
<li>GraphQLClient는 구독을 위한 통신 링크로 WebSocketLink를 사용하여 인스턴스화됩니다. 또한 캐싱을 위해 GraphQLCache를 사용합니다.</li>
<li>link: websocketLink: GraphQL 클라이언트의 통신 링크로 WebSocketLink를 지정합니다. 이는 구독이 WebSocket 연결을 통해 처리되도록 합니다.</li>
<li>cache: GraphQLCache(): GraphQL 클라이언트의 로컬 상태 및 쿼리 결과를 저장하고 관리하기 위한 캐시를 초기화합니다.</li>
</ul>
<p>이제 GraphQL 구독 문서를 작성해 봅시다.</p>
<pre><code class="hljs language-javascript">  <span class="hljs-keyword">static</span> final userUpdatedMutation = <span class="hljs-title function_">gql</span>(r<span class="hljs-string">''</span><span class="hljs-string">'
subscription userUpdatedSubscription($id: String) {
        userUpdatedSubscription(id: $id) {
            ...UserFragment
        }
    }
    fragment UserFragment on User {
        id
        first_name
        last_name
    }
    '</span><span class="hljs-string">''</span>);
</code></pre>
<p>GraphQL Subscription:</p>
<ul>
<li>userUpdatedMutation은 사용자가 업데이트될 때 업데이트를 청취하는 GraphQL 구독(subscription)입니다. 사용자관련 정보를 관심 있는 사용자로 지정하기 위해 String 타입의 $id 매개변수를 가져옵니다.</li>
<li>subscription userUpdatedSubscription($id: String): id 변수를 허용하는 userUpdatedSubscription이라는 이름의 구독을 선언합니다.</li>
<li>userUpdatedSubscription(id: $id): 이 구독은 지정된 id를 가진 사용자에 대한 업데이트에 관심이 있다는 것을 나타냅니다.</li>
<li>' ...UserFragment ': 이 구독에는 fragment spread, ...UserFragment가 포함되어 있어서 UserFragment에서 지정된 필드를 수신하려는 것을 나타냅니다.</li>
</ul>
<p>GraphQL Fragment:</p>
<ul>
<li>GraphQL 프래그먼트 (UserFragment)는 여러 쿼리, 뮤테이션 또는 구독에서 사용할 수 있는 재사용 가능한 필드 세트를 정의합니다.</li>
<li>UserFragment on User ' ... '의 프래그먼트는 User 유형에서 UserFragment라는 이름의 프래그먼트를 선언합니다.</li>
<li>이 프래그먼트에는 id, first_name, last_name과 같은 필드가 포함되어 있습니다. ...UserFragment 스프레드를 포함하는 모든 작업은 이러한 필드를 자동으로 포함합니다.</li>
<li>프래그먼트는 필드 정의의 중복을 피하고 코드 재사용성을 촉진하는 데 도움이 됩니다. 여러 작업이 공통 필드를 공유할 때 특히 유용합니다.</li>
</ul>
<p>이제 이 구독을 들어보겠습니다</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">void</span> <span class="hljs-title function_">_subscribe</span>() <span class="hljs-keyword">async</span> {
  final subscription = <span class="hljs-keyword">await</span> websocketClient.<span class="hljs-title function_">subscribe</span>(
    <span class="hljs-title class_">SubscriptionOptions</span>(
      <span class="hljs-attr">document</span>: userUpdatedMutation,
    ),
  );

  subscription.<span class="hljs-title function_">listen</span>((result) {
    final userData = result.<span class="hljs-property">data</span>?[<span class="hljs-string">'user'</span>];
    <span class="hljs-title function_">print</span>(<span class="hljs-string">'이름: ${userData["first_name"]}'</span>);
    <span class="hljs-title function_">print</span>(<span class="hljs-string">'성: ${userData["last_name"]}'</span>);
    <span class="hljs-comment">// 실시간 업데이트 처리, 예를 들어 UI 업데이트</span>
  });
}
</code></pre>
<p>Subscription Widget도 사용할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-attr">body</span>: <span class="hljs-title class_">Subscription</span>(
        <span class="hljs-attr">options</span>: <span class="hljs-title class_">SubscriptionOptions</span>(
        <span class="hljs-attr">document</span>: userUpdatedMutation,
        ),
        <span class="hljs-attr">builder</span>: (result) {
          final user = result.<span class="hljs-property">data</span>?[<span class="hljs-string">"user"</span>];
          <span class="hljs-keyword">return</span> <span class="hljs-title class_">ListTile</span>(
            <span class="hljs-attr">title</span>: <span class="hljs-title class_">Text</span>(user[<span class="hljs-string">"first_name"</span>]),
            <span class="hljs-attr">subtitle</span>: <span class="hljs-title class_">Text</span>(user[<span class="hljs-string">"last_name"</span>]),
          );
        },
      ),
</code></pre>
<h1>결론</h1>
<p>이 가이드를 통해 플러터에서 GraphQL 구현에 대한 포괄적인 이해를 제공했습니다. 쿼리, 뮤테이션 및 구독의 기본 사항부터 실제 통합 단계에 이르기까지의 내용이 담겨 있습니다. 실시간 업데이트를 통한 GraphQL 구독에 중점을 두고 뮤테이션 작업을 시연함으로써, 개발자들은 이제 플러터 프로젝트에 GraphQL을 원활하게 통합할 수 있습니다. 이 포괄적인 리소스는 모든 수준의 개발자가 데이터 검색을 최적화하고 앱의 효율성을 향상시키며, 플러터에서 GraphQL의 강력함을 통해 동적 사용자 경험을 제공할 수 있는 기술을 제공합니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"2024년 Flutter에서 GraphQL 사용법 쿼리, 뮤테이션, 서브스크립션 구현 완벽 가이드","description":"","date":"2024-06-21 22:20","slug":"2024-06-21-GraphQLinFlutterAComprehensiveGuidetoQueryMutationandSubscriptionImplementations","content":"\n\n![이미지](/assets/img/2024-06-21-GraphQLinFlutterAComprehensiveGuidetoQueryMutationandSubscriptionImplementations_0.png)\n\n이 기사는 플러터(Flutter)에서 GraphQL을 마스터하는 데 필수적인 가이드입니다! 기본 개념 이해부터 쿼리(query), 뮤테이션(mutation), 구독(subscription)의 핵심 개념까지 모두 다룹니다. 뿐만 아니라 Flutter 앱에 GraphQL을 원활하게 통합하는 방법을 단계별 지침과 코드 샘플을 제공하면서 안내해드립니다.\n\n# GraphQL이란?\n\nGraphQL을 주문하듯이 생각해보세요. 일반 레스토랑(전통적인 API와 같은)에서는 특정 토핑이 올라간 고정된 피자를 주문합니다. 원하는 거랑 다르면 완전히 새로운 피자를 주문해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금은 GraphQL을 사용하면 피자에 원하는 대로 말하는 것과 같아요 — 크러스트, 소스, 토핑 종류를 정확하게 말하는 것과 같아요. 당신을 위해 특별히 만들어진 피자를 받게 되는거죠. 딱 필요한 만큼만요. 데이터에 대한 맞춤 주문처럼 생각해보세요 — 필요한 것을 요청하면 정확히 그것을 받게 되어 매우 효율적이고 요구 사항에 맞게 제작됩니다.\n\n그 외에도, GraphQL은 데이터와 상호 작용하는 방법을 간소화하여 세 가지 주요 작업을 제공합니다: 쿼리, 뮤테이션, 그리고 구독.\n\n- 쿼리: GraphQL에서 쿼리는 특정 데이터를 요청하는 것입니다. 서버에서 정보를 요청하는 것과 같이 특정 데이터와 그 구조를 명시합니다. 당신이 원하는 토핑과 크러스트 유형을 주문하는 것과 같은 거죠.\n- 뮤테이션: GraphQL에서 뮤테이션은 데이터 수정을 다루는 작업들입니다. 새 데이터 추가, 기존 레코드 업데이트, 혹은 정보 삭제와 같은 작업을 할 수 있습니다. 피자 비유에서는 셰프에게 선호에 따라 토핑을 추가하거나 제거하도록 지시하는 것과 같아요.\n- 구독: 구독은 GraphQL에서 실시간 업데이트를 가능하도록 합니다. 클라이언트(당신)와 서버(셰프) 사이에 지속적인 연결을 설정하여 서버가 가능한 즉시 새 정보를 클라이언트에게 푸시할 수 있게 합니다. 피자 준비 과정을 알려주는 셰프와 같이 데이터 변경 사항에 대한 실시간 알림을 받는 것과 같아요.\n\n그래서, GraphQL은 주문을 맞춤 제작하는 것 이상이에요; 당신이 요구하는 대로 데이터를 조회, 수정하고 최신 상태를 유지할 수 있도록 효율적이고 요구 사항에 정확히 맞게 제작된 방법을 제공하는겁니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 플러터에서 GraphQL 구현하기\n\n먼저, 다음 패키지를 pubspec.yaml 파일에 추가하고 flutter pub get을 실행하세요:\n\n```js\n  graphql_flutter: latest\n  graphql: latest\n```\n\n이제 다음과 같이 GraphQL 클라이언트를 생성하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n  final HttpLink _httpLink = HttpLink(\n    \"\u003cYOUR-BASE-URL\u003e\",\n    defaultHeaders: {\n      'Authorization': 'Bearer \u003cYOUR_PERSONAL_ACCESS_TOKEN\u003e',\n      'AuthorizationSource': 'API',\n    },\n  );\n\n\n  final ValueNotifier\u003cGraphQLClient\u003e client = ValueNotifier(GraphQLClient(\n    link: _httpLink,\n    cache: GraphQLCache(),\n  ));\n```\n\n앱을 GraphQL 위젯을 사용하기위한 GraphQLProvider 상속 위젯으로 감싸세요:\n\n```js\n  Widget build(BuildContext context) {\n    return GraphQLProvider(\n      client: client,\n      child: MaterialApp(\n        title: 'App',\n        home: HomeScreen(),\n      ),\n    );\n  }\n```\n\n그럼 GraphQL API를 소비해봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 쿼리\n\n먼저 쿼리 문서를 정의해보겠습니다.\n\n```js\nfinal getUserQuery = gql(r'''\n    query getUser($id: ID) {\n      user(id: $id) {\n        id\n        first_name\n        last_name\n      }\n    }\n''');\n```\n\n쿼리 정의:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- query getUser($id: ID): 이 줄은 getUser라는 GraphQL 쿼리의 정의를 시작합니다. $id는 쿼리에 전달할 수 있는 ID 유형의 변수입니다.\n\n쿼리 본문:\n\n- ' user(id: $id) ' ... ' ': 쿼리의 본문은 우리가 원하는 데이터를 지정합니다. 이 경우 주어진 id를 가진 사용자에 대한 정보를 요청하고 있습니다. 요청된 세 가지 필드는 id, first_name 및 last_name입니다.\n\n변수 사용:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 쿼리 내에서 $id 변수는 요청을 매개변수화하는 데 사용됩니다. 이는 쿼리가 실행될 때 특정 ID로 동적으로 채워지는 자리 표시자입니다.\n\n## 쿼리 위젯\n\n이제 이 문서를 사용하여 GraphQL API에 요청을 보냅니다.\n\n```js\nQuery(\n  options: QueryOptions(\n    document: getUserQuery,\n    variables: const {\n      \"id\": \"1\",\n    },\n  ),\n  builder: (\n    QueryResult result, {\n    Future\u003cQueryResult\u003e Function(FetchMoreOptions)? fetchMore,\n    Future\u003cQueryResult?\u003e Function()? refetch,\n  }) {\n    if (result.hasException) {\n      return const Text(\"에러\");\n    }\n    if (result.isLoading) {\n      return const CircularProgressIndicator();\n    }\n    final user = result.data?[\"user\"];\n    return ListTile(\n      title: Text(user[\"first_name\"]),\n      subtitle: Text(user[\"last_name\"]),\n    );\n  },\n)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n쿼리 위젯:\n\n- 이 문구는 graphql_flutter 패키지에서 제공하는 Query 위젯의 일부분입니다. Query 위젯은 GraphQL 쿼리를 실행하는 데 사용됩니다.\n\n쿼리의 옵션:\n\n- 옵션 매개변수는 GraphQL 쿼리 실행에 필요한 세부 정보를 제공하는 데 사용됩니다.\n- 문서: getUserQuery: 실행할 GraphQL 쿼리는 getUserQuery 변수를 사용하여 지정됩니다. 이 변수는 코드의 이전 부분에서 정의된 쿼리입니다.\n- 변수: const '\"id\": \"1\"': 이는 쿼리에 필요한 변수를 제공합니다. 이 경우 \"id\" 변수를 \"1\"로 설정하고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nBuilder 함수:\n\n- builder는 GraphQL 쿼리의 결과로 호출되는 콜백 함수입니다.\n- QueryResult result: GraphQL 쿼리 실행의 결과를 보유합니다.\n- 빌더 안에서:\n- result.hasException을 사용하여 예외를 확인합니다. 예외가 발생하면 \"Error\"를 표시하는 Text 위젯을 반환합니다.\n- result.isLoading을 사용하여 쿼리가 여전히 로딩 중인지 확인합니다. true인 경우 CircularProgressIndicator를 반환합니다.\n- 쿼리가 성공하고 로딩 중이 아닌 경우, 결과에서 사용자 데이터를 추출하고 ListTile에 표시합니다. ListTile에는 사용자의 성과 이름이 각각 제목과 부제목으로 나타납니다.\n\n## 쿼리 메소드\n\n응답을 그릴 때 더 많은 제어를 위해 GraphQL 클라이언트의 query 메소드를 사용하여 GraphQL API를 소비하는 다른 방법이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n# Mutation\n\n이제 먼저 변이 문서를 정의해 봅시다.\n\n```js\n final updateUserMutation = gql(r'''\n    mutation updateUser($id: ID, $first_name: String, $last_name: String) {\n    updateUser(\n    input: {id: $id, first_name: $first_name, last_name: $last_name,}\n      ) {\n    user {\n      id\n      first_name\n      last_name\n    }\n    messages {\n      field\n      message\n    }\n  }\n}\n''');\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 문서를 사용하여 GraphQL 클라이언트 객체를 사용하여 사용자 데이터를 업데이트해 봅시다.\n\n```js\nfinal result = await client.mutate(\n        MutationOptions(\n          document: updateUserMutation,\n          variables: {\n            \"id\": \"1\",\n            \"first_name\": \"John\",\n            \"last_name\": \"Doe\"\n          },\n        ),\n```\n\nGraphQL Mutation 실행:\n\n- client.mutate: 이것은 GraphQL 클라이언트에서 mutate 메소드를 호출하는 것입니다. 클라이언트 객체는 GraphQL 클라이언트의 인스턴스입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n돌변에 대한 옵션:\n\n- 돌변 옵션은 GraphQL 돌변 실행에 대한 세부 정보를 제공하는 데 사용됩니다.\n- 변수: '\"id\": \"1\", \"first_name\": \"John\", \"last_name\": \"Doe\"': 이는 돌변에 필요한 변수를 제공합니다. 사용자의 id와 함께 업데이트할 새로운 이름 및 성 값을 포함합니다.\n\n결과 처리:\n\n- 돌변 작업의 결과는 결과 변수에 저장됩니다.\n- 결과의 실제 구조는 사용되는 GraphQL 클라이언트에 따라 다르지만 일반적으로 돌변에 의해 반환된 데이터, 오류 및 추가 메타데이터와 같은 정보를 포함합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 구독\n\n먼저 웹소켓을 위한 graphQL 클라이언트를 만들겠습니다.\n\n```js\nfinal WebSocketLink websocketLink = WebSocketLink(\n    url: '\u003cYOUR-GRAPHQL-SUBSCRIPTION-ENDPOINT\u003e',\n    config: SocketClientConfig(\n    autoReconnect: true,\n    inactivityTimeout: Duration(seconds: 30),\n  ),\n);\n\nwebsocketClient = GraphQLClient(\n  link: websocketLink,\n  cache: GraphQLCache(),\n);\n```\n\n웹소켓 링크 설정:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- WebSocketLink은 GraphQL 구독용 WebSocket 전송의 구현체입니다. 지정된 GraphQL 서버 엔드포인트로 WebSocket 연결을 설정합니다.\n- URL: `YOUR-GRAPHQL-SUBSCRIPTION-ENDPOINT`: 실제 웹소켓 엔드포인트로 대체합니다. 이는 GraphQL 서버에서 제공하는 실제 웹소켓 엔드포인트로 구독을 처리합니다. 이 URL은 일반적으로 ws:// 또는 wss://로 시작합니다.\n- config: SocketClientConfig(...): WebSocket 연결에 대한 구성 옵션을 제공합니다.\n- autoReconnect: true: 연결이 끊긴 경우 자동 재연결을 활성화합니다.\n- inactivityTimeout: Duration(seconds: 30): 활동이 없거나 해당 시간 내에 통신이 발생하지 않을 경우 웹소켓 연결을 닫기 위한 타임아웃 기간을 설정합니다.\n\nGraphQLClient 설정:\n\n- GraphQLClient는 구독을 위한 통신 링크로 WebSocketLink를 사용하여 인스턴스화됩니다. 또한 캐싱을 위해 GraphQLCache를 사용합니다.\n- link: websocketLink: GraphQL 클라이언트의 통신 링크로 WebSocketLink를 지정합니다. 이는 구독이 WebSocket 연결을 통해 처리되도록 합니다.\n- cache: GraphQLCache(): GraphQL 클라이언트의 로컬 상태 및 쿼리 결과를 저장하고 관리하기 위한 캐시를 초기화합니다.\n\n이제 GraphQL 구독 문서를 작성해 봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```javascript\n  static final userUpdatedMutation = gql(r'''\nsubscription userUpdatedSubscription($id: String) {\n        userUpdatedSubscription(id: $id) {\n            ...UserFragment\n        }\n    }\n    fragment UserFragment on User {\n        id\n        first_name\n        last_name\n    }\n    ''');\n```\n\nGraphQL Subscription:\n\n- userUpdatedMutation은 사용자가 업데이트될 때 업데이트를 청취하는 GraphQL 구독(subscription)입니다. 사용자관련 정보를 관심 있는 사용자로 지정하기 위해 String 타입의 $id 매개변수를 가져옵니다.\n- subscription userUpdatedSubscription($id: String): id 변수를 허용하는 userUpdatedSubscription이라는 이름의 구독을 선언합니다.\n- userUpdatedSubscription(id: $id): 이 구독은 지정된 id를 가진 사용자에 대한 업데이트에 관심이 있다는 것을 나타냅니다.\n- ' ...UserFragment ': 이 구독에는 fragment spread, ...UserFragment가 포함되어 있어서 UserFragment에서 지정된 필드를 수신하려는 것을 나타냅니다.\n\nGraphQL Fragment:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- GraphQL 프래그먼트 (UserFragment)는 여러 쿼리, 뮤테이션 또는 구독에서 사용할 수 있는 재사용 가능한 필드 세트를 정의합니다.\n- UserFragment on User ' ... '의 프래그먼트는 User 유형에서 UserFragment라는 이름의 프래그먼트를 선언합니다.\n- 이 프래그먼트에는 id, first_name, last_name과 같은 필드가 포함되어 있습니다. ...UserFragment 스프레드를 포함하는 모든 작업은 이러한 필드를 자동으로 포함합니다.\n- 프래그먼트는 필드 정의의 중복을 피하고 코드 재사용성을 촉진하는 데 도움이 됩니다. 여러 작업이 공통 필드를 공유할 때 특히 유용합니다.\n\n이제 이 구독을 들어보겠습니다\n\n```js\nvoid _subscribe() async {\n  final subscription = await websocketClient.subscribe(\n    SubscriptionOptions(\n      document: userUpdatedMutation,\n    ),\n  );\n\n  subscription.listen((result) {\n    final userData = result.data?['user'];\n    print('이름: ${userData[\"first_name\"]}');\n    print('성: ${userData[\"last_name\"]}');\n    // 실시간 업데이트 처리, 예를 들어 UI 업데이트\n  });\n}\n```\n\nSubscription Widget도 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nbody: Subscription(\n        options: SubscriptionOptions(\n        document: userUpdatedMutation,\n        ),\n        builder: (result) {\n          final user = result.data?[\"user\"];\n          return ListTile(\n            title: Text(user[\"first_name\"]),\n            subtitle: Text(user[\"last_name\"]),\n          );\n        },\n      ),\n```\n\n# 결론\n\n이 가이드를 통해 플러터에서 GraphQL 구현에 대한 포괄적인 이해를 제공했습니다. 쿼리, 뮤테이션 및 구독의 기본 사항부터 실제 통합 단계에 이르기까지의 내용이 담겨 있습니다. 실시간 업데이트를 통한 GraphQL 구독에 중점을 두고 뮤테이션 작업을 시연함으로써, 개발자들은 이제 플러터 프로젝트에 GraphQL을 원활하게 통합할 수 있습니다. 이 포괄적인 리소스는 모든 수준의 개발자가 데이터 검색을 최적화하고 앱의 효율성을 향상시키며, 플러터에서 GraphQL의 강력함을 통해 동적 사용자 경험을 제공할 수 있는 기술을 제공합니다.","ogImage":{"url":"/assets/img/2024-06-21-GraphQLinFlutterAComprehensiveGuidetoQueryMutationandSubscriptionImplementations_0.png"},"coverImage":"/assets/img/2024-06-21-GraphQLinFlutterAComprehensiveGuidetoQueryMutationandSubscriptionImplementations_0.png","tag":["Tech"],"readingTime":9},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-GraphQLinFlutterAComprehensiveGuidetoQueryMutationandSubscriptionImplementations_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e이 기사는 플러터(Flutter)에서 GraphQL을 마스터하는 데 필수적인 가이드입니다! 기본 개념 이해부터 쿼리(query), 뮤테이션(mutation), 구독(subscription)의 핵심 개념까지 모두 다룹니다. 뿐만 아니라 Flutter 앱에 GraphQL을 원활하게 통합하는 방법을 단계별 지침과 코드 샘플을 제공하면서 안내해드립니다.\u003c/p\u003e\n\u003ch1\u003eGraphQL이란?\u003c/h1\u003e\n\u003cp\u003eGraphQL을 주문하듯이 생각해보세요. 일반 레스토랑(전통적인 API와 같은)에서는 특정 토핑이 올라간 고정된 피자를 주문합니다. 원하는 거랑 다르면 완전히 새로운 피자를 주문해야 합니다.\u003c/p\u003e\n\u003cp\u003e지금은 GraphQL을 사용하면 피자에 원하는 대로 말하는 것과 같아요 — 크러스트, 소스, 토핑 종류를 정확하게 말하는 것과 같아요. 당신을 위해 특별히 만들어진 피자를 받게 되는거죠. 딱 필요한 만큼만요. 데이터에 대한 맞춤 주문처럼 생각해보세요 — 필요한 것을 요청하면 정확히 그것을 받게 되어 매우 효율적이고 요구 사항에 맞게 제작됩니다.\u003c/p\u003e\n\u003cp\u003e그 외에도, GraphQL은 데이터와 상호 작용하는 방법을 간소화하여 세 가지 주요 작업을 제공합니다: 쿼리, 뮤테이션, 그리고 구독.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e쿼리: GraphQL에서 쿼리는 특정 데이터를 요청하는 것입니다. 서버에서 정보를 요청하는 것과 같이 특정 데이터와 그 구조를 명시합니다. 당신이 원하는 토핑과 크러스트 유형을 주문하는 것과 같은 거죠.\u003c/li\u003e\n\u003cli\u003e뮤테이션: GraphQL에서 뮤테이션은 데이터 수정을 다루는 작업들입니다. 새 데이터 추가, 기존 레코드 업데이트, 혹은 정보 삭제와 같은 작업을 할 수 있습니다. 피자 비유에서는 셰프에게 선호에 따라 토핑을 추가하거나 제거하도록 지시하는 것과 같아요.\u003c/li\u003e\n\u003cli\u003e구독: 구독은 GraphQL에서 실시간 업데이트를 가능하도록 합니다. 클라이언트(당신)와 서버(셰프) 사이에 지속적인 연결을 설정하여 서버가 가능한 즉시 새 정보를 클라이언트에게 푸시할 수 있게 합니다. 피자 준비 과정을 알려주는 셰프와 같이 데이터 변경 사항에 대한 실시간 알림을 받는 것과 같아요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e그래서, GraphQL은 주문을 맞춤 제작하는 것 이상이에요; 당신이 요구하는 대로 데이터를 조회, 수정하고 최신 상태를 유지할 수 있도록 효율적이고 요구 사항에 정확히 맞게 제작된 방법을 제공하는겁니다.\u003c/p\u003e\n\u003ch1\u003e플러터에서 GraphQL 구현하기\u003c/h1\u003e\n\u003cp\u003e먼저, 다음 패키지를 pubspec.yaml 파일에 추가하고 flutter pub get을 실행하세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e  \u003cspan class=\"hljs-attr\"\u003egraphql_flutter\u003c/span\u003e: latest\n  \u003cspan class=\"hljs-attr\"\u003egraphql\u003c/span\u003e: latest\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 다음과 같이 GraphQL 클라이언트를 생성하세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e  final \u003cspan class=\"hljs-title class_\"\u003eHttpLink\u003c/span\u003e _httpLink = \u003cspan class=\"hljs-title class_\"\u003eHttpLink\u003c/span\u003e(\n    \u003cspan class=\"hljs-string\"\u003e\"\u0026#x3C;YOUR-BASE-URL\u003e\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003edefaultHeaders\u003c/span\u003e: {\n      \u003cspan class=\"hljs-string\"\u003e'Authorization'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'Bearer \u0026#x3C;YOUR_PERSONAL_ACCESS_TOKEN\u003e'\u003c/span\u003e,\n      \u003cspan class=\"hljs-string\"\u003e'AuthorizationSource'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'API'\u003c/span\u003e,\n    },\n  );\n\n\n  final \u003cspan class=\"hljs-title class_\"\u003eValueNotifier\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eGraphQLClient\u003c/span\u003e\u003e client = \u003cspan class=\"hljs-title class_\"\u003eValueNotifier\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eGraphQLClient\u003c/span\u003e(\n    \u003cspan class=\"hljs-attr\"\u003elink\u003c/span\u003e: _httpLink,\n    \u003cspan class=\"hljs-attr\"\u003ecache\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eGraphQLCache\u003c/span\u003e(),\n  ));\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e앱을 GraphQL 위젯을 사용하기위한 GraphQLProvider 상속 위젯으로 감싸세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e  \u003cspan class=\"hljs-title class_\"\u003eWidget\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebuild\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eBuildContext context\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eGraphQLProvider\u003c/span\u003e(\n      \u003cspan class=\"hljs-attr\"\u003eclient\u003c/span\u003e: client,\n      \u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eMaterialApp\u003c/span\u003e(\n        \u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'App'\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003ehome\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eHomeScreen\u003c/span\u003e(),\n      ),\n    );\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그럼 GraphQL API를 소비해봅시다.\u003c/p\u003e\n\u003ch1\u003e쿼리\u003c/h1\u003e\n\u003cp\u003e먼저 쿼리 문서를 정의해보겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efinal getUserQuery = \u003cspan class=\"hljs-title function_\"\u003egql\u003c/span\u003e(r\u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e'\n    query getUser($id: ID) {\n      user(id: $id) {\n        id\n        first_name\n        last_name\n      }\n    }\n'\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e쿼리 정의:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003equery getUser($id: ID): 이 줄은 getUser라는 GraphQL 쿼리의 정의를 시작합니다. $id는 쿼리에 전달할 수 있는 ID 유형의 변수입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e쿼리 본문:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e' user(id: $id) ' ... ' ': 쿼리의 본문은 우리가 원하는 데이터를 지정합니다. 이 경우 주어진 id를 가진 사용자에 대한 정보를 요청하고 있습니다. 요청된 세 가지 필드는 id, first_name 및 last_name입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e변수 사용:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e쿼리 내에서 $id 변수는 요청을 매개변수화하는 데 사용됩니다. 이는 쿼리가 실행될 때 특정 ID로 동적으로 채워지는 자리 표시자입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e쿼리 위젯\u003c/h2\u003e\n\u003cp\u003e이제 이 문서를 사용하여 GraphQL API에 요청을 보냅니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eQuery\u003c/span\u003e(\n  \u003cspan class=\"hljs-attr\"\u003eoptions\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eQueryOptions\u003c/span\u003e(\n    \u003cspan class=\"hljs-attr\"\u003edocument\u003c/span\u003e: getUserQuery,\n    \u003cspan class=\"hljs-attr\"\u003evariables\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e {\n      \u003cspan class=\"hljs-string\"\u003e\"id\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"1\"\u003c/span\u003e,\n    },\n  ),\n  \u003cspan class=\"hljs-attr\"\u003ebuilder\u003c/span\u003e: (\n    \u003cspan class=\"hljs-title class_\"\u003eQueryResult\u003c/span\u003e result, {\n    \u003cspan class=\"hljs-title class_\"\u003eFuture\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eQueryResult\u003c/span\u003e\u003e \u003cspan class=\"hljs-title class_\"\u003eFunction\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eFetchMoreOptions\u003c/span\u003e)? fetchMore,\n    \u003cspan class=\"hljs-title class_\"\u003eFuture\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eQueryResult\u003c/span\u003e?\u003e \u003cspan class=\"hljs-title class_\"\u003eFunction\u003c/span\u003e()? refetch,\n  }) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (result.\u003cspan class=\"hljs-property\"\u003ehasException\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"에러\"\u003c/span\u003e);\n    }\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (result.\u003cspan class=\"hljs-property\"\u003eisLoading\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCircularProgressIndicator\u003c/span\u003e();\n    }\n    final user = result.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e?[\u003cspan class=\"hljs-string\"\u003e\"user\"\u003c/span\u003e];\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eListTile\u003c/span\u003e(\n      \u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(user[\u003cspan class=\"hljs-string\"\u003e\"first_name\"\u003c/span\u003e]),\n      \u003cspan class=\"hljs-attr\"\u003esubtitle\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(user[\u003cspan class=\"hljs-string\"\u003e\"last_name\"\u003c/span\u003e]),\n    );\n  },\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e쿼리 위젯:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e이 문구는 graphql_flutter 패키지에서 제공하는 Query 위젯의 일부분입니다. Query 위젯은 GraphQL 쿼리를 실행하는 데 사용됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e쿼리의 옵션:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e옵션 매개변수는 GraphQL 쿼리 실행에 필요한 세부 정보를 제공하는 데 사용됩니다.\u003c/li\u003e\n\u003cli\u003e문서: getUserQuery: 실행할 GraphQL 쿼리는 getUserQuery 변수를 사용하여 지정됩니다. 이 변수는 코드의 이전 부분에서 정의된 쿼리입니다.\u003c/li\u003e\n\u003cli\u003e변수: const '\"id\": \"1\"': 이는 쿼리에 필요한 변수를 제공합니다. 이 경우 \"id\" 변수를 \"1\"로 설정하고 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eBuilder 함수:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ebuilder는 GraphQL 쿼리의 결과로 호출되는 콜백 함수입니다.\u003c/li\u003e\n\u003cli\u003eQueryResult result: GraphQL 쿼리 실행의 결과를 보유합니다.\u003c/li\u003e\n\u003cli\u003e빌더 안에서:\u003c/li\u003e\n\u003cli\u003eresult.hasException을 사용하여 예외를 확인합니다. 예외가 발생하면 \"Error\"를 표시하는 Text 위젯을 반환합니다.\u003c/li\u003e\n\u003cli\u003eresult.isLoading을 사용하여 쿼리가 여전히 로딩 중인지 확인합니다. true인 경우 CircularProgressIndicator를 반환합니다.\u003c/li\u003e\n\u003cli\u003e쿼리가 성공하고 로딩 중이 아닌 경우, 결과에서 사용자 데이터를 추출하고 ListTile에 표시합니다. ListTile에는 사용자의 성과 이름이 각각 제목과 부제목으로 나타납니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e쿼리 메소드\u003c/h2\u003e\n\u003cp\u003e응답을 그릴 때 더 많은 제어를 위해 GraphQL 클라이언트의 query 메소드를 사용하여 GraphQL API를 소비하는 다른 방법이 있습니다.\u003c/p\u003e\n\u003ch1\u003eMutation\u003c/h1\u003e\n\u003cp\u003e이제 먼저 변이 문서를 정의해 봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e final updateUserMutation = \u003cspan class=\"hljs-title function_\"\u003egql\u003c/span\u003e(r\u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e'\n    mutation updateUser($id: ID, $first_name: String, $last_name: String) {\n    updateUser(\n    input: {id: $id, first_name: $first_name, last_name: $last_name,}\n      ) {\n    user {\n      id\n      first_name\n      last_name\n    }\n    messages {\n      field\n      message\n    }\n  }\n}\n'\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 문서를 사용하여 GraphQL 클라이언트 객체를 사용하여 사용자 데이터를 업데이트해 봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efinal result = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e client.\u003cspan class=\"hljs-title function_\"\u003emutate\u003c/span\u003e(\n        \u003cspan class=\"hljs-title class_\"\u003eMutationOptions\u003c/span\u003e(\n          \u003cspan class=\"hljs-attr\"\u003edocument\u003c/span\u003e: updateUserMutation,\n          \u003cspan class=\"hljs-attr\"\u003evariables\u003c/span\u003e: {\n            \u003cspan class=\"hljs-string\"\u003e\"id\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"1\"\u003c/span\u003e,\n            \u003cspan class=\"hljs-string\"\u003e\"first_name\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"John\"\u003c/span\u003e,\n            \u003cspan class=\"hljs-string\"\u003e\"last_name\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Doe\"\u003c/span\u003e\n          },\n        ),\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eGraphQL Mutation 실행:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eclient.mutate: 이것은 GraphQL 클라이언트에서 mutate 메소드를 호출하는 것입니다. 클라이언트 객체는 GraphQL 클라이언트의 인스턴스입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e돌변에 대한 옵션:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e돌변 옵션은 GraphQL 돌변 실행에 대한 세부 정보를 제공하는 데 사용됩니다.\u003c/li\u003e\n\u003cli\u003e변수: '\"id\": \"1\", \"first_name\": \"John\", \"last_name\": \"Doe\"': 이는 돌변에 필요한 변수를 제공합니다. 사용자의 id와 함께 업데이트할 새로운 이름 및 성 값을 포함합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e결과 처리:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e돌변 작업의 결과는 결과 변수에 저장됩니다.\u003c/li\u003e\n\u003cli\u003e결과의 실제 구조는 사용되는 GraphQL 클라이언트에 따라 다르지만 일반적으로 돌변에 의해 반환된 데이터, 오류 및 추가 메타데이터와 같은 정보를 포함합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e구독\u003c/h1\u003e\n\u003cp\u003e먼저 웹소켓을 위한 graphQL 클라이언트를 만들겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efinal \u003cspan class=\"hljs-title class_\"\u003eWebSocketLink\u003c/span\u003e websocketLink = \u003cspan class=\"hljs-title class_\"\u003eWebSocketLink\u003c/span\u003e(\n    \u003cspan class=\"hljs-attr\"\u003eurl\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'\u0026#x3C;YOUR-GRAPHQL-SUBSCRIPTION-ENDPOINT\u003e'\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003econfig\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eSocketClientConfig\u003c/span\u003e(\n    \u003cspan class=\"hljs-attr\"\u003eautoReconnect\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003einactivityTimeout\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDuration\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eseconds\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e30\u003c/span\u003e),\n  ),\n);\n\nwebsocketClient = \u003cspan class=\"hljs-title class_\"\u003eGraphQLClient\u003c/span\u003e(\n  \u003cspan class=\"hljs-attr\"\u003elink\u003c/span\u003e: websocketLink,\n  \u003cspan class=\"hljs-attr\"\u003ecache\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eGraphQLCache\u003c/span\u003e(),\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e웹소켓 링크 설정:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWebSocketLink은 GraphQL 구독용 WebSocket 전송의 구현체입니다. 지정된 GraphQL 서버 엔드포인트로 WebSocket 연결을 설정합니다.\u003c/li\u003e\n\u003cli\u003eURL: \u003ccode\u003eYOUR-GRAPHQL-SUBSCRIPTION-ENDPOINT\u003c/code\u003e: 실제 웹소켓 엔드포인트로 대체합니다. 이는 GraphQL 서버에서 제공하는 실제 웹소켓 엔드포인트로 구독을 처리합니다. 이 URL은 일반적으로 ws:// 또는 wss://로 시작합니다.\u003c/li\u003e\n\u003cli\u003econfig: SocketClientConfig(...): WebSocket 연결에 대한 구성 옵션을 제공합니다.\u003c/li\u003e\n\u003cli\u003eautoReconnect: true: 연결이 끊긴 경우 자동 재연결을 활성화합니다.\u003c/li\u003e\n\u003cli\u003einactivityTimeout: Duration(seconds: 30): 활동이 없거나 해당 시간 내에 통신이 발생하지 않을 경우 웹소켓 연결을 닫기 위한 타임아웃 기간을 설정합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eGraphQLClient 설정:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eGraphQLClient는 구독을 위한 통신 링크로 WebSocketLink를 사용하여 인스턴스화됩니다. 또한 캐싱을 위해 GraphQLCache를 사용합니다.\u003c/li\u003e\n\u003cli\u003elink: websocketLink: GraphQL 클라이언트의 통신 링크로 WebSocketLink를 지정합니다. 이는 구독이 WebSocket 연결을 통해 처리되도록 합니다.\u003c/li\u003e\n\u003cli\u003ecache: GraphQLCache(): GraphQL 클라이언트의 로컬 상태 및 쿼리 결과를 저장하고 관리하기 위한 캐시를 초기화합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이제 GraphQL 구독 문서를 작성해 봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e final userUpdatedMutation = \u003cspan class=\"hljs-title function_\"\u003egql\u003c/span\u003e(r\u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e'\nsubscription userUpdatedSubscription($id: String) {\n        userUpdatedSubscription(id: $id) {\n            ...UserFragment\n        }\n    }\n    fragment UserFragment on User {\n        id\n        first_name\n        last_name\n    }\n    '\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eGraphQL Subscription:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003euserUpdatedMutation은 사용자가 업데이트될 때 업데이트를 청취하는 GraphQL 구독(subscription)입니다. 사용자관련 정보를 관심 있는 사용자로 지정하기 위해 String 타입의 $id 매개변수를 가져옵니다.\u003c/li\u003e\n\u003cli\u003esubscription userUpdatedSubscription($id: String): id 변수를 허용하는 userUpdatedSubscription이라는 이름의 구독을 선언합니다.\u003c/li\u003e\n\u003cli\u003euserUpdatedSubscription(id: $id): 이 구독은 지정된 id를 가진 사용자에 대한 업데이트에 관심이 있다는 것을 나타냅니다.\u003c/li\u003e\n\u003cli\u003e' ...UserFragment ': 이 구독에는 fragment spread, ...UserFragment가 포함되어 있어서 UserFragment에서 지정된 필드를 수신하려는 것을 나타냅니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eGraphQL Fragment:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eGraphQL 프래그먼트 (UserFragment)는 여러 쿼리, 뮤테이션 또는 구독에서 사용할 수 있는 재사용 가능한 필드 세트를 정의합니다.\u003c/li\u003e\n\u003cli\u003eUserFragment on User ' ... '의 프래그먼트는 User 유형에서 UserFragment라는 이름의 프래그먼트를 선언합니다.\u003c/li\u003e\n\u003cli\u003e이 프래그먼트에는 id, first_name, last_name과 같은 필드가 포함되어 있습니다. ...UserFragment 스프레드를 포함하는 모든 작업은 이러한 필드를 자동으로 포함합니다.\u003c/li\u003e\n\u003cli\u003e프래그먼트는 필드 정의의 중복을 피하고 코드 재사용성을 촉진하는 데 도움이 됩니다. 여러 작업이 공통 필드를 공유할 때 특히 유용합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이제 이 구독을 들어보겠습니다\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e_subscribe\u003c/span\u003e() \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n  final subscription = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e websocketClient.\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\n    \u003cspan class=\"hljs-title class_\"\u003eSubscriptionOptions\u003c/span\u003e(\n      \u003cspan class=\"hljs-attr\"\u003edocument\u003c/span\u003e: userUpdatedMutation,\n    ),\n  );\n\n  subscription.\u003cspan class=\"hljs-title function_\"\u003elisten\u003c/span\u003e((result) {\n    final userData = result.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e?[\u003cspan class=\"hljs-string\"\u003e'user'\u003c/span\u003e];\n    \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'이름: ${userData[\"first_name\"]}'\u003c/span\u003e);\n    \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'성: ${userData[\"last_name\"]}'\u003c/span\u003e);\n    \u003cspan class=\"hljs-comment\"\u003e// 실시간 업데이트 처리, 예를 들어 UI 업데이트\u003c/span\u003e\n  });\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSubscription Widget도 사용할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eSubscription\u003c/span\u003e(\n        \u003cspan class=\"hljs-attr\"\u003eoptions\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eSubscriptionOptions\u003c/span\u003e(\n        \u003cspan class=\"hljs-attr\"\u003edocument\u003c/span\u003e: userUpdatedMutation,\n        ),\n        \u003cspan class=\"hljs-attr\"\u003ebuilder\u003c/span\u003e: (result) {\n          final user = result.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e?[\u003cspan class=\"hljs-string\"\u003e\"user\"\u003c/span\u003e];\n          \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eListTile\u003c/span\u003e(\n            \u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(user[\u003cspan class=\"hljs-string\"\u003e\"first_name\"\u003c/span\u003e]),\n            \u003cspan class=\"hljs-attr\"\u003esubtitle\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(user[\u003cspan class=\"hljs-string\"\u003e\"last_name\"\u003c/span\u003e]),\n          );\n        },\n      ),\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e이 가이드를 통해 플러터에서 GraphQL 구현에 대한 포괄적인 이해를 제공했습니다. 쿼리, 뮤테이션 및 구독의 기본 사항부터 실제 통합 단계에 이르기까지의 내용이 담겨 있습니다. 실시간 업데이트를 통한 GraphQL 구독에 중점을 두고 뮤테이션 작업을 시연함으로써, 개발자들은 이제 플러터 프로젝트에 GraphQL을 원활하게 통합할 수 있습니다. 이 포괄적인 리소스는 모든 수준의 개발자가 데이터 검색을 최적화하고 앱의 효율성을 향상시키며, 플러터에서 GraphQL의 강력함을 통해 동적 사용자 경험을 제공할 수 있는 기술을 제공합니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-21-GraphQLinFlutterAComprehensiveGuidetoQueryMutationandSubscriptionImplementations"},"buildId":"4HDhroK4kHnB5DAbbbGv3","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>