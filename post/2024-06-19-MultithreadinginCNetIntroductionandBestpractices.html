<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>C Net에서의 멀티스레딩 소개 및 모범 사례 | uidev-css</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://uidev-css.github.io///post/2024-06-19-MultithreadinginCNetIntroductionandBestpractices" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="C Net에서의 멀티스레딩 소개 및 모범 사례 | uidev-css" data-gatsby-head="true"/><meta property="og:title" content="C Net에서의 멀티스레딩 소개 및 모범 사례 | uidev-css" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://uidev-css.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://uidev-css.github.io///post/2024-06-19-MultithreadinginCNetIntroductionandBestpractices" data-gatsby-head="true"/><meta name="twitter:title" content="C Net에서의 멀티스레딩 소개 및 모범 사례 | uidev-css" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | uidev-css" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-19 14:35" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b75a4bf98ee956a8.js" defer=""></script><script src="/_next/static/fyfGyRz00q80ZdkogiVCt/_buildManifest.js" defer=""></script><script src="/_next/static/fyfGyRz00q80ZdkogiVCt/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UIDEV CSS</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">C Net에서의 멀티스레딩 소개 및 모범 사례</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="C Net에서의 멀티스레딩 소개 및 모범 사례" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UIDEV CSS</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 19, 2024</span><span class="posts_reading_time__f7YPP">21<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-19-MultithreadinginCNetIntroductionandBestpractices&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_0.png" alt="image"></p>
<h1>Agenda</h1>
<h2>I/ Introduction</h2>
<ul>
<li>Threads in a Computer CPU</li>
<li>Scheduler &#x26; Time slices</li>
<li>Processes &#x26; Threads</li>
<li>Concurrency and parallelism</li>
<li>Asynchrony vs Multithreading</li>
<li>Benefits of using multithreading in C#</li>
</ul>
<h2>II 스레드 C#에서</h2>
<p>스레드 라이프사이클
스레드 생성, 시작 및 일시 중지
Join
Abort
Interrupt
스레드 취소: 스레드를 중지하는 더 나은 방법</p>
<h2>III/ 스레드 관련 문제</h2>
<p>데드락과 레이스 컨디션
Join 및 Locks를 사용하여 레이스 컨디션 및 데드락 방지
AutoResetEvent
스레드 성능 문제</p>
<h2>IV/ 스레드 풀</h2>
<h2>V/ 동기화 메커니즘</h2>
<p>Mutex
Semaphore
Monitor (lock)</p>
<h2>VI/ 스레드 관리하기</h2>
<p>포그라운드 대비 백그라운드 스레드
스레드 컨텍스트
스레드에 데이터 전달
스레드 우선순위
스레드 로컬 저장소
스레드 디버깅</p>
<h2>VII/ .Net에서 스레드를 다루는 추천 방법</h2>
<h1>I/ 소개</h1>
<h2>컴퓨터 CPU에서의 스레드</h2>
<p>쓰레드(thread)와 병렬성(parallelism)에 대해 이해하기 전에, 기본적인 하드웨어 동작 원리를 잘 파악하는 것이 중요합니다.</p>
<p>CPU(중앙 처리 장치)는 컴퓨터의 뇌로, 애플리케이션을 실행하는 데 필요한 모든 명령을 실행하는 역할을 합니다.</p>
<p>현대 컴퓨터에는 종종 여러 개의 코어(core)가 있으며, 각각이 논리 프로세서(logical processor)로 분할될 수 있습니다.</p>
<p>각 프로세서는 두 개의 논리 프로세서로 나눠집니다.</p>
<p>각 논리 코어는 이제 병렬로 여러 스레드를 처리할 수 있습니다! 예를 들어, 4코어 프로세서는 하이퍼스레딩 기술 덕분에 8개의 스레드를 동시에 처리할 수 있습니다.</p>
<p>컴퓨터의 코어(core) 및 논리 코어(logical core) 수를 확인하려면 작업 관리자로 이동하여 '성능' 탭을 선택하세요.</p>
<p><img src="/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_4.png" alt="Task Manager Performance"></p>
<p>또는 애플리케이션에서 다음 코드를 실행해도 됩니다:</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Console</span>.<span class="hljs-title class_">WriteLine</span>(<span class="hljs-string">"코어 수: "</span> + <span class="hljs-title class_">Environment</span>.<span class="hljs-property">ProcessorCount</span>);
</code></pre>
<h2>스케줄러 및 시간 조각</h2>
<p><strong>스케줄러</strong></p>
<p>실제로 각 코어는 많은 명령을 동시에 실행합니다.</p>
<p>다른 작업을 블록하는 것을 방지하기 위해 각 작업에 일정한 시간을 할당합니다.</p>
<p>모든 작업을 아주 빠른 속도로 전환하면, 모든 작업이 동시에 실행되는 것 같아요!</p>
<p>윈도우즈에서는 스케줄러라는 특별한 프로그램이 프로세서가 명령을 실행할 순서와 시간 프레임(프로세서 시간 조각이라고도 함)을 결정해요.</p>
<p>이 프로그램은 프로세서가 명령을 실행할 순서와 시간 프레임을 결정하는 역할을 해요.</p>
<p><img src="/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_5.png" alt="이미지"></p>
<p>프로세서 시간 조각</p>
<p>이 시간 프레임은 프로세서 시간 조각으로도 알려져 있어요.</p>
<p>이러한 시간 조각은 프로세서가 특정 명령을 처리하는 기간입니다. 너무 긴 명령이 전체 컴퓨터를 막는 것을 방지하기 위해 각 명령에는 특정 시간 조각이 부여됩니다.</p>
<p><img src="/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_6.png" alt="이미지"></p>
<h2>프로세스 및 스레드</h2>
<p>이제 프로세스와 스레드의 차이를 살펴보겠습니다.</p>
<p><img src="/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_7.png" alt="Image"></p>
<p>프로세스는 실행 중인 프로그램입니다. 운영 체제는 실행 중인 응용 프로그램을 분리하기 위해 프로세스를 사용합니다. 스레드는 운영 체제가 프로세서 시간을 할당하는 기본 단위입니다.</p>
<p>프로세스</p>
<ul>
<li>기본적으로 프로그램을 실행하는 인스턴스</li>
<li>고유한 메모리 공간과 자원을 보유합니다.</li>
<li>다른 프로세스와 독립적으로 작동합니다.</li>
<li>스레드를 하나 이상 포함할 수 있습니다.</li>
</ul>
<p>전형적인 시스템에는 수백 개의 프로세스가 동시에 실행될 수 있습니다.</p>
<p>각 프로세스는 스레드를 포함하는 컨테이너 역할을 합니다.</p>
<p>프로세스가 시작되면 각각이 자체 메모리 및 리소스를 할당받아 스레드 사이에서 공유됩니다.</p>
<p>스레드</p>
<ul>
<li>프로세스 내에서의 실행 단위</li>
<li>각각 자체 스택을 가짐</li>
<li>동일한 프로세스 내 다른 스레드와 힙 메모리를 공유함</li>
</ul>
<p>다음은 Markdown 형식으로 된 표입니다.</p>
<p><img src="/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_9.png" alt="이미지1"></p>
<p>멀티 스레딩 프로세스에서 스레드는 힙 메모리를 공유합니다.</p>
<p><img src="/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_10.png" alt="이미지2"></p>
<p>멀티스레딩은 프로그램이 여러 스레드를 실행할 수 있는 능력으로, 시스템 리소스를 효율적으로 활용할 수 있게 합니다.</p>
<p>아래는 Markdown 형식으로 수정한 내용입니다.</p>
<p><img src="/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_11.png" alt="image"></p>
<h2>Concurrency and parallelism</h2>
<p><img src="/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_12.png" alt="image"></p>
<p>Concurrency</p>
<ul>
<li>두 개 이상의 작업이 겹치는 시간 동안 시작, 실행 및 완료될 수 있는 경우</li>
<li>단일 쓰레드가 빠르게 전환하여 여러 작업을 처리하도록 하여 동시 실행의 환상을 주는 것</li>
</ul>
<p>병렬 처리</p>
<ul>
<li>둘 이상의 작업이 서로 다른 쓰레드에서 동시에 실행되는 경우</li>
<li>두 개의 쓰레드가 실행하는 두 가지 작업</li>
</ul>
<p><img src="/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_13.png" alt="이미지"></p>
<h2>비동기 처리 vs 멀티스레딩</h2>
<p>동기</p>
<ul>
<li>각 작업은 다음 작업이 시작되기 전에 완료되어야 합니다.</li>
<li>한 작업이 너무 오래 걸리는 경우 비효율성을 야기할 수 있으며, 작업이 완료될 때까지 앱이 멈추거나 블로킹될 수 있습니다.</li>
</ul>
<p>작업은 순차적으로 실행됩니다.</p>
<p>비동기 (단일 스레드)</p>
<ul>
<li>한 스레드가 여러 작업을 처리하면서 그 사이를 전환함</li>
<li>흐름을 차단하지 않고 작업이 동시에 진행되도록 함</li>
</ul>
<p>두 작업이 같은 스레드 내에서 시작되고 동시에 진행됨</p>
<p>비동기 (다중 스레드)</p>
<ul>
<li>여러 스레드가 동시에 서로 다른 작업을 처리합니다</li>
<li>두 작업을 빠르고 효율적으로 완료합니다</li>
</ul>
<p>두 스레드를 사용하면 두 작업이 서로 독립적으로 동시에 진행됩니다</p>
<p><img src="/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_14.png" alt="이미지"></p>
<h2>C#에서 멀티스레딩을 사용하는 장점</h2>
<p>성능</p>
<p>첫 번째 분명한 장점은 하드웨어 성능을 활용하여 작업을 병렬로 실행하여 속도를 높일 수 있다는 것입니다.</p>
<p>응답성</p>
<p>여러 프로세스가 동시에 실행되는 경우 데이터를 검색하기 위해 사용자가 클릭하더라도, 하나의 스레드가 데이터를 가져오는 동안 앱 전체가 반응성을 유지합니다.</p>
<p>확장성</p>
<p>더 많은 요청을 처리하기 위해서는 각 작업에 대해 다른 스레드를 사용하여 동시에 처리하는 것이 가능합니다.</p>
<h2>II. C#에서의 스레드</h2>
<p>이미 소개된 것처럼, 스레드는 CPU의 가장 낮은 작업 단위입니다.</p>
<p>C#은 스레드를 다루기 쉽게 만드는 라이브러리를 제공합니다: Thread 클래스입니다. 이 클래스를 사용하면 전체 스레드 라이프사이클을 관리할 수 있어요!</p>
<p><img src="/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_15.png" alt="Thread Lifecycle"></p>
<h2>Thread Lifecycle</h2>
<p>일반적인 스레드는 다음과 같은 단계를 거칩니다.</p>
<ul>
<li>스레드가 생성되었습니다</li>
<li>스레드가 시작되었습니다</li>
<li>스레드가 메소드를 완료했습니다</li>
<li>스레드가 자동으로 종료되었습니다</li>
</ul>
<h2>스레드 생성, 시작 및 일시 중지</h2>
<p>스레드를 생성하는 방법은 여러 가지가 있습니다</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 새로운 스레드 생성</span>
<span class="hljs-keyword">var</span> thread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadStart</span>(<span class="hljs-title class_">Operation</span>));

<span class="hljs-comment">// 또는 더 간결한 방법으로</span>
<span class="hljs-keyword">var</span> thread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-title class_">Operation</span>);

<span class="hljs-comment">// 또는 람다를 사용하여</span>
<span class="hljs-keyword">var</span> thread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-function">() =></span> { <span class="hljs-title class_">Operation</span>(); });
</code></pre>
<p>위에서 볼 수 있듯이 스레드는 인스턴스화되려면 메서드 대리자를 가져야 합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 스레드는 작업(메서드 대리자)이 필요합니다</span>
<span class="hljs-keyword">var</span> thread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-title class_">Operation</span>);

<span class="hljs-comment">// 완료해야 할 작업이 스레드 내로 전달됩니다</span>
private <span class="hljs-keyword">void</span> <span class="hljs-title class_">Operation</span>()
{
    <span class="hljs-title class_">Console</span>.<span class="hljs-title class_">WriteLine</span>(<span class="hljs-string">"스레드에서 안녕하세요"</span>);
}
</code></pre>
<p>스레드가 생성되었더라도 명시적으로 시작해야 합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 스레드 시작</span>
thread.<span class="hljs-title class_">Start</span>();
</code></pre>
<p>한 번 시작되면 작업을 자동으로 수행하고 완료될 때까지 계속됩니다.</p>
<p>한 번 종료된 스레드는 다시 시작할 수 없습니다.</p>
<p>그러나 .Sleep 메서드를 사용하여 스레드를 일시 중지할 수 있습니다.</p>
<p>시간이 경과한 후 자동으로 다시 시작됩니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 쓰레드를 일시 중지하고 중단하는 방법</span>
<span class="hljs-title class_">Thread</span>.<span class="hljs-title class_">Sleep</span>(<span class="hljs-number">2000</span>); <span class="hljs-comment">// 밀리초나 TimeSpan을 사용합니다.</span>
sleepingThread.<span class="hljs-title class_">Interrupt</span>();
</code></pre>
<p>쓰레드를 중지하는 방법에는 장단점이 있는 여러 가지 방법이 있습니다:</p>
<ul>
<li>Join</li>
<li>Abort</li>
<li>Interrupt</li>
</ul>
<h2>Join</h2>
<p>Thread.Join은 스레드를 "정상적으로" 중지시키므로 코드는 스레드가 중지될 때까지 기다립니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Thread</span> thread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-title class_">Work</span>);
thread.<span class="hljs-title class_">Start</span>();

<span class="hljs-comment">// 스레드가 "정상적으로" 중지될 때까지 대기</span>
thread.<span class="hljs-title class_">Join</span>();

<span class="hljs-title class_">Console</span>.<span class="hljs-title class_">WriteLine</span>(<span class="hljs-string">"스레드가 종료되었습니다."</span>);
</code></pre>
<p>또한, 스레드가 완료될 때까지 무기한 대기하는 것을 피하기 위해 타임아웃을 전달하는 것도 가능합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Thread</span> thread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-title class_">Work</span>);
thread.<span class="hljs-title class_">Start</span>();

<span class="hljs-comment">// 스레드가 중지되거나 타임아웃 시간이 경과할 때까지 대기</span>
bool didComplete = thread.<span class="hljs-title class_">Join</span>(<span class="hljs-number">1000</span>);
</code></pre>
<p>주로 이 코드는 주 스레드가 1초 동안 대기하도록 하고 해당 스레드의 실행이 완료됐는지 확인합니다.</p>
<p>Join의 블로킹 특성</p>
<p>Thread.Join은 블로킹 호출이므로, 해당 스레드가 실행을 완료하거나 선택적으로 지정된 시간 제한이 경과할 때까지 반환하지 않습니다.</p>
<p>즉, 주 스레드가 해당 스레드의 완료를 기다려야 한다는 것을 의미합니다.</p>
<p>예를 들어, Join을 현재 스레드에서 호출해서는 안 돼요.</p>
<p>현재 스레드에서 현재 스레드에 Thread.Join을 호출하면 현재 스레드가 자기 자신을 기다리기 때문에 애플리케이션이 응답하지 않게 될 거에요.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Thread</span> thread = <span class="hljs-title class_">Thread</span>.<span class="hljs-property">CurrentThread</span>;

<span class="hljs-comment">// 이렇게 하면 데드락이 발생하여 애플리케이션이 응답하지 않게 됩니다</span>
<span class="hljs-comment">// thread.Join(); // 이렇게 하지 마세요</span>

<span class="hljs-title class_">Console</span>.<span class="hljs-title class_">WriteLine</span>(<span class="hljs-string">"현재 스레드에 Join을 호출하는 것을 피하세요."</span>);
</code></pre>
<p>멀티스레드 환경에서 Join</p>
<p>조인은 블로킹 호출이기 때문에 멀티스레딩(그리고 병렬) 목표에 부합하지 않아요!</p>
<p>하지만 언제는 유용할 수도 있어요. 다른 스레드가 객체를 조작하는 하나의 스레드를 기다려야 하는 경쟁 조건에서 유용할 수 있답니다 (나중에 더 설명할게요).</p>
<h2>중단</h2>
<p>쓰레드를 강제로 미리 종료하도록 하는 ThreadAbortException이 발생합니다.</p>
<p>그러나 스트림 연결을 닫지 않은 채로 갑작스럽게 스레드를 중지시킴으로써 메모리 누수나 리소스 누수가 발생할 수 있습니다.</p>
<p>게다가, 스레드가 중단될 때 스레드나 조작된 객체들의 상태가 불분명합니다.</p>
<p>이는 교착 상태, 리소스 누수 또는 메모리 누수로 이어질 수 있습니다!</p>
<p>마크다운 형식의 표 태그를 바꿔보세요.</p>
<p>인터럽트된 스레드가 Thread.Join 또는 Thread.Sleep를 호출했을 때에만 ThreadInterruptedException을 throw합니다.</p>
<p>이는 동기화된 코드 영역에 대한 액세스를 기다리거나 Thread.Sleep 중에 스레드를 차단하는 작업을 중지하는 데 사용할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Thread</span> thread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-title class_">Work</span>);
thread.<span class="hljs-title class_">Start</span>();

<span class="hljs-comment">// 스레드가 시작할 시간을 줍니다</span>
<span class="hljs-title class_">Thread</span>.<span class="hljs-title class_">Sleep</span>(<span class="hljs-number">500</span>);

<span class="hljs-comment">// 스레드를 인터럽트하여 ThreadInterruptedException을 발생시킵니다</span>
thread.<span class="hljs-title class_">Interrupt</span>();

<span class="hljs-comment">// 스레드가 인터럽션을 처리하고 완료할 때까지 기다립니다</span>
thread.<span class="hljs-title class_">Join</span>();
</code></pre>
<p>Thread.Interrupt는 스레드가 차단된 상태에서만 스레드를 인터럽트합니다. Thread.Sleep와 같이 현재 블로킹 호출 중인 코드가 아닌 경우엔 제3자 코드를 임의로 중단하지 않습니다.</p>
<p>Thread.Interrupt은 아직 지원되지만 CancellationToken을 사용한 협력적 취소가 더 예측 가능하고 관리하기 쉬운 스레드 중단 방법으로 자주 선호됩니다.</p>
<h2>스레드 취소: 스레드를 중지하는 더 좋은 방법</h2>
<p>그러나 .Net 5+부터 스레드 중단과 관련된 문제를 따라 Thread.Abort 또는 Thread.Interrupt 대신 스레드 취소를 사용하는 것을 Microsoft가 권장합니다.</p>
<p>이 접근 방식은 스레드를 갑작스럽게 종료하는 것과 관련된 예측할 수 없는 상황 및 잠재적인 리소스 누수를 방지합니다.</p>
<pre><code class="hljs language-cs"><span class="hljs-comment">// 취소 토큰을 인스턴스화합니다</span>
CancellationTokenSource cts = <span class="hljs-keyword">new</span> CancellationTokenSource();

<span class="hljs-comment">// 스레드에 토큰 전달</span>
Thread thread = <span class="hljs-keyword">new</span> Thread(() => Work(cts.Token));
Thread.Start();

<span class="hljs-comment">// 주 스레드에서 다른 작업 시뮬레이션</span>
Thread.Sleep(<span class="hljs-number">1000</span>);

<span class="hljs-comment">// 1초 후 스레드 작업 취소</span>
cts.Cancel();

<span class="hljs-comment">// 스레드가 정상적으로 종료될 때까지 대기</span>
thread.Join();
</code></pre>
<p>CancellationTokenSource: 이 클래스는 취소를 신호하는 메커니즘을 제공합니다. 스레드로 전달할 수 있는 CancellationToken을 생성합니다.</p>
<p>Work 메서드에 취소 토큰 전달</p>
<pre><code class="hljs language-cs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Work</span>(<span class="hljs-params">CancellationToken cancellationToken</span>)</span>
{
    <span class="hljs-keyword">try</span>
    {
        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)
        {
            <span class="hljs-comment">// 취소 요청 확인</span>
            cancellationToken.ThrowIfCancellationRequested();

            <span class="hljs-comment">// 작업 시뮬레이션</span>
            Thread.Sleep(<span class="hljs-number">500</span>);
            Console.WriteLine(<span class="hljs-string">"작업 중..."</span>);
        }
    }
    <span class="hljs-keyword">catch</span> (OperationCanceledException)
    {
        Console.WriteLine(<span class="hljs-string">"취소 요청 받음, 작업 종료."</span>);
    }
    <span class="hljs-keyword">finally</span>
    {
        Console.WriteLine(<span class="hljs-string">"여기 정리 코드가 있습니다."</span>);
    }
}
</code></pre>
<p>ThrowIfCancellationRequested: 이 메서드는 취소가 요청된 경우 OperationCanceledException을 throw하여 스레드가 안전하게 종료될 수 있도록합니다.</p>
<p>CancellationToken을 사용하는 이점</p>
<ul>
<li>안전한 종료: 스레드는 종료하기 전에 현재 작업을 마무리하고 자원을 적절히 정리할 수 있습니다.</li>
<li>예측 가능성: 스레드는 제어된 방식으로 종료되어 갑작스러운 종료의 위험을 피합니다.</li>
<li>협력적인 취소: 스레드는 주기적으로 토큰을 확인하여 중지해야 하는지 여부를 확인하여 스레드 관리에 협력적인 접근이 가능합니다.</li>
</ul>
<p>현대 .NET 애플리케이션에서 스레드 라이프사이클을 관리하는 선호되는 방법은 CancellationToken을 사용하는 것입니다. 이를 통해 스레드가 예측 가능하고 안전하게 취소될 수 있습니다.</p>
<h1>쓰레드 관련 문제</h1>
<h2>데드락과 경쟁 조건</h2>
<p>이미 소개된 대로, 각 쓰레드는 고유한 스택을 가지고 있지만 힙 메모리는 공유합니다.</p>
<p><img src="/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_18.png" alt="이미지"></p>
<p>여러 스레드가 하나의 공유된 값을 액세스하고 수정할 수 있다는 것을 의미합니다.</p>
<p>이는 레이스 조건이라고 불리는 것을 일으킬 수 있습니다. 기본적으로 두 스레드가 동시에 동일한 값을 변경하는 상황입니다.</p>
<p><img src="/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_19.png" alt="이미지 1"></p>
<p><img src="/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_20.png" alt="이미지 2"></p>
<p>요청해주신 코드 예제를 확인해보세요</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 공유 변수</span>
public <span class="hljs-keyword">static</span> int i = <span class="hljs-number">0</span>;

public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title class_">ExecuteWork</span>()
{
    <span class="hljs-comment">// 스레드가 루프를 실행</span>
    <span class="hljs-keyword">var</span> t = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-title class_">DoWork</span>);
    t.<span class="hljs-title class_">Start</span>();
    <span class="hljs-comment">// 다른 스레드가 루프를 실행하면 경쟁 상태로 이어집니다</span>
    <span class="hljs-title class_">DoWork</span>();
}
<span class="hljs-comment">// 두 스레드가 이 메서드를 실행함</span>
public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title class_">DoWork</span>()
{
    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &#x3C; <span class="hljs-number">5</span>; i++)
    {
        <span class="hljs-title class_">Console</span>.<span class="hljs-title class_">WriteLine</span>(<span class="hljs-string">"*"</span>);
    }
}
<span class="hljs-comment">// "******"이 출력되어야 할 것을 5개가 아닌 6개 출력함</span>
</code></pre>
<p>또다른 문제는 데드락인데, 이는 두 개 이상의 스레드가 영원히 차단되어 서로 다른 쓰레드가 리소스를 해제할 때를 기다리는 경우 발생합니다.</p>
<p>데드락은 여러 스레드가 동일한 리소스 세트가 필요하고 이를 서로 다른 순서로 획득할 때 발생할 수 있습니다.</p>
<h2>Join과 Lock을 사용하여 경합 조건과 데드락 방지하기</h2>
<p>경합 조건을 방지하려면 다음 중 하나를 할 수 있습니다:</p>
<ul>
<li>스레드가 서로 기다릴 수 있도록 하기</li>
<li>스레드를 잠그기</li>
</ul>
<p>이전에 보았던 것처럼 <code>Thread.Join</code>을 사용하여 스레드를 대기할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 메인 스레드를 일시 중지합니다.</span>
<span class="hljs-comment">// 스레드가 완료될 때까지 대기합니다.</span>
<span class="hljs-comment">// 메인 스레드를 다시 실행합니다.</span>
thread.<span class="hljs-title class_">Join</span>();

<span class="hljs-comment">// TimeSpan 또는 int Milliseconds도 사용할 수 있습니다.</span>
bool <span class="hljs-title class_">Thread</span>.<span class="hljs-title class_">Join</span>(<span class="hljs-title class_">TimeSpan</span> timeout);
</code></pre>
<p>다른 방법은 <code>Thread.Lock</code> 문을 사용하는 것입니다.</p>
<p>해당 문은 기본적으로 공유 객체를 "잠그고" 실행 중인 스레드만에게 액세스할 수 있도록 합니다.</p>
<p>한 번 스레드가 끝나면 객체를 해제합니다.</p>
<pre><code class="hljs language-js">using <span class="hljs-title class_">System</span>;
using <span class="hljs-title class_">System</span>.<span class="hljs-property">Threading</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Program</span>
{
<span class="hljs-comment">// 이 객체들은 공유됩니다</span>
    private <span class="hljs-keyword">static</span> readonly object lock1 = <span class="hljs-keyword">new</span> <span class="hljs-title function_">object</span>();
    private <span class="hljs-keyword">static</span> readonly object lock2 = <span class="hljs-keyword">new</span> <span class="hljs-title function_">object</span>();

    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title class_">Main</span>()
    {
        <span class="hljs-comment">// 스레드 1</span>
        <span class="hljs-keyword">var</span> t1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-title class_">Thread1</span>);
        t1.<span class="hljs-title class_">Start</span>();

        <span class="hljs-comment">// 스레드 2</span>
        <span class="hljs-keyword">var</span> t2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-title class_">Thread2</span>);
        t2.<span class="hljs-title class_">Start</span>();

        t1.<span class="hljs-title class_">Join</span>();
        t2.<span class="hljs-title class_">Join</span>();
    }

    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title class_">Thread1</span>()
    {
        lock (lock1)
        {
            <span class="hljs-title class_">Thread</span>.<span class="hljs-title class_">Sleep</span>(<span class="hljs-number">100</span>); <span class="hljs-comment">// 일부 작업 시뮬레이션</span>
            lock (lock2)
            {
                <span class="hljs-title class_">Console</span>.<span class="hljs-title class_">WriteLine</span>(<span class="hljs-string">"Thread 1이 두 개의 락을 획득했습니다"</span>);
            }
        }
    }

    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title class_">Thread2</span>()
    {
        lock (lock2)
        {
            <span class="hljs-title class_">Thread</span>.<span class="hljs-title class_">Sleep</span>(<span class="hljs-number">100</span>); <span class="hljs-comment">// 일부 작업 시뮬레이션</span>
            lock (lock1)
            {
                <span class="hljs-title class_">Console</span>.<span class="hljs-title class_">WriteLine</span>(<span class="hljs-string">"Thread 2가 두 개의 락을 획득했습니다"</span>);
            }
        }
    }
}
</code></pre>
<h2>AutoResetEvent</h2>
<p>AutoResetEvent를 사용하면 스레드 간 통신을 동기화할 수 있습니다.</p>
<p>다음은 작동 방법입니다:</p>
<ul>
<li>AutoResetEvent를 생성합니다 =` 이벤트가 생성됨</li>
<li>1번 스레드가 이벤트에 대해 WaitOne()을 호출합니다 =` 스레드1은 이벤트가 해제될 때까지 기다립니다</li>
<li>2번 스레드가 작업을 수행한 후 이벤트에 대해 set()을 호출합니다 =` 스레드1이 작업을 수행할 수 있습니다</li>
</ul>
<pre><code class="hljs language-js">   <span class="hljs-keyword">static</span> <span class="hljs-title class_">AutoResetEvent</span> autoResetEvent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AutoResetEvent</span>(<span class="hljs-literal">false</span>);

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title class_">Thread1</span>()
    {
        autoResetEvent.<span class="hljs-title class_">WaitOne</span>(); <span class="hljs-comment">// 이벤트가 신호를 받을 때까지 대기합니다</span>
        <span class="hljs-comment">// 여기에서 작업을 수행합니다</span>
    }

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title class_">Thread2</span>()
    {
        <span class="hljs-comment">// 일부 작업을 시뮬레이션합니다.</span>
        <span class="hljs-title class_">Thread</span>.<span class="hljs-title class_">Sleep</span>(<span class="hljs-number">2000</span>); 
        autoResetEvent.<span class="hljs-title class_">Set</span>(); <span class="hljs-comment">// 이벤트를 신호하여 대기 중인 스레드 하나를 해제합니다</span>
    }
</code></pre>
<p>이제 스레드 간 통신이 이루어지며 서로 작업을 수행할 수 있는 시기를 신호로 알릴 수 있습니다.</p>
<p>로버스트한 통신을 위해서는 락을 피하기 위해 두 개의 AutoResetEvent와 함께 작업하는 것이 가장 좋습니다. 이렇게 하면 두 스레드가 필요할 때 Set 및 Wait를 시그널할 수 있습니다.</p>
<p><img src="/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_21.png" alt="이미지"></p>
<h2>스레드 성능 문제</h2>
<p>새로운 스레드를 시작하는 것은 성능적으로 비용이 많이 드는데, 그 이유는 여러 가지가 있습니다:</p>
<ul>
<li>메모리 할당</li>
</ul>
<p>새로운 스레드가 생성되면, 시스템은 해당 스레드의 스택과 스레드 제어 블록(TCB)을 위한 메모리를 할당합니다.</p>
<p>이러한 리소스를 할당하고 초기화하는 작업은 메모리와 시간을 모두 소모합니다.</p>
<ul>
<li>운영 체제(OS) 오버헤드</li>
</ul>
<p>각 스레드의 수명주기를 관리해야 합니다. 이러한 작업에는 CPU 사이클이 필요하며 스레드를 시작하는 오버헤드에 기여합니다.</p>
<ul>
<li>스레드 초기화</li>
</ul>
<p>스레드를 생성하는 것은 즉각적으로 이루어지지 않습니다. 할당된 자원을 설정하고 실행 환경을 구성하고 스케줄러에 통보하는 시간이 필요합니다.</p>
<p>이 문제의 해결책은 스레드 풀을 사용하는 것입니다.</p>
<p><img src="https://miro.medium.com/v2/resize:fit:720/0*9oNxhHqD2tltG8U4.gif" alt="ThreadPool"></p>
<h1>IV/ The ThreadPool</h1>
<p>System.Threading.ThreadPool 클래스는 worker 스레드 풀을 제공합니다. 또한 스레드 풀 스레드를 사용할 수 있습니다.</p>
<p>새 스레드를 생성하는 대신 스레드 풀을 사용하면 기존 스레드를 재사용하여 성능을 향상시킬 수 있습니다.</p>
<p>여기 과정이에요:</p>
<ul>
<li>쓰레드풀이 작업을 받음</li>
<li>쓰레드풀이 쓰레드 할당</li>
<li>쓰레드가 작업 실행</li>
<li>쓰레드가 풀로 반환</li>
</ul>
<p>.NET 프레임워크는 스레드 관리를 수동으로 하지 않고도 쓰레드 풀을 사용할 수 있게 해주는 내장 ThreadPool 클래스를 제공합니다.</p>
<p>그래서 이전에 하던 것처럼 쓰레드를 생성하는 대신 쓰레드를 쓰레드풀에 대기시키면 됩니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">ThreadPool</span>.<span class="hljs-title class_">QueueUserWorkItem</span>(<span class="hljs-title class_">Worker</span>);

<span class="hljs-keyword">void</span> <span class="hljs-title class_">Worker</span>()
{
    <span class="hljs-title class_">Console</span>.<span class="hljs-title class_">WriteLine</span>(<span class="hljs-string">"작업이 실행되었습니다."</span>);
}
</code></pre>
<p>관리되는 스레드 풀의 스레드는 백그라운드 스레드입니다.</p>
<p>언제든지 사용 가능한 스레드, 풀의 최대 및 최소 스레드를 볼 수 있습니다. 또한 이를 설정할 수도 있습니다!</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 사용 가능한 스레드 얻기</span>
<span class="hljs-title class_">ThreadPool</span>.<span class="hljs-title class_">GetAvailableThreads</span>(out int workerThreads, out int completionPortThreads);

<span class="hljs-comment">// 최대 스레드 얻기</span>
<span class="hljs-title class_">ThreadPool</span>.<span class="hljs-title class_">GetMaxThreads</span>(out int maxWorkerThreads, out int maxCompletionPortThreads);

<span class="hljs-comment">// 최소 스레드 얻기</span>
<span class="hljs-title class_">ThreadPool</span>.<span class="hljs-title class_">GetMinThreads</span>(out int minWorkerThreads, out int minCompletionPortThreads);

<span class="hljs-comment">// 최대 스레드 설정</span>
<span class="hljs-title class_">ThreadPool</span>.<span class="hljs-title class_">SetMaxThreads</span>(<span class="hljs-number">8</span>, <span class="hljs-number">8</span>);

<span class="hljs-comment">// 최소 스레드 설정</span>
<span class="hljs-title class_">ThreadPool</span>.<span class="hljs-title class_">SetMinThreads</span>(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>);
</code></pre>
<p>쓰레드 풀을 사용해도 공유 데이터를 사용할 때는 여전히 쓰레드를 동기화해야 해요.</p>
<h1>동기화 메커니즘</h1>
<p>Thread 클래스는 .NET의 동기화 기본 요소인 Mutex, Semaphore, Monitor와 원활하게 작동해요.</p>
<p>이러한 메커니즘은 공유 리소스에 대한 액세스를 관리하고, 데이터 일관성을 보장하며 경쟁 조건을 방지하는 데 도움이 돼요.</p>
<h2>뮤텍스</h2>
<p>뮤텍스(Mutex: mutual exclusion의 줄임말)는 한 번에 하나의 스레드만 락을 획득할 수 있는 동기화 기본 요소입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Mutex</span> mutex = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Mutex</span>();

<span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &#x3C; <span class="hljs-number">5</span>; i++)
{
   <span class="hljs-title class_">Thread</span> thread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-title class_">EnterCriticalSection</span>);
   thread.<span class="hljs-title class_">Start</span>(i);
}

<span class="hljs-keyword">void</span> <span class="hljs-title class_">EnterCriticalSection</span>(object threadId)
{
  mutex.<span class="hljs-title class_">WaitOne</span>(); <span class="hljs-comment">// 뮤텍스 락 획득</span>

  <span class="hljs-keyword">try</span>
  {      
      <span class="hljs-title class_">Thread</span>.<span class="hljs-title class_">Sleep</span>(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 작업 시뮬레이션</span>
  }
  
  <span class="hljs-keyword">finally</span>
  {
      mutex.<span class="hljs-title class_">ReleaseMutex</span>(); <span class="hljs-comment">// 뮤텍스 락 해제</span>
  }
}
</code></pre>
<h2>세마포어</h2>
<p>세마포어는 동시에 리소스에 접근할 수 있는 스레드 수를 제한하는 동기화 기본 요소입니다.</p>
<p>사용 가능한 리소스 수를 유지하고, 수가 0이 될 때 스레드를 차단합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Semaphore</span> semaphore = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 2개의 스레드가 동시에 허용됨</span>

<span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &#x3C; <span class="hljs-number">5</span>; i++)
{
    <span class="hljs-title class_">Thread</span> thread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-title class_">EnterCriticalSection</span>);
    thread.<span class="hljs-title class_">Start</span>(i);
}

<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title class_">EnterCriticalSection</span>(object threadId)
{
    semaphore.<span class="hljs-title class_">WaitOne</span>(); <span class="hljs-comment">// 세마포어 획득</span>
    <span class="hljs-keyword">try</span>
    {
        <span class="hljs-comment">// Critical section: 공유 리소스에 액세스</span>
        <span class="hljs-title class_">Thread</span>.<span class="hljs-title class_">Sleep</span>(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 작업 시뮬레이션</span>
    }
    <span class="hljs-keyword">finally</span>
    {
        semaphore.<span class="hljs-title class_">Release</span>(); <span class="hljs-comment">// 세마포어 해제</span>
    }
}
</code></pre>
<h2>모니터 (lock)</h2>
<p>Monitor 클래스는 C#의 lock 키워드를 사용하는 것과 유사하게 리소스에 대한 독점적 액세스 메커니즘을 제공합니다.</p>
<p>이는 한 번에 한 스레드만 코드의 중요한 섹션을 실행할 수 있도록 보장합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">static</span> object lockObject = <span class="hljs-keyword">new</span> <span class="hljs-title function_">object</span>();


<span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &#x3C; <span class="hljs-number">5</span>; i++)
{
     <span class="hljs-title class_">Thread</span> thread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-title class_">EnterCriticalSection</span>);
     thread.<span class="hljs-title class_">Start</span>(i);
    }
 }

<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title class_">EnterCriticalSection</span>(object threadId)
{
   lock (lockObject) <span class="hljs-comment">// 락을 획득합니다.</span>
    {
      <span class="hljs-title class_">Thread</span>.<span class="hljs-title class_">Sleep</span>(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 작업 시뮬레이션</span>
    }
}
</code></pre>
<h1>VI/ 스레드 관리</h1>
<h2>Foreground vs background thread</h2>
<p>기본적으로 .NET에서 생성된 쓰레드는 전경 스레드이므로 완료될 때까지 애플리케이션을 유지합니다.</p>
<p>그러나 쓰레드를 백그라운드 쓰레드로 명시적으로 설정할 수 있으며, 전경 스레드가 모두 실행을 마치면 자동으로 종료됩니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 쓰레드를 백그라운드로 명시적으로 설정합니다.</span>
thread.<span class="hljs-property">IsBackground</span> = <span class="hljs-literal">true</span>;
</code></pre>
<p><img src="/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_22.png" alt="Image"></p>
<h2>스레드 컨텍스트</h2>
<p>스레드 컨텍스트에는 스레드가 실행을 중단하고 다시 시작할 수 있는 모든 정보가 포함되어 있습니다. 이에는 CPU 레지스터, 스택 및 기타 관련 데이터가 포함됩니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 스레드의 현재 상태에 대한 정보를 확인하려면 (실행 중, 백그라운드, 중지됨, 중단됨...)</span>
 <span class="hljs-keyword">var</span> threadState = thread.<span class="hljs-property">ThreadState</span>;
</code></pre>
<h2>쓰레드에 데이터 전달하기</h2>
<p>람다 표현식은 쓰레드를 초기화하고 데이터를 전달하는 데 자주 사용됩니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 한 개의 인수만 전달 가능</span>
<span class="hljs-keyword">var</span> thread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-function">() =></span> <span class="hljs-title class_">Operation</span>(<span class="hljs-string">"Hello"</span>));
</code></pre>
<pre><code class="hljs language-js">private <span class="hljs-keyword">void</span> <span class="hljs-title class_">Operation</span>(string name)
{
    <span class="hljs-title class_">Console</span>.<span class="hljs-title class_">WriteLine</span>(<span class="hljs-string">"쓰레드에서의 안녕"</span> + name);
}
</code></pre>
<p>그러나 race condition을 피하기 위해 공유 변수를 스레드에 전달할 때 주의해야 합니다. 상수 또는 지역 변수를 사용하는 것이 가장 좋습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> string greeting = <span class="hljs-string">"Hello"</span>;
<span class="hljs-keyword">var</span> thread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-function">() =></span> <span class="hljs-title class_">Operation</span>(greeting));
</code></pre>
<h2>스레드 우선순위</h2>
<p>스레드는 실행 순서를 결정하는 서로 다른 우선순위를 가질 수 있습니다.</p>
<p>더 높은 우선순위를 가진 스레드가 더 많은 CPU 시간을 받습니다. 기본 우선순위는 Normal입니다.</p>
<pre><code class="hljs language-js">thread.<span class="hljs-property">Priority</span> = <span class="hljs-title class_">ThreadPriority</span>.<span class="hljs-property">Highest</span>;

<span class="hljs-comment">// 가능한 옵션은:</span>
<span class="hljs-title class_">Lowest</span>
<span class="hljs-title class_">BelowNormal</span>
<span class="hljs-title class_">Normal</span>
<span class="hljs-title class_">AboveNormal</span>
<span class="hljs-title class_">Highest</span>
</code></pre>
<h2>스레드 로컬 스토리지</h2>
<p>Thread 클래스는 ThreadLocal<code>T</code> 클래스를 사용하여 스레드 로컬 스토리지를 지원합니다.</p>
<p>각 스레드가 고유한 데이터를 가지도록하여 스레드 안전을 보장하고 데이터 손상을 방지합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">ThreadLocal</span>&#x3C;int> threadLocalValue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&#x3C;int>(<span class="hljs-function">() =></span> <span class="hljs-number">0</span>);
</code></pre>
<h2>스레드 디버깅</h2>
<p>스레드에 이름을 지정하여 쉽게 디버깅할 수 있습니다.</p>
<p><img src="/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_23.png" alt="이미지"></p>
<pre><code class="hljs language-js">thread.<span class="hljs-property">Name</span> = <span class="hljs-string">"Bob Thread"</span>;
</code></pre>
<p><img src="/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_24.png" alt="이미지"></p>
<p>다음과 같이 사용중인 스레드 정보를 얻을 수 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">ConsoleWriteLine</span>(<span class="hljs-string">"메인 스레드의 ID: "</span> + <span class="hljs-title class_">Thread</span>.<span class="hljs-property">CurrentThread</span>.<span class="hljs-property">ManagedThreadId</span>);
</code></pre>
<p>또한 디버깅 중에는 어떤 스레드가 무엇을 수행하고 있는지 확인할 수도 있어요</p>
<p><img src="/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_25.png" alt="이미지"></p>
<p>위 내용은 아래 창을 표시합니다.</p>
<p><img src="/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_26.png" alt="이미지"></p>
<h1>VII/ .Net에서 스레드 작업 추천 방법</h1>
<ul>
<li>Thread.Abort를 사용하지 마세요</li>
</ul>
<p>해당 스레드에 예외를 throw하는 것과 유사하게 스레드를 강제로 종료시킵니다. 대신 취소 토큰을 사용하세요.</p>
<ul>
<li>다른 리소스를 필요로 하는 작업에는 여러 스레드를 사용하고 단일 리소스에 여러 스레드를 할당하는 것은 피하십시오.</li>
</ul>
<p>I/O 작업을 포함하는 작업은 블록을 방지하고 전체 처리량을 향상시키기 위해 각각 자체 스레드를 가지는 것이 좋습니다.</p>
<p>마찬가지로 사용자 입력 처리와 같은 작업은 전용 스레드로 처리하는 것이 가장 좋습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">ThreadPool</span>.<span class="hljs-title class_">QueueUserWorkItem</span>(<span class="hljs-title class_">PerformIOOperation</span>);
<span class="hljs-title class_">ThreadPool</span>.<span class="hljs-title class_">QueueUserWorkItem</span>(<span class="hljs-title class_">ProcessUserInput</span>);
</code></pre>
<ul>
<li>쓰레드에서 예외를 처리하세요.</li>
</ul>
<p>쓰레드에서 처리되지 않은 예외는 일반적으로 프로세스를 종료시킵니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">ThreadPool</span>.<span class="hljs-title class_">QueueUserWorkItem</span>(<span class="hljs-title class_">DoWork</span>);

<span class="hljs-keyword">void</span> <span class="hljs-title class_">DoWork</span>(object state)
{
    <span class="hljs-keyword">try</span>
    {
        <span class="hljs-comment">// 여기서 작업 수행</span>
    }
    <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> ex)
    {
        <span class="hljs-comment">// 예외 처리</span>
    }
}
</code></pre>
<ul>
<li>System.Threading.ThreadPool을 사용하여 쓰레드를 초기화하고 관리하세요.</li>
</ul>
<p><code>System.Threading.ThreadPool</code> 클래스를 사용하여 스레드를 초기화하고 관리하세요. 특히 짧은 수명을 가진 작업과 비동기 작업에 유용합니다.</p>
<p>스레드 풀은 작업자 스레드의 풀을 효율적으로 관리하여 스레드 생성 및 소멸의 부하를 줄입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">ThreadPool</span>.<span class="hljs-title class_">QueueUserWorkItem</span>(<span class="hljs-title class_">DoWork</span>);
</code></pre>
<ul>
<li>스레드 대신 작업들을 사용하세요!</li>
</ul>
<p>.NET Framework 4부터 멀티스레딩을 활용하는 권장 방법은 Task Parallel Library (TPL) 및 Parallel LINQ (PLINQ)를 사용하는 것입니다. 자세한 내용은 병렬 프로그래밍을 참조하십시오. (Microsoft)</p>
<p><img src="/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_27.png" alt="이미지"></p>
<p>다음 블로그에서 다시 만나요! :)</p>
<h2>언제 스레드를 사용해야 할까요?</h2>
<p>쓰레드는 작업과 같은 고수준 추상화로는 항상 달성할 수 없는 수준의 제어와 사용자 정의를 제공합니다.</p>
<p>쓰레드는 개발자에게 코드 실행을 저수준에서 직접 제어할 수 있는 기회를 제공합니다.</p>
<p>이는 특정 성능 중요한 상황이나 전문화된 시나리오에서 중요할 수 있는 리소스, 스케줄링 및 동기화의 정확한 관리를 가능하게 합니다.</p>
<p>쓰레드는 더 많은 제어와 유연성을 제공하지만 경합 조건, 데드락 및 동기화 문제와 같은 추가 복잡성과 잠재적인 함정도 동반합니다.</p>
<p>따라서, 귀하의 애플리케이션 요구 사항에 기반을 두고 상호 작용 모델을 신중히 고려하고 적절한 동시성 모델을 선택하는 것이 중요합니다.</p>
<h1>소스</h1>
<h2>비동기</h2>
<p><a href="https://www.udemy.com/course/ultimate-csharp-masterclass/" rel="nofollow" target="_blank">https://www.udemy.com/course/ultimate-csharp-masterclass/</a></p>
<h2>쓰레드</h2>
<p><a href="https://www.udemy.com/course/how-to-write-multi-threaded-csharp-code" rel="nofollow" target="_blank">멀티쓰레드 C# 코드 작성 방법</a></p>
<h2>.Net에서 병렬 프로그래밍</h2>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"C Net에서의 멀티스레딩 소개 및 모범 사례","description":"","date":"2024-06-19 14:35","slug":"2024-06-19-MultithreadinginCNetIntroductionandBestpractices","content":"\n\n\n![image](/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_0.png)\n\n# Agenda\n\n## I/ Introduction\n\n- Threads in a Computer CPU\n- Scheduler \u0026 Time slices\n- Processes \u0026 Threads\n- Concurrency and parallelism\n- Asynchrony vs Multithreading\n- Benefits of using multithreading in C#\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## II 스레드 C#에서\n\n스레드 라이프사이클\n스레드 생성, 시작 및 일시 중지\nJoin\nAbort\nInterrupt\n스레드 취소: 스레드를 중지하는 더 나은 방법\n\n## III/ 스레드 관련 문제\n\n데드락과 레이스 컨디션\nJoin 및 Locks를 사용하여 레이스 컨디션 및 데드락 방지\nAutoResetEvent\n스레드 성능 문제\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## IV/ 스레드 풀\n\n## V/ 동기화 메커니즘\n\nMutex\nSemaphore\nMonitor (lock)\n\n## VI/ 스레드 관리하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n포그라운드 대비 백그라운드 스레드\n스레드 컨텍스트\n스레드에 데이터 전달\n스레드 우선순위\n스레드 로컬 저장소\n스레드 디버깅\n\n## VII/ .Net에서 스레드를 다루는 추천 방법\n\n# I/ 소개\n\n## 컴퓨터 CPU에서의 스레드\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n쓰레드(thread)와 병렬성(parallelism)에 대해 이해하기 전에, 기본적인 하드웨어 동작 원리를 잘 파악하는 것이 중요합니다.\n\nCPU(중앙 처리 장치)는 컴퓨터의 뇌로, 애플리케이션을 실행하는 데 필요한 모든 명령을 실행하는 역할을 합니다.\n\n현대 컴퓨터에는 종종 여러 개의 코어(core)가 있으며, 각각이 논리 프로세서(logical processor)로 분할될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n각 프로세서는 두 개의 논리 프로세서로 나눠집니다.\n\n각 논리 코어는 이제 병렬로 여러 스레드를 처리할 수 있습니다! 예를 들어, 4코어 프로세서는 하이퍼스레딩 기술 덕분에 8개의 스레드를 동시에 처리할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n컴퓨터의 코어(core) 및 논리 코어(logical core) 수를 확인하려면 작업 관리자로 이동하여 '성능' 탭을 선택하세요.\n\n![Task Manager Performance](/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_4.png)\n\n또는 애플리케이션에서 다음 코드를 실행해도 됩니다:\n\n```js\nConsole.WriteLine(\"코어 수: \" + Environment.ProcessorCount);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 스케줄러 및 시간 조각\n\n**스케줄러**\n\n실제로 각 코어는 많은 명령을 동시에 실행합니다.\n\n다른 작업을 블록하는 것을 방지하기 위해 각 작업에 일정한 시간을 할당합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모든 작업을 아주 빠른 속도로 전환하면, 모든 작업이 동시에 실행되는 것 같아요!\n\n윈도우즈에서는 스케줄러라는 특별한 프로그램이 프로세서가 명령을 실행할 순서와 시간 프레임(프로세서 시간 조각이라고도 함)을 결정해요.\n\n이 프로그램은 프로세서가 명령을 실행할 순서와 시간 프레임을 결정하는 역할을 해요.\n\n![이미지](/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_5.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로세서 시간 조각\n\n이 시간 프레임은 프로세서 시간 조각으로도 알려져 있어요.\n\n이러한 시간 조각은 프로세서가 특정 명령을 처리하는 기간입니다. 너무 긴 명령이 전체 컴퓨터를 막는 것을 방지하기 위해 각 명령에는 특정 시간 조각이 부여됩니다.\n\n![이미지](/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_6.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 프로세스 및 스레드\n\n이제 프로세스와 스레드의 차이를 살펴보겠습니다.\n\n![Image](/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_7.png)\n\n프로세스는 실행 중인 프로그램입니다. 운영 체제는 실행 중인 응용 프로그램을 분리하기 위해 프로세스를 사용합니다. 스레드는 운영 체제가 프로세서 시간을 할당하는 기본 단위입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로세스\n\n- 기본적으로 프로그램을 실행하는 인스턴스\n- 고유한 메모리 공간과 자원을 보유합니다.\n- 다른 프로세스와 독립적으로 작동합니다.\n- 스레드를 하나 이상 포함할 수 있습니다.\n\n전형적인 시스템에는 수백 개의 프로세스가 동시에 실행될 수 있습니다.\n\n각 프로세스는 스레드를 포함하는 컨테이너 역할을 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로세스가 시작되면 각각이 자체 메모리 및 리소스를 할당받아 스레드 사이에서 공유됩니다.\n\n스레드\n\n- 프로세스 내에서의 실행 단위\n- 각각 자체 스택을 가짐\n- 동일한 프로세스 내 다른 스레드와 힙 메모리를 공유함\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음은 Markdown 형식으로 된 표입니다.\n\n![이미지1](/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_9.png)\n\n멀티 스레딩 프로세스에서 스레드는 힙 메모리를 공유합니다.\n\n![이미지2](/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_10.png)\n\n멀티스레딩은 프로그램이 여러 스레드를 실행할 수 있는 능력으로, 시스템 리소스를 효율적으로 활용할 수 있게 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 Markdown 형식으로 수정한 내용입니다.\n\n![image](/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_11.png)\n\n## Concurrency and parallelism\n\n![image](/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_12.png)\n\nConcurrency\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 두 개 이상의 작업이 겹치는 시간 동안 시작, 실행 및 완료될 수 있는 경우\n- 단일 쓰레드가 빠르게 전환하여 여러 작업을 처리하도록 하여 동시 실행의 환상을 주는 것\n\n병렬 처리\n\n- 둘 이상의 작업이 서로 다른 쓰레드에서 동시에 실행되는 경우\n- 두 개의 쓰레드가 실행하는 두 가지 작업\n\n![이미지](/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_13.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 비동기 처리 vs 멀티스레딩\n\n동기\n\n- 각 작업은 다음 작업이 시작되기 전에 완료되어야 합니다.\n- 한 작업이 너무 오래 걸리는 경우 비효율성을 야기할 수 있으며, 작업이 완료될 때까지 앱이 멈추거나 블로킹될 수 있습니다.\n\n작업은 순차적으로 실행됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n비동기 (단일 스레드)\n\n- 한 스레드가 여러 작업을 처리하면서 그 사이를 전환함\n- 흐름을 차단하지 않고 작업이 동시에 진행되도록 함\n\n두 작업이 같은 스레드 내에서 시작되고 동시에 진행됨\n\n비동기 (다중 스레드)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 여러 스레드가 동시에 서로 다른 작업을 처리합니다\n- 두 작업을 빠르고 효율적으로 완료합니다\n\n두 스레드를 사용하면 두 작업이 서로 독립적으로 동시에 진행됩니다\n\n![이미지](/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_14.png)\n\n## C#에서 멀티스레딩을 사용하는 장점\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n성능\n\n첫 번째 분명한 장점은 하드웨어 성능을 활용하여 작업을 병렬로 실행하여 속도를 높일 수 있다는 것입니다.\n\n응답성\n\n여러 프로세스가 동시에 실행되는 경우 데이터를 검색하기 위해 사용자가 클릭하더라도, 하나의 스레드가 데이터를 가져오는 동안 앱 전체가 반응성을 유지합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n확장성\n\n더 많은 요청을 처리하기 위해서는 각 작업에 대해 다른 스레드를 사용하여 동시에 처리하는 것이 가능합니다.\n\n## II. C#에서의 스레드\n\n이미 소개된 것처럼, 스레드는 CPU의 가장 낮은 작업 단위입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nC#은 스레드를 다루기 쉽게 만드는 라이브러리를 제공합니다: Thread 클래스입니다. 이 클래스를 사용하면 전체 스레드 라이프사이클을 관리할 수 있어요!\n\n![Thread Lifecycle](/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_15.png)\n\n## Thread Lifecycle\n\n일반적인 스레드는 다음과 같은 단계를 거칩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 스레드가 생성되었습니다\n- 스레드가 시작되었습니다\n- 스레드가 메소드를 완료했습니다\n- 스레드가 자동으로 종료되었습니다\n\n## 스레드 생성, 시작 및 일시 중지\n\n스레드를 생성하는 방법은 여러 가지가 있습니다\n\n```js\n// 새로운 스레드 생성\nvar thread = new Thread(new ThreadStart(Operation));\n\n// 또는 더 간결한 방법으로\nvar thread = new Thread(Operation);\n\n// 또는 람다를 사용하여\nvar thread = new Thread(() =\u003e { Operation(); });\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위에서 볼 수 있듯이 스레드는 인스턴스화되려면 메서드 대리자를 가져야 합니다.\n\n```js\n// 스레드는 작업(메서드 대리자)이 필요합니다\nvar thread = new Thread(Operation);\n\n// 완료해야 할 작업이 스레드 내로 전달됩니다\nprivate void Operation()\n{\n    Console.WriteLine(\"스레드에서 안녕하세요\");\n}\n```\n\n스레드가 생성되었더라도 명시적으로 시작해야 합니다.\n\n```js\n// 스레드 시작\nthread.Start();\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n한 번 시작되면 작업을 자동으로 수행하고 완료될 때까지 계속됩니다.\n\n한 번 종료된 스레드는 다시 시작할 수 없습니다.\n\n그러나 .Sleep 메서드를 사용하여 스레드를 일시 중지할 수 있습니다.\n\n시간이 경과한 후 자동으로 다시 시작됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 쓰레드를 일시 중지하고 중단하는 방법\nThread.Sleep(2000); // 밀리초나 TimeSpan을 사용합니다.\nsleepingThread.Interrupt();\n```\n\n쓰레드를 중지하는 방법에는 장단점이 있는 여러 가지 방법이 있습니다:\n\n- Join\n- Abort\n- Interrupt\n\n## Join\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nThread.Join은 스레드를 \"정상적으로\" 중지시키므로 코드는 스레드가 중지될 때까지 기다립니다.\n\n```js\nThread thread = new Thread(Work);\nthread.Start();\n\n// 스레드가 \"정상적으로\" 중지될 때까지 대기\nthread.Join();\n\nConsole.WriteLine(\"스레드가 종료되었습니다.\");\n```\n\n또한, 스레드가 완료될 때까지 무기한 대기하는 것을 피하기 위해 타임아웃을 전달하는 것도 가능합니다.\n\n```js\nThread thread = new Thread(Work);\nthread.Start();\n\n// 스레드가 중지되거나 타임아웃 시간이 경과할 때까지 대기\nbool didComplete = thread.Join(1000);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n주로 이 코드는 주 스레드가 1초 동안 대기하도록 하고 해당 스레드의 실행이 완료됐는지 확인합니다.\n\nJoin의 블로킹 특성\n\nThread.Join은 블로킹 호출이므로, 해당 스레드가 실행을 완료하거나 선택적으로 지정된 시간 제한이 경과할 때까지 반환하지 않습니다.\n\n즉, 주 스레드가 해당 스레드의 완료를 기다려야 한다는 것을 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어, Join을 현재 스레드에서 호출해서는 안 돼요.\n\n현재 스레드에서 현재 스레드에 Thread.Join을 호출하면 현재 스레드가 자기 자신을 기다리기 때문에 애플리케이션이 응답하지 않게 될 거에요.\n\n```js\nThread thread = Thread.CurrentThread;\n\n// 이렇게 하면 데드락이 발생하여 애플리케이션이 응답하지 않게 됩니다\n// thread.Join(); // 이렇게 하지 마세요\n\nConsole.WriteLine(\"현재 스레드에 Join을 호출하는 것을 피하세요.\");\n```\n\n멀티스레드 환경에서 Join\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n조인은 블로킹 호출이기 때문에 멀티스레딩(그리고 병렬) 목표에 부합하지 않아요!\n\n하지만 언제는 유용할 수도 있어요. 다른 스레드가 객체를 조작하는 하나의 스레드를 기다려야 하는 경쟁 조건에서 유용할 수 있답니다 (나중에 더 설명할게요).\n\n\u003cimg src=\"/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_16.png\" /\u003e\n\n## 중단\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n쓰레드를 강제로 미리 종료하도록 하는 ThreadAbortException이 발생합니다.\n\n그러나 스트림 연결을 닫지 않은 채로 갑작스럽게 스레드를 중지시킴으로써 메모리 누수나 리소스 누수가 발생할 수 있습니다.\n\n게다가, 스레드가 중단될 때 스레드나 조작된 객체들의 상태가 불분명합니다.\n\n이는 교착 상태, 리소스 누수 또는 메모리 누수로 이어질 수 있습니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마크다운 형식의 표 태그를 바꿔보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n인터럽트된 스레드가 Thread.Join 또는 Thread.Sleep를 호출했을 때에만 ThreadInterruptedException을 throw합니다.\n\n이는 동기화된 코드 영역에 대한 액세스를 기다리거나 Thread.Sleep 중에 스레드를 차단하는 작업을 중지하는 데 사용할 수 있습니다.\n\n```js\nThread thread = new Thread(Work);\nthread.Start();\n\n// 스레드가 시작할 시간을 줍니다\nThread.Sleep(500);\n\n// 스레드를 인터럽트하여 ThreadInterruptedException을 발생시킵니다\nthread.Interrupt();\n\n// 스레드가 인터럽션을 처리하고 완료할 때까지 기다립니다\nthread.Join();\n```\n\nThread.Interrupt는 스레드가 차단된 상태에서만 스레드를 인터럽트합니다. Thread.Sleep와 같이 현재 블로킹 호출 중인 코드가 아닌 경우엔 제3자 코드를 임의로 중단하지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nThread.Interrupt은 아직 지원되지만 CancellationToken을 사용한 협력적 취소가 더 예측 가능하고 관리하기 쉬운 스레드 중단 방법으로 자주 선호됩니다.\n\n## 스레드 취소: 스레드를 중지하는 더 좋은 방법\n\n그러나 .Net 5+부터 스레드 중단과 관련된 문제를 따라 Thread.Abort 또는 Thread.Interrupt 대신 스레드 취소를 사용하는 것을 Microsoft가 권장합니다.\n\n이 접근 방식은 스레드를 갑작스럽게 종료하는 것과 관련된 예측할 수 없는 상황 및 잠재적인 리소스 누수를 방지합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```cs\n// 취소 토큰을 인스턴스화합니다\nCancellationTokenSource cts = new CancellationTokenSource();\n\n// 스레드에 토큰 전달\nThread thread = new Thread(() =\u003e Work(cts.Token));\nThread.Start();\n\n// 주 스레드에서 다른 작업 시뮬레이션\nThread.Sleep(1000);\n\n// 1초 후 스레드 작업 취소\ncts.Cancel();\n\n// 스레드가 정상적으로 종료될 때까지 대기\nthread.Join();\n```\n\nCancellationTokenSource: 이 클래스는 취소를 신호하는 메커니즘을 제공합니다. 스레드로 전달할 수 있는 CancellationToken을 생성합니다.\n\nWork 메서드에 취소 토큰 전달\n\n```cs\nstatic void Work(CancellationToken cancellationToken)\n{\n    try\n    {\n        while (true)\n        {\n            // 취소 요청 확인\n            cancellationToken.ThrowIfCancellationRequested();\n\n            // 작업 시뮬레이션\n            Thread.Sleep(500);\n            Console.WriteLine(\"작업 중...\");\n        }\n    }\n    catch (OperationCanceledException)\n    {\n        Console.WriteLine(\"취소 요청 받음, 작업 종료.\");\n    }\n    finally\n    {\n        Console.WriteLine(\"여기 정리 코드가 있습니다.\");\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nThrowIfCancellationRequested: 이 메서드는 취소가 요청된 경우 OperationCanceledException을 throw하여 스레드가 안전하게 종료될 수 있도록합니다.\n\nCancellationToken을 사용하는 이점\n\n- 안전한 종료: 스레드는 종료하기 전에 현재 작업을 마무리하고 자원을 적절히 정리할 수 있습니다.\n- 예측 가능성: 스레드는 제어된 방식으로 종료되어 갑작스러운 종료의 위험을 피합니다.\n- 협력적인 취소: 스레드는 주기적으로 토큰을 확인하여 중지해야 하는지 여부를 확인하여 스레드 관리에 협력적인 접근이 가능합니다.\n\n현대 .NET 애플리케이션에서 스레드 라이프사이클을 관리하는 선호되는 방법은 CancellationToken을 사용하는 것입니다. 이를 통해 스레드가 예측 가능하고 안전하게 취소될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 쓰레드 관련 문제\n\n## 데드락과 경쟁 조건\n\n이미 소개된 대로, 각 쓰레드는 고유한 스택을 가지고 있지만 힙 메모리는 공유합니다.\n\n![이미지](/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_18.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여러 스레드가 하나의 공유된 값을 액세스하고 수정할 수 있다는 것을 의미합니다.\n\n이는 레이스 조건이라고 불리는 것을 일으킬 수 있습니다. 기본적으로 두 스레드가 동시에 동일한 값을 변경하는 상황입니다.\n\n![이미지 1](/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_19.png)\n\n![이미지 2](/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_20.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n요청해주신 코드 예제를 확인해보세요\n\n```js\n// 공유 변수\npublic static int i = 0;\n\npublic static void ExecuteWork()\n{\n    // 스레드가 루프를 실행\n    var t = new Thread(DoWork);\n    t.Start();\n    // 다른 스레드가 루프를 실행하면 경쟁 상태로 이어집니다\n    DoWork();\n}\n// 두 스레드가 이 메서드를 실행함\npublic static void DoWork()\n{\n    for(i = 0;i \u003c 5; i++)\n    {\n        Console.WriteLine(\"*\");\n    }\n}\n// \"******\"이 출력되어야 할 것을 5개가 아닌 6개 출력함\n```\n\n또다른 문제는 데드락인데, 이는 두 개 이상의 스레드가 영원히 차단되어 서로 다른 쓰레드가 리소스를 해제할 때를 기다리는 경우 발생합니다.\n\n데드락은 여러 스레드가 동일한 리소스 세트가 필요하고 이를 서로 다른 순서로 획득할 때 발생할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:520/0*QImExmL-baj0qzsk.gif\" /\u003e\n\n## Join과 Lock을 사용하여 경합 조건과 데드락 방지하기\n\n경합 조건을 방지하려면 다음 중 하나를 할 수 있습니다:\n\n- 스레드가 서로 기다릴 수 있도록 하기\n- 스레드를 잠그기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이전에 보았던 것처럼 `Thread.Join`을 사용하여 스레드를 대기할 수 있습니다.\n\n```js\n// 메인 스레드를 일시 중지합니다.\n// 스레드가 완료될 때까지 대기합니다.\n// 메인 스레드를 다시 실행합니다.\nthread.Join();\n\n// TimeSpan 또는 int Milliseconds도 사용할 수 있습니다.\nbool Thread.Join(TimeSpan timeout);\n```\n\n다른 방법은 `Thread.Lock` 문을 사용하는 것입니다.\n\n해당 문은 기본적으로 공유 객체를 \"잠그고\" 실행 중인 스레드만에게 액세스할 수 있도록 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n한 번 스레드가 끝나면 객체를 해제합니다.\n\n```js\nusing System;\nusing System.Threading;\n\nclass Program\n{\n// 이 객체들은 공유됩니다\n    private static readonly object lock1 = new object();\n    private static readonly object lock2 = new object();\n\n    public static void Main()\n    {\n        // 스레드 1\n        var t1 = new Thread(Thread1);\n        t1.Start();\n\n        // 스레드 2\n        var t2 = new Thread(Thread2);\n        t2.Start();\n\n        t1.Join();\n        t2.Join();\n    }\n\n    public static void Thread1()\n    {\n        lock (lock1)\n        {\n            Thread.Sleep(100); // 일부 작업 시뮬레이션\n            lock (lock2)\n            {\n                Console.WriteLine(\"Thread 1이 두 개의 락을 획득했습니다\");\n            }\n        }\n    }\n\n    public static void Thread2()\n    {\n        lock (lock2)\n        {\n            Thread.Sleep(100); // 일부 작업 시뮬레이션\n            lock (lock1)\n            {\n                Console.WriteLine(\"Thread 2가 두 개의 락을 획득했습니다\");\n            }\n        }\n    }\n}\n```\n\n## AutoResetEvent\n\nAutoResetEvent를 사용하면 스레드 간 통신을 동기화할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음은 작동 방법입니다:\n\n- AutoResetEvent를 생성합니다 =` 이벤트가 생성됨\n- 1번 스레드가 이벤트에 대해 WaitOne()을 호출합니다 =` 스레드1은 이벤트가 해제될 때까지 기다립니다\n- 2번 스레드가 작업을 수행한 후 이벤트에 대해 set()을 호출합니다 =` 스레드1이 작업을 수행할 수 있습니다\n\n```js\n   static AutoResetEvent autoResetEvent = new AutoResetEvent(false);\n\n    static void Thread1()\n    {\n        autoResetEvent.WaitOne(); // 이벤트가 신호를 받을 때까지 대기합니다\n        // 여기에서 작업을 수행합니다\n    }\n\n    static void Thread2()\n    {\n        // 일부 작업을 시뮬레이션합니다.\n        Thread.Sleep(2000); \n        autoResetEvent.Set(); // 이벤트를 신호하여 대기 중인 스레드 하나를 해제합니다\n    }\r\n```\n\n이제 스레드 간 통신이 이루어지며 서로 작업을 수행할 수 있는 시기를 신호로 알릴 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n로버스트한 통신을 위해서는 락을 피하기 위해 두 개의 AutoResetEvent와 함께 작업하는 것이 가장 좋습니다. 이렇게 하면 두 스레드가 필요할 때 Set 및 Wait를 시그널할 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_21.png)\n\n## 스레드 성능 문제\n\n새로운 스레드를 시작하는 것은 성능적으로 비용이 많이 드는데, 그 이유는 여러 가지가 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 메모리 할당\n\n새로운 스레드가 생성되면, 시스템은 해당 스레드의 스택과 스레드 제어 블록(TCB)을 위한 메모리를 할당합니다.\n\n이러한 리소스를 할당하고 초기화하는 작업은 메모리와 시간을 모두 소모합니다.\n\n- 운영 체제(OS) 오버헤드\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n각 스레드의 수명주기를 관리해야 합니다. 이러한 작업에는 CPU 사이클이 필요하며 스레드를 시작하는 오버헤드에 기여합니다.\n\n- 스레드 초기화\n\n스레드를 생성하는 것은 즉각적으로 이루어지지 않습니다. 할당된 자원을 설정하고 실행 환경을 구성하고 스케줄러에 통보하는 시간이 필요합니다.\n\n이 문제의 해결책은 스레드 풀을 사용하는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![ThreadPool](https://miro.medium.com/v2/resize:fit:720/0*9oNxhHqD2tltG8U4.gif)\n\n# IV/ The ThreadPool\n\nSystem.Threading.ThreadPool 클래스는 worker 스레드 풀을 제공합니다. 또한 스레드 풀 스레드를 사용할 수 있습니다.\n\n새 스레드를 생성하는 대신 스레드 풀을 사용하면 기존 스레드를 재사용하여 성능을 향상시킬 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기 과정이에요:\n\n- 쓰레드풀이 작업을 받음\n- 쓰레드풀이 쓰레드 할당\n- 쓰레드가 작업 실행\n- 쓰레드가 풀로 반환\n\n.NET 프레임워크는 스레드 관리를 수동으로 하지 않고도 쓰레드 풀을 사용할 수 있게 해주는 내장 ThreadPool 클래스를 제공합니다.\n\n그래서 이전에 하던 것처럼 쓰레드를 생성하는 대신 쓰레드를 쓰레드풀에 대기시키면 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nThreadPool.QueueUserWorkItem(Worker);\n\nvoid Worker()\n{\n    Console.WriteLine(\"작업이 실행되었습니다.\");\n}\n```\n\n관리되는 스레드 풀의 스레드는 백그라운드 스레드입니다.\n\n언제든지 사용 가능한 스레드, 풀의 최대 및 최소 스레드를 볼 수 있습니다. 또한 이를 설정할 수도 있습니다!\n\n```js\n// 사용 가능한 스레드 얻기\nThreadPool.GetAvailableThreads(out int workerThreads, out int completionPortThreads);\n\n// 최대 스레드 얻기\nThreadPool.GetMaxThreads(out int maxWorkerThreads, out int maxCompletionPortThreads);\n\n// 최소 스레드 얻기\nThreadPool.GetMinThreads(out int minWorkerThreads, out int minCompletionPortThreads);\n\n// 최대 스레드 설정\nThreadPool.SetMaxThreads(8, 8);\n\n// 최소 스레드 설정\nThreadPool.SetMinThreads(4, 4);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n쓰레드 풀을 사용해도 공유 데이터를 사용할 때는 여전히 쓰레드를 동기화해야 해요.\n\n# 동기화 메커니즘\n\nThread 클래스는 .NET의 동기화 기본 요소인 Mutex, Semaphore, Monitor와 원활하게 작동해요.\n\n이러한 메커니즘은 공유 리소스에 대한 액세스를 관리하고, 데이터 일관성을 보장하며 경쟁 조건을 방지하는 데 도움이 돼요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 뮤텍스\n\n뮤텍스(Mutex: mutual exclusion의 줄임말)는 한 번에 하나의 스레드만 락을 획득할 수 있는 동기화 기본 요소입니다.\n\n```js\nMutex mutex = new Mutex();\n\nfor (int i = 0; i \u003c 5; i++)\n{\n   Thread thread = new Thread(EnterCriticalSection);\n   thread.Start(i);\n}\n\nvoid EnterCriticalSection(object threadId)\n{\n  mutex.WaitOne(); // 뮤텍스 락 획득\n\n  try\n  {      \n      Thread.Sleep(1000); // 작업 시뮬레이션\n  }\n  \n  finally\n  {\n      mutex.ReleaseMutex(); // 뮤텍스 락 해제\n  }\n}\n```\n\n## 세마포어\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n세마포어는 동시에 리소스에 접근할 수 있는 스레드 수를 제한하는 동기화 기본 요소입니다.\n\n사용 가능한 리소스 수를 유지하고, 수가 0이 될 때 스레드를 차단합니다.\n\n```js\nSemaphore semaphore = new Semaphore(2, 2); // 2개의 스레드가 동시에 허용됨\n\nfor (int i = 0; i \u003c 5; i++)\n{\n    Thread thread = new Thread(EnterCriticalSection);\n    thread.Start(i);\n}\n\nstatic void EnterCriticalSection(object threadId)\n{\n    semaphore.WaitOne(); // 세마포어 획득\n    try\n    {\n        // Critical section: 공유 리소스에 액세스\n        Thread.Sleep(1000); // 작업 시뮬레이션\n    }\n    finally\n    {\n        semaphore.Release(); // 세마포어 해제\n    }\n}\n```\n\n## 모니터 (lock)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nMonitor 클래스는 C#의 lock 키워드를 사용하는 것과 유사하게 리소스에 대한 독점적 액세스 메커니즘을 제공합니다.\n\n이는 한 번에 한 스레드만 코드의 중요한 섹션을 실행할 수 있도록 보장합니다.\n\n```js\nstatic object lockObject = new object();\n\n\nfor (int i = 0; i \u003c 5; i++)\n{\n     Thread thread = new Thread(EnterCriticalSection);\n     thread.Start(i);\n    }\n }\n\nstatic void EnterCriticalSection(object threadId)\n{\n   lock (lockObject) // 락을 획득합니다.\n    {\n      Thread.Sleep(1000); // 작업 시뮬레이션\n    }\n}\n```\n\n# VI/ 스레드 관리\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## Foreground vs background thread\n\n기본적으로 .NET에서 생성된 쓰레드는 전경 스레드이므로 완료될 때까지 애플리케이션을 유지합니다.\n\n그러나 쓰레드를 백그라운드 쓰레드로 명시적으로 설정할 수 있으며, 전경 스레드가 모두 실행을 마치면 자동으로 종료됩니다.\n\n```js\n// 쓰레드를 백그라운드로 명시적으로 설정합니다.\nthread.IsBackground = true;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image](/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_22.png)\n\n## 스레드 컨텍스트\n\n스레드 컨텍스트에는 스레드가 실행을 중단하고 다시 시작할 수 있는 모든 정보가 포함되어 있습니다. 이에는 CPU 레지스터, 스택 및 기타 관련 데이터가 포함됩니다.\n\n```js\n// 스레드의 현재 상태에 대한 정보를 확인하려면 (실행 중, 백그라운드, 중지됨, 중단됨...)\n var threadState = thread.ThreadState;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 쓰레드에 데이터 전달하기\n\n람다 표현식은 쓰레드를 초기화하고 데이터를 전달하는 데 자주 사용됩니다.\n\n```js\n// 한 개의 인수만 전달 가능\nvar thread = new Thread(() =\u003e Operation(\"Hello\"));\n```\n\n```js\nprivate void Operation(string name)\n{\n    Console.WriteLine(\"쓰레드에서의 안녕\" + name);\n}\n```  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러나 race condition을 피하기 위해 공유 변수를 스레드에 전달할 때 주의해야 합니다. 상수 또는 지역 변수를 사용하는 것이 가장 좋습니다.\n\n```js\nconst string greeting = \"Hello\";\nvar thread = new Thread(() =\u003e Operation(greeting));\n```\n\n## 스레드 우선순위\n\n스레드는 실행 순서를 결정하는 서로 다른 우선순위를 가질 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더 높은 우선순위를 가진 스레드가 더 많은 CPU 시간을 받습니다. 기본 우선순위는 Normal입니다.\n\n```js\nthread.Priority = ThreadPriority.Highest;\n\n// 가능한 옵션은:\nLowest\nBelowNormal\nNormal\nAboveNormal\nHighest\n```\n\n## 스레드 로컬 스토리지\n\nThread 클래스는 ThreadLocal`T` 클래스를 사용하여 스레드 로컬 스토리지를 지원합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n각 스레드가 고유한 데이터를 가지도록하여 스레드 안전을 보장하고 데이터 손상을 방지합니다.\n\n```js\nThreadLocal\u003cint\u003e threadLocalValue = new ThreadLocal\u003cint\u003e(() =\u003e 0);\n```\n\n## 스레드 디버깅\n\n스레드에 이름을 지정하여 쉽게 디버깅할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_23.png)\n\n```js\nthread.Name = \"Bob Thread\";\n```\n\n![이미지](/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_24.png)\n\n다음과 같이 사용중인 스레드 정보를 얻을 수 있습니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nConsoleWriteLine(\"메인 스레드의 ID: \" + Thread.CurrentThread.ManagedThreadId);\n```\n\n또한 디버깅 중에는 어떤 스레드가 무엇을 수행하고 있는지 확인할 수도 있어요\n\n![이미지](/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_25.png)\n\n위 내용은 아래 창을 표시합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_26.png)\n\n# VII/ .Net에서 스레드 작업 추천 방법\n\n- Thread.Abort를 사용하지 마세요\n\n해당 스레드에 예외를 throw하는 것과 유사하게 스레드를 강제로 종료시킵니다. 대신 취소 토큰을 사용하세요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 다른 리소스를 필요로 하는 작업에는 여러 스레드를 사용하고 단일 리소스에 여러 스레드를 할당하는 것은 피하십시오.\n\nI/O 작업을 포함하는 작업은 블록을 방지하고 전체 처리량을 향상시키기 위해 각각 자체 스레드를 가지는 것이 좋습니다.\n\n마찬가지로 사용자 입력 처리와 같은 작업은 전용 스레드로 처리하는 것이 가장 좋습니다.\n\n```js\nThreadPool.QueueUserWorkItem(PerformIOOperation);\nThreadPool.QueueUserWorkItem(ProcessUserInput);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 쓰레드에서 예외를 처리하세요.\n\n쓰레드에서 처리되지 않은 예외는 일반적으로 프로세스를 종료시킵니다.\n\n```js\nThreadPool.QueueUserWorkItem(DoWork);\n\nvoid DoWork(object state)\n{\n    try\n    {\n        // 여기서 작업 수행\n    }\n    catch (Exception ex)\n    {\n        // 예외 처리\n    }\n}\n```\n\n- System.Threading.ThreadPool을 사용하여 쓰레드를 초기화하고 관리하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`System.Threading.ThreadPool` 클래스를 사용하여 스레드를 초기화하고 관리하세요. 특히 짧은 수명을 가진 작업과 비동기 작업에 유용합니다.\n\n스레드 풀은 작업자 스레드의 풀을 효율적으로 관리하여 스레드 생성 및 소멸의 부하를 줄입니다.\n\n```js\nThreadPool.QueueUserWorkItem(DoWork);\n```\n\n- 스레드 대신 작업들을 사용하세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n.NET Framework 4부터 멀티스레딩을 활용하는 권장 방법은 Task Parallel Library (TPL) 및 Parallel LINQ (PLINQ)를 사용하는 것입니다. 자세한 내용은 병렬 프로그래밍을 참조하십시오. (Microsoft)\n\n![이미지](/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_27.png)\n\n다음 블로그에서 다시 만나요! :)\n\n## 언제 스레드를 사용해야 할까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n쓰레드는 작업과 같은 고수준 추상화로는 항상 달성할 수 없는 수준의 제어와 사용자 정의를 제공합니다.\n\n쓰레드는 개발자에게 코드 실행을 저수준에서 직접 제어할 수 있는 기회를 제공합니다.\n\n이는 특정 성능 중요한 상황이나 전문화된 시나리오에서 중요할 수 있는 리소스, 스케줄링 및 동기화의 정확한 관리를 가능하게 합니다.\n\n쓰레드는 더 많은 제어와 유연성을 제공하지만 경합 조건, 데드락 및 동기화 문제와 같은 추가 복잡성과 잠재적인 함정도 동반합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n따라서, 귀하의 애플리케이션 요구 사항에 기반을 두고 상호 작용 모델을 신중히 고려하고 적절한 동시성 모델을 선택하는 것이 중요합니다.\n\n# 소스\n\n## 비동기\n\nhttps://www.udemy.com/course/ultimate-csharp-masterclass/\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 쓰레드\n\n[멀티쓰레드 C# 코드 작성 방법](https://www.udemy.com/course/how-to-write-multi-threaded-csharp-code)\n\n## .Net에서 병렬 프로그래밍","ogImage":{"url":"/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_0.png"},"coverImage":"/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_0.png","tag":["Tech"],"readingTime":21},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_0.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ch1\u003eAgenda\u003c/h1\u003e\n\u003ch2\u003eI/ Introduction\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eThreads in a Computer CPU\u003c/li\u003e\n\u003cli\u003eScheduler \u0026#x26; Time slices\u003c/li\u003e\n\u003cli\u003eProcesses \u0026#x26; Threads\u003c/li\u003e\n\u003cli\u003eConcurrency and parallelism\u003c/li\u003e\n\u003cli\u003eAsynchrony vs Multithreading\u003c/li\u003e\n\u003cli\u003eBenefits of using multithreading in C#\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eII 스레드 C#에서\u003c/h2\u003e\n\u003cp\u003e스레드 라이프사이클\n스레드 생성, 시작 및 일시 중지\nJoin\nAbort\nInterrupt\n스레드 취소: 스레드를 중지하는 더 나은 방법\u003c/p\u003e\n\u003ch2\u003eIII/ 스레드 관련 문제\u003c/h2\u003e\n\u003cp\u003e데드락과 레이스 컨디션\nJoin 및 Locks를 사용하여 레이스 컨디션 및 데드락 방지\nAutoResetEvent\n스레드 성능 문제\u003c/p\u003e\n\u003ch2\u003eIV/ 스레드 풀\u003c/h2\u003e\n\u003ch2\u003eV/ 동기화 메커니즘\u003c/h2\u003e\n\u003cp\u003eMutex\nSemaphore\nMonitor (lock)\u003c/p\u003e\n\u003ch2\u003eVI/ 스레드 관리하기\u003c/h2\u003e\n\u003cp\u003e포그라운드 대비 백그라운드 스레드\n스레드 컨텍스트\n스레드에 데이터 전달\n스레드 우선순위\n스레드 로컬 저장소\n스레드 디버깅\u003c/p\u003e\n\u003ch2\u003eVII/ .Net에서 스레드를 다루는 추천 방법\u003c/h2\u003e\n\u003ch1\u003eI/ 소개\u003c/h1\u003e\n\u003ch2\u003e컴퓨터 CPU에서의 스레드\u003c/h2\u003e\n\u003cp\u003e쓰레드(thread)와 병렬성(parallelism)에 대해 이해하기 전에, 기본적인 하드웨어 동작 원리를 잘 파악하는 것이 중요합니다.\u003c/p\u003e\n\u003cp\u003eCPU(중앙 처리 장치)는 컴퓨터의 뇌로, 애플리케이션을 실행하는 데 필요한 모든 명령을 실행하는 역할을 합니다.\u003c/p\u003e\n\u003cp\u003e현대 컴퓨터에는 종종 여러 개의 코어(core)가 있으며, 각각이 논리 프로세서(logical processor)로 분할될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e각 프로세서는 두 개의 논리 프로세서로 나눠집니다.\u003c/p\u003e\n\u003cp\u003e각 논리 코어는 이제 병렬로 여러 스레드를 처리할 수 있습니다! 예를 들어, 4코어 프로세서는 하이퍼스레딩 기술 덕분에 8개의 스레드를 동시에 처리할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e컴퓨터의 코어(core) 및 논리 코어(logical core) 수를 확인하려면 작업 관리자로 이동하여 '성능' 탭을 선택하세요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_4.png\" alt=\"Task Manager Performance\"\u003e\u003c/p\u003e\n\u003cp\u003e또는 애플리케이션에서 다음 코드를 실행해도 됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eConsole\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eWriteLine\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"코어 수: \"\u003c/span\u003e + \u003cspan class=\"hljs-title class_\"\u003eEnvironment\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eProcessorCount\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e스케줄러 및 시간 조각\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e스케줄러\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e실제로 각 코어는 많은 명령을 동시에 실행합니다.\u003c/p\u003e\n\u003cp\u003e다른 작업을 블록하는 것을 방지하기 위해 각 작업에 일정한 시간을 할당합니다.\u003c/p\u003e\n\u003cp\u003e모든 작업을 아주 빠른 속도로 전환하면, 모든 작업이 동시에 실행되는 것 같아요!\u003c/p\u003e\n\u003cp\u003e윈도우즈에서는 스케줄러라는 특별한 프로그램이 프로세서가 명령을 실행할 순서와 시간 프레임(프로세서 시간 조각이라고도 함)을 결정해요.\u003c/p\u003e\n\u003cp\u003e이 프로그램은 프로세서가 명령을 실행할 순서와 시간 프레임을 결정하는 역할을 해요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_5.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e프로세서 시간 조각\u003c/p\u003e\n\u003cp\u003e이 시간 프레임은 프로세서 시간 조각으로도 알려져 있어요.\u003c/p\u003e\n\u003cp\u003e이러한 시간 조각은 프로세서가 특정 명령을 처리하는 기간입니다. 너무 긴 명령이 전체 컴퓨터를 막는 것을 방지하기 위해 각 명령에는 특정 시간 조각이 부여됩니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_6.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch2\u003e프로세스 및 스레드\u003c/h2\u003e\n\u003cp\u003e이제 프로세스와 스레드의 차이를 살펴보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_7.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003cp\u003e프로세스는 실행 중인 프로그램입니다. 운영 체제는 실행 중인 응용 프로그램을 분리하기 위해 프로세스를 사용합니다. 스레드는 운영 체제가 프로세서 시간을 할당하는 기본 단위입니다.\u003c/p\u003e\n\u003cp\u003e프로세스\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e기본적으로 프로그램을 실행하는 인스턴스\u003c/li\u003e\n\u003cli\u003e고유한 메모리 공간과 자원을 보유합니다.\u003c/li\u003e\n\u003cli\u003e다른 프로세스와 독립적으로 작동합니다.\u003c/li\u003e\n\u003cli\u003e스레드를 하나 이상 포함할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e전형적인 시스템에는 수백 개의 프로세스가 동시에 실행될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e각 프로세스는 스레드를 포함하는 컨테이너 역할을 합니다.\u003c/p\u003e\n\u003cp\u003e프로세스가 시작되면 각각이 자체 메모리 및 리소스를 할당받아 스레드 사이에서 공유됩니다.\u003c/p\u003e\n\u003cp\u003e스레드\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e프로세스 내에서의 실행 단위\u003c/li\u003e\n\u003cli\u003e각각 자체 스택을 가짐\u003c/li\u003e\n\u003cli\u003e동일한 프로세스 내 다른 스레드와 힙 메모리를 공유함\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e다음은 Markdown 형식으로 된 표입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_9.png\" alt=\"이미지1\"\u003e\u003c/p\u003e\n\u003cp\u003e멀티 스레딩 프로세스에서 스레드는 힙 메모리를 공유합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_10.png\" alt=\"이미지2\"\u003e\u003c/p\u003e\n\u003cp\u003e멀티스레딩은 프로그램이 여러 스레드를 실행할 수 있는 능력으로, 시스템 리소스를 효율적으로 활용할 수 있게 합니다.\u003c/p\u003e\n\u003cp\u003e아래는 Markdown 형식으로 수정한 내용입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_11.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ch2\u003eConcurrency and parallelism\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_12.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003eConcurrency\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e두 개 이상의 작업이 겹치는 시간 동안 시작, 실행 및 완료될 수 있는 경우\u003c/li\u003e\n\u003cli\u003e단일 쓰레드가 빠르게 전환하여 여러 작업을 처리하도록 하여 동시 실행의 환상을 주는 것\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e병렬 처리\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e둘 이상의 작업이 서로 다른 쓰레드에서 동시에 실행되는 경우\u003c/li\u003e\n\u003cli\u003e두 개의 쓰레드가 실행하는 두 가지 작업\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_13.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch2\u003e비동기 처리 vs 멀티스레딩\u003c/h2\u003e\n\u003cp\u003e동기\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e각 작업은 다음 작업이 시작되기 전에 완료되어야 합니다.\u003c/li\u003e\n\u003cli\u003e한 작업이 너무 오래 걸리는 경우 비효율성을 야기할 수 있으며, 작업이 완료될 때까지 앱이 멈추거나 블로킹될 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e작업은 순차적으로 실행됩니다.\u003c/p\u003e\n\u003cp\u003e비동기 (단일 스레드)\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e한 스레드가 여러 작업을 처리하면서 그 사이를 전환함\u003c/li\u003e\n\u003cli\u003e흐름을 차단하지 않고 작업이 동시에 진행되도록 함\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e두 작업이 같은 스레드 내에서 시작되고 동시에 진행됨\u003c/p\u003e\n\u003cp\u003e비동기 (다중 스레드)\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e여러 스레드가 동시에 서로 다른 작업을 처리합니다\u003c/li\u003e\n\u003cli\u003e두 작업을 빠르고 효율적으로 완료합니다\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e두 스레드를 사용하면 두 작업이 서로 독립적으로 동시에 진행됩니다\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_14.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch2\u003eC#에서 멀티스레딩을 사용하는 장점\u003c/h2\u003e\n\u003cp\u003e성능\u003c/p\u003e\n\u003cp\u003e첫 번째 분명한 장점은 하드웨어 성능을 활용하여 작업을 병렬로 실행하여 속도를 높일 수 있다는 것입니다.\u003c/p\u003e\n\u003cp\u003e응답성\u003c/p\u003e\n\u003cp\u003e여러 프로세스가 동시에 실행되는 경우 데이터를 검색하기 위해 사용자가 클릭하더라도, 하나의 스레드가 데이터를 가져오는 동안 앱 전체가 반응성을 유지합니다.\u003c/p\u003e\n\u003cp\u003e확장성\u003c/p\u003e\n\u003cp\u003e더 많은 요청을 처리하기 위해서는 각 작업에 대해 다른 스레드를 사용하여 동시에 처리하는 것이 가능합니다.\u003c/p\u003e\n\u003ch2\u003eII. C#에서의 스레드\u003c/h2\u003e\n\u003cp\u003e이미 소개된 것처럼, 스레드는 CPU의 가장 낮은 작업 단위입니다.\u003c/p\u003e\n\u003cp\u003eC#은 스레드를 다루기 쉽게 만드는 라이브러리를 제공합니다: Thread 클래스입니다. 이 클래스를 사용하면 전체 스레드 라이프사이클을 관리할 수 있어요!\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_15.png\" alt=\"Thread Lifecycle\"\u003e\u003c/p\u003e\n\u003ch2\u003eThread Lifecycle\u003c/h2\u003e\n\u003cp\u003e일반적인 스레드는 다음과 같은 단계를 거칩니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e스레드가 생성되었습니다\u003c/li\u003e\n\u003cli\u003e스레드가 시작되었습니다\u003c/li\u003e\n\u003cli\u003e스레드가 메소드를 완료했습니다\u003c/li\u003e\n\u003cli\u003e스레드가 자동으로 종료되었습니다\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e스레드 생성, 시작 및 일시 중지\u003c/h2\u003e\n\u003cp\u003e스레드를 생성하는 방법은 여러 가지가 있습니다\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 새로운 스레드 생성\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e thread = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eThread\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eThreadStart\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eOperation\u003c/span\u003e));\n\n\u003cspan class=\"hljs-comment\"\u003e// 또는 더 간결한 방법으로\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e thread = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eThread\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eOperation\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// 또는 람다를 사용하여\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e thread = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eThread\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eOperation\u003c/span\u003e(); });\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위에서 볼 수 있듯이 스레드는 인스턴스화되려면 메서드 대리자를 가져야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 스레드는 작업(메서드 대리자)이 필요합니다\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e thread = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eThread\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eOperation\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// 완료해야 할 작업이 스레드 내로 전달됩니다\u003c/span\u003e\nprivate \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eOperation\u003c/span\u003e()\n{\n    \u003cspan class=\"hljs-title class_\"\u003eConsole\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eWriteLine\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"스레드에서 안녕하세요\"\u003c/span\u003e);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e스레드가 생성되었더라도 명시적으로 시작해야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 스레드 시작\u003c/span\u003e\nthread.\u003cspan class=\"hljs-title class_\"\u003eStart\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e한 번 시작되면 작업을 자동으로 수행하고 완료될 때까지 계속됩니다.\u003c/p\u003e\n\u003cp\u003e한 번 종료된 스레드는 다시 시작할 수 없습니다.\u003c/p\u003e\n\u003cp\u003e그러나 .Sleep 메서드를 사용하여 스레드를 일시 중지할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e시간이 경과한 후 자동으로 다시 시작됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 쓰레드를 일시 중지하고 중단하는 방법\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eThread\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eSleep\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2000\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 밀리초나 TimeSpan을 사용합니다.\u003c/span\u003e\nsleepingThread.\u003cspan class=\"hljs-title class_\"\u003eInterrupt\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e쓰레드를 중지하는 방법에는 장단점이 있는 여러 가지 방법이 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eJoin\u003c/li\u003e\n\u003cli\u003eAbort\u003c/li\u003e\n\u003cli\u003eInterrupt\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eJoin\u003c/h2\u003e\n\u003cp\u003eThread.Join은 스레드를 \"정상적으로\" 중지시키므로 코드는 스레드가 중지될 때까지 기다립니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eThread\u003c/span\u003e thread = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eThread\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eWork\u003c/span\u003e);\nthread.\u003cspan class=\"hljs-title class_\"\u003eStart\u003c/span\u003e();\n\n\u003cspan class=\"hljs-comment\"\u003e// 스레드가 \"정상적으로\" 중지될 때까지 대기\u003c/span\u003e\nthread.\u003cspan class=\"hljs-title class_\"\u003eJoin\u003c/span\u003e();\n\n\u003cspan class=\"hljs-title class_\"\u003eConsole\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eWriteLine\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"스레드가 종료되었습니다.\"\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e또한, 스레드가 완료될 때까지 무기한 대기하는 것을 피하기 위해 타임아웃을 전달하는 것도 가능합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eThread\u003c/span\u003e thread = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eThread\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eWork\u003c/span\u003e);\nthread.\u003cspan class=\"hljs-title class_\"\u003eStart\u003c/span\u003e();\n\n\u003cspan class=\"hljs-comment\"\u003e// 스레드가 중지되거나 타임아웃 시간이 경과할 때까지 대기\u003c/span\u003e\nbool didComplete = thread.\u003cspan class=\"hljs-title class_\"\u003eJoin\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e주로 이 코드는 주 스레드가 1초 동안 대기하도록 하고 해당 스레드의 실행이 완료됐는지 확인합니다.\u003c/p\u003e\n\u003cp\u003eJoin의 블로킹 특성\u003c/p\u003e\n\u003cp\u003eThread.Join은 블로킹 호출이므로, 해당 스레드가 실행을 완료하거나 선택적으로 지정된 시간 제한이 경과할 때까지 반환하지 않습니다.\u003c/p\u003e\n\u003cp\u003e즉, 주 스레드가 해당 스레드의 완료를 기다려야 한다는 것을 의미합니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, Join을 현재 스레드에서 호출해서는 안 돼요.\u003c/p\u003e\n\u003cp\u003e현재 스레드에서 현재 스레드에 Thread.Join을 호출하면 현재 스레드가 자기 자신을 기다리기 때문에 애플리케이션이 응답하지 않게 될 거에요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eThread\u003c/span\u003e thread = \u003cspan class=\"hljs-title class_\"\u003eThread\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eCurrentThread\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e// 이렇게 하면 데드락이 발생하여 애플리케이션이 응답하지 않게 됩니다\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// thread.Join(); // 이렇게 하지 마세요\u003c/span\u003e\n\n\u003cspan class=\"hljs-title class_\"\u003eConsole\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eWriteLine\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"현재 스레드에 Join을 호출하는 것을 피하세요.\"\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e멀티스레드 환경에서 Join\u003c/p\u003e\n\u003cp\u003e조인은 블로킹 호출이기 때문에 멀티스레딩(그리고 병렬) 목표에 부합하지 않아요!\u003c/p\u003e\n\u003cp\u003e하지만 언제는 유용할 수도 있어요. 다른 스레드가 객체를 조작하는 하나의 스레드를 기다려야 하는 경쟁 조건에서 유용할 수 있답니다 (나중에 더 설명할게요).\u003c/p\u003e\n\u003ch2\u003e중단\u003c/h2\u003e\n\u003cp\u003e쓰레드를 강제로 미리 종료하도록 하는 ThreadAbortException이 발생합니다.\u003c/p\u003e\n\u003cp\u003e그러나 스트림 연결을 닫지 않은 채로 갑작스럽게 스레드를 중지시킴으로써 메모리 누수나 리소스 누수가 발생할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e게다가, 스레드가 중단될 때 스레드나 조작된 객체들의 상태가 불분명합니다.\u003c/p\u003e\n\u003cp\u003e이는 교착 상태, 리소스 누수 또는 메모리 누수로 이어질 수 있습니다!\u003c/p\u003e\n\u003cp\u003e마크다운 형식의 표 태그를 바꿔보세요.\u003c/p\u003e\n\u003cp\u003e인터럽트된 스레드가 Thread.Join 또는 Thread.Sleep를 호출했을 때에만 ThreadInterruptedException을 throw합니다.\u003c/p\u003e\n\u003cp\u003e이는 동기화된 코드 영역에 대한 액세스를 기다리거나 Thread.Sleep 중에 스레드를 차단하는 작업을 중지하는 데 사용할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eThread\u003c/span\u003e thread = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eThread\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eWork\u003c/span\u003e);\nthread.\u003cspan class=\"hljs-title class_\"\u003eStart\u003c/span\u003e();\n\n\u003cspan class=\"hljs-comment\"\u003e// 스레드가 시작할 시간을 줍니다\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eThread\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eSleep\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e500\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// 스레드를 인터럽트하여 ThreadInterruptedException을 발생시킵니다\u003c/span\u003e\nthread.\u003cspan class=\"hljs-title class_\"\u003eInterrupt\u003c/span\u003e();\n\n\u003cspan class=\"hljs-comment\"\u003e// 스레드가 인터럽션을 처리하고 완료할 때까지 기다립니다\u003c/span\u003e\nthread.\u003cspan class=\"hljs-title class_\"\u003eJoin\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThread.Interrupt는 스레드가 차단된 상태에서만 스레드를 인터럽트합니다. Thread.Sleep와 같이 현재 블로킹 호출 중인 코드가 아닌 경우엔 제3자 코드를 임의로 중단하지 않습니다.\u003c/p\u003e\n\u003cp\u003eThread.Interrupt은 아직 지원되지만 CancellationToken을 사용한 협력적 취소가 더 예측 가능하고 관리하기 쉬운 스레드 중단 방법으로 자주 선호됩니다.\u003c/p\u003e\n\u003ch2\u003e스레드 취소: 스레드를 중지하는 더 좋은 방법\u003c/h2\u003e\n\u003cp\u003e그러나 .Net 5+부터 스레드 중단과 관련된 문제를 따라 Thread.Abort 또는 Thread.Interrupt 대신 스레드 취소를 사용하는 것을 Microsoft가 권장합니다.\u003c/p\u003e\n\u003cp\u003e이 접근 방식은 스레드를 갑작스럽게 종료하는 것과 관련된 예측할 수 없는 상황 및 잠재적인 리소스 누수를 방지합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-cs\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 취소 토큰을 인스턴스화합니다\u003c/span\u003e\nCancellationTokenSource cts = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e CancellationTokenSource();\n\n\u003cspan class=\"hljs-comment\"\u003e// 스레드에 토큰 전달\u003c/span\u003e\nThread thread = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e Thread(() =\u003e Work(cts.Token));\nThread.Start();\n\n\u003cspan class=\"hljs-comment\"\u003e// 주 스레드에서 다른 작업 시뮬레이션\u003c/span\u003e\nThread.Sleep(\u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// 1초 후 스레드 작업 취소\u003c/span\u003e\ncts.Cancel();\n\n\u003cspan class=\"hljs-comment\"\u003e// 스레드가 정상적으로 종료될 때까지 대기\u003c/span\u003e\nthread.Join();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCancellationTokenSource: 이 클래스는 취소를 신호하는 메커니즘을 제공합니다. 스레드로 전달할 수 있는 CancellationToken을 생성합니다.\u003c/p\u003e\n\u003cp\u003eWork 메서드에 취소 토큰 전달\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-cs\"\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eWork\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eCancellationToken cancellationToken\u003c/span\u003e)\u003c/span\u003e\n{\n    \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e\n    {\n        \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (\u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e)\n        {\n            \u003cspan class=\"hljs-comment\"\u003e// 취소 요청 확인\u003c/span\u003e\n            cancellationToken.ThrowIfCancellationRequested();\n\n            \u003cspan class=\"hljs-comment\"\u003e// 작업 시뮬레이션\u003c/span\u003e\n            Thread.Sleep(\u003cspan class=\"hljs-number\"\u003e500\u003c/span\u003e);\n            Console.WriteLine(\u003cspan class=\"hljs-string\"\u003e\"작업 중...\"\u003c/span\u003e);\n        }\n    }\n    \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (OperationCanceledException)\n    {\n        Console.WriteLine(\u003cspan class=\"hljs-string\"\u003e\"취소 요청 받음, 작업 종료.\"\u003c/span\u003e);\n    }\n    \u003cspan class=\"hljs-keyword\"\u003efinally\u003c/span\u003e\n    {\n        Console.WriteLine(\u003cspan class=\"hljs-string\"\u003e\"여기 정리 코드가 있습니다.\"\u003c/span\u003e);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThrowIfCancellationRequested: 이 메서드는 취소가 요청된 경우 OperationCanceledException을 throw하여 스레드가 안전하게 종료될 수 있도록합니다.\u003c/p\u003e\n\u003cp\u003eCancellationToken을 사용하는 이점\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e안전한 종료: 스레드는 종료하기 전에 현재 작업을 마무리하고 자원을 적절히 정리할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e예측 가능성: 스레드는 제어된 방식으로 종료되어 갑작스러운 종료의 위험을 피합니다.\u003c/li\u003e\n\u003cli\u003e협력적인 취소: 스레드는 주기적으로 토큰을 확인하여 중지해야 하는지 여부를 확인하여 스레드 관리에 협력적인 접근이 가능합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e현대 .NET 애플리케이션에서 스레드 라이프사이클을 관리하는 선호되는 방법은 CancellationToken을 사용하는 것입니다. 이를 통해 스레드가 예측 가능하고 안전하게 취소될 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e쓰레드 관련 문제\u003c/h1\u003e\n\u003ch2\u003e데드락과 경쟁 조건\u003c/h2\u003e\n\u003cp\u003e이미 소개된 대로, 각 쓰레드는 고유한 스택을 가지고 있지만 힙 메모리는 공유합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_18.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e여러 스레드가 하나의 공유된 값을 액세스하고 수정할 수 있다는 것을 의미합니다.\u003c/p\u003e\n\u003cp\u003e이는 레이스 조건이라고 불리는 것을 일으킬 수 있습니다. 기본적으로 두 스레드가 동시에 동일한 값을 변경하는 상황입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_19.png\" alt=\"이미지 1\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_20.png\" alt=\"이미지 2\"\u003e\u003c/p\u003e\n\u003cp\u003e요청해주신 코드 예제를 확인해보세요\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 공유 변수\u003c/span\u003e\npublic \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e int i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n\npublic \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eExecuteWork\u003c/span\u003e()\n{\n    \u003cspan class=\"hljs-comment\"\u003e// 스레드가 루프를 실행\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e t = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eThread\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eDoWork\u003c/span\u003e);\n    t.\u003cspan class=\"hljs-title class_\"\u003eStart\u003c/span\u003e();\n    \u003cspan class=\"hljs-comment\"\u003e// 다른 스레드가 루프를 실행하면 경쟁 상태로 이어집니다\u003c/span\u003e\n    \u003cspan class=\"hljs-title class_\"\u003eDoWork\u003c/span\u003e();\n}\n\u003cspan class=\"hljs-comment\"\u003e// 두 스레드가 이 메서드를 실행함\u003c/span\u003e\npublic \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDoWork\u003c/span\u003e()\n{\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e(i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;i \u0026#x3C; \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e; i++)\n    {\n        \u003cspan class=\"hljs-title class_\"\u003eConsole\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eWriteLine\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"*\"\u003c/span\u003e);\n    }\n}\n\u003cspan class=\"hljs-comment\"\u003e// \"******\"이 출력되어야 할 것을 5개가 아닌 6개 출력함\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e또다른 문제는 데드락인데, 이는 두 개 이상의 스레드가 영원히 차단되어 서로 다른 쓰레드가 리소스를 해제할 때를 기다리는 경우 발생합니다.\u003c/p\u003e\n\u003cp\u003e데드락은 여러 스레드가 동일한 리소스 세트가 필요하고 이를 서로 다른 순서로 획득할 때 발생할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003eJoin과 Lock을 사용하여 경합 조건과 데드락 방지하기\u003c/h2\u003e\n\u003cp\u003e경합 조건을 방지하려면 다음 중 하나를 할 수 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e스레드가 서로 기다릴 수 있도록 하기\u003c/li\u003e\n\u003cli\u003e스레드를 잠그기\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이전에 보았던 것처럼 \u003ccode\u003eThread.Join\u003c/code\u003e을 사용하여 스레드를 대기할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 메인 스레드를 일시 중지합니다.\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 스레드가 완료될 때까지 대기합니다.\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 메인 스레드를 다시 실행합니다.\u003c/span\u003e\nthread.\u003cspan class=\"hljs-title class_\"\u003eJoin\u003c/span\u003e();\n\n\u003cspan class=\"hljs-comment\"\u003e// TimeSpan 또는 int Milliseconds도 사용할 수 있습니다.\u003c/span\u003e\nbool \u003cspan class=\"hljs-title class_\"\u003eThread\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eJoin\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eTimeSpan\u003c/span\u003e timeout);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다른 방법은 \u003ccode\u003eThread.Lock\u003c/code\u003e 문을 사용하는 것입니다.\u003c/p\u003e\n\u003cp\u003e해당 문은 기본적으로 공유 객체를 \"잠그고\" 실행 중인 스레드만에게 액세스할 수 있도록 합니다.\u003c/p\u003e\n\u003cp\u003e한 번 스레드가 끝나면 객체를 해제합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eusing \u003cspan class=\"hljs-title class_\"\u003eSystem\u003c/span\u003e;\nusing \u003cspan class=\"hljs-title class_\"\u003eSystem\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eThreading\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eProgram\u003c/span\u003e\n{\n\u003cspan class=\"hljs-comment\"\u003e// 이 객체들은 공유됩니다\u003c/span\u003e\n    private \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e readonly object lock1 = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eobject\u003c/span\u003e();\n    private \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e readonly object lock2 = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eobject\u003c/span\u003e();\n\n    public \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMain\u003c/span\u003e()\n    {\n        \u003cspan class=\"hljs-comment\"\u003e// 스레드 1\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e t1 = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eThread\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eThread1\u003c/span\u003e);\n        t1.\u003cspan class=\"hljs-title class_\"\u003eStart\u003c/span\u003e();\n\n        \u003cspan class=\"hljs-comment\"\u003e// 스레드 2\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e t2 = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eThread\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eThread2\u003c/span\u003e);\n        t2.\u003cspan class=\"hljs-title class_\"\u003eStart\u003c/span\u003e();\n\n        t1.\u003cspan class=\"hljs-title class_\"\u003eJoin\u003c/span\u003e();\n        t2.\u003cspan class=\"hljs-title class_\"\u003eJoin\u003c/span\u003e();\n    }\n\n    public \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eThread1\u003c/span\u003e()\n    {\n        lock (lock1)\n        {\n            \u003cspan class=\"hljs-title class_\"\u003eThread\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eSleep\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 일부 작업 시뮬레이션\u003c/span\u003e\n            lock (lock2)\n            {\n                \u003cspan class=\"hljs-title class_\"\u003eConsole\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eWriteLine\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Thread 1이 두 개의 락을 획득했습니다\"\u003c/span\u003e);\n            }\n        }\n    }\n\n    public \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eThread2\u003c/span\u003e()\n    {\n        lock (lock2)\n        {\n            \u003cspan class=\"hljs-title class_\"\u003eThread\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eSleep\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 일부 작업 시뮬레이션\u003c/span\u003e\n            lock (lock1)\n            {\n                \u003cspan class=\"hljs-title class_\"\u003eConsole\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eWriteLine\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Thread 2가 두 개의 락을 획득했습니다\"\u003c/span\u003e);\n            }\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eAutoResetEvent\u003c/h2\u003e\n\u003cp\u003eAutoResetEvent를 사용하면 스레드 간 통신을 동기화할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e다음은 작동 방법입니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAutoResetEvent를 생성합니다 =` 이벤트가 생성됨\u003c/li\u003e\n\u003cli\u003e1번 스레드가 이벤트에 대해 WaitOne()을 호출합니다 =` 스레드1은 이벤트가 해제될 때까지 기다립니다\u003c/li\u003e\n\u003cli\u003e2번 스레드가 작업을 수행한 후 이벤트에 대해 set()을 호출합니다 =` 스레드1이 작업을 수행할 수 있습니다\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e   \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAutoResetEvent\u003c/span\u003e autoResetEvent = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAutoResetEvent\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n\n    \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eThread1\u003c/span\u003e()\n    {\n        autoResetEvent.\u003cspan class=\"hljs-title class_\"\u003eWaitOne\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// 이벤트가 신호를 받을 때까지 대기합니다\u003c/span\u003e\n        \u003cspan class=\"hljs-comment\"\u003e// 여기에서 작업을 수행합니다\u003c/span\u003e\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eThread2\u003c/span\u003e()\n    {\n        \u003cspan class=\"hljs-comment\"\u003e// 일부 작업을 시뮬레이션합니다.\u003c/span\u003e\n        \u003cspan class=\"hljs-title class_\"\u003eThread\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eSleep\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2000\u003c/span\u003e); \n        autoResetEvent.\u003cspan class=\"hljs-title class_\"\u003eSet\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// 이벤트를 신호하여 대기 중인 스레드 하나를 해제합니다\u003c/span\u003e\n    }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 스레드 간 통신이 이루어지며 서로 작업을 수행할 수 있는 시기를 신호로 알릴 수 있습니다.\u003c/p\u003e\n\u003cp\u003e로버스트한 통신을 위해서는 락을 피하기 위해 두 개의 AutoResetEvent와 함께 작업하는 것이 가장 좋습니다. 이렇게 하면 두 스레드가 필요할 때 Set 및 Wait를 시그널할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_21.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch2\u003e스레드 성능 문제\u003c/h2\u003e\n\u003cp\u003e새로운 스레드를 시작하는 것은 성능적으로 비용이 많이 드는데, 그 이유는 여러 가지가 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e메모리 할당\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e새로운 스레드가 생성되면, 시스템은 해당 스레드의 스택과 스레드 제어 블록(TCB)을 위한 메모리를 할당합니다.\u003c/p\u003e\n\u003cp\u003e이러한 리소스를 할당하고 초기화하는 작업은 메모리와 시간을 모두 소모합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e운영 체제(OS) 오버헤드\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e각 스레드의 수명주기를 관리해야 합니다. 이러한 작업에는 CPU 사이클이 필요하며 스레드를 시작하는 오버헤드에 기여합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e스레드 초기화\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e스레드를 생성하는 것은 즉각적으로 이루어지지 않습니다. 할당된 자원을 설정하고 실행 환경을 구성하고 스케줄러에 통보하는 시간이 필요합니다.\u003c/p\u003e\n\u003cp\u003e이 문제의 해결책은 스레드 풀을 사용하는 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:720/0*9oNxhHqD2tltG8U4.gif\" alt=\"ThreadPool\"\u003e\u003c/p\u003e\n\u003ch1\u003eIV/ The ThreadPool\u003c/h1\u003e\n\u003cp\u003eSystem.Threading.ThreadPool 클래스는 worker 스레드 풀을 제공합니다. 또한 스레드 풀 스레드를 사용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e새 스레드를 생성하는 대신 스레드 풀을 사용하면 기존 스레드를 재사용하여 성능을 향상시킬 수 있습니다.\u003c/p\u003e\n\u003cp\u003e여기 과정이에요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e쓰레드풀이 작업을 받음\u003c/li\u003e\n\u003cli\u003e쓰레드풀이 쓰레드 할당\u003c/li\u003e\n\u003cli\u003e쓰레드가 작업 실행\u003c/li\u003e\n\u003cli\u003e쓰레드가 풀로 반환\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e.NET 프레임워크는 스레드 관리를 수동으로 하지 않고도 쓰레드 풀을 사용할 수 있게 해주는 내장 ThreadPool 클래스를 제공합니다.\u003c/p\u003e\n\u003cp\u003e그래서 이전에 하던 것처럼 쓰레드를 생성하는 대신 쓰레드를 쓰레드풀에 대기시키면 됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eThreadPool\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eQueueUserWorkItem\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eWorker\u003c/span\u003e);\n\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eWorker\u003c/span\u003e()\n{\n    \u003cspan class=\"hljs-title class_\"\u003eConsole\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eWriteLine\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"작업이 실행되었습니다.\"\u003c/span\u003e);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e관리되는 스레드 풀의 스레드는 백그라운드 스레드입니다.\u003c/p\u003e\n\u003cp\u003e언제든지 사용 가능한 스레드, 풀의 최대 및 최소 스레드를 볼 수 있습니다. 또한 이를 설정할 수도 있습니다!\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 사용 가능한 스레드 얻기\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eThreadPool\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eGetAvailableThreads\u003c/span\u003e(out int workerThreads, out int completionPortThreads);\n\n\u003cspan class=\"hljs-comment\"\u003e// 최대 스레드 얻기\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eThreadPool\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eGetMaxThreads\u003c/span\u003e(out int maxWorkerThreads, out int maxCompletionPortThreads);\n\n\u003cspan class=\"hljs-comment\"\u003e// 최소 스레드 얻기\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eThreadPool\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eGetMinThreads\u003c/span\u003e(out int minWorkerThreads, out int minCompletionPortThreads);\n\n\u003cspan class=\"hljs-comment\"\u003e// 최대 스레드 설정\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eThreadPool\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eSetMaxThreads\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// 최소 스레드 설정\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eThreadPool\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eSetMinThreads\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e쓰레드 풀을 사용해도 공유 데이터를 사용할 때는 여전히 쓰레드를 동기화해야 해요.\u003c/p\u003e\n\u003ch1\u003e동기화 메커니즘\u003c/h1\u003e\n\u003cp\u003eThread 클래스는 .NET의 동기화 기본 요소인 Mutex, Semaphore, Monitor와 원활하게 작동해요.\u003c/p\u003e\n\u003cp\u003e이러한 메커니즘은 공유 리소스에 대한 액세스를 관리하고, 데이터 일관성을 보장하며 경쟁 조건을 방지하는 데 도움이 돼요.\u003c/p\u003e\n\u003ch2\u003e뮤텍스\u003c/h2\u003e\n\u003cp\u003e뮤텍스(Mutex: mutual exclusion의 줄임말)는 한 번에 하나의 스레드만 락을 획득할 수 있는 동기화 기본 요소입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eMutex\u003c/span\u003e mutex = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMutex\u003c/span\u003e();\n\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (int i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; i \u0026#x3C; \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e; i++)\n{\n   \u003cspan class=\"hljs-title class_\"\u003eThread\u003c/span\u003e thread = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eThread\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eEnterCriticalSection\u003c/span\u003e);\n   thread.\u003cspan class=\"hljs-title class_\"\u003eStart\u003c/span\u003e(i);\n}\n\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eEnterCriticalSection\u003c/span\u003e(object threadId)\n{\n  mutex.\u003cspan class=\"hljs-title class_\"\u003eWaitOne\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// 뮤텍스 락 획득\u003c/span\u003e\n\n  \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e\n  {      \n      \u003cspan class=\"hljs-title class_\"\u003eThread\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eSleep\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 작업 시뮬레이션\u003c/span\u003e\n  }\n  \n  \u003cspan class=\"hljs-keyword\"\u003efinally\u003c/span\u003e\n  {\n      mutex.\u003cspan class=\"hljs-title class_\"\u003eReleaseMutex\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// 뮤텍스 락 해제\u003c/span\u003e\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e세마포어\u003c/h2\u003e\n\u003cp\u003e세마포어는 동시에 리소스에 접근할 수 있는 스레드 수를 제한하는 동기화 기본 요소입니다.\u003c/p\u003e\n\u003cp\u003e사용 가능한 리소스 수를 유지하고, 수가 0이 될 때 스레드를 차단합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eSemaphore\u003c/span\u003e semaphore = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSemaphore\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 2개의 스레드가 동시에 허용됨\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (int i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; i \u0026#x3C; \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e; i++)\n{\n    \u003cspan class=\"hljs-title class_\"\u003eThread\u003c/span\u003e thread = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eThread\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eEnterCriticalSection\u003c/span\u003e);\n    thread.\u003cspan class=\"hljs-title class_\"\u003eStart\u003c/span\u003e(i);\n}\n\n\u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eEnterCriticalSection\u003c/span\u003e(object threadId)\n{\n    semaphore.\u003cspan class=\"hljs-title class_\"\u003eWaitOne\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// 세마포어 획득\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e\n    {\n        \u003cspan class=\"hljs-comment\"\u003e// Critical section: 공유 리소스에 액세스\u003c/span\u003e\n        \u003cspan class=\"hljs-title class_\"\u003eThread\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eSleep\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 작업 시뮬레이션\u003c/span\u003e\n    }\n    \u003cspan class=\"hljs-keyword\"\u003efinally\u003c/span\u003e\n    {\n        semaphore.\u003cspan class=\"hljs-title class_\"\u003eRelease\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// 세마포어 해제\u003c/span\u003e\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e모니터 (lock)\u003c/h2\u003e\n\u003cp\u003eMonitor 클래스는 C#의 lock 키워드를 사용하는 것과 유사하게 리소스에 대한 독점적 액세스 메커니즘을 제공합니다.\u003c/p\u003e\n\u003cp\u003e이는 한 번에 한 스레드만 코드의 중요한 섹션을 실행할 수 있도록 보장합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e object lockObject = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eobject\u003c/span\u003e();\n\n\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (int i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; i \u0026#x3C; \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e; i++)\n{\n     \u003cspan class=\"hljs-title class_\"\u003eThread\u003c/span\u003e thread = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eThread\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eEnterCriticalSection\u003c/span\u003e);\n     thread.\u003cspan class=\"hljs-title class_\"\u003eStart\u003c/span\u003e(i);\n    }\n }\n\n\u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eEnterCriticalSection\u003c/span\u003e(object threadId)\n{\n   lock (lockObject) \u003cspan class=\"hljs-comment\"\u003e// 락을 획득합니다.\u003c/span\u003e\n    {\n      \u003cspan class=\"hljs-title class_\"\u003eThread\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eSleep\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 작업 시뮬레이션\u003c/span\u003e\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003eVI/ 스레드 관리\u003c/h1\u003e\n\u003ch2\u003eForeground vs background thread\u003c/h2\u003e\n\u003cp\u003e기본적으로 .NET에서 생성된 쓰레드는 전경 스레드이므로 완료될 때까지 애플리케이션을 유지합니다.\u003c/p\u003e\n\u003cp\u003e그러나 쓰레드를 백그라운드 쓰레드로 명시적으로 설정할 수 있으며, 전경 스레드가 모두 실행을 마치면 자동으로 종료됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 쓰레드를 백그라운드로 명시적으로 설정합니다.\u003c/span\u003e\nthread.\u003cspan class=\"hljs-property\"\u003eIsBackground\u003c/span\u003e = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_22.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003ch2\u003e스레드 컨텍스트\u003c/h2\u003e\n\u003cp\u003e스레드 컨텍스트에는 스레드가 실행을 중단하고 다시 시작할 수 있는 모든 정보가 포함되어 있습니다. 이에는 CPU 레지스터, 스택 및 기타 관련 데이터가 포함됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 스레드의 현재 상태에 대한 정보를 확인하려면 (실행 중, 백그라운드, 중지됨, 중단됨...)\u003c/span\u003e\n \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e threadState = thread.\u003cspan class=\"hljs-property\"\u003eThreadState\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e쓰레드에 데이터 전달하기\u003c/h2\u003e\n\u003cp\u003e람다 표현식은 쓰레드를 초기화하고 데이터를 전달하는 데 자주 사용됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 한 개의 인수만 전달 가능\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e thread = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eThread\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eOperation\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Hello\"\u003c/span\u003e));\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eprivate \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eOperation\u003c/span\u003e(string name)\n{\n    \u003cspan class=\"hljs-title class_\"\u003eConsole\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eWriteLine\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"쓰레드에서의 안녕\"\u003c/span\u003e + name);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그러나 race condition을 피하기 위해 공유 변수를 스레드에 전달할 때 주의해야 합니다. 상수 또는 지역 변수를 사용하는 것이 가장 좋습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e string greeting = \u003cspan class=\"hljs-string\"\u003e\"Hello\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e thread = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eThread\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eOperation\u003c/span\u003e(greeting));\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e스레드 우선순위\u003c/h2\u003e\n\u003cp\u003e스레드는 실행 순서를 결정하는 서로 다른 우선순위를 가질 수 있습니다.\u003c/p\u003e\n\u003cp\u003e더 높은 우선순위를 가진 스레드가 더 많은 CPU 시간을 받습니다. 기본 우선순위는 Normal입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ethread.\u003cspan class=\"hljs-property\"\u003ePriority\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eThreadPriority\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eHighest\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e// 가능한 옵션은:\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eLowest\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eBelowNormal\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eNormal\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eAboveNormal\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eHighest\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e스레드 로컬 스토리지\u003c/h2\u003e\n\u003cp\u003eThread 클래스는 ThreadLocal\u003ccode\u003eT\u003c/code\u003e 클래스를 사용하여 스레드 로컬 스토리지를 지원합니다.\u003c/p\u003e\n\u003cp\u003e각 스레드가 고유한 데이터를 가지도록하여 스레드 안전을 보장하고 데이터 손상을 방지합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eThreadLocal\u003c/span\u003e\u0026#x3C;int\u003e threadLocalValue = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eThreadLocal\u003c/span\u003e\u0026#x3C;int\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e스레드 디버깅\u003c/h2\u003e\n\u003cp\u003e스레드에 이름을 지정하여 쉽게 디버깅할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_23.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ethread.\u003cspan class=\"hljs-property\"\u003eName\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"Bob Thread\"\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_24.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e다음과 같이 사용중인 스레드 정보를 얻을 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eConsoleWriteLine\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"메인 스레드의 ID: \"\u003c/span\u003e + \u003cspan class=\"hljs-title class_\"\u003eThread\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eCurrentThread\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eManagedThreadId\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e또한 디버깅 중에는 어떤 스레드가 무엇을 수행하고 있는지 확인할 수도 있어요\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_25.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e위 내용은 아래 창을 표시합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_26.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch1\u003eVII/ .Net에서 스레드 작업 추천 방법\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eThread.Abort를 사용하지 마세요\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e해당 스레드에 예외를 throw하는 것과 유사하게 스레드를 강제로 종료시킵니다. 대신 취소 토큰을 사용하세요.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e다른 리소스를 필요로 하는 작업에는 여러 스레드를 사용하고 단일 리소스에 여러 스레드를 할당하는 것은 피하십시오.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI/O 작업을 포함하는 작업은 블록을 방지하고 전체 처리량을 향상시키기 위해 각각 자체 스레드를 가지는 것이 좋습니다.\u003c/p\u003e\n\u003cp\u003e마찬가지로 사용자 입력 처리와 같은 작업은 전용 스레드로 처리하는 것이 가장 좋습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eThreadPool\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eQueueUserWorkItem\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003ePerformIOOperation\u003c/span\u003e);\n\u003cspan class=\"hljs-title class_\"\u003eThreadPool\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eQueueUserWorkItem\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eProcessUserInput\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e쓰레드에서 예외를 처리하세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e쓰레드에서 처리되지 않은 예외는 일반적으로 프로세스를 종료시킵니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eThreadPool\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eQueueUserWorkItem\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eDoWork\u003c/span\u003e);\n\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDoWork\u003c/span\u003e(object state)\n{\n    \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e\n    {\n        \u003cspan class=\"hljs-comment\"\u003e// 여기서 작업 수행\u003c/span\u003e\n    }\n    \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (\u003cspan class=\"hljs-title class_\"\u003eException\u003c/span\u003e ex)\n    {\n        \u003cspan class=\"hljs-comment\"\u003e// 예외 처리\u003c/span\u003e\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eSystem.Threading.ThreadPool을 사용하여 쓰레드를 초기화하고 관리하세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003eSystem.Threading.ThreadPool\u003c/code\u003e 클래스를 사용하여 스레드를 초기화하고 관리하세요. 특히 짧은 수명을 가진 작업과 비동기 작업에 유용합니다.\u003c/p\u003e\n\u003cp\u003e스레드 풀은 작업자 스레드의 풀을 효율적으로 관리하여 스레드 생성 및 소멸의 부하를 줄입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eThreadPool\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eQueueUserWorkItem\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eDoWork\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e스레드 대신 작업들을 사용하세요!\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e.NET Framework 4부터 멀티스레딩을 활용하는 권장 방법은 Task Parallel Library (TPL) 및 Parallel LINQ (PLINQ)를 사용하는 것입니다. 자세한 내용은 병렬 프로그래밍을 참조하십시오. (Microsoft)\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-MultithreadinginCNetIntroductionandBestpractices_27.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e다음 블로그에서 다시 만나요! :)\u003c/p\u003e\n\u003ch2\u003e언제 스레드를 사용해야 할까요?\u003c/h2\u003e\n\u003cp\u003e쓰레드는 작업과 같은 고수준 추상화로는 항상 달성할 수 없는 수준의 제어와 사용자 정의를 제공합니다.\u003c/p\u003e\n\u003cp\u003e쓰레드는 개발자에게 코드 실행을 저수준에서 직접 제어할 수 있는 기회를 제공합니다.\u003c/p\u003e\n\u003cp\u003e이는 특정 성능 중요한 상황이나 전문화된 시나리오에서 중요할 수 있는 리소스, 스케줄링 및 동기화의 정확한 관리를 가능하게 합니다.\u003c/p\u003e\n\u003cp\u003e쓰레드는 더 많은 제어와 유연성을 제공하지만 경합 조건, 데드락 및 동기화 문제와 같은 추가 복잡성과 잠재적인 함정도 동반합니다.\u003c/p\u003e\n\u003cp\u003e따라서, 귀하의 애플리케이션 요구 사항에 기반을 두고 상호 작용 모델을 신중히 고려하고 적절한 동시성 모델을 선택하는 것이 중요합니다.\u003c/p\u003e\n\u003ch1\u003e소스\u003c/h1\u003e\n\u003ch2\u003e비동기\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://www.udemy.com/course/ultimate-csharp-masterclass/\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://www.udemy.com/course/ultimate-csharp-masterclass/\u003c/a\u003e\u003c/p\u003e\n\u003ch2\u003e쓰레드\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://www.udemy.com/course/how-to-write-multi-threaded-csharp-code\" rel=\"nofollow\" target=\"_blank\"\u003e멀티쓰레드 C# 코드 작성 방법\u003c/a\u003e\u003c/p\u003e\n\u003ch2\u003e.Net에서 병렬 프로그래밍\u003c/h2\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-19-MultithreadinginCNetIntroductionandBestpractices"},"buildId":"fyfGyRz00q80ZdkogiVCt","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>