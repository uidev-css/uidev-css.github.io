<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>플러터에서 네이티브 코드와의 양방향 통신을 위한 메소드 채널 사용 방법 | uidev-css</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://uidev-css.github.io///post/2024-06-21-MethodChannelinFlutterBridgingNativeCodeandFlutterwithTwo-WayCommunication" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="플러터에서 네이티브 코드와의 양방향 통신을 위한 메소드 채널 사용 방법 | uidev-css" data-gatsby-head="true"/><meta property="og:title" content="플러터에서 네이티브 코드와의 양방향 통신을 위한 메소드 채널 사용 방법 | uidev-css" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-21-MethodChannelinFlutterBridgingNativeCodeandFlutterwithTwo-WayCommunication_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://uidev-css.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://uidev-css.github.io///post/2024-06-21-MethodChannelinFlutterBridgingNativeCodeandFlutterwithTwo-WayCommunication" data-gatsby-head="true"/><meta name="twitter:title" content="플러터에서 네이티브 코드와의 양방향 통신을 위한 메소드 채널 사용 방법 | uidev-css" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-21-MethodChannelinFlutterBridgingNativeCodeandFlutterwithTwo-WayCommunication_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | uidev-css" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-21 22:37" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b4eed7811784bdd3.js" defer=""></script><script src="/_next/static/5et5eMZxpKCgDAAyIS6Ju/_buildManifest.js" defer=""></script><script src="/_next/static/5et5eMZxpKCgDAAyIS6Ju/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UIDEV CSS</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">플러터에서 네이티브 코드와의 양방향 통신을 위한 메소드 채널 사용 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="플러터에서 네이티브 코드와의 양방향 통신을 위한 메소드 채널 사용 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UIDEV CSS</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 21, 2024</span><span class="posts_reading_time__f7YPP">5<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-21-MethodChannelinFlutterBridgingNativeCodeandFlutterwithTwo-WayCommunication&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>플러터의 메소드 채널은 플러터와 플랫폼별 코드 간에 원활한 통신을 제공하는 강력한 메커니즘을 제공합니다. 이 블로그 포스트에서는 플러터에서 메소드 채널을 설정하고 네이티브 MainActivity.kt(Android) 및 AppDelegate.swift(iOS) 코드에서 데이터를 플러터 애플리케이션으로 반환하는 과정을 살펴보겠습니다. 함께 알아보겠습니다!</p>
<p>플러터에서 메소드 채널 설정하기: 먼저, 플러터 프로젝트에 메소드 채널을 설정해 봅시다.</p>
<ul>
<li>의존성 추가: 플러터 프로젝트의 pubspec.yaml 파일에 flutter/services 패키지를 의존성으로 추가하세요:</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-attr">dependencies</span>:
  <span class="hljs-attr">flutter</span>:
    <span class="hljs-attr">sdk</span>: flutter
  flutter/<span class="hljs-attr">services</span>:
    ^<span class="hljs-number">2.0</span><span class="hljs-number">.0</span>
</code></pre>
<div class="content-ad"></div>
<ul>
<li>Method Channel 정의하기: 플러터 Dart 코드에서 Method Channel을 정의하세요:</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter/services.dart'</span>;

<span class="hljs-comment">// MethodChannel의 인스턴스 생성</span>
final <span class="hljs-title class_">MethodChannel</span> platformChannel = <span class="hljs-title class_">MethodChannel</span>(<span class="hljs-string">'your_channel_name'</span>);
</code></pre>
<p>Android에서 Method Channel 통신 구현하기: 이제 Android 플랫폼에서 Method Channel 통신을 구현해 봅시다.</p>
<ul>
<li>MainActivity.kt에서 메소드 호출 수신하기: MainActivity.kt 파일에서 onMethodCall 메소드를 오버라이드하여 Flutter로부터의 메소드 호출을 처리하고 데이터를 반환하세요:</li>
</ul>
<div class="content-ad"></div>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">import</span> io.flutter.embedding.android.FlutterActivity
<span class="hljs-keyword">import</span> io.flutter.embedding.engine.FlutterEngine
<span class="hljs-keyword">import</span> io.flutter.plugin.common.MethodChannel

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-type">FlutterActivity</span>() {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> CHANNEL = <span class="hljs-string">"your_channel_name"</span>

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">configureFlutterEngine</span><span class="hljs-params">(flutterEngine: <span class="hljs-type">FlutterEngine</span>)</span></span> {
        <span class="hljs-keyword">super</span>.configureFlutterEngine(flutterEngine)

        <span class="hljs-comment">// Set up the MethodChannel with the same name as defined in Dart</span>
        MethodChannel(flutterEngine.dartExecutor.binaryMessenger, CHANNEL).setMethodCallHandler { call, result ->
            <span class="hljs-keyword">if</span> (call.method == <span class="hljs-string">"getDataFromNative"</span>) {
                <span class="hljs-comment">// Perform platform-specific operations and obtain the result</span>
                <span class="hljs-keyword">val</span> <span class="hljs-keyword">data</span> = getDataFromNative()

                <span class="hljs-comment">// Send the result back to Flutter</span>
                result.success(<span class="hljs-keyword">data</span>)
            } <span class="hljs-keyword">else</span> {
                result.notImplemented()
            }
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getDataFromNative</span><span class="hljs-params">()</span></span>: String {
        <span class="hljs-comment">// Perform platform-specific operations to fetch the data</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Data from Native"</span>
    }
}
</code></pre>
<p>iOS에서 Method Channel 통신 구현하기: 이제 iOS 플랫폼에서 메서드 채널 통신을 구현해봅시다.</p>
<ul>
<li>AppDelegate.swift에서 메서드 호출 받기: AppDelegate.swift 파일에 아래 코드를 추가하여 Flutter에서의 메서드 호출을 처리하고 데이터를 반환합니다:</li>
</ul>
<pre><code class="hljs language-swift"><span class="hljs-keyword">import</span> UIKit
<span class="hljs-keyword">import</span> Flutter

<span class="hljs-keyword">@UIApplicationMain</span>
<span class="hljs-keyword">@objc</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppDelegate</span>: <span class="hljs-title class_">FlutterAppDelegate</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> <span class="hljs-type">CHANNEL</span> <span class="hljs-operator">=</span> <span class="hljs-string">"your_channel_name"</span>

    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">application</span>(
        <span class="hljs-keyword">_</span> <span class="hljs-params">application</span>: <span class="hljs-type">UIApplication</span>,
        <span class="hljs-params">didFinishLaunchingWithOptions</span> <span class="hljs-params">launchOptions</span>: [<span class="hljs-type">UIApplication</span>.<span class="hljs-params">LaunchOptionsKey</span>: <span class="hljs-keyword">Any</span>]<span class="hljs-operator">?</span>
    ) -> <span class="hljs-type">Bool</span> {
        <span class="hljs-comment">// Set up the MethodChannel with the same name as defined in Dart</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> flutterViewController <span class="hljs-operator">=</span> window<span class="hljs-operator">?</span>.rootViewController <span class="hljs-keyword">as?</span> <span class="hljs-type">FlutterViewController</span> {
            <span class="hljs-keyword">let</span> methodChannel <span class="hljs-operator">=</span> <span class="hljs-type">FlutterMethodChannel</span>(name: <span class="hljs-type">CHANNEL</span>, binaryMessenger: flutterViewController.binaryMessenger)
            methodChannel.setMethodCallHandler { [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] (call: <span class="hljs-type">FlutterMethodCall</span>, result: <span class="hljs-type">FlutterResult</span>) <span class="hljs-keyword">in</span>
                <span class="hljs-keyword">if</span> call.method <span class="hljs-operator">==</span> <span class="hljs-string">"getDataFromNative"</span> {
                    <span class="hljs-comment">// Perform platform-specific operations and obtain the result</span>
                    <span class="hljs-keyword">let</span> data <span class="hljs-operator">=</span> <span class="hljs-keyword">self</span><span class="hljs-operator">?</span>.getDataFromNative()

                    <span class="hljs-comment">// Send the result back to Flutter</span>
                    result(data)
                } <span class="hljs-keyword">else</span> {
                    result(<span class="hljs-type">FlutterMethodNotImplemented</span>)
                }
            }
        }

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.application(application, didFinishLaunchingWithOptions: launchOptions)
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">getDataFromNative</span>() -> <span class="hljs-type">String</span> {
        <span class="hljs-comment">// Perform platform-specific operations to fetch the data</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Data from Native"</span>
    }
}
</code></pre>
<div class="content-ad"></div>
<p>플러터에서 네이티브로 데이터 전달 및 결과 반환하기: 이제 플러터에서 네이티브에 데이터를 전달하고 결과를 다시 플러터에서 받는 방법을 살펴봅시다.</p>
<ul>
<li>플러터에서 메소드 호출: 플러터 Dart 코드에서 플랫폼별 코드에서 메소드를 호출하고 결과를 처리하세요.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">void</span> <span class="hljs-title function_">fetchDataFromNative</span>() <span class="hljs-keyword">async</span> {
  <span class="hljs-keyword">try</span> {
    final <span class="hljs-title class_">String</span> result = <span class="hljs-keyword">await</span> platformChannel.<span class="hljs-title function_">invokeMethod</span>(<span class="hljs-string">'getDataFromNative'</span>);
    <span class="hljs-title function_">print</span>(<span class="hljs-string">'Result from Native: $result'</span>);
  } on <span class="hljs-title class_">PlatformException</span> <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-title function_">print</span>(<span class="hljs-string">'Error: ${e.message}'</span>);
  }
}
</code></pre>
<p>결론: 축하합니다! 이제 플러터에서 메서드 채널을 성공적으로 설정했습니다. 이를 통해 플러터와 플랫폼별 코드 간의 양방향 통신이 가능해졌습니다. 이 블로그 포스트에서 안내된 단계와 코드 예제를 따라 하시면, 네이티브 기능을 쉽게 통합하고 네이티브 측에서 플러터 응용 프로그램으로 데이터를 반환할 수 있습니다. 실험하고 탐색하며, 메서드 채널의 강력한 기능을 활용하여 플러터 프로젝트의 무한한 가능성을 발견하세요. 즐거운 코딩되세요!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"플러터에서 네이티브 코드와의 양방향 통신을 위한 메소드 채널 사용 방법","description":"","date":"2024-06-21 22:37","slug":"2024-06-21-MethodChannelinFlutterBridgingNativeCodeandFlutterwithTwo-WayCommunication","content":"\n\n플러터의 메소드 채널은 플러터와 플랫폼별 코드 간에 원활한 통신을 제공하는 강력한 메커니즘을 제공합니다. 이 블로그 포스트에서는 플러터에서 메소드 채널을 설정하고 네이티브 MainActivity.kt(Android) 및 AppDelegate.swift(iOS) 코드에서 데이터를 플러터 애플리케이션으로 반환하는 과정을 살펴보겠습니다. 함께 알아보겠습니다!\n\n플러터에서 메소드 채널 설정하기: 먼저, 플러터 프로젝트에 메소드 채널을 설정해 봅시다.\n\n- 의존성 추가: 플러터 프로젝트의 pubspec.yaml 파일에 flutter/services 패키지를 의존성으로 추가하세요:\n\n```js\ndependencies:\n  flutter:\n    sdk: flutter\n  flutter/services:\n    ^2.0.0\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Method Channel 정의하기: 플러터 Dart 코드에서 Method Channel을 정의하세요:\n\n```js\nimport 'package:flutter/services.dart';\n\n// MethodChannel의 인스턴스 생성\nfinal MethodChannel platformChannel = MethodChannel('your_channel_name');\n```\n\nAndroid에서 Method Channel 통신 구현하기: 이제 Android 플랫폼에서 Method Channel 통신을 구현해 봅시다.\n\n- MainActivity.kt에서 메소드 호출 수신하기: MainActivity.kt 파일에서 onMethodCall 메소드를 오버라이드하여 Flutter로부터의 메소드 호출을 처리하고 데이터를 반환하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\nimport io.flutter.embedding.android.FlutterActivity\nimport io.flutter.embedding.engine.FlutterEngine\nimport io.flutter.plugin.common.MethodChannel\n\nclass MainActivity : FlutterActivity() {\n    private val CHANNEL = \"your_channel_name\"\n\n    override fun configureFlutterEngine(flutterEngine: FlutterEngine) {\n        super.configureFlutterEngine(flutterEngine)\n\n        // Set up the MethodChannel with the same name as defined in Dart\n        MethodChannel(flutterEngine.dartExecutor.binaryMessenger, CHANNEL).setMethodCallHandler { call, result -\u003e\n            if (call.method == \"getDataFromNative\") {\n                // Perform platform-specific operations and obtain the result\n                val data = getDataFromNative()\n\n                // Send the result back to Flutter\n                result.success(data)\n            } else {\n                result.notImplemented()\n            }\n        }\n    }\n\n    private fun getDataFromNative(): String {\n        // Perform platform-specific operations to fetch the data\n        return \"Data from Native\"\n    }\n}\n```\n\niOS에서 Method Channel 통신 구현하기: 이제 iOS 플랫폼에서 메서드 채널 통신을 구현해봅시다.\n\n- AppDelegate.swift에서 메서드 호출 받기: AppDelegate.swift 파일에 아래 코드를 추가하여 Flutter에서의 메서드 호출을 처리하고 데이터를 반환합니다:\n\n```swift\nimport UIKit\nimport Flutter\n\n@UIApplicationMain\n@objc class AppDelegate: FlutterAppDelegate {\n    private let CHANNEL = \"your_channel_name\"\n\n    override func application(\n        _ application: UIApplication,\n        didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?\n    ) -\u003e Bool {\n        // Set up the MethodChannel with the same name as defined in Dart\n        if let flutterViewController = window?.rootViewController as? FlutterViewController {\n            let methodChannel = FlutterMethodChannel(name: CHANNEL, binaryMessenger: flutterViewController.binaryMessenger)\n            methodChannel.setMethodCallHandler { [weak self] (call: FlutterMethodCall, result: FlutterResult) in\n                if call.method == \"getDataFromNative\" {\n                    // Perform platform-specific operations and obtain the result\n                    let data = self?.getDataFromNative()\n\n                    // Send the result back to Flutter\n                    result(data)\n                } else {\n                    result(FlutterMethodNotImplemented)\n                }\n            }\n        }\n\n        return super.application(application, didFinishLaunchingWithOptions: launchOptions)\n    }\n\n    private func getDataFromNative() -\u003e String {\n        // Perform platform-specific operations to fetch the data\n        return \"Data from Native\"\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플러터에서 네이티브로 데이터 전달 및 결과 반환하기: 이제 플러터에서 네이티브에 데이터를 전달하고 결과를 다시 플러터에서 받는 방법을 살펴봅시다.\n\n- 플러터에서 메소드 호출: 플러터 Dart 코드에서 플랫폼별 코드에서 메소드를 호출하고 결과를 처리하세요.\n\n```js\nvoid fetchDataFromNative() async {\n  try {\n    final String result = await platformChannel.invokeMethod('getDataFromNative');\n    print('Result from Native: $result');\n  } on PlatformException catch (e) {\n    print('Error: ${e.message}');\n  }\n}\n```\n\n결론: 축하합니다! 이제 플러터에서 메서드 채널을 성공적으로 설정했습니다. 이를 통해 플러터와 플랫폼별 코드 간의 양방향 통신이 가능해졌습니다. 이 블로그 포스트에서 안내된 단계와 코드 예제를 따라 하시면, 네이티브 기능을 쉽게 통합하고 네이티브 측에서 플러터 응용 프로그램으로 데이터를 반환할 수 있습니다. 실험하고 탐색하며, 메서드 채널의 강력한 기능을 활용하여 플러터 프로젝트의 무한한 가능성을 발견하세요. 즐거운 코딩되세요!","ogImage":{"url":"/assets/img/2024-06-21-MethodChannelinFlutterBridgingNativeCodeandFlutterwithTwo-WayCommunication_0.png"},"coverImage":"/assets/img/2024-06-21-MethodChannelinFlutterBridgingNativeCodeandFlutterwithTwo-WayCommunication_0.png","tag":["Tech"],"readingTime":5},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e플러터의 메소드 채널은 플러터와 플랫폼별 코드 간에 원활한 통신을 제공하는 강력한 메커니즘을 제공합니다. 이 블로그 포스트에서는 플러터에서 메소드 채널을 설정하고 네이티브 MainActivity.kt(Android) 및 AppDelegate.swift(iOS) 코드에서 데이터를 플러터 애플리케이션으로 반환하는 과정을 살펴보겠습니다. 함께 알아보겠습니다!\u003c/p\u003e\n\u003cp\u003e플러터에서 메소드 채널 설정하기: 먼저, 플러터 프로젝트에 메소드 채널을 설정해 봅시다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e의존성 추가: 플러터 프로젝트의 pubspec.yaml 파일에 flutter/services 패키지를 의존성으로 추가하세요:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-attr\"\u003edependencies\u003c/span\u003e:\n  \u003cspan class=\"hljs-attr\"\u003eflutter\u003c/span\u003e:\n    \u003cspan class=\"hljs-attr\"\u003esdk\u003c/span\u003e: flutter\n  flutter/\u003cspan class=\"hljs-attr\"\u003eservices\u003c/span\u003e:\n    ^\u003cspan class=\"hljs-number\"\u003e2.0\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.0\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003eMethod Channel 정의하기: 플러터 Dart 코드에서 Method Channel을 정의하세요:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:flutter/services.dart'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e// MethodChannel의 인스턴스 생성\u003c/span\u003e\nfinal \u003cspan class=\"hljs-title class_\"\u003eMethodChannel\u003c/span\u003e platformChannel = \u003cspan class=\"hljs-title class_\"\u003eMethodChannel\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'your_channel_name'\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAndroid에서 Method Channel 통신 구현하기: 이제 Android 플랫폼에서 Method Channel 통신을 구현해 봅시다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMainActivity.kt에서 메소드 호출 수신하기: MainActivity.kt 파일에서 onMethodCall 메소드를 오버라이드하여 Flutter로부터의 메소드 호출을 처리하고 데이터를 반환하세요:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e io.flutter.embedding.android.FlutterActivity\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e io.flutter.embedding.engine.FlutterEngine\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e io.flutter.plugin.common.MethodChannel\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMainActivity\u003c/span\u003e : \u003cspan class=\"hljs-type\"\u003eFlutterActivity\u003c/span\u003e() {\n    \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e CHANNEL = \u003cspan class=\"hljs-string\"\u003e\"your_channel_name\"\u003c/span\u003e\n\n    \u003cspan class=\"hljs-keyword\"\u003eoverride\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efun\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003econfigureFlutterEngine\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(flutterEngine: \u003cspan class=\"hljs-type\"\u003eFlutterEngine\u003c/span\u003e)\u003c/span\u003e\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003esuper\u003c/span\u003e.configureFlutterEngine(flutterEngine)\n\n        \u003cspan class=\"hljs-comment\"\u003e// Set up the MethodChannel with the same name as defined in Dart\u003c/span\u003e\n        MethodChannel(flutterEngine.dartExecutor.binaryMessenger, CHANNEL).setMethodCallHandler { call, result -\u003e\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (call.method == \u003cspan class=\"hljs-string\"\u003e\"getDataFromNative\"\u003c/span\u003e) {\n                \u003cspan class=\"hljs-comment\"\u003e// Perform platform-specific operations and obtain the result\u003c/span\u003e\n                \u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edata\u003c/span\u003e = getDataFromNative()\n\n                \u003cspan class=\"hljs-comment\"\u003e// Send the result back to Flutter\u003c/span\u003e\n                result.success(\u003cspan class=\"hljs-keyword\"\u003edata\u003c/span\u003e)\n            } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n                result.notImplemented()\n            }\n        }\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efun\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003egetDataFromNative\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e: String {\n        \u003cspan class=\"hljs-comment\"\u003e// Perform platform-specific operations to fetch the data\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"Data from Native\"\u003c/span\u003e\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eiOS에서 Method Channel 통신 구현하기: 이제 iOS 플랫폼에서 메서드 채널 통신을 구현해봅시다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAppDelegate.swift에서 메서드 호출 받기: AppDelegate.swift 파일에 아래 코드를 추가하여 Flutter에서의 메서드 호출을 처리하고 데이터를 반환합니다:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e UIKit\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e Flutter\n\n\u003cspan class=\"hljs-keyword\"\u003e@UIApplicationMain\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003e@objc\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAppDelegate\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eFlutterAppDelegate\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eCHANNEL\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"your_channel_name\"\u003c/span\u003e\n\n    \u003cspan class=\"hljs-keyword\"\u003eoverride\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eapplication\u003c/span\u003e(\n        \u003cspan class=\"hljs-keyword\"\u003e_\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003eapplication\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eUIApplication\u003c/span\u003e,\n        \u003cspan class=\"hljs-params\"\u003edidFinishLaunchingWithOptions\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003elaunchOptions\u003c/span\u003e: [\u003cspan class=\"hljs-type\"\u003eUIApplication\u003c/span\u003e.\u003cspan class=\"hljs-params\"\u003eLaunchOptionsKey\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003eAny\u003c/span\u003e]\u003cspan class=\"hljs-operator\"\u003e?\u003c/span\u003e\n    ) -\u003e \u003cspan class=\"hljs-type\"\u003eBool\u003c/span\u003e {\n        \u003cspan class=\"hljs-comment\"\u003e// Set up the MethodChannel with the same name as defined in Dart\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e flutterViewController \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e window\u003cspan class=\"hljs-operator\"\u003e?\u003c/span\u003e.rootViewController \u003cspan class=\"hljs-keyword\"\u003eas?\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eFlutterViewController\u003c/span\u003e {\n            \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e methodChannel \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eFlutterMethodChannel\u003c/span\u003e(name: \u003cspan class=\"hljs-type\"\u003eCHANNEL\u003c/span\u003e, binaryMessenger: flutterViewController.binaryMessenger)\n            methodChannel.setMethodCallHandler { [\u003cspan class=\"hljs-keyword\"\u003eweak\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e] (call: \u003cspan class=\"hljs-type\"\u003eFlutterMethodCall\u003c/span\u003e, result: \u003cspan class=\"hljs-type\"\u003eFlutterResult\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e\n                \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e call.method \u003cspan class=\"hljs-operator\"\u003e==\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"getDataFromNative\"\u003c/span\u003e {\n                    \u003cspan class=\"hljs-comment\"\u003e// Perform platform-specific operations and obtain the result\u003c/span\u003e\n                    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e data \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e\u003cspan class=\"hljs-operator\"\u003e?\u003c/span\u003e.getDataFromNative()\n\n                    \u003cspan class=\"hljs-comment\"\u003e// Send the result back to Flutter\u003c/span\u003e\n                    result(data)\n                } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n                    result(\u003cspan class=\"hljs-type\"\u003eFlutterMethodNotImplemented\u003c/span\u003e)\n                }\n            }\n        }\n\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003esuper\u003c/span\u003e.application(application, didFinishLaunchingWithOptions: launchOptions)\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetDataFromNative\u003c/span\u003e() -\u003e \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e {\n        \u003cspan class=\"hljs-comment\"\u003e// Perform platform-specific operations to fetch the data\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"Data from Native\"\u003c/span\u003e\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e플러터에서 네이티브로 데이터 전달 및 결과 반환하기: 이제 플러터에서 네이티브에 데이터를 전달하고 결과를 다시 플러터에서 받는 방법을 살펴봅시다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e플러터에서 메소드 호출: 플러터 Dart 코드에서 플랫폼별 코드에서 메소드를 호출하고 결과를 처리하세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetchDataFromNative\u003c/span\u003e() \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n    final \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e result = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e platformChannel.\u003cspan class=\"hljs-title function_\"\u003einvokeMethod\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'getDataFromNative'\u003c/span\u003e);\n    \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Result from Native: $result'\u003c/span\u003e);\n  } on \u003cspan class=\"hljs-title class_\"\u003ePlatformException\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (e) {\n    \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Error: ${e.message}'\u003c/span\u003e);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e결론: 축하합니다! 이제 플러터에서 메서드 채널을 성공적으로 설정했습니다. 이를 통해 플러터와 플랫폼별 코드 간의 양방향 통신이 가능해졌습니다. 이 블로그 포스트에서 안내된 단계와 코드 예제를 따라 하시면, 네이티브 기능을 쉽게 통합하고 네이티브 측에서 플러터 응용 프로그램으로 데이터를 반환할 수 있습니다. 실험하고 탐색하며, 메서드 채널의 강력한 기능을 활용하여 플러터 프로젝트의 무한한 가능성을 발견하세요. 즐거운 코딩되세요!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-21-MethodChannelinFlutterBridgingNativeCodeandFlutterwithTwo-WayCommunication"},"buildId":"5et5eMZxpKCgDAAyIS6Ju","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>