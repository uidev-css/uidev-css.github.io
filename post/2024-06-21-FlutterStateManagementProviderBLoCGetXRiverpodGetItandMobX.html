<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Flutter 상태 관리 비교 Provider, BLoC, GetX, Riverpod, GetIt, 그리고 MobX | uidev-css</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://uidev-css.github.io///post/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Flutter 상태 관리 비교 Provider, BLoC, GetX, Riverpod, GetIt, 그리고 MobX | uidev-css" data-gatsby-head="true"/><meta property="og:title" content="Flutter 상태 관리 비교 Provider, BLoC, GetX, Riverpod, GetIt, 그리고 MobX | uidev-css" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://uidev-css.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://uidev-css.github.io///post/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX" data-gatsby-head="true"/><meta name="twitter:title" content="Flutter 상태 관리 비교 Provider, BLoC, GetX, Riverpod, GetIt, 그리고 MobX | uidev-css" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | uidev-css" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-21 23:25" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b75a4bf98ee956a8.js" defer=""></script><script src="/_next/static/AAcWCMtAYBsqiURBkbPEc/_buildManifest.js" defer=""></script><script src="/_next/static/AAcWCMtAYBsqiURBkbPEc/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UIDEV CSS</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Flutter 상태 관리 비교 Provider, BLoC, GetX, Riverpod, GetIt, 그리고 MobX</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Flutter 상태 관리 비교 Provider, BLoC, GetX, Riverpod, GetIt, 그리고 MobX" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UIDEV CSS</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 21, 2024</span><span class="posts_reading_time__f7YPP">28<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>본 기사에서는 상태 관리의 일반적인 개요를 검토한 후 가장 흥미로운 상태 관리 방법인 Provider, BLoC, GetX, Riverpod, GetIt, 그리고 MobX를 살펴보겠습니다.</p>
<p><img src="/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_0.png" alt="image"></p>
<h1>일반적인 개요</h1>
<p>모바일 앱을 개발하는 동안, 화면 간이나 전체 앱을 통해 앱 상태를 공유해야 하는 시점이 찾아옵니다.</p>
<p>이 예에서는 MyLoginScreen, MyCatalog 및 MyCart의 3 개 화면이 있습니다. MyCatalog에서는 제품이 이미 쇼핑 카트에 있는지 확인하기 위해 애플리케이션의 상태를 알아야 합니다. 그리고 MyCart에서는 추가된 모든 제품과 총 구매액을 보고 싶습니다. 두 화면 모두 카트의 상태를 알아야 합니다. 이것은 애플리케이션 상태의 예시이며, 나중에 자세히 검토할 예정입니다.</p>
<ul>
<li>Android 또는 iOS 개발에서 추측할 수 있는 많은 가정이 Flutter에는 해당하지 않습니다. 예를 들어, Flutter에서 UI의 일부를 수정하는 대신 처음부터 다시 빌드하는 것은 괜찮습니다. Flutter는 이를 수행할 만큼 충분히 빠릅니다. 필요하다면 매 프레임마다 가능합니다.</li>
<li>Flutter는 선언적입니다. 이것은 Flutter가 현재 상태 애플리케이션을 반영하기 위해 UI를 빌드한다는 것을 의미합니다.</li>
<li>예를 들어 앱 상태가 변경되면, 예를 들어 설정 화면이 있고 사용자가 스위치를 누르는 경우, 그것은 상태를 변경하고 이것은 UI 디자인을 트리거합니다. 이것은 명령형 UI 변경이 아니며, 변경되는 것은 상태이며 UI는 처음부터 다시 빌드됩니다.</li>
<li>UI 프로그래밍의 선언적 스타일에는 많은 이점이 있습니다. 모든 상태에 대해 UI가 어떻게 보이는지 설명하고 한 번만 설명하면 됩니다.</li>
</ul>
<h1>Transient State와 앱 상태의 차이점</h1>
<p><img src="/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_3.png" alt="이미지"></p>
<p>앱 상태는 응용 프로그램이 실행 중일 때 메모리에 있는 모든 요소를 포함합니다. 이는 자산, 변수, 애니메이션 상태, 글ꔼ자 등을 포함합니다.</p>
<p>우리가 관리하는 상태는 일시적인 상태와 앱 상태로 나뉠 수 있습니다.</p>
<h2>일시적 상태</h2>
<p>단일 위젯을 포함할 수 있는 상태입니다. 예를 들어:</p>
<ul>
<li>위젯에서 현재 페이지</li>
<li>애니메이션의 진행 상황</li>
<li>BottomNavigationBar에서 선택한 탭</li>
</ul>
<p>다시 말해, 이 유형의 상태에서는 상태 관리 기술을 사용할 필요가 없습니다. 필요한 것은 StatefulWidget뿐입니다.</p>
<h2>앱 상태</h2>
<p>당연히, 이것은 일시적이지 않은 상태이며 응용 프로그램의 여러 부분에서 공유하고 사용자 세션 사이에서 유지하고 싶은 상태입니다. 응용 프로그램 상태의 예시:</p>
<ul>
<li>사용자의 선호도</li>
<li>로그인 정보</li>
<li>전자 상거래 응용 프로그램의 쇼핑 카트</li>
</ul>
<p>여기서 우리는 상태 관리가 필요할 수 있습니다.</p>
<p>저희가 모든 상태 관리를 위해 개발할 예제를 보여드리겠습니다.</p>
<p><img src="/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_4.png" alt="이미지"></p>
<h1>Provider</h1>
<p>만약 플러터를 처음 시작하시는 초보자이고 다른 접근 방식을 선택할 확실한 이유가 없다면, 아마도 이 접근 방식부터 시작하는 것이 좋을 것입니다. Provider 패키지는 이해하기 쉽고 코드 양이 많지 않습니다. 또한 다른 접근 방식에서 사용되는 개념을 사용합니다.</p>
<p>앱에는 MyCart 및 MyCatalog 위젯으로 나타낸 카탈로그 및 장바구니라는 두 개의 별도 화면이 있습니다. 카탈로그 화면에는 앱 바와 항목 목록이 포함되어 있습니다.</p>
<p>우리는 몇 가지 위젯이 있습니다. 그 중 많은 위젯이 다른 위치에 "소속된" 상태에 액세스해야 합니다. 예를 들어, 카탈로그의 각 항목은 장바구니에 추가할 수 있습니다. 현재 표시된 항목이 이미 장바구니에 있는지 확인하려고 할 수도 있습니다.</p>
<p>이로써 첫 번째 질문으로 이어집니다: 장바구니의 현재 상태를 어디에 두어야 할까요?</p>
<ul>
<li>플러터에서는 상태를 사용하는 위젯 위에 상태를 두는 것이 합리적으로 보입니다. 왜 그럴까요? 플러터와 같은 선언형 프레임워크에서는 UI를 변경하려면 다시 생성해야 합니다. 다시 말해, 외부에서 메서드를 호출하여 위젯을 명령형으로 변경하는 것은 어렵습니다.</li>
<li>현재 UI 상태를 고려하고 새 데이터를 적용해야 합니다. 이런 방식으로 버그를 피하기 어렵습니다.</li>
<li>플러터에서는 컨텐츠가 변경될 때마다 새 위젯을 빌드합니다.</li>
</ul>
<p>이전 질문에 대한 답변은 앱 수준에 장바구니 상태를 두어야 합니다. 이렇게 하면 MyCart와 MyCatalog에서 상태에 액세스할 수 있습니다. MyCatalog 레벨에 상태를 둔다면 MyCart에서 액세스할 수 없습니다. 플러터에서는 불필요한 UI 다시 빌드를 피하기 위해 가능한 한 앱 상태를 위젯 트리의 낮은 위치에 두는 것이 좋은 실천법입니다.</p>
<p><img src="/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_7.png" alt="이미지"></p>
<p>이제 코드를 리뷰해 봅시다.</p>
<p>먼저, 우리에게는 3가지 상태가 있습니다: 초기 상태, 로딩 상태, 성공 상태.</p>
<pre><code class="hljs language-js">enum <span class="hljs-title class_">Status</span> {
  initial,
  loading,
  success,
}
</code></pre>
<p>Provider를 사용할 때 이해해야 할 3가지 개념이 있습니다: ChangeNotifier, ChangeNotifierProvider 및 Consumer.</p>
<h2>ChangeNotifier</h2>
<p>ChangeNotifier은 Flutter SDK에 포함된 간단한 클래스로, 청취자에게 변경 알림을 제공합니다. 즉, 무언가가 ChangeNotifier이면 해당 변경 사항에 구독할 수 있습니다.</p>
<p>provider에서 ChangeNotifier는 응용 프로그램 상태를 캡슐화하는 한 가지 방법입니다. 매우 간단한 앱의 경우에는 하나의 ChangeNotifier로 작업할 수 있습니다. 복잡한 앱의 경우 여러 가지 모델이 있고, 따라서 여러 개의 ChangeNotifier가 있을 것입니다.</p>
<p>ChangeNotifier에 특정한 유일한 코드는 notifyListeners()를 호출하는 부분입니다. 이 메서드를 호출하여 모델에 변경 사항이 있을 때마다 UI가 변경될 수 있는지 확인하세요. CartModel에서의 나머지 코드는 모델 자체와 비즈니스 로직입니다.</p>
<p>우리의 DataProvider 클래스를 확인해주세요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DataProvider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">ChangeNotifier</span> {
  <span class="hljs-comment">/// 데이터 공급자의 내부적인, 비공개 상태입니다.</span>
  <span class="hljs-title class_">Status</span> _state = <span class="hljs-title class_">Status</span>.<span class="hljs-property">initial</span>;

  <span class="hljs-comment">/// 데이터 공급자의 상태입니다.</span>
  <span class="hljs-title class_">Status</span> get state => _state;

  <span class="hljs-comment">/// 데이터 공급자의 상태를 업데이트합니다. 데이터 공급자를 외부에서 수정하는 유일한 방법입니다.</span>
  <span class="hljs-keyword">void</span> <span class="hljs-title function_">fecthData</span>() <span class="hljs-keyword">async</span> {
    _state = <span class="hljs-title class_">Status</span>.<span class="hljs-property">loading</span>;
    <span class="hljs-comment">// 이 호출은 해당 모델을 듣고 있는 위젯에게 rebuild해야 함을 알립니다.</span>
    <span class="hljs-title function_">notifyListeners</span>();

    <span class="hljs-keyword">await</span> <span class="hljs-title class_">Future</span>.<span class="hljs-title function_">delayed</span>(<span class="hljs-keyword">const</span> <span class="hljs-title class_">Duration</span>(<span class="hljs-attr">seconds</span>: <span class="hljs-number">2</span>));

    _state = <span class="hljs-title class_">Status</span>.<span class="hljs-property">success</span>;
    <span class="hljs-title function_">notifyListeners</span>();
  }
}
</code></pre>
<h2>ChangeNotifierProvider</h2>
<p>ChangeNotifierProvider은 ChangeNotifier 인스턴스를 후손들에게 제공하는 위젯입니다. provider 패키지에서 제공됩니다.</p>
<p>ChangeNotifierProvider를 어디에 배치해야 하는지 이미 알고 계시네요: 액세스해야 하는 위젯들 위에요. CartModel의 경우, MyCart와 MyCatalog 둘 다 위쪽에 어딘가에 있어야 합니다.</p>
<p>우리 예제에서 ChangeNotifierProvider와 HomeProvider (UI)를 자식으로 하는 ProviderPage가 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProviderPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">StatelessWidget</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> route = <span class="hljs-string">'provider-page'</span>;

  <span class="hljs-keyword">const</span> <span class="hljs-title class_">ProviderPage</span>({<span class="hljs-variable language_">super</span>.<span class="hljs-property">key</span>});

  @override
  <span class="hljs-title class_">Widget</span> <span class="hljs-title function_">build</span>(<span class="hljs-params">BuildContext context</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">ChangeNotifierProvider</span>(
      <span class="hljs-attr">create</span>: <span class="hljs-function">(<span class="hljs-params">context</span>) =></span> <span class="hljs-title class_">DataProvider</span>(),
      <span class="hljs-attr">child</span>: <span class="hljs-keyword">const</span> <span class="hljs-title class_">HomeProvider</span>(),
    );
  }
}
</code></pre>
<h2>Consumer</h2>
<p>요소별로 Translation을 제공합니다:</p>
<p>Consumer 위젯을 가능한 깊이까지 Tree 안에 두는 것이 최선의 방법입니다. 어딘가의 세부 사항이 변경되었을 때 UI의 큰 부분을 다시 빌드하고 싶지 않으니까요.</p>
<pre><code class="hljs language-dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomeProvider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>{
  <span class="hljs-keyword">const</span> HomeProvider({<span class="hljs-keyword">super</span>.key});

  <span class="hljs-meta">@override</span>
  State&#x3C;HomeProvider> createState() => _HomeProviderState();
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_HomeProviderState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&#x3C;<span class="hljs-title">HomeProvider</span>> </span>{
  <span class="hljs-keyword">late</span> DataProvider provider;

  <span class="hljs-meta">@override</span>
  <span class="hljs-keyword">void</span> initState() {
    provider = Provider.of&#x3C;DataProvider>(context, listen: <span class="hljs-keyword">false</span>);
    <span class="hljs-keyword">super</span>.initState();
  }

  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-keyword">return</span> Scaffold(
      appBar: AppBar(title: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">'Provider Page'</span>)),
      <span class="hljs-comment">// Consumer 위젯을 가능한 깊이까지 Tree 안에 두는 것이 최선의 방법입니다.</span>
      <span class="hljs-comment">// 어딘가의 세부 사항이 변경되었을 때 UI의 큰 부분을 다시 빌드하고 싶지 않으니까요.</span>
      body: Consumer&#x3C;DataProvider>(
        builder: (context, data, child) {
          <span class="hljs-keyword">if</span> (data.state == Status.initial) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">const</span> Center(child: Text(<span class="hljs-string">'Press the Button'</span>));
          }
          <span class="hljs-keyword">if</span> (data.state == Status.loading) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">const</span> Center(child: CircularProgressIndicator());
          }
          <span class="hljs-keyword">if</span> (data.state == Status.success) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">const</span> Center(child: Text(<span class="hljs-string">'Success'</span>));
          }
          <span class="hljs-keyword">return</span> Container();
        },
      ),
      floatingActionButton: Column(
        crossAxisAlignment: CrossAxisAlignment.end,
        mainAxisAlignment: MainAxisAlignment.end,
        children: &#x3C;Widget>[
          FloatingActionButton(
            child: <span class="hljs-keyword">const</span> Icon(Icons.play_arrow),
            onPressed: () => provider.fecthData(),
          ),
        ],
      ),
    );
  }
}
</code></pre>
<p>그 결과는 다음과 같습니다:</p>
<p><img src="/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_8.png" alt="이미지"></p>
<h2>장점</h2>
<ul>
<li>Flutter를 처음 사용하는 경우 시작해야 할 접근 방식입니다. 이해하기 쉽고 많은 코드를 사용하지 않습니다.</li>
<li>Devtool 친화적 — Provider를 사용하면 애플리케이션의 상태가 Flutter devtool에서 볼 수 있습니다.</li>
<li>데이터 할당 및 자원 (데이터) 해제를 간소화합니다.</li>
</ul>
<h2>단점</h2>
<ul>
<li>불필요한 업데이트를 실수로 호출할 수 있습니다. 객체의 상태가 변경되었을 때마다 업데이트를 트리거할 필요는 없습니다. 그러나 Provider를 사용하는 경우 변경이 발생할 때마다 항상 업데이트를 트리거합니다.</li>
<li>확장성</li>
</ul>
<h1>BLoC</h1>
<ul>
<li>이 패키지의 목적은 UI와 비즈니스 로직을 분리하는 것을 용이하게 하는 것입니다.</li>
<li>이 패키지는 패턴의 반응적 부분을 추상화하여 개발자가 비즈니스 로직 작성에 집중할 수 있도록 합니다.</li>
<li>Bloc은 이벤트를 기반으로 한 상태 변경을 트리거하는 메서드 대신 메서드 대신 사용하는 고급 클래스입니다. Bloc은 이벤트를 수신하고 수신된 이벤트를 발생한 이벤트로 변환합니다.</li>
</ul>
<p><img src="/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_9.png" alt="image"></p>
<p>이 부분을 좀 더 잘 이해하기 위해 이벤트가 UI에서 추가되고 BLoC에서 이를 처리하고 이러한 이벤트에 대한 상태 변경으로 응답합니다. bloc 라이브러리를 사용하면 Presentation, Business Logic 및 Data가 세 개의 레이어로 나뉘도록 응용 프로그램을 분리할 수 있습니다.</p>
<p>상태 변경은 이벤트가 추가될 때 블록이 시작되며 onEvent을 트리거합니다. 그런 다음, 이벤트는 EventTransformer를 통해 흘러갑니다. 기본적으로 각 이벤트는 병렬로 처리되지만 사용자 정의 EventTransformer를 제공하여 들어오는 이벤트 스트림을 조작할 수 있습니다. 해당 이벤트 유형에 대해 등록된 모든 EventHandlers는 들어오는 이벤트와 함께 호출됩니다. 각 EventHandler는 이벤트에 대한 응답으로 제로 이상의 상태를 발행하는 책임이 있습니다. 마지막으로, 상태가 업데이트되기 직전에 onTransition이 호출되며 현재 상태, 이벤트 및 다음 상태를 포함합니다.</p>
<p><img src="/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_10.png" alt="이미지"></p>
<p>BLoC 구현에서는 data_bloc, data_event 및 data_state 총 3개의 파일이 필요합니다.</p>
<p><img src="/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_11.png" alt="이미지"></p>
<p>블록 상태에서는 세 가지 상태를 가질 것입니다: 초기, 로딩 및 성공.</p>
<pre><code class="hljs language-js">part <span class="hljs-keyword">of</span> <span class="hljs-string">'data_bloc.dart'</span>;


abstract <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataState</span> {}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Initial</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">DataState</span> {}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Loading</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">DataState</span> {}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Success</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">DataState</span> {}
</code></pre>
<p>또한, 블록 이벤트에서는 FetchDataEvent만 사용할 것입니다.</p>
<pre><code class="hljs language-js">part <span class="hljs-keyword">of</span> <span class="hljs-string">'data_bloc.dart'</span>;

abstract <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataEvent</span> {}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">FetchDataEvent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">DataEvent</span> {}

&#x3C;div <span class="hljs-keyword">class</span>=<span class="hljs-string">"content-ad"</span>>&#x3C;/div>

<span class="hljs-title class_">In</span> <span class="hljs-title class_">DataBloc</span>, when the <span class="hljs-title class_">FetchDataEvent</span> is added, the _onFetchDataEvent method is triggered.

<span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter_bloc/flutter_bloc.dart'</span>;

part <span class="hljs-string">'data_event.dart'</span>;
part <span class="hljs-string">'data_state.dart'</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">DataBloc</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Bloc</span>&#x3C;<span class="hljs-title class_">DataEvent</span>, <span class="hljs-title class_">DataState</span>> {
  <span class="hljs-title class_">DataBloc</span>() : <span class="hljs-title function_">super</span>(<span class="hljs-params">Initial()</span>) {
    on&#x3C;<span class="hljs-title class_">FetchDataEvent</span>>(_onFetchDataEvent);
  }

  <span class="hljs-keyword">void</span> <span class="hljs-title function_">_onFetchDataEvent</span>(
    <span class="hljs-title class_">FetchDataEvent</span> event,
    <span class="hljs-title class_">Emitter</span>&#x3C;<span class="hljs-title class_">DataState</span>> emit,
  ) <span class="hljs-keyword">async</span> {
    <span class="hljs-title function_">emit</span>(<span class="hljs-title class_">Loading</span>());
    <span class="hljs-keyword">await</span> <span class="hljs-title class_">Future</span>.<span class="hljs-title function_">delayed</span>(<span class="hljs-keyword">const</span> <span class="hljs-title class_">Duration</span>(<span class="hljs-attr">seconds</span>: <span class="hljs-number">2</span>));
    <span class="hljs-title function_">emit</span>(<span class="hljs-title class_">Success</span>());
  }
}

<span class="hljs-title class_">In</span> <span class="hljs-variable language_">this</span> example, we have a <span class="hljs-title class_">BlocPage</span> that includes a <span class="hljs-title class_">BlocProvider</span> <span class="hljs-keyword">with</span> <span class="hljs-title class_">HomeBloc</span> <span class="hljs-keyword">as</span> a child.

<span class="hljs-keyword">class</span> <span class="hljs-title class_">BlocPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">StatelessWidget</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> route = <span class="hljs-string">'bloc-page'</span>;

  <span class="hljs-keyword">const</span> <span class="hljs-title class_">BlocPage</span>({<span class="hljs-title class_">Key</span> key}) : <span class="hljs-variable language_">super</span>(<span class="hljs-attr">key</span>: key);

  @override
  <span class="hljs-title class_">Widget</span> <span class="hljs-title function_">build</span>(<span class="hljs-params">BuildContext context</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">BlocProvider</span>(
      <span class="hljs-attr">create</span>: <span class="hljs-function">(<span class="hljs-params">context</span>) =></span> <span class="hljs-title class_">DataBloc</span>(),
      <span class="hljs-attr">child</span>: <span class="hljs-keyword">const</span> <span class="hljs-title class_">HomeBloc</span>(),
    );
  }
}

&#x3C;div <span class="hljs-keyword">class</span>=<span class="hljs-string">"content-ad"</span>>&#x3C;/div>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">HomeBloc</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">StatefulWidget</span> {
  <span class="hljs-keyword">const</span> <span class="hljs-title class_">HomeBloc</span>({<span class="hljs-variable language_">super</span>.<span class="hljs-property">key</span>});

  @override
  <span class="hljs-title class_">State</span>&#x3C;<span class="hljs-title class_">HomeBloc</span>> <span class="hljs-title function_">createState</span>() => <span class="hljs-title function_">_HomeBlocState</span>();
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">_HomeBlocState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">State</span>&#x3C;<span class="hljs-title class_">HomeBloc</span>> {
  late <span class="hljs-title class_">DataBloc</span> bloc;

  @override
  <span class="hljs-keyword">void</span> <span class="hljs-title function_">initState</span>(<span class="hljs-params"></span>) {
    bloc = <span class="hljs-title class_">BlocProvider</span>.<span class="hljs-property">of</span>&#x3C;<span class="hljs-title class_">DataBloc</span>>(context);
    <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">initState</span>();
  }

  @override
  <span class="hljs-title class_">Widget</span> <span class="hljs-title function_">build</span>(<span class="hljs-params">BuildContext context</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Scaffold</span>(
      <span class="hljs-attr">appBar</span>: <span class="hljs-title class_">AppBar</span>(<span class="hljs-attr">title</span>: <span class="hljs-keyword">const</span> <span class="hljs-title class_">Text</span>(<span class="hljs-string">'BLoC 페이지'</span>)),
      <span class="hljs-attr">body</span>: <span class="hljs-title class_">BlocBuilder</span>&#x3C;<span class="hljs-title class_">DataBloc</span>, <span class="hljs-title class_">DataState</span>>(
        <span class="hljs-attr">builder</span>: (context, state) {
          <span class="hljs-keyword">if</span> (state is <span class="hljs-title class_">Initial</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Center</span>(<span class="hljs-attr">child</span>: <span class="hljs-title class_">Text</span>(<span class="hljs-string">'버튼을 눌러주세요'</span>));
          }
          <span class="hljs-keyword">if</span> (state is <span class="hljs-title class_">Loading</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Center</span>(<span class="hljs-attr">child</span>: <span class="hljs-title class_">CircularProgressIndicator</span>());
          }
          <span class="hljs-keyword">if</span> (state is <span class="hljs-title class_">Success</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Center</span>(<span class="hljs-attr">child</span>: <span class="hljs-title class_">Text</span>(<span class="hljs-string">'성공'</span>));
          }
          <span class="hljs-keyword">return</span> <span class="hljs-title class_">Container</span>();
        },
      ),
      <span class="hljs-attr">floatingActionButton</span>: <span class="hljs-title class_">Column</span>(
        <span class="hljs-attr">crossAxisAlignment</span>: <span class="hljs-title class_">CrossAxisAlignment</span>.<span class="hljs-property">end</span>,
        <span class="hljs-attr">mainAxisAlignment</span>: <span class="hljs-title class_">MainAxisAlignment</span>.<span class="hljs-property">end</span>,
        <span class="hljs-attr">children</span>: &#x3C;<span class="hljs-title class_">Widget</span>>[
          <span class="hljs-title class_">FloatingActionButton</span>(
            <span class="hljs-attr">child</span>: <span class="hljs-keyword">const</span> <span class="hljs-title class_">Icon</span>(<span class="hljs-title class_">Icons</span>.<span class="hljs-property">play_arrow</span>),
            <span class="hljs-attr">onPressed</span>: <span class="hljs-function">() =></span> bloc.<span class="hljs-title function_">add</span>(<span class="hljs-title class_">FetchDataEvent</span>()),
          ),
        ],
      ),
    );
  }
}

그리고 <span class="hljs-title class_">Bloc</span> 결과입니다:

<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_12.png"</span> /></span></span>

## 장점
</code></pre>
<ul>
<li>애플리케이션의 상태를 언제든지 파악할 수 있습니다.</li>
<li>앱이 적절하게 응답하는지 확인하기 위해 모든 케이스를 쉽게 테스트할 수 있습니다.</li>
<li>애플리케이션에서 모든 사용자 상호 작용을 기록하여 데이터 기반 결정을 내릴 수 있습니다.</li>
<li>빠르고 반응성 있는 앱을 개발할 수 있습니다.</li>
<li>대규모 데이터 크기에 대해 더 나은 성능을 제공합니다.</li>
</ul>
<h2>단점</h2>
<ul>
<li>대형 애플리케이션을 가지고 있을 때만 효과적입니다.</li>
<li>두 방향으로 스트림을 사용해야 하므로 Provider보다 더 많은 보일러플레이트가 발생할 수 있습니다.</li>
<li>복잡한 시나리오에서는 너무 제한적일 수 있으며 하나의 입력과 출력만 다루는 BLoC를 생성할 수 있습니다.</li>
<li>특히 앱의 여러 부분에 유사한 비즈니스 로직을 구현해야할 경우 코드 중복으로 이어질 수 있습니다.</li>
</ul>
<h1>GetX</h1>
<ul>
<li>플러터에 대한 가벼우면서도 강력한 솔루션입니다. 고성능 상태 관리, 스마트한 의존성 주입, 라우트 관리를 빠르고 실용적으로 결합합니다.</li>
<li>성능과 자원 최소 소비에 중점을 둡니다. GetX는 Streams나 ChangeNotifier를 사용하지 않습니다.</li>
<li>사용하기 쉽고 즐거운 구문을 사용합니다.</li>
<li>뷰, 표현 로직, 비즈니스 로직, 의존성 주입, 네비게이션의 완전한 분리를 허용합니다.</li>
</ul>
<p>다음 이미지에서 모든 GetX 기능을 확인할 수 있습니다:</p>
<p><img src="/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_13.png" alt="GetX Functions"></p>
<p>하지만 우리에게 가장 중요한 것은 반응형 상태 관리자입니다.</p>
<h2>반응성 상태 관리자</h2>
<p>반응형 프로그래밍은 복잡하다고 말리기 때문에 많은 사람들을 멀리하곤 합니다. GetX는 반응형 프로그래밍을 꽤 간단하게 만들어 줍니다:</p>
<ul>
<li>StreamControllers를 만들 필요가 없습니다.</li>
<li>각 변수마다 StreamBuilder를 만들 필요가 없습니다.</li>
<li>각 상태마다 클래스를 만들 필요가 없습니다.</li>
<li>초기 값에 대한 get을 만들 필요가 없습니다.</li>
</ul>
<p>이름 변수가 있고 이 변수를 변경할 때마다 사용하는 모든 위젯이 자동으로 변경되기를 원한다고 상상해 봅시다.</p>
<p>여기 당신의 계수 변수가 있어요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">'Jonatas Borges'</span>;
</code></pre>
<p>이를 관찰 가능하도록 만들기 위해서는 그 뒤에 ".obs"를 추가하기만 하면 돼요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">'Jonatas Borges'</span>.<span class="hljs-property">obs</span>;
</code></pre>
<p>UI에서 해당 값이 표시되고 값이 변경될 때 화면을 업데이트하려면 다음과 같이 하면 됩니다:</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Obx</span>(<span class="hljs-function">() =></span> <span class="hljs-title class_">Text</span>(<span class="hljs-string">"${controller.name}"</span>));
</code></pre>
<p>단순합니다.</p>
<p>이제 코드로 넘어갑니다. GetX에서 Controller가 정의됩니다. 이 경우 GetxController를 확장한 Controller 클래스를 만듭니다.</p>
<pre><code class="hljs language-js">열거형 <span class="hljs-title class_">Status</span> {
  초기,
  로딩,
  성공,
}
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Controller</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">GetxController</span> {
  <span class="hljs-comment">// GetX는 반응형이기 때문에 변수가 변경되면 자동으로 화면에서 변경됩니다.</span>
  <span class="hljs-comment">// 변수 앞에 ".obs"를 추가하기만 하면 이미 반응형입니다.</span>
  <span class="hljs-keyword">var</span> state = <span class="hljs-title class_">Status</span>.<span class="hljs-property">initial</span>.<span class="hljs-property">obs</span>;

  <span class="hljs-comment">/// 컨트롤러의 상태를 업데이트합니다. 이 방법이 컨트롤러를 외부에서 수정하는 유일한 방법입니다.</span>
  <span class="hljs-keyword">void</span> <span class="hljs-title function_">fetchData</span>() <span class="hljs-keyword">async</span> {
    state.<span class="hljs-property">value</span> = <span class="hljs-title class_">Status</span>.<span class="hljs-property">loading</span>;
    <span class="hljs-comment">//update();</span>

    <span class="hljs-keyword">await</span> <span class="hljs-title class_">Future</span>.<span class="hljs-title function_">delayed</span>(<span class="hljs-keyword">const</span> <span class="hljs-title class_">Duration</span>(<span class="hljs-attr">seconds</span>: <span class="hljs-number">2</span>));

    state.<span class="hljs-property">value</span> = <span class="hljs-title class_">Status</span>.<span class="hljs-property">success</span>;
  }
}
</code></pre>
<p>UI에서 우리는 GetXPage가 있습니다. 그 안에는 간단한 HomeGetX 위젯이 자식으로 있습니다. 이 방식으로 정의되었는데, Provider 및 Bloc과의 차이를 보려고 했습니다. Provider나 Bloc을 자식 위젯에 제공하기 위해 ChangeNotifierProvider나 BlocProvider의 부모 위젯을 정의해야 했던 과정과의 차이점을 볼 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GetXPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">StatelessWidget</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> route = <span class="hljs-string">'getx-page'</span>;

  <span class="hljs-keyword">const</span> <span class="hljs-title class_">GetXPage</span>({key}) : <span class="hljs-variable language_">super</span>(<span class="hljs-attr">key</span>: key);

  @override
  <span class="hljs-title class_">Widget</span> <span class="hljs-title function_">build</span>(<span class="hljs-params">BuildContext context</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">HomeGetX</span>();
  }
}
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HomeGetX</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">StatefulWidget</span> {
  <span class="hljs-keyword">const</span> <span class="hljs-title class_">HomeGetX</span>({<span class="hljs-variable language_">super</span>.<span class="hljs-property">key</span>});

  @override
  <span class="hljs-title class_">State</span>&#x3C;<span class="hljs-title class_">HomeGetX</span>> <span class="hljs-title function_">createState</span>() => <span class="hljs-title function_">_HomeGetXState</span>();
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">_HomeGetXState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">State</span>&#x3C;<span class="hljs-title class_">HomeGetX</span>> {
  late <span class="hljs-title class_">Controller</span> c;

  @override
  <span class="hljs-keyword">void</span> <span class="hljs-title function_">initState</span>(<span class="hljs-params"></span>) {
    c = <span class="hljs-title class_">Get</span>.<span class="hljs-title function_">put</span>(<span class="hljs-title class_">Controller</span>());
    <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">initState</span>();
  }

  @override
  <span class="hljs-title class_">Widget</span> <span class="hljs-title function_">build</span>(<span class="hljs-params">BuildContext context</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Scaffold</span>(
      <span class="hljs-attr">appBar</span>: <span class="hljs-title class_">AppBar</span>(<span class="hljs-attr">title</span>: <span class="hljs-keyword">const</span> <span class="hljs-title class_">Text</span>(<span class="hljs-string">'GetX Page'</span>)),
      <span class="hljs-comment">//최상위에 Consumer 위젯을 가능한 깊게 두는 것이 가장 좋습니다.</span>
      <span class="hljs-comment">//어딘가의 세부 사항이 변경되었기 때문에 UI의 큰 부분을 다시 빌드하고 싶지 않습니다.</span>
      <span class="hljs-attr">body</span>: <span class="hljs-title class_">GetX</span>&#x3C;<span class="hljs-title class_">Controller</span>>(
        <span class="hljs-attr">builder</span>: (context) {
          <span class="hljs-keyword">if</span> (c.<span class="hljs-property">state</span>.<span class="hljs-property">value</span> == <span class="hljs-title class_">Status</span>.<span class="hljs-property">initial</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Center</span>(<span class="hljs-attr">child</span>: <span class="hljs-title class_">Text</span>(<span class="hljs-string">'Press the Button'</span>));
          }
          <span class="hljs-keyword">if</span> (c.<span class="hljs-property">state</span>.<span class="hljs-property">value</span> == <span class="hljs-title class_">Status</span>.<span class="hljs-property">loading</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Center</span>(<span class="hljs-attr">child</span>: <span class="hljs-title class_">CircularProgressIndicator</span>());
          }
          <span class="hljs-keyword">if</span> (c.<span class="hljs-property">state</span>.<span class="hljs-property">value</span> == <span class="hljs-title class_">Status</span>.<span class="hljs-property">success</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Center</span>(<span class="hljs-attr">child</span>: <span class="hljs-title class_">Text</span>(<span class="hljs-string">'Success'</span>));
          }
          <span class="hljs-keyword">return</span> <span class="hljs-title class_">Container</span>();
        },
      ),
      <span class="hljs-attr">floatingActionButton</span>: <span class="hljs-title class_">Column</span>(
        <span class="hljs-attr">crossAxisAlignment</span>: <span class="hljs-title class_">CrossAxisAlignment</span>.<span class="hljs-property">end</span>,
        <span class="hljs-attr">mainAxisAlignment</span>: <span class="hljs-title class_">MainAxisAlignment</span>.<span class="hljs-property">end</span>,
        <span class="hljs-attr">children</span>: &#x3C;<span class="hljs-title class_">Widget</span>>[
          <span class="hljs-title class_">FloatingActionButton</span>(
            <span class="hljs-attr">child</span>: <span class="hljs-keyword">const</span> <span class="hljs-title class_">Icon</span>(<span class="hljs-title class_">Icons</span>.<span class="hljs-property">play_arrow</span>),
            <span class="hljs-attr">onPressed</span>: <span class="hljs-function">() =></span> c.<span class="hljs-title function_">fecthData</span>(),
          ),
        ],
      ),
    );
  }
}
</code></pre>
<p>결과는 다음과 같습니다:</p>
<h2>장점</h2>
<ul>
<li>몇 줄의 코드로 작성된 간단한 상태 업데이터입니다. 최소한의 CPU 영향을 주도록 단순하게 만들었고, 단일 목적을 충족하고 가능한 한 최소한의 리소스를 사용하기 위해 제작되었습니다.</li>
<li>강력한 상태 관리자이며 변수가 아닌 흐름(Flow)으로 작동하며, 내부적으로는 모든 것이 스트림(Stream)입니다.</li>
<li>코드 생성기나 장식품(Decoration) 없이도 실제로 BLoC 접근 방식입니다. .obs를 사용하여 모든 것을 "Observable"로 변환할 수 있습니다.</li>
</ul>
<h2>단점</h2>
<ul>
<li>문제들이 많이 발생할 수 있으며 중복될 수도 있습니다. 문제 해결, 답변, 태깅, 중복 제거 등에 대해 아무도 관심을 가지지 않는 것이 분명합니다.</li>
<li>GetX가 너무 많은 작업을 수행하고 이 프로젝트가 단 한 사람에게는 너무 큽니다.</li>
<li>핫 리로드 문제 - GetX는 자체 종속성 주입 시스템을 가지고 있으며, 이는 GetX 모듈의 거의 모든 곳에서 사용되지만 아직 안정적이지 않습니다.</li>
<li>GetX로 단위 및 위젯 테스트를 작성하는 것은 정말 어렵고 몇 가지 경우에는 일부 기능을 테스트하는 것이 불가능합니다.</li>
</ul>
<h1>Riverpod</h1>
<ul>
<li>Provider와 유사하며 컴파일 안전성과 테스트 가능성을 갖추고 있습니다.</li>
<li>Riverpod은 Provider에서 영감을 받았지만 동일한 유형의 여러 공급자 지원; 비동기 공급자 대기; 어디서든 공급자 추가와 같은 주요 문제들을 해결합니다.</li>
<li>이제 main.dart와 UI 파일 간에 이동할 필요가 없어졌습니다.</li>
<li>공유 상태 코드를 필요한 곳에 배치하고, 별도의 패키지에 있든 위젯 옆에 있든 테스트 가능성을 잃지 않고 유지하세요.</li>
</ul>
<p>Providers는 Riverpod 앱의 가장 중요한 요소입니다. Provider는 상태 조각을 캡슐화하고 해당 상태를 청취할 수 있는 개체입니다.</p>
<pre><code class="hljs language-js">enum <span class="hljs-title class_">Status</span> {
  initial,
  loading,
  success,
}
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RiverpodProvider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">StateNotifier</span>&#x3C;<span class="hljs-title class_">Status</span>> {
  <span class="hljs-title class_">RiverpodProvider</span>() : <span class="hljs-variable language_">super</span>(<span class="hljs-title class_">Status</span>.<span class="hljs-property">initial</span>);

  <span class="hljs-title class_">Future</span>&#x3C;<span class="hljs-keyword">void</span>> <span class="hljs-title function_">fetchData</span>() <span class="hljs-keyword">async</span> {
    state = <span class="hljs-title class_">Status</span>.<span class="hljs-property">loading</span>;

    <span class="hljs-keyword">await</span> <span class="hljs-title class_">Future</span>.<span class="hljs-title function_">delayed</span>(<span class="hljs-keyword">const</span> <span class="hljs-title class_">Duration</span>(<span class="hljs-attr">seconds</span>: <span class="hljs-number">2</span>));

    state = <span class="hljs-title class_">Status</span>.<span class="hljs-property">success</span>;
  }
}

final riverpodProvider =
    <span class="hljs-title class_">StateNotifierProvider</span>.<span class="hljs-title function_">autoDispose</span>(<span class="hljs-function">(<span class="hljs-params">ref</span>) =></span> <span class="hljs-title class_">RiverpodProvider</span>());
</code></pre>
<p>UI에서 다음과 같이 하고 있습니다:</p>
<pre><code class="hljs language-dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RiverpodPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> route = <span class="hljs-string">'riverpod-page'</span>;

  <span class="hljs-keyword">const</span> RiverpodPage({<span class="hljs-keyword">super</span>.key});

  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">const</span> ProviderScope(
      child: HomeRiverpod(),
    );
  }
}
</code></pre>
<p>위젯이 프로바이더를 읽을 수 있도록 하려면 전체 애플리케이션을 "ProviderScope" 위젯으로 감싸야 합니다. 이곳에는 프로바이더의 상태가 저장됩니다.</p>
<pre><code class="hljs language-dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomeRiverpod</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConsumerWidget</span> </span>{
  <span class="hljs-keyword">const</span> HomeRiverpod({<span class="hljs-keyword">super</span>.key});

  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context, WidgetRef ref) {
    <span class="hljs-keyword">final</span> data = ref.read(riverpodProvider.notifier);

    <span class="hljs-keyword">return</span> Scaffold(
      appBar: AppBar(title: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">'Riverpod Page'</span>)),
      <span class="hljs-comment">// 소비자 위젯을 가능한 깊게 트리 안에 배치하는 것이 가장 좋습니다.</span>
      <span class="hljs-comment">// 어딘가의 세부 사항이 변경되었을 때 UI의 큰 부분을 다시 빌드하고 싶지 않습니다.</span>
      body: Consumer(
        builder: (context, ref, child) {
          <span class="hljs-keyword">final</span> state = ref.watch(riverpodProvider);
          <span class="hljs-keyword">if</span> (state == Status.initial) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">const</span> Center(child: Text(<span class="hljs-string">'Press the Button'</span>));
          }
          <span class="hljs-keyword">if</span> (state == Status.loading) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">const</span> Center(child: CircularProgressIndicator());
          }
          <span class="hljs-keyword">if</span> (state == Status.success) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">const</span> Center(child: Text(<span class="hljs-string">'Success'</span>));
          }
          <span class="hljs-keyword">return</span> Container();
        },
      ),
      floatingActionButton: Column(
        crossAxisAlignment: CrossAxisAlignment.end,
        mainAxisAlignment: MainAxisAlignment.end,
        children: &#x3C;Widget>[
          FloatingActionButton(
            child: <span class="hljs-keyword">const</span> Icon(Icons.play_arrow),
            onPressed: () => data.fetchData(),
          ),
        ],
      ),
    );
  }
}
</code></pre>
<h2>제공자들과 상호 작용하는 ref 사용하기</h2>
<p>"ref"를 사용하는 주요 용도는 다음과 같습니다:</p>
<ul>
<li>ref.watch를 사용하여 제공자의 값을 얻고 변경 사항을 청취하는 것입니다. 값이 변경되면 해당 위젯이나 제공자가 다시 빌드되는 기능입니다.</li>
<li>ref.listen을 사용하여 제공자에서 리스너를 추가하여 해당 제공자가 변경될 때 새 페이지로 이동하거나 모달을 표시하는 등의 동작을 실행하는 것입니다.</li>
<li>ref.read를 사용하여 변경 사항을 무시하고 제공자의 값을 얻는 것입니다. "클릭"과 같은 이벤트에서 제공자의 값을 필요로 할 때 유용합니다.</li>
</ul>
<p>이 결과는 다음과 같습니다:</p>
<p>빠른 대답을 위해 노력중입니다!</p>
<ul>
<li>Riverpod은 앱에서 상태를 구현하는 데 너무 많은 자유를 제공합니다. 이는 새로운 개발자들에게 가장 좋은 접근 방식을 선택하는 데 어려움을 줄 수 있습니다.</li>
<li>공유 상태를 위젯 트리 전체에 분산시키는 나쁜 안티패턴을 촉진합니다. 이는 코드가 매우 찾기 어렵도록 (중앙화되지 않음) 하고, Provider 간에 과도한 의존성 체인과 결합으로 디버깅을 추적하기 어렵게 만들 수 있습니다.</li>
</ul>
<h1>GetIt</h1>
<p>GetIt은 상태 관리 솔루션이 아닙니다! 객체의 로케이터이므로 스트림이나 ValueNotifiers와 같은 다른 방법을 사용하여 UI에 변경을 알릴 필요가 있습니다. 그러나 get_it_mixin과 함께 사용하면 get_it에 등록된 객체와 통합되는 완전한 기능의 쉬운 상태 관리 솔루션이 됩니다.</p>
<p>GetIt은:</p>
<ul>
<li>극히 빠름</li>
<li>배우고 사용하기 쉬움</li>
<li>Provider나 Redux처럼 데이터에 액세스하기 위해 특별한 위젯을 UI 트리에 추가하지 않음</li>
</ul>
<p>저희의 구현은 다음과 같습니다:</p>
<pre><code class="hljs language-js">enum <span class="hljs-title class_">Status</span> {
  initial,
  loading,
  success,
}
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GetItProvider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">ChangeNotifier</span> {
  <span class="hljs-comment">/// GetItProvider의 내부 및 비공개 상태입니다.</span>
  <span class="hljs-title class_">Status</span> _state = <span class="hljs-title class_">Status</span>.<span class="hljs-property">initial</span>;

  <span class="hljs-comment">/// GetItProvider의 상태입니다.</span>
  <span class="hljs-title class_">Status</span> get state => _state;

  <span class="hljs-comment">/// GetItProvider의 상태를 업데이트합니다. 이는 외부에서 GetItProvider를 수정하는 유일한 방법입니다.</span>
  <span class="hljs-keyword">void</span> <span class="hljs-title function_">fecthData</span>() <span class="hljs-keyword">async</span> {
    _state = <span class="hljs-title class_">Status</span>.<span class="hljs-property">loading</span>;
    <span class="hljs-comment">// 이 호출은 이 모델을 듣고 있는 위젯에게 다시 빌드하도록 지시합니다.</span>
    <span class="hljs-title function_">notifyListeners</span>();

    <span class="hljs-keyword">await</span> <span class="hljs-title class_">Future</span>.<span class="hljs-title function_">delayed</span>(<span class="hljs-keyword">const</span> <span class="hljs-title class_">Duration</span>(<span class="hljs-attr">seconds</span>: <span class="hljs-number">2</span>));

    _state = <span class="hljs-title class_">Status</span>.<span class="hljs-property">success</span>;
    <span class="hljs-title function_">notifyListeners</span>();
  }
}
</code></pre>
<p>만약 주목했다면, GetItProvider가 Provider를 검토할 때 우리가 구현한 DataProvider와 동일하다는 것을 알 수 있어요.</p>
<p>객체에 액세스하기 전에는 GetIt에 그들을 등록해야 합니다. 보통 initState 코드 내에서 직접 등록합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GetItPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">StatefulWidget</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> route = <span class="hljs-string">'get-it-page'</span>;

  <span class="hljs-keyword">const</span> <span class="hljs-title class_">GetItPage</span>({<span class="hljs-variable language_">super</span>.<span class="hljs-property">key</span>});

  @override
  <span class="hljs-title class_">State</span>&#x3C;<span class="hljs-title class_">GetItPage</span>> <span class="hljs-title function_">createState</span>() => <span class="hljs-title function_">_GetItPageState</span>();
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">_GetItPageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">State</span>&#x3C;<span class="hljs-title class_">GetItPage</span>> {
  @override
  <span class="hljs-keyword">void</span> <span class="hljs-title function_">initState</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">//시작할 때 모든 객체를 등록합니다.</span>
    <span class="hljs-comment">//나중에 액세스하려는 객체들을 이렇게 등록하세요:</span>
    <span class="hljs-title class_">GetIt</span>.<span class="hljs-property">I</span>.<span class="hljs-property">registerSingleton</span>&#x3C;<span class="hljs-title class_">GetItProvider</span>>(<span class="hljs-title class_">GetItProvider</span>());
    <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">initState</span>();
  }

  @override
  <span class="hljs-title class_">Widget</span> <span class="hljs-title function_">build</span>(<span class="hljs-params">BuildContext context</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">HomeGetIt</span>();
  }
}
</code></pre>
<p>GetIt로 데이터를 읽는 것은 이미 간단합니다. 하지만 mixin을 추가하면 더욱 쉬워집니다. StatelessWidget에 GetItMixin을 추가하고 get<code>T</code>를 호출하면 됩니다:</p>
<pre><code class="hljs language-dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomeGetIt</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> <span class="hljs-title">with</span> <span class="hljs-title">GetItMixin</span> </span>{
  HomeGetIt({<span class="hljs-keyword">super</span>.key});

  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-comment">// 보기 쉽게! view 가 rebuild 되기를 원할 때는 watchOnly 를 호출하여 상태가 변경될 때마다 알려줄 수 있습니다:</span>
    <span class="hljs-keyword">final</span> state =
        watchOnly((GetItProvider getItProvider) => getItProvider.state);

    <span class="hljs-keyword">return</span> Scaffold(
      appBar: AppBar(title: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">'GetIt 페이지'</span>)),
      body: Builder(
        builder: (context) {
          <span class="hljs-keyword">if</span> (state == Status.initial) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">const</span> Center(child: Text(<span class="hljs-string">'버튼을 눌러보세요'</span>));
          }
          <span class="hljs-keyword">if</span> (state == Status.loading) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">const</span> Center(child: CircularProgressIndicator());
          }
          <span class="hljs-keyword">if</span> (state == Status.success) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">const</span> Center(child: Text(<span class="hljs-string">'성공'</span>));
          }
          <span class="hljs-keyword">return</span> Container();
        },
      ),
      floatingActionButton: Column(
        crossAxisAlignment: CrossAxisAlignment.end,
        mainAxisAlignment: MainAxisAlignment.end,
        children: &#x3C;Widget>[
          FloatingActionButton(
            child: <span class="hljs-keyword">const</span> Icon(Icons.play_arrow),
            <span class="hljs-comment">// 이후 아래와 같이 GetItProvider 클래스에 접근할 수 있습니다:</span>
            onPressed: () => <span class="hljs-keyword">get</span>&#x3C;GetItProvider>().fecthData(),
          ),
        ],
      ),
    );
  }
}
</code></pre>
<p>보통 데이터 원본 타입에 대한 다양한 watch 메서드가 있습니다. ChangeNotifier, ValueNotifier, Stream 및 Future를 포함합니다.</p>
<p>watch 메서드의 주요 이점은 ValueListenableBuilders, StreamBuilder 등을 사용하지 않아도 된다는 것입니다. 각 바인딩마다 한 줄만 사용되며 중첩이 없으므로 가독성이 좋습니다.</p>
<p><img src="/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_16.png" alt="alt text"></p>
<h2>장점</h2>
<ul>
<li>간단하고 사용하기 쉽며, Flutter에 의존하지 않아서 모든 Dart 코드와 함께 사용할 수 있습니다.</li>
<li>매우 빠르고 배우기/사용하기 쉽습니다. UI 트리를 특별한 위젯으로 엮지 않고 데이터에 액세스할 수 있습니다.</li>
</ul>
<h2>단점</h2>
<ul>
<li>위젯 트리의 본질적인 부분이 아니기 때문에 항목을 수동으로 폐기하거나 등록 해제해야 할 수도 있습니다.</li>
<li>동일한 형식의 인스턴스를 제공하는 문제가 있지만 등록할 때 이름 필드를 노출하기 때문에 문제에 대한 합리적인 해결책을 제공합니다.</li>
<li>GetIt 싱글톤의 전역적인 성격을 선호하지 않는 개발자들도 있을 수 있으며, 이는 riverpod나 Provider의 더 제한적인 스코핑 모델을 선호할 수도 있습니다. 다른 개발자들은 이것을 이점으로 생각할 수도 있습니다.</li>
</ul>
<h1>MobX</h1>
<p>MobX는 응용 프로그램의 반응형 데이터와 UI를 간단히 연결하는 상태 관리 라이브러리입니다. 이 연결은 완전히 자동적이며 매우 자연스럽게 느껴집니다. 응용 프로그램 개발자는 UI에서 (그리고 다른 곳에서) 소비해야 하는 반응형 데이터에 순수하게 집중할 뿐, 두 가지를 동기화할 필요없이 고민할 필요가 없습니다.</p>
<p>실제로 마법은 아니지만, 소비되는 것(observable)과 어디에서(reactions) 소비되는지에 관한 지혜가 있으며, 이를 자동으로 추적합니다. observable이 변경되면 모든 reactions가 다시 실행됩니다. 흥미로운 점은 이러한 reactions가 간단한 콘솔 로그에서 네트워크 호출 또는 UI 다시 렌더링까지 모두 될 수 있다는 것입니다.</p>
<p>MobX의 핵심에는 Observables, Actions 및 Reactions이라는 세 가지 중요한 개념이 있습니다.</p>
<p><img src="/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_17.png" alt="image"></p>
<h2>Observables</h2>
<ul>
<li>Observables는 응용 프로그램의 반응형 상태를 나타냅니다. 단순 스칼라부터 복잡한 객체 트리까지 될 수 있습니다. 응용 프로그램의 상태를 Observables 트리로 정의함으로써, 반응형 상태 트리를 노출하여 UI(또는 응용 프로그램의 다른 관찰자)에서 사용할 수 있습니다.</li>
</ul>
<h2>작업</h2>
<ul>
<li>작업은 옵저버를 변이시키는 방법입니다. 직접 변이시키는 대신 작업은 변이에 의미를 부여합니다. 예를 들어 value++를 하는 대신 increment() 작업을 실행하면 더 많은 의미가 전달됩니다. 또한, 작업은 모든 알림을 일괄 처리하고 변경 사항은 완료된 후에만 알림을 보내도록 보장합니다. 따라서 옵저버는 작업의 원자적 완료 후에만 알림을 받습니다.</li>
</ul>
<h2>반응</h2>
<ul>
<li>반응은 MobX의 옵저버, 작업 및 반응의 삼합체를 완성합니다. 이들은 반응형 시스템의 옵저버이며 추적 중인 옵저버가 변경될 때마다 알림을 받습니다. 반응에는 아래에 나열된 몇 가지 종류가 있습니다. 이들은 모두 ReactionDisposer를 반환하며, 이는 반응을 폐기하기 위해 호출할 수 있는 함수입니다. 반응의 두드러진 특징 중 하나는 옵저버를 명시적으로 연결하지 않아도 자동으로 모든 옵저버를 추적한다는 것입니다. 반응 내에서 옵저버를 읽는 행위만으로도 추적이 가능합니다!</li>
</ul>
<p>MobX의 스토어는 관련 observable 상태를 하나의 클래스 아래에 수집하는 방법입니다. 이 스토어를 사용하면 주석을 사용하고 코드를 간단하게 유지할 수 있습니다.</p>
<pre><code class="hljs language-js">enum <span class="hljs-title class_">Status</span> {
  initial,
  loading,
  success,
}
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">// 이것은 코드베이스의 나머지 부분에서 사용되는 클래스입니다.</span>
<span class="hljs-comment">// ignore: library_private_types_in_public_api</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">DataStore</span> = _DataStore <span class="hljs-keyword">with</span> _$DataStore;

<span class="hljs-comment">// 스토어 클래스</span>
abstract <span class="hljs-keyword">class</span> <span class="hljs-title class_">_DataStore</span> <span class="hljs-keyword">with</span> <span class="hljs-title class_">Store</span> {
  @observable
  <span class="hljs-title class_">Status</span> state = <span class="hljs-title class_">Status</span>.<span class="hljs-property">initial</span>;

  @action
  <span class="hljs-title class_">Future</span>&#x3C;<span class="hljs-keyword">void</span>> <span class="hljs-title function_">fetchData</span>() <span class="hljs-keyword">async</span> {
    state = <span class="hljs-title class_">Status</span>.<span class="hljs-property">loading</span>;

    <span class="hljs-keyword">await</span> <span class="hljs-title class_">Future</span>.<span class="hljs-title function_">delayed</span>(<span class="hljs-keyword">const</span> <span class="hljs-title class_">Duration</span>(<span class="hljs-attr">seconds</span>: <span class="hljs-number">2</span>));

    state = <span class="hljs-title class_">Status</span>.<span class="hljs-property">success</span>;
  }
}
</code></pre>
<p>주석을 사용하여 클래스의 observable 속성을 표시하는 방법에 유의하십시오. 주석은 mobx_codgen 패키지를 통해 사용할 수 있습니다.</p>
<p>여기서 흥미로운 부분은:</p>
<ul>
<li>Store mixin을 포함하는 추상 클래스 _DataStore입니다. 모든 스토어 관련 코드는 이 추상 클래스 내에 배치되어야 합니다. build_runner에서 코드를 조합하기 위해 DataStore 클래스를 생성합니다.</li>
<li>생성된 코드는 part 파일인 data_store.g.dart에 포함됩니다. 이를 part 지시문으로 포함해야 build_runner가 출력물을 생성합니다. 생성된 파일에는 _$DataStore mixin이 포함됩니다.</li>
<li>값을 observable로 표시하는 @observable 어노테이션.</li>
<li>increment() 메서드를 action으로 표시하기 위한 @action 사용.</li>
</ul>
<p>프로젝트 폴더 내에서 다음 명령을 실행하세요. 이는 counter.g.dart에 코드를 생성하며, 이미 part 파일로 포함해 두었습니다.</p>
<pre><code class="hljs language-js">flutter pub run build_runner build
</code></pre>
<p>이제 UI를 살펴보겠습니다:</p>
<pre><code class="hljs language-js">final dataStore = <span class="hljs-title class_">DataStore</span>(); <span class="hljs-comment">// 스토어를 인스턴스화합니다.</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MobXPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">StatelessWidget</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> route = <span class="hljs-string">'mobx-page'</span>;

  <span class="hljs-keyword">const</span> <span class="hljs-title class_">MobXPage</span>({<span class="hljs-title class_">Key</span> key}) : <span class="hljs-variable language_">super</span>(<span class="hljs-attr">key</span>: key);

  @override
  <span class="hljs-title class_">Widget</span> <span class="hljs-title function_">build</span>(<span class="hljs-params">BuildContext context</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">HomeMobX</span>();
  }
}
</code></pre>
<p>Observer 위젯(flutter_mobx의 일부)은 빌더 함수에서 사용된 observables의 세부적인 옵저버를 제공합니다. 이러한 observables이 변경될 때마다 Observer가 다시 빌드되고 렌더링됩니다.</p>
<pre><code class="hljs language-dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomeMobX</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-keyword">const</span> HomeMobX({<span class="hljs-keyword">super</span>.key});

  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-keyword">return</span> Scaffold(
      appBar: AppBar(title: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">'MobX 페이지'</span>)),
      <span class="hljs-comment">// 가능한 깊은 곳에 Consumer 위젯을 배치하는 것이 가장 좋습니다.</span>
      <span class="hljs-comment">// 어딘가의 세부 사항이 변경되어도 대규모 UI의 큰 부분을 다시 빌드하고 싶지 않을 것입니다.</span>
      body: Observer(
        builder: (_) {
          <span class="hljs-keyword">if</span> (dataStore.state == Status.initial) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">const</span> Center(child: Text(<span class="hljs-string">'버튼을 눌러주세요'</span>));
          }
          <span class="hljs-keyword">if</span> (dataStore.state == Status.loading) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">const</span> Center(child: CircularProgressIndicator());
          }
          <span class="hljs-keyword">if</span> (dataStore.state == Status.success) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">const</span> Center(child: Text(<span class="hljs-string">'성공'</span>));
          }
          <span class="hljs-keyword">return</span> Container();
        },
      ),
      floatingActionButton: Column(
        crossAxisAlignment: CrossAxisAlignment.end,
        mainAxisAlignment: MainAxisAlignment.end,
        children: &#x3C;Widget>[
          FloatingActionButton(
            child: <span class="hljs-keyword">const</span> Icon(Icons.play_arrow),
            onPressed: () => dataStore.fecthData(),
          ),
        ],
      ),
    );
  }
}
</code></pre>
<p>그 결과는:</p>
<h2>장점</h2>
<ul>
<li>반응형 앱 데이터를 UI와 쉽게 연결할 수 있습니다.</li>
<li>학습을 쉽게하는 친숙한 구문과 간단한 핵심 API를 사용하여 옵저버 패턴을 구현합니다.</li>
<li>크고 복잡한 프로젝트에서 사용할 수 있으며 확장 가능합니다.</li>
<li>성능이 좋고 테스트하기 쉽습니다.</li>
<li>코드 생성 덕분에 보일러플레이트를 줄일 수 있습니다.</li>
</ul>
<h2>단점</h2>
<ul>
<li>코드 생성에 시간이 걸리고 상태 변경 시마다 코드 생성기를 실행해야 할 수도 있습니다.</li>
<li>상태가 변경될 때 어떤 이벤트가 그것을 일으킨 것인지 파악하기 어려울 수 있습니다. 복잡한 앱에서 이러한 추적 불가능성은 디버깅과 상태 관리를 어렵게 만들 수 있습니다.</li>
<li>Mobx 생성기는 단순성을 높이는 데 좋지만 동시에 추상화 수준을 추가합니다. 이는 내부 작업을 실제로 보고 이해하기 어렵게 만듭니다.</li>
</ul>
<h1>결론</h1>
<ul>
<li>상태 관리는 가장 중요한 측면 중 하나입니다. 이는 사용자가 UI에 가한 모든 변경 사항을 추적하는 방법입니다.</li>
<li>Flutter의 상태 관리 라이브러리들은 상태 변경의 유형과 상관없이 애플리케이션을 개발하고 관리하기 쉽게 만들어 줍니다.</li>
<li>올바른 Flutter 상태 관리자를 선택하는 것은 사용하는 것만큼 중요합니다. 상태 관리자의 선택지는 다양하지만, 어떤 것을 사용할지 선택하는 것은 우리에게, 우리의 취향에, 편안한 느낌에, 또한 프로젝트 유형, 요구 사항에 달려 있습니다. 작은 프로젝트인 경우 한 가지 접근 방식을 사용할 수 있고, 확장 가능한 프로젝트를 만들고 싶다면 다른 접근 방식을 사용할 수 있습니다.</li>
</ul>
<p>마침내 기대하던 것, 여기에서 전체 예제를 찾을 수 있습니다:</p>
<p>마음에 든다면 커피 한 잔 사주세요!</p>
<p><img src="/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_20.png" alt="이미지"></p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Flutter 상태 관리 비교 Provider, BLoC, GetX, Riverpod, GetIt, 그리고 MobX","description":"","date":"2024-06-21 23:25","slug":"2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX","content":"\n\n본 기사에서는 상태 관리의 일반적인 개요를 검토한 후 가장 흥미로운 상태 관리 방법인 Provider, BLoC, GetX, Riverpod, GetIt, 그리고 MobX를 살펴보겠습니다.\n\n![image](/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_0.png)\n\n# 일반적인 개요\n\n모바일 앱을 개발하는 동안, 화면 간이나 전체 앱을 통해 앱 상태를 공유해야 하는 시점이 찾아옵니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_1.png\" /\u003e\n\n이 예에서는 MyLoginScreen, MyCatalog 및 MyCart의 3 개 화면이 있습니다. MyCatalog에서는 제품이 이미 쇼핑 카트에 있는지 확인하기 위해 애플리케이션의 상태를 알아야 합니다. 그리고 MyCart에서는 추가된 모든 제품과 총 구매액을 보고 싶습니다. 두 화면 모두 카트의 상태를 알아야 합니다. 이것은 애플리케이션 상태의 예시이며, 나중에 자세히 검토할 예정입니다.\n\n- Android 또는 iOS 개발에서 추측할 수 있는 많은 가정이 Flutter에는 해당하지 않습니다. 예를 들어, Flutter에서 UI의 일부를 수정하는 대신 처음부터 다시 빌드하는 것은 괜찮습니다. Flutter는 이를 수행할 만큼 충분히 빠릅니다. 필요하다면 매 프레임마다 가능합니다.\n- Flutter는 선언적입니다. 이것은 Flutter가 현재 상태 애플리케이션을 반영하기 위해 UI를 빌드한다는 것을 의미합니다.\n- 예를 들어 앱 상태가 변경되면, 예를 들어 설정 화면이 있고 사용자가 스위치를 누르는 경우, 그것은 상태를 변경하고 이것은 UI 디자인을 트리거합니다. 이것은 명령형 UI 변경이 아니며, 변경되는 것은 상태이며 UI는 처음부터 다시 빌드됩니다.\n- UI 프로그래밍의 선언적 스타일에는 많은 이점이 있습니다. 모든 상태에 대해 UI가 어떻게 보이는지 설명하고 한 번만 설명하면 됩니다.\n\n\u003cimg src=\"/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_2.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Transient State와 앱 상태의 차이점\n\n![이미지](/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_3.png)\n\n앱 상태는 응용 프로그램이 실행 중일 때 메모리에 있는 모든 요소를 포함합니다. 이는 자산, 변수, 애니메이션 상태, 글ꔼ자 등을 포함합니다.\n\n우리가 관리하는 상태는 일시적인 상태와 앱 상태로 나뉠 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 일시적 상태\n\n단일 위젯을 포함할 수 있는 상태입니다. 예를 들어:\n\n- 위젯에서 현재 페이지\n- 애니메이션의 진행 상황\n- BottomNavigationBar에서 선택한 탭\n\n다시 말해, 이 유형의 상태에서는 상태 관리 기술을 사용할 필요가 없습니다. 필요한 것은 StatefulWidget뿐입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 앱 상태\n\n당연히, 이것은 일시적이지 않은 상태이며 응용 프로그램의 여러 부분에서 공유하고 사용자 세션 사이에서 유지하고 싶은 상태입니다. 응용 프로그램 상태의 예시:\n\n- 사용자의 선호도\n- 로그인 정보\n- 전자 상거래 응용 프로그램의 쇼핑 카트\n\n여기서 우리는 상태 관리가 필요할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희가 모든 상태 관리를 위해 개발할 예제를 보여드리겠습니다.\n\n![이미지](/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_4.png)\n\n# Provider\n\n만약 플러터를 처음 시작하시는 초보자이고 다른 접근 방식을 선택할 확실한 이유가 없다면, 아마도 이 접근 방식부터 시작하는 것이 좋을 것입니다. Provider 패키지는 이해하기 쉽고 코드 양이 많지 않습니다. 또한 다른 접근 방식에서 사용되는 개념을 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앱에는 MyCart 및 MyCatalog 위젯으로 나타낸 카탈로그 및 장바구니라는 두 개의 별도 화면이 있습니다. 카탈로그 화면에는 앱 바와 항목 목록이 포함되어 있습니다.\n\n우리는 몇 가지 위젯이 있습니다. 그 중 많은 위젯이 다른 위치에 \"소속된\" 상태에 액세스해야 합니다. 예를 들어, 카탈로그의 각 항목은 장바구니에 추가할 수 있습니다. 현재 표시된 항목이 이미 장바구니에 있는지 확인하려고 할 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이로써 첫 번째 질문으로 이어집니다: 장바구니의 현재 상태를 어디에 두어야 할까요?\n\n- 플러터에서는 상태를 사용하는 위젯 위에 상태를 두는 것이 합리적으로 보입니다. 왜 그럴까요? 플러터와 같은 선언형 프레임워크에서는 UI를 변경하려면 다시 생성해야 합니다. 다시 말해, 외부에서 메서드를 호출하여 위젯을 명령형으로 변경하는 것은 어렵습니다.\n- 현재 UI 상태를 고려하고 새 데이터를 적용해야 합니다. 이런 방식으로 버그를 피하기 어렵습니다.\n- 플러터에서는 컨텐츠가 변경될 때마다 새 위젯을 빌드합니다.\n\n이전 질문에 대한 답변은 앱 수준에 장바구니 상태를 두어야 합니다. 이렇게 하면 MyCart와 MyCatalog에서 상태에 액세스할 수 있습니다. MyCatalog 레벨에 상태를 둔다면 MyCart에서 액세스할 수 없습니다. 플러터에서는 불필요한 UI 다시 빌드를 피하기 위해 가능한 한 앱 상태를 위젯 트리의 낮은 위치에 두는 것이 좋은 실천법입니다.\n\n![이미지](/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_7.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 코드를 리뷰해 봅시다.\n\n먼저, 우리에게는 3가지 상태가 있습니다: 초기 상태, 로딩 상태, 성공 상태.\n\n```js\nenum Status {\n  initial,\n  loading,\n  success,\n}\n```\n\nProvider를 사용할 때 이해해야 할 3가지 개념이 있습니다: ChangeNotifier, ChangeNotifierProvider 및 Consumer.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## ChangeNotifier\n\nChangeNotifier은 Flutter SDK에 포함된 간단한 클래스로, 청취자에게 변경 알림을 제공합니다. 즉, 무언가가 ChangeNotifier이면 해당 변경 사항에 구독할 수 있습니다.\n\nprovider에서 ChangeNotifier는 응용 프로그램 상태를 캡슐화하는 한 가지 방법입니다. 매우 간단한 앱의 경우에는 하나의 ChangeNotifier로 작업할 수 있습니다. 복잡한 앱의 경우 여러 가지 모델이 있고, 따라서 여러 개의 ChangeNotifier가 있을 것입니다.\n\nChangeNotifier에 특정한 유일한 코드는 notifyListeners()를 호출하는 부분입니다. 이 메서드를 호출하여 모델에 변경 사항이 있을 때마다 UI가 변경될 수 있는지 확인하세요. CartModel에서의 나머지 코드는 모델 자체와 비즈니스 로직입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리의 DataProvider 클래스를 확인해주세요:\n\n```js\nclass DataProvider extends ChangeNotifier {\n  /// 데이터 공급자의 내부적인, 비공개 상태입니다.\n  Status _state = Status.initial;\n\n  /// 데이터 공급자의 상태입니다.\n  Status get state =\u003e _state;\n\n  /// 데이터 공급자의 상태를 업데이트합니다. 데이터 공급자를 외부에서 수정하는 유일한 방법입니다.\n  void fecthData() async {\n    _state = Status.loading;\n    // 이 호출은 해당 모델을 듣고 있는 위젯에게 rebuild해야 함을 알립니다.\n    notifyListeners();\n\n    await Future.delayed(const Duration(seconds: 2));\n\n    _state = Status.success;\n    notifyListeners();\n  }\n}\n```\n\n## ChangeNotifierProvider\n\nChangeNotifierProvider은 ChangeNotifier 인스턴스를 후손들에게 제공하는 위젯입니다. provider 패키지에서 제공됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nChangeNotifierProvider를 어디에 배치해야 하는지 이미 알고 계시네요: 액세스해야 하는 위젯들 위에요. CartModel의 경우, MyCart와 MyCatalog 둘 다 위쪽에 어딘가에 있어야 합니다.\n\n우리 예제에서 ChangeNotifierProvider와 HomeProvider (UI)를 자식으로 하는 ProviderPage가 있습니다.\n\n```js\nclass ProviderPage extends StatelessWidget {\n  static const route = 'provider-page';\n\n  const ProviderPage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return ChangeNotifierProvider(\n      create: (context) =\u003e DataProvider(),\n      child: const HomeProvider(),\n    );\n  }\n}\n```\n\n## Consumer\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n요소별로 Translation을 제공합니다:\n\n\nConsumer 위젯을 가능한 깊이까지 Tree 안에 두는 것이 최선의 방법입니다. 어딘가의 세부 사항이 변경되었을 때 UI의 큰 부분을 다시 빌드하고 싶지 않으니까요.\n\n```dart\nclass HomeProvider extends StatefulWidget {\n  const HomeProvider({super.key});\n\n  @override\n  State\u003cHomeProvider\u003e createState() =\u003e _HomeProviderState();\n}\n\nclass _HomeProviderState extends State\u003cHomeProvider\u003e {\n  late DataProvider provider;\n\n  @override\n  void initState() {\n    provider = Provider.of\u003cDataProvider\u003e(context, listen: false);\n    super.initState();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Provider Page')),\n      // Consumer 위젯을 가능한 깊이까지 Tree 안에 두는 것이 최선의 방법입니다.\n      // 어딘가의 세부 사항이 변경되었을 때 UI의 큰 부분을 다시 빌드하고 싶지 않으니까요.\n      body: Consumer\u003cDataProvider\u003e(\n        builder: (context, data, child) {\n          if (data.state == Status.initial) {\n            return const Center(child: Text('Press the Button'));\n          }\n          if (data.state == Status.loading) {\n            return const Center(child: CircularProgressIndicator());\n          }\n          if (data.state == Status.success) {\n            return const Center(child: Text('Success'));\n          }\n          return Container();\n        },\n      ),\n      floatingActionButton: Column(\n        crossAxisAlignment: CrossAxisAlignment.end,\n        mainAxisAlignment: MainAxisAlignment.end,\n        children: \u003cWidget\u003e[\n          FloatingActionButton(\n            child: const Icon(Icons.play_arrow),\n            onPressed: () =\u003e provider.fecthData(),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n그 결과는 다음과 같습니다:\n\n![이미지](/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_8.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 장점\n\n- Flutter를 처음 사용하는 경우 시작해야 할 접근 방식입니다. 이해하기 쉽고 많은 코드를 사용하지 않습니다.\n- Devtool 친화적 — Provider를 사용하면 애플리케이션의 상태가 Flutter devtool에서 볼 수 있습니다.\n- 데이터 할당 및 자원 (데이터) 해제를 간소화합니다.\n\n## 단점\n\n- 불필요한 업데이트를 실수로 호출할 수 있습니다. 객체의 상태가 변경되었을 때마다 업데이트를 트리거할 필요는 없습니다. 그러나 Provider를 사용하는 경우 변경이 발생할 때마다 항상 업데이트를 트리거합니다.\n- 확장성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# BLoC\n\n- 이 패키지의 목적은 UI와 비즈니스 로직을 분리하는 것을 용이하게 하는 것입니다.\n- 이 패키지는 패턴의 반응적 부분을 추상화하여 개발자가 비즈니스 로직 작성에 집중할 수 있도록 합니다.\n- Bloc은 이벤트를 기반으로 한 상태 변경을 트리거하는 메서드 대신 메서드 대신 사용하는 고급 클래스입니다. Bloc은 이벤트를 수신하고 수신된 이벤트를 발생한 이벤트로 변환합니다.\n\n![image](/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_9.png)\n\n이 부분을 좀 더 잘 이해하기 위해 이벤트가 UI에서 추가되고 BLoC에서 이를 처리하고 이러한 이벤트에 대한 상태 변경으로 응답합니다. bloc 라이브러리를 사용하면 Presentation, Business Logic 및 Data가 세 개의 레이어로 나뉘도록 응용 프로그램을 분리할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n상태 변경은 이벤트가 추가될 때 블록이 시작되며 onEvent을 트리거합니다. 그런 다음, 이벤트는 EventTransformer를 통해 흘러갑니다. 기본적으로 각 이벤트는 병렬로 처리되지만 사용자 정의 EventTransformer를 제공하여 들어오는 이벤트 스트림을 조작할 수 있습니다. 해당 이벤트 유형에 대해 등록된 모든 EventHandlers는 들어오는 이벤트와 함께 호출됩니다. 각 EventHandler는 이벤트에 대한 응답으로 제로 이상의 상태를 발행하는 책임이 있습니다. 마지막으로, 상태가 업데이트되기 직전에 onTransition이 호출되며 현재 상태, 이벤트 및 다음 상태를 포함합니다.\n\n![이미지](/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_10.png)\n\nBLoC 구현에서는 data_bloc, data_event 및 data_state 총 3개의 파일이 필요합니다.\n\n![이미지](/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_11.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n블록 상태에서는 세 가지 상태를 가질 것입니다: 초기, 로딩 및 성공.\n\n```js\npart of 'data_bloc.dart';\n\n\nabstract class DataState {}\n\nclass Initial extends DataState {}\n\nclass Loading extends DataState {}\n\nclass Success extends DataState {}\n```\n\n또한, 블록 이벤트에서는 FetchDataEvent만 사용할 것입니다.\n\n```js\npart of 'data_bloc.dart';\n\nabstract class DataEvent {}\n\nclass FetchDataEvent extends DataEvent {}\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nIn DataBloc, when the FetchDataEvent is added, the _onFetchDataEvent method is triggered.\n\nimport 'package:flutter_bloc/flutter_bloc.dart';\n\npart 'data_event.dart';\npart 'data_state.dart';\n\nclass DataBloc extends Bloc\u003cDataEvent, DataState\u003e {\n  DataBloc() : super(Initial()) {\n    on\u003cFetchDataEvent\u003e(_onFetchDataEvent);\n  }\n\n  void _onFetchDataEvent(\n    FetchDataEvent event,\n    Emitter\u003cDataState\u003e emit,\n  ) async {\n    emit(Loading());\n    await Future.delayed(const Duration(seconds: 2));\n    emit(Success());\n  }\n}\n\nIn this example, we have a BlocPage that includes a BlocProvider with HomeBloc as a child.\n\nclass BlocPage extends StatelessWidget {\n  static const route = 'bloc-page';\n\n  const BlocPage({Key key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return BlocProvider(\n      create: (context) =\u003e DataBloc(),\n      child: const HomeBloc(),\n    );\n  }\n}\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nclass HomeBloc extends StatefulWidget {\n  const HomeBloc({super.key});\n\n  @override\n  State\u003cHomeBloc\u003e createState() =\u003e _HomeBlocState();\n}\n\nclass _HomeBlocState extends State\u003cHomeBloc\u003e {\n  late DataBloc bloc;\n\n  @override\n  void initState() {\n    bloc = BlocProvider.of\u003cDataBloc\u003e(context);\n    super.initState();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('BLoC 페이지')),\n      body: BlocBuilder\u003cDataBloc, DataState\u003e(\n        builder: (context, state) {\n          if (state is Initial) {\n            return const Center(child: Text('버튼을 눌러주세요'));\n          }\n          if (state is Loading) {\n            return const Center(child: CircularProgressIndicator());\n          }\n          if (state is Success) {\n            return const Center(child: Text('성공'));\n          }\n          return Container();\n        },\n      ),\n      floatingActionButton: Column(\n        crossAxisAlignment: CrossAxisAlignment.end,\n        mainAxisAlignment: MainAxisAlignment.end,\n        children: \u003cWidget\u003e[\n          FloatingActionButton(\n            child: const Icon(Icons.play_arrow),\n            onPressed: () =\u003e bloc.add(FetchDataEvent()),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n그리고 Bloc 결과입니다:\n\n\u003cimg src=\"/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_12.png\" /\u003e\n\n## 장점\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 애플리케이션의 상태를 언제든지 파악할 수 있습니다.\n- 앱이 적절하게 응답하는지 확인하기 위해 모든 케이스를 쉽게 테스트할 수 있습니다.\n- 애플리케이션에서 모든 사용자 상호 작용을 기록하여 데이터 기반 결정을 내릴 수 있습니다.\n- 빠르고 반응성 있는 앱을 개발할 수 있습니다.\n- 대규모 데이터 크기에 대해 더 나은 성능을 제공합니다.\n\n## 단점\n\n- 대형 애플리케이션을 가지고 있을 때만 효과적입니다.\n- 두 방향으로 스트림을 사용해야 하므로 Provider보다 더 많은 보일러플레이트가 발생할 수 있습니다.\n- 복잡한 시나리오에서는 너무 제한적일 수 있으며 하나의 입력과 출력만 다루는 BLoC를 생성할 수 있습니다.\n- 특히 앱의 여러 부분에 유사한 비즈니스 로직을 구현해야할 경우 코드 중복으로 이어질 수 있습니다.\n\n# GetX\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 플러터에 대한 가벼우면서도 강력한 솔루션입니다. 고성능 상태 관리, 스마트한 의존성 주입, 라우트 관리를 빠르고 실용적으로 결합합니다.\n- 성능과 자원 최소 소비에 중점을 둡니다. GetX는 Streams나 ChangeNotifier를 사용하지 않습니다.\n- 사용하기 쉽고 즐거운 구문을 사용합니다.\n- 뷰, 표현 로직, 비즈니스 로직, 의존성 주입, 네비게이션의 완전한 분리를 허용합니다.\n\n다음 이미지에서 모든 GetX 기능을 확인할 수 있습니다:\n\n![GetX Functions](/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_13.png)\n\n하지만 우리에게 가장 중요한 것은 반응형 상태 관리자입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 반응성 상태 관리자\n\n반응형 프로그래밍은 복잡하다고 말리기 때문에 많은 사람들을 멀리하곤 합니다. GetX는 반응형 프로그래밍을 꽤 간단하게 만들어 줍니다:\n\n- StreamControllers를 만들 필요가 없습니다.\n- 각 변수마다 StreamBuilder를 만들 필요가 없습니다.\n- 각 상태마다 클래스를 만들 필요가 없습니다.\n- 초기 값에 대한 get을 만들 필요가 없습니다.\n\n이름 변수가 있고 이 변수를 변경할 때마다 사용하는 모든 위젯이 자동으로 변경되기를 원한다고 상상해 봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기 당신의 계수 변수가 있어요:\n\n```js\nvar name = 'Jonatas Borges';\n```\n\n이를 관찰 가능하도록 만들기 위해서는 그 뒤에 \".obs\"를 추가하기만 하면 돼요:\n\n```js\nvar name = 'Jonatas Borges'.obs;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nUI에서 해당 값이 표시되고 값이 변경될 때 화면을 업데이트하려면 다음과 같이 하면 됩니다:\n\n```js\nObx(() =\u003e Text(\"${controller.name}\"));\n```\n\n단순합니다.\n\n이제 코드로 넘어갑니다. GetX에서 Controller가 정의됩니다. 이 경우 GetxController를 확장한 Controller 클래스를 만듭니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\n열거형 Status {\n  초기,\n  로딩,\n  성공,\n}\n```\n\n```js\r\nclass Controller extends GetxController {\n  // GetX는 반응형이기 때문에 변수가 변경되면 자동으로 화면에서 변경됩니다.\n  // 변수 앞에 \".obs\"를 추가하기만 하면 이미 반응형입니다.\n  var state = Status.initial.obs;\n\n  /// 컨트롤러의 상태를 업데이트합니다. 이 방법이 컨트롤러를 외부에서 수정하는 유일한 방법입니다.\n  void fetchData() async {\n    state.value = Status.loading;\n    //update();\n\n    await Future.delayed(const Duration(seconds: 2));\n\n    state.value = Status.success;\n  }\n}\r\n```\n\nUI에서 우리는 GetXPage가 있습니다. 그 안에는 간단한 HomeGetX 위젯이 자식으로 있습니다. 이 방식으로 정의되었는데, Provider 및 Bloc과의 차이를 보려고 했습니다. Provider나 Bloc을 자식 위젯에 제공하기 위해 ChangeNotifierProvider나 BlocProvider의 부모 위젯을 정의해야 했던 과정과의 차이점을 볼 수 있습니다.\n\n```js\r\nclass GetXPage extends StatelessWidget {\n  static const route = 'getx-page';\n\n  const GetXPage({key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return const HomeGetX();\n  }\n}\r\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nclass HomeGetX extends StatefulWidget {\n  const HomeGetX({super.key});\n\n  @override\n  State\u003cHomeGetX\u003e createState() =\u003e _HomeGetXState();\n}\n\nclass _HomeGetXState extends State\u003cHomeGetX\u003e {\n  late Controller c;\n\n  @override\n  void initState() {\n    c = Get.put(Controller());\n    super.initState();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('GetX Page')),\n      //최상위에 Consumer 위젯을 가능한 깊게 두는 것이 가장 좋습니다.\n      //어딘가의 세부 사항이 변경되었기 때문에 UI의 큰 부분을 다시 빌드하고 싶지 않습니다.\n      body: GetX\u003cController\u003e(\n        builder: (context) {\n          if (c.state.value == Status.initial) {\n            return const Center(child: Text('Press the Button'));\n          }\n          if (c.state.value == Status.loading) {\n            return const Center(child: CircularProgressIndicator());\n          }\n          if (c.state.value == Status.success) {\n            return const Center(child: Text('Success'));\n          }\n          return Container();\n        },\n      ),\n      floatingActionButton: Column(\n        crossAxisAlignment: CrossAxisAlignment.end,\n        mainAxisAlignment: MainAxisAlignment.end,\n        children: \u003cWidget\u003e[\n          FloatingActionButton(\n            child: const Icon(Icons.play_arrow),\n            onPressed: () =\u003e c.fecthData(),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n결과는 다음과 같습니다:\n\n\u003cimg src=\"/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_14.png\" /\u003e\n\n## 장점\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 몇 줄의 코드로 작성된 간단한 상태 업데이터입니다. 최소한의 CPU 영향을 주도록 단순하게 만들었고, 단일 목적을 충족하고 가능한 한 최소한의 리소스를 사용하기 위해 제작되었습니다.\n- 강력한 상태 관리자이며 변수가 아닌 흐름(Flow)으로 작동하며, 내부적으로는 모든 것이 스트림(Stream)입니다.\n- 코드 생성기나 장식품(Decoration) 없이도 실제로 BLoC 접근 방식입니다. .obs를 사용하여 모든 것을 \"Observable\"로 변환할 수 있습니다.\n\n## 단점\n\n- 문제들이 많이 발생할 수 있으며 중복될 수도 있습니다. 문제 해결, 답변, 태깅, 중복 제거 등에 대해 아무도 관심을 가지지 않는 것이 분명합니다.\n- GetX가 너무 많은 작업을 수행하고 이 프로젝트가 단 한 사람에게는 너무 큽니다.\n- 핫 리로드 문제 - GetX는 자체 종속성 주입 시스템을 가지고 있으며, 이는 GetX 모듈의 거의 모든 곳에서 사용되지만 아직 안정적이지 않습니다.\n- GetX로 단위 및 위젯 테스트를 작성하는 것은 정말 어렵고 몇 가지 경우에는 일부 기능을 테스트하는 것이 불가능합니다.\n\n# Riverpod\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Provider와 유사하며 컴파일 안전성과 테스트 가능성을 갖추고 있습니다.\n- Riverpod은 Provider에서 영감을 받았지만 동일한 유형의 여러 공급자 지원; 비동기 공급자 대기; 어디서든 공급자 추가와 같은 주요 문제들을 해결합니다.\n- 이제 main.dart와 UI 파일 간에 이동할 필요가 없어졌습니다.\n- 공유 상태 코드를 필요한 곳에 배치하고, 별도의 패키지에 있든 위젯 옆에 있든 테스트 가능성을 잃지 않고 유지하세요.\n\nProviders는 Riverpod 앱의 가장 중요한 요소입니다. Provider는 상태 조각을 캡슐화하고 해당 상태를 청취할 수 있는 개체입니다.\n\n```js\nenum Status {\n  initial,\n  loading,\n  success,\n}\n```\n\n```js\nclass RiverpodProvider extends StateNotifier\u003cStatus\u003e {\n  RiverpodProvider() : super(Status.initial);\n\n  Future\u003cvoid\u003e fetchData() async {\n    state = Status.loading;\n\n    await Future.delayed(const Duration(seconds: 2));\n\n    state = Status.success;\n  }\n}\n\nfinal riverpodProvider =\n    StateNotifierProvider.autoDispose((ref) =\u003e RiverpodProvider());\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nUI에서 다음과 같이 하고 있습니다:\n\n```dart\nclass RiverpodPage extends StatelessWidget {\n  static const route = 'riverpod-page';\n\n  const RiverpodPage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const ProviderScope(\n      child: HomeRiverpod(),\n    );\n  }\n}\n```\n\n위젯이 프로바이더를 읽을 수 있도록 하려면 전체 애플리케이션을 \"ProviderScope\" 위젯으로 감싸야 합니다. 이곳에는 프로바이더의 상태가 저장됩니다.\n\n```dart\nclass HomeRiverpod extends ConsumerWidget {\n  const HomeRiverpod({super.key});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final data = ref.read(riverpodProvider.notifier);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Riverpod Page')),\n      // 소비자 위젯을 가능한 깊게 트리 안에 배치하는 것이 가장 좋습니다.\n      // 어딘가의 세부 사항이 변경되었을 때 UI의 큰 부분을 다시 빌드하고 싶지 않습니다.\n      body: Consumer(\n        builder: (context, ref, child) {\n          final state = ref.watch(riverpodProvider);\n          if (state == Status.initial) {\n            return const Center(child: Text('Press the Button'));\n          }\n          if (state == Status.loading) {\n            return const Center(child: CircularProgressIndicator());\n          }\n          if (state == Status.success) {\n            return const Center(child: Text('Success'));\n          }\n          return Container();\n        },\n      ),\n      floatingActionButton: Column(\n        crossAxisAlignment: CrossAxisAlignment.end,\n        mainAxisAlignment: MainAxisAlignment.end,\n        children: \u003cWidget\u003e[\n          FloatingActionButton(\n            child: const Icon(Icons.play_arrow),\n            onPressed: () =\u003e data.fetchData(),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 제공자들과 상호 작용하는 ref 사용하기\n\n\"ref\"를 사용하는 주요 용도는 다음과 같습니다:\n\n- ref.watch를 사용하여 제공자의 값을 얻고 변경 사항을 청취하는 것입니다. 값이 변경되면 해당 위젯이나 제공자가 다시 빌드되는 기능입니다.\n- ref.listen을 사용하여 제공자에서 리스너를 추가하여 해당 제공자가 변경될 때 새 페이지로 이동하거나 모달을 표시하는 등의 동작을 실행하는 것입니다.\n- ref.read를 사용하여 변경 사항을 무시하고 제공자의 값을 얻는 것입니다. \"클릭\"과 같은 이벤트에서 제공자의 값을 필요로 할 때 유용합니다.\n\n이 결과는 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n빠른 대답을 위해 노력중입니다! \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Riverpod은 앱에서 상태를 구현하는 데 너무 많은 자유를 제공합니다. 이는 새로운 개발자들에게 가장 좋은 접근 방식을 선택하는 데 어려움을 줄 수 있습니다.\n- 공유 상태를 위젯 트리 전체에 분산시키는 나쁜 안티패턴을 촉진합니다. 이는 코드가 매우 찾기 어렵도록 (중앙화되지 않음) 하고, Provider 간에 과도한 의존성 체인과 결합으로 디버깅을 추적하기 어렵게 만들 수 있습니다.\n\n# GetIt\n\nGetIt은 상태 관리 솔루션이 아닙니다! 객체의 로케이터이므로 스트림이나 ValueNotifiers와 같은 다른 방법을 사용하여 UI에 변경을 알릴 필요가 있습니다. 그러나 get_it_mixin과 함께 사용하면 get_it에 등록된 객체와 통합되는 완전한 기능의 쉬운 상태 관리 솔루션이 됩니다.\n\nGetIt은:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 극히 빠름\n- 배우고 사용하기 쉬움\n- Provider나 Redux처럼 데이터에 액세스하기 위해 특별한 위젯을 UI 트리에 추가하지 않음\n\n저희의 구현은 다음과 같습니다:\n\n```js\nenum Status {\n  initial,\n  loading,\n  success,\n}\n```\n\n```js\nclass GetItProvider extends ChangeNotifier {\n  /// GetItProvider의 내부 및 비공개 상태입니다.\n  Status _state = Status.initial;\n\n  /// GetItProvider의 상태입니다.\n  Status get state =\u003e _state;\n\n  /// GetItProvider의 상태를 업데이트합니다. 이는 외부에서 GetItProvider를 수정하는 유일한 방법입니다.\n  void fecthData() async {\n    _state = Status.loading;\n    // 이 호출은 이 모델을 듣고 있는 위젯에게 다시 빌드하도록 지시합니다.\n    notifyListeners();\n\n    await Future.delayed(const Duration(seconds: 2));\n\n    _state = Status.success;\n    notifyListeners();\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 주목했다면, GetItProvider가 Provider를 검토할 때 우리가 구현한 DataProvider와 동일하다는 것을 알 수 있어요.\n\n객체에 액세스하기 전에는 GetIt에 그들을 등록해야 합니다. 보통 initState 코드 내에서 직접 등록합니다.\n\n```js\nclass GetItPage extends StatefulWidget {\n  static const route = 'get-it-page';\n\n  const GetItPage({super.key});\n\n  @override\n  State\u003cGetItPage\u003e createState() =\u003e _GetItPageState();\n}\n\nclass _GetItPageState extends State\u003cGetItPage\u003e {\n  @override\n  void initState() {\n    //시작할 때 모든 객체를 등록합니다.\n    //나중에 액세스하려는 객체들을 이렇게 등록하세요:\n    GetIt.I.registerSingleton\u003cGetItProvider\u003e(GetItProvider());\n    super.initState();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return HomeGetIt();\n  }\n}\n```\n\nGetIt로 데이터를 읽는 것은 이미 간단합니다. 하지만 mixin을 추가하면 더욱 쉬워집니다. StatelessWidget에 GetItMixin을 추가하고 get`T`를 호출하면 됩니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\nclass HomeGetIt extends StatelessWidget with GetItMixin {\n  HomeGetIt({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // 보기 쉽게! view 가 rebuild 되기를 원할 때는 watchOnly 를 호출하여 상태가 변경될 때마다 알려줄 수 있습니다:\n    final state =\n        watchOnly((GetItProvider getItProvider) =\u003e getItProvider.state);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('GetIt 페이지')),\n      body: Builder(\n        builder: (context) {\n          if (state == Status.initial) {\n            return const Center(child: Text('버튼을 눌러보세요'));\n          }\n          if (state == Status.loading) {\n            return const Center(child: CircularProgressIndicator());\n          }\n          if (state == Status.success) {\n            return const Center(child: Text('성공'));\n          }\n          return Container();\n        },\n      ),\n      floatingActionButton: Column(\n        crossAxisAlignment: CrossAxisAlignment.end,\n        mainAxisAlignment: MainAxisAlignment.end,\n        children: \u003cWidget\u003e[\n          FloatingActionButton(\n            child: const Icon(Icons.play_arrow),\n            // 이후 아래와 같이 GetItProvider 클래스에 접근할 수 있습니다:\n            onPressed: () =\u003e get\u003cGetItProvider\u003e().fecthData(),\n          ),\n        ],\n      ),\n    );\n  }\n}\r\n```\n\n보통 데이터 원본 타입에 대한 다양한 watch 메서드가 있습니다. ChangeNotifier, ValueNotifier, Stream 및 Future를 포함합니다.\n\nwatch 메서드의 주요 이점은 ValueListenableBuilders, StreamBuilder 등을 사용하지 않아도 된다는 것입니다. 각 바인딩마다 한 줄만 사용되며 중첩이 없으므로 가독성이 좋습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![alt text](/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_16.png)\n\n## 장점\n\n- 간단하고 사용하기 쉽며, Flutter에 의존하지 않아서 모든 Dart 코드와 함께 사용할 수 있습니다.\n- 매우 빠르고 배우기/사용하기 쉽습니다. UI 트리를 특별한 위젯으로 엮지 않고 데이터에 액세스할 수 있습니다.\n\n## 단점\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 위젯 트리의 본질적인 부분이 아니기 때문에 항목을 수동으로 폐기하거나 등록 해제해야 할 수도 있습니다.\n- 동일한 형식의 인스턴스를 제공하는 문제가 있지만 등록할 때 이름 필드를 노출하기 때문에 문제에 대한 합리적인 해결책을 제공합니다.\n- GetIt 싱글톤의 전역적인 성격을 선호하지 않는 개발자들도 있을 수 있으며, 이는 riverpod나 Provider의 더 제한적인 스코핑 모델을 선호할 수도 있습니다. 다른 개발자들은 이것을 이점으로 생각할 수도 있습니다.\n\n# MobX\n\nMobX는 응용 프로그램의 반응형 데이터와 UI를 간단히 연결하는 상태 관리 라이브러리입니다. 이 연결은 완전히 자동적이며 매우 자연스럽게 느껴집니다. 응용 프로그램 개발자는 UI에서 (그리고 다른 곳에서) 소비해야 하는 반응형 데이터에 순수하게 집중할 뿐, 두 가지를 동기화할 필요없이 고민할 필요가 없습니다.\n\n실제로 마법은 아니지만, 소비되는 것(observable)과 어디에서(reactions) 소비되는지에 관한 지혜가 있으며, 이를 자동으로 추적합니다. observable이 변경되면 모든 reactions가 다시 실행됩니다. 흥미로운 점은 이러한 reactions가 간단한 콘솔 로그에서 네트워크 호출 또는 UI 다시 렌더링까지 모두 될 수 있다는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nMobX의 핵심에는 Observables, Actions 및 Reactions이라는 세 가지 중요한 개념이 있습니다.\n\n![image](/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_17.png)\n\n## Observables\n\n- Observables는 응용 프로그램의 반응형 상태를 나타냅니다. 단순 스칼라부터 복잡한 객체 트리까지 될 수 있습니다. 응용 프로그램의 상태를 Observables 트리로 정의함으로써, 반응형 상태 트리를 노출하여 UI(또는 응용 프로그램의 다른 관찰자)에서 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 작업\n\n- 작업은 옵저버를 변이시키는 방법입니다. 직접 변이시키는 대신 작업은 변이에 의미를 부여합니다. 예를 들어 value++를 하는 대신 increment() 작업을 실행하면 더 많은 의미가 전달됩니다. 또한, 작업은 모든 알림을 일괄 처리하고 변경 사항은 완료된 후에만 알림을 보내도록 보장합니다. 따라서 옵저버는 작업의 원자적 완료 후에만 알림을 받습니다.\n\n## 반응\n\n- 반응은 MobX의 옵저버, 작업 및 반응의 삼합체를 완성합니다. 이들은 반응형 시스템의 옵저버이며 추적 중인 옵저버가 변경될 때마다 알림을 받습니다. 반응에는 아래에 나열된 몇 가지 종류가 있습니다. 이들은 모두 ReactionDisposer를 반환하며, 이는 반응을 폐기하기 위해 호출할 수 있는 함수입니다. 반응의 두드러진 특징 중 하나는 옵저버를 명시적으로 연결하지 않아도 자동으로 모든 옵저버를 추적한다는 것입니다. 반응 내에서 옵저버를 읽는 행위만으로도 추적이 가능합니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nMobX의 스토어는 관련 observable 상태를 하나의 클래스 아래에 수집하는 방법입니다. 이 스토어를 사용하면 주석을 사용하고 코드를 간단하게 유지할 수 있습니다.\n\n```js\nenum Status {\n  initial,\n  loading,\n  success,\n}\n```\n\n```js\n// 이것은 코드베이스의 나머지 부분에서 사용되는 클래스입니다.\n// ignore: library_private_types_in_public_api\nclass DataStore = _DataStore with _$DataStore;\n\n// 스토어 클래스\nabstract class _DataStore with Store {\n  @observable\n  Status state = Status.initial;\n\n  @action\n  Future\u003cvoid\u003e fetchData() async {\n    state = Status.loading;\n\n    await Future.delayed(const Duration(seconds: 2));\n\n    state = Status.success;\n  }\n}\n```\n\n주석을 사용하여 클래스의 observable 속성을 표시하는 방법에 유의하십시오. 주석은 mobx_codgen 패키지를 통해 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기서 흥미로운 부분은:\n\n- Store mixin을 포함하는 추상 클래스 _DataStore입니다. 모든 스토어 관련 코드는 이 추상 클래스 내에 배치되어야 합니다. build_runner에서 코드를 조합하기 위해 DataStore 클래스를 생성합니다.\n- 생성된 코드는 part 파일인 data_store.g.dart에 포함됩니다. 이를 part 지시문으로 포함해야 build_runner가 출력물을 생성합니다. 생성된 파일에는 _$DataStore mixin이 포함됩니다.\n- 값을 observable로 표시하는 @observable 어노테이션.\n- increment() 메서드를 action으로 표시하기 위한 @action 사용.\n\n\u003cimg src=\"/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_18.png\" /\u003e\n\n프로젝트 폴더 내에서 다음 명령을 실행하세요. 이는 counter.g.dart에 코드를 생성하며, 이미 part 파일로 포함해 두었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nflutter pub run build_runner build\n```\n\n이제 UI를 살펴보겠습니다:\n\n```js\nfinal dataStore = DataStore(); // 스토어를 인스턴스화합니다.\n\nclass MobXPage extends StatelessWidget {\n  static const route = 'mobx-page';\n\n  const MobXPage({Key key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return const HomeMobX();\n  }\n}\n```\n\nObserver 위젯(flutter_mobx의 일부)은 빌더 함수에서 사용된 observables의 세부적인 옵저버를 제공합니다. 이러한 observables이 변경될 때마다 Observer가 다시 빌드되고 렌더링됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\nclass HomeMobX extends StatelessWidget {\n  const HomeMobX({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('MobX 페이지')),\n      // 가능한 깊은 곳에 Consumer 위젯을 배치하는 것이 가장 좋습니다.\n      // 어딘가의 세부 사항이 변경되어도 대규모 UI의 큰 부분을 다시 빌드하고 싶지 않을 것입니다.\n      body: Observer(\n        builder: (_) {\n          if (dataStore.state == Status.initial) {\n            return const Center(child: Text('버튼을 눌러주세요'));\n          }\n          if (dataStore.state == Status.loading) {\n            return const Center(child: CircularProgressIndicator());\n          }\n          if (dataStore.state == Status.success) {\n            return const Center(child: Text('성공'));\n          }\n          return Container();\n        },\n      ),\n      floatingActionButton: Column(\n        crossAxisAlignment: CrossAxisAlignment.end,\n        mainAxisAlignment: MainAxisAlignment.end,\n        children: \u003cWidget\u003e[\n          FloatingActionButton(\n            child: const Icon(Icons.play_arrow),\n            onPressed: () =\u003e dataStore.fecthData(),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n그 결과는:\n\n\u003cimg src=\"/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_19.png\" /\u003e\n\n## 장점\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 반응형 앱 데이터를 UI와 쉽게 연결할 수 있습니다.\n- 학습을 쉽게하는 친숙한 구문과 간단한 핵심 API를 사용하여 옵저버 패턴을 구현합니다.\n- 크고 복잡한 프로젝트에서 사용할 수 있으며 확장 가능합니다.\n- 성능이 좋고 테스트하기 쉽습니다.\n- 코드 생성 덕분에 보일러플레이트를 줄일 수 있습니다.\n\n## 단점\n\n- 코드 생성에 시간이 걸리고 상태 변경 시마다 코드 생성기를 실행해야 할 수도 있습니다.\n- 상태가 변경될 때 어떤 이벤트가 그것을 일으킨 것인지 파악하기 어려울 수 있습니다. 복잡한 앱에서 이러한 추적 불가능성은 디버깅과 상태 관리를 어렵게 만들 수 있습니다.\n- Mobx 생성기는 단순성을 높이는 데 좋지만 동시에 추상화 수준을 추가합니다. 이는 내부 작업을 실제로 보고 이해하기 어렵게 만듭니다.\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 상태 관리는 가장 중요한 측면 중 하나입니다. 이는 사용자가 UI에 가한 모든 변경 사항을 추적하는 방법입니다.\n- Flutter의 상태 관리 라이브러리들은 상태 변경의 유형과 상관없이 애플리케이션을 개발하고 관리하기 쉽게 만들어 줍니다.\n- 올바른 Flutter 상태 관리자를 선택하는 것은 사용하는 것만큼 중요합니다. 상태 관리자의 선택지는 다양하지만, 어떤 것을 사용할지 선택하는 것은 우리에게, 우리의 취향에, 편안한 느낌에, 또한 프로젝트 유형, 요구 사항에 달려 있습니다. 작은 프로젝트인 경우 한 가지 접근 방식을 사용할 수 있고, 확장 가능한 프로젝트를 만들고 싶다면 다른 접근 방식을 사용할 수 있습니다.\n\n마침내 기대하던 것, 여기에서 전체 예제를 찾을 수 있습니다:\n\n마음에 든다면 커피 한 잔 사주세요!\n\n![이미지](/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_20.png)","ogImage":{"url":"/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_0.png"},"coverImage":"/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_0.png","tag":["Tech"],"readingTime":28},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e본 기사에서는 상태 관리의 일반적인 개요를 검토한 후 가장 흥미로운 상태 관리 방법인 Provider, BLoC, GetX, Riverpod, GetIt, 그리고 MobX를 살펴보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_0.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ch1\u003e일반적인 개요\u003c/h1\u003e\n\u003cp\u003e모바일 앱을 개발하는 동안, 화면 간이나 전체 앱을 통해 앱 상태를 공유해야 하는 시점이 찾아옵니다.\u003c/p\u003e\n\u003cp\u003e이 예에서는 MyLoginScreen, MyCatalog 및 MyCart의 3 개 화면이 있습니다. MyCatalog에서는 제품이 이미 쇼핑 카트에 있는지 확인하기 위해 애플리케이션의 상태를 알아야 합니다. 그리고 MyCart에서는 추가된 모든 제품과 총 구매액을 보고 싶습니다. 두 화면 모두 카트의 상태를 알아야 합니다. 이것은 애플리케이션 상태의 예시이며, 나중에 자세히 검토할 예정입니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAndroid 또는 iOS 개발에서 추측할 수 있는 많은 가정이 Flutter에는 해당하지 않습니다. 예를 들어, Flutter에서 UI의 일부를 수정하는 대신 처음부터 다시 빌드하는 것은 괜찮습니다. Flutter는 이를 수행할 만큼 충분히 빠릅니다. 필요하다면 매 프레임마다 가능합니다.\u003c/li\u003e\n\u003cli\u003eFlutter는 선언적입니다. 이것은 Flutter가 현재 상태 애플리케이션을 반영하기 위해 UI를 빌드한다는 것을 의미합니다.\u003c/li\u003e\n\u003cli\u003e예를 들어 앱 상태가 변경되면, 예를 들어 설정 화면이 있고 사용자가 스위치를 누르는 경우, 그것은 상태를 변경하고 이것은 UI 디자인을 트리거합니다. 이것은 명령형 UI 변경이 아니며, 변경되는 것은 상태이며 UI는 처음부터 다시 빌드됩니다.\u003c/li\u003e\n\u003cli\u003eUI 프로그래밍의 선언적 스타일에는 많은 이점이 있습니다. 모든 상태에 대해 UI가 어떻게 보이는지 설명하고 한 번만 설명하면 됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003eTransient State와 앱 상태의 차이점\u003c/h1\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_3.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e앱 상태는 응용 프로그램이 실행 중일 때 메모리에 있는 모든 요소를 포함합니다. 이는 자산, 변수, 애니메이션 상태, 글ꔼ자 등을 포함합니다.\u003c/p\u003e\n\u003cp\u003e우리가 관리하는 상태는 일시적인 상태와 앱 상태로 나뉠 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e일시적 상태\u003c/h2\u003e\n\u003cp\u003e단일 위젯을 포함할 수 있는 상태입니다. 예를 들어:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e위젯에서 현재 페이지\u003c/li\u003e\n\u003cli\u003e애니메이션의 진행 상황\u003c/li\u003e\n\u003cli\u003eBottomNavigationBar에서 선택한 탭\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e다시 말해, 이 유형의 상태에서는 상태 관리 기술을 사용할 필요가 없습니다. 필요한 것은 StatefulWidget뿐입니다.\u003c/p\u003e\n\u003ch2\u003e앱 상태\u003c/h2\u003e\n\u003cp\u003e당연히, 이것은 일시적이지 않은 상태이며 응용 프로그램의 여러 부분에서 공유하고 사용자 세션 사이에서 유지하고 싶은 상태입니다. 응용 프로그램 상태의 예시:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e사용자의 선호도\u003c/li\u003e\n\u003cli\u003e로그인 정보\u003c/li\u003e\n\u003cli\u003e전자 상거래 응용 프로그램의 쇼핑 카트\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e여기서 우리는 상태 관리가 필요할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e저희가 모든 상태 관리를 위해 개발할 예제를 보여드리겠습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_4.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch1\u003eProvider\u003c/h1\u003e\n\u003cp\u003e만약 플러터를 처음 시작하시는 초보자이고 다른 접근 방식을 선택할 확실한 이유가 없다면, 아마도 이 접근 방식부터 시작하는 것이 좋을 것입니다. Provider 패키지는 이해하기 쉽고 코드 양이 많지 않습니다. 또한 다른 접근 방식에서 사용되는 개념을 사용합니다.\u003c/p\u003e\n\u003cp\u003e앱에는 MyCart 및 MyCatalog 위젯으로 나타낸 카탈로그 및 장바구니라는 두 개의 별도 화면이 있습니다. 카탈로그 화면에는 앱 바와 항목 목록이 포함되어 있습니다.\u003c/p\u003e\n\u003cp\u003e우리는 몇 가지 위젯이 있습니다. 그 중 많은 위젯이 다른 위치에 \"소속된\" 상태에 액세스해야 합니다. 예를 들어, 카탈로그의 각 항목은 장바구니에 추가할 수 있습니다. 현재 표시된 항목이 이미 장바구니에 있는지 확인하려고 할 수도 있습니다.\u003c/p\u003e\n\u003cp\u003e이로써 첫 번째 질문으로 이어집니다: 장바구니의 현재 상태를 어디에 두어야 할까요?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e플러터에서는 상태를 사용하는 위젯 위에 상태를 두는 것이 합리적으로 보입니다. 왜 그럴까요? 플러터와 같은 선언형 프레임워크에서는 UI를 변경하려면 다시 생성해야 합니다. 다시 말해, 외부에서 메서드를 호출하여 위젯을 명령형으로 변경하는 것은 어렵습니다.\u003c/li\u003e\n\u003cli\u003e현재 UI 상태를 고려하고 새 데이터를 적용해야 합니다. 이런 방식으로 버그를 피하기 어렵습니다.\u003c/li\u003e\n\u003cli\u003e플러터에서는 컨텐츠가 변경될 때마다 새 위젯을 빌드합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이전 질문에 대한 답변은 앱 수준에 장바구니 상태를 두어야 합니다. 이렇게 하면 MyCart와 MyCatalog에서 상태에 액세스할 수 있습니다. MyCatalog 레벨에 상태를 둔다면 MyCart에서 액세스할 수 없습니다. 플러터에서는 불필요한 UI 다시 빌드를 피하기 위해 가능한 한 앱 상태를 위젯 트리의 낮은 위치에 두는 것이 좋은 실천법입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_7.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e이제 코드를 리뷰해 봅시다.\u003c/p\u003e\n\u003cp\u003e먼저, 우리에게는 3가지 상태가 있습니다: 초기 상태, 로딩 상태, 성공 상태.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eenum \u003cspan class=\"hljs-title class_\"\u003eStatus\u003c/span\u003e {\n  initial,\n  loading,\n  success,\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eProvider를 사용할 때 이해해야 할 3가지 개념이 있습니다: ChangeNotifier, ChangeNotifierProvider 및 Consumer.\u003c/p\u003e\n\u003ch2\u003eChangeNotifier\u003c/h2\u003e\n\u003cp\u003eChangeNotifier은 Flutter SDK에 포함된 간단한 클래스로, 청취자에게 변경 알림을 제공합니다. 즉, 무언가가 ChangeNotifier이면 해당 변경 사항에 구독할 수 있습니다.\u003c/p\u003e\n\u003cp\u003eprovider에서 ChangeNotifier는 응용 프로그램 상태를 캡슐화하는 한 가지 방법입니다. 매우 간단한 앱의 경우에는 하나의 ChangeNotifier로 작업할 수 있습니다. 복잡한 앱의 경우 여러 가지 모델이 있고, 따라서 여러 개의 ChangeNotifier가 있을 것입니다.\u003c/p\u003e\n\u003cp\u003eChangeNotifier에 특정한 유일한 코드는 notifyListeners()를 호출하는 부분입니다. 이 메서드를 호출하여 모델에 변경 사항이 있을 때마다 UI가 변경될 수 있는지 확인하세요. CartModel에서의 나머지 코드는 모델 자체와 비즈니스 로직입니다.\u003c/p\u003e\n\u003cp\u003e우리의 DataProvider 클래스를 확인해주세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDataProvider\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eChangeNotifier\u003c/span\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e/// 데이터 공급자의 내부적인, 비공개 상태입니다.\u003c/span\u003e\n  \u003cspan class=\"hljs-title class_\"\u003eStatus\u003c/span\u003e _state = \u003cspan class=\"hljs-title class_\"\u003eStatus\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003einitial\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-comment\"\u003e/// 데이터 공급자의 상태입니다.\u003c/span\u003e\n  \u003cspan class=\"hljs-title class_\"\u003eStatus\u003c/span\u003e get state =\u003e _state;\n\n  \u003cspan class=\"hljs-comment\"\u003e/// 데이터 공급자의 상태를 업데이트합니다. 데이터 공급자를 외부에서 수정하는 유일한 방법입니다.\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efecthData\u003c/span\u003e() \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n    _state = \u003cspan class=\"hljs-title class_\"\u003eStatus\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eloading\u003c/span\u003e;\n    \u003cspan class=\"hljs-comment\"\u003e// 이 호출은 해당 모델을 듣고 있는 위젯에게 rebuild해야 함을 알립니다.\u003c/span\u003e\n    \u003cspan class=\"hljs-title function_\"\u003enotifyListeners\u003c/span\u003e();\n\n    \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFuture\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003edelayed\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDuration\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eseconds\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e));\n\n    _state = \u003cspan class=\"hljs-title class_\"\u003eStatus\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003esuccess\u003c/span\u003e;\n    \u003cspan class=\"hljs-title function_\"\u003enotifyListeners\u003c/span\u003e();\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eChangeNotifierProvider\u003c/h2\u003e\n\u003cp\u003eChangeNotifierProvider은 ChangeNotifier 인스턴스를 후손들에게 제공하는 위젯입니다. provider 패키지에서 제공됩니다.\u003c/p\u003e\n\u003cp\u003eChangeNotifierProvider를 어디에 배치해야 하는지 이미 알고 계시네요: 액세스해야 하는 위젯들 위에요. CartModel의 경우, MyCart와 MyCatalog 둘 다 위쪽에 어딘가에 있어야 합니다.\u003c/p\u003e\n\u003cp\u003e우리 예제에서 ChangeNotifierProvider와 HomeProvider (UI)를 자식으로 하는 ProviderPage가 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eProviderPage\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eStatelessWidget\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e route = \u003cspan class=\"hljs-string\"\u003e'provider-page'\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eProviderPage\u003c/span\u003e({\u003cspan class=\"hljs-variable language_\"\u003esuper\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ekey\u003c/span\u003e});\n\n  @override\n  \u003cspan class=\"hljs-title class_\"\u003eWidget\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebuild\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eBuildContext context\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eChangeNotifierProvider\u003c/span\u003e(\n      \u003cspan class=\"hljs-attr\"\u003ecreate\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003econtext\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDataProvider\u003c/span\u003e(),\n      \u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHomeProvider\u003c/span\u003e(),\n    );\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eConsumer\u003c/h2\u003e\n\u003cp\u003e요소별로 Translation을 제공합니다:\u003c/p\u003e\n\u003cp\u003eConsumer 위젯을 가능한 깊이까지 Tree 안에 두는 것이 최선의 방법입니다. 어딘가의 세부 사항이 변경되었을 때 UI의 큰 부분을 다시 빌드하고 싶지 않으니까요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-dart\"\u003e\u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eHomeProvider\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eStatefulWidget\u003c/span\u003e \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e HomeProvider({\u003cspan class=\"hljs-keyword\"\u003esuper\u003c/span\u003e.key});\n\n  \u003cspan class=\"hljs-meta\"\u003e@override\u003c/span\u003e\n  State\u0026#x3C;HomeProvider\u003e createState() =\u003e _HomeProviderState();\n}\n\n\u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003e_HomeProviderState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eState\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title\"\u003eHomeProvider\u003c/span\u003e\u003e \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003elate\u003c/span\u003e DataProvider provider;\n\n  \u003cspan class=\"hljs-meta\"\u003e@override\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e initState() {\n    provider = Provider.of\u0026#x3C;DataProvider\u003e(context, listen: \u003cspan class=\"hljs-keyword\"\u003efalse\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003esuper\u003c/span\u003e.initState();\n  }\n\n  \u003cspan class=\"hljs-meta\"\u003e@override\u003c/span\u003e\n  Widget build(BuildContext context) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e Scaffold(\n      appBar: AppBar(title: \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e Text(\u003cspan class=\"hljs-string\"\u003e'Provider Page'\u003c/span\u003e)),\n      \u003cspan class=\"hljs-comment\"\u003e// Consumer 위젯을 가능한 깊이까지 Tree 안에 두는 것이 최선의 방법입니다.\u003c/span\u003e\n      \u003cspan class=\"hljs-comment\"\u003e// 어딘가의 세부 사항이 변경되었을 때 UI의 큰 부분을 다시 빌드하고 싶지 않으니까요.\u003c/span\u003e\n      body: Consumer\u0026#x3C;DataProvider\u003e(\n        builder: (context, data, child) {\n          \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (data.state == Status.initial) {\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e Center(child: Text(\u003cspan class=\"hljs-string\"\u003e'Press the Button'\u003c/span\u003e));\n          }\n          \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (data.state == Status.loading) {\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e Center(child: CircularProgressIndicator());\n          }\n          \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (data.state == Status.success) {\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e Center(child: Text(\u003cspan class=\"hljs-string\"\u003e'Success'\u003c/span\u003e));\n          }\n          \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e Container();\n        },\n      ),\n      floatingActionButton: Column(\n        crossAxisAlignment: CrossAxisAlignment.end,\n        mainAxisAlignment: MainAxisAlignment.end,\n        children: \u0026#x3C;Widget\u003e[\n          FloatingActionButton(\n            child: \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e Icon(Icons.play_arrow),\n            onPressed: () =\u003e provider.fecthData(),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그 결과는 다음과 같습니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_8.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch2\u003e장점\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eFlutter를 처음 사용하는 경우 시작해야 할 접근 방식입니다. 이해하기 쉽고 많은 코드를 사용하지 않습니다.\u003c/li\u003e\n\u003cli\u003eDevtool 친화적 — Provider를 사용하면 애플리케이션의 상태가 Flutter devtool에서 볼 수 있습니다.\u003c/li\u003e\n\u003cli\u003e데이터 할당 및 자원 (데이터) 해제를 간소화합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e단점\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e불필요한 업데이트를 실수로 호출할 수 있습니다. 객체의 상태가 변경되었을 때마다 업데이트를 트리거할 필요는 없습니다. 그러나 Provider를 사용하는 경우 변경이 발생할 때마다 항상 업데이트를 트리거합니다.\u003c/li\u003e\n\u003cli\u003e확장성\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003eBLoC\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e이 패키지의 목적은 UI와 비즈니스 로직을 분리하는 것을 용이하게 하는 것입니다.\u003c/li\u003e\n\u003cli\u003e이 패키지는 패턴의 반응적 부분을 추상화하여 개발자가 비즈니스 로직 작성에 집중할 수 있도록 합니다.\u003c/li\u003e\n\u003cli\u003eBloc은 이벤트를 기반으로 한 상태 변경을 트리거하는 메서드 대신 메서드 대신 사용하는 고급 클래스입니다. Bloc은 이벤트를 수신하고 수신된 이벤트를 발생한 이벤트로 변환합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_9.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e이 부분을 좀 더 잘 이해하기 위해 이벤트가 UI에서 추가되고 BLoC에서 이를 처리하고 이러한 이벤트에 대한 상태 변경으로 응답합니다. bloc 라이브러리를 사용하면 Presentation, Business Logic 및 Data가 세 개의 레이어로 나뉘도록 응용 프로그램을 분리할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e상태 변경은 이벤트가 추가될 때 블록이 시작되며 onEvent을 트리거합니다. 그런 다음, 이벤트는 EventTransformer를 통해 흘러갑니다. 기본적으로 각 이벤트는 병렬로 처리되지만 사용자 정의 EventTransformer를 제공하여 들어오는 이벤트 스트림을 조작할 수 있습니다. 해당 이벤트 유형에 대해 등록된 모든 EventHandlers는 들어오는 이벤트와 함께 호출됩니다. 각 EventHandler는 이벤트에 대한 응답으로 제로 이상의 상태를 발행하는 책임이 있습니다. 마지막으로, 상태가 업데이트되기 직전에 onTransition이 호출되며 현재 상태, 이벤트 및 다음 상태를 포함합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_10.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003eBLoC 구현에서는 data_bloc, data_event 및 data_state 총 3개의 파일이 필요합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_11.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e블록 상태에서는 세 가지 상태를 가질 것입니다: 초기, 로딩 및 성공.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003epart \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'data_bloc.dart'\u003c/span\u003e;\n\n\nabstract \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDataState\u003c/span\u003e {}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eInitial\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eDataState\u003c/span\u003e {}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eLoading\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eDataState\u003c/span\u003e {}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSuccess\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eDataState\u003c/span\u003e {}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e또한, 블록 이벤트에서는 FetchDataEvent만 사용할 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003epart \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'data_bloc.dart'\u003c/span\u003e;\n\nabstract \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDataEvent\u003c/span\u003e {}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFetchDataEvent\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eDataEvent\u003c/span\u003e {}\n\n\u0026#x3C;div \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"content-ad\"\u003c/span\u003e\u003e\u0026#x3C;/div\u003e\n\n\u003cspan class=\"hljs-title class_\"\u003eIn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDataBloc\u003c/span\u003e, when the \u003cspan class=\"hljs-title class_\"\u003eFetchDataEvent\u003c/span\u003e is added, the _onFetchDataEvent method is triggered.\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:flutter_bloc/flutter_bloc.dart'\u003c/span\u003e;\n\npart \u003cspan class=\"hljs-string\"\u003e'data_event.dart'\u003c/span\u003e;\npart \u003cspan class=\"hljs-string\"\u003e'data_state.dart'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDataBloc\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eBloc\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eDataEvent\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eDataState\u003c/span\u003e\u003e {\n  \u003cspan class=\"hljs-title class_\"\u003eDataBloc\u003c/span\u003e() : \u003cspan class=\"hljs-title function_\"\u003esuper\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eInitial()\u003c/span\u003e) {\n    on\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eFetchDataEvent\u003c/span\u003e\u003e(_onFetchDataEvent);\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e_onFetchDataEvent\u003c/span\u003e(\n    \u003cspan class=\"hljs-title class_\"\u003eFetchDataEvent\u003c/span\u003e event,\n    \u003cspan class=\"hljs-title class_\"\u003eEmitter\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eDataState\u003c/span\u003e\u003e emit,\n  ) \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n    \u003cspan class=\"hljs-title function_\"\u003eemit\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eLoading\u003c/span\u003e());\n    \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFuture\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003edelayed\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDuration\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eseconds\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e));\n    \u003cspan class=\"hljs-title function_\"\u003eemit\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eSuccess\u003c/span\u003e());\n  }\n}\n\n\u003cspan class=\"hljs-title class_\"\u003eIn\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e example, we have a \u003cspan class=\"hljs-title class_\"\u003eBlocPage\u003c/span\u003e that includes a \u003cspan class=\"hljs-title class_\"\u003eBlocProvider\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHomeBloc\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e a child.\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBlocPage\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eStatelessWidget\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e route = \u003cspan class=\"hljs-string\"\u003e'bloc-page'\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBlocPage\u003c/span\u003e({\u003cspan class=\"hljs-title class_\"\u003eKey\u003c/span\u003e key}) : \u003cspan class=\"hljs-variable language_\"\u003esuper\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e: key);\n\n  @override\n  \u003cspan class=\"hljs-title class_\"\u003eWidget\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebuild\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eBuildContext context\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBlocProvider\u003c/span\u003e(\n      \u003cspan class=\"hljs-attr\"\u003ecreate\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003econtext\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDataBloc\u003c/span\u003e(),\n      \u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHomeBloc\u003c/span\u003e(),\n    );\n  }\n}\n\n\u0026#x3C;div \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"content-ad\"\u003c/span\u003e\u003e\u0026#x3C;/div\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHomeBloc\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eStatefulWidget\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHomeBloc\u003c/span\u003e({\u003cspan class=\"hljs-variable language_\"\u003esuper\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ekey\u003c/span\u003e});\n\n  @override\n  \u003cspan class=\"hljs-title class_\"\u003eState\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eHomeBloc\u003c/span\u003e\u003e \u003cspan class=\"hljs-title function_\"\u003ecreateState\u003c/span\u003e() =\u003e \u003cspan class=\"hljs-title function_\"\u003e_HomeBlocState\u003c/span\u003e();\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003e_HomeBlocState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eState\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eHomeBloc\u003c/span\u003e\u003e {\n  late \u003cspan class=\"hljs-title class_\"\u003eDataBloc\u003c/span\u003e bloc;\n\n  @override\n  \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003einitState\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    bloc = \u003cspan class=\"hljs-title class_\"\u003eBlocProvider\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eof\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eDataBloc\u003c/span\u003e\u003e(context);\n    \u003cspan class=\"hljs-variable language_\"\u003esuper\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003einitState\u003c/span\u003e();\n  }\n\n  @override\n  \u003cspan class=\"hljs-title class_\"\u003eWidget\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebuild\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eBuildContext context\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eScaffold\u003c/span\u003e(\n      \u003cspan class=\"hljs-attr\"\u003eappBar\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eAppBar\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'BLoC 페이지'\u003c/span\u003e)),\n      \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eBlocBuilder\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eDataBloc\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eDataState\u003c/span\u003e\u003e(\n        \u003cspan class=\"hljs-attr\"\u003ebuilder\u003c/span\u003e: (context, state) {\n          \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (state is \u003cspan class=\"hljs-title class_\"\u003eInitial\u003c/span\u003e) {\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCenter\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'버튼을 눌러주세요'\u003c/span\u003e));\n          }\n          \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (state is \u003cspan class=\"hljs-title class_\"\u003eLoading\u003c/span\u003e) {\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCenter\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCircularProgressIndicator\u003c/span\u003e());\n          }\n          \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (state is \u003cspan class=\"hljs-title class_\"\u003eSuccess\u003c/span\u003e) {\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCenter\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'성공'\u003c/span\u003e));\n          }\n          \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eContainer\u003c/span\u003e();\n        },\n      ),\n      \u003cspan class=\"hljs-attr\"\u003efloatingActionButton\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eColumn\u003c/span\u003e(\n        \u003cspan class=\"hljs-attr\"\u003ecrossAxisAlignment\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCrossAxisAlignment\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eend\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003emainAxisAlignment\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eMainAxisAlignment\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eend\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003echildren\u003c/span\u003e: \u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eWidget\u003c/span\u003e\u003e[\n          \u003cspan class=\"hljs-title class_\"\u003eFloatingActionButton\u003c/span\u003e(\n            \u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eIcon\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eIcons\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eplay_arrow\u003c/span\u003e),\n            \u003cspan class=\"hljs-attr\"\u003eonPressed\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e bloc.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eFetchDataEvent\u003c/span\u003e()),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\n그리고 \u003cspan class=\"hljs-title class_\"\u003eBloc\u003c/span\u003e 결과입니다:\n\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eimg\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_12.png\"\u003c/span\u003e /\u003e\u003c/span\u003e\u003c/span\u003e\n\n## 장점\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e애플리케이션의 상태를 언제든지 파악할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e앱이 적절하게 응답하는지 확인하기 위해 모든 케이스를 쉽게 테스트할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e애플리케이션에서 모든 사용자 상호 작용을 기록하여 데이터 기반 결정을 내릴 수 있습니다.\u003c/li\u003e\n\u003cli\u003e빠르고 반응성 있는 앱을 개발할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e대규모 데이터 크기에 대해 더 나은 성능을 제공합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e단점\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e대형 애플리케이션을 가지고 있을 때만 효과적입니다.\u003c/li\u003e\n\u003cli\u003e두 방향으로 스트림을 사용해야 하므로 Provider보다 더 많은 보일러플레이트가 발생할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e복잡한 시나리오에서는 너무 제한적일 수 있으며 하나의 입력과 출력만 다루는 BLoC를 생성할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e특히 앱의 여러 부분에 유사한 비즈니스 로직을 구현해야할 경우 코드 중복으로 이어질 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003eGetX\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e플러터에 대한 가벼우면서도 강력한 솔루션입니다. 고성능 상태 관리, 스마트한 의존성 주입, 라우트 관리를 빠르고 실용적으로 결합합니다.\u003c/li\u003e\n\u003cli\u003e성능과 자원 최소 소비에 중점을 둡니다. GetX는 Streams나 ChangeNotifier를 사용하지 않습니다.\u003c/li\u003e\n\u003cli\u003e사용하기 쉽고 즐거운 구문을 사용합니다.\u003c/li\u003e\n\u003cli\u003e뷰, 표현 로직, 비즈니스 로직, 의존성 주입, 네비게이션의 완전한 분리를 허용합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e다음 이미지에서 모든 GetX 기능을 확인할 수 있습니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_13.png\" alt=\"GetX Functions\"\u003e\u003c/p\u003e\n\u003cp\u003e하지만 우리에게 가장 중요한 것은 반응형 상태 관리자입니다.\u003c/p\u003e\n\u003ch2\u003e반응성 상태 관리자\u003c/h2\u003e\n\u003cp\u003e반응형 프로그래밍은 복잡하다고 말리기 때문에 많은 사람들을 멀리하곤 합니다. GetX는 반응형 프로그래밍을 꽤 간단하게 만들어 줍니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eStreamControllers를 만들 필요가 없습니다.\u003c/li\u003e\n\u003cli\u003e각 변수마다 StreamBuilder를 만들 필요가 없습니다.\u003c/li\u003e\n\u003cli\u003e각 상태마다 클래스를 만들 필요가 없습니다.\u003c/li\u003e\n\u003cli\u003e초기 값에 대한 get을 만들 필요가 없습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이름 변수가 있고 이 변수를 변경할 때마다 사용하는 모든 위젯이 자동으로 변경되기를 원한다고 상상해 봅시다.\u003c/p\u003e\n\u003cp\u003e여기 당신의 계수 변수가 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e name = \u003cspan class=\"hljs-string\"\u003e'Jonatas Borges'\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이를 관찰 가능하도록 만들기 위해서는 그 뒤에 \".obs\"를 추가하기만 하면 돼요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e name = \u003cspan class=\"hljs-string\"\u003e'Jonatas Borges'\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eobs\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eUI에서 해당 값이 표시되고 값이 변경될 때 화면을 업데이트하려면 다음과 같이 하면 됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eObx\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"${controller.name}\"\u003c/span\u003e));\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e단순합니다.\u003c/p\u003e\n\u003cp\u003e이제 코드로 넘어갑니다. GetX에서 Controller가 정의됩니다. 이 경우 GetxController를 확장한 Controller 클래스를 만듭니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e열거형 \u003cspan class=\"hljs-title class_\"\u003eStatus\u003c/span\u003e {\n  초기,\n  로딩,\n  성공,\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eController\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eGetxController\u003c/span\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e// GetX는 반응형이기 때문에 변수가 변경되면 자동으로 화면에서 변경됩니다.\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// 변수 앞에 \".obs\"를 추가하기만 하면 이미 반응형입니다.\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e state = \u003cspan class=\"hljs-title class_\"\u003eStatus\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003einitial\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eobs\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-comment\"\u003e/// 컨트롤러의 상태를 업데이트합니다. 이 방법이 컨트롤러를 외부에서 수정하는 유일한 방법입니다.\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetchData\u003c/span\u003e() \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n    state.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eStatus\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eloading\u003c/span\u003e;\n    \u003cspan class=\"hljs-comment\"\u003e//update();\u003c/span\u003e\n\n    \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFuture\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003edelayed\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDuration\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eseconds\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e));\n\n    state.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eStatus\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003esuccess\u003c/span\u003e;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eUI에서 우리는 GetXPage가 있습니다. 그 안에는 간단한 HomeGetX 위젯이 자식으로 있습니다. 이 방식으로 정의되었는데, Provider 및 Bloc과의 차이를 보려고 했습니다. Provider나 Bloc을 자식 위젯에 제공하기 위해 ChangeNotifierProvider나 BlocProvider의 부모 위젯을 정의해야 했던 과정과의 차이점을 볼 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eGetXPage\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eStatelessWidget\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e route = \u003cspan class=\"hljs-string\"\u003e'getx-page'\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eGetXPage\u003c/span\u003e({key}) : \u003cspan class=\"hljs-variable language_\"\u003esuper\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e: key);\n\n  @override\n  \u003cspan class=\"hljs-title class_\"\u003eWidget\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebuild\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eBuildContext context\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHomeGetX\u003c/span\u003e();\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHomeGetX\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eStatefulWidget\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHomeGetX\u003c/span\u003e({\u003cspan class=\"hljs-variable language_\"\u003esuper\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ekey\u003c/span\u003e});\n\n  @override\n  \u003cspan class=\"hljs-title class_\"\u003eState\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eHomeGetX\u003c/span\u003e\u003e \u003cspan class=\"hljs-title function_\"\u003ecreateState\u003c/span\u003e() =\u003e \u003cspan class=\"hljs-title function_\"\u003e_HomeGetXState\u003c/span\u003e();\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003e_HomeGetXState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eState\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eHomeGetX\u003c/span\u003e\u003e {\n  late \u003cspan class=\"hljs-title class_\"\u003eController\u003c/span\u003e c;\n\n  @override\n  \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003einitState\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    c = \u003cspan class=\"hljs-title class_\"\u003eGet\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eput\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eController\u003c/span\u003e());\n    \u003cspan class=\"hljs-variable language_\"\u003esuper\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003einitState\u003c/span\u003e();\n  }\n\n  @override\n  \u003cspan class=\"hljs-title class_\"\u003eWidget\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebuild\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eBuildContext context\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eScaffold\u003c/span\u003e(\n      \u003cspan class=\"hljs-attr\"\u003eappBar\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eAppBar\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'GetX Page'\u003c/span\u003e)),\n      \u003cspan class=\"hljs-comment\"\u003e//최상위에 Consumer 위젯을 가능한 깊게 두는 것이 가장 좋습니다.\u003c/span\u003e\n      \u003cspan class=\"hljs-comment\"\u003e//어딘가의 세부 사항이 변경되었기 때문에 UI의 큰 부분을 다시 빌드하고 싶지 않습니다.\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eGetX\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eController\u003c/span\u003e\u003e(\n        \u003cspan class=\"hljs-attr\"\u003ebuilder\u003c/span\u003e: (context) {\n          \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (c.\u003cspan class=\"hljs-property\"\u003estate\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e == \u003cspan class=\"hljs-title class_\"\u003eStatus\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003einitial\u003c/span\u003e) {\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCenter\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Press the Button'\u003c/span\u003e));\n          }\n          \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (c.\u003cspan class=\"hljs-property\"\u003estate\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e == \u003cspan class=\"hljs-title class_\"\u003eStatus\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eloading\u003c/span\u003e) {\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCenter\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCircularProgressIndicator\u003c/span\u003e());\n          }\n          \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (c.\u003cspan class=\"hljs-property\"\u003estate\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e == \u003cspan class=\"hljs-title class_\"\u003eStatus\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003esuccess\u003c/span\u003e) {\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCenter\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Success'\u003c/span\u003e));\n          }\n          \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eContainer\u003c/span\u003e();\n        },\n      ),\n      \u003cspan class=\"hljs-attr\"\u003efloatingActionButton\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eColumn\u003c/span\u003e(\n        \u003cspan class=\"hljs-attr\"\u003ecrossAxisAlignment\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCrossAxisAlignment\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eend\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003emainAxisAlignment\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eMainAxisAlignment\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eend\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003echildren\u003c/span\u003e: \u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eWidget\u003c/span\u003e\u003e[\n          \u003cspan class=\"hljs-title class_\"\u003eFloatingActionButton\u003c/span\u003e(\n            \u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eIcon\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eIcons\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eplay_arrow\u003c/span\u003e),\n            \u003cspan class=\"hljs-attr\"\u003eonPressed\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e c.\u003cspan class=\"hljs-title function_\"\u003efecthData\u003c/span\u003e(),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e결과는 다음과 같습니다:\u003c/p\u003e\n\u003ch2\u003e장점\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e몇 줄의 코드로 작성된 간단한 상태 업데이터입니다. 최소한의 CPU 영향을 주도록 단순하게 만들었고, 단일 목적을 충족하고 가능한 한 최소한의 리소스를 사용하기 위해 제작되었습니다.\u003c/li\u003e\n\u003cli\u003e강력한 상태 관리자이며 변수가 아닌 흐름(Flow)으로 작동하며, 내부적으로는 모든 것이 스트림(Stream)입니다.\u003c/li\u003e\n\u003cli\u003e코드 생성기나 장식품(Decoration) 없이도 실제로 BLoC 접근 방식입니다. .obs를 사용하여 모든 것을 \"Observable\"로 변환할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e단점\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e문제들이 많이 발생할 수 있으며 중복될 수도 있습니다. 문제 해결, 답변, 태깅, 중복 제거 등에 대해 아무도 관심을 가지지 않는 것이 분명합니다.\u003c/li\u003e\n\u003cli\u003eGetX가 너무 많은 작업을 수행하고 이 프로젝트가 단 한 사람에게는 너무 큽니다.\u003c/li\u003e\n\u003cli\u003e핫 리로드 문제 - GetX는 자체 종속성 주입 시스템을 가지고 있으며, 이는 GetX 모듈의 거의 모든 곳에서 사용되지만 아직 안정적이지 않습니다.\u003c/li\u003e\n\u003cli\u003eGetX로 단위 및 위젯 테스트를 작성하는 것은 정말 어렵고 몇 가지 경우에는 일부 기능을 테스트하는 것이 불가능합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003eRiverpod\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eProvider와 유사하며 컴파일 안전성과 테스트 가능성을 갖추고 있습니다.\u003c/li\u003e\n\u003cli\u003eRiverpod은 Provider에서 영감을 받았지만 동일한 유형의 여러 공급자 지원; 비동기 공급자 대기; 어디서든 공급자 추가와 같은 주요 문제들을 해결합니다.\u003c/li\u003e\n\u003cli\u003e이제 main.dart와 UI 파일 간에 이동할 필요가 없어졌습니다.\u003c/li\u003e\n\u003cli\u003e공유 상태 코드를 필요한 곳에 배치하고, 별도의 패키지에 있든 위젯 옆에 있든 테스트 가능성을 잃지 않고 유지하세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eProviders는 Riverpod 앱의 가장 중요한 요소입니다. Provider는 상태 조각을 캡슐화하고 해당 상태를 청취할 수 있는 개체입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eenum \u003cspan class=\"hljs-title class_\"\u003eStatus\u003c/span\u003e {\n  initial,\n  loading,\n  success,\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eRiverpodProvider\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eStateNotifier\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eStatus\u003c/span\u003e\u003e {\n  \u003cspan class=\"hljs-title class_\"\u003eRiverpodProvider\u003c/span\u003e() : \u003cspan class=\"hljs-variable language_\"\u003esuper\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eStatus\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003einitial\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-title class_\"\u003eFuture\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e\u003e \u003cspan class=\"hljs-title function_\"\u003efetchData\u003c/span\u003e() \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n    state = \u003cspan class=\"hljs-title class_\"\u003eStatus\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eloading\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFuture\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003edelayed\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDuration\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eseconds\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e));\n\n    state = \u003cspan class=\"hljs-title class_\"\u003eStatus\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003esuccess\u003c/span\u003e;\n  }\n}\n\nfinal riverpodProvider =\n    \u003cspan class=\"hljs-title class_\"\u003eStateNotifierProvider\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eautoDispose\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eref\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eRiverpodProvider\u003c/span\u003e());\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eUI에서 다음과 같이 하고 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-dart\"\u003e\u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eRiverpodPage\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eStatelessWidget\u003c/span\u003e \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e route = \u003cspan class=\"hljs-string\"\u003e'riverpod-page'\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e RiverpodPage({\u003cspan class=\"hljs-keyword\"\u003esuper\u003c/span\u003e.key});\n\n  \u003cspan class=\"hljs-meta\"\u003e@override\u003c/span\u003e\n  Widget build(BuildContext context) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e ProviderScope(\n      child: HomeRiverpod(),\n    );\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위젯이 프로바이더를 읽을 수 있도록 하려면 전체 애플리케이션을 \"ProviderScope\" 위젯으로 감싸야 합니다. 이곳에는 프로바이더의 상태가 저장됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-dart\"\u003e\u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eHomeRiverpod\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eConsumerWidget\u003c/span\u003e \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e HomeRiverpod({\u003cspan class=\"hljs-keyword\"\u003esuper\u003c/span\u003e.key});\n\n  \u003cspan class=\"hljs-meta\"\u003e@override\u003c/span\u003e\n  Widget build(BuildContext context, WidgetRef ref) {\n    \u003cspan class=\"hljs-keyword\"\u003efinal\u003c/span\u003e data = ref.read(riverpodProvider.notifier);\n\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e Scaffold(\n      appBar: AppBar(title: \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e Text(\u003cspan class=\"hljs-string\"\u003e'Riverpod Page'\u003c/span\u003e)),\n      \u003cspan class=\"hljs-comment\"\u003e// 소비자 위젯을 가능한 깊게 트리 안에 배치하는 것이 가장 좋습니다.\u003c/span\u003e\n      \u003cspan class=\"hljs-comment\"\u003e// 어딘가의 세부 사항이 변경되었을 때 UI의 큰 부분을 다시 빌드하고 싶지 않습니다.\u003c/span\u003e\n      body: Consumer(\n        builder: (context, ref, child) {\n          \u003cspan class=\"hljs-keyword\"\u003efinal\u003c/span\u003e state = ref.watch(riverpodProvider);\n          \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (state == Status.initial) {\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e Center(child: Text(\u003cspan class=\"hljs-string\"\u003e'Press the Button'\u003c/span\u003e));\n          }\n          \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (state == Status.loading) {\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e Center(child: CircularProgressIndicator());\n          }\n          \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (state == Status.success) {\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e Center(child: Text(\u003cspan class=\"hljs-string\"\u003e'Success'\u003c/span\u003e));\n          }\n          \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e Container();\n        },\n      ),\n      floatingActionButton: Column(\n        crossAxisAlignment: CrossAxisAlignment.end,\n        mainAxisAlignment: MainAxisAlignment.end,\n        children: \u0026#x3C;Widget\u003e[\n          FloatingActionButton(\n            child: \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e Icon(Icons.play_arrow),\n            onPressed: () =\u003e data.fetchData(),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e제공자들과 상호 작용하는 ref 사용하기\u003c/h2\u003e\n\u003cp\u003e\"ref\"를 사용하는 주요 용도는 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eref.watch를 사용하여 제공자의 값을 얻고 변경 사항을 청취하는 것입니다. 값이 변경되면 해당 위젯이나 제공자가 다시 빌드되는 기능입니다.\u003c/li\u003e\n\u003cli\u003eref.listen을 사용하여 제공자에서 리스너를 추가하여 해당 제공자가 변경될 때 새 페이지로 이동하거나 모달을 표시하는 등의 동작을 실행하는 것입니다.\u003c/li\u003e\n\u003cli\u003eref.read를 사용하여 변경 사항을 무시하고 제공자의 값을 얻는 것입니다. \"클릭\"과 같은 이벤트에서 제공자의 값을 필요로 할 때 유용합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 결과는 다음과 같습니다:\u003c/p\u003e\n\u003cp\u003e빠른 대답을 위해 노력중입니다!\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eRiverpod은 앱에서 상태를 구현하는 데 너무 많은 자유를 제공합니다. 이는 새로운 개발자들에게 가장 좋은 접근 방식을 선택하는 데 어려움을 줄 수 있습니다.\u003c/li\u003e\n\u003cli\u003e공유 상태를 위젯 트리 전체에 분산시키는 나쁜 안티패턴을 촉진합니다. 이는 코드가 매우 찾기 어렵도록 (중앙화되지 않음) 하고, Provider 간에 과도한 의존성 체인과 결합으로 디버깅을 추적하기 어렵게 만들 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003eGetIt\u003c/h1\u003e\n\u003cp\u003eGetIt은 상태 관리 솔루션이 아닙니다! 객체의 로케이터이므로 스트림이나 ValueNotifiers와 같은 다른 방법을 사용하여 UI에 변경을 알릴 필요가 있습니다. 그러나 get_it_mixin과 함께 사용하면 get_it에 등록된 객체와 통합되는 완전한 기능의 쉬운 상태 관리 솔루션이 됩니다.\u003c/p\u003e\n\u003cp\u003eGetIt은:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e극히 빠름\u003c/li\u003e\n\u003cli\u003e배우고 사용하기 쉬움\u003c/li\u003e\n\u003cli\u003eProvider나 Redux처럼 데이터에 액세스하기 위해 특별한 위젯을 UI 트리에 추가하지 않음\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e저희의 구현은 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eenum \u003cspan class=\"hljs-title class_\"\u003eStatus\u003c/span\u003e {\n  initial,\n  loading,\n  success,\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eGetItProvider\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eChangeNotifier\u003c/span\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e/// GetItProvider의 내부 및 비공개 상태입니다.\u003c/span\u003e\n  \u003cspan class=\"hljs-title class_\"\u003eStatus\u003c/span\u003e _state = \u003cspan class=\"hljs-title class_\"\u003eStatus\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003einitial\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-comment\"\u003e/// GetItProvider의 상태입니다.\u003c/span\u003e\n  \u003cspan class=\"hljs-title class_\"\u003eStatus\u003c/span\u003e get state =\u003e _state;\n\n  \u003cspan class=\"hljs-comment\"\u003e/// GetItProvider의 상태를 업데이트합니다. 이는 외부에서 GetItProvider를 수정하는 유일한 방법입니다.\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efecthData\u003c/span\u003e() \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n    _state = \u003cspan class=\"hljs-title class_\"\u003eStatus\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eloading\u003c/span\u003e;\n    \u003cspan class=\"hljs-comment\"\u003e// 이 호출은 이 모델을 듣고 있는 위젯에게 다시 빌드하도록 지시합니다.\u003c/span\u003e\n    \u003cspan class=\"hljs-title function_\"\u003enotifyListeners\u003c/span\u003e();\n\n    \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFuture\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003edelayed\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDuration\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eseconds\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e));\n\n    _state = \u003cspan class=\"hljs-title class_\"\u003eStatus\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003esuccess\u003c/span\u003e;\n    \u003cspan class=\"hljs-title function_\"\u003enotifyListeners\u003c/span\u003e();\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e만약 주목했다면, GetItProvider가 Provider를 검토할 때 우리가 구현한 DataProvider와 동일하다는 것을 알 수 있어요.\u003c/p\u003e\n\u003cp\u003e객체에 액세스하기 전에는 GetIt에 그들을 등록해야 합니다. 보통 initState 코드 내에서 직접 등록합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eGetItPage\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eStatefulWidget\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e route = \u003cspan class=\"hljs-string\"\u003e'get-it-page'\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eGetItPage\u003c/span\u003e({\u003cspan class=\"hljs-variable language_\"\u003esuper\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ekey\u003c/span\u003e});\n\n  @override\n  \u003cspan class=\"hljs-title class_\"\u003eState\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eGetItPage\u003c/span\u003e\u003e \u003cspan class=\"hljs-title function_\"\u003ecreateState\u003c/span\u003e() =\u003e \u003cspan class=\"hljs-title function_\"\u003e_GetItPageState\u003c/span\u003e();\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003e_GetItPageState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eState\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eGetItPage\u003c/span\u003e\u003e {\n  @override\n  \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003einitState\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e//시작할 때 모든 객체를 등록합니다.\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e//나중에 액세스하려는 객체들을 이렇게 등록하세요:\u003c/span\u003e\n    \u003cspan class=\"hljs-title class_\"\u003eGetIt\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eI\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eregisterSingleton\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eGetItProvider\u003c/span\u003e\u003e(\u003cspan class=\"hljs-title class_\"\u003eGetItProvider\u003c/span\u003e());\n    \u003cspan class=\"hljs-variable language_\"\u003esuper\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003einitState\u003c/span\u003e();\n  }\n\n  @override\n  \u003cspan class=\"hljs-title class_\"\u003eWidget\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebuild\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eBuildContext context\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHomeGetIt\u003c/span\u003e();\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eGetIt로 데이터를 읽는 것은 이미 간단합니다. 하지만 mixin을 추가하면 더욱 쉬워집니다. StatelessWidget에 GetItMixin을 추가하고 get\u003ccode\u003eT\u003c/code\u003e를 호출하면 됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-dart\"\u003e\u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eHomeGetIt\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eStatelessWidget\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ewith\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eGetItMixin\u003c/span\u003e \u003c/span\u003e{\n  HomeGetIt({\u003cspan class=\"hljs-keyword\"\u003esuper\u003c/span\u003e.key});\n\n  \u003cspan class=\"hljs-meta\"\u003e@override\u003c/span\u003e\n  Widget build(BuildContext context) {\n    \u003cspan class=\"hljs-comment\"\u003e// 보기 쉽게! view 가 rebuild 되기를 원할 때는 watchOnly 를 호출하여 상태가 변경될 때마다 알려줄 수 있습니다:\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003efinal\u003c/span\u003e state =\n        watchOnly((GetItProvider getItProvider) =\u003e getItProvider.state);\n\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e Scaffold(\n      appBar: AppBar(title: \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e Text(\u003cspan class=\"hljs-string\"\u003e'GetIt 페이지'\u003c/span\u003e)),\n      body: Builder(\n        builder: (context) {\n          \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (state == Status.initial) {\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e Center(child: Text(\u003cspan class=\"hljs-string\"\u003e'버튼을 눌러보세요'\u003c/span\u003e));\n          }\n          \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (state == Status.loading) {\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e Center(child: CircularProgressIndicator());\n          }\n          \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (state == Status.success) {\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e Center(child: Text(\u003cspan class=\"hljs-string\"\u003e'성공'\u003c/span\u003e));\n          }\n          \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e Container();\n        },\n      ),\n      floatingActionButton: Column(\n        crossAxisAlignment: CrossAxisAlignment.end,\n        mainAxisAlignment: MainAxisAlignment.end,\n        children: \u0026#x3C;Widget\u003e[\n          FloatingActionButton(\n            child: \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e Icon(Icons.play_arrow),\n            \u003cspan class=\"hljs-comment\"\u003e// 이후 아래와 같이 GetItProvider 클래스에 접근할 수 있습니다:\u003c/span\u003e\n            onPressed: () =\u003e \u003cspan class=\"hljs-keyword\"\u003eget\u003c/span\u003e\u0026#x3C;GetItProvider\u003e().fecthData(),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e보통 데이터 원본 타입에 대한 다양한 watch 메서드가 있습니다. ChangeNotifier, ValueNotifier, Stream 및 Future를 포함합니다.\u003c/p\u003e\n\u003cp\u003ewatch 메서드의 주요 이점은 ValueListenableBuilders, StreamBuilder 등을 사용하지 않아도 된다는 것입니다. 각 바인딩마다 한 줄만 사용되며 중첩이 없으므로 가독성이 좋습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_16.png\" alt=\"alt text\"\u003e\u003c/p\u003e\n\u003ch2\u003e장점\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e간단하고 사용하기 쉽며, Flutter에 의존하지 않아서 모든 Dart 코드와 함께 사용할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e매우 빠르고 배우기/사용하기 쉽습니다. UI 트리를 특별한 위젯으로 엮지 않고 데이터에 액세스할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e단점\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e위젯 트리의 본질적인 부분이 아니기 때문에 항목을 수동으로 폐기하거나 등록 해제해야 할 수도 있습니다.\u003c/li\u003e\n\u003cli\u003e동일한 형식의 인스턴스를 제공하는 문제가 있지만 등록할 때 이름 필드를 노출하기 때문에 문제에 대한 합리적인 해결책을 제공합니다.\u003c/li\u003e\n\u003cli\u003eGetIt 싱글톤의 전역적인 성격을 선호하지 않는 개발자들도 있을 수 있으며, 이는 riverpod나 Provider의 더 제한적인 스코핑 모델을 선호할 수도 있습니다. 다른 개발자들은 이것을 이점으로 생각할 수도 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003eMobX\u003c/h1\u003e\n\u003cp\u003eMobX는 응용 프로그램의 반응형 데이터와 UI를 간단히 연결하는 상태 관리 라이브러리입니다. 이 연결은 완전히 자동적이며 매우 자연스럽게 느껴집니다. 응용 프로그램 개발자는 UI에서 (그리고 다른 곳에서) 소비해야 하는 반응형 데이터에 순수하게 집중할 뿐, 두 가지를 동기화할 필요없이 고민할 필요가 없습니다.\u003c/p\u003e\n\u003cp\u003e실제로 마법은 아니지만, 소비되는 것(observable)과 어디에서(reactions) 소비되는지에 관한 지혜가 있으며, 이를 자동으로 추적합니다. observable이 변경되면 모든 reactions가 다시 실행됩니다. 흥미로운 점은 이러한 reactions가 간단한 콘솔 로그에서 네트워크 호출 또는 UI 다시 렌더링까지 모두 될 수 있다는 것입니다.\u003c/p\u003e\n\u003cp\u003eMobX의 핵심에는 Observables, Actions 및 Reactions이라는 세 가지 중요한 개념이 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_17.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ch2\u003eObservables\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eObservables는 응용 프로그램의 반응형 상태를 나타냅니다. 단순 스칼라부터 복잡한 객체 트리까지 될 수 있습니다. 응용 프로그램의 상태를 Observables 트리로 정의함으로써, 반응형 상태 트리를 노출하여 UI(또는 응용 프로그램의 다른 관찰자)에서 사용할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e작업\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e작업은 옵저버를 변이시키는 방법입니다. 직접 변이시키는 대신 작업은 변이에 의미를 부여합니다. 예를 들어 value++를 하는 대신 increment() 작업을 실행하면 더 많은 의미가 전달됩니다. 또한, 작업은 모든 알림을 일괄 처리하고 변경 사항은 완료된 후에만 알림을 보내도록 보장합니다. 따라서 옵저버는 작업의 원자적 완료 후에만 알림을 받습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e반응\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e반응은 MobX의 옵저버, 작업 및 반응의 삼합체를 완성합니다. 이들은 반응형 시스템의 옵저버이며 추적 중인 옵저버가 변경될 때마다 알림을 받습니다. 반응에는 아래에 나열된 몇 가지 종류가 있습니다. 이들은 모두 ReactionDisposer를 반환하며, 이는 반응을 폐기하기 위해 호출할 수 있는 함수입니다. 반응의 두드러진 특징 중 하나는 옵저버를 명시적으로 연결하지 않아도 자동으로 모든 옵저버를 추적한다는 것입니다. 반응 내에서 옵저버를 읽는 행위만으로도 추적이 가능합니다!\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eMobX의 스토어는 관련 observable 상태를 하나의 클래스 아래에 수집하는 방법입니다. 이 스토어를 사용하면 주석을 사용하고 코드를 간단하게 유지할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eenum \u003cspan class=\"hljs-title class_\"\u003eStatus\u003c/span\u003e {\n  initial,\n  loading,\n  success,\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 이것은 코드베이스의 나머지 부분에서 사용되는 클래스입니다.\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// ignore: library_private_types_in_public_api\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDataStore\u003c/span\u003e = _DataStore \u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e _$DataStore;\n\n\u003cspan class=\"hljs-comment\"\u003e// 스토어 클래스\u003c/span\u003e\nabstract \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003e_DataStore\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eStore\u003c/span\u003e {\n  @observable\n  \u003cspan class=\"hljs-title class_\"\u003eStatus\u003c/span\u003e state = \u003cspan class=\"hljs-title class_\"\u003eStatus\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003einitial\u003c/span\u003e;\n\n  @action\n  \u003cspan class=\"hljs-title class_\"\u003eFuture\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e\u003e \u003cspan class=\"hljs-title function_\"\u003efetchData\u003c/span\u003e() \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n    state = \u003cspan class=\"hljs-title class_\"\u003eStatus\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eloading\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFuture\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003edelayed\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDuration\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eseconds\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e));\n\n    state = \u003cspan class=\"hljs-title class_\"\u003eStatus\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003esuccess\u003c/span\u003e;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e주석을 사용하여 클래스의 observable 속성을 표시하는 방법에 유의하십시오. 주석은 mobx_codgen 패키지를 통해 사용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e여기서 흥미로운 부분은:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eStore mixin을 포함하는 추상 클래스 _DataStore입니다. 모든 스토어 관련 코드는 이 추상 클래스 내에 배치되어야 합니다. build_runner에서 코드를 조합하기 위해 DataStore 클래스를 생성합니다.\u003c/li\u003e\n\u003cli\u003e생성된 코드는 part 파일인 data_store.g.dart에 포함됩니다. 이를 part 지시문으로 포함해야 build_runner가 출력물을 생성합니다. 생성된 파일에는 _$DataStore mixin이 포함됩니다.\u003c/li\u003e\n\u003cli\u003e값을 observable로 표시하는 @observable 어노테이션.\u003c/li\u003e\n\u003cli\u003eincrement() 메서드를 action으로 표시하기 위한 @action 사용.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e프로젝트 폴더 내에서 다음 명령을 실행하세요. 이는 counter.g.dart에 코드를 생성하며, 이미 part 파일로 포함해 두었습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eflutter pub run build_runner build\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 UI를 살펴보겠습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efinal dataStore = \u003cspan class=\"hljs-title class_\"\u003eDataStore\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// 스토어를 인스턴스화합니다.\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMobXPage\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eStatelessWidget\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e route = \u003cspan class=\"hljs-string\"\u003e'mobx-page'\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMobXPage\u003c/span\u003e({\u003cspan class=\"hljs-title class_\"\u003eKey\u003c/span\u003e key}) : \u003cspan class=\"hljs-variable language_\"\u003esuper\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e: key);\n\n  @override\n  \u003cspan class=\"hljs-title class_\"\u003eWidget\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebuild\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eBuildContext context\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHomeMobX\u003c/span\u003e();\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eObserver 위젯(flutter_mobx의 일부)은 빌더 함수에서 사용된 observables의 세부적인 옵저버를 제공합니다. 이러한 observables이 변경될 때마다 Observer가 다시 빌드되고 렌더링됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-dart\"\u003e\u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eHomeMobX\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eStatelessWidget\u003c/span\u003e \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e HomeMobX({\u003cspan class=\"hljs-keyword\"\u003esuper\u003c/span\u003e.key});\n\n  \u003cspan class=\"hljs-meta\"\u003e@override\u003c/span\u003e\n  Widget build(BuildContext context) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e Scaffold(\n      appBar: AppBar(title: \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e Text(\u003cspan class=\"hljs-string\"\u003e'MobX 페이지'\u003c/span\u003e)),\n      \u003cspan class=\"hljs-comment\"\u003e// 가능한 깊은 곳에 Consumer 위젯을 배치하는 것이 가장 좋습니다.\u003c/span\u003e\n      \u003cspan class=\"hljs-comment\"\u003e// 어딘가의 세부 사항이 변경되어도 대규모 UI의 큰 부분을 다시 빌드하고 싶지 않을 것입니다.\u003c/span\u003e\n      body: Observer(\n        builder: (_) {\n          \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (dataStore.state == Status.initial) {\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e Center(child: Text(\u003cspan class=\"hljs-string\"\u003e'버튼을 눌러주세요'\u003c/span\u003e));\n          }\n          \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (dataStore.state == Status.loading) {\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e Center(child: CircularProgressIndicator());\n          }\n          \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (dataStore.state == Status.success) {\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e Center(child: Text(\u003cspan class=\"hljs-string\"\u003e'성공'\u003c/span\u003e));\n          }\n          \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e Container();\n        },\n      ),\n      floatingActionButton: Column(\n        crossAxisAlignment: CrossAxisAlignment.end,\n        mainAxisAlignment: MainAxisAlignment.end,\n        children: \u0026#x3C;Widget\u003e[\n          FloatingActionButton(\n            child: \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e Icon(Icons.play_arrow),\n            onPressed: () =\u003e dataStore.fecthData(),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그 결과는:\u003c/p\u003e\n\u003ch2\u003e장점\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e반응형 앱 데이터를 UI와 쉽게 연결할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e학습을 쉽게하는 친숙한 구문과 간단한 핵심 API를 사용하여 옵저버 패턴을 구현합니다.\u003c/li\u003e\n\u003cli\u003e크고 복잡한 프로젝트에서 사용할 수 있으며 확장 가능합니다.\u003c/li\u003e\n\u003cli\u003e성능이 좋고 테스트하기 쉽습니다.\u003c/li\u003e\n\u003cli\u003e코드 생성 덕분에 보일러플레이트를 줄일 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e단점\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e코드 생성에 시간이 걸리고 상태 변경 시마다 코드 생성기를 실행해야 할 수도 있습니다.\u003c/li\u003e\n\u003cli\u003e상태가 변경될 때 어떤 이벤트가 그것을 일으킨 것인지 파악하기 어려울 수 있습니다. 복잡한 앱에서 이러한 추적 불가능성은 디버깅과 상태 관리를 어렵게 만들 수 있습니다.\u003c/li\u003e\n\u003cli\u003eMobx 생성기는 단순성을 높이는 데 좋지만 동시에 추상화 수준을 추가합니다. 이는 내부 작업을 실제로 보고 이해하기 어렵게 만듭니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e상태 관리는 가장 중요한 측면 중 하나입니다. 이는 사용자가 UI에 가한 모든 변경 사항을 추적하는 방법입니다.\u003c/li\u003e\n\u003cli\u003eFlutter의 상태 관리 라이브러리들은 상태 변경의 유형과 상관없이 애플리케이션을 개발하고 관리하기 쉽게 만들어 줍니다.\u003c/li\u003e\n\u003cli\u003e올바른 Flutter 상태 관리자를 선택하는 것은 사용하는 것만큼 중요합니다. 상태 관리자의 선택지는 다양하지만, 어떤 것을 사용할지 선택하는 것은 우리에게, 우리의 취향에, 편안한 느낌에, 또한 프로젝트 유형, 요구 사항에 달려 있습니다. 작은 프로젝트인 경우 한 가지 접근 방식을 사용할 수 있고, 확장 가능한 프로젝트를 만들고 싶다면 다른 접근 방식을 사용할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e마침내 기대하던 것, 여기에서 전체 예제를 찾을 수 있습니다:\u003c/p\u003e\n\u003cp\u003e마음에 든다면 커피 한 잔 사주세요!\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX_20.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-21-FlutterStateManagementProviderBLoCGetXRiverpodGetItandMobX"},"buildId":"AAcWCMtAYBsqiURBkbPEc","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>