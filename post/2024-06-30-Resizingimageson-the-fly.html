<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>이미지를 실시간으로 크기 조절하는 방법 | uidev-css</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://uidev-css.github.io///post/2024-06-30-Resizingimageson-the-fly" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="이미지를 실시간으로 크기 조절하는 방법 | uidev-css" data-gatsby-head="true"/><meta property="og:title" content="이미지를 실시간으로 크기 조절하는 방법 | uidev-css" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-30-Resizingimageson-the-fly_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://uidev-css.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://uidev-css.github.io///post/2024-06-30-Resizingimageson-the-fly" data-gatsby-head="true"/><meta name="twitter:title" content="이미지를 실시간으로 크기 조절하는 방법 | uidev-css" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-30-Resizingimageson-the-fly_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | uidev-css" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-30 23:03" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b4eed7811784bdd3.js" defer=""></script><script src="/_next/static/ckvP8zvWyPnScUqpsTElP/_buildManifest.js" defer=""></script><script src="/_next/static/ckvP8zvWyPnScUqpsTElP/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UIDEV CSS</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">이미지를 실시간으로 크기 조절하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="이미지를 실시간으로 크기 조절하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UIDEV CSS</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 30, 2024</span><span class="posts_reading_time__f7YPP">6<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-30-Resizingimageson-the-fly&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-06-30-Resizingimageson-the-fly_0.png" alt="Resizing images on the fly"></p>
<p>웹 아키텍트로서 자산 관리는 많은 문제 중 하나입니다. 그리고 자산 중에서도 가장 중요한 문제는 이미지입니다. 하나의 단순한 접근 방식은 이미지를 설정하고 브라우저가 CSS를 통해 이미지를 크기 조정하도록 하는 것입니다:</p>
<pre><code class="hljs language-css"><span class="hljs-selector-tag">img</span> {
    <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;
    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;
    <span class="hljs-attribute">object-fit</span>: contain;
}
</code></pre>
<p>하지만 이는 원본 이미지를 다운로드한다는 뜻입니다. 이로써 원본 이미지의 크기와 최적화되지 않은 브라우저 기반 크기 조정 두 가지 문제가 발생합니다.</p>
<div class="content-ad"></div>
<p>이 포스트에서는 두 가지 대안을 다룹니다: 전통적인 방법과 새로운 솔루션.</p>
<h1>미리 크기 조정하기</h1>
<p>단일 이미지 원본에 대한 전통적인 솔루션은 미리 크기를 조정하는 것이었습니다. 출시하기 전에 디자이너들은 다양한 해상도의 여러 이미지 버전을 제공하는 데 시간을 할애했습니다. 이 블로그에서는 이 기술을 사용하고 있습니다. 포스트의 주 이미지를 다양한 맥락에서 백그라운드 이미지로 표시하기 위해 세 가지 해상도를 제공합니다:</p>
<ul>
<li>페이지의 포스트용 큰 크기</li>
<li>홈페이지의 포스트용 중간 크기</li>
<li>포스트 페이지에서 관련 포스트용 작은 크기</li>
</ul>
<div class="content-ad"></div>
<p>저는 더 높은 용량 감소를 위해 JPEG 메타데이터도 제거합니다.</p>
<p>하지만 전통적인 방식은 HTML picture 태그를 활용하는 것입니다:</p>
<p>그리고 다음과 같이 사용할 수 있습니다:</p>
<pre><code class="hljs language-js">&#x3C;picture>
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">source</span> <span class="hljs-attr">media</span>=<span class="hljs-string">"(max-width: 199px)"</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">"ai-generated-200.jpg"</span> /></span></span>
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">source</span> <span class="hljs-attr">media</span>=<span class="hljs-string">"(max-width: 399px)"</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">"ai-generated-400.jpg"</span> /></span></span>
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">source</span> <span class="hljs-attr">media</span>=<span class="hljs-string">"(max-width: 599px)"</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">"ai-generated-600.jpg"</span> /></span></span>
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">source</span> <span class="hljs-attr">media</span>=<span class="hljs-string">"(max-width: 799px)"</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">"ai-generated-800.jpg"</span> /></span></span>
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">source</span> <span class="hljs-attr">media</span>=<span class="hljs-string">"(max-width: 999px)"</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">"ai-generated-1000.jpg"</span> /></span></span>
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"ai-generated.jpg"</span> /></span></span>
&#x3C;/picture>
</code></pre>
<div class="content-ad"></div>
<p>이 방식은 오랫동안 잘 작동했지만 두 가지 문제가 있습니다. 먼저, 각 이미지에 대해 여러 해상도를 제공하는 작업은 시간이 많이 소요됩니다. 이를 자동화하여 AI를 사용하면 좋은 결과를 얻을 수 있습니다.</p>
<p>그러나 필요한 저장 용량은 추가로 생성된 해상도의 수에 따라 원본 이미지의 두배 또는 세배가 될 수 있습니다. 자산이 풍부한 환경에서 예를 들어 전자 상거래와 같은 경우 비용이 크게 증가할 수 있습니다.</p>
<h1>실시간 크기 조정</h1>
<p>최근에 imgproxy라는 이미지 크기를 실시간으로 조정하는 구성 요소를 우연히 발견했습니다:</p>
<div class="content-ad"></div>
<p>imgproxy는 다음을 정의하는 인코딩된 URL을 보낼 수 있는 엔드포인트를 제공합니다:</p>
<ul>
<li>변경할 이미지와 위치(로컬, HTTP URL, S3 버킷 등)</li>
<li>다양한 크기 조정 매개변수, 예를 들어, 차원, 맞출지 채울지 여부 등</li>
<li>형식. imgproxy는 JPEG 및 PNG과 같은 표준 형식을 지원하지만 WebP 및 AVIF와 같은 더 현대적인 형식도 지원합니다. 또한 'Accept' 헤더에 따라 최적의 형식을 선택할 수 있습니다.</li>
<li>워터마킹, 필터링, 회전 등 많은(정말 많은!) 다른 옵션들</li>
</ul>
<p>imgproxy는 오픈 소스 무료 버전과 유료 버전을 제공합니다. 이 포스트에 포함된 모든 내용은 전자의 일부입니다.</p>
<p>한 가지 해결책은 웹 개발자가 HTML에 각 imgproxy URL을 직접 코딩하는 것입니다.</p>
<div class="content-ad"></div>
<picture>
    <source media="(max-width: 199px)" srcset="http://imgproxy:8080//rs:fill/w:200/plain/http://server:3000/ai-generated.jpg@webp">
    <source media="(max-width: 399px)" srcset="http://imgproxy:8080//rs:fill/w:400/plain/http://server:3000/ai-generated.jpg@webp">
    <source media="(max-width: 599px)" srcset="http://imgproxy:8080//rs:fill/w:600/plain/http://server:3000/ai-generated.jpg@webp">
    <source media="(max-width: 799px)" srcset="http://imgproxy:8080//rs:fill/w:800/plain/http://server:3000/ai-generated.jpg@webp">
    <source media="(max-width: 999px)" srcset="http://imgproxy:8080//rs:fill/w:1000/plain/http://server:3000/ai-generated.jpg@webp">
    <img src="ai-generated.jpg">
</picture>
<p>웹 페이지에 대한 토폴로지 관련 세부 정보가 노출됩니다. 이는 유지 관리하기 어려운 해결책입니다. 리버스 프록시나 API 게이트웨이를 사용하여 문제를 해결할 수 있습니다. 명백한 이유로 Apache APISIX를 사용하겠습니다.</p>
<p>이 방법을 통해 위의 HTML이 훨씬 간단해집니다:</p>
<picture>
    <source media="(max-width: 199px)" srcset="/resize/200/ai-generated.jpg">
    <source media="(max-width: 399px)" srcset="/resize/400/ai-generated.jpg">
    <source media="(max-width: 599px)" srcset="/resize/600/ai-generated.jpg">
    <source media="(max-width: 799px)" srcset="/resize/800/ai-generated.jpg">
    <source media="(max-width: 999px)" srcset="/resize/1000/ai-generated.jpg">
    <img src="ai-generated.jpg">
</picture>
<div class="content-ad"></div>
<p>Apache APISIX은 /resize로 시작하는 요청을 가로채어 URL을 imgproxy로 재작성하여 imgproxy에 재작성된 URL을 전달합니다. 전체 흐름은 다음과 같습니다:</p>
<p><img src="/assets/img/2024-06-30-Resizingimageson-the-fly_1.png" alt="image"></p>
<p>해당 Apache APISIX 구성은 다음과 같습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-attr">routes</span>:
  - <span class="hljs-attr">uri</span>: <span class="hljs-regexp">/resize/</span>*
    <span class="hljs-attr">plugins</span>:
      proxy-<span class="hljs-attr">rewrite</span>:
        <span class="hljs-attr">regex_uri</span>:
          - <span class="hljs-regexp">/resize/</span>(.*)/(.*)
          - <span class="hljs-regexp">/rs:fill/</span><span class="hljs-attr">w</span>:$1/plain/<span class="hljs-attr">http</span>:<span class="hljs-comment">//server:3000/$2@webp</span>
    <span class="hljs-attr">upstream</span>:
      <span class="hljs-attr">nodes</span>:
        <span class="hljs-string">"imgproxy:8080"</span>: <span class="hljs-number">1</span>
</code></pre>
<div class="content-ad"></div>
<ul>
<li><strong>/resize</strong>로 시작하는 요청 일치시키기</li>
<li>URL 다시 작성</li>
<li>정규 표현식에서 너비와 이미지 캡처</li>
<li>이미지 프록시를 위한 URL 형식화. <a href="http://server:3000%EC%9D%80" rel="nofollow" target="_blank">http://server:3000은</a> 원본 이미지를 호스팅하는 서버이며, @webp은 브라우저가 지원하는 경우 WebP 형식을 선호함을 나타냄</li>
</ul>
<p>위와 같이, Apache APISIX에게서 <strong>/resize/200/ai-generated.jpg</strong>를 받으면 imgproxy에서 **/rs:fill/w:200/plain/<a href="http://server:3000/ai-generated.jpg@webp**%EB%A1%9C" rel="nofollow" target="_blank">http://server:3000/ai-generated.jpg@webp**로</a> 다시 작성됩니다.</p>
<h1>테스트</h1>
<p>Docker Compose를 사용하여 작은 테스트 샘플을 설정할 수 있습니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-yaml"><span class="hljs-attr">services:</span>
  <span class="hljs-attr">apisix:</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">apache/apisix:3.5.0-debian</span>
    <span class="hljs-attr">volumes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">./apisix/config.yml:/usr/local/apisix/conf/config.yaml:ro</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">./apisix/apisix.yml:/usr/local/apisix/conf/apisix.yaml:ro</span>
    <span class="hljs-attr">ports:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">"9080:9080"</span>
  <span class="hljs-attr">imgproxy:</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">darthsim/imgproxy:v3.19</span>
  <span class="hljs-attr">server:</span>                                                         <span class="hljs-comment">#1</span>
    <span class="hljs-attr">build:</span> <span class="hljs-string">content</span>
</code></pre>
<ul>
<li>HTML 및 주 이미지를 호스팅하는 간단한 웹 서버</li>
</ul>
<p>이제 위 설정을 브라우저의 개발자 도구를 사용하여 테스트할 수 있습니다. 작은 화면 장치인 iPhone SE를 흉내 내는 것입니다. 결과는 다음과 같습니다:</p>
<img src="/assets/img/2024-06-30-Resizingimageson-the-fly_2.png">
<div class="content-ad"></div>
<ul>
<li>화면 해상도 때문에 요청된 이미지는 원본 이미지가 아닌 400px 폭 이미지입니다. 요청 URL에서 확인할 수 있어요.</li>
<li>반환된 이미지는 WebP 형식이며, 용량은 14.4kb입니다.</li>
<li>원본 JPEG 이미지는 154kb로, 10배나 더 많은 용량을 차지합니다. 네트워크 대역폭을 아주 많이 절약하는 것이죠!</li>
</ul>
<h1>토론</h1>
<p>저장 비용을 10배 줄이는 것은 당연히 큰 이점입니다. 하지만 모든 것이 완벽한 것은 아닙니다. 이미지 크기를 조정하는 것은 계산에 많은 비용이 드는 작업이에요. 각 요청마다 CPU 시간이 소요됩니다. 또한 imgproxy가 얼마나 효율적이든 이미지 생성에는 시간이 걸립니다. 우리는 저장 비용을 CPU 비용으로 교환하고, 결과적으로 성능에 약간의 저하가 발생합니다.</p>
<p>이를 해결하려면 앞 단에 캐싱 레이어가 필요합니다. 커스텀 캐싱이나 더 가능한 CDN 등을 사용할 수 있어요. 자산을 다시 저장할 것이라는 이의가 있을 수 있습니다. 따라서 저장 비용이 다시 증가할 거라는 거죠. 그러나 캐시는 사용된 이미지에만 작동하며, 이전 솔루션에서는 모든 이미지를 저장하기 위해 비용을 지불했습니다. 이외에도, 이미지가 필요한 경우에 캐시를 미리 로딩하는 등 캐싱에 대한 이미 알려진 레시피를 적용할 수도 있어요. 예를 들어, 이벤트 전에 필요한 이미지 그룹을 미리 로딩하는 것 등이죠.</p>
<div class="content-ad"></div>
<h1>결론</h1>
<p>이 게시물에서는 Apache APISIX와 imgproxy를 사용하여 여러 해상도의 이미지 저장 비용을 줄이는 방법을 설명했습니다. 캐싱을 추가하면 전체 아키텍처에 더 많은 구성 요소가 추가되지만 저장 비용이 줄어듭니다.</p>
<p>이 게시물은 Andreas Lehr의 StackConf 발표에서 영감을 받았습니다.</p>
<p>이 게시물의 전체 소스 코드는 GitHub에서 찾을 수 있습니다.</p>
<div class="content-ad"></div>
<p>더 알아보기:</p>
<ul>
<li>imgproxy 문서</li>
<li>imgproxy 인터랙티브 데모</li>
</ul>
<p>2023년 10월 1일에 A Java Geek에서 처음 발행되었습니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"이미지를 실시간으로 크기 조절하는 방법","description":"","date":"2024-06-30 23:03","slug":"2024-06-30-Resizingimageson-the-fly","content":"\n\n\n![Resizing images on the fly](/assets/img/2024-06-30-Resizingimageson-the-fly_0.png)\n\n웹 아키텍트로서 자산 관리는 많은 문제 중 하나입니다. 그리고 자산 중에서도 가장 중요한 문제는 이미지입니다. 하나의 단순한 접근 방식은 이미지를 설정하고 브라우저가 CSS를 통해 이미지를 크기 조정하도록 하는 것입니다:\n\n```css\nimg {\n    height: 100%;\n    width: 100%;\n    object-fit: contain;\n}\n```\n\n하지만 이는 원본 이미지를 다운로드한다는 뜻입니다. 이로써 원본 이미지의 크기와 최적화되지 않은 브라우저 기반 크기 조정 두 가지 문제가 발생합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 포스트에서는 두 가지 대안을 다룹니다: 전통적인 방법과 새로운 솔루션.\n\n# 미리 크기 조정하기\n\n단일 이미지 원본에 대한 전통적인 솔루션은 미리 크기를 조정하는 것이었습니다. 출시하기 전에 디자이너들은 다양한 해상도의 여러 이미지 버전을 제공하는 데 시간을 할애했습니다. 이 블로그에서는 이 기술을 사용하고 있습니다. 포스트의 주 이미지를 다양한 맥락에서 백그라운드 이미지로 표시하기 위해 세 가지 해상도를 제공합니다:\n\n- 페이지의 포스트용 큰 크기\n- 홈페이지의 포스트용 중간 크기\n- 포스트 페이지에서 관련 포스트용 작은 크기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저는 더 높은 용량 감소를 위해 JPEG 메타데이터도 제거합니다.\n\n하지만 전통적인 방식은 HTML picture 태그를 활용하는 것입니다:\n\n그리고 다음과 같이 사용할 수 있습니다:\n\n```js\n\u003cpicture\u003e\n    \u003csource media=\"(max-width: 199px)\" srcset=\"ai-generated-200.jpg\" /\u003e\n    \u003csource media=\"(max-width: 399px)\" srcset=\"ai-generated-400.jpg\" /\u003e\n    \u003csource media=\"(max-width: 599px)\" srcset=\"ai-generated-600.jpg\" /\u003e\n    \u003csource media=\"(max-width: 799px)\" srcset=\"ai-generated-800.jpg\" /\u003e\n    \u003csource media=\"(max-width: 999px)\" srcset=\"ai-generated-1000.jpg\" /\u003e\n    \u003cimg src=\"ai-generated.jpg\" /\u003e\n\u003c/picture\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 방식은 오랫동안 잘 작동했지만 두 가지 문제가 있습니다. 먼저, 각 이미지에 대해 여러 해상도를 제공하는 작업은 시간이 많이 소요됩니다. 이를 자동화하여 AI를 사용하면 좋은 결과를 얻을 수 있습니다.\n\n그러나 필요한 저장 용량은 추가로 생성된 해상도의 수에 따라 원본 이미지의 두배 또는 세배가 될 수 있습니다. 자산이 풍부한 환경에서 예를 들어 전자 상거래와 같은 경우 비용이 크게 증가할 수 있습니다.\n\n# 실시간 크기 조정\n\n최근에 imgproxy라는 이미지 크기를 실시간으로 조정하는 구성 요소를 우연히 발견했습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nimgproxy는 다음을 정의하는 인코딩된 URL을 보낼 수 있는 엔드포인트를 제공합니다:\n- 변경할 이미지와 위치(로컬, HTTP URL, S3 버킷 등)\n- 다양한 크기 조정 매개변수, 예를 들어, 차원, 맞출지 채울지 여부 등\n- 형식. imgproxy는 JPEG 및 PNG과 같은 표준 형식을 지원하지만 WebP 및 AVIF와 같은 더 현대적인 형식도 지원합니다. 또한 'Accept' 헤더에 따라 최적의 형식을 선택할 수 있습니다.\n- 워터마킹, 필터링, 회전 등 많은(정말 많은!) 다른 옵션들\n\nimgproxy는 오픈 소스 무료 버전과 유료 버전을 제공합니다. 이 포스트에 포함된 모든 내용은 전자의 일부입니다.\n\n한 가지 해결책은 웹 개발자가 HTML에 각 imgproxy URL을 직접 코딩하는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\u003cpicture\u003e\n    \u003csource media=\"(max-width: 199px)\" srcset=\"http://imgproxy:8080//rs:fill/w:200/plain/http://server:3000/ai-generated.jpg@webp\" /\u003e\n    \u003csource media=\"(max-width: 399px)\" srcset=\"http://imgproxy:8080//rs:fill/w:400/plain/http://server:3000/ai-generated.jpg@webp\" /\u003e\n    \u003csource media=\"(max-width: 599px)\" srcset=\"http://imgproxy:8080//rs:fill/w:600/plain/http://server:3000/ai-generated.jpg@webp\" /\u003e\n    \u003csource media=\"(max-width: 799px)\" srcset=\"http://imgproxy:8080//rs:fill/w:800/plain/http://server:3000/ai-generated.jpg@webp\" /\u003e\n    \u003csource media=\"(max-width: 999px)\" srcset=\"http://imgproxy:8080//rs:fill/w:1000/plain/http://server:3000/ai-generated.jpg@webp\" /\u003e\n    \u003cimg src=\"ai-generated.jpg\" /\u003e\n\u003c/picture\u003e\n\n\n웹 페이지에 대한 토폴로지 관련 세부 정보가 노출됩니다. 이는 유지 관리하기 어려운 해결책입니다. 리버스 프록시나 API 게이트웨이를 사용하여 문제를 해결할 수 있습니다. 명백한 이유로 Apache APISIX를 사용하겠습니다.\n\n이 방법을 통해 위의 HTML이 훨씬 간단해집니다:\n\n\n\u003cpicture\u003e\n    \u003csource media=\"(max-width: 199px)\" srcset=\"/resize/200/ai-generated.jpg\" /\u003e\n    \u003csource media=\"(max-width: 399px)\" srcset=\"/resize/400/ai-generated.jpg\" /\u003e\n    \u003csource media=\"(max-width: 599px)\" srcset=\"/resize/600/ai-generated.jpg\" /\u003e\n    \u003csource media=\"(max-width: 799px)\" srcset=\"/resize/800/ai-generated.jpg\" /\u003e\n    \u003csource media=\"(max-width: 999px)\" srcset=\"/resize/1000/ai-generated.jpg\" /\u003e\n    \u003cimg src=\"ai-generated.jpg\" /\u003e\n\u003c/picture\u003e\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nApache APISIX은 /resize로 시작하는 요청을 가로채어 URL을 imgproxy로 재작성하여 imgproxy에 재작성된 URL을 전달합니다. 전체 흐름은 다음과 같습니다:\n\n![image](/assets/img/2024-06-30-Resizingimageson-the-fly_1.png)\n\n해당 Apache APISIX 구성은 다음과 같습니다:\n\n```js\nroutes:\n  - uri: /resize/*\n    plugins:\n      proxy-rewrite:\n        regex_uri:\n          - /resize/(.*)/(.*)\n          - /rs:fill/w:$1/plain/http://server:3000/$2@webp\n    upstream:\n      nodes:\n        \"imgproxy:8080\": 1\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- **/resize**로 시작하는 요청 일치시키기\n- URL 다시 작성\n- 정규 표현식에서 너비와 이미지 캡처\n- 이미지 프록시를 위한 URL 형식화. http://server:3000은 원본 이미지를 호스팅하는 서버이며, @webp은 브라우저가 지원하는 경우 WebP 형식을 선호함을 나타냄\n\n위와 같이, Apache APISIX에게서 **/resize/200/ai-generated.jpg**를 받으면 imgproxy에서 **/rs:fill/w:200/plain/http://server:3000/ai-generated.jpg@webp**로 다시 작성됩니다.\n\n# 테스트\n\nDocker Compose를 사용하여 작은 테스트 샘플을 설정할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```yaml\nservices:\n  apisix:\n    image: apache/apisix:3.5.0-debian\n    volumes:\n      - ./apisix/config.yml:/usr/local/apisix/conf/config.yaml:ro\n      - ./apisix/apisix.yml:/usr/local/apisix/conf/apisix.yaml:ro\n    ports:\n      - \"9080:9080\"\n  imgproxy:\n    image: darthsim/imgproxy:v3.19\n  server:                                                         #1\n    build: content\n```\n\n- HTML 및 주 이미지를 호스팅하는 간단한 웹 서버\n\n이제 위 설정을 브라우저의 개발자 도구를 사용하여 테스트할 수 있습니다. 작은 화면 장치인 iPhone SE를 흉내 내는 것입니다. 결과는 다음과 같습니다:\n\n\u003cimg src=\"/assets/img/2024-06-30-Resizingimageson-the-fly_2.png\" /\u003e\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 화면 해상도 때문에 요청된 이미지는 원본 이미지가 아닌 400px 폭 이미지입니다. 요청 URL에서 확인할 수 있어요.\n- 반환된 이미지는 WebP 형식이며, 용량은 14.4kb입니다.\n- 원본 JPEG 이미지는 154kb로, 10배나 더 많은 용량을 차지합니다. 네트워크 대역폭을 아주 많이 절약하는 것이죠!\n\n# 토론\n\n저장 비용을 10배 줄이는 것은 당연히 큰 이점입니다. 하지만 모든 것이 완벽한 것은 아닙니다. 이미지 크기를 조정하는 것은 계산에 많은 비용이 드는 작업이에요. 각 요청마다 CPU 시간이 소요됩니다. 또한 imgproxy가 얼마나 효율적이든 이미지 생성에는 시간이 걸립니다. 우리는 저장 비용을 CPU 비용으로 교환하고, 결과적으로 성능에 약간의 저하가 발생합니다.\n\n이를 해결하려면 앞 단에 캐싱 레이어가 필요합니다. 커스텀 캐싱이나 더 가능한 CDN 등을 사용할 수 있어요. 자산을 다시 저장할 것이라는 이의가 있을 수 있습니다. 따라서 저장 비용이 다시 증가할 거라는 거죠. 그러나 캐시는 사용된 이미지에만 작동하며, 이전 솔루션에서는 모든 이미지를 저장하기 위해 비용을 지불했습니다. 이외에도, 이미지가 필요한 경우에 캐시를 미리 로딩하는 등 캐싱에 대한 이미 알려진 레시피를 적용할 수도 있어요. 예를 들어, 이벤트 전에 필요한 이미지 그룹을 미리 로딩하는 것 등이죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n이 게시물에서는 Apache APISIX와 imgproxy를 사용하여 여러 해상도의 이미지 저장 비용을 줄이는 방법을 설명했습니다. 캐싱을 추가하면 전체 아키텍처에 더 많은 구성 요소가 추가되지만 저장 비용이 줄어듭니다.\n\n이 게시물은 Andreas Lehr의 StackConf 발표에서 영감을 받았습니다.\n\n이 게시물의 전체 소스 코드는 GitHub에서 찾을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더 알아보기:\n\n- imgproxy 문서\n- imgproxy 인터랙티브 데모\n\n2023년 10월 1일에 A Java Geek에서 처음 발행되었습니다.","ogImage":{"url":"/assets/img/2024-06-30-Resizingimageson-the-fly_0.png"},"coverImage":"/assets/img/2024-06-30-Resizingimageson-the-fly_0.png","tag":["Tech"],"readingTime":6},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-30-Resizingimageson-the-fly_0.png\" alt=\"Resizing images on the fly\"\u003e\u003c/p\u003e\n\u003cp\u003e웹 아키텍트로서 자산 관리는 많은 문제 중 하나입니다. 그리고 자산 중에서도 가장 중요한 문제는 이미지입니다. 하나의 단순한 접근 방식은 이미지를 설정하고 브라우저가 CSS를 통해 이미지를 크기 조정하도록 하는 것입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-css\"\u003e\u003cspan class=\"hljs-selector-tag\"\u003eimg\u003c/span\u003e {\n    \u003cspan class=\"hljs-attribute\"\u003eheight\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e100%\u003c/span\u003e;\n    \u003cspan class=\"hljs-attribute\"\u003ewidth\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e100%\u003c/span\u003e;\n    \u003cspan class=\"hljs-attribute\"\u003eobject-fit\u003c/span\u003e: contain;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e하지만 이는 원본 이미지를 다운로드한다는 뜻입니다. 이로써 원본 이미지의 크기와 최적화되지 않은 브라우저 기반 크기 조정 두 가지 문제가 발생합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 포스트에서는 두 가지 대안을 다룹니다: 전통적인 방법과 새로운 솔루션.\u003c/p\u003e\n\u003ch1\u003e미리 크기 조정하기\u003c/h1\u003e\n\u003cp\u003e단일 이미지 원본에 대한 전통적인 솔루션은 미리 크기를 조정하는 것이었습니다. 출시하기 전에 디자이너들은 다양한 해상도의 여러 이미지 버전을 제공하는 데 시간을 할애했습니다. 이 블로그에서는 이 기술을 사용하고 있습니다. 포스트의 주 이미지를 다양한 맥락에서 백그라운드 이미지로 표시하기 위해 세 가지 해상도를 제공합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e페이지의 포스트용 큰 크기\u003c/li\u003e\n\u003cli\u003e홈페이지의 포스트용 중간 크기\u003c/li\u003e\n\u003cli\u003e포스트 페이지에서 관련 포스트용 작은 크기\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e저는 더 높은 용량 감소를 위해 JPEG 메타데이터도 제거합니다.\u003c/p\u003e\n\u003cp\u003e하지만 전통적인 방식은 HTML picture 태그를 활용하는 것입니다:\u003c/p\u003e\n\u003cp\u003e그리고 다음과 같이 사용할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;picture\u003e\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003esource\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003emedia\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"(max-width: 199px)\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrcset\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"ai-generated-200.jpg\"\u003c/span\u003e /\u003e\u003c/span\u003e\u003c/span\u003e\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003esource\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003emedia\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"(max-width: 399px)\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrcset\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"ai-generated-400.jpg\"\u003c/span\u003e /\u003e\u003c/span\u003e\u003c/span\u003e\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003esource\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003emedia\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"(max-width: 599px)\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrcset\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"ai-generated-600.jpg\"\u003c/span\u003e /\u003e\u003c/span\u003e\u003c/span\u003e\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003esource\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003emedia\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"(max-width: 799px)\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrcset\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"ai-generated-800.jpg\"\u003c/span\u003e /\u003e\u003c/span\u003e\u003c/span\u003e\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003esource\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003emedia\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"(max-width: 999px)\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrcset\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"ai-generated-1000.jpg\"\u003c/span\u003e /\u003e\u003c/span\u003e\u003c/span\u003e\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eimg\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"ai-generated.jpg\"\u003c/span\u003e /\u003e\u003c/span\u003e\u003c/span\u003e\n\u0026#x3C;/picture\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 방식은 오랫동안 잘 작동했지만 두 가지 문제가 있습니다. 먼저, 각 이미지에 대해 여러 해상도를 제공하는 작업은 시간이 많이 소요됩니다. 이를 자동화하여 AI를 사용하면 좋은 결과를 얻을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e그러나 필요한 저장 용량은 추가로 생성된 해상도의 수에 따라 원본 이미지의 두배 또는 세배가 될 수 있습니다. 자산이 풍부한 환경에서 예를 들어 전자 상거래와 같은 경우 비용이 크게 증가할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e실시간 크기 조정\u003c/h1\u003e\n\u003cp\u003e최근에 imgproxy라는 이미지 크기를 실시간으로 조정하는 구성 요소를 우연히 발견했습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eimgproxy는 다음을 정의하는 인코딩된 URL을 보낼 수 있는 엔드포인트를 제공합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e변경할 이미지와 위치(로컬, HTTP URL, S3 버킷 등)\u003c/li\u003e\n\u003cli\u003e다양한 크기 조정 매개변수, 예를 들어, 차원, 맞출지 채울지 여부 등\u003c/li\u003e\n\u003cli\u003e형식. imgproxy는 JPEG 및 PNG과 같은 표준 형식을 지원하지만 WebP 및 AVIF와 같은 더 현대적인 형식도 지원합니다. 또한 'Accept' 헤더에 따라 최적의 형식을 선택할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e워터마킹, 필터링, 회전 등 많은(정말 많은!) 다른 옵션들\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eimgproxy는 오픈 소스 무료 버전과 유료 버전을 제공합니다. 이 포스트에 포함된 모든 내용은 전자의 일부입니다.\u003c/p\u003e\n\u003cp\u003e한 가지 해결책은 웹 개발자가 HTML에 각 imgproxy URL을 직접 코딩하는 것입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpicture\u003e\n    \u003csource media=\"(max-width: 199px)\" srcset=\"http://imgproxy:8080//rs:fill/w:200/plain/http://server:3000/ai-generated.jpg@webp\"\u003e\n    \u003csource media=\"(max-width: 399px)\" srcset=\"http://imgproxy:8080//rs:fill/w:400/plain/http://server:3000/ai-generated.jpg@webp\"\u003e\n    \u003csource media=\"(max-width: 599px)\" srcset=\"http://imgproxy:8080//rs:fill/w:600/plain/http://server:3000/ai-generated.jpg@webp\"\u003e\n    \u003csource media=\"(max-width: 799px)\" srcset=\"http://imgproxy:8080//rs:fill/w:800/plain/http://server:3000/ai-generated.jpg@webp\"\u003e\n    \u003csource media=\"(max-width: 999px)\" srcset=\"http://imgproxy:8080//rs:fill/w:1000/plain/http://server:3000/ai-generated.jpg@webp\"\u003e\n    \u003cimg src=\"ai-generated.jpg\"\u003e\n\u003c/picture\u003e\n\u003cp\u003e웹 페이지에 대한 토폴로지 관련 세부 정보가 노출됩니다. 이는 유지 관리하기 어려운 해결책입니다. 리버스 프록시나 API 게이트웨이를 사용하여 문제를 해결할 수 있습니다. 명백한 이유로 Apache APISIX를 사용하겠습니다.\u003c/p\u003e\n\u003cp\u003e이 방법을 통해 위의 HTML이 훨씬 간단해집니다:\u003c/p\u003e\n\u003cpicture\u003e\n    \u003csource media=\"(max-width: 199px)\" srcset=\"/resize/200/ai-generated.jpg\"\u003e\n    \u003csource media=\"(max-width: 399px)\" srcset=\"/resize/400/ai-generated.jpg\"\u003e\n    \u003csource media=\"(max-width: 599px)\" srcset=\"/resize/600/ai-generated.jpg\"\u003e\n    \u003csource media=\"(max-width: 799px)\" srcset=\"/resize/800/ai-generated.jpg\"\u003e\n    \u003csource media=\"(max-width: 999px)\" srcset=\"/resize/1000/ai-generated.jpg\"\u003e\n    \u003cimg src=\"ai-generated.jpg\"\u003e\n\u003c/picture\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eApache APISIX은 /resize로 시작하는 요청을 가로채어 URL을 imgproxy로 재작성하여 imgproxy에 재작성된 URL을 전달합니다. 전체 흐름은 다음과 같습니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-30-Resizingimageson-the-fly_1.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e해당 Apache APISIX 구성은 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-attr\"\u003eroutes\u003c/span\u003e:\n  - \u003cspan class=\"hljs-attr\"\u003euri\u003c/span\u003e: \u003cspan class=\"hljs-regexp\"\u003e/resize/\u003c/span\u003e*\n    \u003cspan class=\"hljs-attr\"\u003eplugins\u003c/span\u003e:\n      proxy-\u003cspan class=\"hljs-attr\"\u003erewrite\u003c/span\u003e:\n        \u003cspan class=\"hljs-attr\"\u003eregex_uri\u003c/span\u003e:\n          - \u003cspan class=\"hljs-regexp\"\u003e/resize/\u003c/span\u003e(.*)/(.*)\n          - \u003cspan class=\"hljs-regexp\"\u003e/rs:fill/\u003c/span\u003e\u003cspan class=\"hljs-attr\"\u003ew\u003c/span\u003e:$1/plain/\u003cspan class=\"hljs-attr\"\u003ehttp\u003c/span\u003e:\u003cspan class=\"hljs-comment\"\u003e//server:3000/$2@webp\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eupstream\u003c/span\u003e:\n      \u003cspan class=\"hljs-attr\"\u003enodes\u003c/span\u003e:\n        \u003cspan class=\"hljs-string\"\u003e\"imgproxy:8080\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e/resize\u003c/strong\u003e로 시작하는 요청 일치시키기\u003c/li\u003e\n\u003cli\u003eURL 다시 작성\u003c/li\u003e\n\u003cli\u003e정규 표현식에서 너비와 이미지 캡처\u003c/li\u003e\n\u003cli\u003e이미지 프록시를 위한 URL 형식화. \u003ca href=\"http://server:3000%EC%9D%80\" rel=\"nofollow\" target=\"_blank\"\u003ehttp://server:3000은\u003c/a\u003e 원본 이미지를 호스팅하는 서버이며, @webp은 브라우저가 지원하는 경우 WebP 형식을 선호함을 나타냄\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e위와 같이, Apache APISIX에게서 \u003cstrong\u003e/resize/200/ai-generated.jpg\u003c/strong\u003e를 받으면 imgproxy에서 **/rs:fill/w:200/plain/\u003ca href=\"http://server:3000/ai-generated.jpg@webp**%EB%A1%9C\" rel=\"nofollow\" target=\"_blank\"\u003ehttp://server:3000/ai-generated.jpg@webp**로\u003c/a\u003e 다시 작성됩니다.\u003c/p\u003e\n\u003ch1\u003e테스트\u003c/h1\u003e\n\u003cp\u003eDocker Compose를 사용하여 작은 테스트 샘플을 설정할 수 있습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-yaml\"\u003e\u003cspan class=\"hljs-attr\"\u003eservices:\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003eapisix:\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eimage:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eapache/apisix:3.5.0-debian\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003evolumes:\u003c/span\u003e\n      \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e./apisix/config.yml:/usr/local/apisix/conf/config.yaml:ro\u003c/span\u003e\n      \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e./apisix/apisix.yml:/usr/local/apisix/conf/apisix.yaml:ro\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eports:\u003c/span\u003e\n      \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"9080:9080\"\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003eimgproxy:\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eimage:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003edarthsim/imgproxy:v3.19\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003eserver:\u003c/span\u003e                                                         \u003cspan class=\"hljs-comment\"\u003e#1\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003ebuild:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003econtent\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eHTML 및 주 이미지를 호스팅하는 간단한 웹 서버\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이제 위 설정을 브라우저의 개발자 도구를 사용하여 테스트할 수 있습니다. 작은 화면 장치인 iPhone SE를 흉내 내는 것입니다. 결과는 다음과 같습니다:\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-06-30-Resizingimageson-the-fly_2.png\"\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e화면 해상도 때문에 요청된 이미지는 원본 이미지가 아닌 400px 폭 이미지입니다. 요청 URL에서 확인할 수 있어요.\u003c/li\u003e\n\u003cli\u003e반환된 이미지는 WebP 형식이며, 용량은 14.4kb입니다.\u003c/li\u003e\n\u003cli\u003e원본 JPEG 이미지는 154kb로, 10배나 더 많은 용량을 차지합니다. 네트워크 대역폭을 아주 많이 절약하는 것이죠!\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e토론\u003c/h1\u003e\n\u003cp\u003e저장 비용을 10배 줄이는 것은 당연히 큰 이점입니다. 하지만 모든 것이 완벽한 것은 아닙니다. 이미지 크기를 조정하는 것은 계산에 많은 비용이 드는 작업이에요. 각 요청마다 CPU 시간이 소요됩니다. 또한 imgproxy가 얼마나 효율적이든 이미지 생성에는 시간이 걸립니다. 우리는 저장 비용을 CPU 비용으로 교환하고, 결과적으로 성능에 약간의 저하가 발생합니다.\u003c/p\u003e\n\u003cp\u003e이를 해결하려면 앞 단에 캐싱 레이어가 필요합니다. 커스텀 캐싱이나 더 가능한 CDN 등을 사용할 수 있어요. 자산을 다시 저장할 것이라는 이의가 있을 수 있습니다. 따라서 저장 비용이 다시 증가할 거라는 거죠. 그러나 캐시는 사용된 이미지에만 작동하며, 이전 솔루션에서는 모든 이미지를 저장하기 위해 비용을 지불했습니다. 이외에도, 이미지가 필요한 경우에 캐시를 미리 로딩하는 등 캐싱에 대한 이미 알려진 레시피를 적용할 수도 있어요. 예를 들어, 이벤트 전에 필요한 이미지 그룹을 미리 로딩하는 것 등이죠.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e이 게시물에서는 Apache APISIX와 imgproxy를 사용하여 여러 해상도의 이미지 저장 비용을 줄이는 방법을 설명했습니다. 캐싱을 추가하면 전체 아키텍처에 더 많은 구성 요소가 추가되지만 저장 비용이 줄어듭니다.\u003c/p\u003e\n\u003cp\u003e이 게시물은 Andreas Lehr의 StackConf 발표에서 영감을 받았습니다.\u003c/p\u003e\n\u003cp\u003e이 게시물의 전체 소스 코드는 GitHub에서 찾을 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e더 알아보기:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eimgproxy 문서\u003c/li\u003e\n\u003cli\u003eimgproxy 인터랙티브 데모\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e2023년 10월 1일에 A Java Geek에서 처음 발행되었습니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-30-Resizingimageson-the-fly"},"buildId":"ckvP8zvWyPnScUqpsTElP","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>