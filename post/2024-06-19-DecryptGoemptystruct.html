<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>복호화 Go 빈 구조체 | uidev-css</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://uidev-css.github.io///post/2024-06-19-DecryptGoemptystruct" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="복호화 Go 빈 구조체 | uidev-css" data-gatsby-head="true"/><meta property="og:title" content="복호화 Go 빈 구조체 | uidev-css" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-19-DecryptGoemptystruct_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://uidev-css.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://uidev-css.github.io///post/2024-06-19-DecryptGoemptystruct" data-gatsby-head="true"/><meta name="twitter:title" content="복호화 Go 빈 구조체 | uidev-css" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-19-DecryptGoemptystruct_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | uidev-css" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-19 08:25" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b75a4bf98ee956a8.js" defer=""></script><script src="/_next/static/x5lQ-Qhw0MhdJKm-cNZYh/_buildManifest.js" defer=""></script><script src="/_next/static/x5lQ-Qhw0MhdJKm-cNZYh/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UIDEV CSS</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">복호화 Go 빈 구조체</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="복호화 Go 빈 구조체" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UIDEV CSS</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 19, 2024</span><span class="posts_reading_time__f7YPP">4<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-19-DecryptGoemptystruct&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h1>고(Go)에서 빈 구조체의 수수께끼: 사용법과 최적화를 이해해보세요</h1>
<p>일반적으로 구조체는 메모리 블록을 차지합니다. 그러나 특별한 경우가 있습니다: 만약 빈 구조체라면, 크기는 제로입니다. 이것이 어떻게 가능한 것이고, 빈 구조체의 사용은 무엇일까요?</p>
<pre><code class="hljs language-js">type <span class="hljs-title class_">Test</span> struct {
     A int
     B string
 }
 
 func <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) {
     fmt.<span class="hljs-title class_">Println</span>(unsafe.<span class="hljs-title class_">Sizeof</span>(<span class="hljs-title class_">Test</span>{}))
     fmt.<span class="hljs-title class_">Println</span>(unsafe.<span class="hljs-title class_">Sizeof</span>(struct{}{}))
 }
 
 <span class="hljs-comment">/*
 24
 0
 */</span>
</code></pre>
<h1>빈 구조체의 비밀</h1>
<h2>특별한 변수: zerobase</h2>
<p>빈 구조체는 메모리 크기가 없는 구조체입니다. 이 문장은 맞지만, 더 정확하게 말하면 특별한 시작점이 있습니다: zerobase 변수입니다. 이는 8바이트를 차지하는 uintptr 전역 변수입니다. 무수히 많은 구조체 '' 변수가 정의될 때, 컴파일러는 이 zerobase 변수의 주소를 할당합니다. 다시 말해, Go에서 크기가 0인 모든 메모리 할당은 동일한 주소 &#x26;zerobase 를 사용합니다.</p>
<p>예제</p>
<pre><code class="hljs language-go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span>

<span class="hljs-keyword">type</span> emptyStruct <span class="hljs-keyword">struct</span>{}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    a := <span class="hljs-keyword">struct</span>{}{}
    b := <span class="hljs-keyword">struct</span>{}{}
    c := emptyStruct{}

    fmt.Printf(<span class="hljs-string">"%p\n"</span>, &#x26;a)
    fmt.Printf(<span class="hljs-string">"%p\n"</span>, &#x26;b)
    fmt.Printf(<span class="hljs-string">"%p\n"</span>, &#x26;c)
}

<span class="hljs-comment">// 0x58e360</span>
<span class="hljs-comment">// 0x58e360</span>
<span class="hljs-comment">// 0x58e360</span>
</code></pre>
<p>빈 구조체 변수의 메모리 주소는 모두 동일합니다. 이는 컴파일 시에 특수한 형식의 메모리 할당을 만나면 컴파일러가 &#x26;zerobase를 할당하기 때문입니다. 이 로직은 mallocgc 함수에 있습니다.</p>
<pre><code class="hljs language-go"><span class="hljs-comment">//go:linkname mallocgc</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mallocgc</span><span class="hljs-params">(size <span class="hljs-type">uintptr</span>, typ *_type, needzero <span class="hljs-type">bool</span>)</span></span> unsafe.Pointer {
    ...
    <span class="hljs-keyword">if</span> size == <span class="hljs-number">0</span> {
        <span class="hljs-keyword">return</span> unsafe.Pointer(&#x26;zerobase)
    }
    ...
</code></pre>
<p>이것이 빈 구조체의 비밀입니다. 이 특수한 변수로 많은 기능을 수행할 수 있습니다.</p>
<h1>빈 구조체와 메모리 정렬</h1>
<p>일반적으로 빈 구조체가 더 큰 구조체의 일부인 경우 메모리를 차지하지 않습니다. 그러나 빈 구조체가 마지막 필드인 경우에는 메모리 정렬이 트리거됩니다.</p>
<p>예시</p>
<pre><code class="hljs language-js">type A struct {
    x int
    y string
    z struct{}
}
type B struct {
    x int
    z struct{}
    y string
}

func <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">println</span>(unsafe.<span class="hljs-title class_">Alignof</span>(A{}))
    <span class="hljs-title function_">println</span>(unsafe.<span class="hljs-title class_">Alignof</span>(B{}))
    <span class="hljs-title function_">println</span>(unsafe.<span class="hljs-title class_">Sizeof</span>(A{}))
    <span class="hljs-title function_">println</span>(unsafe.<span class="hljs-title class_">Sizeof</span>(B{}))
}
</code></pre>
<p>결과:</p>
<pre><code class="hljs language-plaintext">8
8
32
24
</code></pre>
<p>포인터가 필드를 가리키는 경우, 반환된 주소는 구조체 외부에 있을 수 있으며, 구조체가 해제될 때 해당 메모리가 해제되지 않으면 메모리 누수로 이어질 수 있습니다. 따라서 다른 구조체의 마지막 필드로 빈 구조체가 사용될 때는 안전을 위해 추가적인 메모리가 할당됩니다. 빈 구조체가 시작이나 중간에 위치할 경우, 그 주소는 다음 변수와 동일합니다.</p>
<pre><code class="hljs language-js">type A struct {  
    x int  
    y string  
    z struct{}  
}  
type B struct {  
    x int  
    z struct{}  
    y string  
}  

func <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) {  
    a := A{}  
    b := B{}  
    fmt.<span class="hljs-title class_">Printf</span>(<span class="hljs-string">"%p\n"</span>, &#x26;a.<span class="hljs-property">y</span>)  
    fmt.<span class="hljs-title class_">Printf</span>(<span class="hljs-string">"%p\n"</span>, &#x26;a.<span class="hljs-property">z</span>)  
    fmt.<span class="hljs-title class_">Printf</span>(<span class="hljs-string">"%p\n"</span>, &#x26;b.<span class="hljs-property">y</span>)  
    fmt.<span class="hljs-title class_">Printf</span>(<span class="hljs-string">"%p\n"</span>, &#x26;b.<span class="hljs-property">z</span>)  
}

<span class="hljs-comment">/**
0x1400012c008
0x1400012c018
0x1400012e008
0x1400012e008
**/</span>
</code></pre>
<h1>빈 구조체의 사용 사례</h1>
<p>빈 구조체(struct{})의 존재 이유는 메모리를 절약하는 데 있습니다. 내용에 관심이 없지만 구조체가 필요할 때 빈 구조체를 사용하는 것을 고려해보세요. Go의 핵심 복합 구조체인 map, chan 및 slice 모두 빈 구조체를 사용할 수 있습니다.</p>
<h2>맵과 구조체</h2>
<pre><code class="hljs language-go"><span class="hljs-comment">// 맵 생성</span>
m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-keyword">struct</span>{})
<span class="hljs-comment">// 값 할당</span>
m[<span class="hljs-number">1</span>] = <span class="hljs-keyword">struct</span>{}{}
<span class="hljs-comment">// 키 존재 여부 확인</span>
_, ok := m[<span class="hljs-number">1</span>]
</code></pre>
<h2>채널과 구조체</h2>
<p>채널과 구조체를 결합하는 클래식한 시나리오에서는 구조체를 신호로 사용하고 내용에 대해 신경 쓰지 않습니다. 이전 글에서 분석한 대로 채널의 필수 데이터 구조는 관리 구조체와 링 버퍼가 함께합니다. 구조체를 요소로 사용하는 경우 링 버퍼는 제로 할당됩니다.</p>
<p>chan과 struct를 함께 사용하는 유일한 목적은 빈 구조체 자체가 어떤 값을 전달할 수 없기 때문에 신호 전달에 사용된다는 것입니다. 일반적으로 버퍼가 없는 채널과 함께 사용됩니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 신호 채널 생성</span>
waitc := <span class="hljs-title function_">make</span>(chan struct{})
 
<span class="hljs-comment">// ...</span>
goroutine <span class="hljs-number">1</span>:
    <span class="hljs-comment">// 신호 전송: 요소 추가</span>
    waitc &#x3C;- struct{}{}
    <span class="hljs-comment">// 신호 전송: 종료</span>
    <span class="hljs-title function_">close</span>(waitc)
 
goroutine <span class="hljs-number">2</span>:
    select {
    <span class="hljs-comment">// 신호 수신 및 해당 작업 수행</span>
    <span class="hljs-keyword">case</span> <span class="xml">&#x3C;-waitc:
    }
</span></code></pre>
<p>이 시나리오에서 struct가 꼭 필요할까요? 정말 필요하지는 않으며, 절약되는 메모리는 미미합니다. 핵심은 chan의 요소 값이 중요하지 않다는 것이며, 따라서 struct가 사용됩니다.</p>
<h1>요약</h1>
<ul>
<li>빈 구조체는 여전히 크기가 0인 구조체입니다.</li>
<li>모든 빈 구조체는 동일한 주소를 공유합니다: zerobase 주소입니다.</li>
<li>빈 구조체의 메모리를 차지하지 않는 기능을 활용하여 맵을 사용하여 집합 및 채널을 구현하는 등 코드를 최적화할 수 있습니다.</li>
</ul>
<h1>참고 자료</h1>
<ul>
<li>빈 구조체, Dave Cheney</li>
<li>Go 최종 릴리스 - struct'' 빈 구조체가 정확히 무엇인가요?</li>
</ul>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"복호화 Go 빈 구조체","description":"","date":"2024-06-19 08:25","slug":"2024-06-19-DecryptGoemptystruct","content":"\n\n\u003cimg src=\"/assets/img/2024-06-19-DecryptGoemptystruct_0.png\" /\u003e\n\n# 고(Go)에서 빈 구조체의 수수께끼: 사용법과 최적화를 이해해보세요\n\n일반적으로 구조체는 메모리 블록을 차지합니다. 그러나 특별한 경우가 있습니다: 만약 빈 구조체라면, 크기는 제로입니다. 이것이 어떻게 가능한 것이고, 빈 구조체의 사용은 무엇일까요?\n\n```js\ntype Test struct {\n     A int\n     B string\n }\n \n func main() {\n     fmt.Println(unsafe.Sizeof(Test{}))\n     fmt.Println(unsafe.Sizeof(struct{}{}))\n }\n \n /*\n 24\n 0\n */\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 빈 구조체의 비밀\n\n## 특별한 변수: zerobase\n\n빈 구조체는 메모리 크기가 없는 구조체입니다. 이 문장은 맞지만, 더 정확하게 말하면 특별한 시작점이 있습니다: zerobase 변수입니다. 이는 8바이트를 차지하는 uintptr 전역 변수입니다. 무수히 많은 구조체 '' 변수가 정의될 때, 컴파일러는 이 zerobase 변수의 주소를 할당합니다. 다시 말해, Go에서 크기가 0인 모든 메모리 할당은 동일한 주소 \u0026zerobase 를 사용합니다.\n\n예제\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```go\npackage main\n\nimport \"fmt\"\n\ntype emptyStruct struct{}\n\nfunc main() {\n    a := struct{}{}\n    b := struct{}{}\n    c := emptyStruct{}\n\n    fmt.Printf(\"%p\\n\", \u0026a)\n    fmt.Printf(\"%p\\n\", \u0026b)\n    fmt.Printf(\"%p\\n\", \u0026c)\n}\n\n// 0x58e360\n// 0x58e360\n// 0x58e360\n```\n\n빈 구조체 변수의 메모리 주소는 모두 동일합니다. 이는 컴파일 시에 특수한 형식의 메모리 할당을 만나면 컴파일러가 \u0026zerobase를 할당하기 때문입니다. 이 로직은 mallocgc 함수에 있습니다.\n\n```go\n//go:linkname mallocgc\nfunc mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n    ...\n    if size == 0 {\n        return unsafe.Pointer(\u0026zerobase)\n    }\n    ...\n```\n\n이것이 빈 구조체의 비밀입니다. 이 특수한 변수로 많은 기능을 수행할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 빈 구조체와 메모리 정렬\n\n일반적으로 빈 구조체가 더 큰 구조체의 일부인 경우 메모리를 차지하지 않습니다. 그러나 빈 구조체가 마지막 필드인 경우에는 메모리 정렬이 트리거됩니다.\n\n예시\n\n```js\ntype A struct {\n    x int\n    y string\n    z struct{}\n}\ntype B struct {\n    x int\n    z struct{}\n    y string\n}\n\nfunc main() {\n    println(unsafe.Alignof(A{}))\n    println(unsafe.Alignof(B{}))\n    println(unsafe.Sizeof(A{}))\n    println(unsafe.Sizeof(B{}))\n}\n```\n\n결과:\n\n```plaintext\n8\n8\n32\n24\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n포인터가 필드를 가리키는 경우, 반환된 주소는 구조체 외부에 있을 수 있으며, 구조체가 해제될 때 해당 메모리가 해제되지 않으면 메모리 누수로 이어질 수 있습니다. 따라서 다른 구조체의 마지막 필드로 빈 구조체가 사용될 때는 안전을 위해 추가적인 메모리가 할당됩니다. 빈 구조체가 시작이나 중간에 위치할 경우, 그 주소는 다음 변수와 동일합니다.\n\n```js\ntype A struct {  \n    x int  \n    y string  \n    z struct{}  \n}  \ntype B struct {  \n    x int  \n    z struct{}  \n    y string  \n}  \n\nfunc main() {  \n    a := A{}  \n    b := B{}  \n    fmt.Printf(\"%p\\n\", \u0026a.y)  \n    fmt.Printf(\"%p\\n\", \u0026a.z)  \n    fmt.Printf(\"%p\\n\", \u0026b.y)  \n    fmt.Printf(\"%p\\n\", \u0026b.z)  \n}\n\n/**\n0x1400012c008\n0x1400012c018\n0x1400012e008\n0x1400012e008\n**/\n```\n\n# 빈 구조체의 사용 사례\n\n빈 구조체(struct{})의 존재 이유는 메모리를 절약하는 데 있습니다. 내용에 관심이 없지만 구조체가 필요할 때 빈 구조체를 사용하는 것을 고려해보세요. Go의 핵심 복합 구조체인 map, chan 및 slice 모두 빈 구조체를 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 맵과 구조체\n\n```go\n// 맵 생성\nm := make(map[int]struct{})\n// 값 할당\nm[1] = struct{}{}\n// 키 존재 여부 확인\n_, ok := m[1]\n```\n\n## 채널과 구조체\n\n채널과 구조체를 결합하는 클래식한 시나리오에서는 구조체를 신호로 사용하고 내용에 대해 신경 쓰지 않습니다. 이전 글에서 분석한 대로 채널의 필수 데이터 구조는 관리 구조체와 링 버퍼가 함께합니다. 구조체를 요소로 사용하는 경우 링 버퍼는 제로 할당됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nchan과 struct를 함께 사용하는 유일한 목적은 빈 구조체 자체가 어떤 값을 전달할 수 없기 때문에 신호 전달에 사용된다는 것입니다. 일반적으로 버퍼가 없는 채널과 함께 사용됩니다.\n\n```js\n// 신호 채널 생성\nwaitc := make(chan struct{})\n \n// ...\ngoroutine 1:\n    // 신호 전송: 요소 추가\n    waitc \u003c- struct{}{}\n    // 신호 전송: 종료\n    close(waitc)\n \ngoroutine 2:\n    select {\n    // 신호 수신 및 해당 작업 수행\n    case \u003c-waitc:\n    }\n```\n\n이 시나리오에서 struct가 꼭 필요할까요? 정말 필요하지는 않으며, 절약되는 메모리는 미미합니다. 핵심은 chan의 요소 값이 중요하지 않다는 것이며, 따라서 struct가 사용됩니다.\n\n# 요약\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 빈 구조체는 여전히 크기가 0인 구조체입니다.\n- 모든 빈 구조체는 동일한 주소를 공유합니다: zerobase 주소입니다.\n- 빈 구조체의 메모리를 차지하지 않는 기능을 활용하여 맵을 사용하여 집합 및 채널을 구현하는 등 코드를 최적화할 수 있습니다.\n\n# 참고 자료\n\n- 빈 구조체, Dave Cheney\n- Go 최종 릴리스 - struct'' 빈 구조체가 정확히 무엇인가요?","ogImage":{"url":"/assets/img/2024-06-19-DecryptGoemptystruct_0.png"},"coverImage":"/assets/img/2024-06-19-DecryptGoemptystruct_0.png","tag":["Tech"],"readingTime":4},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch1\u003e고(Go)에서 빈 구조체의 수수께끼: 사용법과 최적화를 이해해보세요\u003c/h1\u003e\n\u003cp\u003e일반적으로 구조체는 메모리 블록을 차지합니다. 그러나 특별한 경우가 있습니다: 만약 빈 구조체라면, 크기는 제로입니다. 이것이 어떻게 가능한 것이고, 빈 구조체의 사용은 무엇일까요?\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003etype \u003cspan class=\"hljs-title class_\"\u003eTest\u003c/span\u003e struct {\n     A int\n     B string\n }\n \n func \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n     fmt.\u003cspan class=\"hljs-title class_\"\u003ePrintln\u003c/span\u003e(unsafe.\u003cspan class=\"hljs-title class_\"\u003eSizeof\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eTest\u003c/span\u003e{}))\n     fmt.\u003cspan class=\"hljs-title class_\"\u003ePrintln\u003c/span\u003e(unsafe.\u003cspan class=\"hljs-title class_\"\u003eSizeof\u003c/span\u003e(struct{}{}))\n }\n \n \u003cspan class=\"hljs-comment\"\u003e/*\n 24\n 0\n */\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e빈 구조체의 비밀\u003c/h1\u003e\n\u003ch2\u003e특별한 변수: zerobase\u003c/h2\u003e\n\u003cp\u003e빈 구조체는 메모리 크기가 없는 구조체입니다. 이 문장은 맞지만, 더 정확하게 말하면 특별한 시작점이 있습니다: zerobase 변수입니다. 이는 8바이트를 차지하는 uintptr 전역 변수입니다. 무수히 많은 구조체 '' 변수가 정의될 때, 컴파일러는 이 zerobase 변수의 주소를 할당합니다. 다시 말해, Go에서 크기가 0인 모든 메모리 할당은 동일한 주소 \u0026#x26;zerobase 를 사용합니다.\u003c/p\u003e\n\u003cp\u003e예제\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-go\"\u003e\u003cspan class=\"hljs-keyword\"\u003epackage\u003c/span\u003e main\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"fmt\"\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e emptyStruct \u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e{}\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e {\n    a := \u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e{}{}\n    b := \u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e{}{}\n    c := emptyStruct{}\n\n    fmt.Printf(\u003cspan class=\"hljs-string\"\u003e\"%p\\n\"\u003c/span\u003e, \u0026#x26;a)\n    fmt.Printf(\u003cspan class=\"hljs-string\"\u003e\"%p\\n\"\u003c/span\u003e, \u0026#x26;b)\n    fmt.Printf(\u003cspan class=\"hljs-string\"\u003e\"%p\\n\"\u003c/span\u003e, \u0026#x26;c)\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 0x58e360\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 0x58e360\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 0x58e360\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e빈 구조체 변수의 메모리 주소는 모두 동일합니다. 이는 컴파일 시에 특수한 형식의 메모리 할당을 만나면 컴파일러가 \u0026#x26;zerobase를 할당하기 때문입니다. 이 로직은 mallocgc 함수에 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-go\"\u003e\u003cspan class=\"hljs-comment\"\u003e//go:linkname mallocgc\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003emallocgc\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(size \u003cspan class=\"hljs-type\"\u003euintptr\u003c/span\u003e, typ *_type, needzero \u003cspan class=\"hljs-type\"\u003ebool\u003c/span\u003e)\u003c/span\u003e\u003c/span\u003e unsafe.Pointer {\n    ...\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e size == \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e unsafe.Pointer(\u0026#x26;zerobase)\n    }\n    ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이것이 빈 구조체의 비밀입니다. 이 특수한 변수로 많은 기능을 수행할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e빈 구조체와 메모리 정렬\u003c/h1\u003e\n\u003cp\u003e일반적으로 빈 구조체가 더 큰 구조체의 일부인 경우 메모리를 차지하지 않습니다. 그러나 빈 구조체가 마지막 필드인 경우에는 메모리 정렬이 트리거됩니다.\u003c/p\u003e\n\u003cp\u003e예시\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003etype A struct {\n    x int\n    y string\n    z struct{}\n}\ntype B struct {\n    x int\n    z struct{}\n    y string\n}\n\nfunc \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-title function_\"\u003eprintln\u003c/span\u003e(unsafe.\u003cspan class=\"hljs-title class_\"\u003eAlignof\u003c/span\u003e(A{}))\n    \u003cspan class=\"hljs-title function_\"\u003eprintln\u003c/span\u003e(unsafe.\u003cspan class=\"hljs-title class_\"\u003eAlignof\u003c/span\u003e(B{}))\n    \u003cspan class=\"hljs-title function_\"\u003eprintln\u003c/span\u003e(unsafe.\u003cspan class=\"hljs-title class_\"\u003eSizeof\u003c/span\u003e(A{}))\n    \u003cspan class=\"hljs-title function_\"\u003eprintln\u003c/span\u003e(unsafe.\u003cspan class=\"hljs-title class_\"\u003eSizeof\u003c/span\u003e(B{}))\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e결과:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-plaintext\"\u003e8\n8\n32\n24\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e포인터가 필드를 가리키는 경우, 반환된 주소는 구조체 외부에 있을 수 있으며, 구조체가 해제될 때 해당 메모리가 해제되지 않으면 메모리 누수로 이어질 수 있습니다. 따라서 다른 구조체의 마지막 필드로 빈 구조체가 사용될 때는 안전을 위해 추가적인 메모리가 할당됩니다. 빈 구조체가 시작이나 중간에 위치할 경우, 그 주소는 다음 변수와 동일합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003etype A struct {  \n    x int  \n    y string  \n    z struct{}  \n}  \ntype B struct {  \n    x int  \n    z struct{}  \n    y string  \n}  \n\nfunc \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {  \n    a := A{}  \n    b := B{}  \n    fmt.\u003cspan class=\"hljs-title class_\"\u003ePrintf\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"%p\\n\"\u003c/span\u003e, \u0026#x26;a.\u003cspan class=\"hljs-property\"\u003ey\u003c/span\u003e)  \n    fmt.\u003cspan class=\"hljs-title class_\"\u003ePrintf\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"%p\\n\"\u003c/span\u003e, \u0026#x26;a.\u003cspan class=\"hljs-property\"\u003ez\u003c/span\u003e)  \n    fmt.\u003cspan class=\"hljs-title class_\"\u003ePrintf\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"%p\\n\"\u003c/span\u003e, \u0026#x26;b.\u003cspan class=\"hljs-property\"\u003ey\u003c/span\u003e)  \n    fmt.\u003cspan class=\"hljs-title class_\"\u003ePrintf\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"%p\\n\"\u003c/span\u003e, \u0026#x26;b.\u003cspan class=\"hljs-property\"\u003ez\u003c/span\u003e)  \n}\n\n\u003cspan class=\"hljs-comment\"\u003e/**\n0x1400012c008\n0x1400012c018\n0x1400012e008\n0x1400012e008\n**/\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e빈 구조체의 사용 사례\u003c/h1\u003e\n\u003cp\u003e빈 구조체(struct{})의 존재 이유는 메모리를 절약하는 데 있습니다. 내용에 관심이 없지만 구조체가 필요할 때 빈 구조체를 사용하는 것을 고려해보세요. Go의 핵심 복합 구조체인 map, chan 및 slice 모두 빈 구조체를 사용할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e맵과 구조체\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-go\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 맵 생성\u003c/span\u003e\nm := \u003cspan class=\"hljs-built_in\"\u003emake\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003emap\u003c/span\u003e[\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e]\u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e{})\n\u003cspan class=\"hljs-comment\"\u003e// 값 할당\u003c/span\u003e\nm[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e] = \u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e{}{}\n\u003cspan class=\"hljs-comment\"\u003e// 키 존재 여부 확인\u003c/span\u003e\n_, ok := m[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e채널과 구조체\u003c/h2\u003e\n\u003cp\u003e채널과 구조체를 결합하는 클래식한 시나리오에서는 구조체를 신호로 사용하고 내용에 대해 신경 쓰지 않습니다. 이전 글에서 분석한 대로 채널의 필수 데이터 구조는 관리 구조체와 링 버퍼가 함께합니다. 구조체를 요소로 사용하는 경우 링 버퍼는 제로 할당됩니다.\u003c/p\u003e\n\u003cp\u003echan과 struct를 함께 사용하는 유일한 목적은 빈 구조체 자체가 어떤 값을 전달할 수 없기 때문에 신호 전달에 사용된다는 것입니다. 일반적으로 버퍼가 없는 채널과 함께 사용됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 신호 채널 생성\u003c/span\u003e\nwaitc := \u003cspan class=\"hljs-title function_\"\u003emake\u003c/span\u003e(chan struct{})\n \n\u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\ngoroutine \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e:\n    \u003cspan class=\"hljs-comment\"\u003e// 신호 전송: 요소 추가\u003c/span\u003e\n    waitc \u0026#x3C;- struct{}{}\n    \u003cspan class=\"hljs-comment\"\u003e// 신호 전송: 종료\u003c/span\u003e\n    \u003cspan class=\"hljs-title function_\"\u003eclose\u003c/span\u003e(waitc)\n \ngoroutine \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e:\n    select {\n    \u003cspan class=\"hljs-comment\"\u003e// 신호 수신 및 해당 작업 수행\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u0026#x3C;-waitc:\n    }\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 시나리오에서 struct가 꼭 필요할까요? 정말 필요하지는 않으며, 절약되는 메모리는 미미합니다. 핵심은 chan의 요소 값이 중요하지 않다는 것이며, 따라서 struct가 사용됩니다.\u003c/p\u003e\n\u003ch1\u003e요약\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e빈 구조체는 여전히 크기가 0인 구조체입니다.\u003c/li\u003e\n\u003cli\u003e모든 빈 구조체는 동일한 주소를 공유합니다: zerobase 주소입니다.\u003c/li\u003e\n\u003cli\u003e빈 구조체의 메모리를 차지하지 않는 기능을 활용하여 맵을 사용하여 집합 및 채널을 구현하는 등 코드를 최적화할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e참고 자료\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e빈 구조체, Dave Cheney\u003c/li\u003e\n\u003cli\u003eGo 최종 릴리스 - struct'' 빈 구조체가 정확히 무엇인가요?\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-19-DecryptGoemptystruct"},"buildId":"x5lQ-Qhw0MhdJKm-cNZYh","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>