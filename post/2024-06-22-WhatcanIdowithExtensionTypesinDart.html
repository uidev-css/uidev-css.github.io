<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Dart에서 Extension Types으로 할 수 있는 것들 | uidev-css</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://uidev-css.github.io///post/2024-06-22-WhatcanIdowithExtensionTypesinDart" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Dart에서 Extension Types으로 할 수 있는 것들 | uidev-css" data-gatsby-head="true"/><meta property="og:title" content="Dart에서 Extension Types으로 할 수 있는 것들 | uidev-css" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://uidev-css.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://uidev-css.github.io///post/2024-06-22-WhatcanIdowithExtensionTypesinDart" data-gatsby-head="true"/><meta name="twitter:title" content="Dart에서 Extension Types으로 할 수 있는 것들 | uidev-css" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | uidev-css" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-22 00:40" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b75a4bf98ee956a8.js" defer=""></script><script src="/_next/static/AAcWCMtAYBsqiURBkbPEc/_buildManifest.js" defer=""></script><script src="/_next/static/AAcWCMtAYBsqiURBkbPEc/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UIDEV CSS</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Dart에서 Extension Types으로 할 수 있는 것들</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Dart에서 Extension Types으로 할 수 있는 것들" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UIDEV CSS</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 22, 2024</span><span class="posts_reading_time__f7YPP">12<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-22-WhatcanIdowithExtensionTypesinDart&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>Dart 3.3 확장 타입</p>
<p><img src="/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_0.png" alt="Image"></p>
<p>공식 문서는 다음과 같이 시작합니다:</p>
<p>확장 타입은 강력한 타입 래퍼로 작용하는 컴파일 시간 추상화입니다. 성능 최적화를 위해 도입되었으며 네이티브 코드와의 향상된 상호작용을 제공합니다. Zero-cost 래퍼로서, 다른 언어와 통신할 때 Wrapper 클래스와 Helper 클래스와 관련된 전형적인 메모리 비용을 제거합니다.</p>
<p>일반 클래스 래퍼는 런타임에서 작동하며 항상 클래스 및 객체 사용량의 오버헤드가 발생하여 메모리 사용량과 GC(Garbage Collection) 비용이 증가합니다. 단기간에 많은 래퍼 인스턴스가 생성되는 시나리오에서는 이 부담이 상당해집니다.</p>
<p>확장 유형은 특정 유형의 확장으로 컴파일 시간에 확인되므로 런타임에서는 원래 표현 유형으로 되돌아가며 추상화가 사라집니다. 따라서 확장 유형을 사용하면 응용 프로그램에 비용이 발생하지 않아 매우 효율적인 개발 방법이 됩니다.
확장 유형은 정적 JavaScript 상호 운용을 가능하게 하며, 기존 JavaScript 유형과의 원활한 상호 작용을 허용합니다.</p>
<h1>혜택</h1>
<h2>유연한 제한과 확장</h2>
<p>기존 유형(예: int 또는 String)을 속성, 함수 및 다른 API를 추가하여 향상시킬 수 있습니다.</p>
<h2>더 명확한 추상화</h2>
<p>기본 표현 유형의 복잡성을 숨겨 의미 있는 확장을 가능하게 하여 코드 가독성과 유지 관리성을 향상시킵니다.</p>
<h2>편리하고 안전한 상호 운용성</h2>
<p>Dart 사용자 정의 유형은 기본 유형에 액세스하는 것만큼 간단하여 유형 안전성을 제공합니다. 이는 네이티브 플랫폼 및 다른 언어와의 상호 운용성에 특히 유용하며, 프로세스를 간소화합니다.</p>
<h2>향상된 성능</h2>
<p>각 서비스마다 Wrapper 클래스를 생성하지 않아 추가 메모리 오버헤드가 발생하지 않습니다. 특히 대량 데이터 집합이나 빈번한 객체 작업을 처리할 때 성능에 민감한 시나리오에 이상적입니다.</p>
<h1>개발</h1>
<p>확장 형식은 선언될 때 기본 생성자가 자동으로 포함됩니다.</p>
<pre><code class="hljs language-js">extension type <span class="hljs-title class_">MyId</span>(int id) {}

<span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">List&#x3C;<span class="hljs-built_in">String</span>> <span class="hljs-variable language_">arguments</span></span>) {
  final id = <span class="hljs-title class_">MyId</span>(<span class="hljs-number">1</span>);
  
  <span class="hljs-title function_">print</span>(id); <span class="hljs-comment">// 1 </span>
  <span class="hljs-title function_">print</span>(id.<span class="hljs-property">runtimeType</span>); <span class="hljs-comment">// int</span>
}
</code></pre>
<p>어떤 경우에도 확장 형식에 의해 래핑된 형식은 "표현 형식"으로 불리며 서브타입이 아닙니다. 따라서 일반적으로 표현 형식과 사용자 정의 확장 형식은 서로 값 할당이 불가능합니다.</p>
<p>사용자 정의된 새로운 속성과 함수 인터페이스가 없을 때에는 기능적인 작업이 없습니다. int의 원래 동작이 제한됩니다.</p>
<p><img src="/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_1.png" alt="extension types in Dart"></p>
<p>기존 유형에 대해서는 더 많은 확장이나 유형의 제약 사항에 대해 노출되는 것이 아닌 사용 가능한 API만 노출되며, 그렇게 함으로써 일부 허용되지 않는 작업을 피할 수 있습니다. 우리가 필요로 하는 의미 있는 함수를 추가할 수 있습니다.</p>
<pre><code class="hljs language-dart"><span class="hljs-keyword">extension</span> type MyId(<span class="hljs-built_in">int</span> id) {
  <span class="hljs-keyword">operator</span> >(MyId other) => id > other.id;
  
  <span class="hljs-built_in">bool</span> isBiggerThan(MyId other) => id > other.id;
}

<span class="hljs-keyword">void</span> main(<span class="hljs-built_in">List</span>&#x3C;<span class="hljs-built_in">String</span>> arguments) {
  MyId safeId = MyId(<span class="hljs-number">200</span>);
  safeId + <span class="hljs-number">10</span>; <span class="hljs-comment">// Compile error: No '+' operator.</span>
  safeId - <span class="hljs-number">10</span>; <span class="hljs-comment">// Compile error: No '-' operator.</span>
  safeId > <span class="hljs-number">10</span>; <span class="hljs-comment">// Compile error: Wrong type.</span>
  safeId > MyId(<span class="hljs-number">300</span>); <span class="hljs-comment">// ✅</span>

  <span class="hljs-built_in">int</span> number = <span class="hljs-number">100</span>;
  number = safeId; <span class="hljs-comment">// Compile error: Wrong type.</span>
  number = safeId <span class="hljs-keyword">as</span> <span class="hljs-built_in">int</span>; <span class="hljs-comment">// ✅ Cast to representation type.</span>
  safeId = number <span class="hljs-keyword">as</span> MyId; <span class="hljs-comment">// ✅ Cast to extension type.</span>

  <span class="hljs-built_in">print</span>(safeId.isBiggerThan(MyId(<span class="hljs-number">300</span>))); <span class="hljs-comment">// false</span>
}
</code></pre>
<p>서비스나 네이티브 API와 상호 작용 후 반환된 값은 int를 사용하여 가독성을 높일 수 있어요. 확장 유형을 통해 특정 이름을 지정할 수 있어요. 이렇게 하면 한눈에 이해하기 쉬워져요.</p>
<p>확장 유형과 표현 유형은 as 캐스팅을 사용하여 직접 변환할 수 있어요. 재미있는 점은 상속 관계가 아님에도 불구하고 강제로 변환할 수도 있어요.</p>
<pre><code class="hljs language-js">i = id <span class="hljs-keyword">as</span> int; <span class="hljs-comment">// ✅</span>
i = -<span class="hljs-number">1</span>;
id = i <span class="hljs-keyword">as</span> <span class="hljs-title class_">Id</span>;  <span class="hljs-comment">// ✅</span>
</code></pre>
<p>다트 클래스처럼 확장 유형을 일반적으로 처리하고 인스턴스화하고 사용자 정의 함수를 호출할 수 있는 예제가 있어요. 다트는 이를 일반 int로 컴파일해요.</p>
<pre><code class="hljs language-dart"><span class="hljs-keyword">extension</span> type Wrapper(<span class="hljs-built_in">int</span> i) {
  <span class="hljs-keyword">void</span> showValue() {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'my value is <span class="hljs-subst">$i</span>'</span>);
  }
}

<span class="hljs-keyword">void</span> main() {
  <span class="hljs-keyword">final</span> wrapper = Wrapper(<span class="hljs-number">42</span>);
  wrapper.showValue(); <span class="hljs-comment">// Prints 'my value is 42'</span>
}
</code></pre>
<p>공식 설명에 따르면 익스텐션 타입은 네이티브 코드와의 상호 운용성을 위해 유용하며, 간접 비용을 발생시키지 않고 네이티브 타입을 직접 사용할 수 있으면서도 깔끔한 Dart API를 제공합니다.</p>
<h1>제네릭</h1>
<p>익스텐션 타입과 제네릭을 함께 사용하기:</p>
<pre><code class="hljs language-dart"><span class="hljs-keyword">extension</span> type MyList&#x3C;T>(<span class="hljs-built_in">List</span>&#x3C;T> elements) {
 <span class="hljs-keyword">void</span> add(T value) => elements.add(value);
}

<span class="hljs-keyword">void</span> main(<span class="hljs-built_in">List</span>&#x3C;<span class="hljs-built_in">String</span>> arguments) {
  MyList list = MyList&#x3C;<span class="hljs-built_in">int</span>>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]);
  list.add(<span class="hljs-number">3</span>);

  <span class="hljs-keyword">final</span> normalList = list <span class="hljs-keyword">as</span> <span class="hljs-built_in">List</span>&#x3C;<span class="hljs-built_in">int</span>>;
  <span class="hljs-built_in">print</span>(list); <span class="hljs-comment">// [1, 2, 3]</span>
  <span class="hljs-built_in">print</span>(normalList); <span class="hljs-comment">// [1, 2, 3]</span>
}
</code></pre>
<h1>생성자</h1>
<p>Extension 타입은 여러 개의 생성자를 가질 수 있습니다:</p>
<ul>
<li>일반 생성자</li>
<li>명명된 생성자</li>
<li>private 생성자 문법을 사용한 숨겨진 생성자</li>
</ul>
<pre><code class="hljs language-dart"><span class="hljs-keyword">extension</span> type Password._(<span class="hljs-built_in">String</span> value) {
  Password(<span class="hljs-keyword">this</span>.value) {
    <span class="hljs-keyword">assert</span>(value.length >= <span class="hljs-number">8</span>);
    
    <span class="hljs-keyword">if</span> (value.length &#x3C; <span class="hljs-number">8</span>) {
      <span class="hljs-keyword">throw</span> Exception(<span class="hljs-string">'Password must be at least 8 characters long'</span>);
    }
  }

  Password.random() : value = _generateRandomPassword();

  <span class="hljs-keyword">static</span> <span class="hljs-built_in">String</span> _generateRandomPassword() => ...;

  <span class="hljs-built_in">bool</span> <span class="hljs-keyword">get</span> isValid => value.length >= <span class="hljs-number">8</span>;
}

<span class="hljs-keyword">void</span> main(<span class="hljs-built_in">List</span>&#x3C;<span class="hljs-built_in">String</span>> arguments) {
  <span class="hljs-comment">// 암시적 명명되지 않은 생성자.</span>
  Password password = Password(<span class="hljs-string">'abcdefghijklmnopqrstuvwxyz'</span>); <span class="hljs-comment">// ✅</span>

  <span class="hljs-comment">// 명명된 생성자.</span>
  password = Password.random(); <span class="hljs-comment">// ✅</span>
  password = Password(<span class="hljs-string">'hello12'</span>); <span class="hljs-comment">// Exception: Password must be at least 8 characters long</span>
  password = <span class="hljs-string">'hello'</span> <span class="hljs-keyword">as</span> Password; <span class="hljs-comment">// ✅</span>
}
</code></pre>
<p>기억하세요, 암시적 주 생성자에서는 assert() 체크나 다른 작업을 사용할 수 없습니다. 기본 생성자를 재정의하고 assert 체크를 추가하세요. 기본 생성자를 내부적으로(private) 만드세요.</p>
<pre><code class="hljs language-dart"><span class="hljs-keyword">extension</span> type Password._(<span class="hljs-built_in">String</span> value) {

  Password(<span class="hljs-keyword">this</span>.value) {
    <span class="hljs-keyword">assert</span>(value.length >= <span class="hljs-number">8</span>);
    
    <span class="hljs-keyword">if</span> (value.length &#x3C; <span class="hljs-number">8</span>) {
      <span class="hljs-keyword">throw</span> Exception(<span class="hljs-string">'Password must be at least 8 characters long'</span>);
    }
  }
  
}
</code></pre>
<h1>안전한 Alias</h1>
<p>implements를 사용하면 Extension Types가 기본 유형을 노출하여 Representation 타입의 모든 멤버 및 사용자 지정 도우미 API에 액세스할 수 있습니다. 이는 원래 유형의 기능을 제공하면서도 별칭 및 타입 안전성 확인을 제공합니다.</p>
<pre><code class="hljs language-js">extension type <span class="hljs-title class_">Height</span>(double _) implements double {}
extension type <span class="hljs-title class_">Weight</span>(double _) implements double {}

double <span class="hljs-title function_">calculateBmi</span>(<span class="hljs-title class_">Height</span> height, <span class="hljs-title class_">Weight</span> weight) => weight / ( height * height);

<span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">var</span> height = <span class="hljs-title class_">Height</span>(<span class="hljs-number">1.75</span>);
  <span class="hljs-keyword">var</span> weight = <span class="hljs-title class_">Weight</span>(<span class="hljs-number">65</span>);
  <span class="hljs-keyword">var</span> bmi = <span class="hljs-title function_">calculateBmi</span>(height, weight);
  <span class="hljs-title function_">print</span>(bmi); <span class="hljs-comment">// 21.22448979591837</span>
  
  bmi = <span class="hljs-title function_">calculateBmi</span>(<span class="hljs-number">1.64</span>, <span class="hljs-number">54.0</span>);     <span class="hljs-comment">// ❌ 컴파일 타임 오류</span>
  bmi = <span class="hljs-title function_">calculateBmi</span>(weight, height); <span class="hljs-comment">// ❌ 컴파일 타임 오류</span>
}
</code></pre>
<p>기존 타입에 새로운 인터페이스 추가하기:</p>
<pre><code class="hljs language-js">extension type <span class="hljs-title class_">MyId</span>(int id) implements int {
  <span class="hljs-title class_">MyId</span> get value => <span class="hljs-variable language_">this</span>;
}

<span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">List&#x3C;<span class="hljs-built_in">String</span>> <span class="hljs-variable language_">arguments</span></span>) {
  final safeId = <span class="hljs-title class_">MyId</span>(<span class="hljs-number">100</span>);
  safeId + <span class="hljs-number">1</span>; <span class="hljs-comment">// 101</span>
  safeId - <span class="hljs-number">1</span>; <span class="hljs-comment">// 99</span>
  safeId * <span class="hljs-number">2</span>; <span class="hljs-comment">// 200</span>
  safeId / <span class="hljs-number">2</span>; <span class="hljs-comment">// 50</span>
  safeId % <span class="hljs-number">3</span>; <span class="hljs-comment">// 1</span>
  safeId.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// '100'</span>

  int normalId = safeId; <span class="hljs-comment">// 100</span>
  final safeId2 = safeId + normalId; <span class="hljs-comment">// 200</span>
  final safeId3 = <span class="hljs-number">10</span> + safeId; <span class="hljs-comment">// 110</span>
}
</code></pre>
<p>기존의 기능적 동작을 재정의하고 확장 타입의 멤버들은 완전히 부모 타입의 동일한 이름을 가진 멤버들을 대체하여 새 구현 방법을 제공합니다.</p>
<pre><code class="hljs language-js">확장 타입 <span class="hljs-title class_">MyId</span>(int id)은 int를 구현합니다 {
  bool get isEven => <span class="hljs-literal">true</span>;
}

<span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">List&#x3C;<span class="hljs-built_in">String</span>> <span class="hljs-variable language_">arguments</span></span>) {
  final myId = <span class="hljs-title class_">MyId</span>(<span class="hljs-number">101</span>);
  <span class="hljs-title function_">print</span>(myId.<span class="hljs-property">isEven</span>); <span class="hljs-comment">// true</span>
}
</code></pre>
<h1>다른 시나리오</h1>
<h2>다중 타입 확장</h2>
<p>보통, 확장 유형은 하나의 유형을 확장합니다. 여러 정보가 있는 경우 Record를 사용할 수 있습니다.</p>
<pre><code class="hljs language-js">typedef <span class="hljs-title class_">UserInfo</span> = ({<span class="hljs-title class_">String</span> email, <span class="hljs-title class_">String</span> password});

extension type <span class="hljs-title class_">User</span>(<span class="hljs-title class_">UserInfo</span> info) {
  <span class="hljs-keyword">void</span> <span class="hljs-title function_">printInfo</span>() => <span class="hljs-title function_">print</span>(<span class="hljs-string">"Email: ${info.email}, Password: ${info.password}"</span>);
}

<span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">List&#x3C;<span class="hljs-built_in">String</span>> <span class="hljs-variable language_">arguments</span></span>) {
  final user = <span class="hljs-title class_">User</span>(
    (
      <span class="hljs-attr">email</span>: <span class="hljs-string">'extension@gmail.com'</span>,
      <span class="hljs-attr">password</span>: <span class="hljs-string">'types'</span>,
    ),
  );
  user.<span class="hljs-title function_">printInfo</span>(); <span class="hljs-comment">// Email: extension@gmail.com, Password: types</span>
}
</code></pre>
<h2>테스트용 모의 데이터</h2>
<p>테스트에서 Extension Types를 사용하는 것도 가능합니다. Mock 클래스에 따르면 코드를 약간 조정하기만 하면 됩니다. 일반 클래스와의 차이점은 인터페이스를 구현하지 않은 경우 일반 클래스는 컴파일 경고를 표시하지만, Extension Types는 표시하지 않는다.</p>
<h2>JSON 접근</h2>
<p>JSON 데이터에 대한 Extension Types 활용.</p>
<pre><code class="hljs language-js">final userMap = json.<span class="hljs-title function_">decode</span>(r<span class="hljs-string">''</span><span class="hljs-string">'
  {
    "name": {
      "first": "Yii",
      "last": "Chen"
    },
    "email": "ab20803@gmail.com"
  }
'</span><span class="hljs-string">''</span>); <span class="hljs-comment">// Map&#x3C;String, dynamic></span>

extension type <span class="hljs-title class_">User</span>(<span class="hljs-title class_">Map</span>&#x3C;<span class="hljs-title class_">String</span>, dynamic> _) {
  <span class="hljs-title class_">Name</span> get name => _[<span class="hljs-string">'name'</span>] <span class="hljs-keyword">as</span> <span class="hljs-title class_">Name</span>;
  <span class="hljs-title class_">String</span> get email => _[<span class="hljs-string">'email'</span>] <span class="hljs-keyword">as</span> <span class="hljs-title class_">String</span>;
}
extension type <span class="hljs-title class_">Name</span>(<span class="hljs-title class_">Map</span>&#x3C;<span class="hljs-title class_">String</span>, dynamic> _) {
  <span class="hljs-title class_">String</span> get first => _[<span class="hljs-string">'first'</span>] <span class="hljs-keyword">as</span> <span class="hljs-title class_">String</span>;
  <span class="hljs-title class_">String</span> get last => _[<span class="hljs-string">'last'</span>] <span class="hljs-keyword">as</span> <span class="hljs-title class_">String</span>;
}
<span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) {
  final person = <span class="hljs-title class_">User</span>(userMap);
  <span class="hljs-title function_">print</span>(person.<span class="hljs-property">name</span>.<span class="hljs-property">first</span>);   <span class="hljs-comment">// Yii</span>
  <span class="hljs-title function_">print</span>(person.<span class="hljs-property">name</span>.<span class="hljs-property">last</span>);    <span class="hljs-comment">// Chen</span>
  <span class="hljs-title function_">print</span>(person.<span class="hljs-property">email</span>);        <span class="hljs-comment">// ab20803@gmail.com</span>
  <span class="hljs-title function_">print</span>(person.<span class="hljs-property">email</span>.<span class="hljs-property">length</span>); <span class="hljs-comment">// 17</span>
}
</code></pre>
<h1>상호 운용성</h1>
<p>현재 Extension Types은 주로 dart: js_interop 패키지에서 사용되며, 익숙한 구문을 사용하여 JavaScript API에 액세스하고 상호 작용할 수 있도록 합니다. 이 패키지는 JSObject 및 JSAny와 같은 많은 JS 관련 유형을 정의하여 Dart와 네이티브 플랫폼 간의 안전한 통신을 보장합니다. C++와 같은 다른 언어도 이 접근 방식에서 혜택을 볼 수 있습니다.</p>
<p><img src="/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_2.png" alt="image"></p>
<p>external → 이 키워드는 일반적으로 다른 언어에서 사용하는 외부 함수에 액세스할 수 있도록 합니다. 따라서 Dart 상호 운용성 개발에서 자주 볼 수 있습니다.</p>
<p>@JS() → 만약 Dart 측에서 다른 이름을 구현하거나 동일한 JavaScript API를 가리키는 여러 Dart API를 작성하려는 경우, 상호 운용성을 위해 JS API의 이름을 정의할 수 있습니다.</p>
<h2>패키지 예시</h2>
<p>flutter_soloud는 C++을 기반으로 개발된 오디오 엔진 및 패키지로, 낮은 지연 시간, 고성능 플레이어를 제공합니다. 소스 코드에서 재생 기능을 실행하고자 할 때, player.cpp의 play 함수로 시작하여 최종적으로 Dart 측에서는 소리 작업의 ID를 얻기 위해 soloud.play()를 실행합니다.</p>
<p>사용자 정의 SoundHandle은 가독성과 성능을 보장하기 위해 ID를 래핑합니다.</p>
<pre><code class="hljs language-dart"><span class="hljs-keyword">final</span> soloud = SoLoud.instance;
<span class="hljs-keyword">await</span> soloud.init();
<span class="hljs-keyword">final</span> source = <span class="hljs-keyword">await</span> soloud.loadAsset(<span class="hljs-string">'path/to/asset.mp3'</span>);

SoundHandle soundHandle = <span class="hljs-keyword">await</span> soloud.play(source); <span class="hljs-comment">// id(int)</span>

<span class="hljs-keyword">await</span> soloud.stop(soundHandle);
<span class="hljs-keyword">await</span> soloud.disposeSource(soundHandle);
</code></pre>
<p>전체 API 작업 프로세스를 간단히 살펴보겠습니다:</p>
<ul>
<li>player.cpp의 play()를 사용하여 오디오 핸들을 얻습니다.</li>
</ul>
<p><img src="/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_3.png" alt="Extension Types in Dart"></p>
<ol start="2">
<li>양쪽 간의 통신을 처리하기 위해 bindings_player_ffi.dart를 사용하여 얻은 핸들 ID를 SoundHandle으로 래핑합니다.</li>
</ol>
<p><img src="/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_4.png" alt="image"></p>
<ol start="3">
<li>Flutter 쪽에서는 soloud.dart를 사용하여 play()를 호출한 후 Record 유형의 결과를 반환합니다. 해당 newHandle을 추출하여 필요한 ID인 ID를 얻을 수 있습니다.</li>
</ol>
<p><img src="/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_5.png" alt="image"></p>
<ol start="4">
<li>Dart 쪽에서는 음향 컨트롤 작업을 위해 의미 있는 확장 유형인 SoundHandle을 사용하여 id가 랩핑됩니다.</li>
</ol>
<p><img src="/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_6.png" alt="이미지"></p>
<h1>고급 사용법</h1>
<p>팩토리 생성자: 다른 유형의 확장이 Representation 유형에 적용될 수 있습니다. 이를 통해 연산을 여러 확장 유형에 재사용할 수 있습니다 (다중 상속과 유사).</p>
<pre><code class="hljs language-js">extension type <span class="hljs-title class_">Number</span>(int i) {
  <span class="hljs-keyword">const</span> factory <span class="hljs-title class_">Number</span>.<span class="hljs-title function_">zero</span>() = <span class="hljs-title class_">Number2</span>;
}

extension type <span class="hljs-title class_">Number2</span>(int i) implements <span class="hljs-title class_">Number</span> { 
  <span class="hljs-keyword">const</span> <span class="hljs-title class_">Number2</span>(int value) : <span class="hljs-title function_">this</span>(<span class="hljs-attr">i</span>: value);
}
</code></pre>
<h1>기억해주세요</h1>
<p>확장 유형(Extension Type)은 컴파일 시간에 래핑 동작입니다. 런타임에는 존재하지 않습니다. 런타임에서는 어떤 유형의 쿼리나 작업이라도 표현 유형(Representation Type)에 적용됩니다. 이로 인해 확장 유형은 안전하지 않은 추상화이며 원래 표현 유형을 항상 찾을 수 있고 런타임에서 기본 객체에 액세스할 수 있습니다.</p>
<pre><code class="hljs language-js">extension type <span class="hljs-title class_">Id</span>(int value) {}

<span class="hljs-keyword">void</span> <span class="hljs-title function_">idToInt</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">var</span> id = <span class="hljs-title class_">Id</span>(<span class="hljs-number">1</span>);

  <span class="hljs-comment">// 'id'의 런타임 유형은 표현 유형 'int'.</span>
  <span class="hljs-keyword">if</span> (id is int) <span class="hljs-title function_">print</span>(id.<span class="hljs-property">value</span>); <span class="hljs-comment">// 1</span>

  <span class="hljs-comment">// 런타임에서 'id'에 'int' 메서드 사용 가능.</span>
  <span class="hljs-keyword">if</span> (id <span class="hljs-keyword">case</span> int x) <span class="hljs-title function_">print</span>(x.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// 1</span>
  <span class="hljs-keyword">switch</span> (id) {
    <span class="hljs-keyword">case</span> <span class="hljs-title function_">int</span>(:final isEven):
      <span class="hljs-title function_">print</span>(<span class="hljs-string">"$id (${isEven ? "</span>짝수<span class="hljs-string">" : "</span>홀수<span class="hljs-string">"})"</span>); <span class="hljs-comment">// 1 (홀수)</span>
  }
}

<span class="hljs-keyword">void</span> <span class="hljs-title function_">intToId</span>(<span class="hljs-params"></span>) {
  int i = <span class="hljs-number">2</span>;

  <span class="hljs-keyword">if</span> (i is <span class="hljs-title class_">Id</span>) <span class="hljs-title function_">print</span>(<span class="hljs-string">"예"</span>); <span class="hljs-comment">// 예</span>

  <span class="hljs-keyword">if</span> (i <span class="hljs-keyword">case</span> <span class="hljs-title class_">Id</span> id) <span class="hljs-title function_">print</span>(<span class="hljs-string">"값: ${id.value}"</span>); <span class="hljs-comment">// 값: 2</span>

  <span class="hljs-keyword">switch</span> (i) {
    <span class="hljs-keyword">case</span> <span class="hljs-title class_">Id</span>(:<span class="hljs-keyword">var</span> value):
      <span class="hljs-title function_">print</span>(<span class="hljs-string">"값: $value"</span>); <span class="hljs-comment">// 값: 2</span>
  }
}
</code></pre>
<h1>요약</h1>
<ul>
<li><strong>확장 유형</strong>은 기존 유형을 제한할 수도 있고, 새로운 기능을 제공할 수도 있습니다.</li>
<li><strong>확장 유형</strong>의 본질을 이해하는 것이 중요합니다. 이들은 컴파일 시에만 존재하며 런타임에서는 무시되며 <strong>표현 유형</strong>으로 표시됩니다.</li>
<li><strong>확장 유형</strong>은 특정 상황에서 비용을 절약하고, 특히 상호 운용성 개발에서 성능을 크게 향상시킬 수 있습니다.</li>
</ul>
<h1>확장 유형 비교</h1>
<ul>
<li><strong>확장 메서드</strong>: 기존 유형에 간단한 기능을 추가하는 데 적합합니다.</li>
<li><strong>확장 유형</strong>: 기존 유형을 향상시키고, 복잡한 기능을 구현하며, 다른 프로그래밍 언어와의 상호 운용성을 최적화하는 데 적합합니다.</li>
</ul>
<h1>참고</h1>
<ul>
<li><a href="https://dart.dev/language/extension-types" rel="nofollow" target="_blank">Dart 언어 확장 유형</a></li>
<li><a href="https://dart.dev/interop/js-interop/usage" rel="nofollow" target="_blank">Dart 상호 운용성 및 JS 상호 운용 사용법</a></li>
<li><a href="https://medium.com/dartlang/dart-3-3-325bf2bf6c13" rel="nofollow" target="_blank">Dart 3.3 소개</a></li>
<li><a href="https://ildysilva.medium.com/what-are-flutter-and-dart-extension-types-896eda0a3ddf" rel="nofollow" target="_blank">Dart와 Flutter 확장 유형에 대한 소개</a></li>
<li><a href="https://qiita.com/Cat_sushi/items/987e7eee469793369ef8" rel="nofollow" target="_blank">Dart 언어에 대한 유용한 기능과 팁</a></li>
<li><a href="https://qiita.com/Cat_sushi/items/87742dc3a886dd984f46" rel="nofollow" target="_blank">Flutter와 Dart의 개요</a></li>
<li><a href="https://www.youtube.com/watch?v=YHsi1Gfz5UU&#x26;ab_channel=imaNNeO" rel="nofollow" target="_blank">imaNNeO 유튜브 채널</a></li>
<li><a href="https://www.youtube.com/watch?v=SyFNB81p-OY&#x26;t=3276s&#x26;ab_channel=FlutterUruguay" rel="nofollow" target="_blank">FlutterUruguay 유튜브 채널</a></li>
<li><a href="https://www.youtube.com/watch?v=2TJIOpBDMnU&#x26;ab_channel=Prof.DiegoAntunes" rel="nofollow" target="_blank">Prof.DiegoAntunes 유튜브 채널</a></li>
</ul>
<h1>다른 글들</h1>
<ul>
<li>2024년 4월 'Flutter Monthly' 😍</li>
<li>2024년 3월 'Flutter Monthly' 😍</li>
<li>2024년 2월 'Flutter Monthly' 😍</li>
<li>Flutter 3.19 및 Dart 3.3 업데이트 포인트!</li>
<li>2024년 1월 'Flutter Monthly' 😍</li>
<li>개발 기술 향상을 위한 Dart 3 사용하기. 더 많은 예제와 팁.</li>
<li>2023년 12월 'Flutter Monthly' 😍</li>
<li>2023년 11월 'Flutter Monthly' 😍</li>
<li>Dart 3를 숙지해서 삶을 쉽게 만들기!</li>
<li>Flutter 3.16 및 Dart 3.2 요약!</li>
<li>2023년 10월 'Flutter Monthly' 😍</li>
<li>2023년 9월 'Flutter Monthly' 😍</li>
<li>2023년 8월 'Flutter Monthly' 😍</li>
<li>2023년 7월 'Flutter Monthly' 😍</li>
</ul>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Dart에서 Extension Types으로 할 수 있는 것들","description":"","date":"2024-06-22 00:40","slug":"2024-06-22-WhatcanIdowithExtensionTypesinDart","content":"\n\nDart 3.3 확장 타입\n\n![Image](/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_0.png)\n\n공식 문서는 다음과 같이 시작합니다:\n\n확장 타입은 강력한 타입 래퍼로 작용하는 컴파일 시간 추상화입니다. 성능 최적화를 위해 도입되었으며 네이티브 코드와의 향상된 상호작용을 제공합니다. Zero-cost 래퍼로서, 다른 언어와 통신할 때 Wrapper 클래스와 Helper 클래스와 관련된 전형적인 메모리 비용을 제거합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일반 클래스 래퍼는 런타임에서 작동하며 항상 클래스 및 객체 사용량의 오버헤드가 발생하여 메모리 사용량과 GC(Garbage Collection) 비용이 증가합니다. 단기간에 많은 래퍼 인스턴스가 생성되는 시나리오에서는 이 부담이 상당해집니다.\n\n확장 유형은 특정 유형의 확장으로 컴파일 시간에 확인되므로 런타임에서는 원래 표현 유형으로 되돌아가며 추상화가 사라집니다. 따라서 확장 유형을 사용하면 응용 프로그램에 비용이 발생하지 않아 매우 효율적인 개발 방법이 됩니다.\n확장 유형은 정적 JavaScript 상호 운용을 가능하게 하며, 기존 JavaScript 유형과의 원활한 상호 작용을 허용합니다.\n\n# 혜택\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 유연한 제한과 확장\n\n기존 유형(예: int 또는 String)을 속성, 함수 및 다른 API를 추가하여 향상시킬 수 있습니다.\n\n## 더 명확한 추상화\n\n기본 표현 유형의 복잡성을 숨겨 의미 있는 확장을 가능하게 하여 코드 가독성과 유지 관리성을 향상시킵니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 편리하고 안전한 상호 운용성\n\nDart 사용자 정의 유형은 기본 유형에 액세스하는 것만큼 간단하여 유형 안전성을 제공합니다. 이는 네이티브 플랫폼 및 다른 언어와의 상호 운용성에 특히 유용하며, 프로세스를 간소화합니다.\n\n## 향상된 성능\n\n각 서비스마다 Wrapper 클래스를 생성하지 않아 추가 메모리 오버헤드가 발생하지 않습니다. 특히 대량 데이터 집합이나 빈번한 객체 작업을 처리할 때 성능에 민감한 시나리오에 이상적입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 개발\n\n확장 형식은 선언될 때 기본 생성자가 자동으로 포함됩니다.\n\n```js\nextension type MyId(int id) {}\n\nvoid main(List\u003cString\u003e arguments) {\n  final id = MyId(1);\n  \n  print(id); // 1 \n  print(id.runtimeType); // int\n}\n```\n\n어떤 경우에도 확장 형식에 의해 래핑된 형식은 \"표현 형식\"으로 불리며 서브타입이 아닙니다. 따라서 일반적으로 표현 형식과 사용자 정의 확장 형식은 서로 값 할당이 불가능합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사용자 정의된 새로운 속성과 함수 인터페이스가 없을 때에는 기능적인 작업이 없습니다. int의 원래 동작이 제한됩니다.\n\n![extension types in Dart](/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_1.png)\n\n기존 유형에 대해서는 더 많은 확장이나 유형의 제약 사항에 대해 노출되는 것이 아닌 사용 가능한 API만 노출되며, 그렇게 함으로써 일부 허용되지 않는 작업을 피할 수 있습니다. 우리가 필요로 하는 의미 있는 함수를 추가할 수 있습니다.\n\n```dart\nextension type MyId(int id) {\n  operator \u003e(MyId other) =\u003e id \u003e other.id;\n  \n  bool isBiggerThan(MyId other) =\u003e id \u003e other.id;\n}\n\nvoid main(List\u003cString\u003e arguments) {\n  MyId safeId = MyId(200);\n  safeId + 10; // Compile error: No '+' operator.\n  safeId - 10; // Compile error: No '-' operator.\n  safeId \u003e 10; // Compile error: Wrong type.\n  safeId \u003e MyId(300); // ✅\n\n  int number = 100;\n  number = safeId; // Compile error: Wrong type.\n  number = safeId as int; // ✅ Cast to representation type.\n  safeId = number as MyId; // ✅ Cast to extension type.\n\n  print(safeId.isBiggerThan(MyId(300))); // false\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n서비스나 네이티브 API와 상호 작용 후 반환된 값은 int를 사용하여 가독성을 높일 수 있어요. 확장 유형을 통해 특정 이름을 지정할 수 있어요. 이렇게 하면 한눈에 이해하기 쉬워져요.\n\n확장 유형과 표현 유형은 as 캐스팅을 사용하여 직접 변환할 수 있어요. 재미있는 점은 상속 관계가 아님에도 불구하고 강제로 변환할 수도 있어요.\n\n```js\ni = id as int; // ✅\ni = -1;\nid = i as Id;  // ✅\n```\n\n다트 클래스처럼 확장 유형을 일반적으로 처리하고 인스턴스화하고 사용자 정의 함수를 호출할 수 있는 예제가 있어요. 다트는 이를 일반 int로 컴파일해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\nextension type Wrapper(int i) {\n  void showValue() {\n    print('my value is $i');\n  }\n}\n\nvoid main() {\n  final wrapper = Wrapper(42);\n  wrapper.showValue(); // Prints 'my value is 42'\n}\n```\n\n공식 설명에 따르면 익스텐션 타입은 네이티브 코드와의 상호 운용성을 위해 유용하며, 간접 비용을 발생시키지 않고 네이티브 타입을 직접 사용할 수 있으면서도 깔끔한 Dart API를 제공합니다.\n\n# 제네릭\n\n익스텐션 타입과 제네릭을 함께 사용하기:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\nextension type MyList\u003cT\u003e(List\u003cT\u003e elements) {\n void add(T value) =\u003e elements.add(value);\n}\n\nvoid main(List\u003cString\u003e arguments) {\n  MyList list = MyList\u003cint\u003e([1, 2]);\n  list.add(3);\n\n  final normalList = list as List\u003cint\u003e;\n  print(list); // [1, 2, 3]\n  print(normalList); // [1, 2, 3]\n}\n```\n\n# 생성자\n\nExtension 타입은 여러 개의 생성자를 가질 수 있습니다:\n\n- 일반 생성자\n- 명명된 생성자\n- private 생성자 문법을 사용한 숨겨진 생성자\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\nextension type Password._(String value) {\n  Password(this.value) {\n    assert(value.length \u003e= 8);\n    \n    if (value.length \u003c 8) {\n      throw Exception('Password must be at least 8 characters long');\n    }\n  }\n\n  Password.random() : value = _generateRandomPassword();\n\n  static String _generateRandomPassword() =\u003e ...;\n\n  bool get isValid =\u003e value.length \u003e= 8;\n}\n\nvoid main(List\u003cString\u003e arguments) {\n  // 암시적 명명되지 않은 생성자.\n  Password password = Password('abcdefghijklmnopqrstuvwxyz'); // ✅\n\n  // 명명된 생성자.\n  password = Password.random(); // ✅\n  password = Password('hello12'); // Exception: Password must be at least 8 characters long\n  password = 'hello' as Password; // ✅\n}\n```\n\n기억하세요, 암시적 주 생성자에서는 assert() 체크나 다른 작업을 사용할 수 없습니다. 기본 생성자를 재정의하고 assert 체크를 추가하세요. 기본 생성자를 내부적으로(private) 만드세요.\n```dart\nextension type Password._(String value) {\n\n  Password(this.value) {\n    assert(value.length \u003e= 8);\n    \n    if (value.length \u003c 8) {\n      throw Exception('Password must be at least 8 characters long');\n    }\n  }\n  \n}\n```\n\n# 안전한 Alias\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nimplements를 사용하면 Extension Types가 기본 유형을 노출하여 Representation 타입의 모든 멤버 및 사용자 지정 도우미 API에 액세스할 수 있습니다. 이는 원래 유형의 기능을 제공하면서도 별칭 및 타입 안전성 확인을 제공합니다.\n\n```js\nextension type Height(double _) implements double {}\nextension type Weight(double _) implements double {}\n\ndouble calculateBmi(Height height, Weight weight) =\u003e weight / ( height * height);\n\nvoid main() {\n  var height = Height(1.75);\n  var weight = Weight(65);\n  var bmi = calculateBmi(height, weight);\n  print(bmi); // 21.22448979591837\n  \n  bmi = calculateBmi(1.64, 54.0);     // ❌ 컴파일 타임 오류\n  bmi = calculateBmi(weight, height); // ❌ 컴파일 타임 오류\n}\n```\n\n기존 타입에 새로운 인터페이스 추가하기:\n\n```js\nextension type MyId(int id) implements int {\n  MyId get value =\u003e this;\n}\n\nvoid main(List\u003cString\u003e arguments) {\n  final safeId = MyId(100);\n  safeId + 1; // 101\n  safeId - 1; // 99\n  safeId * 2; // 200\n  safeId / 2; // 50\n  safeId % 3; // 1\n  safeId.toString(); // '100'\n\n  int normalId = safeId; // 100\n  final safeId2 = safeId + normalId; // 200\n  final safeId3 = 10 + safeId; // 110\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기존의 기능적 동작을 재정의하고 확장 타입의 멤버들은 완전히 부모 타입의 동일한 이름을 가진 멤버들을 대체하여 새 구현 방법을 제공합니다.\n\n```js\n확장 타입 MyId(int id)은 int를 구현합니다 {\n  bool get isEven =\u003e true;\n}\n\nvoid main(List\u003cString\u003e arguments) {\n  final myId = MyId(101);\n  print(myId.isEven); // true\n}\n```\n\n# 다른 시나리오\n\n## 다중 타입 확장\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n보통, 확장 유형은 하나의 유형을 확장합니다. 여러 정보가 있는 경우 Record를 사용할 수 있습니다.\n\n```js\ntypedef UserInfo = ({String email, String password});\n\nextension type User(UserInfo info) {\n  void printInfo() =\u003e print(\"Email: ${info.email}, Password: ${info.password}\");\n}\n\nvoid main(List\u003cString\u003e arguments) {\n  final user = User(\n    (\n      email: 'extension@gmail.com',\n      password: 'types',\n    ),\n  );\n  user.printInfo(); // Email: extension@gmail.com, Password: types\n}\n```\n\n## 테스트용 모의 데이터\n\n테스트에서 Extension Types를 사용하는 것도 가능합니다. Mock 클래스에 따르면 코드를 약간 조정하기만 하면 됩니다. 일반 클래스와의 차이점은 인터페이스를 구현하지 않은 경우 일반 클래스는 컴파일 경고를 표시하지만, Extension Types는 표시하지 않는다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n## JSON 접근\n\nJSON 데이터에 대한 Extension Types 활용.\n\n```js\nfinal userMap = json.decode(r'''\n  {\n    \"name\": {\n      \"first\": \"Yii\",\n      \"last\": \"Chen\"\n    },\n    \"email\": \"ab20803@gmail.com\"\n  }\n'''); // Map\u003cString, dynamic\u003e\n\nextension type User(Map\u003cString, dynamic\u003e _) {\n  Name get name =\u003e _['name'] as Name;\n  String get email =\u003e _['email'] as String;\n}\nextension type Name(Map\u003cString, dynamic\u003e _) {\n  String get first =\u003e _['first'] as String;\n  String get last =\u003e _['last'] as String;\n}\nvoid main() {\n  final person = User(userMap);\n  print(person.name.first);   // Yii\n  print(person.name.last);    // Chen\n  print(person.email);        // ab20803@gmail.com\n  print(person.email.length); // 17\n}\n```\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 상호 운용성\n\n현재 Extension Types은 주로 dart: js_interop 패키지에서 사용되며, 익숙한 구문을 사용하여 JavaScript API에 액세스하고 상호 작용할 수 있도록 합니다. 이 패키지는 JSObject 및 JSAny와 같은 많은 JS 관련 유형을 정의하여 Dart와 네이티브 플랫폼 간의 안전한 통신을 보장합니다. C++와 같은 다른 언어도 이 접근 방식에서 혜택을 볼 수 있습니다.\n\n![image](/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_2.png)\n\nexternal → 이 키워드는 일반적으로 다른 언어에서 사용하는 외부 함수에 액세스할 수 있도록 합니다. 따라서 Dart 상호 운용성 개발에서 자주 볼 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n@JS() → 만약 Dart 측에서 다른 이름을 구현하거나 동일한 JavaScript API를 가리키는 여러 Dart API를 작성하려는 경우, 상호 운용성을 위해 JS API의 이름을 정의할 수 있습니다.\n\n## 패키지 예시\n\nflutter_soloud는 C++을 기반으로 개발된 오디오 엔진 및 패키지로, 낮은 지연 시간, 고성능 플레이어를 제공합니다. 소스 코드에서 재생 기능을 실행하고자 할 때, player.cpp의 play 함수로 시작하여 최종적으로 Dart 측에서는 소리 작업의 ID를 얻기 위해 soloud.play()를 실행합니다.\n\n사용자 정의 SoundHandle은 가독성과 성능을 보장하기 위해 ID를 래핑합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\nfinal soloud = SoLoud.instance;\nawait soloud.init();\nfinal source = await soloud.loadAsset('path/to/asset.mp3');\n\nSoundHandle soundHandle = await soloud.play(source); // id(int)\n\nawait soloud.stop(soundHandle);\nawait soloud.disposeSource(soundHandle);\n```\n\n전체 API 작업 프로세스를 간단히 살펴보겠습니다:\n\n- player.cpp의 play()를 사용하여 오디오 핸들을 얻습니다.\n\n![Extension Types in Dart](/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_3.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 양쪽 간의 통신을 처리하기 위해 bindings_player_ffi.dart를 사용하여 얻은 핸들 ID를 SoundHandle으로 래핑합니다.\n\n![image](/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_4.png)\n\n3. Flutter 쪽에서는 soloud.dart를 사용하여 play()를 호출한 후 Record 유형의 결과를 반환합니다. 해당 newHandle을 추출하여 필요한 ID인 ID를 얻을 수 있습니다.\n\n![image](/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_5.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n4. Dart 쪽에서는 음향 컨트롤 작업을 위해 의미 있는 확장 유형인 SoundHandle을 사용하여 id가 랩핑됩니다.\n\n![이미지](/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_6.png)\n\n# 고급 사용법\n\n팩토리 생성자: 다른 유형의 확장이 Representation 유형에 적용될 수 있습니다. 이를 통해 연산을 여러 확장 유형에 재사용할 수 있습니다 (다중 상속과 유사).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nextension type Number(int i) {\n  const factory Number.zero() = Number2;\n}\n\nextension type Number2(int i) implements Number { \n  const Number2(int value) : this(i: value);\n}\n```\n\n# 기억해주세요\n\n확장 유형(Extension Type)은 컴파일 시간에 래핑 동작입니다. 런타임에는 존재하지 않습니다. 런타임에서는 어떤 유형의 쿼리나 작업이라도 표현 유형(Representation Type)에 적용됩니다. 이로 인해 확장 유형은 안전하지 않은 추상화이며 원래 표현 유형을 항상 찾을 수 있고 런타임에서 기본 객체에 액세스할 수 있습니다.\n\n```js\nextension type Id(int value) {}\n\nvoid idToInt() {\n  var id = Id(1);\n\n  // 'id'의 런타임 유형은 표현 유형 'int'.\n  if (id is int) print(id.value); // 1\n\n  // 런타임에서 'id'에 'int' 메서드 사용 가능.\n  if (id case int x) print(x.toString()); // 1\n  switch (id) {\n    case int(:final isEven):\n      print(\"$id (${isEven ? \"짝수\" : \"홀수\"})\"); // 1 (홀수)\n  }\n}\n\nvoid intToId() {\n  int i = 2;\n\n  if (i is Id) print(\"예\"); // 예\n\n  if (i case Id id) print(\"값: ${id.value}\"); // 값: 2\n\n  switch (i) {\n    case Id(:var value):\n      print(\"값: $value\"); // 값: 2\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 요약\n\n- **확장 유형**은 기존 유형을 제한할 수도 있고, 새로운 기능을 제공할 수도 있습니다.\n- **확장 유형**의 본질을 이해하는 것이 중요합니다. 이들은 컴파일 시에만 존재하며 런타임에서는 무시되며 **표현 유형**으로 표시됩니다.\n- **확장 유형**은 특정 상황에서 비용을 절약하고, 특히 상호 운용성 개발에서 성능을 크게 향상시킬 수 있습니다.\n\n# 확장 유형 비교\n\n- **확장 메서드**: 기존 유형에 간단한 기능을 추가하는 데 적합합니다.\n- **확장 유형**: 기존 유형을 향상시키고, 복잡한 기능을 구현하며, 다른 프로그래밍 언어와의 상호 운용성을 최적화하는 데 적합합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 참고\n\n- [Dart 언어 확장 유형](https://dart.dev/language/extension-types)\n- [Dart 상호 운용성 및 JS 상호 운용 사용법](https://dart.dev/interop/js-interop/usage)\n- [Dart 3.3 소개](https://medium.com/dartlang/dart-3-3-325bf2bf6c13)\n- [Dart와 Flutter 확장 유형에 대한 소개](https://ildysilva.medium.com/what-are-flutter-and-dart-extension-types-896eda0a3ddf)\n- [Dart 언어에 대한 유용한 기능과 팁](https://qiita.com/Cat_sushi/items/987e7eee469793369ef8)\n- [Flutter와 Dart의 개요](https://qiita.com/Cat_sushi/items/87742dc3a886dd984f46)\n- [imaNNeO 유튜브 채널](https://www.youtube.com/watch?v=YHsi1Gfz5UU\u0026ab_channel=imaNNeO)\n- [FlutterUruguay 유튜브 채널](https://www.youtube.com/watch?v=SyFNB81p-OY\u0026t=3276s\u0026ab_channel=FlutterUruguay)\n- [Prof.DiegoAntunes 유튜브 채널](https://www.youtube.com/watch?v=2TJIOpBDMnU\u0026ab_channel=Prof.DiegoAntunes)\n\n# 다른 글들\n\n- 2024년 4월 'Flutter Monthly' 😍\n- 2024년 3월 'Flutter Monthly' 😍\n- 2024년 2월 'Flutter Monthly' 😍\n- Flutter 3.19 및 Dart 3.3 업데이트 포인트!\n- 2024년 1월 'Flutter Monthly' 😍\n- 개발 기술 향상을 위한 Dart 3 사용하기. 더 많은 예제와 팁.\n- 2023년 12월 'Flutter Monthly' 😍\n- 2023년 11월 'Flutter Monthly' 😍\n- Dart 3를 숙지해서 삶을 쉽게 만들기!\n- Flutter 3.16 및 Dart 3.2 요약!\n- 2023년 10월 'Flutter Monthly' 😍\n- 2023년 9월 'Flutter Monthly' 😍\n- 2023년 8월 'Flutter Monthly' 😍\n- 2023년 7월 'Flutter Monthly' 😍","ogImage":{"url":"/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_0.png"},"coverImage":"/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_0.png","tag":["Tech"],"readingTime":12},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003eDart 3.3 확장 타입\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_0.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003cp\u003e공식 문서는 다음과 같이 시작합니다:\u003c/p\u003e\n\u003cp\u003e확장 타입은 강력한 타입 래퍼로 작용하는 컴파일 시간 추상화입니다. 성능 최적화를 위해 도입되었으며 네이티브 코드와의 향상된 상호작용을 제공합니다. Zero-cost 래퍼로서, 다른 언어와 통신할 때 Wrapper 클래스와 Helper 클래스와 관련된 전형적인 메모리 비용을 제거합니다.\u003c/p\u003e\n\u003cp\u003e일반 클래스 래퍼는 런타임에서 작동하며 항상 클래스 및 객체 사용량의 오버헤드가 발생하여 메모리 사용량과 GC(Garbage Collection) 비용이 증가합니다. 단기간에 많은 래퍼 인스턴스가 생성되는 시나리오에서는 이 부담이 상당해집니다.\u003c/p\u003e\n\u003cp\u003e확장 유형은 특정 유형의 확장으로 컴파일 시간에 확인되므로 런타임에서는 원래 표현 유형으로 되돌아가며 추상화가 사라집니다. 따라서 확장 유형을 사용하면 응용 프로그램에 비용이 발생하지 않아 매우 효율적인 개발 방법이 됩니다.\n확장 유형은 정적 JavaScript 상호 운용을 가능하게 하며, 기존 JavaScript 유형과의 원활한 상호 작용을 허용합니다.\u003c/p\u003e\n\u003ch1\u003e혜택\u003c/h1\u003e\n\u003ch2\u003e유연한 제한과 확장\u003c/h2\u003e\n\u003cp\u003e기존 유형(예: int 또는 String)을 속성, 함수 및 다른 API를 추가하여 향상시킬 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e더 명확한 추상화\u003c/h2\u003e\n\u003cp\u003e기본 표현 유형의 복잡성을 숨겨 의미 있는 확장을 가능하게 하여 코드 가독성과 유지 관리성을 향상시킵니다.\u003c/p\u003e\n\u003ch2\u003e편리하고 안전한 상호 운용성\u003c/h2\u003e\n\u003cp\u003eDart 사용자 정의 유형은 기본 유형에 액세스하는 것만큼 간단하여 유형 안전성을 제공합니다. 이는 네이티브 플랫폼 및 다른 언어와의 상호 운용성에 특히 유용하며, 프로세스를 간소화합니다.\u003c/p\u003e\n\u003ch2\u003e향상된 성능\u003c/h2\u003e\n\u003cp\u003e각 서비스마다 Wrapper 클래스를 생성하지 않아 추가 메모리 오버헤드가 발생하지 않습니다. 특히 대량 데이터 집합이나 빈번한 객체 작업을 처리할 때 성능에 민감한 시나리오에 이상적입니다.\u003c/p\u003e\n\u003ch1\u003e개발\u003c/h1\u003e\n\u003cp\u003e확장 형식은 선언될 때 기본 생성자가 자동으로 포함됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eextension type \u003cspan class=\"hljs-title class_\"\u003eMyId\u003c/span\u003e(int id) {}\n\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eList\u0026#x3C;\u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e\u003e \u003cspan class=\"hljs-variable language_\"\u003earguments\u003c/span\u003e\u003c/span\u003e) {\n  final id = \u003cspan class=\"hljs-title class_\"\u003eMyId\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n  \n  \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(id); \u003cspan class=\"hljs-comment\"\u003e// 1 \u003c/span\u003e\n  \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(id.\u003cspan class=\"hljs-property\"\u003eruntimeType\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// int\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e어떤 경우에도 확장 형식에 의해 래핑된 형식은 \"표현 형식\"으로 불리며 서브타입이 아닙니다. 따라서 일반적으로 표현 형식과 사용자 정의 확장 형식은 서로 값 할당이 불가능합니다.\u003c/p\u003e\n\u003cp\u003e사용자 정의된 새로운 속성과 함수 인터페이스가 없을 때에는 기능적인 작업이 없습니다. int의 원래 동작이 제한됩니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_1.png\" alt=\"extension types in Dart\"\u003e\u003c/p\u003e\n\u003cp\u003e기존 유형에 대해서는 더 많은 확장이나 유형의 제약 사항에 대해 노출되는 것이 아닌 사용 가능한 API만 노출되며, 그렇게 함으로써 일부 허용되지 않는 작업을 피할 수 있습니다. 우리가 필요로 하는 의미 있는 함수를 추가할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-dart\"\u003e\u003cspan class=\"hljs-keyword\"\u003eextension\u003c/span\u003e type MyId(\u003cspan class=\"hljs-built_in\"\u003eint\u003c/span\u003e id) {\n  \u003cspan class=\"hljs-keyword\"\u003eoperator\u003c/span\u003e \u003e(MyId other) =\u003e id \u003e other.id;\n  \n  \u003cspan class=\"hljs-built_in\"\u003ebool\u003c/span\u003e isBiggerThan(MyId other) =\u003e id \u003e other.id;\n}\n\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e main(\u003cspan class=\"hljs-built_in\"\u003eList\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e\u003e arguments) {\n  MyId safeId = MyId(\u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e);\n  safeId + \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// Compile error: No '+' operator.\u003c/span\u003e\n  safeId - \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// Compile error: No '-' operator.\u003c/span\u003e\n  safeId \u003e \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// Compile error: Wrong type.\u003c/span\u003e\n  safeId \u003e MyId(\u003cspan class=\"hljs-number\"\u003e300\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// ✅\u003c/span\u003e\n\n  \u003cspan class=\"hljs-built_in\"\u003eint\u003c/span\u003e number = \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e;\n  number = safeId; \u003cspan class=\"hljs-comment\"\u003e// Compile error: Wrong type.\u003c/span\u003e\n  number = safeId \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eint\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// ✅ Cast to representation type.\u003c/span\u003e\n  safeId = number \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e MyId; \u003cspan class=\"hljs-comment\"\u003e// ✅ Cast to extension type.\u003c/span\u003e\n\n  \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(safeId.isBiggerThan(MyId(\u003cspan class=\"hljs-number\"\u003e300\u003c/span\u003e))); \u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e서비스나 네이티브 API와 상호 작용 후 반환된 값은 int를 사용하여 가독성을 높일 수 있어요. 확장 유형을 통해 특정 이름을 지정할 수 있어요. 이렇게 하면 한눈에 이해하기 쉬워져요.\u003c/p\u003e\n\u003cp\u003e확장 유형과 표현 유형은 as 캐스팅을 사용하여 직접 변환할 수 있어요. 재미있는 점은 상속 관계가 아님에도 불구하고 강제로 변환할 수도 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ei = id \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e int; \u003cspan class=\"hljs-comment\"\u003e// ✅\u003c/span\u003e\ni = -\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\nid = i \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eId\u003c/span\u003e;  \u003cspan class=\"hljs-comment\"\u003e// ✅\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다트 클래스처럼 확장 유형을 일반적으로 처리하고 인스턴스화하고 사용자 정의 함수를 호출할 수 있는 예제가 있어요. 다트는 이를 일반 int로 컴파일해요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-dart\"\u003e\u003cspan class=\"hljs-keyword\"\u003eextension\u003c/span\u003e type Wrapper(\u003cspan class=\"hljs-built_in\"\u003eint\u003c/span\u003e i) {\n  \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e showValue() {\n    \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'my value is \u003cspan class=\"hljs-subst\"\u003e$i\u003c/span\u003e'\u003c/span\u003e);\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e main() {\n  \u003cspan class=\"hljs-keyword\"\u003efinal\u003c/span\u003e wrapper = Wrapper(\u003cspan class=\"hljs-number\"\u003e42\u003c/span\u003e);\n  wrapper.showValue(); \u003cspan class=\"hljs-comment\"\u003e// Prints 'my value is 42'\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e공식 설명에 따르면 익스텐션 타입은 네이티브 코드와의 상호 운용성을 위해 유용하며, 간접 비용을 발생시키지 않고 네이티브 타입을 직접 사용할 수 있으면서도 깔끔한 Dart API를 제공합니다.\u003c/p\u003e\n\u003ch1\u003e제네릭\u003c/h1\u003e\n\u003cp\u003e익스텐션 타입과 제네릭을 함께 사용하기:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-dart\"\u003e\u003cspan class=\"hljs-keyword\"\u003eextension\u003c/span\u003e type MyList\u0026#x3C;T\u003e(\u003cspan class=\"hljs-built_in\"\u003eList\u003c/span\u003e\u0026#x3C;T\u003e elements) {\n \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e add(T value) =\u003e elements.add(value);\n}\n\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e main(\u003cspan class=\"hljs-built_in\"\u003eList\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e\u003e arguments) {\n  MyList list = MyList\u0026#x3C;\u003cspan class=\"hljs-built_in\"\u003eint\u003c/span\u003e\u003e([\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e]);\n  list.add(\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-keyword\"\u003efinal\u003c/span\u003e normalList = list \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eList\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-built_in\"\u003eint\u003c/span\u003e\u003e;\n  \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(list); \u003cspan class=\"hljs-comment\"\u003e// [1, 2, 3]\u003c/span\u003e\n  \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(normalList); \u003cspan class=\"hljs-comment\"\u003e// [1, 2, 3]\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e생성자\u003c/h1\u003e\n\u003cp\u003eExtension 타입은 여러 개의 생성자를 가질 수 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e일반 생성자\u003c/li\u003e\n\u003cli\u003e명명된 생성자\u003c/li\u003e\n\u003cli\u003eprivate 생성자 문법을 사용한 숨겨진 생성자\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-dart\"\u003e\u003cspan class=\"hljs-keyword\"\u003eextension\u003c/span\u003e type Password._(\u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e value) {\n  Password(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.value) {\n    \u003cspan class=\"hljs-keyword\"\u003eassert\u003c/span\u003e(value.length \u003e= \u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e);\n    \n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (value.length \u0026#x3C; \u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e Exception(\u003cspan class=\"hljs-string\"\u003e'Password must be at least 8 characters long'\u003c/span\u003e);\n    }\n  }\n\n  Password.random() : value = _generateRandomPassword();\n\n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e _generateRandomPassword() =\u003e ...;\n\n  \u003cspan class=\"hljs-built_in\"\u003ebool\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eget\u003c/span\u003e isValid =\u003e value.length \u003e= \u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e;\n}\n\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e main(\u003cspan class=\"hljs-built_in\"\u003eList\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e\u003e arguments) {\n  \u003cspan class=\"hljs-comment\"\u003e// 암시적 명명되지 않은 생성자.\u003c/span\u003e\n  Password password = Password(\u003cspan class=\"hljs-string\"\u003e'abcdefghijklmnopqrstuvwxyz'\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// ✅\u003c/span\u003e\n\n  \u003cspan class=\"hljs-comment\"\u003e// 명명된 생성자.\u003c/span\u003e\n  password = Password.random(); \u003cspan class=\"hljs-comment\"\u003e// ✅\u003c/span\u003e\n  password = Password(\u003cspan class=\"hljs-string\"\u003e'hello12'\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// Exception: Password must be at least 8 characters long\u003c/span\u003e\n  password = \u003cspan class=\"hljs-string\"\u003e'hello'\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e Password; \u003cspan class=\"hljs-comment\"\u003e// ✅\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e기억하세요, 암시적 주 생성자에서는 assert() 체크나 다른 작업을 사용할 수 없습니다. 기본 생성자를 재정의하고 assert 체크를 추가하세요. 기본 생성자를 내부적으로(private) 만드세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-dart\"\u003e\u003cspan class=\"hljs-keyword\"\u003eextension\u003c/span\u003e type Password._(\u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e value) {\n\n  Password(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.value) {\n    \u003cspan class=\"hljs-keyword\"\u003eassert\u003c/span\u003e(value.length \u003e= \u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e);\n    \n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (value.length \u0026#x3C; \u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e Exception(\u003cspan class=\"hljs-string\"\u003e'Password must be at least 8 characters long'\u003c/span\u003e);\n    }\n  }\n  \n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e안전한 Alias\u003c/h1\u003e\n\u003cp\u003eimplements를 사용하면 Extension Types가 기본 유형을 노출하여 Representation 타입의 모든 멤버 및 사용자 지정 도우미 API에 액세스할 수 있습니다. 이는 원래 유형의 기능을 제공하면서도 별칭 및 타입 안전성 확인을 제공합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eextension type \u003cspan class=\"hljs-title class_\"\u003eHeight\u003c/span\u003e(double _) implements double {}\nextension type \u003cspan class=\"hljs-title class_\"\u003eWeight\u003c/span\u003e(double _) implements double {}\n\ndouble \u003cspan class=\"hljs-title function_\"\u003ecalculateBmi\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eHeight\u003c/span\u003e height, \u003cspan class=\"hljs-title class_\"\u003eWeight\u003c/span\u003e weight) =\u003e weight / ( height * height);\n\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e height = \u003cspan class=\"hljs-title class_\"\u003eHeight\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1.75\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e weight = \u003cspan class=\"hljs-title class_\"\u003eWeight\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e65\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e bmi = \u003cspan class=\"hljs-title function_\"\u003ecalculateBmi\u003c/span\u003e(height, weight);\n  \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(bmi); \u003cspan class=\"hljs-comment\"\u003e// 21.22448979591837\u003c/span\u003e\n  \n  bmi = \u003cspan class=\"hljs-title function_\"\u003ecalculateBmi\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1.64\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e54.0\u003c/span\u003e);     \u003cspan class=\"hljs-comment\"\u003e// ❌ 컴파일 타임 오류\u003c/span\u003e\n  bmi = \u003cspan class=\"hljs-title function_\"\u003ecalculateBmi\u003c/span\u003e(weight, height); \u003cspan class=\"hljs-comment\"\u003e// ❌ 컴파일 타임 오류\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e기존 타입에 새로운 인터페이스 추가하기:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eextension type \u003cspan class=\"hljs-title class_\"\u003eMyId\u003c/span\u003e(int id) implements int {\n  \u003cspan class=\"hljs-title class_\"\u003eMyId\u003c/span\u003e get value =\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e;\n}\n\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eList\u0026#x3C;\u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e\u003e \u003cspan class=\"hljs-variable language_\"\u003earguments\u003c/span\u003e\u003c/span\u003e) {\n  final safeId = \u003cspan class=\"hljs-title class_\"\u003eMyId\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e);\n  safeId + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 101\u003c/span\u003e\n  safeId - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 99\u003c/span\u003e\n  safeId * \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 200\u003c/span\u003e\n  safeId / \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 50\u003c/span\u003e\n  safeId % \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 1\u003c/span\u003e\n  safeId.\u003cspan class=\"hljs-title function_\"\u003etoString\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// '100'\u003c/span\u003e\n\n  int normalId = safeId; \u003cspan class=\"hljs-comment\"\u003e// 100\u003c/span\u003e\n  final safeId2 = safeId + normalId; \u003cspan class=\"hljs-comment\"\u003e// 200\u003c/span\u003e\n  final safeId3 = \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e + safeId; \u003cspan class=\"hljs-comment\"\u003e// 110\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e기존의 기능적 동작을 재정의하고 확장 타입의 멤버들은 완전히 부모 타입의 동일한 이름을 가진 멤버들을 대체하여 새 구현 방법을 제공합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e확장 타입 \u003cspan class=\"hljs-title class_\"\u003eMyId\u003c/span\u003e(int id)은 int를 구현합니다 {\n  bool get isEven =\u003e \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n}\n\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eList\u0026#x3C;\u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e\u003e \u003cspan class=\"hljs-variable language_\"\u003earguments\u003c/span\u003e\u003c/span\u003e) {\n  final myId = \u003cspan class=\"hljs-title class_\"\u003eMyId\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e101\u003c/span\u003e);\n  \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(myId.\u003cspan class=\"hljs-property\"\u003eisEven\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e다른 시나리오\u003c/h1\u003e\n\u003ch2\u003e다중 타입 확장\u003c/h2\u003e\n\u003cp\u003e보통, 확장 유형은 하나의 유형을 확장합니다. 여러 정보가 있는 경우 Record를 사용할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003etypedef \u003cspan class=\"hljs-title class_\"\u003eUserInfo\u003c/span\u003e = ({\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e email, \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e password});\n\nextension type \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eUserInfo\u003c/span\u003e info) {\n  \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eprintInfo\u003c/span\u003e() =\u003e \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Email: ${info.email}, Password: ${info.password}\"\u003c/span\u003e);\n}\n\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eList\u0026#x3C;\u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e\u003e \u003cspan class=\"hljs-variable language_\"\u003earguments\u003c/span\u003e\u003c/span\u003e) {\n  final user = \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e(\n    (\n      \u003cspan class=\"hljs-attr\"\u003eemail\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'extension@gmail.com'\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003epassword\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'types'\u003c/span\u003e,\n    ),\n  );\n  user.\u003cspan class=\"hljs-title function_\"\u003eprintInfo\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// Email: extension@gmail.com, Password: types\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e테스트용 모의 데이터\u003c/h2\u003e\n\u003cp\u003e테스트에서 Extension Types를 사용하는 것도 가능합니다. Mock 클래스에 따르면 코드를 약간 조정하기만 하면 됩니다. 일반 클래스와의 차이점은 인터페이스를 구현하지 않은 경우 일반 클래스는 컴파일 경고를 표시하지만, Extension Types는 표시하지 않는다.\u003c/p\u003e\n\u003ch2\u003eJSON 접근\u003c/h2\u003e\n\u003cp\u003eJSON 데이터에 대한 Extension Types 활용.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efinal userMap = json.\u003cspan class=\"hljs-title function_\"\u003edecode\u003c/span\u003e(r\u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e'\n  {\n    \"name\": {\n      \"first\": \"Yii\",\n      \"last\": \"Chen\"\n    },\n    \"email\": \"ab20803@gmail.com\"\n  }\n'\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// Map\u0026#x3C;String, dynamic\u003e\u003c/span\u003e\n\nextension type \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eMap\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e, dynamic\u003e _) {\n  \u003cspan class=\"hljs-title class_\"\u003eName\u003c/span\u003e get name =\u003e _[\u003cspan class=\"hljs-string\"\u003e'name'\u003c/span\u003e] \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eName\u003c/span\u003e;\n  \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e get email =\u003e _[\u003cspan class=\"hljs-string\"\u003e'email'\u003c/span\u003e] \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e;\n}\nextension type \u003cspan class=\"hljs-title class_\"\u003eName\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eMap\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e, dynamic\u003e _) {\n  \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e get first =\u003e _[\u003cspan class=\"hljs-string\"\u003e'first'\u003c/span\u003e] \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e;\n  \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e get last =\u003e _[\u003cspan class=\"hljs-string\"\u003e'last'\u003c/span\u003e] \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e;\n}\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  final person = \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e(userMap);\n  \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(person.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003efirst\u003c/span\u003e);   \u003cspan class=\"hljs-comment\"\u003e// Yii\u003c/span\u003e\n  \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(person.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003elast\u003c/span\u003e);    \u003cspan class=\"hljs-comment\"\u003e// Chen\u003c/span\u003e\n  \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(person.\u003cspan class=\"hljs-property\"\u003eemail\u003c/span\u003e);        \u003cspan class=\"hljs-comment\"\u003e// ab20803@gmail.com\u003c/span\u003e\n  \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(person.\u003cspan class=\"hljs-property\"\u003eemail\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 17\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e상호 운용성\u003c/h1\u003e\n\u003cp\u003e현재 Extension Types은 주로 dart: js_interop 패키지에서 사용되며, 익숙한 구문을 사용하여 JavaScript API에 액세스하고 상호 작용할 수 있도록 합니다. 이 패키지는 JSObject 및 JSAny와 같은 많은 JS 관련 유형을 정의하여 Dart와 네이티브 플랫폼 간의 안전한 통신을 보장합니다. C++와 같은 다른 언어도 이 접근 방식에서 혜택을 볼 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_2.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003eexternal → 이 키워드는 일반적으로 다른 언어에서 사용하는 외부 함수에 액세스할 수 있도록 합니다. 따라서 Dart 상호 운용성 개발에서 자주 볼 수 있습니다.\u003c/p\u003e\n\u003cp\u003e@JS() → 만약 Dart 측에서 다른 이름을 구현하거나 동일한 JavaScript API를 가리키는 여러 Dart API를 작성하려는 경우, 상호 운용성을 위해 JS API의 이름을 정의할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e패키지 예시\u003c/h2\u003e\n\u003cp\u003eflutter_soloud는 C++을 기반으로 개발된 오디오 엔진 및 패키지로, 낮은 지연 시간, 고성능 플레이어를 제공합니다. 소스 코드에서 재생 기능을 실행하고자 할 때, player.cpp의 play 함수로 시작하여 최종적으로 Dart 측에서는 소리 작업의 ID를 얻기 위해 soloud.play()를 실행합니다.\u003c/p\u003e\n\u003cp\u003e사용자 정의 SoundHandle은 가독성과 성능을 보장하기 위해 ID를 래핑합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-dart\"\u003e\u003cspan class=\"hljs-keyword\"\u003efinal\u003c/span\u003e soloud = SoLoud.instance;\n\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e soloud.init();\n\u003cspan class=\"hljs-keyword\"\u003efinal\u003c/span\u003e source = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e soloud.loadAsset(\u003cspan class=\"hljs-string\"\u003e'path/to/asset.mp3'\u003c/span\u003e);\n\nSoundHandle soundHandle = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e soloud.play(source); \u003cspan class=\"hljs-comment\"\u003e// id(int)\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e soloud.stop(soundHandle);\n\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e soloud.disposeSource(soundHandle);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e전체 API 작업 프로세스를 간단히 살펴보겠습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eplayer.cpp의 play()를 사용하여 오디오 핸들을 얻습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_3.png\" alt=\"Extension Types in Dart\"\u003e\u003c/p\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e양쪽 간의 통신을 처리하기 위해 bindings_player_ffi.dart를 사용하여 얻은 핸들 ID를 SoundHandle으로 래핑합니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_4.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003eFlutter 쪽에서는 soloud.dart를 사용하여 play()를 호출한 후 Record 유형의 결과를 반환합니다. 해당 newHandle을 추출하여 필요한 ID인 ID를 얻을 수 있습니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_5.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003eDart 쪽에서는 음향 컨트롤 작업을 위해 의미 있는 확장 유형인 SoundHandle을 사용하여 id가 랩핑됩니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_6.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch1\u003e고급 사용법\u003c/h1\u003e\n\u003cp\u003e팩토리 생성자: 다른 유형의 확장이 Representation 유형에 적용될 수 있습니다. 이를 통해 연산을 여러 확장 유형에 재사용할 수 있습니다 (다중 상속과 유사).\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eextension type \u003cspan class=\"hljs-title class_\"\u003eNumber\u003c/span\u003e(int i) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e factory \u003cspan class=\"hljs-title class_\"\u003eNumber\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ezero\u003c/span\u003e() = \u003cspan class=\"hljs-title class_\"\u003eNumber2\u003c/span\u003e;\n}\n\nextension type \u003cspan class=\"hljs-title class_\"\u003eNumber2\u003c/span\u003e(int i) implements \u003cspan class=\"hljs-title class_\"\u003eNumber\u003c/span\u003e { \n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNumber2\u003c/span\u003e(int value) : \u003cspan class=\"hljs-title function_\"\u003ethis\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ei\u003c/span\u003e: value);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e기억해주세요\u003c/h1\u003e\n\u003cp\u003e확장 유형(Extension Type)은 컴파일 시간에 래핑 동작입니다. 런타임에는 존재하지 않습니다. 런타임에서는 어떤 유형의 쿼리나 작업이라도 표현 유형(Representation Type)에 적용됩니다. 이로 인해 확장 유형은 안전하지 않은 추상화이며 원래 표현 유형을 항상 찾을 수 있고 런타임에서 기본 객체에 액세스할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eextension type \u003cspan class=\"hljs-title class_\"\u003eId\u003c/span\u003e(int value) {}\n\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eidToInt\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e id = \u003cspan class=\"hljs-title class_\"\u003eId\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-comment\"\u003e// 'id'의 런타임 유형은 표현 유형 'int'.\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (id is int) \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(id.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 1\u003c/span\u003e\n\n  \u003cspan class=\"hljs-comment\"\u003e// 런타임에서 'id'에 'int' 메서드 사용 가능.\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (id \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e int x) \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(x.\u003cspan class=\"hljs-title function_\"\u003etoString\u003c/span\u003e()); \u003cspan class=\"hljs-comment\"\u003e// 1\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e (id) {\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eint\u003c/span\u003e(:final isEven):\n      \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"$id (${isEven ? \"\u003c/span\u003e짝수\u003cspan class=\"hljs-string\"\u003e\" : \"\u003c/span\u003e홀수\u003cspan class=\"hljs-string\"\u003e\"})\"\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 1 (홀수)\u003c/span\u003e\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eintToId\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  int i = \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (i is \u003cspan class=\"hljs-title class_\"\u003eId\u003c/span\u003e) \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"예\"\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 예\u003c/span\u003e\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (i \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eId\u003c/span\u003e id) \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"값: ${id.value}\"\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 값: 2\u003c/span\u003e\n\n  \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e (i) {\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eId\u003c/span\u003e(:\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e value):\n      \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"값: $value\"\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 값: 2\u003c/span\u003e\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e요약\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e확장 유형\u003c/strong\u003e은 기존 유형을 제한할 수도 있고, 새로운 기능을 제공할 수도 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e확장 유형\u003c/strong\u003e의 본질을 이해하는 것이 중요합니다. 이들은 컴파일 시에만 존재하며 런타임에서는 무시되며 \u003cstrong\u003e표현 유형\u003c/strong\u003e으로 표시됩니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e확장 유형\u003c/strong\u003e은 특정 상황에서 비용을 절약하고, 특히 상호 운용성 개발에서 성능을 크게 향상시킬 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e확장 유형 비교\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e확장 메서드\u003c/strong\u003e: 기존 유형에 간단한 기능을 추가하는 데 적합합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e확장 유형\u003c/strong\u003e: 기존 유형을 향상시키고, 복잡한 기능을 구현하며, 다른 프로그래밍 언어와의 상호 운용성을 최적화하는 데 적합합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e참고\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://dart.dev/language/extension-types\" rel=\"nofollow\" target=\"_blank\"\u003eDart 언어 확장 유형\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dart.dev/interop/js-interop/usage\" rel=\"nofollow\" target=\"_blank\"\u003eDart 상호 운용성 및 JS 상호 운용 사용법\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://medium.com/dartlang/dart-3-3-325bf2bf6c13\" rel=\"nofollow\" target=\"_blank\"\u003eDart 3.3 소개\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://ildysilva.medium.com/what-are-flutter-and-dart-extension-types-896eda0a3ddf\" rel=\"nofollow\" target=\"_blank\"\u003eDart와 Flutter 확장 유형에 대한 소개\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://qiita.com/Cat_sushi/items/987e7eee469793369ef8\" rel=\"nofollow\" target=\"_blank\"\u003eDart 언어에 대한 유용한 기능과 팁\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://qiita.com/Cat_sushi/items/87742dc3a886dd984f46\" rel=\"nofollow\" target=\"_blank\"\u003eFlutter와 Dart의 개요\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=YHsi1Gfz5UU\u0026#x26;ab_channel=imaNNeO\" rel=\"nofollow\" target=\"_blank\"\u003eimaNNeO 유튜브 채널\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=SyFNB81p-OY\u0026#x26;t=3276s\u0026#x26;ab_channel=FlutterUruguay\" rel=\"nofollow\" target=\"_blank\"\u003eFlutterUruguay 유튜브 채널\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=2TJIOpBDMnU\u0026#x26;ab_channel=Prof.DiegoAntunes\" rel=\"nofollow\" target=\"_blank\"\u003eProf.DiegoAntunes 유튜브 채널\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e다른 글들\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e2024년 4월 'Flutter Monthly' 😍\u003c/li\u003e\n\u003cli\u003e2024년 3월 'Flutter Monthly' 😍\u003c/li\u003e\n\u003cli\u003e2024년 2월 'Flutter Monthly' 😍\u003c/li\u003e\n\u003cli\u003eFlutter 3.19 및 Dart 3.3 업데이트 포인트!\u003c/li\u003e\n\u003cli\u003e2024년 1월 'Flutter Monthly' 😍\u003c/li\u003e\n\u003cli\u003e개발 기술 향상을 위한 Dart 3 사용하기. 더 많은 예제와 팁.\u003c/li\u003e\n\u003cli\u003e2023년 12월 'Flutter Monthly' 😍\u003c/li\u003e\n\u003cli\u003e2023년 11월 'Flutter Monthly' 😍\u003c/li\u003e\n\u003cli\u003eDart 3를 숙지해서 삶을 쉽게 만들기!\u003c/li\u003e\n\u003cli\u003eFlutter 3.16 및 Dart 3.2 요약!\u003c/li\u003e\n\u003cli\u003e2023년 10월 'Flutter Monthly' 😍\u003c/li\u003e\n\u003cli\u003e2023년 9월 'Flutter Monthly' 😍\u003c/li\u003e\n\u003cli\u003e2023년 8월 'Flutter Monthly' 😍\u003c/li\u003e\n\u003cli\u003e2023년 7월 'Flutter Monthly' 😍\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-22-WhatcanIdowithExtensionTypesinDart"},"buildId":"AAcWCMtAYBsqiURBkbPEc","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>