<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>자바스크립트 실행 컨텍스트 심층 탐구 | uidev-css</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://uidev-css.github.io///post/2024-06-23-In-DepthExplorationofJavaScriptExecutionContext" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="자바스크립트 실행 컨텍스트 심층 탐구 | uidev-css" data-gatsby-head="true"/><meta property="og:title" content="자바스크립트 실행 컨텍스트 심층 탐구 | uidev-css" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-23-In-DepthExplorationofJavaScriptExecutionContext_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://uidev-css.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://uidev-css.github.io///post/2024-06-23-In-DepthExplorationofJavaScriptExecutionContext" data-gatsby-head="true"/><meta name="twitter:title" content="자바스크립트 실행 컨텍스트 심층 탐구 | uidev-css" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-23-In-DepthExplorationofJavaScriptExecutionContext_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | uidev-css" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-23 15:14" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b4eed7811784bdd3.js" defer=""></script><script src="/_next/static/5et5eMZxpKCgDAAyIS6Ju/_buildManifest.js" defer=""></script><script src="/_next/static/5et5eMZxpKCgDAAyIS6Ju/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UIDEV CSS</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">자바스크립트 실행 컨텍스트 심층 탐구</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="자바스크립트 실행 컨텍스트 심층 탐구" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UIDEV CSS</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 23, 2024</span><span class="posts_reading_time__f7YPP">8<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-23-In-DepthExplorationofJavaScriptExecutionContext&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>자바스크립트 초심자든 전문가든, 면접이건 일상적인 개발 작업이건, 우리는 종종 다음과 같은 상황을 맞닥뜨립니다: 몇 줄의 코드가 주어졌을 때, 그들이 무엇을 출력하며 어떤 순서로 실행되는지 알아야 합니다. 🧑‍💻 자바스크립트는 싱글 스레드 언어이기 때문에 우리는 다음 결론을 내릴 수 있습니다:</p>
<p>자바스크립트는 문장을 나타난 순서대로 실행합니다. 📜</p>
<p>이 시점에서, "나는 JS가 한 줄씩 실행된다는 것을 알아, 왜 강조하는 거지?"라고 하실 수 있습니다. 🤔 우리는 JS가 한 줄씩 실행된다고 가정하기 때문에 이런 식으로 모든 JS가 동작한다고 가정합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> a = <span class="hljs-string">'1'</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);

<span class="hljs-keyword">let</span> b = <span class="hljs-string">'2'</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b);
</code></pre>
<div class="content-ad"></div>
<p>하지만 실제로 JavaScript는 다음과 같이 실행됩니다:</p>
<pre><code class="hljs language-js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Timer started'</span>)
});
<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>){
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'For loop is about to be executed'</span>);
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &#x3C; <span class="hljs-number">10000</span>; i++){
    i == <span class="hljs-number">99</span> &#x26;&#x26; <span class="hljs-title function_">resolve</span>();
  }
}).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Execute then function'</span>)
});
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Code execution ends'</span>);
</code></pre>
<p>JavaScript가 문장을 순서대로 실행한다는 개념을 따라, 예상 출력을 자신 있게 적었습니다:</p>
<ol>
<li>타이머 시작. ⏱️</li>
<li>for 루프가 실행됩니다. 🔄</li>
<li>then 함수를 실행합니다. ➡️</li>
<li>코드 실행 종료. 🛑</li>
</ol>
<div class="content-ad"></div>
<p>그러나 Chrome에서 확인했을 때 결과가 완전히 잘못되어 순간적으로 혼란스러웠어요. 😕 예상대로 줄 단위로 실행되어야 하는 것이 아니었나요? 🤨</p>
<p>이 혼란을 해소하기 위해 JavaScript의 실행 메커니즘을 완전히 이해해야 합니다.</p>
<h1>JavaScript에 대해</h1>
<p>JavaScript는 단일 스레드 언어입니다. 🧵 최신 HTML5에서 Web Workers가 소개되었지만, JavaScript의 단일 스레드 코어는 변하지 않았습니다. 따라서 JavaScript의 모든 "다중 스레딩"은 단일 스레드를 사용하여 모의되며, 모든 다중 스레딩은 속임수입니다!</p>
<div class="content-ad"></div>
<h1>자바스크립트 이벤트 루프</h1>
<p>자바스크립트는 한 번에 하나의 작업만 처리하기 때문에, 한 창만 있는 은행과 같아요; 고객들은 차례로 업무를 처리하기 위해 줄을 서야 합니다. 🏦 마찬가지로, 자바스크립트 작업들은 하나씩 실행되어야 해요. 만약 어떤 작업이 너무 오래 걸린다면, 다음 작업은 기다려야 해요.</p>
<p>그래서 질문이 생깁니다: 우리가 뉴스를 보려고 하는데, 뉴스에 있는 고화질 사진들이 느리게 로드된다면, 사진이 완전히 표시될 때까지 웹 페이지가 멈춰 있어야 할까요?</p>
<p>똑똑한 프로그래머들은 이 문제를 두 가지 범주로 작업을 나누어 해결합니다:</p>
<div class="content-ad"></div>
<ol>
<li>동기 작업 🕒</li>
<li>비동기 작업 ⏩</li>
</ol>
<p>웹사이트를 열 때, 렌더링 프로세스는 페이지 골격과 요소를 렌더링하는 등 많은 동기 작업으로 구성됩니다. 🖥️ 사진이나 음악 파일과 같이 많은 리소스를 사용하고 오랜 시간이 걸리는 작업들은 비동기 작업입니다.</p>
<p>더 쉽게 이해하기 위해 마인드 맵을 사용하여 설명하겠습니다:</p>
<p><img src="/assets/img/2024-06-23-In-DepthExplorationofJavaScriptExecutionContext_0.png" alt="마인드 맵"></p>
<div class="content-ad"></div>
<p>마음의 맵 콘텐츠를 설명하는 단어를 사용하면:</p>
<ol>
<li>동기 작업과 비동기 작업은 서로 다른 실행 "장소"로 들어갑니다. 🕒⏩</li>
<li>동기 작업은 주 스레드로 들어가고, 비동기 작업은 이벤트 테이블에 들어가서 함수를 등록합니다. 🧵📋</li>
<li>지정된 작업이 완료되면, 이벤트 테이블은 이 함수를 이벤트 큐로 이동시킵니다. 📤</li>
<li>주 스레드의 작업이 실행되고 나면, 해당 함수는 이벤트 큐에서 읽혀 주 스레드에서 실행됩니다. 🔄</li>
<li>이 프로세스는 계속해서 반복되며, 이를 이벤트 루프라고 합니다. 🔁</li>
</ol>
<p>여러분은 아마 궁금해 할지도 모릅니다. 주 스레드 실행 스택이 비어있는지 어떻게 알 수 있을까요? 🤔 자바스크립트 엔진은 주 스레드 실행 스택이 비어있는지 계속 확인하는 모니터링 프로세스가 있습니다. 한 번 비어지면, 이벤트 큐로 이동하여 호출을 기다리는 함수가 있는지 확인할 것입니다.</p>
<p>위 설명 이후에, 코드 한 줄이 더 직관적일지 모릅니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> data = [];
$.<span class="hljs-title function_">ajax</span>({
  <span class="hljs-attr">url</span>: <span class="hljs-string">'www.javascript.com'</span>,
  <span class="hljs-attr">data</span>: data,
  <span class="hljs-attr">success</span>: <span class="hljs-function">() =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Send successful'</span>);
  }
})
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Code execution completed'</span>);
</code></pre>
<p>여기에 간단한 AJAX 요청 코드 예시가 있어요:</p>
<ol>
<li>AJAX가 이벤트 테이블에 들어가며 콜백 함수 success를 등록해. 📋</li>
<li>console.log(<code>Code execution ended</code>)를 실행해. 🖨️</li>
<li>AJAX 이벤트가 완료되고 콜백 함수 success가 이벤트 대기열에 들어갔어. 📤</li>
<li>메인 스레드가 이벤트 대기열에서 콜백 함수 success를 읽고 실행해. 🔄</li>
</ol>
<p>위의 텍스트와 코드를 통해 JavaScript의 실행 순서에 대해 간단히 이해했을 거라고 믿어.</p>
<div class="content-ad"></div>
<p>🧑‍💻 다음으로, 고급 주제인 setTimeout을 공부해 봅시다.</p>
<h1>setTimeout에 대한 사랑과 미움</h1>
<p>우리가 모두 알다시피, setTimeout에 대해 자세한 소개는 필요하지 않습니다. ⏳ 우리의 첫인상은 지연 후 비동기적으로 실행될 수 있다는 것입니다. 우리는 종종 3초 지연 실행을 구현하기 위해 사용합니다:</p>
<pre><code class="hljs language-js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> {
  <span class="hljs-title function_">task</span>();
}, <span class="hljs-number">3000</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'콘솔 실행'</span>);
</code></pre>
<div class="content-ad"></div>
<p>그러나 setTimeout을 계속 사용할수록 문제가 발생합니다. 때로는 코드에서 3초의 지연을 지정해도 함수가 5 또는 6초 이후에 실행되기도 합니다. 🤯 그 이유가 무엇일까요? 🤔</p>
<p>예시를 살펴봅시다:</p>
<pre><code class="hljs language-js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-title function_">task</span>();
}, <span class="hljs-number">3000</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'콘솔 실행'</span>);
</code></pre>
<p>이전 결론에 따르면, setTimeout은 비동기적이므로 동기 작업인 console.log이 먼저 실행되어야 합니다. 따라서 우리의 결론은 다음과 같습니다:</p>
<div class="content-ad"></div>
<ul>
<li>콘솔 실행</li>
<li>task()</li>
</ul>
<p>확인해보세요. 결과가 맞다면 지난 코드를 수정해봅시다:</p>
<pre><code class="hljs language-js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-title function_">task</span>();
}, <span class="hljs-number">3000</span>)
<span class="hljs-title function_">sleep</span>(<span class="hljs-number">10000000</span>)
</code></pre>
<p>처음에는 비슷해 보이지만, 이 코드를 Chrome에서 실행하면 콘솔 실행 시간이 3초보다 훨씬 길다는 것을 알 수 있습니다. 왜 이제 시간이 오래 걸릴까요?</p>
<div class="content-ad"></div>
<p>지금 선언해야 하는 것은 setTimeout을 재정의하는 것입니다. 위의 코드의 실행 프로세스를 논의해 봅시다:</p>
<ul>
<li>task()가 이벤트 테이블에 등록되어 타이밍이 시작됩니다.</li>
<li>sleep 함수를 아주 천천히 실행하고 타이밍이 계속됩니다.</li>
<li>3초 후에 타임아웃 이벤트가 완료됩니다. task()가 이벤트 큐에 입력됩니다. 그러나 sleep 함수는 아직 완료되지 않아서 대기해야 합니다.</li>
<li>마지막으로 sleep 함수가 실행되고 task()가 마침내 이벤트 큐에서 메인 스레드로 이동되어 실행됩니다.</li>
</ul>
<p>위의 과정을 거친 후, setTimeout 함수는 지정된 시간이 지난 후 작업(이 경우 task())을 이벤트 큐에 추가함을 이해할 수 있습니다. 작업은 단일 스레드 환경에서 하나씩 실행되기 때문에, 이전 작업이 실행하는 데 너무 오래 걸리면 실행 시간이 3초를 크게 초과할 수 있습니다.</p>
<p>우리는 종종 setTimeout(fn, 0)와 같은 코드를 볼 수 있습니다. "0초 후 실행"이란 무엇을 의미하는 걸까요? 즉시 실행될 수 있을까요?</p>
<div class="content-ad"></div>
<p>답변은 아니요. setTimeout(fn, 0)은 주 스레드의 가장 빠른 유휴 시간에 실행할 작업을 지정하는 것을 의미합니다. 추가적인 초를 기다리지 않고 호출되며, 모든 동기 작업이 완료되고 스택이 비어있는 상태가 되었을 때 실행됩니다. 예를 들어:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 코드 1</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'이 부분은 먼저 실행됩니다'</span>);
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'실행됨'</span>)
}, <span class="hljs-number">0</span>);

<span class="hljs-comment">// 코드 2</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'이 부분은 먼저 실행됩니다'</span>);
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'실행됨'</span>)
}, <span class="hljs-number">3000</span>);
</code></pre>
<p>코드 1의 출력 결과는:</p>
<ul>
<li>이 부분은 먼저 실행됩니다</li>
<li>실행됨</li>
</ul>
<div class="content-ad"></div>
<p>코드 2의 출력은:</p>
<ul>
<li>먼저 여기에서 실행</li>
<li>... 3초 후</li>
<li>실행됨</li>
</ul>
<p>setTimeout에 대해 주목해야 할 점은 주 스레드가 유휴 상태라도 0밀리초까지 달성할 수 없다는 것입니다. HTML 표준에 따르면 최소 값은 4밀리초입니다. 관심 있는 학생들은 스스로 탐구해 볼 수 있습니다.</p>
<h1>쌍둥이 동생 setInterval</h1>
<div class="content-ad"></div>
<p>setTimeout에 관해서 이야기할 때는, 그 둘둥이 형제 setInterval을 빠트릴 수 없어요. ⏳🔁 이 둘은 매우 비슷하지만, 후자는 루프에서 실행됩니다. 실행 순서 측면에서, setInterval로 등록된 함수는 각 지정된 간격마다 이벤트 큐에 넣을 거예요. 이전 작업이 너무 오래 걸린 경우에도 기다려야 해요. ⏱️</p>
<p>유의할 점은 setInterval(fn, ms)의 경우, fn이 ms초마다 실행되는 것이 아니라, fn의 새 인스턴스가 ms초 간격으로 이벤트 큐에 들어간다는 것이에요. 📤 만약 setInterval의 콜백 함수 fn이 지연 시간 ms보다 오래 걸린다면, 명백한 시간 간격이 없을 거예요. 이 문장을 신중하게 생각해보세요.</p>
<h1>Promises와 process.nextTick(callback)</h1>
<p>이제 전통적인 타이머를 살펴본 후에, Promise와 process.nextTick(callback)의 동작을 알아보겠어요.</p>
<div class="content-ad"></div>
<p>이 글에서는 Promise의 정의와 기능을 자세히 다루지 않을 것입니다. process.nextTick(callback)은 Node.js에서 "setTimeout"와 유사하며, 콜백 함수를 다음 라운드의 이벤트 루프에서 호출합니다.</p>
<p>이해를 돕기 위해 바로 요점에 들어가보겠습니다. 동기적 및 비동기적 작업의 일반적인 정의 외에도 작업에 대한 더 구체적인 정의가 있습니다:</p>
<ul>
<li>🕰️ Macro-task(매크로 작업): 전체 코드, setTimeout, setInterval을 포함합니다.</li>
<li>🎯 Micro-task(마이크로 작업): Promise, process.nextTick을 포함합니다.</li>
</ul>
<p>다른 유형의 작업은 해당하는 이벤트 큐에 들어가게 됩니다. 예를 들어, setTimeout과 setInterval은 동일한 이벤트 큐에 들어갑니다.</p>
<div class="content-ad"></div>
<p>이벤트 루프의 순서는 JavaScript 코드가 실행되는 순서를 결정합니다. 전체 코드(매크로태스크)를 입력한 후 첫 번째 루프를 시작합니다. 그런 다음 모든 마이크로태스크를 실행합니다. 다음으로, 매크로태스크에서 시작하여 태스크 큐가 완료될 때까지 다시 시작하고, 다시 모든 마이크로태스크를 실행합니다. 약간 복잡해 보일 수 있지만, 지금 이 기사에서 한 코드 스니펫을 사용하여 설명해보겠습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'setTimeout'</span>);
})

<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'promise'</span>);
}).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'then'</span>);
})

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'console'</span>);
</code></pre>
<ul>
<li>🔄 이 코드는 매크로태스크로 주 스레드로 들어갑니다.</li>
<li>setTimeout을 만나면 해당 콜백 함수가 등록되어 매크로태스크 이벤트 큐로 전달됩니다.</li>
<li>그 다음 Promise를 만나면 즉시 새 Promise가 실행되고 then 함수가 마이크로태스크 이벤트 큐로 전달됩니다.</li>
<li>console.log()을 만나면 즉시 실행됩니다.</li>
<li>매크로태스크로 전체 코드를 실행한 후, 어떤 마이크로태스크가 있는지 살펴봅니다. 마이크로태스크 이벤트 큐에서 then을 찾아 실행합니다.</li>
<li>첫 번째 이벤트 루프가 끝났습니다. 이제 매크로태스크 이벤트 큐에서 두 번째 라운드를 시작합니다. 이 큐에서 setTimeout에 해당하는 콜백 함수가 바로 실행됩니다.</li>
<li>✅ 실행 완료.</li>
</ul>
<p>이벤트 루프, 매크로태스크 및 마이크로태스크 사이의 관계는 다음 그림에 나와 있습니다:</p>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-06-23-In-DepthExplorationofJavaScriptExecutionContext_1.png" alt="Exploration of JavaScript ExecutionContext"></p>
<h1>요약</h1>
<p>🔄 JavaScript 비동기성: JavaScript는 단일 스레드 언어로 동작합니다. 비동기성을 달성하기 위한 새로운 프레임워크와 구문이 있지만, 기본적으로 동기적 방법을 사용합니다. 이 단일 스레드 특성을 이해하는 것이 중요합니다.</p>
<p>🌀 이벤트 루프: 이벤트 루프는 JavaScript의 비동기 작업을 처리하고 실행 흐름을 관리하는 메커니즘입니다.</p>
<div class="content-ad"></div>
<p>🖥️ JavaScript 실행과 실행 방법: JavaScript의 실행은 Node.js, 브라우저 및 기타 환경(예: Ringo)에서 다양하게 이뤄집니다. 반면 "실행"이라는 용어는 일반적으로 JavaScript 파싱 엔진의 일관된 동작을 나타냅니다.</p>
<p>⏰ setImmediate: 마이크로태스크 및 매크로태스크와 함께, setImmediate는 비동기 작업의 한 유형입니다. 그들은 예약 및 실행 방법에 대해 일반적인 특성을 공유합니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"자바스크립트 실행 컨텍스트 심층 탐구","description":"","date":"2024-06-23 15:14","slug":"2024-06-23-In-DepthExplorationofJavaScriptExecutionContext","content":"\n\n자바스크립트 초심자든 전문가든, 면접이건 일상적인 개발 작업이건, 우리는 종종 다음과 같은 상황을 맞닥뜨립니다: 몇 줄의 코드가 주어졌을 때, 그들이 무엇을 출력하며 어떤 순서로 실행되는지 알아야 합니다. 🧑‍💻 자바스크립트는 싱글 스레드 언어이기 때문에 우리는 다음 결론을 내릴 수 있습니다:\n\n자바스크립트는 문장을 나타난 순서대로 실행합니다. 📜\n\n이 시점에서, \"나는 JS가 한 줄씩 실행된다는 것을 알아, 왜 강조하는 거지?\"라고 하실 수 있습니다. 🤔 우리는 JS가 한 줄씩 실행된다고 가정하기 때문에 이런 식으로 모든 JS가 동작한다고 가정합니다.\n\n```js\nlet a = '1';\nconsole.log(a);\n\nlet b = '2';\nconsole.log(b);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 실제로 JavaScript는 다음과 같이 실행됩니다:\n\n```js\nsetTimeout(function(){\n  console.log('Timer started')\n});\nnew Promise(function(resolve){\n  console.log('For loop is about to be executed');\n  for(var i = 0; i \u003c 10000; i++){\n    i == 99 \u0026\u0026 resolve();\n  }\n}).then(function(){\n  console.log('Execute then function')\n});\nconsole.log('Code execution ends');\n```\n\nJavaScript가 문장을 순서대로 실행한다는 개념을 따라, 예상 출력을 자신 있게 적었습니다:\n\n1. 타이머 시작. ⏱️\n2. for 루프가 실행됩니다. 🔄\n3. then 함수를 실행합니다. ➡️\n4. 코드 실행 종료. 🛑\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러나 Chrome에서 확인했을 때 결과가 완전히 잘못되어 순간적으로 혼란스러웠어요. 😕 예상대로 줄 단위로 실행되어야 하는 것이 아니었나요? 🤨\n\n이 혼란을 해소하기 위해 JavaScript의 실행 메커니즘을 완전히 이해해야 합니다.\n\n# JavaScript에 대해\n\nJavaScript는 단일 스레드 언어입니다. 🧵 최신 HTML5에서 Web Workers가 소개되었지만, JavaScript의 단일 스레드 코어는 변하지 않았습니다. 따라서 JavaScript의 모든 \"다중 스레딩\"은 단일 스레드를 사용하여 모의되며, 모든 다중 스레딩은 속임수입니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 자바스크립트 이벤트 루프\n\n자바스크립트는 한 번에 하나의 작업만 처리하기 때문에, 한 창만 있는 은행과 같아요; 고객들은 차례로 업무를 처리하기 위해 줄을 서야 합니다. 🏦 마찬가지로, 자바스크립트 작업들은 하나씩 실행되어야 해요. 만약 어떤 작업이 너무 오래 걸린다면, 다음 작업은 기다려야 해요.\n\n그래서 질문이 생깁니다: 우리가 뉴스를 보려고 하는데, 뉴스에 있는 고화질 사진들이 느리게 로드된다면, 사진이 완전히 표시될 때까지 웹 페이지가 멈춰 있어야 할까요?\n\n똑똑한 프로그래머들은 이 문제를 두 가지 범주로 작업을 나누어 해결합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n1. 동기 작업 🕒 \n2. 비동기 작업 ⏩\n\n웹사이트를 열 때, 렌더링 프로세스는 페이지 골격과 요소를 렌더링하는 등 많은 동기 작업으로 구성됩니다. 🖥️ 사진이나 음악 파일과 같이 많은 리소스를 사용하고 오랜 시간이 걸리는 작업들은 비동기 작업입니다.\n\n더 쉽게 이해하기 위해 마인드 맵을 사용하여 설명하겠습니다:\n\n![마인드 맵](/assets/img/2024-06-23-In-DepthExplorationofJavaScriptExecutionContext_0.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마음의 맵 콘텐츠를 설명하는 단어를 사용하면:\n\n1. 동기 작업과 비동기 작업은 서로 다른 실행 \"장소\"로 들어갑니다. 🕒⏩\n2. 동기 작업은 주 스레드로 들어가고, 비동기 작업은 이벤트 테이블에 들어가서 함수를 등록합니다. 🧵📋\n3. 지정된 작업이 완료되면, 이벤트 테이블은 이 함수를 이벤트 큐로 이동시킵니다. 📤\n4. 주 스레드의 작업이 실행되고 나면, 해당 함수는 이벤트 큐에서 읽혀 주 스레드에서 실행됩니다. 🔄\n5. 이 프로세스는 계속해서 반복되며, 이를 이벤트 루프라고 합니다. 🔁\n\n여러분은 아마 궁금해 할지도 모릅니다. 주 스레드 실행 스택이 비어있는지 어떻게 알 수 있을까요? 🤔 자바스크립트 엔진은 주 스레드 실행 스택이 비어있는지 계속 확인하는 모니터링 프로세스가 있습니다. 한 번 비어지면, 이벤트 큐로 이동하여 호출을 기다리는 함수가 있는지 확인할 것입니다.\n\n위 설명 이후에, 코드 한 줄이 더 직관적일지 모릅니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nlet data = [];\n$.ajax({\n  url: 'www.javascript.com',\n  data: data,\n  success: () =\u003e {\n    console.log('Send successful');\n  }\n})\nconsole.log('Code execution completed');\n```\n\n여기에 간단한 AJAX 요청 코드 예시가 있어요:\n\n1. AJAX가 이벤트 테이블에 들어가며 콜백 함수 success를 등록해. 📋\n2. console.log(`Code execution ended`)를 실행해. 🖨️\n3. AJAX 이벤트가 완료되고 콜백 함수 success가 이벤트 대기열에 들어갔어. 📤\n4. 메인 스레드가 이벤트 대기열에서 콜백 함수 success를 읽고 실행해. 🔄\n\n위의 텍스트와 코드를 통해 JavaScript의 실행 순서에 대해 간단히 이해했을 거라고 믿어.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n🧑‍💻 다음으로, 고급 주제인 setTimeout을 공부해 봅시다.\n\n# setTimeout에 대한 사랑과 미움\n\n우리가 모두 알다시피, setTimeout에 대해 자세한 소개는 필요하지 않습니다. ⏳ 우리의 첫인상은 지연 후 비동기적으로 실행될 수 있다는 것입니다. 우리는 종종 3초 지연 실행을 구현하기 위해 사용합니다:\n\n```js\nsetTimeout(() =\u003e {\n  task();\n}, 3000);\nconsole.log('콘솔 실행');\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러나 setTimeout을 계속 사용할수록 문제가 발생합니다. 때로는 코드에서 3초의 지연을 지정해도 함수가 5 또는 6초 이후에 실행되기도 합니다. 🤯 그 이유가 무엇일까요? 🤔\n\n예시를 살펴봅시다:\n\n```js\nsetTimeout(() =\u003e {\n    task();\n}, 3000)\nconsole.log('콘솔 실행');\n```\n\n이전 결론에 따르면, setTimeout은 비동기적이므로 동기 작업인 console.log이 먼저 실행되어야 합니다. 따라서 우리의 결론은 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 콘솔 실행\n- task()\n\n확인해보세요. 결과가 맞다면 지난 코드를 수정해봅시다:\n\n```js\nsetTimeout(() =\u003e {\n    task();\n}, 3000)\nsleep(10000000)\n```\n\n처음에는 비슷해 보이지만, 이 코드를 Chrome에서 실행하면 콘솔 실행 시간이 3초보다 훨씬 길다는 것을 알 수 있습니다. 왜 이제 시간이 오래 걸릴까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금 선언해야 하는 것은 setTimeout을 재정의하는 것입니다. 위의 코드의 실행 프로세스를 논의해 봅시다:\n\n- task()가 이벤트 테이블에 등록되어 타이밍이 시작됩니다.\n- sleep 함수를 아주 천천히 실행하고 타이밍이 계속됩니다.\n- 3초 후에 타임아웃 이벤트가 완료됩니다. task()가 이벤트 큐에 입력됩니다. 그러나 sleep 함수는 아직 완료되지 않아서 대기해야 합니다.\n- 마지막으로 sleep 함수가 실행되고 task()가 마침내 이벤트 큐에서 메인 스레드로 이동되어 실행됩니다.\n\n위의 과정을 거친 후, setTimeout 함수는 지정된 시간이 지난 후 작업(이 경우 task())을 이벤트 큐에 추가함을 이해할 수 있습니다. 작업은 단일 스레드 환경에서 하나씩 실행되기 때문에, 이전 작업이 실행하는 데 너무 오래 걸리면 실행 시간이 3초를 크게 초과할 수 있습니다.\n\n우리는 종종 setTimeout(fn, 0)와 같은 코드를 볼 수 있습니다. \"0초 후 실행\"이란 무엇을 의미하는 걸까요? 즉시 실행될 수 있을까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n답변은 아니요. setTimeout(fn, 0)은 주 스레드의 가장 빠른 유휴 시간에 실행할 작업을 지정하는 것을 의미합니다. 추가적인 초를 기다리지 않고 호출되며, 모든 동기 작업이 완료되고 스택이 비어있는 상태가 되었을 때 실행됩니다. 예를 들어:\n\n```js\n// 코드 1\nconsole.log('이 부분은 먼저 실행됩니다');\nsetTimeout(() =\u003e {\n  console.log('실행됨')\n}, 0);\n\n// 코드 2\nconsole.log('이 부분은 먼저 실행됩니다');\nsetTimeout(() =\u003e {\n  console.log('실행됨')\n}, 3000);\n```\n\n코드 1의 출력 결과는:\n\n- 이 부분은 먼저 실행됩니다\n- 실행됨\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n코드 2의 출력은:\n\n- 먼저 여기에서 실행\n- ... 3초 후\n- 실행됨\n\nsetTimeout에 대해 주목해야 할 점은 주 스레드가 유휴 상태라도 0밀리초까지 달성할 수 없다는 것입니다. HTML 표준에 따르면 최소 값은 4밀리초입니다. 관심 있는 학생들은 스스로 탐구해 볼 수 있습니다.\n\n# 쌍둥이 동생 setInterval\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nsetTimeout에 관해서 이야기할 때는, 그 둘둥이 형제 setInterval을 빠트릴 수 없어요. ⏳🔁 이 둘은 매우 비슷하지만, 후자는 루프에서 실행됩니다. 실행 순서 측면에서, setInterval로 등록된 함수는 각 지정된 간격마다 이벤트 큐에 넣을 거예요. 이전 작업이 너무 오래 걸린 경우에도 기다려야 해요. ⏱️\n\n유의할 점은 setInterval(fn, ms)의 경우, fn이 ms초마다 실행되는 것이 아니라, fn의 새 인스턴스가 ms초 간격으로 이벤트 큐에 들어간다는 것이에요. 📤 만약 setInterval의 콜백 함수 fn이 지연 시간 ms보다 오래 걸린다면, 명백한 시간 간격이 없을 거예요. 이 문장을 신중하게 생각해보세요.\n\n# Promises와 process.nextTick(callback)\n\n이제 전통적인 타이머를 살펴본 후에, Promise와 process.nextTick(callback)의 동작을 알아보겠어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 글에서는 Promise의 정의와 기능을 자세히 다루지 않을 것입니다. process.nextTick(callback)은 Node.js에서 \"setTimeout\"와 유사하며, 콜백 함수를 다음 라운드의 이벤트 루프에서 호출합니다.\n\n이해를 돕기 위해 바로 요점에 들어가보겠습니다. 동기적 및 비동기적 작업의 일반적인 정의 외에도 작업에 대한 더 구체적인 정의가 있습니다:\n\n- 🕰️ Macro-task(매크로 작업): 전체 코드, setTimeout, setInterval을 포함합니다.\n- 🎯 Micro-task(마이크로 작업): Promise, process.nextTick을 포함합니다.\n\n다른 유형의 작업은 해당하는 이벤트 큐에 들어가게 됩니다. 예를 들어, setTimeout과 setInterval은 동일한 이벤트 큐에 들어갑니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이벤트 루프의 순서는 JavaScript 코드가 실행되는 순서를 결정합니다. 전체 코드(매크로태스크)를 입력한 후 첫 번째 루프를 시작합니다. 그런 다음 모든 마이크로태스크를 실행합니다. 다음으로, 매크로태스크에서 시작하여 태스크 큐가 완료될 때까지 다시 시작하고, 다시 모든 마이크로태스크를 실행합니다. 약간 복잡해 보일 수 있지만, 지금 이 기사에서 한 코드 스니펫을 사용하여 설명해보겠습니다:\n\n```js\nsetTimeout(function() {\n    console.log('setTimeout');\n})\n\nnew Promise(function(resolve) {\n    console.log('promise');\n}).then(function() {\n    console.log('then');\n})\n\nconsole.log('console');\n```\n\n- 🔄 이 코드는 매크로태스크로 주 스레드로 들어갑니다.\n- setTimeout을 만나면 해당 콜백 함수가 등록되어 매크로태스크 이벤트 큐로 전달됩니다.\n- 그 다음 Promise를 만나면 즉시 새 Promise가 실행되고 then 함수가 마이크로태스크 이벤트 큐로 전달됩니다.\n- console.log()을 만나면 즉시 실행됩니다.\n- 매크로태스크로 전체 코드를 실행한 후, 어떤 마이크로태스크가 있는지 살펴봅니다. 마이크로태스크 이벤트 큐에서 then을 찾아 실행합니다.\n- 첫 번째 이벤트 루프가 끝났습니다. 이제 매크로태스크 이벤트 큐에서 두 번째 라운드를 시작합니다. 이 큐에서 setTimeout에 해당하는 콜백 함수가 바로 실행됩니다.\n- ✅ 실행 완료.\n\n이벤트 루프, 매크로태스크 및 마이크로태스크 사이의 관계는 다음 그림에 나와 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Exploration of JavaScript ExecutionContext](/assets/img/2024-06-23-In-DepthExplorationofJavaScriptExecutionContext_1.png)\n\n# 요약\n\n🔄 JavaScript 비동기성: JavaScript는 단일 스레드 언어로 동작합니다. 비동기성을 달성하기 위한 새로운 프레임워크와 구문이 있지만, 기본적으로 동기적 방법을 사용합니다. 이 단일 스레드 특성을 이해하는 것이 중요합니다.\n\n🌀 이벤트 루프: 이벤트 루프는 JavaScript의 비동기 작업을 처리하고 실행 흐름을 관리하는 메커니즘입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n🖥️ JavaScript 실행과 실행 방법: JavaScript의 실행은 Node.js, 브라우저 및 기타 환경(예: Ringo)에서 다양하게 이뤄집니다. 반면 \"실행\"이라는 용어는 일반적으로 JavaScript 파싱 엔진의 일관된 동작을 나타냅니다.\n\n⏰ setImmediate: 마이크로태스크 및 매크로태스크와 함께, setImmediate는 비동기 작업의 한 유형입니다. 그들은 예약 및 실행 방법에 대해 일반적인 특성을 공유합니다.","ogImage":{"url":"/assets/img/2024-06-23-In-DepthExplorationofJavaScriptExecutionContext_0.png"},"coverImage":"/assets/img/2024-06-23-In-DepthExplorationofJavaScriptExecutionContext_0.png","tag":["Tech"],"readingTime":8},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e자바스크립트 초심자든 전문가든, 면접이건 일상적인 개발 작업이건, 우리는 종종 다음과 같은 상황을 맞닥뜨립니다: 몇 줄의 코드가 주어졌을 때, 그들이 무엇을 출력하며 어떤 순서로 실행되는지 알아야 합니다. 🧑‍💻 자바스크립트는 싱글 스레드 언어이기 때문에 우리는 다음 결론을 내릴 수 있습니다:\u003c/p\u003e\n\u003cp\u003e자바스크립트는 문장을 나타난 순서대로 실행합니다. 📜\u003c/p\u003e\n\u003cp\u003e이 시점에서, \"나는 JS가 한 줄씩 실행된다는 것을 알아, 왜 강조하는 거지?\"라고 하실 수 있습니다. 🤔 우리는 JS가 한 줄씩 실행된다고 가정하기 때문에 이런 식으로 모든 JS가 동작한다고 가정합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e a = \u003cspan class=\"hljs-string\"\u003e'1'\u003c/span\u003e;\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(a);\n\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e b = \u003cspan class=\"hljs-string\"\u003e'2'\u003c/span\u003e;\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(b);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e하지만 실제로 JavaScript는 다음과 같이 실행됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-built_in\"\u003esetTimeout\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e){\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Timer started'\u003c/span\u003e)\n});\n\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eresolve\u003c/span\u003e){\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'For loop is about to be executed'\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; i \u0026#x3C; \u003cspan class=\"hljs-number\"\u003e10000\u003c/span\u003e; i++){\n    i == \u003cspan class=\"hljs-number\"\u003e99\u003c/span\u003e \u0026#x26;\u0026#x26; \u003cspan class=\"hljs-title function_\"\u003eresolve\u003c/span\u003e();\n  }\n}).\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e){\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Execute then function'\u003c/span\u003e)\n});\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Code execution ends'\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eJavaScript가 문장을 순서대로 실행한다는 개념을 따라, 예상 출력을 자신 있게 적었습니다:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e타이머 시작. ⏱️\u003c/li\u003e\n\u003cli\u003efor 루프가 실행됩니다. 🔄\u003c/li\u003e\n\u003cli\u003ethen 함수를 실행합니다. ➡️\u003c/li\u003e\n\u003cli\u003e코드 실행 종료. 🛑\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e그러나 Chrome에서 확인했을 때 결과가 완전히 잘못되어 순간적으로 혼란스러웠어요. 😕 예상대로 줄 단위로 실행되어야 하는 것이 아니었나요? 🤨\u003c/p\u003e\n\u003cp\u003e이 혼란을 해소하기 위해 JavaScript의 실행 메커니즘을 완전히 이해해야 합니다.\u003c/p\u003e\n\u003ch1\u003eJavaScript에 대해\u003c/h1\u003e\n\u003cp\u003eJavaScript는 단일 스레드 언어입니다. 🧵 최신 HTML5에서 Web Workers가 소개되었지만, JavaScript의 단일 스레드 코어는 변하지 않았습니다. 따라서 JavaScript의 모든 \"다중 스레딩\"은 단일 스레드를 사용하여 모의되며, 모든 다중 스레딩은 속임수입니다!\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e자바스크립트 이벤트 루프\u003c/h1\u003e\n\u003cp\u003e자바스크립트는 한 번에 하나의 작업만 처리하기 때문에, 한 창만 있는 은행과 같아요; 고객들은 차례로 업무를 처리하기 위해 줄을 서야 합니다. 🏦 마찬가지로, 자바스크립트 작업들은 하나씩 실행되어야 해요. 만약 어떤 작업이 너무 오래 걸린다면, 다음 작업은 기다려야 해요.\u003c/p\u003e\n\u003cp\u003e그래서 질문이 생깁니다: 우리가 뉴스를 보려고 하는데, 뉴스에 있는 고화질 사진들이 느리게 로드된다면, 사진이 완전히 표시될 때까지 웹 페이지가 멈춰 있어야 할까요?\u003c/p\u003e\n\u003cp\u003e똑똑한 프로그래머들은 이 문제를 두 가지 범주로 작업을 나누어 해결합니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003col\u003e\n\u003cli\u003e동기 작업 🕒\u003c/li\u003e\n\u003cli\u003e비동기 작업 ⏩\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e웹사이트를 열 때, 렌더링 프로세스는 페이지 골격과 요소를 렌더링하는 등 많은 동기 작업으로 구성됩니다. 🖥️ 사진이나 음악 파일과 같이 많은 리소스를 사용하고 오랜 시간이 걸리는 작업들은 비동기 작업입니다.\u003c/p\u003e\n\u003cp\u003e더 쉽게 이해하기 위해 마인드 맵을 사용하여 설명하겠습니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-In-DepthExplorationofJavaScriptExecutionContext_0.png\" alt=\"마인드 맵\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e마음의 맵 콘텐츠를 설명하는 단어를 사용하면:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e동기 작업과 비동기 작업은 서로 다른 실행 \"장소\"로 들어갑니다. 🕒⏩\u003c/li\u003e\n\u003cli\u003e동기 작업은 주 스레드로 들어가고, 비동기 작업은 이벤트 테이블에 들어가서 함수를 등록합니다. 🧵📋\u003c/li\u003e\n\u003cli\u003e지정된 작업이 완료되면, 이벤트 테이블은 이 함수를 이벤트 큐로 이동시킵니다. 📤\u003c/li\u003e\n\u003cli\u003e주 스레드의 작업이 실행되고 나면, 해당 함수는 이벤트 큐에서 읽혀 주 스레드에서 실행됩니다. 🔄\u003c/li\u003e\n\u003cli\u003e이 프로세스는 계속해서 반복되며, 이를 이벤트 루프라고 합니다. 🔁\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e여러분은 아마 궁금해 할지도 모릅니다. 주 스레드 실행 스택이 비어있는지 어떻게 알 수 있을까요? 🤔 자바스크립트 엔진은 주 스레드 실행 스택이 비어있는지 계속 확인하는 모니터링 프로세스가 있습니다. 한 번 비어지면, 이벤트 큐로 이동하여 호출을 기다리는 함수가 있는지 확인할 것입니다.\u003c/p\u003e\n\u003cp\u003e위 설명 이후에, 코드 한 줄이 더 직관적일지 모릅니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e data = [];\n$.\u003cspan class=\"hljs-title function_\"\u003eajax\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003eurl\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'www.javascript.com'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e: data,\n  \u003cspan class=\"hljs-attr\"\u003esuccess\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Send successful'\u003c/span\u003e);\n  }\n})\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Code execution completed'\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기에 간단한 AJAX 요청 코드 예시가 있어요:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eAJAX가 이벤트 테이블에 들어가며 콜백 함수 success를 등록해. 📋\u003c/li\u003e\n\u003cli\u003econsole.log(\u003ccode\u003eCode execution ended\u003c/code\u003e)를 실행해. 🖨️\u003c/li\u003e\n\u003cli\u003eAJAX 이벤트가 완료되고 콜백 함수 success가 이벤트 대기열에 들어갔어. 📤\u003c/li\u003e\n\u003cli\u003e메인 스레드가 이벤트 대기열에서 콜백 함수 success를 읽고 실행해. 🔄\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e위의 텍스트와 코드를 통해 JavaScript의 실행 순서에 대해 간단히 이해했을 거라고 믿어.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e🧑‍💻 다음으로, 고급 주제인 setTimeout을 공부해 봅시다.\u003c/p\u003e\n\u003ch1\u003esetTimeout에 대한 사랑과 미움\u003c/h1\u003e\n\u003cp\u003e우리가 모두 알다시피, setTimeout에 대해 자세한 소개는 필요하지 않습니다. ⏳ 우리의 첫인상은 지연 후 비동기적으로 실행될 수 있다는 것입니다. 우리는 종종 3초 지연 실행을 구현하기 위해 사용합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-built_in\"\u003esetTimeout\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003etask\u003c/span\u003e();\n}, \u003cspan class=\"hljs-number\"\u003e3000\u003c/span\u003e);\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'콘솔 실행'\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e그러나 setTimeout을 계속 사용할수록 문제가 발생합니다. 때로는 코드에서 3초의 지연을 지정해도 함수가 5 또는 6초 이후에 실행되기도 합니다. 🤯 그 이유가 무엇일까요? 🤔\u003c/p\u003e\n\u003cp\u003e예시를 살펴봅시다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-built_in\"\u003esetTimeout\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-title function_\"\u003etask\u003c/span\u003e();\n}, \u003cspan class=\"hljs-number\"\u003e3000\u003c/span\u003e)\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'콘솔 실행'\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이전 결론에 따르면, setTimeout은 비동기적이므로 동기 작업인 console.log이 먼저 실행되어야 합니다. 따라서 우리의 결론은 다음과 같습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e콘솔 실행\u003c/li\u003e\n\u003cli\u003etask()\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e확인해보세요. 결과가 맞다면 지난 코드를 수정해봅시다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-built_in\"\u003esetTimeout\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-title function_\"\u003etask\u003c/span\u003e();\n}, \u003cspan class=\"hljs-number\"\u003e3000\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003esleep\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e10000000\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e처음에는 비슷해 보이지만, 이 코드를 Chrome에서 실행하면 콘솔 실행 시간이 3초보다 훨씬 길다는 것을 알 수 있습니다. 왜 이제 시간이 오래 걸릴까요?\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e지금 선언해야 하는 것은 setTimeout을 재정의하는 것입니다. 위의 코드의 실행 프로세스를 논의해 봅시다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003etask()가 이벤트 테이블에 등록되어 타이밍이 시작됩니다.\u003c/li\u003e\n\u003cli\u003esleep 함수를 아주 천천히 실행하고 타이밍이 계속됩니다.\u003c/li\u003e\n\u003cli\u003e3초 후에 타임아웃 이벤트가 완료됩니다. task()가 이벤트 큐에 입력됩니다. 그러나 sleep 함수는 아직 완료되지 않아서 대기해야 합니다.\u003c/li\u003e\n\u003cli\u003e마지막으로 sleep 함수가 실행되고 task()가 마침내 이벤트 큐에서 메인 스레드로 이동되어 실행됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e위의 과정을 거친 후, setTimeout 함수는 지정된 시간이 지난 후 작업(이 경우 task())을 이벤트 큐에 추가함을 이해할 수 있습니다. 작업은 단일 스레드 환경에서 하나씩 실행되기 때문에, 이전 작업이 실행하는 데 너무 오래 걸리면 실행 시간이 3초를 크게 초과할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e우리는 종종 setTimeout(fn, 0)와 같은 코드를 볼 수 있습니다. \"0초 후 실행\"이란 무엇을 의미하는 걸까요? 즉시 실행될 수 있을까요?\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e답변은 아니요. setTimeout(fn, 0)은 주 스레드의 가장 빠른 유휴 시간에 실행할 작업을 지정하는 것을 의미합니다. 추가적인 초를 기다리지 않고 호출되며, 모든 동기 작업이 완료되고 스택이 비어있는 상태가 되었을 때 실행됩니다. 예를 들어:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 코드 1\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'이 부분은 먼저 실행됩니다'\u003c/span\u003e);\n\u003cspan class=\"hljs-built_in\"\u003esetTimeout\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'실행됨'\u003c/span\u003e)\n}, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// 코드 2\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'이 부분은 먼저 실행됩니다'\u003c/span\u003e);\n\u003cspan class=\"hljs-built_in\"\u003esetTimeout\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'실행됨'\u003c/span\u003e)\n}, \u003cspan class=\"hljs-number\"\u003e3000\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e코드 1의 출력 결과는:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e이 부분은 먼저 실행됩니다\u003c/li\u003e\n\u003cli\u003e실행됨\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e코드 2의 출력은:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e먼저 여기에서 실행\u003c/li\u003e\n\u003cli\u003e... 3초 후\u003c/li\u003e\n\u003cli\u003e실행됨\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003esetTimeout에 대해 주목해야 할 점은 주 스레드가 유휴 상태라도 0밀리초까지 달성할 수 없다는 것입니다. HTML 표준에 따르면 최소 값은 4밀리초입니다. 관심 있는 학생들은 스스로 탐구해 볼 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e쌍둥이 동생 setInterval\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003esetTimeout에 관해서 이야기할 때는, 그 둘둥이 형제 setInterval을 빠트릴 수 없어요. ⏳🔁 이 둘은 매우 비슷하지만, 후자는 루프에서 실행됩니다. 실행 순서 측면에서, setInterval로 등록된 함수는 각 지정된 간격마다 이벤트 큐에 넣을 거예요. 이전 작업이 너무 오래 걸린 경우에도 기다려야 해요. ⏱️\u003c/p\u003e\n\u003cp\u003e유의할 점은 setInterval(fn, ms)의 경우, fn이 ms초마다 실행되는 것이 아니라, fn의 새 인스턴스가 ms초 간격으로 이벤트 큐에 들어간다는 것이에요. 📤 만약 setInterval의 콜백 함수 fn이 지연 시간 ms보다 오래 걸린다면, 명백한 시간 간격이 없을 거예요. 이 문장을 신중하게 생각해보세요.\u003c/p\u003e\n\u003ch1\u003ePromises와 process.nextTick(callback)\u003c/h1\u003e\n\u003cp\u003e이제 전통적인 타이머를 살펴본 후에, Promise와 process.nextTick(callback)의 동작을 알아보겠어요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 글에서는 Promise의 정의와 기능을 자세히 다루지 않을 것입니다. process.nextTick(callback)은 Node.js에서 \"setTimeout\"와 유사하며, 콜백 함수를 다음 라운드의 이벤트 루프에서 호출합니다.\u003c/p\u003e\n\u003cp\u003e이해를 돕기 위해 바로 요점에 들어가보겠습니다. 동기적 및 비동기적 작업의 일반적인 정의 외에도 작업에 대한 더 구체적인 정의가 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e🕰️ Macro-task(매크로 작업): 전체 코드, setTimeout, setInterval을 포함합니다.\u003c/li\u003e\n\u003cli\u003e🎯 Micro-task(마이크로 작업): Promise, process.nextTick을 포함합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e다른 유형의 작업은 해당하는 이벤트 큐에 들어가게 됩니다. 예를 들어, setTimeout과 setInterval은 동일한 이벤트 큐에 들어갑니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이벤트 루프의 순서는 JavaScript 코드가 실행되는 순서를 결정합니다. 전체 코드(매크로태스크)를 입력한 후 첫 번째 루프를 시작합니다. 그런 다음 모든 마이크로태스크를 실행합니다. 다음으로, 매크로태스크에서 시작하여 태스크 큐가 완료될 때까지 다시 시작하고, 다시 모든 마이크로태스크를 실행합니다. 약간 복잡해 보일 수 있지만, 지금 이 기사에서 한 코드 스니펫을 사용하여 설명해보겠습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-built_in\"\u003esetTimeout\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'setTimeout'\u003c/span\u003e);\n})\n\n\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eresolve\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'promise'\u003c/span\u003e);\n}).\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'then'\u003c/span\u003e);\n})\n\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'console'\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e🔄 이 코드는 매크로태스크로 주 스레드로 들어갑니다.\u003c/li\u003e\n\u003cli\u003esetTimeout을 만나면 해당 콜백 함수가 등록되어 매크로태스크 이벤트 큐로 전달됩니다.\u003c/li\u003e\n\u003cli\u003e그 다음 Promise를 만나면 즉시 새 Promise가 실행되고 then 함수가 마이크로태스크 이벤트 큐로 전달됩니다.\u003c/li\u003e\n\u003cli\u003econsole.log()을 만나면 즉시 실행됩니다.\u003c/li\u003e\n\u003cli\u003e매크로태스크로 전체 코드를 실행한 후, 어떤 마이크로태스크가 있는지 살펴봅니다. 마이크로태스크 이벤트 큐에서 then을 찾아 실행합니다.\u003c/li\u003e\n\u003cli\u003e첫 번째 이벤트 루프가 끝났습니다. 이제 매크로태스크 이벤트 큐에서 두 번째 라운드를 시작합니다. 이 큐에서 setTimeout에 해당하는 콜백 함수가 바로 실행됩니다.\u003c/li\u003e\n\u003cli\u003e✅ 실행 완료.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이벤트 루프, 매크로태스크 및 마이크로태스크 사이의 관계는 다음 그림에 나와 있습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-In-DepthExplorationofJavaScriptExecutionContext_1.png\" alt=\"Exploration of JavaScript ExecutionContext\"\u003e\u003c/p\u003e\n\u003ch1\u003e요약\u003c/h1\u003e\n\u003cp\u003e🔄 JavaScript 비동기성: JavaScript는 단일 스레드 언어로 동작합니다. 비동기성을 달성하기 위한 새로운 프레임워크와 구문이 있지만, 기본적으로 동기적 방법을 사용합니다. 이 단일 스레드 특성을 이해하는 것이 중요합니다.\u003c/p\u003e\n\u003cp\u003e🌀 이벤트 루프: 이벤트 루프는 JavaScript의 비동기 작업을 처리하고 실행 흐름을 관리하는 메커니즘입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e🖥️ JavaScript 실행과 실행 방법: JavaScript의 실행은 Node.js, 브라우저 및 기타 환경(예: Ringo)에서 다양하게 이뤄집니다. 반면 \"실행\"이라는 용어는 일반적으로 JavaScript 파싱 엔진의 일관된 동작을 나타냅니다.\u003c/p\u003e\n\u003cp\u003e⏰ setImmediate: 마이크로태스크 및 매크로태스크와 함께, setImmediate는 비동기 작업의 한 유형입니다. 그들은 예약 및 실행 방법에 대해 일반적인 특성을 공유합니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-23-In-DepthExplorationofJavaScriptExecutionContext"},"buildId":"5et5eMZxpKCgDAAyIS6Ju","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>