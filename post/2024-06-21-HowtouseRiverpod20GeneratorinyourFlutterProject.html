<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Flutter 프로젝트에서 Riverpod 20  Generator 사용법 | uidev-css</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://uidev-css.github.io///post/2024-06-21-HowtouseRiverpod20GeneratorinyourFlutterProject" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Flutter 프로젝트에서 Riverpod 20  Generator 사용법 | uidev-css" data-gatsby-head="true"/><meta property="og:title" content="Flutter 프로젝트에서 Riverpod 20  Generator 사용법 | uidev-css" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-21-HowtouseRiverpod20GeneratorinyourFlutterProject_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://uidev-css.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://uidev-css.github.io///post/2024-06-21-HowtouseRiverpod20GeneratorinyourFlutterProject" data-gatsby-head="true"/><meta name="twitter:title" content="Flutter 프로젝트에서 Riverpod 20  Generator 사용법 | uidev-css" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-21-HowtouseRiverpod20GeneratorinyourFlutterProject_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | uidev-css" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-21 20:19" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b75a4bf98ee956a8.js" defer=""></script><script src="/_next/static/-8k4Xu2rlgTZWfP5qtaGa/_buildManifest.js" defer=""></script><script src="/_next/static/-8k4Xu2rlgTZWfP5qtaGa/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UIDEV CSS</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Flutter 프로젝트에서 Riverpod 20  Generator 사용법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Flutter 프로젝트에서 Riverpod 20  Generator 사용법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UIDEV CSS</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 21, 2024</span><span class="posts_reading_time__f7YPP">15<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-21-HowtouseRiverpod20GeneratorinyourFlutterProject&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>Riverpod은 플러터(Flutter)에서 상태 관리 및 반응형 데이터 캐싱의 새로운 표준입니다. 두 번째 버전인 Riverpod 2.0은 꽤 오랫동안 출시되었지만, 새로운 데이터 관리 방법과 컨셉을 이해하기 어려울 수 있습니다.</p>
<h1>우리가 배울 내용</h1>
<ul>
<li>Riverpod 2.0의 새로운 프로바이더로 기존 프로바이더를 업데이트하는 방법.</li>
<li>앱 내에서 상태를 새로운 방식으로 관리하는 방법.</li>
<li>Riverpod 2.0에서 퓨처(futures)를 다루는 방법.</li>
<li>프로바이더를 자동으로 생성하고 프로바이더 생성 프로세스를 간소화하는 방법.</li>
</ul>
<p>시작하기 전에, Riverpod가 무엇을 할 수 있는지 알아보아야 합니다. Riverpod는 상태를 관리하기 위해 providers라는 것을 사용하며, 다음은 2.0 이전에 존재했던 providers입니다. 다양한 유형의 providers를 빠르게 살펴보겠습니다:</p>
<ul>
<li>Provider: 이 provider는 값을 생성합니다. 반응적 상태나 메모리가 없기 때문에 대부분의 경우에 최적이 아니지만, 많은 정적 메소드를 가진 클래스나 접근하려는 종속성이 있는 경우 유용합니다.</li>
<li>ChangeNotifierProvider, StateNotifierProvider, StateProvider: 이들은 앱 내부에서 로컬 상태를 생성, 액세스 및 캐싱하는 데 도움을 줍니다. 모두 반응적인 변경을 지원합니다.</li>
<li>FutureProvider, StreamProvider: 이들은 앱 내에서 비동기 데이터를 캐싱하고 액세스하는 데 도움을 줍니다.</li>
</ul>
<p>Riverpod 2.0에서는 이러한 모든 providers를 대체하는 2개의 providers가 있습니다... 하나만 제외하고요.</p>
<ul>
<li>NotifierProvider: 이는 변경 알림/동기 변경에 사용되며, ChangeNotifierProvider, StateNotifierProvider, StateProvider를 대체합니다.</li>
<li>AsyncNotifier: 이는 비동기 변경에 사용되며, FutureProvider를 대체합니다. 2024년 6월 19일 현재, StreamProvider를 대체할 대안이 없습니다.</li>
</ul>
<p>이전에 언급한 대로, 생성기를 사용하여 우리의 프로바이더를 만들기도 할 겁니다. 생성기는 새로운 프로바이더 구문을 지원합니다 (StreamProviders를 제외하고). 또한 AutoDisposeProviders를 지원합니다. @riverpod 어노테이션을 사용하여 생성기에게 다음 함수를 프로바이더로 만들라고 알립니다.</p>
<p>새로운 프로바이더에 대해 익숙해졌으니, 생성기를 사용하여 어떻게 앱에서 사용할 지 살펴봅시다.</p>
<h1>시작하기</h1>
<p>가장 중요한 것은 앱에 Riverpod 2.0 패키지를 설치하는 것입니다. pubspec.yaml 파일에 다음 줄을 추가하세요.</p>
<pre><code class="hljs language-yaml"><span class="hljs-comment"># pubspec.yaml</span>

<span class="hljs-attr">dependencies:</span>
  <span class="hljs-attr">flutter_riverpod:</span> <span class="hljs-string">^2.1.3</span>
  <span class="hljs-attr">riverpod_annotation:</span> <span class="hljs-string">^1.1.1</span>
<span class="hljs-attr">dev_dependencies:</span>
  <span class="hljs-attr">build_runner:</span>
  <span class="hljs-attr">riverpod_generator:</span> <span class="hljs-string">^1.1.1</span>
</code></pre>
<h1>HelloWorld Provider 생성</h1>
<p>이제 가장 기본적인 provider 스타일을 만들고 사용하는 방법을 보여주는 다음 코드 조각을 살펴봅시다.</p>
<pre><code class="hljs language-dart"><span class="hljs-comment">// main.dart</span>

<span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter/material.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter_riverpod/flutter_riverpod.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:riverpod_annotation/riverpod_annotation.dart'</span>;
<span class="hljs-comment">// 생성기는 provider가 포함된 파일을 생성합니다. 전형적으로 "&#x3C;filename>.g.dart" 구문을 따르도록 합니다.</span>
<span class="hljs-comment">// 또한 import 문 이후에 코드를 작성하는 것이 좋습니다.</span>
<span class="hljs-keyword">part</span> <span class="hljs-string">'main.g.dart'</span>;

<span class="hljs-comment">// 단순히 메서드를 생성하고 "@riverpod"로 주석을 달아 provider를 만듭니다.</span>
<span class="hljs-comment">// "HelloWorldRef" 객체를 생성하는 방법에 유의하세요.</span>
<span class="hljs-comment">// 이 객체는 아직 존재하지 않지만 "dart run build_runner watch" 명령을 실행하면 생성됩니다.</span>
<span class="hljs-meta">@riverpod</span>
<span class="hljs-built_in">String</span> helloWorld(HelloWorldRef ref) {
  <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello world'</span>;
}

<span class="hljs-comment">// provider를 사용하기 위해서는 동기식 provider를 사용하는 방식과 동일한 방식으로 사용합니다.</span>
<span class="hljs-keyword">void</span> main() {
  runApp(
    <span class="hljs-comment">// 앱의 모든 provider 상태는 ProviderScope 내에 저장됩니다.</span>
    <span class="hljs-comment">// provider를 읽기 위해서는 이를 반드시 포함해야 합니다.</span>
    ProviderScope(
      child: MyApp(),
    ),
  );
}

<span class="hljs-comment">// Riverpod는 Stateless와 Stateful 위젯과 유사한 ConsumerWidget 및 ConsumerStatefulWidget 클래스 액세스를 제공합니다.</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConsumerWidget</span> </span>{
  <span class="hljs-comment">// ConsumerWidget의 build 메서드가 WidgetRef 객체를 가져오는 방식에 유의하세요.</span>
  <span class="hljs-comment">// WidgetRef는 provider를 읽는 데 사용됩니다.</span>
  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context, WidgetRef ref) {
    <span class="hljs-comment">// provider를 읽는 두 가지 방법이 있습니다.</span>
    <span class="hljs-comment">// 값을 읽고 변경 사항을 감시하려면 ref.watch(...)를 사용하고,</span>
    <span class="hljs-comment">// 함수를 호출하려면 ref.read(...)를 사용합니다.</span>
    <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> val = ref.watch(helloWorldProvider);
    <span class="hljs-keyword">return</span> MaterialApp(
      home: Scaffold(
        appBar: AppBar(title: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">'Hello World Example'</span>)),
        body: Center(
          child: Text(val),
        ),
      ),
    );
  }
}
</code></pre>
<ul>
<li>제너레이터는 프로바이더가 포함된 파일을 생성합니다. 일반적으로 이 구문을 따르도록 하려면 <code>filename</code>.g.dart 형식을 따르길 원합니다. 그리고 import 문 이후에 이를 유지하는 것이 좋습니다. 이 부분은 파일이 서로 관련되어 있음을 Dart에게 알려주는 부분입니다.</li>
<li>프로바이더를 만들기 위해서는 단순히 메서드를 만들고 이를 “@riverpod”으로 주석 처리하여 우리의 프로바이더를 생성합니다. "HelloWorldRef" 객체를 만든 방법에 주목해보세요. 아직 존재하지는 않지만 우리가 터미널에서 dart run build_runner watch 명령을 실행하면 생성될 것입니다. 따라서 해당 명령을 실행하고 <code>filename</code>.g.dart라는 파일을 생성하고 생성 중 발생한 오류를 해결하세요. 해당 파일은 다음과 같습니다:</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// GENERATED CODE - DO NOT MODIFY BY HAND</span>

part <span class="hljs-keyword">of</span> <span class="hljs-string">'main.dart'</span>;
<span class="hljs-comment">// **************************************************************************</span>
<span class="hljs-comment">// RiverpodGenerator</span>
<span class="hljs-comment">// **************************************************************************</span>
<span class="hljs-comment">// ignore_for_file: avoid_private_typedef_functions, non_constant_identifier_names, subtype_of_sealed_class, invalid_use_of_internal_member, unused_element, constant_identifier_names, unnecessary_raw_strings, library_private_types_in_public_api</span>
<span class="hljs-comment">/// Dart SDK에서 복사함</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">_SystemHash</span> {
  _SystemHash.<span class="hljs-title function_">_</span>();
  <span class="hljs-keyword">static</span> int <span class="hljs-title function_">combine</span>(<span class="hljs-params">int hash, int value</span>) {
    <span class="hljs-comment">// ignore: parameter_assignments</span>
    hash = <span class="hljs-number">0x1fffffff</span> &#x26; (hash + value);
    <span class="hljs-comment">// ignore: parameter_assignments</span>
    hash = <span class="hljs-number">0x1fffffff</span> &#x26; (hash + ((<span class="hljs-number">0x0007ffff</span> &#x26; hash) &#x3C;&#x3C; <span class="hljs-number">10</span>));
    <span class="hljs-keyword">return</span> hash ^ (hash >> <span class="hljs-number">6</span>);
  }
  <span class="hljs-keyword">static</span> int <span class="hljs-title function_">finish</span>(<span class="hljs-params">int hash</span>) {
    <span class="hljs-comment">// ignore: parameter_assignments</span>
    hash = <span class="hljs-number">0x1fffffff</span> &#x26; (hash + ((<span class="hljs-number">0x03ffffff</span> &#x26; hash) &#x3C;&#x3C; <span class="hljs-number">3</span>));
    <span class="hljs-comment">// ignore: parameter_assignments</span>
    hash = hash ^ (hash >> <span class="hljs-number">11</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0x1fffffff</span> &#x26; (hash + ((<span class="hljs-number">0x00003fff</span> &#x26; hash) &#x3C;&#x3C; <span class="hljs-number">15</span>));
  }
}
<span class="hljs-title class_">String</span> $helloWorldHash() => r<span class="hljs-string">'8bbe6cff2b7b1f4e1f7be3d1820da793259f7bfc'</span>;
<span class="hljs-comment">/// [helloWorld]도 참고하세요.</span>
final helloWorldProvider = <span class="hljs-title class_">AutoDisposeProvider</span>&#x3C;<span class="hljs-title class_">String</span>>(
  helloWorld,
  <span class="hljs-attr">name</span>: r<span class="hljs-string">'helloWorldProvider'</span>,
  <span class="hljs-attr">debugGetCreateSourceHash</span>:
      <span class="hljs-keyword">const</span> bool.<span class="hljs-title function_">fromEnvironment</span>(<span class="hljs-string">'dart.vm.product'</span>) ? <span class="hljs-literal">null</span> : $helloWorldHash,
);
typedef <span class="hljs-title class_">HelloWorldRef</span> = <span class="hljs-title class_">AutoDisposeProviderRef</span>&#x3C;<span class="hljs-title class_">String</span>>;
</code></pre>
<ul>
<li>생성된 프로바이더가 AutoDisposeProvider인 것을 주목하세요. 이는 상태가 없는 데이터와 유사하기 때문입니다.</li>
<li>파일을 저장한 후, dart run build_runner watch가 실행 중인 한 모든 생성된 프로바이더가 다시 생성됩니다.</li>
</ul>
<h1>위젯 트리 어디서든 프로바이더에 접근하기</h1>
<p>이제 당신은 앱 내에서 제공 업체의 데이터를 어디서든 읽을 수 있는지 궁금해 할 수도 있습니다. 이를 제공 업체 소비하기라고하며, 이를 위해 ref.watch(…) 메서드를 호출하는 WidgetRef 개체를 사용해야합니다. 위젯의 특정 부분만 제공 업체에 액세스해야하는 경우 Consumer 클래스를 사용할 수 있습니다.</p>
<p>다음은 Consumer 클래스를 사용한 예시입니다.</p>
<pre><code class="hljs language-dart"><span class="hljs-comment">// main.dart</span>

<span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter/material.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter_riverpod/flutter_riverpod.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:riverpod_annotation/riverpod_annotation.dart'</span>;

<span class="hljs-keyword">part</span> <span class="hljs-string">'main.g.dart'</span>;

<span class="hljs-meta">@riverpod</span>
<span class="hljs-built_in">String</span> helloWorld(HelloWorldRef ref) {
  <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello world'</span>;
}

<span class="hljs-keyword">void</span> main() {
  runApp(
    ProviderScope(
      child: MyApp(),
    ),
  );
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context, WidgetRef ref) {
    <span class="hljs-keyword">return</span> MaterialApp(
      home: Scaffold(
        appBar: AppBar(title: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">'Hello World Example'</span>)),
        body: Center(
          child: Consumer(
            builder: (context, ref, child) {
              <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> val = ref.watch(helloWorldProvider);
              <span class="hljs-comment">// Consumer has a return type of Widget.</span>
              <span class="hljs-comment">// Almost like using a Builder widget, but Riverpodified :)</span>
              <span class="hljs-keyword">return</span> Text(val);
            },
        ),
      ),
    );
  }
}
</code></pre>
<h1>변수에 반응형 상태 추가하기</h1>
<p>더 복잡한 제공자 예제를 살펴봅시다. 클래스를 사용하는 것과 같은 예제입니다. 이는 체크박스 부울 값이나 요소 목록과 같은 반응성 상태가 필요한 변수가 있는 경우 유용할 수 있습니다.</p>
<p>다음 예제에서는 클래스를 사용하여 변수의 저장소로 사용하고 제공자로 변환하는 방법을 보여줍니다.</p>
<pre><code class="hljs language-js">@riverpod
<span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">_$HelloWorld</span> {
  <span class="hljs-title class_">String</span> <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"hello world"</span>;
  }

  <span class="hljs-keyword">void</span> <span class="hljs-title function_">toCamelCase</span>(<span class="hljs-params"></span>) {
      <span class="hljs-comment">// 변수 상태를 사용하여 제공자의 현재 상태에 액세스하는 방법에 주목해주세요.</span>
      state = <span class="hljs-string">'${state[0].toUpperCase()}${state.substring(1).toLowerCase()}'</span>;
  }
}

ref.<span class="hljs-title function_">watch</span>(helloWorldProvider); <span class="hljs-comment">// hello world</span>
ref.<span class="hljs-title function_">watch</span>(helloWorldProvider.<span class="hljs-property">notifier</span>).<span class="hljs-title function_">toCamelCase</span>();
ref.<span class="hljs-title function_">watch</span>(helloWorldProvider); <span class="hljs-comment">// Hello World</span>
</code></pre>
<p>이 예제에서는 우리의 클래스가 _$<code>클래스명</code>을 확장하고 제공자로 변환되어야 한다는 것을 riverpod에게 알려주기 위해 위에 riverpod 주석이 달렸습니다. 참고: 클래스로 만든 모든 제공자는 build() 메서드가 필요합니다. 이곳이 제공자의 초기 상태를 구성하는 곳입니다.</p>
<p>제공자를 사용하는 것은 이전에 언급한 예제들만큼 간단합니다: 단순히 ref.watch(<code>생성된 제공자 이름</code>)을 호출하면 앱이 변경 사항을 감시합니다. 그리고 클래스의 접근자 메서드를 사용하려면 ref.watch(<code>생성된 제공자 이름</code>.notifier).<code>메서드 이름</code>()을 호출해야 합니다. .notifier를 꼭 포함하도록 하세요.</p>
<h1>제공자의 현재 값 변경하기</h1>
<p>이제 제공자 내의 현재 값을 변경하려면 클래스 내에 생성자를 사용하고 약간 수정해야 합니다. 즐겨 사용하는 단어 목록을 살펴보겠습니다.</p>
<pre><code class="hljs language-js">@riverpod
<span class="hljs-keyword">class</span> <span class="hljs-title class_">FavoriteWordsRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">_$FavoriteWordsRepository</span> {
  <span class="hljs-title class_">FavoriteWordsRepository</span>(<span class="hljs-title class_">List</span>&#x3C;<span class="hljs-title class_">String</span>> favoriteWords) {
    words = favoriteWords;
  }

  <span class="hljs-title class_">List</span>&#x3C;<span class="hljs-title class_">String</span>> words = [];

  @override
  <span class="hljs-title class_">List</span>&#x3C;<span class="hljs-title class_">String</span>> <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> words;
  }
}
</code></pre>
<p>main.g.dart 파일에서 FavoriteWordsRepository.new를 사용할 수 없다는 오류가 발생할 수 있습니다. 이 간단한 수정으로 해결할 수 있습니다:</p>
<pre><code class="hljs language-js">final favoriteWordsRepositoryProvider =
    <span class="hljs-title class_">AutoDisposeAsyncNotifierProvider</span>&#x3C;<span class="hljs-title class_">FavoriteWordsRepository</span>, <span class="hljs-title class_">List</span>&#x3C;<span class="hljs-title class_">String</span>>>(
  <span class="hljs-function">() =></span> <span class="hljs-title class_">FavoriteWordsRepository</span>([]), <span class="hljs-comment">// FavoriteWordsRepository.new --> () => FavoriteWordsRepository([])</span>
</code></pre>
<p>이것을 값으로 리스트를 초기화하는 것과 혼동하지 마세요. 이것은 단순히 시작점일 뿐이고 실제로 초기화된 리스트는 List<code>String</code> words = []; 입니다.</p>
<p>그리고 위젯 코드 내에서 provider의 상태를 다음과 같이 업데이트할 수 있습니다:</p>
<pre><code class="hljs language-js">ref.<span class="hljs-title function_">watch</span>(favoriteWordsRepositoryProvider.<span class="hljs-property">notifier</span>).<span class="hljs-property">words</span> = [<span class="hljs-string">'Cars'</span>, <span class="hljs-string">'Dogs'</span>, <span class="hljs-string">'Flutter'</span>];
</code></pre>
<h1>비동기 공급자 생성</h1>
<p>지역 공급자 데이터 작업에 익숙해지면 futures를 다루는 방법도 알아봅시다! 아래 예시는 기본적인 future 공급자를 만드는 방법을 보여줍니다.</p>
<pre><code class="hljs language-js">@riverpod
<span class="hljs-title class_">Future</span>&#x3C;<span class="hljs-title class_">String</span>> <span class="hljs-title function_">helloWorldFuture</span>(<span class="hljs-title class_">HelloWorldFutureRef</span> ref) <span class="hljs-keyword">async</span> {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">await</span> <span class="hljs-title class_">Future</span>.<span class="hljs-title function_">delayed</span>(<span class="hljs-keyword">const</span> <span class="hljs-title class_">Duration</span>(<span class="hljs-attr">seconds</span>: <span class="hljs-number">3</span>));
    <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello World'</span>;
  } <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-comment">// 이 함수는 오류를 발생시킬 수 없습니다.</span>
    <span class="hljs-comment">// futures에 대한 Try/Catch 블록은 좋은 실천법입니다 :)</span>
    rethrow;
  }
}
</code></pre>
<p>우리의 함수는 다시 HelloWorldFutureRef를 가져와야 합니다. 이것은 단일 공급자에서 여러 제공자를 사용하는 데에 사용됩니다. 다음은 dio: ^4.0.6을 사용하여 예제 API에 HTTP 요청을하는 예제입니다:</p>
<pre><code class="hljs language-dart"><span class="hljs-comment">// dio_provider.dart</span>

<span class="hljs-keyword">import</span> <span class="hljs-string">'package:dio/dio.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter_riverpod/flutter_riverpod.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:riverpod_annotation/riverpod_annotation.dart'</span>;
<span class="hljs-keyword">part</span> <span class="hljs-string">'dio_provider.g.dart'</span>;

<span class="hljs-meta">@riverpod</span>
Dio dio(DioRef ref, {<span class="hljs-built_in">Map</span>&#x3C;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>>? headers, <span class="hljs-built_in">String?</span> subDomain}) {
  <span class="hljs-keyword">return</span> Dio(BaseOptions(baseUrl: <span class="hljs-string">'https://api.example.com'</span>, headers: headers));
}
</code></pre>
<p>그리고 우리의 공급자에서 액세스하는 방법은 다음과 같습니다:</p>
<pre><code class="hljs language-dart"><span class="hljs-comment">// greeting_service.dart</span>

<span class="hljs-keyword">import</span> <span class="hljs-string">'dio_provider.dart'</span>;
<span class="hljs-meta">@riverpod</span>
Future&#x3C;<span class="hljs-built_in">String</span>> getGreeting(GetGreetingRef ref, {<span class="hljs-keyword">required</span> <span class="hljs-built_in">String</span> name}) <span class="hljs-keyword">async</span> {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">final</span> response = <span class="hljs-keyword">await</span> ref.watch(dioProvider()).<span class="hljs-keyword">get</span>(<span class="hljs-string">'/greeting'</span>);
    <span class="hljs-keyword">final</span> result = response.data;
    <span class="hljs-keyword">final</span> greeting = result + <span class="hljs-string">', '</span> + name;
    <span class="hljs-keyword">return</span> greeting; <span class="hljs-comment">// Hello there, Carlton</span>
  } <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-keyword">rethrow</span>;
  }
}
</code></pre>
<p>다른 공급자를 사용해 공급자를 <code>.family</code>로 만들어요.</p>
<h1>build 메서드에 인수 전달하기</h1>
<p>Riverpod은 초기화할 때 build 메서드로 인수를 전달할 수 있게 해줘요. 이를 코드에서 어떻게 할 수 있는지 알아볼게요.</p>
<pre><code class="hljs language-js">@riverpod
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">_$MyRepository</span> {
  @override
  <span class="hljs-comment">// 여기에 위치 인수를 추가하세요. 이름 지정도 가능해요.</span>
  <span class="hljs-title class_">Future</span>&#x3C;<span class="hljs-title class_">String</span>> <span class="hljs-title function_">build</span>(<span class="hljs-title class_">String</span> id, {bool value}) <span class="hljs-keyword">async</span> {
    final <span class="hljs-title class_">String</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">myFuture</span>(id, value);
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">anotherFutureThatReturnsAString</span>(result);
  }
  <span class="hljs-comment">// ...</span>
}
</code></pre>
<h1>AsyncProvider를 사용하는 방법</h1>
<p>AsyncProvider를 사용하는 방법은 로컬 공급자를 사용하는 방법과 다르며 데이터와 상호 작용하는 방식이 변경됩니다. 주의 깊게 살펴보세요, 이것은 매우 중요합니다!</p>
<p>UI에서 공급자를 사용하려면 .when() 구문을 사용해야 합니다. 이 구문에는 3가지 다른 상태가 포함되어 있습니다: 데이터(완료), 로딩, 오류. ConnectionState를 확인하고 해당 위젯을 반환하는 것의 번거로움을 제거하기 때문에 FutureBuilders를 이것으로 교체할 수 있습니다. 아래는 완전한 앱의 예시를 살펴봅시다:</p>
<p>초기 앱 만들기</p>
<pre><code class="hljs language-dart"><span class="hljs-comment">// main.dart</span>

<span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter/material.dart'</span>;

<span class="hljs-keyword">void</span> main() {
  runApp(<span class="hljs-keyword">const</span> MyApp());
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-keyword">const</span> MyApp({Key? key});

  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">const</span> ProviderScope(
      child: MaterialApp(
        home: MyHomePage(),
      ),
    );
  }
}
</code></pre>
<p>Creating foo class and provider</p>
<pre><code class="hljs language-dart"><span class="hljs-comment">// foo.dart</span>

<span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter_riverpod/flutter_riverpod.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:riverpod_annotation/riverpod_annotation.dart'</span>;

<span class="hljs-keyword">part</span> <span class="hljs-string">'foo.g.dart'</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>{
  <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> bar;
  <span class="hljs-built_in">int?</span> baz;

  Foo(
    <span class="hljs-keyword">this</span>.bar, {
    <span class="hljs-keyword">this</span>.baz,
  });
}

<span class="hljs-meta">@riverpod</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FooController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">_</span>$<span class="hljs-title">FooController</span> </span>{
  FooController(<span class="hljs-keyword">this</span>.foo);
  Foo foo;

  <span class="hljs-meta">@override</span>
  FutureOr&#x3C;Foo> build() <span class="hljs-keyword">async</span> {
    foo = <span class="hljs-keyword">await</span> getFoo();
    <span class="hljs-keyword">return</span> foo;
  }

  Future&#x3C;Foo> getFoo() <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">await</span> Future.delayed(<span class="hljs-keyword">const</span> <span class="hljs-built_in">Duration</span>(seconds: <span class="hljs-number">1</span>));
    <span class="hljs-keyword">return</span> Foo(<span class="hljs-number">1</span>);
  }
}
</code></pre>
<p>Consuming foo provider</p>
<pre><code class="hljs language-dart"></code></pre>
<pre><code class="hljs language-dart"><span class="hljs-comment">// home.dart</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHomePage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-keyword">const</span> MyHomePage({key});

  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-keyword">return</span> Scaffold(
      appBar: AppBar(),
      body: Consumer(
        builder: (context, ref, _) {
          <span class="hljs-comment">// Provider를 얻어와서 watch합니다</span>
          <span class="hljs-keyword">final</span> fooAsync = ref.watch(fooControllerProvider);
          <span class="hljs-comment">// .when을 사용하여 Future로부터 UI를 렌더링합니다</span>
          <span class="hljs-keyword">return</span> fooAsync.<span class="hljs-keyword">when</span>(
            data: (foo) => Text(<span class="hljs-string">'bar: <span class="hljs-subst">${foo.bar}</span>, baz: <span class="hljs-subst">${foo.baz}</span>'</span>),
            loading: () => <span class="hljs-keyword">const</span> CircularProgressIndicator(),
            error: (err, stack) => Text(err.toString()),
          );
        },
      ),
    );
  }
}
</code></pre>
<p>이 예시에서는 Consumer 위젯을 사용하여 ref에 액세스하므로 ref.watch(fooControllerProvider)를 호출하여 AsyncData 유형을 반환할 수 있습니다. 그런 다음 .when(…) 함수가 제공하는 속성을 사용하여 UI를 매우 깨끗하고 관리하기 쉬운 형식으로 구성할 수 있습니다.</p>
<p>이 작업은 생성된 파일에서 provider의 초기값을 설정해야 합니다.</p>
<pre><code class="hljs language-dart"><span class="hljs-keyword">final</span> fooControllerProvider = AutoDisposeAsyncNotifierProvider&#x3C;FooController, Foo>(
  () => FooController(Foo(<span class="hljs-number">1</span>)), <span class="hljs-comment">// FooController.new --> FooController(Foo(1))</span>
  name: <span class="hljs-string">r'fooControllerProvider'</span>,
  debugGetCreateSourceHash: <span class="hljs-keyword">const</span> <span class="hljs-built_in">bool</span>.fromEnvironment(<span class="hljs-string">'dart.vm.product'</span>) ? <span class="hljs-keyword">null</span> : $FooControllerHash,
);
</code></pre>
<h1>AsyncProvider의 현재 상태를 개체/가공 가능한 데이터처럼 가져오는 방법</h1>
<p>현재 방법은 API 데이터에 빠르게 액세스하는 데 유용하지만 문제가 발생합니다. 미래 Provider 내부의 데이터를 어떻게 가공 가능한 데이터처럼 액세스할 수 있을까요? API에서 사용자 데이터를 요청하고, 사용자 설정에서 사용자의 이름을 업데이트하고 싶다고 가정해 봅시다. 우리는 ref.watch(<code>YourFutureProvider</code>)가 User 클래스가 아닌 AsyncData 유형을 반환하기 때문에 이렇게 할 수 없습니다. 일부 데이터를 알고 싶을 때마다 GET 요청을 완료하고 싶지 않으며, 특히 첫 번째로로드되고 사용 가능한 경우입니다. 두 Provider를 만들어야할 것으로 생각할 수 있지만, 하나는 AsyncProvider이고, 하나는 NotifierProvider로 대화해야 한다면 그것은 비효율적입니다. 다행히도 이를 처리하는 방법이 있습니다.</p>
<p>다음 코드는 AsyncProvider를 사용하고 로드된 데이터를 NotifierProvider처럼 사용하는 방법을 보여줍니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// home.dart</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyHomePage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">StatelessWidget</span> {
  <span class="hljs-keyword">const</span> <span class="hljs-title class_">MyHomePage</span>({<span class="hljs-variable language_">super</span>.<span class="hljs-property">key</span>});

  @override
  <span class="hljs-title class_">Widget</span> <span class="hljs-title function_">build</span>(<span class="hljs-params">BuildContext context</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Scaffold</span>(
      <span class="hljs-attr">appBar</span>: <span class="hljs-title class_">AppBar</span>(),
      <span class="hljs-attr">body</span>: <span class="hljs-title class_">Consumer</span>(
        <span class="hljs-attr">builder</span>: (context, ref, _) {
          <span class="hljs-comment">// Foo Provider를 가져와 상태를 설정합니다.</span>
          <span class="hljs-comment">// State Provider처럼 사용합니다.</span>
          ref.<span class="hljs-title function_">watch</span>(fooControllerProvider.<span class="hljs-property">notifier</span>).<span class="hljs-property">foo</span> = <span class="hljs-title class_">Foo</span>(<span class="hljs-number">3</span>);
          <span class="hljs-comment">// UI에서 Foo 사용 (.requireValue는 변경 사항을 청취할 수 있도록 사용됨)</span>
          final foo = ref.<span class="hljs-title function_">watch</span>(fooControllerProvider).<span class="hljs-property">requireValue</span>;
          <span class="hljs-comment">// .when을 사용하여 미래에서 UI를 렌더링합니다.</span>
          <span class="hljs-keyword">return</span> <span class="hljs-title class_">Text</span>(<span class="hljs-string">'bar: ${foo.bar}, baz: ${foo.baz}'</span>);
        },
      ),
    );
  }
}
</code></pre>
<h1>결론</h1>
<p>Riverpod는 플러터에서 상태 관리의 가장 추천되는 방법으로 나타났으며 완전히 반응적인 상태 프레임워크로 발전했습니다.</p>
<p>나중에 Provider와 같은 다른 패키지는 더 이상 유지되지 않을 수 있으므로 Riverpod를 배우는 것이 중요합니다 (물론 먼 훗날입니다). 또한 Riverpod는 새로운 제너레이터 덕분에 상태를 효과적으로 관리할 수 있는 유연성과 제어성을 제공하여 build_runner를 사용해 강력하고 메모리를 고려한 프로바이더를 쉽게 만들 수 있습니다.</p>
<p>이 글을 만드는 과정에서 도움이 된 멋진 자료를 제공해 준 다음 분들께 큰 박수를 보냅니다. 🎉</p>
<ul>
<li>CodeWithAndrea</li>
<li>Adnanjpg</li>
<li>rrouselgit</li>
</ul>
<p>이 글이 도움이 되셨기를 바랍니다. 만약 도움이 되었다면, 더 많은 튜토리얼, 경험, 그리고 안내서가 포함된 다른 글도 자유롭게 읽어보세요!</p>
<p>하나님을 신뢰합니다 🙏🏾</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Flutter 프로젝트에서 Riverpod 20  Generator 사용법","description":"","date":"2024-06-21 20:19","slug":"2024-06-21-HowtouseRiverpod20GeneratorinyourFlutterProject","content":"\n\n\u003cimg src=\"/assets/img/2024-06-21-HowtouseRiverpod20GeneratorinyourFlutterProject_0.png\" /\u003e\n\nRiverpod은 플러터(Flutter)에서 상태 관리 및 반응형 데이터 캐싱의 새로운 표준입니다. 두 번째 버전인 Riverpod 2.0은 꽤 오랫동안 출시되었지만, 새로운 데이터 관리 방법과 컨셉을 이해하기 어려울 수 있습니다.\n\n# 우리가 배울 내용\n\n- Riverpod 2.0의 새로운 프로바이더로 기존 프로바이더를 업데이트하는 방법.\n- 앱 내에서 상태를 새로운 방식으로 관리하는 방법.\n- Riverpod 2.0에서 퓨처(futures)를 다루는 방법.\n- 프로바이더를 자동으로 생성하고 프로바이더 생성 프로세스를 간소화하는 방법.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n시작하기 전에, Riverpod가 무엇을 할 수 있는지 알아보아야 합니다. Riverpod는 상태를 관리하기 위해 providers라는 것을 사용하며, 다음은 2.0 이전에 존재했던 providers입니다. 다양한 유형의 providers를 빠르게 살펴보겠습니다:\n\n- Provider: 이 provider는 값을 생성합니다. 반응적 상태나 메모리가 없기 때문에 대부분의 경우에 최적이 아니지만, 많은 정적 메소드를 가진 클래스나 접근하려는 종속성이 있는 경우 유용합니다.\n- ChangeNotifierProvider, StateNotifierProvider, StateProvider: 이들은 앱 내부에서 로컬 상태를 생성, 액세스 및 캐싱하는 데 도움을 줍니다. 모두 반응적인 변경을 지원합니다.\n- FutureProvider, StreamProvider: 이들은 앱 내에서 비동기 데이터를 캐싱하고 액세스하는 데 도움을 줍니다.\n\nRiverpod 2.0에서는 이러한 모든 providers를 대체하는 2개의 providers가 있습니다... 하나만 제외하고요.\n\n- NotifierProvider: 이는 변경 알림/동기 변경에 사용되며, ChangeNotifierProvider, StateNotifierProvider, StateProvider를 대체합니다.\n- AsyncNotifier: 이는 비동기 변경에 사용되며, FutureProvider를 대체합니다. 2024년 6월 19일 현재, StreamProvider를 대체할 대안이 없습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이전에 언급한 대로, 생성기를 사용하여 우리의 프로바이더를 만들기도 할 겁니다. 생성기는 새로운 프로바이더 구문을 지원합니다 (StreamProviders를 제외하고). 또한 AutoDisposeProviders를 지원합니다. @riverpod 어노테이션을 사용하여 생성기에게 다음 함수를 프로바이더로 만들라고 알립니다.\n\n새로운 프로바이더에 대해 익숙해졌으니, 생성기를 사용하여 어떻게 앱에서 사용할 지 살펴봅시다.\n\n# 시작하기\n\n가장 중요한 것은 앱에 Riverpod 2.0 패키지를 설치하는 것입니다. pubspec.yaml 파일에 다음 줄을 추가하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```yaml\n# pubspec.yaml\n\ndependencies:\n  flutter_riverpod: ^2.1.3\n  riverpod_annotation: ^1.1.1\ndev_dependencies:\n  build_runner:\n  riverpod_generator: ^1.1.1\n```\n\n# HelloWorld Provider 생성\n\n이제 가장 기본적인 provider 스타일을 만들고 사용하는 방법을 보여주는 다음 코드 조각을 살펴봅시다.\n\n```dart\n// main.dart\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:riverpod_annotation/riverpod_annotation.dart';\n// 생성기는 provider가 포함된 파일을 생성합니다. 전형적으로 \"\u003cfilename\u003e.g.dart\" 구문을 따르도록 합니다.\n// 또한 import 문 이후에 코드를 작성하는 것이 좋습니다.\npart 'main.g.dart';\n\n// 단순히 메서드를 생성하고 \"@riverpod\"로 주석을 달아 provider를 만듭니다.\n// \"HelloWorldRef\" 객체를 생성하는 방법에 유의하세요.\n// 이 객체는 아직 존재하지 않지만 \"dart run build_runner watch\" 명령을 실행하면 생성됩니다.\n@riverpod\nString helloWorld(HelloWorldRef ref) {\n  return 'Hello world';\n}\n\n// provider를 사용하기 위해서는 동기식 provider를 사용하는 방식과 동일한 방식으로 사용합니다.\nvoid main() {\n  runApp(\n    // 앱의 모든 provider 상태는 ProviderScope 내에 저장됩니다.\n    // provider를 읽기 위해서는 이를 반드시 포함해야 합니다.\n    ProviderScope(\n      child: MyApp(),\n    ),\n  );\n}\n\n// Riverpod는 Stateless와 Stateful 위젯과 유사한 ConsumerWidget 및 ConsumerStatefulWidget 클래스 액세스를 제공합니다.\nclass MyApp extends ConsumerWidget {\n  // ConsumerWidget의 build 메서드가 WidgetRef 객체를 가져오는 방식에 유의하세요.\n  // WidgetRef는 provider를 읽는 데 사용됩니다.\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // provider를 읽는 두 가지 방법이 있습니다.\n    // 값을 읽고 변경 사항을 감시하려면 ref.watch(...)를 사용하고,\n    // 함수를 호출하려면 ref.read(...)를 사용합니다.\n    final String val = ref.watch(helloWorldProvider);\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Hello World Example')),\n        body: Center(\n          child: Text(val),\n        ),\n      ),\n    );\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 제너레이터는 프로바이더가 포함된 파일을 생성합니다. 일반적으로 이 구문을 따르도록 하려면 `filename`.g.dart 형식을 따르길 원합니다. 그리고 import 문 이후에 이를 유지하는 것이 좋습니다. 이 부분은 파일이 서로 관련되어 있음을 Dart에게 알려주는 부분입니다.\n- 프로바이더를 만들기 위해서는 단순히 메서드를 만들고 이를 “@riverpod”으로 주석 처리하여 우리의 프로바이더를 생성합니다. \"HelloWorldRef\" 객체를 만든 방법에 주목해보세요. 아직 존재하지는 않지만 우리가 터미널에서 dart run build_runner watch 명령을 실행하면 생성될 것입니다. 따라서 해당 명령을 실행하고 `filename`.g.dart라는 파일을 생성하고 생성 중 발생한 오류를 해결하세요. 해당 파일은 다음과 같습니다:\n\n```js\n// GENERATED CODE - DO NOT MODIFY BY HAND\n\npart of 'main.dart';\n// **************************************************************************\n// RiverpodGenerator\n// **************************************************************************\n// ignore_for_file: avoid_private_typedef_functions, non_constant_identifier_names, subtype_of_sealed_class, invalid_use_of_internal_member, unused_element, constant_identifier_names, unnecessary_raw_strings, library_private_types_in_public_api\n/// Dart SDK에서 복사함\nclass _SystemHash {\n  _SystemHash._();\n  static int combine(int hash, int value) {\n    // ignore: parameter_assignments\n    hash = 0x1fffffff \u0026 (hash + value);\n    // ignore: parameter_assignments\n    hash = 0x1fffffff \u0026 (hash + ((0x0007ffff \u0026 hash) \u003c\u003c 10));\n    return hash ^ (hash \u003e\u003e 6);\n  }\n  static int finish(int hash) {\n    // ignore: parameter_assignments\n    hash = 0x1fffffff \u0026 (hash + ((0x03ffffff \u0026 hash) \u003c\u003c 3));\n    // ignore: parameter_assignments\n    hash = hash ^ (hash \u003e\u003e 11);\n    return 0x1fffffff \u0026 (hash + ((0x00003fff \u0026 hash) \u003c\u003c 15));\n  }\n}\nString $helloWorldHash() =\u003e r'8bbe6cff2b7b1f4e1f7be3d1820da793259f7bfc';\n/// [helloWorld]도 참고하세요.\nfinal helloWorldProvider = AutoDisposeProvider\u003cString\u003e(\n  helloWorld,\n  name: r'helloWorldProvider',\n  debugGetCreateSourceHash:\n      const bool.fromEnvironment('dart.vm.product') ? null : $helloWorldHash,\n);\ntypedef HelloWorldRef = AutoDisposeProviderRef\u003cString\u003e;\n```\n\n- 생성된 프로바이더가 AutoDisposeProvider인 것을 주목하세요. 이는 상태가 없는 데이터와 유사하기 때문입니다.\n- 파일을 저장한 후, dart run build_runner watch가 실행 중인 한 모든 생성된 프로바이더가 다시 생성됩니다.\n\n# 위젯 트리 어디서든 프로바이더에 접근하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 당신은 앱 내에서 제공 업체의 데이터를 어디서든 읽을 수 있는지 궁금해 할 수도 있습니다. 이를 제공 업체 소비하기라고하며, 이를 위해 ref.watch(…) 메서드를 호출하는 WidgetRef 개체를 사용해야합니다. 위젯의 특정 부분만 제공 업체에 액세스해야하는 경우 Consumer 클래스를 사용할 수 있습니다.\n\n다음은 Consumer 클래스를 사용한 예시입니다.\n\n```dart\n// main.dart\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:riverpod_annotation/riverpod_annotation.dart';\n\npart 'main.g.dart';\n\n@riverpod\nString helloWorld(HelloWorldRef ref) {\n  return 'Hello world';\n}\n\nvoid main() {\n  runApp(\n    ProviderScope(\n      child: MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Hello World Example')),\n        body: Center(\n          child: Consumer(\n            builder: (context, ref, child) {\n              final String val = ref.watch(helloWorldProvider);\n              // Consumer has a return type of Widget.\n              // Almost like using a Builder widget, but Riverpodified :)\n              return Text(val);\n            },\n        ),\n      ),\n    );\n  }\n}\n```\n\n# 변수에 반응형 상태 추가하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더 복잡한 제공자 예제를 살펴봅시다. 클래스를 사용하는 것과 같은 예제입니다. 이는 체크박스 부울 값이나 요소 목록과 같은 반응성 상태가 필요한 변수가 있는 경우 유용할 수 있습니다.\n\n다음 예제에서는 클래스를 사용하여 변수의 저장소로 사용하고 제공자로 변환하는 방법을 보여줍니다.\n\n```js\n@riverpod\nclass HelloWorld extends _$HelloWorld {\n  String build() {\n    return \"hello world\";\n  }\n\n  void toCamelCase() {\n      // 변수 상태를 사용하여 제공자의 현재 상태에 액세스하는 방법에 주목해주세요.\n      state = '${state[0].toUpperCase()}${state.substring(1).toLowerCase()}';\n  }\n}\n\nref.watch(helloWorldProvider); // hello world\nref.watch(helloWorldProvider.notifier).toCamelCase();\nref.watch(helloWorldProvider); // Hello World\n```\n\n이 예제에서는 우리의 클래스가 _$`클래스명`을 확장하고 제공자로 변환되어야 한다는 것을 riverpod에게 알려주기 위해 위에 riverpod 주석이 달렸습니다. 참고: 클래스로 만든 모든 제공자는 build() 메서드가 필요합니다. 이곳이 제공자의 초기 상태를 구성하는 곳입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제공자를 사용하는 것은 이전에 언급한 예제들만큼 간단합니다: 단순히 ref.watch(`생성된 제공자 이름`)을 호출하면 앱이 변경 사항을 감시합니다. 그리고 클래스의 접근자 메서드를 사용하려면 ref.watch(`생성된 제공자 이름`.notifier).`메서드 이름`()을 호출해야 합니다. .notifier를 꼭 포함하도록 하세요.\n\n# 제공자의 현재 값 변경하기\n\n이제 제공자 내의 현재 값을 변경하려면 클래스 내에 생성자를 사용하고 약간 수정해야 합니다. 즐겨 사용하는 단어 목록을 살펴보겠습니다.\n\n```js\n@riverpod\nclass FavoriteWordsRepository extends _$FavoriteWordsRepository {\n  FavoriteWordsRepository(List\u003cString\u003e favoriteWords) {\n    words = favoriteWords;\n  }\n\n  List\u003cString\u003e words = [];\n\n  @override\n  List\u003cString\u003e build() {\n    return words;\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nmain.g.dart 파일에서 FavoriteWordsRepository.new를 사용할 수 없다는 오류가 발생할 수 있습니다. 이 간단한 수정으로 해결할 수 있습니다:\n\n```js\nfinal favoriteWordsRepositoryProvider =\n    AutoDisposeAsyncNotifierProvider\u003cFavoriteWordsRepository, List\u003cString\u003e\u003e(\n  () =\u003e FavoriteWordsRepository([]), // FavoriteWordsRepository.new --\u003e () =\u003e FavoriteWordsRepository([])\n```\n\n이것을 값으로 리스트를 초기화하는 것과 혼동하지 마세요. 이것은 단순히 시작점일 뿐이고 실제로 초기화된 리스트는 List`String` words = []; 입니다.\n\n그리고 위젯 코드 내에서 provider의 상태를 다음과 같이 업데이트할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nref.watch(favoriteWordsRepositoryProvider.notifier).words = ['Cars', 'Dogs', 'Flutter'];\n```\n\n# 비동기 공급자 생성\n\n지역 공급자 데이터 작업에 익숙해지면 futures를 다루는 방법도 알아봅시다! 아래 예시는 기본적인 future 공급자를 만드는 방법을 보여줍니다.\n\n```js\n@riverpod\nFuture\u003cString\u003e helloWorldFuture(HelloWorldFutureRef ref) async {\n  try {\n    await Future.delayed(const Duration(seconds: 3));\n    return 'Hello World';\n  } catch (e) {\n    // 이 함수는 오류를 발생시킬 수 없습니다.\n    // futures에 대한 Try/Catch 블록은 좋은 실천법입니다 :)\n    rethrow;\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리의 함수는 다시 HelloWorldFutureRef를 가져와야 합니다. 이것은 단일 공급자에서 여러 제공자를 사용하는 데에 사용됩니다. 다음은 dio: ^4.0.6을 사용하여 예제 API에 HTTP 요청을하는 예제입니다:\n\n```dart\n// dio_provider.dart\n\nimport 'package:dio/dio.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:riverpod_annotation/riverpod_annotation.dart';\npart 'dio_provider.g.dart';\n\n@riverpod\nDio dio(DioRef ref, {Map\u003cString, dynamic\u003e? headers, String? subDomain}) {\n  return Dio(BaseOptions(baseUrl: 'https://api.example.com', headers: headers));\n}\n```\n\n그리고 우리의 공급자에서 액세스하는 방법은 다음과 같습니다:\n\n```dart\n// greeting_service.dart\n\nimport 'dio_provider.dart';\n@riverpod\nFuture\u003cString\u003e getGreeting(GetGreetingRef ref, {required String name}) async {\n  try {\n    final response = await ref.watch(dioProvider()).get('/greeting');\n    final result = response.data;\n    final greeting = result + ', ' + name;\n    return greeting; // Hello there, Carlton\n  } catch (e) {\n    rethrow;\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다른 공급자를 사용해 공급자를 `.family`로 만들어요.\n\n# build 메서드에 인수 전달하기\n\nRiverpod은 초기화할 때 build 메서드로 인수를 전달할 수 있게 해줘요. 이를 코드에서 어떻게 할 수 있는지 알아볼게요.\n\n```js\n@riverpod\nclass MyRepository extends _$MyRepository {\n  @override\n  // 여기에 위치 인수를 추가하세요. 이름 지정도 가능해요.\n  Future\u003cString\u003e build(String id, {bool value}) async {\n    final String result = await myFuture(id, value);\n    return anotherFutureThatReturnsAString(result);\n  }\n  // ...\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# AsyncProvider를 사용하는 방법\n\nAsyncProvider를 사용하는 방법은 로컬 공급자를 사용하는 방법과 다르며 데이터와 상호 작용하는 방식이 변경됩니다. 주의 깊게 살펴보세요, 이것은 매우 중요합니다!\n\nUI에서 공급자를 사용하려면 .when() 구문을 사용해야 합니다. 이 구문에는 3가지 다른 상태가 포함되어 있습니다: 데이터(완료), 로딩, 오류. ConnectionState를 확인하고 해당 위젯을 반환하는 것의 번거로움을 제거하기 때문에 FutureBuilders를 이것으로 교체할 수 있습니다. 아래는 완전한 앱의 예시를 살펴봅시다:\n\n초기 앱 만들기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\n// main.dart\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({Key? key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const ProviderScope(\n      child: MaterialApp(\n        home: MyHomePage(),\n      ),\n    );\n  }\n}\n```\n\nCreating foo class and provider\n\n```dart\n// foo.dart\n\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:riverpod_annotation/riverpod_annotation.dart';\n\npart 'foo.g.dart';\n\nclass Foo {\n  final int bar;\n  int? baz;\n\n  Foo(\n    this.bar, {\n    this.baz,\n  });\n}\n\n@riverpod\nclass FooController extends _$FooController {\n  FooController(this.foo);\n  Foo foo;\n\n  @override\n  FutureOr\u003cFoo\u003e build() async {\n    foo = await getFoo();\n    return foo;\n  }\n\n  Future\u003cFoo\u003e getFoo() async {\n    await Future.delayed(const Duration(seconds: 1));\n    return Foo(1);\n  }\n}\n```\n\nConsuming foo provider\n```dart\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\n// home.dart\n\nclass MyHomePage extends StatelessWidget {\n  const MyHomePage({key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(),\n      body: Consumer(\n        builder: (context, ref, _) {\n          // Provider를 얻어와서 watch합니다\n          final fooAsync = ref.watch(fooControllerProvider);\n          // .when을 사용하여 Future로부터 UI를 렌더링합니다\n          return fooAsync.when(\n            data: (foo) =\u003e Text('bar: ${foo.bar}, baz: ${foo.baz}'),\n            loading: () =\u003e const CircularProgressIndicator(),\n            error: (err, stack) =\u003e Text(err.toString()),\n          );\n        },\n      ),\n    );\n  }\n}\n```\n\n이 예시에서는 Consumer 위젯을 사용하여 ref에 액세스하므로 ref.watch(fooControllerProvider)를 호출하여 AsyncData 유형을 반환할 수 있습니다. 그런 다음 .when(…) 함수가 제공하는 속성을 사용하여 UI를 매우 깨끗하고 관리하기 쉬운 형식으로 구성할 수 있습니다.\n\n이 작업은 생성된 파일에서 provider의 초기값을 설정해야 합니다.\n\n```dart\nfinal fooControllerProvider = AutoDisposeAsyncNotifierProvider\u003cFooController, Foo\u003e(\n  () =\u003e FooController(Foo(1)), // FooController.new --\u003e FooController(Foo(1))\n  name: r'fooControllerProvider',\n  debugGetCreateSourceHash: const bool.fromEnvironment('dart.vm.product') ? null : $FooControllerHash,\n);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# AsyncProvider의 현재 상태를 개체/가공 가능한 데이터처럼 가져오는 방법\n\n현재 방법은 API 데이터에 빠르게 액세스하는 데 유용하지만 문제가 발생합니다. 미래 Provider 내부의 데이터를 어떻게 가공 가능한 데이터처럼 액세스할 수 있을까요? API에서 사용자 데이터를 요청하고, 사용자 설정에서 사용자의 이름을 업데이트하고 싶다고 가정해 봅시다. 우리는 ref.watch(`YourFutureProvider`)가 User 클래스가 아닌 AsyncData 유형을 반환하기 때문에 이렇게 할 수 없습니다. 일부 데이터를 알고 싶을 때마다 GET 요청을 완료하고 싶지 않으며, 특히 첫 번째로로드되고 사용 가능한 경우입니다. 두 Provider를 만들어야할 것으로 생각할 수 있지만, 하나는 AsyncProvider이고, 하나는 NotifierProvider로 대화해야 한다면 그것은 비효율적입니다. 다행히도 이를 처리하는 방법이 있습니다.\n\n다음 코드는 AsyncProvider를 사용하고 로드된 데이터를 NotifierProvider처럼 사용하는 방법을 보여줍니다.\n\n```js\n// home.dart\n\nclass MyHomePage extends StatelessWidget {\n  const MyHomePage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(),\n      body: Consumer(\n        builder: (context, ref, _) {\n          // Foo Provider를 가져와 상태를 설정합니다.\n          // State Provider처럼 사용합니다.\n          ref.watch(fooControllerProvider.notifier).foo = Foo(3);\n          // UI에서 Foo 사용 (.requireValue는 변경 사항을 청취할 수 있도록 사용됨)\n          final foo = ref.watch(fooControllerProvider).requireValue;\n          // .when을 사용하여 미래에서 UI를 렌더링합니다.\n          return Text('bar: ${foo.bar}, baz: ${foo.baz}');\n        },\n      ),\n    );\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\nRiverpod는 플러터에서 상태 관리의 가장 추천되는 방법으로 나타났으며 완전히 반응적인 상태 프레임워크로 발전했습니다.\n\n나중에 Provider와 같은 다른 패키지는 더 이상 유지되지 않을 수 있으므로 Riverpod를 배우는 것이 중요합니다 (물론 먼 훗날입니다). 또한 Riverpod는 새로운 제너레이터 덕분에 상태를 효과적으로 관리할 수 있는 유연성과 제어성을 제공하여 build_runner를 사용해 강력하고 메모리를 고려한 프로바이더를 쉽게 만들 수 있습니다.\n\n이 글을 만드는 과정에서 도움이 된 멋진 자료를 제공해 준 다음 분들께 큰 박수를 보냅니다. 🎉\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- CodeWithAndrea\n- Adnanjpg\n- rrouselgit\n\n이 글이 도움이 되셨기를 바랍니다. 만약 도움이 되었다면, 더 많은 튜토리얼, 경험, 그리고 안내서가 포함된 다른 글도 자유롭게 읽어보세요!\n\n하나님을 신뢰합니다 🙏🏾","ogImage":{"url":"/assets/img/2024-06-21-HowtouseRiverpod20GeneratorinyourFlutterProject_0.png"},"coverImage":"/assets/img/2024-06-21-HowtouseRiverpod20GeneratorinyourFlutterProject_0.png","tag":["Tech"],"readingTime":15},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003eRiverpod은 플러터(Flutter)에서 상태 관리 및 반응형 데이터 캐싱의 새로운 표준입니다. 두 번째 버전인 Riverpod 2.0은 꽤 오랫동안 출시되었지만, 새로운 데이터 관리 방법과 컨셉을 이해하기 어려울 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e우리가 배울 내용\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eRiverpod 2.0의 새로운 프로바이더로 기존 프로바이더를 업데이트하는 방법.\u003c/li\u003e\n\u003cli\u003e앱 내에서 상태를 새로운 방식으로 관리하는 방법.\u003c/li\u003e\n\u003cli\u003eRiverpod 2.0에서 퓨처(futures)를 다루는 방법.\u003c/li\u003e\n\u003cli\u003e프로바이더를 자동으로 생성하고 프로바이더 생성 프로세스를 간소화하는 방법.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e시작하기 전에, Riverpod가 무엇을 할 수 있는지 알아보아야 합니다. Riverpod는 상태를 관리하기 위해 providers라는 것을 사용하며, 다음은 2.0 이전에 존재했던 providers입니다. 다양한 유형의 providers를 빠르게 살펴보겠습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eProvider: 이 provider는 값을 생성합니다. 반응적 상태나 메모리가 없기 때문에 대부분의 경우에 최적이 아니지만, 많은 정적 메소드를 가진 클래스나 접근하려는 종속성이 있는 경우 유용합니다.\u003c/li\u003e\n\u003cli\u003eChangeNotifierProvider, StateNotifierProvider, StateProvider: 이들은 앱 내부에서 로컬 상태를 생성, 액세스 및 캐싱하는 데 도움을 줍니다. 모두 반응적인 변경을 지원합니다.\u003c/li\u003e\n\u003cli\u003eFutureProvider, StreamProvider: 이들은 앱 내에서 비동기 데이터를 캐싱하고 액세스하는 데 도움을 줍니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eRiverpod 2.0에서는 이러한 모든 providers를 대체하는 2개의 providers가 있습니다... 하나만 제외하고요.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eNotifierProvider: 이는 변경 알림/동기 변경에 사용되며, ChangeNotifierProvider, StateNotifierProvider, StateProvider를 대체합니다.\u003c/li\u003e\n\u003cli\u003eAsyncNotifier: 이는 비동기 변경에 사용되며, FutureProvider를 대체합니다. 2024년 6월 19일 현재, StreamProvider를 대체할 대안이 없습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이전에 언급한 대로, 생성기를 사용하여 우리의 프로바이더를 만들기도 할 겁니다. 생성기는 새로운 프로바이더 구문을 지원합니다 (StreamProviders를 제외하고). 또한 AutoDisposeProviders를 지원합니다. @riverpod 어노테이션을 사용하여 생성기에게 다음 함수를 프로바이더로 만들라고 알립니다.\u003c/p\u003e\n\u003cp\u003e새로운 프로바이더에 대해 익숙해졌으니, 생성기를 사용하여 어떻게 앱에서 사용할 지 살펴봅시다.\u003c/p\u003e\n\u003ch1\u003e시작하기\u003c/h1\u003e\n\u003cp\u003e가장 중요한 것은 앱에 Riverpod 2.0 패키지를 설치하는 것입니다. pubspec.yaml 파일에 다음 줄을 추가하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-yaml\"\u003e\u003cspan class=\"hljs-comment\"\u003e# pubspec.yaml\u003c/span\u003e\n\n\u003cspan class=\"hljs-attr\"\u003edependencies:\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003eflutter_riverpod:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e^2.1.3\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003eriverpod_annotation:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e^1.1.1\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003edev_dependencies:\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003ebuild_runner:\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003eriverpod_generator:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e^1.1.1\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003eHelloWorld Provider 생성\u003c/h1\u003e\n\u003cp\u003e이제 가장 기본적인 provider 스타일을 만들고 사용하는 방법을 보여주는 다음 코드 조각을 살펴봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-dart\"\u003e\u003cspan class=\"hljs-comment\"\u003e// main.dart\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:flutter/material.dart'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:flutter_riverpod/flutter_riverpod.dart'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:riverpod_annotation/riverpod_annotation.dart'\u003c/span\u003e;\n\u003cspan class=\"hljs-comment\"\u003e// 생성기는 provider가 포함된 파일을 생성합니다. 전형적으로 \"\u0026#x3C;filename\u003e.g.dart\" 구문을 따르도록 합니다.\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 또한 import 문 이후에 코드를 작성하는 것이 좋습니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003epart\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'main.g.dart'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e// 단순히 메서드를 생성하고 \"@riverpod\"로 주석을 달아 provider를 만듭니다.\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// \"HelloWorldRef\" 객체를 생성하는 방법에 유의하세요.\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 이 객체는 아직 존재하지 않지만 \"dart run build_runner watch\" 명령을 실행하면 생성됩니다.\u003c/span\u003e\n\u003cspan class=\"hljs-meta\"\u003e@riverpod\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e helloWorld(HelloWorldRef ref) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'Hello world'\u003c/span\u003e;\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// provider를 사용하기 위해서는 동기식 provider를 사용하는 방식과 동일한 방식으로 사용합니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e main() {\n  runApp(\n    \u003cspan class=\"hljs-comment\"\u003e// 앱의 모든 provider 상태는 ProviderScope 내에 저장됩니다.\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// provider를 읽기 위해서는 이를 반드시 포함해야 합니다.\u003c/span\u003e\n    ProviderScope(\n      child: MyApp(),\n    ),\n  );\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// Riverpod는 Stateless와 Stateful 위젯과 유사한 ConsumerWidget 및 ConsumerStatefulWidget 클래스 액세스를 제공합니다.\u003c/span\u003e\n\u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eMyApp\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eConsumerWidget\u003c/span\u003e \u003c/span\u003e{\n  \u003cspan class=\"hljs-comment\"\u003e// ConsumerWidget의 build 메서드가 WidgetRef 객체를 가져오는 방식에 유의하세요.\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// WidgetRef는 provider를 읽는 데 사용됩니다.\u003c/span\u003e\n  \u003cspan class=\"hljs-meta\"\u003e@override\u003c/span\u003e\n  Widget build(BuildContext context, WidgetRef ref) {\n    \u003cspan class=\"hljs-comment\"\u003e// provider를 읽는 두 가지 방법이 있습니다.\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// 값을 읽고 변경 사항을 감시하려면 ref.watch(...)를 사용하고,\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// 함수를 호출하려면 ref.read(...)를 사용합니다.\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003efinal\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e val = ref.watch(helloWorldProvider);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e Text(\u003cspan class=\"hljs-string\"\u003e'Hello World Example'\u003c/span\u003e)),\n        body: Center(\n          child: Text(val),\n        ),\n      ),\n    );\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e제너레이터는 프로바이더가 포함된 파일을 생성합니다. 일반적으로 이 구문을 따르도록 하려면 \u003ccode\u003efilename\u003c/code\u003e.g.dart 형식을 따르길 원합니다. 그리고 import 문 이후에 이를 유지하는 것이 좋습니다. 이 부분은 파일이 서로 관련되어 있음을 Dart에게 알려주는 부분입니다.\u003c/li\u003e\n\u003cli\u003e프로바이더를 만들기 위해서는 단순히 메서드를 만들고 이를 “@riverpod”으로 주석 처리하여 우리의 프로바이더를 생성합니다. \"HelloWorldRef\" 객체를 만든 방법에 주목해보세요. 아직 존재하지는 않지만 우리가 터미널에서 dart run build_runner watch 명령을 실행하면 생성될 것입니다. 따라서 해당 명령을 실행하고 \u003ccode\u003efilename\u003c/code\u003e.g.dart라는 파일을 생성하고 생성 중 발생한 오류를 해결하세요. 해당 파일은 다음과 같습니다:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// GENERATED CODE - DO NOT MODIFY BY HAND\u003c/span\u003e\n\npart \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'main.dart'\u003c/span\u003e;\n\u003cspan class=\"hljs-comment\"\u003e// **************************************************************************\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// RiverpodGenerator\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// **************************************************************************\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// ignore_for_file: avoid_private_typedef_functions, non_constant_identifier_names, subtype_of_sealed_class, invalid_use_of_internal_member, unused_element, constant_identifier_names, unnecessary_raw_strings, library_private_types_in_public_api\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e/// Dart SDK에서 복사함\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003e_SystemHash\u003c/span\u003e {\n  _SystemHash.\u003cspan class=\"hljs-title function_\"\u003e_\u003c/span\u003e();\n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e int \u003cspan class=\"hljs-title function_\"\u003ecombine\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eint hash, int value\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// ignore: parameter_assignments\u003c/span\u003e\n    hash = \u003cspan class=\"hljs-number\"\u003e0x1fffffff\u003c/span\u003e \u0026#x26; (hash + value);\n    \u003cspan class=\"hljs-comment\"\u003e// ignore: parameter_assignments\u003c/span\u003e\n    hash = \u003cspan class=\"hljs-number\"\u003e0x1fffffff\u003c/span\u003e \u0026#x26; (hash + ((\u003cspan class=\"hljs-number\"\u003e0x0007ffff\u003c/span\u003e \u0026#x26; hash) \u0026#x3C;\u0026#x3C; \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e));\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e hash ^ (hash \u003e\u003e \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e);\n  }\n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e int \u003cspan class=\"hljs-title function_\"\u003efinish\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eint hash\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// ignore: parameter_assignments\u003c/span\u003e\n    hash = \u003cspan class=\"hljs-number\"\u003e0x1fffffff\u003c/span\u003e \u0026#x26; (hash + ((\u003cspan class=\"hljs-number\"\u003e0x03ffffff\u003c/span\u003e \u0026#x26; hash) \u0026#x3C;\u0026#x3C; \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e));\n    \u003cspan class=\"hljs-comment\"\u003e// ignore: parameter_assignments\u003c/span\u003e\n    hash = hash ^ (hash \u003e\u003e \u003cspan class=\"hljs-number\"\u003e11\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0x1fffffff\u003c/span\u003e \u0026#x26; (hash + ((\u003cspan class=\"hljs-number\"\u003e0x00003fff\u003c/span\u003e \u0026#x26; hash) \u0026#x3C;\u0026#x3C; \u003cspan class=\"hljs-number\"\u003e15\u003c/span\u003e));\n  }\n}\n\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e $helloWorldHash() =\u003e r\u003cspan class=\"hljs-string\"\u003e'8bbe6cff2b7b1f4e1f7be3d1820da793259f7bfc'\u003c/span\u003e;\n\u003cspan class=\"hljs-comment\"\u003e/// [helloWorld]도 참고하세요.\u003c/span\u003e\nfinal helloWorldProvider = \u003cspan class=\"hljs-title class_\"\u003eAutoDisposeProvider\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e\u003e(\n  helloWorld,\n  \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: r\u003cspan class=\"hljs-string\"\u003e'helloWorldProvider'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003edebugGetCreateSourceHash\u003c/span\u003e:\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e bool.\u003cspan class=\"hljs-title function_\"\u003efromEnvironment\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'dart.vm.product'\u003c/span\u003e) ? \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e : $helloWorldHash,\n);\ntypedef \u003cspan class=\"hljs-title class_\"\u003eHelloWorldRef\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eAutoDisposeProviderRef\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e생성된 프로바이더가 AutoDisposeProvider인 것을 주목하세요. 이는 상태가 없는 데이터와 유사하기 때문입니다.\u003c/li\u003e\n\u003cli\u003e파일을 저장한 후, dart run build_runner watch가 실행 중인 한 모든 생성된 프로바이더가 다시 생성됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e위젯 트리 어디서든 프로바이더에 접근하기\u003c/h1\u003e\n\u003cp\u003e이제 당신은 앱 내에서 제공 업체의 데이터를 어디서든 읽을 수 있는지 궁금해 할 수도 있습니다. 이를 제공 업체 소비하기라고하며, 이를 위해 ref.watch(…) 메서드를 호출하는 WidgetRef 개체를 사용해야합니다. 위젯의 특정 부분만 제공 업체에 액세스해야하는 경우 Consumer 클래스를 사용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e다음은 Consumer 클래스를 사용한 예시입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-dart\"\u003e\u003cspan class=\"hljs-comment\"\u003e// main.dart\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:flutter/material.dart'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:flutter_riverpod/flutter_riverpod.dart'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:riverpod_annotation/riverpod_annotation.dart'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003epart\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'main.g.dart'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-meta\"\u003e@riverpod\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e helloWorld(HelloWorldRef ref) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'Hello world'\u003c/span\u003e;\n}\n\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e main() {\n  runApp(\n    ProviderScope(\n      child: MyApp(),\n    ),\n  );\n}\n\n\u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eMyApp\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eStatelessWidget\u003c/span\u003e \u003c/span\u003e{\n  \u003cspan class=\"hljs-meta\"\u003e@override\u003c/span\u003e\n  Widget build(BuildContext context, WidgetRef ref) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e Text(\u003cspan class=\"hljs-string\"\u003e'Hello World Example'\u003c/span\u003e)),\n        body: Center(\n          child: Consumer(\n            builder: (context, ref, child) {\n              \u003cspan class=\"hljs-keyword\"\u003efinal\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e val = ref.watch(helloWorldProvider);\n              \u003cspan class=\"hljs-comment\"\u003e// Consumer has a return type of Widget.\u003c/span\u003e\n              \u003cspan class=\"hljs-comment\"\u003e// Almost like using a Builder widget, but Riverpodified :)\u003c/span\u003e\n              \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e Text(val);\n            },\n        ),\n      ),\n    );\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e변수에 반응형 상태 추가하기\u003c/h1\u003e\n\u003cp\u003e더 복잡한 제공자 예제를 살펴봅시다. 클래스를 사용하는 것과 같은 예제입니다. 이는 체크박스 부울 값이나 요소 목록과 같은 반응성 상태가 필요한 변수가 있는 경우 유용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e다음 예제에서는 클래스를 사용하여 변수의 저장소로 사용하고 제공자로 변환하는 방법을 보여줍니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@riverpod\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHelloWorld\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003e_$HelloWorld\u003c/span\u003e {\n  \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebuild\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"hello world\"\u003c/span\u003e;\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003etoCamelCase\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n      \u003cspan class=\"hljs-comment\"\u003e// 변수 상태를 사용하여 제공자의 현재 상태에 액세스하는 방법에 주목해주세요.\u003c/span\u003e\n      state = \u003cspan class=\"hljs-string\"\u003e'${state[0].toUpperCase()}${state.substring(1).toLowerCase()}'\u003c/span\u003e;\n  }\n}\n\nref.\u003cspan class=\"hljs-title function_\"\u003ewatch\u003c/span\u003e(helloWorldProvider); \u003cspan class=\"hljs-comment\"\u003e// hello world\u003c/span\u003e\nref.\u003cspan class=\"hljs-title function_\"\u003ewatch\u003c/span\u003e(helloWorldProvider.\u003cspan class=\"hljs-property\"\u003enotifier\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003etoCamelCase\u003c/span\u003e();\nref.\u003cspan class=\"hljs-title function_\"\u003ewatch\u003c/span\u003e(helloWorldProvider); \u003cspan class=\"hljs-comment\"\u003e// Hello World\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예제에서는 우리의 클래스가 _$\u003ccode\u003e클래스명\u003c/code\u003e을 확장하고 제공자로 변환되어야 한다는 것을 riverpod에게 알려주기 위해 위에 riverpod 주석이 달렸습니다. 참고: 클래스로 만든 모든 제공자는 build() 메서드가 필요합니다. 이곳이 제공자의 초기 상태를 구성하는 곳입니다.\u003c/p\u003e\n\u003cp\u003e제공자를 사용하는 것은 이전에 언급한 예제들만큼 간단합니다: 단순히 ref.watch(\u003ccode\u003e생성된 제공자 이름\u003c/code\u003e)을 호출하면 앱이 변경 사항을 감시합니다. 그리고 클래스의 접근자 메서드를 사용하려면 ref.watch(\u003ccode\u003e생성된 제공자 이름\u003c/code\u003e.notifier).\u003ccode\u003e메서드 이름\u003c/code\u003e()을 호출해야 합니다. .notifier를 꼭 포함하도록 하세요.\u003c/p\u003e\n\u003ch1\u003e제공자의 현재 값 변경하기\u003c/h1\u003e\n\u003cp\u003e이제 제공자 내의 현재 값을 변경하려면 클래스 내에 생성자를 사용하고 약간 수정해야 합니다. 즐겨 사용하는 단어 목록을 살펴보겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@riverpod\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFavoriteWordsRepository\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003e_$FavoriteWordsRepository\u003c/span\u003e {\n  \u003cspan class=\"hljs-title class_\"\u003eFavoriteWordsRepository\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e\u003e favoriteWords) {\n    words = favoriteWords;\n  }\n\n  \u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e\u003e words = [];\n\n  @override\n  \u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e\u003e \u003cspan class=\"hljs-title function_\"\u003ebuild\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e words;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003emain.g.dart 파일에서 FavoriteWordsRepository.new를 사용할 수 없다는 오류가 발생할 수 있습니다. 이 간단한 수정으로 해결할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efinal favoriteWordsRepositoryProvider =\n    \u003cspan class=\"hljs-title class_\"\u003eAutoDisposeAsyncNotifierProvider\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eFavoriteWordsRepository\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e\u003e\u003e(\n  \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFavoriteWordsRepository\u003c/span\u003e([]), \u003cspan class=\"hljs-comment\"\u003e// FavoriteWordsRepository.new --\u003e () =\u003e FavoriteWordsRepository([])\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이것을 값으로 리스트를 초기화하는 것과 혼동하지 마세요. 이것은 단순히 시작점일 뿐이고 실제로 초기화된 리스트는 List\u003ccode\u003eString\u003c/code\u003e words = []; 입니다.\u003c/p\u003e\n\u003cp\u003e그리고 위젯 코드 내에서 provider의 상태를 다음과 같이 업데이트할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eref.\u003cspan class=\"hljs-title function_\"\u003ewatch\u003c/span\u003e(favoriteWordsRepositoryProvider.\u003cspan class=\"hljs-property\"\u003enotifier\u003c/span\u003e).\u003cspan class=\"hljs-property\"\u003ewords\u003c/span\u003e = [\u003cspan class=\"hljs-string\"\u003e'Cars'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'Dogs'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'Flutter'\u003c/span\u003e];\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e비동기 공급자 생성\u003c/h1\u003e\n\u003cp\u003e지역 공급자 데이터 작업에 익숙해지면 futures를 다루는 방법도 알아봅시다! 아래 예시는 기본적인 future 공급자를 만드는 방법을 보여줍니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@riverpod\n\u003cspan class=\"hljs-title class_\"\u003eFuture\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e\u003e \u003cspan class=\"hljs-title function_\"\u003ehelloWorldFuture\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eHelloWorldFutureRef\u003c/span\u003e ref) \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFuture\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003edelayed\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDuration\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eseconds\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e));\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'Hello World'\u003c/span\u003e;\n  } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (e) {\n    \u003cspan class=\"hljs-comment\"\u003e// 이 함수는 오류를 발생시킬 수 없습니다.\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// futures에 대한 Try/Catch 블록은 좋은 실천법입니다 :)\u003c/span\u003e\n    rethrow;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e우리의 함수는 다시 HelloWorldFutureRef를 가져와야 합니다. 이것은 단일 공급자에서 여러 제공자를 사용하는 데에 사용됩니다. 다음은 dio: ^4.0.6을 사용하여 예제 API에 HTTP 요청을하는 예제입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-dart\"\u003e\u003cspan class=\"hljs-comment\"\u003e// dio_provider.dart\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:dio/dio.dart'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:flutter_riverpod/flutter_riverpod.dart'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:riverpod_annotation/riverpod_annotation.dart'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003epart\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'dio_provider.g.dart'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-meta\"\u003e@riverpod\u003c/span\u003e\nDio dio(DioRef ref, {\u003cspan class=\"hljs-built_in\"\u003eMap\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e, \u003cspan class=\"hljs-built_in\"\u003edynamic\u003c/span\u003e\u003e? headers, \u003cspan class=\"hljs-built_in\"\u003eString?\u003c/span\u003e subDomain}) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e Dio(BaseOptions(baseUrl: \u003cspan class=\"hljs-string\"\u003e'https://api.example.com'\u003c/span\u003e, headers: headers));\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 우리의 공급자에서 액세스하는 방법은 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-dart\"\u003e\u003cspan class=\"hljs-comment\"\u003e// greeting_service.dart\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'dio_provider.dart'\u003c/span\u003e;\n\u003cspan class=\"hljs-meta\"\u003e@riverpod\u003c/span\u003e\nFuture\u0026#x3C;\u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e\u003e getGreeting(GetGreetingRef ref, {\u003cspan class=\"hljs-keyword\"\u003erequired\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e name}) \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003efinal\u003c/span\u003e response = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e ref.watch(dioProvider()).\u003cspan class=\"hljs-keyword\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/greeting'\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003efinal\u003c/span\u003e result = response.data;\n    \u003cspan class=\"hljs-keyword\"\u003efinal\u003c/span\u003e greeting = result + \u003cspan class=\"hljs-string\"\u003e', '\u003c/span\u003e + name;\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e greeting; \u003cspan class=\"hljs-comment\"\u003e// Hello there, Carlton\u003c/span\u003e\n  } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (e) {\n    \u003cspan class=\"hljs-keyword\"\u003erethrow\u003c/span\u003e;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다른 공급자를 사용해 공급자를 \u003ccode\u003e.family\u003c/code\u003e로 만들어요.\u003c/p\u003e\n\u003ch1\u003ebuild 메서드에 인수 전달하기\u003c/h1\u003e\n\u003cp\u003eRiverpod은 초기화할 때 build 메서드로 인수를 전달할 수 있게 해줘요. 이를 코드에서 어떻게 할 수 있는지 알아볼게요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@riverpod\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyRepository\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003e_$MyRepository\u003c/span\u003e {\n  @override\n  \u003cspan class=\"hljs-comment\"\u003e// 여기에 위치 인수를 추가하세요. 이름 지정도 가능해요.\u003c/span\u003e\n  \u003cspan class=\"hljs-title class_\"\u003eFuture\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e\u003e \u003cspan class=\"hljs-title function_\"\u003ebuild\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e id, {bool value}) \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n    final \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e result = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emyFuture\u003c/span\u003e(id, value);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eanotherFutureThatReturnsAString\u003c/span\u003e(result);\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003eAsyncProvider를 사용하는 방법\u003c/h1\u003e\n\u003cp\u003eAsyncProvider를 사용하는 방법은 로컬 공급자를 사용하는 방법과 다르며 데이터와 상호 작용하는 방식이 변경됩니다. 주의 깊게 살펴보세요, 이것은 매우 중요합니다!\u003c/p\u003e\n\u003cp\u003eUI에서 공급자를 사용하려면 .when() 구문을 사용해야 합니다. 이 구문에는 3가지 다른 상태가 포함되어 있습니다: 데이터(완료), 로딩, 오류. ConnectionState를 확인하고 해당 위젯을 반환하는 것의 번거로움을 제거하기 때문에 FutureBuilders를 이것으로 교체할 수 있습니다. 아래는 완전한 앱의 예시를 살펴봅시다:\u003c/p\u003e\n\u003cp\u003e초기 앱 만들기\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-dart\"\u003e\u003cspan class=\"hljs-comment\"\u003e// main.dart\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:flutter/material.dart'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e main() {\n  runApp(\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e MyApp());\n}\n\n\u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eMyApp\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eStatelessWidget\u003c/span\u003e \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e MyApp({Key? key});\n\n  \u003cspan class=\"hljs-meta\"\u003e@override\u003c/span\u003e\n  Widget build(BuildContext context) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e ProviderScope(\n      child: MaterialApp(\n        home: MyHomePage(),\n      ),\n    );\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCreating foo class and provider\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-dart\"\u003e\u003cspan class=\"hljs-comment\"\u003e// foo.dart\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:flutter_riverpod/flutter_riverpod.dart'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:riverpod_annotation/riverpod_annotation.dart'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003epart\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'foo.g.dart'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eFoo\u003c/span\u003e \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003efinal\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eint\u003c/span\u003e bar;\n  \u003cspan class=\"hljs-built_in\"\u003eint?\u003c/span\u003e baz;\n\n  Foo(\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.bar, {\n    \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.baz,\n  });\n}\n\n\u003cspan class=\"hljs-meta\"\u003e@riverpod\u003c/span\u003e\n\u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eFooController\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003e_\u003c/span\u003e$\u003cspan class=\"hljs-title\"\u003eFooController\u003c/span\u003e \u003c/span\u003e{\n  FooController(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.foo);\n  Foo foo;\n\n  \u003cspan class=\"hljs-meta\"\u003e@override\u003c/span\u003e\n  FutureOr\u0026#x3C;Foo\u003e build() \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n    foo = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e getFoo();\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e foo;\n  }\n\n  Future\u0026#x3C;Foo\u003e getFoo() \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e Future.delayed(\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eDuration\u003c/span\u003e(seconds: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e));\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e Foo(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eConsuming foo provider\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-dart\"\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-dart\"\u003e\u003cspan class=\"hljs-comment\"\u003e// home.dart\u003c/span\u003e\n\n\u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eMyHomePage\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eStatelessWidget\u003c/span\u003e \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e MyHomePage({key});\n\n  \u003cspan class=\"hljs-meta\"\u003e@override\u003c/span\u003e\n  Widget build(BuildContext context) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e Scaffold(\n      appBar: AppBar(),\n      body: Consumer(\n        builder: (context, ref, _) {\n          \u003cspan class=\"hljs-comment\"\u003e// Provider를 얻어와서 watch합니다\u003c/span\u003e\n          \u003cspan class=\"hljs-keyword\"\u003efinal\u003c/span\u003e fooAsync = ref.watch(fooControllerProvider);\n          \u003cspan class=\"hljs-comment\"\u003e// .when을 사용하여 Future로부터 UI를 렌더링합니다\u003c/span\u003e\n          \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e fooAsync.\u003cspan class=\"hljs-keyword\"\u003ewhen\u003c/span\u003e(\n            data: (foo) =\u003e Text(\u003cspan class=\"hljs-string\"\u003e'bar: \u003cspan class=\"hljs-subst\"\u003e${foo.bar}\u003c/span\u003e, baz: \u003cspan class=\"hljs-subst\"\u003e${foo.baz}\u003c/span\u003e'\u003c/span\u003e),\n            loading: () =\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e CircularProgressIndicator(),\n            error: (err, stack) =\u003e Text(err.toString()),\n          );\n        },\n      ),\n    );\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예시에서는 Consumer 위젯을 사용하여 ref에 액세스하므로 ref.watch(fooControllerProvider)를 호출하여 AsyncData 유형을 반환할 수 있습니다. 그런 다음 .when(…) 함수가 제공하는 속성을 사용하여 UI를 매우 깨끗하고 관리하기 쉬운 형식으로 구성할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 작업은 생성된 파일에서 provider의 초기값을 설정해야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-dart\"\u003e\u003cspan class=\"hljs-keyword\"\u003efinal\u003c/span\u003e fooControllerProvider = AutoDisposeAsyncNotifierProvider\u0026#x3C;FooController, Foo\u003e(\n  () =\u003e FooController(Foo(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)), \u003cspan class=\"hljs-comment\"\u003e// FooController.new --\u003e FooController(Foo(1))\u003c/span\u003e\n  name: \u003cspan class=\"hljs-string\"\u003er'fooControllerProvider'\u003c/span\u003e,\n  debugGetCreateSourceHash: \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003ebool\u003c/span\u003e.fromEnvironment(\u003cspan class=\"hljs-string\"\u003e'dart.vm.product'\u003c/span\u003e) ? \u003cspan class=\"hljs-keyword\"\u003enull\u003c/span\u003e : $FooControllerHash,\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003eAsyncProvider의 현재 상태를 개체/가공 가능한 데이터처럼 가져오는 방법\u003c/h1\u003e\n\u003cp\u003e현재 방법은 API 데이터에 빠르게 액세스하는 데 유용하지만 문제가 발생합니다. 미래 Provider 내부의 데이터를 어떻게 가공 가능한 데이터처럼 액세스할 수 있을까요? API에서 사용자 데이터를 요청하고, 사용자 설정에서 사용자의 이름을 업데이트하고 싶다고 가정해 봅시다. 우리는 ref.watch(\u003ccode\u003eYourFutureProvider\u003c/code\u003e)가 User 클래스가 아닌 AsyncData 유형을 반환하기 때문에 이렇게 할 수 없습니다. 일부 데이터를 알고 싶을 때마다 GET 요청을 완료하고 싶지 않으며, 특히 첫 번째로로드되고 사용 가능한 경우입니다. 두 Provider를 만들어야할 것으로 생각할 수 있지만, 하나는 AsyncProvider이고, 하나는 NotifierProvider로 대화해야 한다면 그것은 비효율적입니다. 다행히도 이를 처리하는 방법이 있습니다.\u003c/p\u003e\n\u003cp\u003e다음 코드는 AsyncProvider를 사용하고 로드된 데이터를 NotifierProvider처럼 사용하는 방법을 보여줍니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// home.dart\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyHomePage\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eStatelessWidget\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyHomePage\u003c/span\u003e({\u003cspan class=\"hljs-variable language_\"\u003esuper\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ekey\u003c/span\u003e});\n\n  @override\n  \u003cspan class=\"hljs-title class_\"\u003eWidget\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebuild\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eBuildContext context\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eScaffold\u003c/span\u003e(\n      \u003cspan class=\"hljs-attr\"\u003eappBar\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eAppBar\u003c/span\u003e(),\n      \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eConsumer\u003c/span\u003e(\n        \u003cspan class=\"hljs-attr\"\u003ebuilder\u003c/span\u003e: (context, ref, _) {\n          \u003cspan class=\"hljs-comment\"\u003e// Foo Provider를 가져와 상태를 설정합니다.\u003c/span\u003e\n          \u003cspan class=\"hljs-comment\"\u003e// State Provider처럼 사용합니다.\u003c/span\u003e\n          ref.\u003cspan class=\"hljs-title function_\"\u003ewatch\u003c/span\u003e(fooControllerProvider.\u003cspan class=\"hljs-property\"\u003enotifier\u003c/span\u003e).\u003cspan class=\"hljs-property\"\u003efoo\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eFoo\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e);\n          \u003cspan class=\"hljs-comment\"\u003e// UI에서 Foo 사용 (.requireValue는 변경 사항을 청취할 수 있도록 사용됨)\u003c/span\u003e\n          final foo = ref.\u003cspan class=\"hljs-title function_\"\u003ewatch\u003c/span\u003e(fooControllerProvider).\u003cspan class=\"hljs-property\"\u003erequireValue\u003c/span\u003e;\n          \u003cspan class=\"hljs-comment\"\u003e// .when을 사용하여 미래에서 UI를 렌더링합니다.\u003c/span\u003e\n          \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'bar: ${foo.bar}, baz: ${foo.baz}'\u003c/span\u003e);\n        },\n      ),\n    );\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003eRiverpod는 플러터에서 상태 관리의 가장 추천되는 방법으로 나타났으며 완전히 반응적인 상태 프레임워크로 발전했습니다.\u003c/p\u003e\n\u003cp\u003e나중에 Provider와 같은 다른 패키지는 더 이상 유지되지 않을 수 있으므로 Riverpod를 배우는 것이 중요합니다 (물론 먼 훗날입니다). 또한 Riverpod는 새로운 제너레이터 덕분에 상태를 효과적으로 관리할 수 있는 유연성과 제어성을 제공하여 build_runner를 사용해 강력하고 메모리를 고려한 프로바이더를 쉽게 만들 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 글을 만드는 과정에서 도움이 된 멋진 자료를 제공해 준 다음 분들께 큰 박수를 보냅니다. 🎉\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCodeWithAndrea\u003c/li\u003e\n\u003cli\u003eAdnanjpg\u003c/li\u003e\n\u003cli\u003errouselgit\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 글이 도움이 되셨기를 바랍니다. 만약 도움이 되었다면, 더 많은 튜토리얼, 경험, 그리고 안내서가 포함된 다른 글도 자유롭게 읽어보세요!\u003c/p\u003e\n\u003cp\u003e하나님을 신뢰합니다 🙏🏾\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-21-HowtouseRiverpod20GeneratorinyourFlutterProject"},"buildId":"-8k4Xu2rlgTZWfP5qtaGa","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>