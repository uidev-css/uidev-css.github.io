<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>API 통합 및 상태 관리를 위한 Flutter BLoC 라이브러리 | uidev-css</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://uidev-css.github.io///post/2024-06-19-APIIntegrationandStateManagementwithFlutterBLoCLibrary" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="API 통합 및 상태 관리를 위한 Flutter BLoC 라이브러리 | uidev-css" data-gatsby-head="true"/><meta property="og:title" content="API 통합 및 상태 관리를 위한 Flutter BLoC 라이브러리 | uidev-css" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-19-APIIntegrationandStateManagementwithFlutterBLoCLibrary_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://uidev-css.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://uidev-css.github.io///post/2024-06-19-APIIntegrationandStateManagementwithFlutterBLoCLibrary" data-gatsby-head="true"/><meta name="twitter:title" content="API 통합 및 상태 관리를 위한 Flutter BLoC 라이브러리 | uidev-css" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-19-APIIntegrationandStateManagementwithFlutterBLoCLibrary_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | uidev-css" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-19 08:08" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b4eed7811784bdd3.js" defer=""></script><script src="/_next/static/5et5eMZxpKCgDAAyIS6Ju/_buildManifest.js" defer=""></script><script src="/_next/static/5et5eMZxpKCgDAAyIS6Ju/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UIDEV CSS</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">API 통합 및 상태 관리를 위한 Flutter BLoC 라이브러리</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="API 통합 및 상태 관리를 위한 Flutter BLoC 라이브러리" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UIDEV CSS</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 19, 2024</span><span class="posts_reading_time__f7YPP">9<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-19-APIIntegrationandStateManagementwithFlutterBLoCLibrary&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>Flutter Bloc 라이브러리는 잘 정의된 아키텍처를 통해 응용 프로그램 상태를 효과적으로 관리하는 방법을 제공합니다.</p>
<p><img src="/assets/img/2024-06-19-APIIntegrationandStateManagementwithFlutterBLoCLibrary_0.png" alt="image"></p>
<p>Flutter Bloc Library를 사용하면 다양한 응용 프로그램 상태를 명시적으로 관리할 수 있습니다.</p>
<p>이전에 작성한 기사에서 Flutter Bloc 아키텍처 및 이벤트 및 상태 이해에 대해 설명했습니다. setState를 사용하여 상태 관리의 기본 개념을 이미 알고 계시다면, 이 기사를 참고하시면 이해하기 쉬울 것입니다.</p>
<div class="content-ad"></div>
<p>통합 데이터 소스: 전자 상거래 또는 쇼핑 웹사이트용 가짜 상점 REST API 테스트 API는 네트워크 데이터 소스로 사용됩니다.</p>
<p>더미 JSON URL: <a href="https://dummyjson.com/products" rel="nofollow" target="_blank">https://dummyjson.com/products</a></p>
<p>본 문서에서는 하나의 엔드포인트(GET: 모든 제품 가져 오기: <a href="https://dummyjson.com/products)%EA%B0%80" rel="nofollow" target="_blank">https://dummyjson.com/products)가</a> 통합될 것입니다</p>
<p><img src="/assets/img/2024-06-19-APIIntegrationandStateManagementwithFlutterBLoCLibrary_1.png" alt="이미지"></p>
<div class="content-ad"></div>
<p>이 엔드포인트를 통합하기 위해서는 Flutter BLoC 아키텍처를 구현하여 응용 프로그램을 세 개의 계층으로 분리해야 합니다.</p>
<ul>
<li>데이터: 데이터 제공자, 도메인 (저장소, 모델)</li>
<li>비즈니스 로직: 비즈니스 로직 계층의 책임은 프리젠테이션 계층에서 발생하는 이벤트에 새로운 상태로 응답하는 것입니다. 이 계층은 응용 프로그램 상태를 구축하는 데 필요한 데이터를 검색하기 위해 하나 이상의 저장소에 의존할 수 있습니다.</li>
<li>프리젠테이션: 프리젠테이션 계층의 책임은 하나 이상의 블록 상태에 기반하여 자신을 렌더링하는 방법을 결정하는 것입니다. 또한 사용자 상호 작용 및 응용 프로그램 라이프사이클 이벤트를 처리해야 합니다.</li>
</ul>
<p>이 3개의 계층 중에서 어떤 계층부터 시작해야 할까요?</p>
<p>그래, 데이터 계층부터 시작하겠습니다. 왜냐하면 데이터 계층에서 비즈니스 로직으로 순차적인 통신이 이루어지고, 비즈니스 로직에서 프리젠테이션으로 이어지기 때문이죠.</p>
<div class="content-ad"></div>
<p>특수한 경우에는 네트워크 및 데이터 시뮬레이션에 더 적합한 방법을 따를 수 있습니다.</p>
<p>데이터 레이어 구현으로 넘어가기 전에 필요한 종속성을 추가해 봅시다:</p>
<p><img src="/assets/img/2024-06-19-APIIntegrationandStateManagementwithFlutterBLoCLibrary_2.png" alt="Dependency"></p>
<p>HTTP: HTTP 요청을 만들기 위한 구성 가능한 미래 기반 라이브러리입니다.</p>
<div class="content-ad"></div>
<p>플러터 Bloc: 빠르고 반응성 있는 모바일 애플리케이션을 구축하기 위해 bloc과 함께 작동하는 강력한 플러터 위젯</p>
<p>Equatable: == 및 hashCode를 명시적으로 재정의할 필요 없이 값을 기반으로 한 등가성을 구현하는 데 도움이 되는 Dart 패키지입니다. Flutter Bloc에서는 동일한 상태가 발생하는 경우 상태 재구성을 방지하거나 결정하는 데 도움이 됩니다.</p>
<p>Intl: 숫자 형식 지정에 사용됩니다.</p>
<p>실행: <code>flutter pub get</code> 명령을 실행하여 종속성을 프로젝트에 추가하세요.</p>
<div class="content-ad"></div>
<h1>1. 데이터 레이어</h1>
<p>데이터 제공자: 데이터 제공자는 원시 데이터, 즉 HTTP 요청의 원시 응답을 받습니다.</p>
<p>대규모 애플리케이션을 구축할 때 모든 HTTP 메서드를 포함하는 단일 데이터 제공자를 사용할 수 있습니다. 이는 모든 원시 데이터가 HTTP 응답임을 고려한 것입니다.</p>
<p>데이터 제공자는 HTTP 메서드(PUT, GET, POST, DELETE)와 리포지토리에 의해 관리되는 다른 원시 데이터 소스(예: 로컬 저장소)를 포함할 수 있습니다.</p>
<div class="content-ad"></div>
<p>이 구현의 예는 데이터를 가져 오기 때문에 HTTP Get 요청만 수행됩니다.</p>
<p>HTTP 요청은 try-catch 블록 내에 있어 이 요청에서 발생할 수 있는 모든 예외를 잡아내고 해당 예외를 다시 던집니다. 이 예외는 데이터 제공자 클래스에서 처리되지 않고 리포지토리로 던져집니다.</p>
<p>모델</p>
<p>모델은 데이터 구조를 결정하는 데 도움이 되는 클래스입니다. 모델은 데이터베이스나 HTTP 응답을 반영하도록 작성될 수 있으며 이 경우 제품 JSON 응답을 얻는 것입니다.</p>
<div class="content-ad"></div>
<p>이 모델에는 데이터 제공자로부터 JSON 형식의 HTTP 응답을 특정 모델(Dart 객체)로 디코딩하는 데이터 역직렬화 방법도 포함됩니다.</p>
<p>데이터를 전송할 때(e.g. POST, PUT, PATCH 요청 등)는 인코딩된 json이 필요한 경우 요청 본문을 인코딩하기 위한 직렬화 방법을 추가할 수 있습니다.</p>
<p>저장소</p>
<p>저장소는 도메인으로서 우리의 데이터 계층을 추상화하고 블록 계층과의 통신을 용이하게 합니다. 이를 통해 우리 코드베이스의 나머지 부분은 특정 데이터 제공자가 아닌 저장소 계층에서 노출된 함수에만 의존하게 됩니다.</p>
<div class="content-ad"></div>
<p><code>getProducts</code> 메서드는 List of Product (List<code>Product</code>)을 데이터 타입으로 반환하는 비동기 메서드입니다. Product는 product_model.dart에서 생성된 모델입니다. (Line: 6)</p>
<p>(Line: 5) 데이터 공급 업체는 get products 엔드포인트(“<a href="https://dummyjson.com/products%E2%80%9D)%EB%A5%BC" rel="nofollow" target="_blank">https://dummyjson.com/products”)를</a> 파싱하는 getRequest 메서드를 호출하기 위해 인스턴스화됩니다.</p>
<p>데이터 공급 업체는 응답 본문, 응답 상태 코드 등에 액세스할 수 있는 raw HTPP 응답을 반환합니다. 상태 코드 200은 요청이 성공적이고 제품이 반환되었음을 나타내며, 요청이 성공적이지 않으면 예외(“Error loading product”)가 던져져 Bloc Layer에서 처리됩니다 (Line: 15).</p>
<p>또한 레포지토리에서 getRequest는 예외를 블록 레이어에서 처리하도록 다시 던지기 위한 try-catch 블록 내에 있습니다.</p>
<div class="content-ad"></div>
<h1>2. BLOC</h1>
<p>BLOC 레이어를 관리할 때, 우리는 이벤트 및 상태를 생성합니다. 이것이 응용 프로그램 상태를 우아하게 관리하는 Flutter Bloc의 핵심 부분입니다.</p>
<p>선호하는 IDE에서 Flutter Bloc 확장 프로그램을 사용하면 bloc을 더 빨리 생성할 수 있습니다. (이벤트, 상태, bloc을 포함하는) 보일러플레이트입니다.</p>
<p>Bloc 확장 프로그램 사용하기</p>
<div class="content-ad"></div>
<ul>
<li>Bloc을 extension에 설치하세요.</li>
<li>Bloc 디렉토리를 만드세요.</li>
<li>이 디렉토리를 마우스 오른쪽 클릭하고 New <code>Bloc Class</code>를 선택하세요.</li>
<li>이름을 product으로 지정하면 _bloc, _event, _state가 클래스 이름에 추가됩니다. 또한 equatable를 확장할 수 있습니다.</li>
</ul>
<p><img src="/assets/img/2024-06-19-APIIntegrationandStateManagementwithFlutterBLoCLibrary_3.png" alt="이미지"></p>
<p>세 개의 bloc 파일(클래스)을 살펴봅시다. 먼저 고려해야 할 것은 product state 입니다.</p>
<p>product_state</p>
<div class="content-ad"></div>
<p>제품 상태는 원격 데이터 소스에서 제품을 가져오는 동안 애플리케이션이 있을 수있는 상태를 정의합니다.</p>
<ul>
<li>제품 초기 상태: 이름 그대로 어떠한 프로세스도 시작되기 전에 애플리케이션의 초기 상태입니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductInitial</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">ProductState</span> {}
</code></pre>
<ul>
<li>제품 로딩 상태: 원격 데이터 소스에서 제품을 가져오기 위한 요청이 시작됐을 때, 애플리케이션은 제품 로딩 상태를 나타내며, 이 상태는 Flutter Bloc 위젯을 통해 확인할 수 있습니다. 이 상태는 BlocListener, BlocConsumer, BlocBuilder를 통해 듣을 수 있으며, 사용자에게 요청 프로세스가 진행 중임을 보여줄 수 있도록 애플리케이션을 로딩 상태로 설정할 수 있습니다.</li>
</ul>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductLoadingState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">ProductState</span> {}
</code></pre>
<ul>
<li>Product Loaded State: 제품이 원격 데이터 소스에서 로드되어 화면에 표시될 수 있는 상태입니다.</li>
<li>ProductLoadedState에는 생성자에서 제품 목록(List<product> products)이 필요하며, 이는 이 상태가 가져온 제품을 화면에 표시하기 위해 발생시킵니다. (라인 13)</product></li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductLoadedState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">ProductState</span> {
  <span class="hljs-keyword">const</span> <span class="hljs-title class_">ProductLoadedState</span>({required <span class="hljs-variable language_">this</span>.<span class="hljs-property">products</span>});
  final <span class="hljs-title class_">List</span>&#x3C;<span class="hljs-title class_">Product</span>> products;
  @override
  <span class="hljs-title class_">List</span>&#x3C;<span class="hljs-title class_">Object</span>> get props => [products];
}
</code></pre>
<ul>
<li>Product Empty State: 명시적이고 표현 계층에 로직을 줄이기 위해 상품 조회가 성공했지만 제품 데이터가 비어 있는 상태를 관리합니다. (라인 20)</li>
<li>Product Loading Failed State: 제품을 로드하는 중에 오류가 발생한 상태입니다. 이 오류는 HTTP 오류이거나 예외일 수 있습니다. 사용자 경험을 향상시키기 위해 페이지에 친절한 메시지를 표시하여 오류의 원인 또는 요청이 완료되지 않은 이유를 설명하는 것이 좋습니다. 이로 인해 ProductLoadingFailedState는 생성자에서 오류 메시지를 요구합니다. (라인 22)</li>
</ul>
<div class="content-ad"></div>
<p>플러터 Bloc을 사용할 때 애플리케이션에서 모든 것은 이벤트와 상태에 기반합니다. 단일 이벤트 초기화는 애플리케이션의 여러 상태와 관련될 수 있습니다.</p>
<p>이 시나리오에서 단일 이벤트인 GetProductEvent를 선언합니다. 이 단일 이벤트의 초기화는 다양한 애플리케이션 상태(ProductLoadingState, ProductLoadedState, ProductEmptyState, ProductLoadingFailedState)를 발생시킬 수 있습니다.</p>
<pre><code class="hljs language-js">part <span class="hljs-keyword">of</span> <span class="hljs-string">'product_bloc.dart'</span>;

abstract <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductEvent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Equatable</span> {
  <span class="hljs-keyword">const</span> <span class="hljs-title class_">ProductEvent</span>();
  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> implement props</span>
  @override
  <span class="hljs-title class_">List</span>&#x3C;<span class="hljs-title class_">Object</span>?> get props => [];
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">GetProductEvent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">ProductEvent</span> {}
</code></pre>
<p>그 다음, 이벤트를 상태로 매핑합니다. 이전 Bloc 클래스에서 최근 업데이트 이전에 사용된 용어로 (mapEventToState)를 사용하여 이벤트를 상태로 기본적으로 매핑하는 것이 매우 좋다고 생각합니다.</p>
<div class="content-ad"></div>
<p>이벤트와 상태 간의 매핑이 구현되어 있습니다. Bloc은 새로운 상태를 발생시킬 수 있는 Emitter를 사용합니다.</p>
<p>아래 Bloc은 단순히 이벤트의 초기화를 보여줍니다. Emitter는 Product State를 확장하여 다른 상태를 발생시킬 수 있습니다. 이 경우 GetProductEvent에서 Emitter<code>ProductState</code>를 사용합니다.</p>
<p>Bloc은 저장소로부터 디코딩된 응답과 통신하며, 저장소는 원시 데이터를 제공하는 데이터 제공자와 통신합니다.</p>
<p>ProductRepository는 BlocProvider 래퍼를 통해 프레젠테이션 레이어(위젯)에 주입되거나 제공될 것입니다. 그러나 먼저 Bloc에 집중해 보겠습니다.</p>
<div class="content-ad"></div>
<p>이 블록 파일은 이벤트를 상태에 매핑하는 것을 관리합니다:</p>
<ul>
<li>getProducts()는 제품 목록을 반환합니다 (17번 라인)</li>
<li>getProducts()가 성공적으로 반환되면 제품이 비어 있는지 확인합니다 (18번 라인)</li>
<li>제품이 비어 있다면 ProductEmptyState를 발생시키고, 그렇지 않으면 제품 데이터로 getProducts()가 성공적입니다.</li>
<li>ProductLoadedState를 발생시키면 반환된 제품이 ProductLoadedState에 의해 발생합니다 (21번 라인)</li>
<li>우리는 여기서 try-catch 메서드를 사용하는데, 예외는 handleExceptionWithMessage() 메서드로 처리됩니다. 이 함수는 예외를 캡처하고 친숙한 메시지를 반환하여 관리합니다. FormatException, SocketException, NetworkImageLoadException의 스택 추적을 사용자에게 보여주고 싶지 않을 것입니다.</li>
</ul>
<p>예외 처리기</p>
<p>참고: 예외를 관리하는 더 많은 방법이 있습니다. 본 문서는 주로 예외 처리에 중점을 둔 것이 아니지만, 이 방법을 사용하여 Kosher!를 반복할 수 있습니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-string">'dart:async'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'dart:io'</span>;

<span class="hljs-title class_">String</span> <span class="hljs-title function_">handleExceptionWithMessage</span>(<span class="hljs-params">dynamic error</span>) {
  <span class="hljs-keyword">if</span> (error is <span class="hljs-title class_">SocketException</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"인터넷에 연결되지 않은 것 같습니다."</span>;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (error is <span class="hljs-title class_">TimeoutException</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"요청 시간이 초과되었습니다. 안정적인 인터넷 연결이 있는지 확인해주세요."</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"오류가 발생했습니다. 다시 시도해주세요."</span>;
  }
}
</code></pre>
<p>handleExceptionWithMessage() 함수는 발생한 예외에 대한 설명을 반환합니다. 이 경우에는 두 가지 종류의 예외 유형(SocketException; 인터넷 연결이 없을 때 발생, TimeoutException; HTTP 요청의 설정된 시간 초과할 때 발생)만 확인합니다.</p>
<h1>3. 프레젠테이션</h1>
<p>데이터와 블록 레이어가 준비되어 있으며, 프레젠테이션에는 데이터를 표시하는 위젯이 포함되어 있습니다.</p>
<div class="content-ad"></div>
<p>Bloc 이벤트 또는 상태에 액세스하기 전에는 애플리케이션에 이 Bloc을 제공해야 합니다.</p>
<p>BlocProvider 및 Repository Provider를 사용한 의존성 주입(DI)</p>
<p>BlocProvider는 Flutter 위젯으로, BlocProvider.of<code> T</code>(context)를 통해 자식 위젯에 bloc을 제공합니다. 이는 의존성 주입(DI) 위젯으로 사용되어 서브트리 내에서 여러 위젯에 대해 단일 bloc 인스턴스를 제공할 수 있도록 합니다.</p>
<p>대부분의 경우 BlocProvider는 서브트리의 나머지 부분에서 사용할 새로운 bloc을 생성하는 데 사용되어야 합니다. 이 경우 BlocProvider는 bloc을 생성하는 것에 대한 책임이 있으므로 자동으로 그것을 닫아 줄 것입니다. (출처: Flutter Bloc 문서)</p>
<div class="content-ad"></div>
<p>이 Bloc을 main.dart의 최상위 부모 위젯 (MaterialApp)에 제공합니다.</p>
<p>Bloc 이벤트를 초기화하고 상태를 관리합니다</p>
<p>제품을 표시하는 페이지가 생성되었을 때 (initState) 이 페이지의 초기화에서 Bloc 이벤트 (GetProductEvent)를 호출하거나 추가합니다.</p>
<pre><code class="hljs language-js">@override
<span class="hljs-keyword">void</span> <span class="hljs-title function_">initState</span>(<span class="hljs-params"></span>) {
  context.<span class="hljs-property">read</span>&#x3C;<span class="hljs-title class_">ProductBloc</span>>().<span class="hljs-title function_">add</span>(<span class="hljs-title class_">GetProductEvent</span>());
  <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">initState</span>();
}
</code></pre>
<div class="content-ad"></div>
<p>GetProductEvent이 호출될 때, BlocBuilder는 상태를 통해 생성되는 위젯(제품 로딩 위젯, 제품 로딩 오류 위젯 등)을 관리할 수 있는 Bloc 위젯으로 추가됩니다.</p>
<p>만세! 위 예제를 통해 Flutter Bloc을 사용한 API 통합 및 상태 관리의 기본 개념이 설명되었습니다.</p>
<p>이 예제의 전체 프로젝트 코드는 GitHub에서 확인할 수 있습니다: <a href="https://github.com/waleajepe/flutter_bloc_api" rel="nofollow" target="_blank">https://github.com/waleajepe/flutter_bloc_api</a></p>
<p>이 개념을 더 잘 이해하기 위해 Flutter Bloc 라이브러리 팀 (Very Good Ventures 팀)이 제공하는 더 많은 예제를 읽고 확인하는 것이 좋습니다: <a href="https://bloclibrary.dev/getting-started/" rel="nofollow" target="_blank">https://bloclibrary.dev/getting-started/</a></p>
<div class="content-ad"></div>
<p>만약 이 기사가 도움이 되었다면 👏 몇 개 클랩(claps)도 부탁드려요. 댓글 섹션에 기여와 수정 사항을 남겨주셔도 됩니다. 건배! 👊😊</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"API 통합 및 상태 관리를 위한 Flutter BLoC 라이브러리","description":"","date":"2024-06-19 08:08","slug":"2024-06-19-APIIntegrationandStateManagementwithFlutterBLoCLibrary","content":"\nFlutter Bloc 라이브러리는 잘 정의된 아키텍처를 통해 응용 프로그램 상태를 효과적으로 관리하는 방법을 제공합니다.\n\n![image](/assets/img/2024-06-19-APIIntegrationandStateManagementwithFlutterBLoCLibrary_0.png)\n\nFlutter Bloc Library를 사용하면 다양한 응용 프로그램 상태를 명시적으로 관리할 수 있습니다.\n\n이전에 작성한 기사에서 Flutter Bloc 아키텍처 및 이벤트 및 상태 이해에 대해 설명했습니다. setState를 사용하여 상태 관리의 기본 개념을 이미 알고 계시다면, 이 기사를 참고하시면 이해하기 쉬울 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n통합 데이터 소스: 전자 상거래 또는 쇼핑 웹사이트용 가짜 상점 REST API 테스트 API는 네트워크 데이터 소스로 사용됩니다.\n\n더미 JSON URL: https://dummyjson.com/products\n\n본 문서에서는 하나의 엔드포인트(GET: 모든 제품 가져 오기: https://dummyjson.com/products)가 통합될 것입니다\n\n![이미지](/assets/img/2024-06-19-APIIntegrationandStateManagementwithFlutterBLoCLibrary_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 엔드포인트를 통합하기 위해서는 Flutter BLoC 아키텍처를 구현하여 응용 프로그램을 세 개의 계층으로 분리해야 합니다.\n\n- 데이터: 데이터 제공자, 도메인 (저장소, 모델)\n- 비즈니스 로직: 비즈니스 로직 계층의 책임은 프리젠테이션 계층에서 발생하는 이벤트에 새로운 상태로 응답하는 것입니다. 이 계층은 응용 프로그램 상태를 구축하는 데 필요한 데이터를 검색하기 위해 하나 이상의 저장소에 의존할 수 있습니다.\n- 프리젠테이션: 프리젠테이션 계층의 책임은 하나 이상의 블록 상태에 기반하여 자신을 렌더링하는 방법을 결정하는 것입니다. 또한 사용자 상호 작용 및 응용 프로그램 라이프사이클 이벤트를 처리해야 합니다.\n\n이 3개의 계층 중에서 어떤 계층부터 시작해야 할까요?\n\n그래, 데이터 계층부터 시작하겠습니다. 왜냐하면 데이터 계층에서 비즈니스 로직으로 순차적인 통신이 이루어지고, 비즈니스 로직에서 프리젠테이션으로 이어지기 때문이죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n특수한 경우에는 네트워크 및 데이터 시뮬레이션에 더 적합한 방법을 따를 수 있습니다.\n\n데이터 레이어 구현으로 넘어가기 전에 필요한 종속성을 추가해 봅시다:\n\n![Dependency](/assets/img/2024-06-19-APIIntegrationandStateManagementwithFlutterBLoCLibrary_2.png)\n\nHTTP: HTTP 요청을 만들기 위한 구성 가능한 미래 기반 라이브러리입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플러터 Bloc: 빠르고 반응성 있는 모바일 애플리케이션을 구축하기 위해 bloc과 함께 작동하는 강력한 플러터 위젯\n\nEquatable: == 및 hashCode를 명시적으로 재정의할 필요 없이 값을 기반으로 한 등가성을 구현하는 데 도움이 되는 Dart 패키지입니다. Flutter Bloc에서는 동일한 상태가 발생하는 경우 상태 재구성을 방지하거나 결정하는 데 도움이 됩니다.\n\nIntl: 숫자 형식 지정에 사용됩니다.\n\n실행: `flutter pub get` 명령을 실행하여 종속성을 프로젝트에 추가하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 1. 데이터 레이어\n\n데이터 제공자: 데이터 제공자는 원시 데이터, 즉 HTTP 요청의 원시 응답을 받습니다.\n\n대규모 애플리케이션을 구축할 때 모든 HTTP 메서드를 포함하는 단일 데이터 제공자를 사용할 수 있습니다. 이는 모든 원시 데이터가 HTTP 응답임을 고려한 것입니다.\n\n데이터 제공자는 HTTP 메서드(PUT, GET, POST, DELETE)와 리포지토리에 의해 관리되는 다른 원시 데이터 소스(예: 로컬 저장소)를 포함할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 구현의 예는 데이터를 가져 오기 때문에 HTTP Get 요청만 수행됩니다.\n\nHTTP 요청은 try-catch 블록 내에 있어 이 요청에서 발생할 수 있는 모든 예외를 잡아내고 해당 예외를 다시 던집니다. 이 예외는 데이터 제공자 클래스에서 처리되지 않고 리포지토리로 던져집니다.\n\n모델\n\n모델은 데이터 구조를 결정하는 데 도움이 되는 클래스입니다. 모델은 데이터베이스나 HTTP 응답을 반영하도록 작성될 수 있으며 이 경우 제품 JSON 응답을 얻는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 모델에는 데이터 제공자로부터 JSON 형식의 HTTP 응답을 특정 모델(Dart 객체)로 디코딩하는 데이터 역직렬화 방법도 포함됩니다.\n\n데이터를 전송할 때(e.g. POST, PUT, PATCH 요청 등)는 인코딩된 json이 필요한 경우 요청 본문을 인코딩하기 위한 직렬화 방법을 추가할 수 있습니다.\n\n저장소\n\n저장소는 도메인으로서 우리의 데이터 계층을 추상화하고 블록 계층과의 통신을 용이하게 합니다. 이를 통해 우리 코드베이스의 나머지 부분은 특정 데이터 제공자가 아닌 저장소 계층에서 노출된 함수에만 의존하게 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`getProducts` 메서드는 List of Product (List`Product`)을 데이터 타입으로 반환하는 비동기 메서드입니다. Product는 product_model.dart에서 생성된 모델입니다. (Line: 6)\n\n(Line: 5) 데이터 공급 업체는 get products 엔드포인트(“https://dummyjson.com/products”)를 파싱하는 getRequest 메서드를 호출하기 위해 인스턴스화됩니다.\n\n데이터 공급 업체는 응답 본문, 응답 상태 코드 등에 액세스할 수 있는 raw HTPP 응답을 반환합니다. 상태 코드 200은 요청이 성공적이고 제품이 반환되었음을 나타내며, 요청이 성공적이지 않으면 예외(“Error loading product”)가 던져져 Bloc Layer에서 처리됩니다 (Line: 15).\n\n또한 레포지토리에서 getRequest는 예외를 블록 레이어에서 처리하도록 다시 던지기 위한 try-catch 블록 내에 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 2. BLOC\n\nBLOC 레이어를 관리할 때, 우리는 이벤트 및 상태를 생성합니다. 이것이 응용 프로그램 상태를 우아하게 관리하는 Flutter Bloc의 핵심 부분입니다.\n\n선호하는 IDE에서 Flutter Bloc 확장 프로그램을 사용하면 bloc을 더 빨리 생성할 수 있습니다. (이벤트, 상태, bloc을 포함하는) 보일러플레이트입니다.\n\nBloc 확장 프로그램 사용하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Bloc을 extension에 설치하세요.\n- Bloc 디렉토리를 만드세요.\n- 이 디렉토리를 마우스 오른쪽 클릭하고 New `Bloc Class`를 선택하세요.\n- 이름을 product으로 지정하면 \\_bloc, \\_event, \\_state가 클래스 이름에 추가됩니다. 또한 equatable를 확장할 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-APIIntegrationandStateManagementwithFlutterBLoCLibrary_3.png)\n\n세 개의 bloc 파일(클래스)을 살펴봅시다. 먼저 고려해야 할 것은 product state 입니다.\n\nproduct_state\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제품 상태는 원격 데이터 소스에서 제품을 가져오는 동안 애플리케이션이 있을 수있는 상태를 정의합니다.\n\n- 제품 초기 상태: 이름 그대로 어떠한 프로세스도 시작되기 전에 애플리케이션의 초기 상태입니다.\n\n```js\nclass ProductInitial extends ProductState {}\n```\n\n- 제품 로딩 상태: 원격 데이터 소스에서 제품을 가져오기 위한 요청이 시작됐을 때, 애플리케이션은 제품 로딩 상태를 나타내며, 이 상태는 Flutter Bloc 위젯을 통해 확인할 수 있습니다. 이 상태는 BlocListener, BlocConsumer, BlocBuilder를 통해 듣을 수 있으며, 사용자에게 요청 프로세스가 진행 중임을 보여줄 수 있도록 애플리케이션을 로딩 상태로 설정할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nclass ProductLoadingState extends ProductState {}\n```\n\n- Product Loaded State: 제품이 원격 데이터 소스에서 로드되어 화면에 표시될 수 있는 상태입니다.\n- ProductLoadedState에는 생성자에서 제품 목록(List\u003cProduct\u003e products)이 필요하며, 이는 이 상태가 가져온 제품을 화면에 표시하기 위해 발생시킵니다. (라인 13)\n\n```js\nclass ProductLoadedState extends ProductState {\n  const ProductLoadedState({required this.products});\n  final List\u003cProduct\u003e products;\n  @override\n  List\u003cObject\u003e get props =\u003e [products];\n}\n```\n\n- Product Empty State: 명시적이고 표현 계층에 로직을 줄이기 위해 상품 조회가 성공했지만 제품 데이터가 비어 있는 상태를 관리합니다. (라인 20)\n- Product Loading Failed State: 제품을 로드하는 중에 오류가 발생한 상태입니다. 이 오류는 HTTP 오류이거나 예외일 수 있습니다. 사용자 경험을 향상시키기 위해 페이지에 친절한 메시지를 표시하여 오류의 원인 또는 요청이 완료되지 않은 이유를 설명하는 것이 좋습니다. 이로 인해 ProductLoadingFailedState는 생성자에서 오류 메시지를 요구합니다. (라인 22)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플러터 Bloc을 사용할 때 애플리케이션에서 모든 것은 이벤트와 상태에 기반합니다. 단일 이벤트 초기화는 애플리케이션의 여러 상태와 관련될 수 있습니다.\n\n이 시나리오에서 단일 이벤트인 GetProductEvent를 선언합니다. 이 단일 이벤트의 초기화는 다양한 애플리케이션 상태(ProductLoadingState, ProductLoadedState, ProductEmptyState, ProductLoadingFailedState)를 발생시킬 수 있습니다.\n\n```js\npart of 'product_bloc.dart';\n\nabstract class ProductEvent extends Equatable {\n  const ProductEvent();\n  // TODO: implement props\n  @override\n  List\u003cObject?\u003e get props =\u003e [];\n}\n\nclass GetProductEvent extends ProductEvent {}\n```\n\n그 다음, 이벤트를 상태로 매핑합니다. 이전 Bloc 클래스에서 최근 업데이트 이전에 사용된 용어로 (mapEventToState)를 사용하여 이벤트를 상태로 기본적으로 매핑하는 것이 매우 좋다고 생각합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이벤트와 상태 간의 매핑이 구현되어 있습니다. Bloc은 새로운 상태를 발생시킬 수 있는 Emitter를 사용합니다.\n\n아래 Bloc은 단순히 이벤트의 초기화를 보여줍니다. Emitter는 Product State를 확장하여 다른 상태를 발생시킬 수 있습니다. 이 경우 GetProductEvent에서 Emitter`ProductState`를 사용합니다.\n\nBloc은 저장소로부터 디코딩된 응답과 통신하며, 저장소는 원시 데이터를 제공하는 데이터 제공자와 통신합니다.\n\nProductRepository는 BlocProvider 래퍼를 통해 프레젠테이션 레이어(위젯)에 주입되거나 제공될 것입니다. 그러나 먼저 Bloc에 집중해 보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 블록 파일은 이벤트를 상태에 매핑하는 것을 관리합니다:\n\n- getProducts()는 제품 목록을 반환합니다 (17번 라인)\n- getProducts()가 성공적으로 반환되면 제품이 비어 있는지 확인합니다 (18번 라인)\n- 제품이 비어 있다면 ProductEmptyState를 발생시키고, 그렇지 않으면 제품 데이터로 getProducts()가 성공적입니다.\n- ProductLoadedState를 발생시키면 반환된 제품이 ProductLoadedState에 의해 발생합니다 (21번 라인)\n- 우리는 여기서 try-catch 메서드를 사용하는데, 예외는 handleExceptionWithMessage() 메서드로 처리됩니다. 이 함수는 예외를 캡처하고 친숙한 메시지를 반환하여 관리합니다. FormatException, SocketException, NetworkImageLoadException의 스택 추적을 사용자에게 보여주고 싶지 않을 것입니다.\n\n예외 처리기\n\n참고: 예외를 관리하는 더 많은 방법이 있습니다. 본 문서는 주로 예외 처리에 중점을 둔 것이 아니지만, 이 방법을 사용하여 Kosher!를 반복할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport 'dart:async';\nimport 'dart:io';\n\nString handleExceptionWithMessage(dynamic error) {\n  if (error is SocketException) {\n    return \"인터넷에 연결되지 않은 것 같습니다.\";\n  } else if (error is TimeoutException) {\n    return \"요청 시간이 초과되었습니다. 안정적인 인터넷 연결이 있는지 확인해주세요.\";\n  } else {\n    return \"오류가 발생했습니다. 다시 시도해주세요.\";\n  }\n}\n```\n\nhandleExceptionWithMessage() 함수는 발생한 예외에 대한 설명을 반환합니다. 이 경우에는 두 가지 종류의 예외 유형(SocketException; 인터넷 연결이 없을 때 발생, TimeoutException; HTTP 요청의 설정된 시간 초과할 때 발생)만 확인합니다.\n\n# 3. 프레젠테이션\n\n데이터와 블록 레이어가 준비되어 있으며, 프레젠테이션에는 데이터를 표시하는 위젯이 포함되어 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nBloc 이벤트 또는 상태에 액세스하기 전에는 애플리케이션에 이 Bloc을 제공해야 합니다.\n\nBlocProvider 및 Repository Provider를 사용한 의존성 주입(DI)\n\nBlocProvider는 Flutter 위젯으로, BlocProvider.of` T`(context)를 통해 자식 위젯에 bloc을 제공합니다. 이는 의존성 주입(DI) 위젯으로 사용되어 서브트리 내에서 여러 위젯에 대해 단일 bloc 인스턴스를 제공할 수 있도록 합니다.\n\n대부분의 경우 BlocProvider는 서브트리의 나머지 부분에서 사용할 새로운 bloc을 생성하는 데 사용되어야 합니다. 이 경우 BlocProvider는 bloc을 생성하는 것에 대한 책임이 있으므로 자동으로 그것을 닫아 줄 것입니다. (출처: Flutter Bloc 문서)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 Bloc을 main.dart의 최상위 부모 위젯 (MaterialApp)에 제공합니다.\n\nBloc 이벤트를 초기화하고 상태를 관리합니다\n\n제품을 표시하는 페이지가 생성되었을 때 (initState) 이 페이지의 초기화에서 Bloc 이벤트 (GetProductEvent)를 호출하거나 추가합니다.\n\n```js\n@override\nvoid initState() {\n  context.read\u003cProductBloc\u003e().add(GetProductEvent());\n  super.initState();\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGetProductEvent이 호출될 때, BlocBuilder는 상태를 통해 생성되는 위젯(제품 로딩 위젯, 제품 로딩 오류 위젯 등)을 관리할 수 있는 Bloc 위젯으로 추가됩니다.\n\n만세! 위 예제를 통해 Flutter Bloc을 사용한 API 통합 및 상태 관리의 기본 개념이 설명되었습니다.\n\n이 예제의 전체 프로젝트 코드는 GitHub에서 확인할 수 있습니다: https://github.com/waleajepe/flutter_bloc_api\n\n이 개념을 더 잘 이해하기 위해 Flutter Bloc 라이브러리 팀 (Very Good Ventures 팀)이 제공하는 더 많은 예제를 읽고 확인하는 것이 좋습니다: https://bloclibrary.dev/getting-started/\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 이 기사가 도움이 되었다면 👏 몇 개 클랩(claps)도 부탁드려요. 댓글 섹션에 기여와 수정 사항을 남겨주셔도 됩니다. 건배! 👊😊\n","ogImage":{"url":"/assets/img/2024-06-19-APIIntegrationandStateManagementwithFlutterBLoCLibrary_0.png"},"coverImage":"/assets/img/2024-06-19-APIIntegrationandStateManagementwithFlutterBLoCLibrary_0.png","tag":["Tech"],"readingTime":9},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003eFlutter Bloc 라이브러리는 잘 정의된 아키텍처를 통해 응용 프로그램 상태를 효과적으로 관리하는 방법을 제공합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-APIIntegrationandStateManagementwithFlutterBLoCLibrary_0.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003eFlutter Bloc Library를 사용하면 다양한 응용 프로그램 상태를 명시적으로 관리할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이전에 작성한 기사에서 Flutter Bloc 아키텍처 및 이벤트 및 상태 이해에 대해 설명했습니다. setState를 사용하여 상태 관리의 기본 개념을 이미 알고 계시다면, 이 기사를 참고하시면 이해하기 쉬울 것입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e통합 데이터 소스: 전자 상거래 또는 쇼핑 웹사이트용 가짜 상점 REST API 테스트 API는 네트워크 데이터 소스로 사용됩니다.\u003c/p\u003e\n\u003cp\u003e더미 JSON URL: \u003ca href=\"https://dummyjson.com/products\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://dummyjson.com/products\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e본 문서에서는 하나의 엔드포인트(GET: 모든 제품 가져 오기: \u003ca href=\"https://dummyjson.com/products)%EA%B0%80\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://dummyjson.com/products)가\u003c/a\u003e 통합될 것입니다\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-APIIntegrationandStateManagementwithFlutterBLoCLibrary_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 엔드포인트를 통합하기 위해서는 Flutter BLoC 아키텍처를 구현하여 응용 프로그램을 세 개의 계층으로 분리해야 합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e데이터: 데이터 제공자, 도메인 (저장소, 모델)\u003c/li\u003e\n\u003cli\u003e비즈니스 로직: 비즈니스 로직 계층의 책임은 프리젠테이션 계층에서 발생하는 이벤트에 새로운 상태로 응답하는 것입니다. 이 계층은 응용 프로그램 상태를 구축하는 데 필요한 데이터를 검색하기 위해 하나 이상의 저장소에 의존할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e프리젠테이션: 프리젠테이션 계층의 책임은 하나 이상의 블록 상태에 기반하여 자신을 렌더링하는 방법을 결정하는 것입니다. 또한 사용자 상호 작용 및 응용 프로그램 라이프사이클 이벤트를 처리해야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 3개의 계층 중에서 어떤 계층부터 시작해야 할까요?\u003c/p\u003e\n\u003cp\u003e그래, 데이터 계층부터 시작하겠습니다. 왜냐하면 데이터 계층에서 비즈니스 로직으로 순차적인 통신이 이루어지고, 비즈니스 로직에서 프리젠테이션으로 이어지기 때문이죠.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e특수한 경우에는 네트워크 및 데이터 시뮬레이션에 더 적합한 방법을 따를 수 있습니다.\u003c/p\u003e\n\u003cp\u003e데이터 레이어 구현으로 넘어가기 전에 필요한 종속성을 추가해 봅시다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-APIIntegrationandStateManagementwithFlutterBLoCLibrary_2.png\" alt=\"Dependency\"\u003e\u003c/p\u003e\n\u003cp\u003eHTTP: HTTP 요청을 만들기 위한 구성 가능한 미래 기반 라이브러리입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e플러터 Bloc: 빠르고 반응성 있는 모바일 애플리케이션을 구축하기 위해 bloc과 함께 작동하는 강력한 플러터 위젯\u003c/p\u003e\n\u003cp\u003eEquatable: == 및 hashCode를 명시적으로 재정의할 필요 없이 값을 기반으로 한 등가성을 구현하는 데 도움이 되는 Dart 패키지입니다. Flutter Bloc에서는 동일한 상태가 발생하는 경우 상태 재구성을 방지하거나 결정하는 데 도움이 됩니다.\u003c/p\u003e\n\u003cp\u003eIntl: 숫자 형식 지정에 사용됩니다.\u003c/p\u003e\n\u003cp\u003e실행: \u003ccode\u003eflutter pub get\u003c/code\u003e 명령을 실행하여 종속성을 프로젝트에 추가하세요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e1. 데이터 레이어\u003c/h1\u003e\n\u003cp\u003e데이터 제공자: 데이터 제공자는 원시 데이터, 즉 HTTP 요청의 원시 응답을 받습니다.\u003c/p\u003e\n\u003cp\u003e대규모 애플리케이션을 구축할 때 모든 HTTP 메서드를 포함하는 단일 데이터 제공자를 사용할 수 있습니다. 이는 모든 원시 데이터가 HTTP 응답임을 고려한 것입니다.\u003c/p\u003e\n\u003cp\u003e데이터 제공자는 HTTP 메서드(PUT, GET, POST, DELETE)와 리포지토리에 의해 관리되는 다른 원시 데이터 소스(예: 로컬 저장소)를 포함할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 구현의 예는 데이터를 가져 오기 때문에 HTTP Get 요청만 수행됩니다.\u003c/p\u003e\n\u003cp\u003eHTTP 요청은 try-catch 블록 내에 있어 이 요청에서 발생할 수 있는 모든 예외를 잡아내고 해당 예외를 다시 던집니다. 이 예외는 데이터 제공자 클래스에서 처리되지 않고 리포지토리로 던져집니다.\u003c/p\u003e\n\u003cp\u003e모델\u003c/p\u003e\n\u003cp\u003e모델은 데이터 구조를 결정하는 데 도움이 되는 클래스입니다. 모델은 데이터베이스나 HTTP 응답을 반영하도록 작성될 수 있으며 이 경우 제품 JSON 응답을 얻는 것입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 모델에는 데이터 제공자로부터 JSON 형식의 HTTP 응답을 특정 모델(Dart 객체)로 디코딩하는 데이터 역직렬화 방법도 포함됩니다.\u003c/p\u003e\n\u003cp\u003e데이터를 전송할 때(e.g. POST, PUT, PATCH 요청 등)는 인코딩된 json이 필요한 경우 요청 본문을 인코딩하기 위한 직렬화 방법을 추가할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e저장소\u003c/p\u003e\n\u003cp\u003e저장소는 도메인으로서 우리의 데이터 계층을 추상화하고 블록 계층과의 통신을 용이하게 합니다. 이를 통해 우리 코드베이스의 나머지 부분은 특정 데이터 제공자가 아닌 저장소 계층에서 노출된 함수에만 의존하게 됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003ccode\u003egetProducts\u003c/code\u003e 메서드는 List of Product (List\u003ccode\u003eProduct\u003c/code\u003e)을 데이터 타입으로 반환하는 비동기 메서드입니다. Product는 product_model.dart에서 생성된 모델입니다. (Line: 6)\u003c/p\u003e\n\u003cp\u003e(Line: 5) 데이터 공급 업체는 get products 엔드포인트(“\u003ca href=\"https://dummyjson.com/products%E2%80%9D)%EB%A5%BC\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://dummyjson.com/products”)를\u003c/a\u003e 파싱하는 getRequest 메서드를 호출하기 위해 인스턴스화됩니다.\u003c/p\u003e\n\u003cp\u003e데이터 공급 업체는 응답 본문, 응답 상태 코드 등에 액세스할 수 있는 raw HTPP 응답을 반환합니다. 상태 코드 200은 요청이 성공적이고 제품이 반환되었음을 나타내며, 요청이 성공적이지 않으면 예외(“Error loading product”)가 던져져 Bloc Layer에서 처리됩니다 (Line: 15).\u003c/p\u003e\n\u003cp\u003e또한 레포지토리에서 getRequest는 예외를 블록 레이어에서 처리하도록 다시 던지기 위한 try-catch 블록 내에 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e2. BLOC\u003c/h1\u003e\n\u003cp\u003eBLOC 레이어를 관리할 때, 우리는 이벤트 및 상태를 생성합니다. 이것이 응용 프로그램 상태를 우아하게 관리하는 Flutter Bloc의 핵심 부분입니다.\u003c/p\u003e\n\u003cp\u003e선호하는 IDE에서 Flutter Bloc 확장 프로그램을 사용하면 bloc을 더 빨리 생성할 수 있습니다. (이벤트, 상태, bloc을 포함하는) 보일러플레이트입니다.\u003c/p\u003e\n\u003cp\u003eBloc 확장 프로그램 사용하기\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003eBloc을 extension에 설치하세요.\u003c/li\u003e\n\u003cli\u003eBloc 디렉토리를 만드세요.\u003c/li\u003e\n\u003cli\u003e이 디렉토리를 마우스 오른쪽 클릭하고 New \u003ccode\u003eBloc Class\u003c/code\u003e를 선택하세요.\u003c/li\u003e\n\u003cli\u003e이름을 product으로 지정하면 _bloc, _event, _state가 클래스 이름에 추가됩니다. 또한 equatable를 확장할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-APIIntegrationandStateManagementwithFlutterBLoCLibrary_3.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e세 개의 bloc 파일(클래스)을 살펴봅시다. 먼저 고려해야 할 것은 product state 입니다.\u003c/p\u003e\n\u003cp\u003eproduct_state\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e제품 상태는 원격 데이터 소스에서 제품을 가져오는 동안 애플리케이션이 있을 수있는 상태를 정의합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e제품 초기 상태: 이름 그대로 어떠한 프로세스도 시작되기 전에 애플리케이션의 초기 상태입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eProductInitial\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eProductState\u003c/span\u003e {}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e제품 로딩 상태: 원격 데이터 소스에서 제품을 가져오기 위한 요청이 시작됐을 때, 애플리케이션은 제품 로딩 상태를 나타내며, 이 상태는 Flutter Bloc 위젯을 통해 확인할 수 있습니다. 이 상태는 BlocListener, BlocConsumer, BlocBuilder를 통해 듣을 수 있으며, 사용자에게 요청 프로세스가 진행 중임을 보여줄 수 있도록 애플리케이션을 로딩 상태로 설정할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eProductLoadingState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eProductState\u003c/span\u003e {}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eProduct Loaded State: 제품이 원격 데이터 소스에서 로드되어 화면에 표시될 수 있는 상태입니다.\u003c/li\u003e\n\u003cli\u003eProductLoadedState에는 생성자에서 제품 목록(List\u003cproduct\u003e products)이 필요하며, 이는 이 상태가 가져온 제품을 화면에 표시하기 위해 발생시킵니다. (라인 13)\u003c/product\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eProductLoadedState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eProductState\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eProductLoadedState\u003c/span\u003e({required \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eproducts\u003c/span\u003e});\n  final \u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eProduct\u003c/span\u003e\u003e products;\n  @override\n  \u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e\u003e get props =\u003e [products];\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eProduct Empty State: 명시적이고 표현 계층에 로직을 줄이기 위해 상품 조회가 성공했지만 제품 데이터가 비어 있는 상태를 관리합니다. (라인 20)\u003c/li\u003e\n\u003cli\u003eProduct Loading Failed State: 제품을 로드하는 중에 오류가 발생한 상태입니다. 이 오류는 HTTP 오류이거나 예외일 수 있습니다. 사용자 경험을 향상시키기 위해 페이지에 친절한 메시지를 표시하여 오류의 원인 또는 요청이 완료되지 않은 이유를 설명하는 것이 좋습니다. 이로 인해 ProductLoadingFailedState는 생성자에서 오류 메시지를 요구합니다. (라인 22)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e플러터 Bloc을 사용할 때 애플리케이션에서 모든 것은 이벤트와 상태에 기반합니다. 단일 이벤트 초기화는 애플리케이션의 여러 상태와 관련될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 시나리오에서 단일 이벤트인 GetProductEvent를 선언합니다. 이 단일 이벤트의 초기화는 다양한 애플리케이션 상태(ProductLoadingState, ProductLoadedState, ProductEmptyState, ProductLoadingFailedState)를 발생시킬 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003epart \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'product_bloc.dart'\u003c/span\u003e;\n\nabstract \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eProductEvent\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eEquatable\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eProductEvent\u003c/span\u003e();\n  \u003cspan class=\"hljs-comment\"\u003e// \u003cspan class=\"hljs-doctag\"\u003eTODO:\u003c/span\u003e implement props\u003c/span\u003e\n  @override\n  \u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e?\u003e get props =\u003e [];\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eGetProductEvent\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eProductEvent\u003c/span\u003e {}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그 다음, 이벤트를 상태로 매핑합니다. 이전 Bloc 클래스에서 최근 업데이트 이전에 사용된 용어로 (mapEventToState)를 사용하여 이벤트를 상태로 기본적으로 매핑하는 것이 매우 좋다고 생각합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이벤트와 상태 간의 매핑이 구현되어 있습니다. Bloc은 새로운 상태를 발생시킬 수 있는 Emitter를 사용합니다.\u003c/p\u003e\n\u003cp\u003e아래 Bloc은 단순히 이벤트의 초기화를 보여줍니다. Emitter는 Product State를 확장하여 다른 상태를 발생시킬 수 있습니다. 이 경우 GetProductEvent에서 Emitter\u003ccode\u003eProductState\u003c/code\u003e를 사용합니다.\u003c/p\u003e\n\u003cp\u003eBloc은 저장소로부터 디코딩된 응답과 통신하며, 저장소는 원시 데이터를 제공하는 데이터 제공자와 통신합니다.\u003c/p\u003e\n\u003cp\u003eProductRepository는 BlocProvider 래퍼를 통해 프레젠테이션 레이어(위젯)에 주입되거나 제공될 것입니다. 그러나 먼저 Bloc에 집중해 보겠습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 블록 파일은 이벤트를 상태에 매핑하는 것을 관리합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003egetProducts()는 제품 목록을 반환합니다 (17번 라인)\u003c/li\u003e\n\u003cli\u003egetProducts()가 성공적으로 반환되면 제품이 비어 있는지 확인합니다 (18번 라인)\u003c/li\u003e\n\u003cli\u003e제품이 비어 있다면 ProductEmptyState를 발생시키고, 그렇지 않으면 제품 데이터로 getProducts()가 성공적입니다.\u003c/li\u003e\n\u003cli\u003eProductLoadedState를 발생시키면 반환된 제품이 ProductLoadedState에 의해 발생합니다 (21번 라인)\u003c/li\u003e\n\u003cli\u003e우리는 여기서 try-catch 메서드를 사용하는데, 예외는 handleExceptionWithMessage() 메서드로 처리됩니다. 이 함수는 예외를 캡처하고 친숙한 메시지를 반환하여 관리합니다. FormatException, SocketException, NetworkImageLoadException의 스택 추적을 사용자에게 보여주고 싶지 않을 것입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e예외 처리기\u003c/p\u003e\n\u003cp\u003e참고: 예외를 관리하는 더 많은 방법이 있습니다. 본 문서는 주로 예외 처리에 중점을 둔 것이 아니지만, 이 방법을 사용하여 Kosher!를 반복할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'dart:async'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'dart:io'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehandleExceptionWithMessage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003edynamic error\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (error is \u003cspan class=\"hljs-title class_\"\u003eSocketException\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"인터넷에 연결되지 않은 것 같습니다.\"\u003c/span\u003e;\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (error is \u003cspan class=\"hljs-title class_\"\u003eTimeoutException\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"요청 시간이 초과되었습니다. 안정적인 인터넷 연결이 있는지 확인해주세요.\"\u003c/span\u003e;\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"오류가 발생했습니다. 다시 시도해주세요.\"\u003c/span\u003e;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ehandleExceptionWithMessage() 함수는 발생한 예외에 대한 설명을 반환합니다. 이 경우에는 두 가지 종류의 예외 유형(SocketException; 인터넷 연결이 없을 때 발생, TimeoutException; HTTP 요청의 설정된 시간 초과할 때 발생)만 확인합니다.\u003c/p\u003e\n\u003ch1\u003e3. 프레젠테이션\u003c/h1\u003e\n\u003cp\u003e데이터와 블록 레이어가 준비되어 있으며, 프레젠테이션에는 데이터를 표시하는 위젯이 포함되어 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eBloc 이벤트 또는 상태에 액세스하기 전에는 애플리케이션에 이 Bloc을 제공해야 합니다.\u003c/p\u003e\n\u003cp\u003eBlocProvider 및 Repository Provider를 사용한 의존성 주입(DI)\u003c/p\u003e\n\u003cp\u003eBlocProvider는 Flutter 위젯으로, BlocProvider.of\u003ccode\u003e T\u003c/code\u003e(context)를 통해 자식 위젯에 bloc을 제공합니다. 이는 의존성 주입(DI) 위젯으로 사용되어 서브트리 내에서 여러 위젯에 대해 단일 bloc 인스턴스를 제공할 수 있도록 합니다.\u003c/p\u003e\n\u003cp\u003e대부분의 경우 BlocProvider는 서브트리의 나머지 부분에서 사용할 새로운 bloc을 생성하는 데 사용되어야 합니다. 이 경우 BlocProvider는 bloc을 생성하는 것에 대한 책임이 있으므로 자동으로 그것을 닫아 줄 것입니다. (출처: Flutter Bloc 문서)\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 Bloc을 main.dart의 최상위 부모 위젯 (MaterialApp)에 제공합니다.\u003c/p\u003e\n\u003cp\u003eBloc 이벤트를 초기화하고 상태를 관리합니다\u003c/p\u003e\n\u003cp\u003e제품을 표시하는 페이지가 생성되었을 때 (initState) 이 페이지의 초기화에서 Bloc 이벤트 (GetProductEvent)를 호출하거나 추가합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@override\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003einitState\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  context.\u003cspan class=\"hljs-property\"\u003eread\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eProductBloc\u003c/span\u003e\u003e().\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eGetProductEvent\u003c/span\u003e());\n  \u003cspan class=\"hljs-variable language_\"\u003esuper\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003einitState\u003c/span\u003e();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eGetProductEvent이 호출될 때, BlocBuilder는 상태를 통해 생성되는 위젯(제품 로딩 위젯, 제품 로딩 오류 위젯 등)을 관리할 수 있는 Bloc 위젯으로 추가됩니다.\u003c/p\u003e\n\u003cp\u003e만세! 위 예제를 통해 Flutter Bloc을 사용한 API 통합 및 상태 관리의 기본 개념이 설명되었습니다.\u003c/p\u003e\n\u003cp\u003e이 예제의 전체 프로젝트 코드는 GitHub에서 확인할 수 있습니다: \u003ca href=\"https://github.com/waleajepe/flutter_bloc_api\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://github.com/waleajepe/flutter_bloc_api\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e이 개념을 더 잘 이해하기 위해 Flutter Bloc 라이브러리 팀 (Very Good Ventures 팀)이 제공하는 더 많은 예제를 읽고 확인하는 것이 좋습니다: \u003ca href=\"https://bloclibrary.dev/getting-started/\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://bloclibrary.dev/getting-started/\u003c/a\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e만약 이 기사가 도움이 되었다면 👏 몇 개 클랩(claps)도 부탁드려요. 댓글 섹션에 기여와 수정 사항을 남겨주셔도 됩니다. 건배! 👊😊\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-19-APIIntegrationandStateManagementwithFlutterBLoCLibrary"},"buildId":"5et5eMZxpKCgDAAyIS6Ju","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>