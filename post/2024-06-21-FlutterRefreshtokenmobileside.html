<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Flutter에서 리프레시 토큰 사용하는 방법 모바일 | uidev-css</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://uidev-css.github.io///post/2024-06-21-FlutterRefreshtokenmobileside" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Flutter에서 리프레시 토큰 사용하는 방법 모바일 | uidev-css" data-gatsby-head="true"/><meta property="og:title" content="Flutter에서 리프레시 토큰 사용하는 방법 모바일 | uidev-css" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-21-FlutterRefreshtokenmobileside_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://uidev-css.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://uidev-css.github.io///post/2024-06-21-FlutterRefreshtokenmobileside" data-gatsby-head="true"/><meta name="twitter:title" content="Flutter에서 리프레시 토큰 사용하는 방법 모바일 | uidev-css" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-21-FlutterRefreshtokenmobileside_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | uidev-css" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-21 23:50" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b4eed7811784bdd3.js" defer=""></script><script src="/_next/static/ckvP8zvWyPnScUqpsTElP/_buildManifest.js" defer=""></script><script src="/_next/static/ckvP8zvWyPnScUqpsTElP/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UIDEV CSS</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Flutter에서 리프레시 토큰 사용하는 방법 모바일</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Flutter에서 리프레시 토큰 사용하는 방법 모바일" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UIDEV CSS</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 21, 2024</span><span class="posts_reading_time__f7YPP">4<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-21-FlutterRefreshtokenmobileside&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>플러터에서 Dio를 사용하여 토큰을 새로 고치는 방법</p>
<p><img src="/assets/img/2024-06-21-FlutterRefreshtokenmobileside_0.png" alt="image"></p>
<p>현대 모바일 애플리케이션에서는 사용자 인증 세션을 원활하게 유지하는 것이 사용자 경험에 매우 중요합니다. 인증을 관리하는 효과적인 방법 중 하나는 리프레시 토큰을 사용하는 것입니다. 이 기사에서는 Dio를 사용하여 플러터 애플리케이션에서 리프레시 토큰을 처리하는 방법에 대해 살펴보겠습니다.</p>
<p>토큰이란 무엇인가요?
토큰은 토큰 기반 인증에서 애플리케이션이 API에 액세스할 수 있도록 허용하는 데 사용됩니다. 사용자가 성공적으로 인증하고 액세스 권한을 부여한 후 애플리케이션은 액세스 토큰을 받아들이고 대상 API를 호출할 때 자격 증명으로서 액세스 토큰을 전달합니다. 전달된 토큰은 API에게 전달된 토큰의 소유자가 API에 액세스할 권한이 있으며 승인 중에 부여된 범위에 따라 특정 조치를 수행할 수 있음을 알립니다.</p>
<div class="content-ad"></div>
<p>리프레시 토큰이 무엇인가요?
리프레시 토큰은 사용자가 다시 인증을 받지 않고 새로운 엑세스 토큰을 얻는 메커니즘입니다. 일반적으로 엑세스 토큰은 보안상의 이유로 수명이 짧지만, 리프레시 토큰은 더 오래 지속됩니다. 엑세스 토큰이 만료되면 리프레시 토큰을 사용하여 새로운 엑세스 토큰을 얻을 수 있어 사용자의 세션을 중단시키지 않고 유지할 수 있습니다.</p>
<p>단계별로 리프레시 토큰 구현하기</p>
<p>Dio의 인스턴스를 구성하고 초기화하는 'DioFactory' 클래스를 만드세요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DioFactory</span> {

  <span class="hljs-title class_">Future</span>&#x3C;<span class="hljs-title class_">Dio</span>> <span class="hljs-title function_">getDio</span>() <span class="hljs-keyword">async</span> {
    <span class="hljs-title class_">Dio</span> dio = <span class="hljs-title class_">Dio</span>();

    <span class="hljs-title class_">Map</span>&#x3C;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">String</span>> headers = {
      <span class="hljs-attr">contentType</span>: applicationJson,
      <span class="hljs-attr">accept</span>: applicationJson,
    };

    dio.<span class="hljs-property">options</span> = <span class="hljs-title class_">BaseOptions</span>(
      <span class="hljs-attr">baseUrl</span>: <span class="hljs-title class_">ConstantsApi</span>.<span class="hljs-property">baseUrl</span>,
      <span class="hljs-attr">headers</span>: headers,
      <span class="hljs-attr">receiveTimeout</span>: <span class="hljs-keyword">const</span> <span class="hljs-title class_">Duration</span>(<span class="hljs-attr">milliseconds</span>: <span class="hljs-title class_">Constants</span>.<span class="hljs-property">apiTimeOut</span>),
      <span class="hljs-attr">sendTimeout</span>: <span class="hljs-keyword">const</span> <span class="hljs-title class_">Duration</span>(<span class="hljs-attr">milliseconds</span>: <span class="hljs-title class_">Constants</span>.<span class="hljs-property">apiTimeOut</span>),
      <span class="hljs-attr">connectTimeout</span>: <span class="hljs-keyword">const</span> <span class="hljs-title class_">Duration</span>(<span class="hljs-attr">milliseconds</span>: <span class="hljs-title class_">Constants</span>.<span class="hljs-property">apiTimeOut</span>),
    );

    <span class="hljs-keyword">if</span> (!kReleaseMode) {
      dio.<span class="hljs-property">interceptors</span>.<span class="hljs-title function_">add</span>(
        <span class="hljs-title class_">PrettyDioLogger</span>(
          <span class="hljs-attr">requestHeader</span>: <span class="hljs-literal">true</span>,
          <span class="hljs-attr">requestBody</span>: <span class="hljs-literal">true</span>,
          <span class="hljs-attr">responseHeader</span>: <span class="hljs-literal">true</span>,
          <span class="hljs-attr">error</span>: <span class="hljs-literal">true</span>,
        ),
      );
    }

    <span class="hljs-keyword">return</span> dio;
  }
}
</code></pre>
<div class="content-ad"></div>
<p>ApiService 클래스는 Dio를 사용하여 API 요청을 처리하고 인증 토큰을 관리하기 위해 설계된 포괄적인 서비스 레이어입니다. 이 클래스와 기능에 대한 자세한 설명을 제공합니다.</p>
<p>01- 클래스 선언 및 필드
“_dio1”과 “_dio2”는 "Dio"의 인스턴스입니다. “_dio1”은 일반 API 요청에 사용되고, “_dio2”는 토큰 갱신 요청에 사용됩니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ApiService</span> {
  final <span class="hljs-title class_">Dio</span> _dio1;
  final <span class="hljs-title class_">Dio</span> _dio2;
  final <span class="hljs-title class_">AppPreferences</span> _appPref;

  <span class="hljs-title class_">ApiService</span>(
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_dio1</span>,
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_dio2</span>,
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_appPref</span>,
  ) {
    _dio1.<span class="hljs-property">interceptors</span>.<span class="hljs-title function_">add</span>(
      <span class="hljs-title class_">InterceptorsWrapper</span>(
        <span class="hljs-attr">onRequest</span>: _onRequest,
        <span class="hljs-attr">onError</span>: _onError,
      ),
    );
  }
}
</code></pre>
<p>02- 인터셉터</p>
<div class="content-ad"></div>
<p>생성자는 요청 및 오류 처리를 처리하기 위해 "dio"에 인터셉터를 추가합니다.</p>
<p>오류 인터셉터:
이 메서드는 오류를 처리합니다. 특히, 오류가 401 Unauthorized인 경우 토큰을 새로 고치려고 시도합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">_onError</span>(<span class="hljs-title class_">DioException</span> e, <span class="hljs-title class_">ErrorInterceptorHandler</span> handler) <span class="hljs-keyword">async</span> {
  <span class="hljs-keyword">if</span>(e.<span class="hljs-property">response</span>?.<span class="hljs-property">statusCode</span> == <span class="hljs-number">401</span>) {
    <span class="hljs-title function_">_refreshToken</span>(e, handler);
  } <span class="hljs-keyword">else</span> {
    handler.<span class="hljs-title function_">next</span>(e);
  }
}
</code></pre>
<p>03- 토큰 새로고침 로직
" _refreshToken "메서드는 새 액세스 토큰을 받아오기 위해 리프레시 토큰을 사용하려고 시도합니다.</p>
<div class="content-ad"></div>
<ul>
<li>성공하면 저장된 토큰을 업데이트하고 원래 요청을 다시 시도합니다.</li>
<li>새로 고침이 실패하는 경우 (특히 새로 고침 토큰도 잘못된 경우), 사용자를 로그아웃 처리하고 오류를 거절합니다.</li>
</ul>
<pre><code class="hljs language-js">  <span class="hljs-title class_">Future</span>&#x3C;<span class="hljs-keyword">void</span>> <span class="hljs-title function_">_refreshToken</span>(<span class="hljs-title class_">DioException</span> e, <span class="hljs-title class_">ErrorInterceptorHandler</span> handler) <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">try</span> {
      final refreshToken = _appPref.<span class="hljs-title function_">getRefreshToken</span>();
      final response = <span class="hljs-keyword">await</span> _dio2.<span class="hljs-title function_">post</span>(
        <span class="hljs-title class_">ConstantsApi</span>.<span class="hljs-property">refreshTokenUrl</span>,
        <span class="hljs-attr">data</span>: {<span class="hljs-string">'refreshToken'</span>: refreshToken},
      );
      _appPref.<span class="hljs-title function_">setToken</span>(response.<span class="hljs-property">data</span>[<span class="hljs-string">'accessToken'</span>]);
      _appPref.<span class="hljs-title function_">setRefreshToken</span>(response.<span class="hljs-property">data</span>[<span class="hljs-string">'refreshToken'</span>]);
      handler.<span class="hljs-title function_">resolve</span>(<span class="hljs-keyword">await</span> _dio1.<span class="hljs-title function_">fetch</span>(e.<span class="hljs-property">requestOptions</span>));
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-keyword">if</span> (error is <span class="hljs-title class_">DioException</span>) {
        <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>?.<span class="hljs-property">statusCode</span> == <span class="hljs-number">401</span>) {
          <span class="hljs-title function_">_logout</span>();
          handler.<span class="hljs-title function_">reject</span>(e);
        } <span class="hljs-keyword">else</span> {
          handler.<span class="hljs-title function_">next</span>(error);
        }
      } <span class="hljs-keyword">else</span> {
        handler.<span class="hljs-title function_">next</span>(e);
      }
    }
  }
</code></pre>
<p>위 단계를 따라 하면 Dio를 사용하여 Flutter 애플리케이션에서 새로 고침 토큰을 처리할 수 있어서 사용자가 원할한 경험을 얻을 수 있습니다. 이 방법은 Dio 인스턴스의 구성을 중앙 집중화하고 토큰을 효율적으로 관리하는 데 도움이 됩니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Flutter에서 리프레시 토큰 사용하는 방법 모바일","description":"","date":"2024-06-21 23:50","slug":"2024-06-21-FlutterRefreshtokenmobileside","content":"\n\n플러터에서 Dio를 사용하여 토큰을 새로 고치는 방법\n\n![image](/assets/img/2024-06-21-FlutterRefreshtokenmobileside_0.png)\n\n현대 모바일 애플리케이션에서는 사용자 인증 세션을 원활하게 유지하는 것이 사용자 경험에 매우 중요합니다. 인증을 관리하는 효과적인 방법 중 하나는 리프레시 토큰을 사용하는 것입니다. 이 기사에서는 Dio를 사용하여 플러터 애플리케이션에서 리프레시 토큰을 처리하는 방법에 대해 살펴보겠습니다.\n\n토큰이란 무엇인가요?\n토큰은 토큰 기반 인증에서 애플리케이션이 API에 액세스할 수 있도록 허용하는 데 사용됩니다. 사용자가 성공적으로 인증하고 액세스 권한을 부여한 후 애플리케이션은 액세스 토큰을 받아들이고 대상 API를 호출할 때 자격 증명으로서 액세스 토큰을 전달합니다. 전달된 토큰은 API에게 전달된 토큰의 소유자가 API에 액세스할 권한이 있으며 승인 중에 부여된 범위에 따라 특정 조치를 수행할 수 있음을 알립니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리프레시 토큰이 무엇인가요?\n리프레시 토큰은 사용자가 다시 인증을 받지 않고 새로운 엑세스 토큰을 얻는 메커니즘입니다. 일반적으로 엑세스 토큰은 보안상의 이유로 수명이 짧지만, 리프레시 토큰은 더 오래 지속됩니다. 엑세스 토큰이 만료되면 리프레시 토큰을 사용하여 새로운 엑세스 토큰을 얻을 수 있어 사용자의 세션을 중단시키지 않고 유지할 수 있습니다.\n\n단계별로 리프레시 토큰 구현하기\n\nDio의 인스턴스를 구성하고 초기화하는 'DioFactory' 클래스를 만드세요.\n\n```js\nclass DioFactory {\n\n  Future\u003cDio\u003e getDio() async {\n    Dio dio = Dio();\n\n    Map\u003cString, String\u003e headers = {\n      contentType: applicationJson,\n      accept: applicationJson,\n    };\n\n    dio.options = BaseOptions(\n      baseUrl: ConstantsApi.baseUrl,\n      headers: headers,\n      receiveTimeout: const Duration(milliseconds: Constants.apiTimeOut),\n      sendTimeout: const Duration(milliseconds: Constants.apiTimeOut),\n      connectTimeout: const Duration(milliseconds: Constants.apiTimeOut),\n    );\n\n    if (!kReleaseMode) {\n      dio.interceptors.add(\n        PrettyDioLogger(\n          requestHeader: true,\n          requestBody: true,\n          responseHeader: true,\n          error: true,\n        ),\n      );\n    }\n\n    return dio;\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nApiService 클래스는 Dio를 사용하여 API 요청을 처리하고 인증 토큰을 관리하기 위해 설계된 포괄적인 서비스 레이어입니다. 이 클래스와 기능에 대한 자세한 설명을 제공합니다.\n\n01- 클래스 선언 및 필드\n“_dio1”과 “_dio2”는 \"Dio\"의 인스턴스입니다. “_dio1”은 일반 API 요청에 사용되고, “_dio2”는 토큰 갱신 요청에 사용됩니다.\n\n```js\nclass ApiService {\n  final Dio _dio1;\n  final Dio _dio2;\n  final AppPreferences _appPref;\n\n  ApiService(\n    this._dio1,\n    this._dio2,\n    this._appPref,\n  ) {\n    _dio1.interceptors.add(\n      InterceptorsWrapper(\n        onRequest: _onRequest,\n        onError: _onError,\n      ),\n    );\n  }\n}\n```\n\n02- 인터셉터\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n생성자는 요청 및 오류 처리를 처리하기 위해 \"dio\"에 인터셉터를 추가합니다.\n\n오류 인터셉터:\n이 메서드는 오류를 처리합니다. 특히, 오류가 401 Unauthorized인 경우 토큰을 새로 고치려고 시도합니다.\n\n```js\n_onError(DioException e, ErrorInterceptorHandler handler) async {\n  if(e.response?.statusCode == 401) {\n    _refreshToken(e, handler);\n  } else {\n    handler.next(e);\n  }\n}\n```\n\n03- 토큰 새로고침 로직\n\" _refreshToken \"메서드는 새 액세스 토큰을 받아오기 위해 리프레시 토큰을 사용하려고 시도합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 성공하면 저장된 토큰을 업데이트하고 원래 요청을 다시 시도합니다.\n- 새로 고침이 실패하는 경우 (특히 새로 고침 토큰도 잘못된 경우), 사용자를 로그아웃 처리하고 오류를 거절합니다.\n\n```js\n  Future\u003cvoid\u003e _refreshToken(DioException e, ErrorInterceptorHandler handler) async {\n    try {\n      final refreshToken = _appPref.getRefreshToken();\n      final response = await _dio2.post(\n        ConstantsApi.refreshTokenUrl,\n        data: {'refreshToken': refreshToken},\n      );\n      _appPref.setToken(response.data['accessToken']);\n      _appPref.setRefreshToken(response.data['refreshToken']);\n      handler.resolve(await _dio1.fetch(e.requestOptions));\n    } catch (error) {\n      if (error is DioException) {\n        if (error.response?.statusCode == 401) {\n          _logout();\n          handler.reject(e);\n        } else {\n          handler.next(error);\n        }\n      } else {\n        handler.next(e);\n      }\n    }\n  }\n```\n\n위 단계를 따라 하면 Dio를 사용하여 Flutter 애플리케이션에서 새로 고침 토큰을 처리할 수 있어서 사용자가 원할한 경험을 얻을 수 있습니다. 이 방법은 Dio 인스턴스의 구성을 중앙 집중화하고 토큰을 효율적으로 관리하는 데 도움이 됩니다.","ogImage":{"url":"/assets/img/2024-06-21-FlutterRefreshtokenmobileside_0.png"},"coverImage":"/assets/img/2024-06-21-FlutterRefreshtokenmobileside_0.png","tag":["Tech"],"readingTime":4},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e플러터에서 Dio를 사용하여 토큰을 새로 고치는 방법\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-FlutterRefreshtokenmobileside_0.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e현대 모바일 애플리케이션에서는 사용자 인증 세션을 원활하게 유지하는 것이 사용자 경험에 매우 중요합니다. 인증을 관리하는 효과적인 방법 중 하나는 리프레시 토큰을 사용하는 것입니다. 이 기사에서는 Dio를 사용하여 플러터 애플리케이션에서 리프레시 토큰을 처리하는 방법에 대해 살펴보겠습니다.\u003c/p\u003e\n\u003cp\u003e토큰이란 무엇인가요?\n토큰은 토큰 기반 인증에서 애플리케이션이 API에 액세스할 수 있도록 허용하는 데 사용됩니다. 사용자가 성공적으로 인증하고 액세스 권한을 부여한 후 애플리케이션은 액세스 토큰을 받아들이고 대상 API를 호출할 때 자격 증명으로서 액세스 토큰을 전달합니다. 전달된 토큰은 API에게 전달된 토큰의 소유자가 API에 액세스할 권한이 있으며 승인 중에 부여된 범위에 따라 특정 조치를 수행할 수 있음을 알립니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e리프레시 토큰이 무엇인가요?\n리프레시 토큰은 사용자가 다시 인증을 받지 않고 새로운 엑세스 토큰을 얻는 메커니즘입니다. 일반적으로 엑세스 토큰은 보안상의 이유로 수명이 짧지만, 리프레시 토큰은 더 오래 지속됩니다. 엑세스 토큰이 만료되면 리프레시 토큰을 사용하여 새로운 엑세스 토큰을 얻을 수 있어 사용자의 세션을 중단시키지 않고 유지할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e단계별로 리프레시 토큰 구현하기\u003c/p\u003e\n\u003cp\u003eDio의 인스턴스를 구성하고 초기화하는 'DioFactory' 클래스를 만드세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDioFactory\u003c/span\u003e {\n\n  \u003cspan class=\"hljs-title class_\"\u003eFuture\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eDio\u003c/span\u003e\u003e \u003cspan class=\"hljs-title function_\"\u003egetDio\u003c/span\u003e() \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n    \u003cspan class=\"hljs-title class_\"\u003eDio\u003c/span\u003e dio = \u003cspan class=\"hljs-title class_\"\u003eDio\u003c/span\u003e();\n\n    \u003cspan class=\"hljs-title class_\"\u003eMap\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e\u003e headers = {\n      \u003cspan class=\"hljs-attr\"\u003econtentType\u003c/span\u003e: applicationJson,\n      \u003cspan class=\"hljs-attr\"\u003eaccept\u003c/span\u003e: applicationJson,\n    };\n\n    dio.\u003cspan class=\"hljs-property\"\u003eoptions\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eBaseOptions\u003c/span\u003e(\n      \u003cspan class=\"hljs-attr\"\u003ebaseUrl\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eConstantsApi\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ebaseUrl\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003eheaders\u003c/span\u003e: headers,\n      \u003cspan class=\"hljs-attr\"\u003ereceiveTimeout\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDuration\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003emilliseconds\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eConstants\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eapiTimeOut\u003c/span\u003e),\n      \u003cspan class=\"hljs-attr\"\u003esendTimeout\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDuration\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003emilliseconds\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eConstants\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eapiTimeOut\u003c/span\u003e),\n      \u003cspan class=\"hljs-attr\"\u003econnectTimeout\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDuration\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003emilliseconds\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eConstants\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eapiTimeOut\u003c/span\u003e),\n    );\n\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!kReleaseMode) {\n      dio.\u003cspan class=\"hljs-property\"\u003einterceptors\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\n        \u003cspan class=\"hljs-title class_\"\u003ePrettyDioLogger\u003c/span\u003e(\n          \u003cspan class=\"hljs-attr\"\u003erequestHeader\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n          \u003cspan class=\"hljs-attr\"\u003erequestBody\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n          \u003cspan class=\"hljs-attr\"\u003eresponseHeader\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n          \u003cspan class=\"hljs-attr\"\u003eerror\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n        ),\n      );\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e dio;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eApiService 클래스는 Dio를 사용하여 API 요청을 처리하고 인증 토큰을 관리하기 위해 설계된 포괄적인 서비스 레이어입니다. 이 클래스와 기능에 대한 자세한 설명을 제공합니다.\u003c/p\u003e\n\u003cp\u003e01- 클래스 선언 및 필드\n“_dio1”과 “_dio2”는 \"Dio\"의 인스턴스입니다. “_dio1”은 일반 API 요청에 사용되고, “_dio2”는 토큰 갱신 요청에 사용됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eApiService\u003c/span\u003e {\n  final \u003cspan class=\"hljs-title class_\"\u003eDio\u003c/span\u003e _dio1;\n  final \u003cspan class=\"hljs-title class_\"\u003eDio\u003c/span\u003e _dio2;\n  final \u003cspan class=\"hljs-title class_\"\u003eAppPreferences\u003c/span\u003e _appPref;\n\n  \u003cspan class=\"hljs-title class_\"\u003eApiService\u003c/span\u003e(\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e_dio1\u003c/span\u003e,\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e_dio2\u003c/span\u003e,\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e_appPref\u003c/span\u003e,\n  ) {\n    _dio1.\u003cspan class=\"hljs-property\"\u003einterceptors\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\n      \u003cspan class=\"hljs-title class_\"\u003eInterceptorsWrapper\u003c/span\u003e(\n        \u003cspan class=\"hljs-attr\"\u003eonRequest\u003c/span\u003e: _onRequest,\n        \u003cspan class=\"hljs-attr\"\u003eonError\u003c/span\u003e: _onError,\n      ),\n    );\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e02- 인터셉터\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e생성자는 요청 및 오류 처리를 처리하기 위해 \"dio\"에 인터셉터를 추가합니다.\u003c/p\u003e\n\u003cp\u003e오류 인터셉터:\n이 메서드는 오류를 처리합니다. 특히, 오류가 401 Unauthorized인 경우 토큰을 새로 고치려고 시도합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title function_\"\u003e_onError\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eDioException\u003c/span\u003e e, \u003cspan class=\"hljs-title class_\"\u003eErrorInterceptorHandler\u003c/span\u003e handler) \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(e.\u003cspan class=\"hljs-property\"\u003eresponse\u003c/span\u003e?.\u003cspan class=\"hljs-property\"\u003estatusCode\u003c/span\u003e == \u003cspan class=\"hljs-number\"\u003e401\u003c/span\u003e) {\n    \u003cspan class=\"hljs-title function_\"\u003e_refreshToken\u003c/span\u003e(e, handler);\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    handler.\u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e(e);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e03- 토큰 새로고침 로직\n\" _refreshToken \"메서드는 새 액세스 토큰을 받아오기 위해 리프레시 토큰을 사용하려고 시도합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e성공하면 저장된 토큰을 업데이트하고 원래 요청을 다시 시도합니다.\u003c/li\u003e\n\u003cli\u003e새로 고침이 실패하는 경우 (특히 새로 고침 토큰도 잘못된 경우), 사용자를 로그아웃 처리하고 오류를 거절합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e  \u003cspan class=\"hljs-title class_\"\u003eFuture\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e\u003e \u003cspan class=\"hljs-title function_\"\u003e_refreshToken\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eDioException\u003c/span\u003e e, \u003cspan class=\"hljs-title class_\"\u003eErrorInterceptorHandler\u003c/span\u003e handler) \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n      final refreshToken = _appPref.\u003cspan class=\"hljs-title function_\"\u003egetRefreshToken\u003c/span\u003e();\n      final response = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e _dio2.\u003cspan class=\"hljs-title function_\"\u003epost\u003c/span\u003e(\n        \u003cspan class=\"hljs-title class_\"\u003eConstantsApi\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003erefreshTokenUrl\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e: {\u003cspan class=\"hljs-string\"\u003e'refreshToken'\u003c/span\u003e: refreshToken},\n      );\n      _appPref.\u003cspan class=\"hljs-title function_\"\u003esetToken\u003c/span\u003e(response.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e[\u003cspan class=\"hljs-string\"\u003e'accessToken'\u003c/span\u003e]);\n      _appPref.\u003cspan class=\"hljs-title function_\"\u003esetRefreshToken\u003c/span\u003e(response.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e[\u003cspan class=\"hljs-string\"\u003e'refreshToken'\u003c/span\u003e]);\n      handler.\u003cspan class=\"hljs-title function_\"\u003eresolve\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e _dio1.\u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(e.\u003cspan class=\"hljs-property\"\u003erequestOptions\u003c/span\u003e));\n    } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (error) {\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (error is \u003cspan class=\"hljs-title class_\"\u003eDioException\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (error.\u003cspan class=\"hljs-property\"\u003eresponse\u003c/span\u003e?.\u003cspan class=\"hljs-property\"\u003estatusCode\u003c/span\u003e == \u003cspan class=\"hljs-number\"\u003e401\u003c/span\u003e) {\n          \u003cspan class=\"hljs-title function_\"\u003e_logout\u003c/span\u003e();\n          handler.\u003cspan class=\"hljs-title function_\"\u003ereject\u003c/span\u003e(e);\n        } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n          handler.\u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e(error);\n        }\n      } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n        handler.\u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e(e);\n      }\n    }\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 단계를 따라 하면 Dio를 사용하여 Flutter 애플리케이션에서 새로 고침 토큰을 처리할 수 있어서 사용자가 원할한 경험을 얻을 수 있습니다. 이 방법은 Dio 인스턴스의 구성을 중앙 집중화하고 토큰을 효율적으로 관리하는 데 도움이 됩니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-21-FlutterRefreshtokenmobileside"},"buildId":"ckvP8zvWyPnScUqpsTElP","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>