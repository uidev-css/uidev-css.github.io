<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>플러터에서 BloC 패턴으로 Fetch API 사용 방법 | uidev-css</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://uidev-css.github.io///post/2024-06-21-FetchAPIWithBloCinFlutter" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="플러터에서 BloC 패턴으로 Fetch API 사용 방법 | uidev-css" data-gatsby-head="true"/><meta property="og:title" content="플러터에서 BloC 패턴으로 Fetch API 사용 방법 | uidev-css" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-21-FetchAPIWithBloCinFlutter_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://uidev-css.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://uidev-css.github.io///post/2024-06-21-FetchAPIWithBloCinFlutter" data-gatsby-head="true"/><meta name="twitter:title" content="플러터에서 BloC 패턴으로 Fetch API 사용 방법 | uidev-css" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-21-FetchAPIWithBloCinFlutter_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | uidev-css" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-21 22:39" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b75a4bf98ee956a8.js" defer=""></script><script src="/_next/static/fyfGyRz00q80ZdkogiVCt/_buildManifest.js" defer=""></script><script src="/_next/static/fyfGyRz00q80ZdkogiVCt/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UIDEV CSS</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">플러터에서 BloC 패턴으로 Fetch API 사용 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="플러터에서 BloC 패턴으로 Fetch API 사용 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UIDEV CSS</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 21, 2024</span><span class="posts_reading_time__f7YPP">10<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-21-FetchAPIWithBloCinFlutter&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>이 문서에서는 블록 라이브러리를 사용하여 HTTP 요청을 수행하고 애플리케이션의 상태를 관리하는 방법을 살펴보겠습니다. 최종 애플리케이션은 다음과 같습니다:</p>
<p><img src="https://miro.medium.com/v2/resize:fit:576/1*amzYfYKgiZ8zpehBTVcx4w.gif" alt="애플리케이션 데모"></p>
<p>앱이 처음 실행될 때, 서버에서 데이터를 가져올 때 로딩 표시기가 표시됩니다. 데이터를 가져온 후에는 목록에 표시됩니다.</p>
<p>이를 위해 몇 가지 패키지를 사용하겠습니다:</p>
<pre><code class="hljs language-yaml"><span class="hljs-attr">dependencies:</span>
  <span class="hljs-attr">flutter_bloc:</span> <span class="hljs-string">^8.1.1</span>
  <span class="hljs-attr">http:</span> <span class="hljs-string">^0.13.5</span>
  <span class="hljs-attr">equatable:</span> <span class="hljs-string">^2.0.5</span>
</code></pre>
<p>이제 API를 사용하여 서버에서 데이터를 가져오는 메커니즘을 만들어 보겠습니다. http 작업을 수행하기 위해 lib 내부에 폴더를 생성하고 repo라는 이름으로 지정합니다. 이 repo 내부에 repositories.dart라는 새 파일을 생성합니다.</p>
<pre><code class="hljs language-dart"><span class="hljs-keyword">import</span> <span class="hljs-string">'dart:convert'</span>;

<span class="hljs-keyword">import</span> <span class="hljs-string">'package:bloc_example/models/user_model.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:http/http.dart'</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserRepository</span> </span>{
  <span class="hljs-built_in">String</span> userUrl = <span class="hljs-string">'https://reqres.in/api/users?page=2'</span>;

  Future&#x3C;<span class="hljs-built_in">List</span>&#x3C;UserModel>> getUsers() <span class="hljs-keyword">async</span> {
    Response response = <span class="hljs-keyword">await</span> <span class="hljs-keyword">get</span>(<span class="hljs-built_in">Uri</span>.parse(userUrl));
   
    <span class="hljs-keyword">if</span> (response.statusCode == <span class="hljs-number">200</span>) {
      <span class="hljs-keyword">final</span> <span class="hljs-built_in">List</span> result = jsonDecode(response.body)[<span class="hljs-string">'data'</span>];
      <span class="hljs-keyword">return</span> result.map((e) => UserModel.fromJson(e)).toList();
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">throw</span> Exception(response.reasonPhrase);
    }
  }
}
</code></pre>
<p>http 요청을 수행하려면 http 패키지를 사용할 것입니다. 이제 json 내용을 살펴봅시다. 우리는 이 링크의 API를 사용하고 있습니다.</p>
<p>위의 링크에서 제공되는 JSON을 보면 모델이 어떻게 보일지에 대한 아이디어를 얻을 수 있습니다. 이 JSON에서는 데이터 태그의 속성을 갖게 될 것입니다. 여기서 우리는 firstname, lastname, email, 그리고 avatar에 초점을 맞출 것입니다.</p>
<p>이제 모델 클래스를 만들어 봅시다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserModel</span> {
  int? id;
  <span class="hljs-title class_">String</span>? email;
  <span class="hljs-title class_">String</span>? firstName;
  <span class="hljs-title class_">String</span>? lastName;
  <span class="hljs-title class_">String</span>? avatar;

  <span class="hljs-title class_">UserModel</span>({<span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">email</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">avatar</span>});

  <span class="hljs-title class_">UserModel</span>.<span class="hljs-title function_">fromJson</span>(<span class="hljs-params"><span class="hljs-built_in">Map</span>&#x3C;<span class="hljs-built_in">String</span>, dynamic> json</span>) {
    id = json[<span class="hljs-string">'id'</span>];
    email = json[<span class="hljs-string">'email'</span>];
    firstName = json[<span class="hljs-string">'first_name'</span>];
    lastName = json[<span class="hljs-string">'last_name'</span>];
    avatar = json[<span class="hljs-string">'avatar'</span>];
  }
}
</code></pre>
<p>계속해서, 이제 우리의 블록이 어떻게 작동하는지에 대해 알아보겠습니다.</p>
<p>위의 그림을 보면</p>
<ul>
<li>먼저 UI가 있고 UI에서 블록으로 요청을 합니다.</li>
<li>블록에는 이벤트와 상태 두 가지가 있습니다. 먼저 UI가 블록에 연결되면 이벤트를 생성하고 트리거합니다.</li>
<li>이벤트는 최종적으로 엔드포인트를 통해 서버에 저장소를 호출합니다.</li>
<li>서버에서 데이터를 가져와 블록에 다시 전달합니다. 데이터가 있으므로 상태를 트리거합니다.</li>
<li>상태가 변경되었으므로 UI는 Bloc 패턴에서 알고 UI를 업데이트합니다.</li>
</ul>
<p>새 폴더 blocs를 만들고 app_states.dart라는 새 파일을 생성합니다.</p>
<pre><code class="hljs language-dart"><span class="hljs-keyword">import</span> <span class="hljs-string">'package:bloc_example/models/user_model.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:equatable/equatable.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter/material.dart'</span>;

<span class="hljs-meta">@immutable</span>
<span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Equatable</span> </span>{}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserLoadingState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">UserState</span> </span>{
  <span class="hljs-meta">@override</span>
  <span class="hljs-built_in">List</span>&#x3C;<span class="hljs-built_in">Object?</span>> <span class="hljs-keyword">get</span> props => [];
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserLoadedState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">UserState</span> </span>{
  <span class="hljs-keyword">final</span> <span class="hljs-built_in">List</span>&#x3C;UserModel> users;
  UserLoadedState(<span class="hljs-keyword">this</span>.users);
  <span class="hljs-meta">@override</span>
  <span class="hljs-built_in">List</span>&#x3C;<span class="hljs-built_in">Object?</span>> <span class="hljs-keyword">get</span> props => [users];
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserErrorState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">UserState</span> </span>{
  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> error;
  UserErrorState(<span class="hljs-keyword">this</span>.error);
  <span class="hljs-meta">@override</span>
  <span class="hljs-built_in">List</span>&#x3C;<span class="hljs-built_in">Object?</span>> <span class="hljs-keyword">get</span> props => [error];
}
</code></pre>
<p>Equatable를 사용하면 값들을 비교할 수 있습니다. 두 변수가 동일한 값을 갖고 있다면 UI를 변경하거나 업데이트하지 않을 것입니다.</p>
<p>먼저 상태를 생성하려면 equatable을 확장해야 하는 추상 클래스를 생성해야 합니다.</p>
<p>Bloc에서 x.obs를 통해 변수를 반응형으로 만들 수 있는 Getx와 달리 Bloc에서는 이와 같이 작동하지 않습니다. Bloc을 사용할 때는 모든 상태가 클래스임을 염두에 두어야 합니다.</p>
<p>이 프로젝트에서는 세 가지 상태가 있습니다.</p>
<ul>
<li>데이터를 불러올 때의 상태</li>
<li>데이터를 불러왔을 때의 상태</li>
<li>데이터를 가져오는 데 오류가 발생했을 때의 상태</li>
</ul>
<p>그리고 Equatable 내부에 get props라는 속성이 있습니다. 이를 재정의해야 합니다. UserState 클래스가 Equatable을 확장했으므로 UserLoadingState, UserLoadedState 및 UserErrorState 상태 클래스가 get props 속성에 액세스할 수 있게 됩니다. 이를 얻기 위해 재정의하고 해당 값을 설정해야 합니다.</p>
<p>상태 이후, Flutter 블록에서는 각 상태마다 이벤트가 있습니다. 지금 app_events.dart라는 파일을 만들어야 합니다. 상태와 마찬가지로 이벤트를 위한 클래스를 생성해야 합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-string">'package:equatable/equatable.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter/material.dart'</span>;

@immutable
abstract <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserEvent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Equatable</span> {
  <span class="hljs-keyword">const</span> <span class="hljs-title class_">UserEvent</span>();
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">LoadUserEvent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">UserEvent</span> {
  @override
  <span class="hljs-title class_">List</span>&#x3C;<span class="hljs-title class_">Object</span>?> get props => [];
}
</code></pre>
<p>상태처럼 이벤트도 Equatable 클래스를 확장해야 합니다. 각 이벤트를 위한 전용 클래스를 만들어야 합니다. 이벤트 클래스는 기본 클래스를 확장해야 합니다. 여기서 기본 클래스는 UserEvent입니다. 그리고 이벤트는 LoadUserEvent입니다. 그리고 get props를 재정의해야 합니다.</p>
<p>@immutable은 클래스의 속성을 변경하고 싶지 않다는 것을 나타냅니다.</p>
<p>상태와 이벤트를 생성한 후에는 그들을 연결하는 방법을 찾아야 합니다.</p>
<p>그러려면 새 클래스를 만들고 방금 만든 상태와 이벤트를 삽입해야 해요. 이제 Bloc 라이브러리를 사용하여 이것들을 연결해 보죠.</p>
<p>blocs 폴더 안에 app_blocs라는 새 파일을 만들어주세요.</p>
<pre><code class="hljs language-dart"><span class="hljs-keyword">import</span> <span class="hljs-string">'package:bloc_example/blocs/app_events.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:bloc_example/blocs/app_states.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:bloc_example/repos/repositories.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter_bloc/flutter_bloc.dart'</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserBloc</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Bloc</span>&#x3C;<span class="hljs-title">UserEvent</span>, <span class="hljs-title">UserState</span>> </span>{
  <span class="hljs-keyword">final</span> UserRepository _userRepository;

  UserBloc(<span class="hljs-keyword">this</span>._userRepository) : <span class="hljs-keyword">super</span>(UserLoadingState()) {
    <span class="hljs-keyword">on</span>&#x3C;LoadUserEvent>((event, emit) <span class="hljs-keyword">async</span> {
      emit(UserLoadingState());
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">final</span> users = <span class="hljs-keyword">await</span> _userRepository.getUsers();
        emit(UserLoadedState(users));
      } <span class="hljs-keyword">catch</span> (e) {
        emit(UserErrorState(e.toString()));
      }
    });
  }
}
</code></pre>
<p>여기엔 UserBloc이라는 클래스가 있습니다. 이 클래스는 Bloc을 확장합니다. 이 Bloc은 이벤트와 상태를 가져와야 합니다. 저희 경우에는 UserEvent와 UserState입니다. 이곳에서 사용하는 Bloc은 실제로 Bloc 라이브러리에서 제공됩니다.</p>
<p>이 UserBloc에는 리포지토리를 전달하는 생성자가 있어요. UI에서 이것을 호출할 거거든요. 이 클래스를 호출하는 동안 UserRepository를 전달합니다. Bloc을 사용했기 때문에 초기 상태를 슈퍼 생성자에 전달해야해요. 초기값을 호출한 후에는 on 메소드를 호출하게 됩니다.</p>
<p>이제 on 메소드는 이벤트 유형을 가져와서 LoadUserEvent를 여기에 전달합니다. 이 이벤트를 사용하여 어떤 작업을 수행할 수 있어요. 이 이벤트가 호출되면 일부 상태를 방출하도록 지정합니다. 이 경우에는 UserLoadingState를 UI에서 변경 사항을 확인하려고 해요.</p>
<p>BLoc에서 상태, 이벤트를 연결하여 상태를 트리거하고 작업할 수 있도록 하려면 lib 폴더에 homepage.dart라는 새 파일을 만들어요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HomePage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">StatelessWidget</span> {
  <span class="hljs-keyword">const</span> <span class="hljs-title class_">HomePage</span>({<span class="hljs-title class_">Key</span> key});

  @override
  <span class="hljs-title class_">Widget</span> <span class="hljs-title function_">build</span>(<span class="hljs-params">BuildContext context</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">MultiBlocProvider</span>(
      <span class="hljs-attr">providers</span>: [
        <span class="hljs-title class_">BlocProvider</span>&#x3C;<span class="hljs-title class_">UserBloc</span>>(
          <span class="hljs-attr">create</span>: <span class="hljs-function">(<span class="hljs-params">BuildContext context</span>) =></span> <span class="hljs-title class_">UserBloc</span>(<span class="hljs-title class_">UserRepository</span>()),
        ),
      ],
      <span class="hljs-attr">child</span>: <span class="hljs-title class_">Scaffold</span>(
          <span class="hljs-attr">appBar</span>: <span class="hljs-title class_">AppBar</span>(<span class="hljs-attr">title</span>: <span class="hljs-keyword">const</span> <span class="hljs-title class_">Text</span>(<span class="hljs-string">'The BloC App'</span>)),
          <span class="hljs-attr">body</span>: <span class="hljs-title function_">blocBody</span>()),
    );
  }

<span class="hljs-title class_">Widget</span> <span class="hljs-title function_">blocBody</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">BlocProvider</span>(
      <span class="hljs-attr">create</span>: <span class="hljs-function">(<span class="hljs-params">context</span>) =></span> <span class="hljs-title class_">UserBloc</span>(
        <span class="hljs-title class_">UserRepository</span>(),
      )..<span class="hljs-title function_">add</span>(<span class="hljs-title class_">LoadUserEvent</span>()),
      <span class="hljs-attr">child</span>: <span class="hljs-title class_">BlocBuilder</span>&#x3C;<span class="hljs-title class_">UserBloc</span>, <span class="hljs-title class_">UserState</span>>(
        <span class="hljs-attr">builder</span>: (context, state) {
          <span class="hljs-keyword">if</span> (state is <span class="hljs-title class_">UserLoadingState</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Center</span>(
              <span class="hljs-attr">child</span>: <span class="hljs-title class_">CircularProgressIndicator</span>(),
            );
          }
           <span class="hljs-keyword">if</span> (state is <span class="hljs-title class_">UserErrorState</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Center</span>(<span class="hljs-attr">child</span>:  <span class="hljs-title class_">Text</span>(<span class="hljs-string">"Error"</span>));
          }
          <span class="hljs-keyword">if</span> (state is <span class="hljs-title class_">UserLoadedState</span>) {
            <span class="hljs-title class_">List</span>&#x3C;<span class="hljs-title class_">UserModel</span>> userList = state.<span class="hljs-property">users</span>;
            <span class="hljs-keyword">return</span> <span class="hljs-title class_">ListView</span>.<span class="hljs-title function_">builder</span>(
                <span class="hljs-attr">itemCount</span>: userList.<span class="hljs-property">length</span>,
                <span class="hljs-attr">itemBuilder</span>: (_, index) {
                  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Padding</span>(
                    <span class="hljs-attr">padding</span>:
                        <span class="hljs-keyword">const</span> <span class="hljs-title class_">EdgeInsets</span>.<span class="hljs-title function_">symmetric</span>(<span class="hljs-attr">vertical</span>: <span class="hljs-number">4</span>, <span class="hljs-attr">horizontal</span>: <span class="hljs-number">8</span>),
                    <span class="hljs-attr">child</span>: <span class="hljs-title class_">Card</span>(
                        <span class="hljs-attr">color</span>: <span class="hljs-title class_">Theme</span>.<span class="hljs-title function_">of</span>(context).<span class="hljs-property">primaryColor</span>,
                        <span class="hljs-attr">child</span>: <span class="hljs-title class_">ListTile</span>(
                            <span class="hljs-attr">title</span>: <span class="hljs-title class_">Text</span>(
                              <span class="hljs-string">'${userList[index].firstName}  ${userList[index].lastName}'</span>,
                              <span class="hljs-attr">style</span>: <span class="hljs-keyword">const</span> <span class="hljs-title class_">TextStyle</span>(<span class="hljs-attr">color</span>: <span class="hljs-title class_">Colors</span>.<span class="hljs-property">white</span>),
                            ),

                            <span class="hljs-attr">subtitle</span>: <span class="hljs-title class_">Text</span>(
                              <span class="hljs-string">'${userList[index].email}'</span>,
                              <span class="hljs-attr">style</span>: <span class="hljs-keyword">const</span> <span class="hljs-title class_">TextStyle</span>(<span class="hljs-attr">color</span>: <span class="hljs-title class_">Colors</span>.<span class="hljs-property">white</span>),
                            ),
                            
                            <span class="hljs-attr">leading</span>: <span class="hljs-title class_">CircleAvatar</span>(
                              <span class="hljs-attr">backgroundImage</span>: <span class="hljs-title class_">NetworkImage</span>(
                                  userList[index].<span class="hljs-property">avatar</span>.<span class="hljs-title function_">toString</span>()),
                            ))),
                  );
                });
          }

          <span class="hljs-keyword">return</span> <span class="hljs-title class_">Container</span>();
        },
      ),
    );
  }
}
</code></pre>
<p>보시다시피 'MultiBlocProvider'가 제공되는 우리의 bloc 라이브러리에서 온 것을 확인할 수 있어요. 서버에서 데이터를로드하고 한 번만 로드하려고하기 때문에 빌드 방법에서 UserRepository를 주입합니다. bloc 형식의 MultiBlocProvider에서는 클래스에 여러 Bloc을 추가하여 전체 클래스에서 사용할 수 있습니다. 또한이 리포지토리를 배치할 위치에는 클래스가 있어야합니다. 우리의 경우에는 Scaffold입니다.</p>
<p>그래서 MultiBlocProvider가 하는 일은 서버에서 데이터를 이동시키고 이를 만들어서 데이터와 상태를 모든 하위 요소에서 사용할 수 있게하는 것입니다.</p>
<p>blocBody 내부에서 BlocProvider를 볼 수 있습니다. Getx에 익숙하다면 Get.put와 비슷합니다. BlocProvider 내부에서는 리포지토리와 함께 bloc 즉 UserBloc을 주입합니다. 위에서 이미 bloc을 주입했으므로 blocBody 내에서 이벤트에 액세스 할 수 있습니다.</p>
<p>리포지토리와 함께 bloc을 주입 한 후에는 이벤트 즉 LoadUserEvent를 추가하고 이를 사용하여 UserBloc에서 UserLoadingState를 트리거하는 캐스캐이딩 연산자를 사용합니다.</p>
<p>이제 빌더 내부의 상태를 확인할 수 있습니다. 세 가지 상태가 있으므로 각각을 확인하여 다른 작업을 수행하고 다른 UI를 반환합니다.</p>
<p>다음과 같이 확인할 수 있습니다.</p>
<ul>
<li><code>UserLoadingState</code>일 때는 데이터를 불러오고 있다는 의미로 CircularProgressIndicator를 표시합니다.</li>
<li><code>UserLoadedState</code>일 때는 데이터 목록을 반환합니다.</li>
<li><code>UserErrorState</code>일 때는 오류 메시지를 반환합니다.</li>
</ul>
<p>이제 애플리케이션을 실행하면 bloc 라이브러리를 사용하여 데이터가 검색될 것입니다.</p>
<p>단점을 확인하려면 잘못된 종단점을 만들어 보실 수 있습니다.</p>
<h1>결론</h1>
<p>이 글에서 Bloc 및 Bloc 작업 메커니즘에 대해 설명했습니다. 필요에 맞게 코드를 조정하여 사용해 보세요. 새 페이지를 만들어 보는 것도 좋은 방법입니다. Bloc 아키텍처는 대규모 프로젝트에 매우 유용할 수 있습니다.</p>
<p>이 블로그 게시물이 앞으로의 프로젝트에서 bloc 라이브러리와 아키텍처를 사용하는 데 충분한 중요한 정보를 제공해 줄 것을 바랍니다.</p>
<p>❤ ❤ 이 글 읽어주셔서 감사합니다 ❤ ❤</p>
<p>만약 이 글을 좋아하셨다면 👏 두 번 치세요.</p>
<p>또한, 업데이트되는 흥미로운 글과 프로젝트를 확인하려면 팔로우하세요.</p>
<p>무엇인가 잘못된 점이 있다면? 댓글로 알려주세요. 개선해나가겠습니다.</p>
<h1>함께 연결해요</h1>
<p>우리 친구가 되어요. 페이스북, 링크드인, 깃허브, 유튜브, BuyMeACoffee, 그리고 인스타그램에서 찾아요.</p>
<p>방문하기: Flutter Junction</p>
<p>기여하기: BuyMeACoffee</p>
<p>다음 링크에서 전체 코드를 확인하세요:</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"플러터에서 BloC 패턴으로 Fetch API 사용 방법","description":"","date":"2024-06-21 22:39","slug":"2024-06-21-FetchAPIWithBloCinFlutter","content":"\n\n이 문서에서는 블록 라이브러리를 사용하여 HTTP 요청을 수행하고 애플리케이션의 상태를 관리하는 방법을 살펴보겠습니다. 최종 애플리케이션은 다음과 같습니다:\n\n![애플리케이션 데모](https://miro.medium.com/v2/resize:fit:576/1*amzYfYKgiZ8zpehBTVcx4w.gif)\n\n앱이 처음 실행될 때, 서버에서 데이터를 가져올 때 로딩 표시기가 표시됩니다. 데이터를 가져온 후에는 목록에 표시됩니다.\n\n이를 위해 몇 가지 패키지를 사용하겠습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```yaml\ndependencies:\n  flutter_bloc: ^8.1.1\n  http: ^0.13.5\n  equatable: ^2.0.5\n```\n\n이제 API를 사용하여 서버에서 데이터를 가져오는 메커니즘을 만들어 보겠습니다. http 작업을 수행하기 위해 lib 내부에 폴더를 생성하고 repo라는 이름으로 지정합니다. 이 repo 내부에 repositories.dart라는 새 파일을 생성합니다.\n\n```dart\nimport 'dart:convert';\n\nimport 'package:bloc_example/models/user_model.dart';\nimport 'package:http/http.dart';\n\nclass UserRepository {\n  String userUrl = 'https://reqres.in/api/users?page=2';\n\n  Future\u003cList\u003cUserModel\u003e\u003e getUsers() async {\n    Response response = await get(Uri.parse(userUrl));\n   \n    if (response.statusCode == 200) {\n      final List result = jsonDecode(response.body)['data'];\n      return result.map((e) =\u003e UserModel.fromJson(e)).toList();\n    } else {\n      throw Exception(response.reasonPhrase);\n    }\n  }\n}\n```\n\nhttp 요청을 수행하려면 http 패키지를 사용할 것입니다. 이제 json 내용을 살펴봅시다. 우리는 이 링크의 API를 사용하고 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 링크에서 제공되는 JSON을 보면 모델이 어떻게 보일지에 대한 아이디어를 얻을 수 있습니다. 이 JSON에서는 데이터 태그의 속성을 갖게 될 것입니다. 여기서 우리는 firstname, lastname, email, 그리고 avatar에 초점을 맞출 것입니다.\n\n이제 모델 클래스를 만들어 봅시다.\n\n```js\nclass UserModel {\n  int? id;\n  String? email;\n  String? firstName;\n  String? lastName;\n  String? avatar;\n\n  UserModel({this.id, this.email, this.firstName, this.lastName, this.avatar});\n\n  UserModel.fromJson(Map\u003cString, dynamic\u003e json) {\n    id = json['id'];\n    email = json['email'];\n    firstName = json['first_name'];\n    lastName = json['last_name'];\n    avatar = json['avatar'];\n  }\n}\n```\n\n계속해서, 이제 우리의 블록이 어떻게 작동하는지에 대해 알아보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-21-FetchAPIWithBloCinFlutter_0.png\" /\u003e\n\n위의 그림을 보면\n\n- 먼저 UI가 있고 UI에서 블록으로 요청을 합니다.\n- 블록에는 이벤트와 상태 두 가지가 있습니다. 먼저 UI가 블록에 연결되면 이벤트를 생성하고 트리거합니다.\n- 이벤트는 최종적으로 엔드포인트를 통해 서버에 저장소를 호출합니다.\n- 서버에서 데이터를 가져와 블록에 다시 전달합니다. 데이터가 있으므로 상태를 트리거합니다.\n- 상태가 변경되었으므로 UI는 Bloc 패턴에서 알고 UI를 업데이트합니다.\n\n새 폴더 blocs를 만들고 app_states.dart라는 새 파일을 생성합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```dart\nimport 'package:bloc_example/models/user_model.dart';\nimport 'package:equatable/equatable.dart';\nimport 'package:flutter/material.dart';\n\n@immutable\nabstract class UserState extends Equatable {}\n\nclass UserLoadingState extends UserState {\n  @override\n  List\u003cObject?\u003e get props =\u003e [];\n}\n\nclass UserLoadedState extends UserState {\n  final List\u003cUserModel\u003e users;\n  UserLoadedState(this.users);\n  @override\n  List\u003cObject?\u003e get props =\u003e [users];\n}\n\nclass UserErrorState extends UserState {\n  final String error;\n  UserErrorState(this.error);\n  @override\n  List\u003cObject?\u003e get props =\u003e [error];\n}\n```\n\nEquatable를 사용하면 값들을 비교할 수 있습니다. 두 변수가 동일한 값을 갖고 있다면 UI를 변경하거나 업데이트하지 않을 것입니다.\n\n먼저 상태를 생성하려면 equatable을 확장해야 하는 추상 클래스를 생성해야 합니다.\n\nBloc에서 x.obs를 통해 변수를 반응형으로 만들 수 있는 Getx와 달리 Bloc에서는 이와 같이 작동하지 않습니다. Bloc을 사용할 때는 모든 상태가 클래스임을 염두에 두어야 합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 프로젝트에서는 세 가지 상태가 있습니다.\n\n- 데이터를 불러올 때의 상태\n- 데이터를 불러왔을 때의 상태\n- 데이터를 가져오는 데 오류가 발생했을 때의 상태\n\n그리고 Equatable 내부에 get props라는 속성이 있습니다. 이를 재정의해야 합니다. UserState 클래스가 Equatable을 확장했으므로 UserLoadingState, UserLoadedState 및 UserErrorState 상태 클래스가 get props 속성에 액세스할 수 있게 됩니다. 이를 얻기 위해 재정의하고 해당 값을 설정해야 합니다.\n\n상태 이후, Flutter 블록에서는 각 상태마다 이벤트가 있습니다. 지금 app_events.dart라는 파일을 만들어야 합니다. 상태와 마찬가지로 이벤트를 위한 클래스를 생성해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport 'package:equatable/equatable.dart';\nimport 'package:flutter/material.dart';\n\n@immutable\nabstract class UserEvent extends Equatable {\n  const UserEvent();\n}\n\nclass LoadUserEvent extends UserEvent {\n  @override\n  List\u003cObject?\u003e get props =\u003e [];\n}\n```\n\n상태처럼 이벤트도 Equatable 클래스를 확장해야 합니다. 각 이벤트를 위한 전용 클래스를 만들어야 합니다. 이벤트 클래스는 기본 클래스를 확장해야 합니다. 여기서 기본 클래스는 UserEvent입니다. 그리고 이벤트는 LoadUserEvent입니다. 그리고 get props를 재정의해야 합니다.\n\n@immutable은 클래스의 속성을 변경하고 싶지 않다는 것을 나타냅니다.\n\n상태와 이벤트를 생성한 후에는 그들을 연결하는 방법을 찾아야 합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러려면 새 클래스를 만들고 방금 만든 상태와 이벤트를 삽입해야 해요. 이제 Bloc 라이브러리를 사용하여 이것들을 연결해 보죠.\n\nblocs 폴더 안에 app_blocs라는 새 파일을 만들어주세요.\n\n```dart\nimport 'package:bloc_example/blocs/app_events.dart';\nimport 'package:bloc_example/blocs/app_states.dart';\nimport 'package:bloc_example/repos/repositories.dart';\nimport 'package:flutter_bloc/flutter_bloc.dart';\n\nclass UserBloc extends Bloc\u003cUserEvent, UserState\u003e {\n  final UserRepository _userRepository;\n\n  UserBloc(this._userRepository) : super(UserLoadingState()) {\n    on\u003cLoadUserEvent\u003e((event, emit) async {\n      emit(UserLoadingState());\n      try {\n        final users = await _userRepository.getUsers();\n        emit(UserLoadedState(users));\n      } catch (e) {\n        emit(UserErrorState(e.toString()));\n      }\n    });\n  }\n}\n```\n\n여기엔 UserBloc이라는 클래스가 있습니다. 이 클래스는 Bloc을 확장합니다. 이 Bloc은 이벤트와 상태를 가져와야 합니다. 저희 경우에는 UserEvent와 UserState입니다. 이곳에서 사용하는 Bloc은 실제로 Bloc 라이브러리에서 제공됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 UserBloc에는 리포지토리를 전달하는 생성자가 있어요. UI에서 이것을 호출할 거거든요. 이 클래스를 호출하는 동안 UserRepository를 전달합니다. Bloc을 사용했기 때문에 초기 상태를 슈퍼 생성자에 전달해야해요. 초기값을 호출한 후에는 on 메소드를 호출하게 됩니다.\n\n이제 on 메소드는 이벤트 유형을 가져와서 LoadUserEvent를 여기에 전달합니다. 이 이벤트를 사용하여 어떤 작업을 수행할 수 있어요. 이 이벤트가 호출되면 일부 상태를 방출하도록 지정합니다. 이 경우에는 UserLoadingState를 UI에서 변경 사항을 확인하려고 해요.\n\nBLoc에서 상태, 이벤트를 연결하여 상태를 트리거하고 작업할 수 있도록 하려면 lib 폴더에 homepage.dart라는 새 파일을 만들어요.\n\n```js\nclass HomePage extends StatelessWidget {\n  const HomePage({Key key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MultiBlocProvider(\n      providers: [\n        BlocProvider\u003cUserBloc\u003e(\n          create: (BuildContext context) =\u003e UserBloc(UserRepository()),\n        ),\n      ],\n      child: Scaffold(\n          appBar: AppBar(title: const Text('The BloC App')),\n          body: blocBody()),\n    );\n  }\n\nWidget blocBody() {\n    return BlocProvider(\n      create: (context) =\u003e UserBloc(\n        UserRepository(),\n      )..add(LoadUserEvent()),\n      child: BlocBuilder\u003cUserBloc, UserState\u003e(\n        builder: (context, state) {\n          if (state is UserLoadingState) {\n            return const Center(\n              child: CircularProgressIndicator(),\n            );\n          }\n           if (state is UserErrorState) {\n            return const Center(child:  Text(\"Error\"));\n          }\n          if (state is UserLoadedState) {\n            List\u003cUserModel\u003e userList = state.users;\n            return ListView.builder(\n                itemCount: userList.length,\n                itemBuilder: (_, index) {\n                  return Padding(\n                    padding:\n                        const EdgeInsets.symmetric(vertical: 4, horizontal: 8),\n                    child: Card(\n                        color: Theme.of(context).primaryColor,\n                        child: ListTile(\n                            title: Text(\n                              '${userList[index].firstName}  ${userList[index].lastName}',\n                              style: const TextStyle(color: Colors.white),\n                            ),\n\n                            subtitle: Text(\n                              '${userList[index].email}',\n                              style: const TextStyle(color: Colors.white),\n                            ),\n                            \n                            leading: CircleAvatar(\n                              backgroundImage: NetworkImage(\n                                  userList[index].avatar.toString()),\n                            ))),\n                  );\n                });\n          }\n\n          return Container();\n        },\n      ),\n    );\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n보시다시피 'MultiBlocProvider'가 제공되는 우리의 bloc 라이브러리에서 온 것을 확인할 수 있어요. 서버에서 데이터를로드하고 한 번만 로드하려고하기 때문에 빌드 방법에서 UserRepository를 주입합니다. bloc 형식의 MultiBlocProvider에서는 클래스에 여러 Bloc을 추가하여 전체 클래스에서 사용할 수 있습니다. 또한이 리포지토리를 배치할 위치에는 클래스가 있어야합니다. 우리의 경우에는 Scaffold입니다.\n\n그래서 MultiBlocProvider가 하는 일은 서버에서 데이터를 이동시키고 이를 만들어서 데이터와 상태를 모든 하위 요소에서 사용할 수 있게하는 것입니다.\n\nblocBody 내부에서 BlocProvider를 볼 수 있습니다. Getx에 익숙하다면 Get.put와 비슷합니다. BlocProvider 내부에서는 리포지토리와 함께 bloc 즉 UserBloc을 주입합니다. 위에서 이미 bloc을 주입했으므로 blocBody 내에서 이벤트에 액세스 할 수 있습니다.\n\n리포지토리와 함께 bloc을 주입 한 후에는 이벤트 즉 LoadUserEvent를 추가하고 이를 사용하여 UserBloc에서 UserLoadingState를 트리거하는 캐스캐이딩 연산자를 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 빌더 내부의 상태를 확인할 수 있습니다. 세 가지 상태가 있으므로 각각을 확인하여 다른 작업을 수행하고 다른 UI를 반환합니다.\n\n다음과 같이 확인할 수 있습니다.\n\n- `UserLoadingState`일 때는 데이터를 불러오고 있다는 의미로 CircularProgressIndicator를 표시합니다.\n- `UserLoadedState`일 때는 데이터 목록을 반환합니다.\n- `UserErrorState`일 때는 오류 메시지를 반환합니다.\n\n이제 애플리케이션을 실행하면 bloc 라이브러리를 사용하여 데이터가 검색될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n단점을 확인하려면 잘못된 종단점을 만들어 보실 수 있습니다.\n\n# 결론\n\n이 글에서 Bloc 및 Bloc 작업 메커니즘에 대해 설명했습니다. 필요에 맞게 코드를 조정하여 사용해 보세요. 새 페이지를 만들어 보는 것도 좋은 방법입니다. Bloc 아키텍처는 대규모 프로젝트에 매우 유용할 수 있습니다.\n\n이 블로그 게시물이 앞으로의 프로젝트에서 bloc 라이브러리와 아키텍처를 사용하는 데 충분한 중요한 정보를 제공해 줄 것을 바랍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n❤ ❤ 이 글 읽어주셔서 감사합니다 ❤ ❤\n\n만약 이 글을 좋아하셨다면 👏 두 번 치세요.\n\n또한, 업데이트되는 흥미로운 글과 프로젝트를 확인하려면 팔로우하세요.\n\n무엇인가 잘못된 점이 있다면? 댓글로 알려주세요. 개선해나가겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 함께 연결해요\n\n우리 친구가 되어요. 페이스북, 링크드인, 깃허브, 유튜브, BuyMeACoffee, 그리고 인스타그램에서 찾아요.\n\n방문하기: Flutter Junction\n\n기여하기: BuyMeACoffee\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 링크에서 전체 코드를 확인하세요:","ogImage":{"url":"/assets/img/2024-06-21-FetchAPIWithBloCinFlutter_0.png"},"coverImage":"/assets/img/2024-06-21-FetchAPIWithBloCinFlutter_0.png","tag":["Tech"],"readingTime":10},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e이 문서에서는 블록 라이브러리를 사용하여 HTTP 요청을 수행하고 애플리케이션의 상태를 관리하는 방법을 살펴보겠습니다. 최종 애플리케이션은 다음과 같습니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:576/1*amzYfYKgiZ8zpehBTVcx4w.gif\" alt=\"애플리케이션 데모\"\u003e\u003c/p\u003e\n\u003cp\u003e앱이 처음 실행될 때, 서버에서 데이터를 가져올 때 로딩 표시기가 표시됩니다. 데이터를 가져온 후에는 목록에 표시됩니다.\u003c/p\u003e\n\u003cp\u003e이를 위해 몇 가지 패키지를 사용하겠습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-yaml\"\u003e\u003cspan class=\"hljs-attr\"\u003edependencies:\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003eflutter_bloc:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e^8.1.1\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003ehttp:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e^0.13.5\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003eequatable:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e^2.0.5\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 API를 사용하여 서버에서 데이터를 가져오는 메커니즘을 만들어 보겠습니다. http 작업을 수행하기 위해 lib 내부에 폴더를 생성하고 repo라는 이름으로 지정합니다. 이 repo 내부에 repositories.dart라는 새 파일을 생성합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-dart\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'dart:convert'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:bloc_example/models/user_model.dart'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:http/http.dart'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eUserRepository\u003c/span\u003e \u003c/span\u003e{\n  \u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e userUrl = \u003cspan class=\"hljs-string\"\u003e'https://reqres.in/api/users?page=2'\u003c/span\u003e;\n\n  Future\u0026#x3C;\u003cspan class=\"hljs-built_in\"\u003eList\u003c/span\u003e\u0026#x3C;UserModel\u003e\u003e getUsers() \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n    Response response = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-built_in\"\u003eUri\u003c/span\u003e.parse(userUrl));\n   \n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (response.statusCode == \u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003efinal\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eList\u003c/span\u003e result = jsonDecode(response.body)[\u003cspan class=\"hljs-string\"\u003e'data'\u003c/span\u003e];\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e result.map((e) =\u003e UserModel.fromJson(e)).toList();\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e Exception(response.reasonPhrase);\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ehttp 요청을 수행하려면 http 패키지를 사용할 것입니다. 이제 json 내용을 살펴봅시다. 우리는 이 링크의 API를 사용하고 있습니다.\u003c/p\u003e\n\u003cp\u003e위의 링크에서 제공되는 JSON을 보면 모델이 어떻게 보일지에 대한 아이디어를 얻을 수 있습니다. 이 JSON에서는 데이터 태그의 속성을 갖게 될 것입니다. 여기서 우리는 firstname, lastname, email, 그리고 avatar에 초점을 맞출 것입니다.\u003c/p\u003e\n\u003cp\u003e이제 모델 클래스를 만들어 봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUserModel\u003c/span\u003e {\n  int? id;\n  \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e? email;\n  \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e? firstName;\n  \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e? lastName;\n  \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e? avatar;\n\n  \u003cspan class=\"hljs-title class_\"\u003eUserModel\u003c/span\u003e({\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e, \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eemail\u003c/span\u003e, \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003efirstName\u003c/span\u003e, \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003elastName\u003c/span\u003e, \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eavatar\u003c/span\u003e});\n\n  \u003cspan class=\"hljs-title class_\"\u003eUserModel\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efromJson\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-built_in\"\u003eMap\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e, dynamic\u003e json\u003c/span\u003e) {\n    id = json[\u003cspan class=\"hljs-string\"\u003e'id'\u003c/span\u003e];\n    email = json[\u003cspan class=\"hljs-string\"\u003e'email'\u003c/span\u003e];\n    firstName = json[\u003cspan class=\"hljs-string\"\u003e'first_name'\u003c/span\u003e];\n    lastName = json[\u003cspan class=\"hljs-string\"\u003e'last_name'\u003c/span\u003e];\n    avatar = json[\u003cspan class=\"hljs-string\"\u003e'avatar'\u003c/span\u003e];\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e계속해서, 이제 우리의 블록이 어떻게 작동하는지에 대해 알아보겠습니다.\u003c/p\u003e\n\u003cp\u003e위의 그림을 보면\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e먼저 UI가 있고 UI에서 블록으로 요청을 합니다.\u003c/li\u003e\n\u003cli\u003e블록에는 이벤트와 상태 두 가지가 있습니다. 먼저 UI가 블록에 연결되면 이벤트를 생성하고 트리거합니다.\u003c/li\u003e\n\u003cli\u003e이벤트는 최종적으로 엔드포인트를 통해 서버에 저장소를 호출합니다.\u003c/li\u003e\n\u003cli\u003e서버에서 데이터를 가져와 블록에 다시 전달합니다. 데이터가 있으므로 상태를 트리거합니다.\u003c/li\u003e\n\u003cli\u003e상태가 변경되었으므로 UI는 Bloc 패턴에서 알고 UI를 업데이트합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e새 폴더 blocs를 만들고 app_states.dart라는 새 파일을 생성합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-dart\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:bloc_example/models/user_model.dart'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:equatable/equatable.dart'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:flutter/material.dart'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-meta\"\u003e@immutable\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eabstract\u003c/span\u003e \u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eUserState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eEquatable\u003c/span\u003e \u003c/span\u003e{}\n\n\u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eUserLoadingState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eUserState\u003c/span\u003e \u003c/span\u003e{\n  \u003cspan class=\"hljs-meta\"\u003e@override\u003c/span\u003e\n  \u003cspan class=\"hljs-built_in\"\u003eList\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-built_in\"\u003eObject?\u003c/span\u003e\u003e \u003cspan class=\"hljs-keyword\"\u003eget\u003c/span\u003e props =\u003e [];\n}\n\n\u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eUserLoadedState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eUserState\u003c/span\u003e \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003efinal\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eList\u003c/span\u003e\u0026#x3C;UserModel\u003e users;\n  UserLoadedState(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.users);\n  \u003cspan class=\"hljs-meta\"\u003e@override\u003c/span\u003e\n  \u003cspan class=\"hljs-built_in\"\u003eList\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-built_in\"\u003eObject?\u003c/span\u003e\u003e \u003cspan class=\"hljs-keyword\"\u003eget\u003c/span\u003e props =\u003e [users];\n}\n\n\u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eUserErrorState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eUserState\u003c/span\u003e \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003efinal\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e error;\n  UserErrorState(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.error);\n  \u003cspan class=\"hljs-meta\"\u003e@override\u003c/span\u003e\n  \u003cspan class=\"hljs-built_in\"\u003eList\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-built_in\"\u003eObject?\u003c/span\u003e\u003e \u003cspan class=\"hljs-keyword\"\u003eget\u003c/span\u003e props =\u003e [error];\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEquatable를 사용하면 값들을 비교할 수 있습니다. 두 변수가 동일한 값을 갖고 있다면 UI를 변경하거나 업데이트하지 않을 것입니다.\u003c/p\u003e\n\u003cp\u003e먼저 상태를 생성하려면 equatable을 확장해야 하는 추상 클래스를 생성해야 합니다.\u003c/p\u003e\n\u003cp\u003eBloc에서 x.obs를 통해 변수를 반응형으로 만들 수 있는 Getx와 달리 Bloc에서는 이와 같이 작동하지 않습니다. Bloc을 사용할 때는 모든 상태가 클래스임을 염두에 두어야 합니다.\u003c/p\u003e\n\u003cp\u003e이 프로젝트에서는 세 가지 상태가 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e데이터를 불러올 때의 상태\u003c/li\u003e\n\u003cli\u003e데이터를 불러왔을 때의 상태\u003c/li\u003e\n\u003cli\u003e데이터를 가져오는 데 오류가 발생했을 때의 상태\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e그리고 Equatable 내부에 get props라는 속성이 있습니다. 이를 재정의해야 합니다. UserState 클래스가 Equatable을 확장했으므로 UserLoadingState, UserLoadedState 및 UserErrorState 상태 클래스가 get props 속성에 액세스할 수 있게 됩니다. 이를 얻기 위해 재정의하고 해당 값을 설정해야 합니다.\u003c/p\u003e\n\u003cp\u003e상태 이후, Flutter 블록에서는 각 상태마다 이벤트가 있습니다. 지금 app_events.dart라는 파일을 만들어야 합니다. 상태와 마찬가지로 이벤트를 위한 클래스를 생성해야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:equatable/equatable.dart'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:flutter/material.dart'\u003c/span\u003e;\n\n@immutable\nabstract \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUserEvent\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eEquatable\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUserEvent\u003c/span\u003e();\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eLoadUserEvent\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eUserEvent\u003c/span\u003e {\n  @override\n  \u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e?\u003e get props =\u003e [];\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e상태처럼 이벤트도 Equatable 클래스를 확장해야 합니다. 각 이벤트를 위한 전용 클래스를 만들어야 합니다. 이벤트 클래스는 기본 클래스를 확장해야 합니다. 여기서 기본 클래스는 UserEvent입니다. 그리고 이벤트는 LoadUserEvent입니다. 그리고 get props를 재정의해야 합니다.\u003c/p\u003e\n\u003cp\u003e@immutable은 클래스의 속성을 변경하고 싶지 않다는 것을 나타냅니다.\u003c/p\u003e\n\u003cp\u003e상태와 이벤트를 생성한 후에는 그들을 연결하는 방법을 찾아야 합니다.\u003c/p\u003e\n\u003cp\u003e그러려면 새 클래스를 만들고 방금 만든 상태와 이벤트를 삽입해야 해요. 이제 Bloc 라이브러리를 사용하여 이것들을 연결해 보죠.\u003c/p\u003e\n\u003cp\u003eblocs 폴더 안에 app_blocs라는 새 파일을 만들어주세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-dart\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:bloc_example/blocs/app_events.dart'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:bloc_example/blocs/app_states.dart'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:bloc_example/repos/repositories.dart'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:flutter_bloc/flutter_bloc.dart'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eUserBloc\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eBloc\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title\"\u003eUserEvent\u003c/span\u003e, \u003cspan class=\"hljs-title\"\u003eUserState\u003c/span\u003e\u003e \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003efinal\u003c/span\u003e UserRepository _userRepository;\n\n  UserBloc(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e._userRepository) : \u003cspan class=\"hljs-keyword\"\u003esuper\u003c/span\u003e(UserLoadingState()) {\n    \u003cspan class=\"hljs-keyword\"\u003eon\u003c/span\u003e\u0026#x3C;LoadUserEvent\u003e((event, emit) \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n      emit(UserLoadingState());\n      \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003efinal\u003c/span\u003e users = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e _userRepository.getUsers();\n        emit(UserLoadedState(users));\n      } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (e) {\n        emit(UserErrorState(e.toString()));\n      }\n    });\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기엔 UserBloc이라는 클래스가 있습니다. 이 클래스는 Bloc을 확장합니다. 이 Bloc은 이벤트와 상태를 가져와야 합니다. 저희 경우에는 UserEvent와 UserState입니다. 이곳에서 사용하는 Bloc은 실제로 Bloc 라이브러리에서 제공됩니다.\u003c/p\u003e\n\u003cp\u003e이 UserBloc에는 리포지토리를 전달하는 생성자가 있어요. UI에서 이것을 호출할 거거든요. 이 클래스를 호출하는 동안 UserRepository를 전달합니다. Bloc을 사용했기 때문에 초기 상태를 슈퍼 생성자에 전달해야해요. 초기값을 호출한 후에는 on 메소드를 호출하게 됩니다.\u003c/p\u003e\n\u003cp\u003e이제 on 메소드는 이벤트 유형을 가져와서 LoadUserEvent를 여기에 전달합니다. 이 이벤트를 사용하여 어떤 작업을 수행할 수 있어요. 이 이벤트가 호출되면 일부 상태를 방출하도록 지정합니다. 이 경우에는 UserLoadingState를 UI에서 변경 사항을 확인하려고 해요.\u003c/p\u003e\n\u003cp\u003eBLoc에서 상태, 이벤트를 연결하여 상태를 트리거하고 작업할 수 있도록 하려면 lib 폴더에 homepage.dart라는 새 파일을 만들어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHomePage\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eStatelessWidget\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHomePage\u003c/span\u003e({\u003cspan class=\"hljs-title class_\"\u003eKey\u003c/span\u003e key});\n\n  @override\n  \u003cspan class=\"hljs-title class_\"\u003eWidget\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebuild\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eBuildContext context\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMultiBlocProvider\u003c/span\u003e(\n      \u003cspan class=\"hljs-attr\"\u003eproviders\u003c/span\u003e: [\n        \u003cspan class=\"hljs-title class_\"\u003eBlocProvider\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eUserBloc\u003c/span\u003e\u003e(\n          \u003cspan class=\"hljs-attr\"\u003ecreate\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eBuildContext context\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUserBloc\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eUserRepository\u003c/span\u003e()),\n        ),\n      ],\n      \u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eScaffold\u003c/span\u003e(\n          \u003cspan class=\"hljs-attr\"\u003eappBar\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eAppBar\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'The BloC App'\u003c/span\u003e)),\n          \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: \u003cspan class=\"hljs-title function_\"\u003eblocBody\u003c/span\u003e()),\n    );\n  }\n\n\u003cspan class=\"hljs-title class_\"\u003eWidget\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eblocBody\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBlocProvider\u003c/span\u003e(\n      \u003cspan class=\"hljs-attr\"\u003ecreate\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003econtext\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUserBloc\u003c/span\u003e(\n        \u003cspan class=\"hljs-title class_\"\u003eUserRepository\u003c/span\u003e(),\n      )..\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eLoadUserEvent\u003c/span\u003e()),\n      \u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eBlocBuilder\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eUserBloc\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eUserState\u003c/span\u003e\u003e(\n        \u003cspan class=\"hljs-attr\"\u003ebuilder\u003c/span\u003e: (context, state) {\n          \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (state is \u003cspan class=\"hljs-title class_\"\u003eUserLoadingState\u003c/span\u003e) {\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCenter\u003c/span\u003e(\n              \u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCircularProgressIndicator\u003c/span\u003e(),\n            );\n          }\n           \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (state is \u003cspan class=\"hljs-title class_\"\u003eUserErrorState\u003c/span\u003e) {\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCenter\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e:  \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Error\"\u003c/span\u003e));\n          }\n          \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (state is \u003cspan class=\"hljs-title class_\"\u003eUserLoadedState\u003c/span\u003e) {\n            \u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eUserModel\u003c/span\u003e\u003e userList = state.\u003cspan class=\"hljs-property\"\u003eusers\u003c/span\u003e;\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eListView\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ebuilder\u003c/span\u003e(\n                \u003cspan class=\"hljs-attr\"\u003eitemCount\u003c/span\u003e: userList.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e,\n                \u003cspan class=\"hljs-attr\"\u003eitemBuilder\u003c/span\u003e: (_, index) {\n                  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePadding\u003c/span\u003e(\n                    \u003cspan class=\"hljs-attr\"\u003epadding\u003c/span\u003e:\n                        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eEdgeInsets\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003esymmetric\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003evertical\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ehorizontal\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e),\n                    \u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCard\u003c/span\u003e(\n                        \u003cspan class=\"hljs-attr\"\u003ecolor\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eTheme\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eof\u003c/span\u003e(context).\u003cspan class=\"hljs-property\"\u003eprimaryColor\u003c/span\u003e,\n                        \u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eListTile\u003c/span\u003e(\n                            \u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\n                              \u003cspan class=\"hljs-string\"\u003e'${userList[index].firstName}  ${userList[index].lastName}'\u003c/span\u003e,\n                              \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTextStyle\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ecolor\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eColors\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ewhite\u003c/span\u003e),\n                            ),\n\n                            \u003cspan class=\"hljs-attr\"\u003esubtitle\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\n                              \u003cspan class=\"hljs-string\"\u003e'${userList[index].email}'\u003c/span\u003e,\n                              \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTextStyle\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ecolor\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eColors\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ewhite\u003c/span\u003e),\n                            ),\n                            \n                            \u003cspan class=\"hljs-attr\"\u003eleading\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCircleAvatar\u003c/span\u003e(\n                              \u003cspan class=\"hljs-attr\"\u003ebackgroundImage\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eNetworkImage\u003c/span\u003e(\n                                  userList[index].\u003cspan class=\"hljs-property\"\u003eavatar\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etoString\u003c/span\u003e()),\n                            ))),\n                  );\n                });\n          }\n\n          \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eContainer\u003c/span\u003e();\n        },\n      ),\n    );\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e보시다시피 'MultiBlocProvider'가 제공되는 우리의 bloc 라이브러리에서 온 것을 확인할 수 있어요. 서버에서 데이터를로드하고 한 번만 로드하려고하기 때문에 빌드 방법에서 UserRepository를 주입합니다. bloc 형식의 MultiBlocProvider에서는 클래스에 여러 Bloc을 추가하여 전체 클래스에서 사용할 수 있습니다. 또한이 리포지토리를 배치할 위치에는 클래스가 있어야합니다. 우리의 경우에는 Scaffold입니다.\u003c/p\u003e\n\u003cp\u003e그래서 MultiBlocProvider가 하는 일은 서버에서 데이터를 이동시키고 이를 만들어서 데이터와 상태를 모든 하위 요소에서 사용할 수 있게하는 것입니다.\u003c/p\u003e\n\u003cp\u003eblocBody 내부에서 BlocProvider를 볼 수 있습니다. Getx에 익숙하다면 Get.put와 비슷합니다. BlocProvider 내부에서는 리포지토리와 함께 bloc 즉 UserBloc을 주입합니다. 위에서 이미 bloc을 주입했으므로 blocBody 내에서 이벤트에 액세스 할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e리포지토리와 함께 bloc을 주입 한 후에는 이벤트 즉 LoadUserEvent를 추가하고 이를 사용하여 UserBloc에서 UserLoadingState를 트리거하는 캐스캐이딩 연산자를 사용합니다.\u003c/p\u003e\n\u003cp\u003e이제 빌더 내부의 상태를 확인할 수 있습니다. 세 가지 상태가 있으므로 각각을 확인하여 다른 작업을 수행하고 다른 UI를 반환합니다.\u003c/p\u003e\n\u003cp\u003e다음과 같이 확인할 수 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eUserLoadingState\u003c/code\u003e일 때는 데이터를 불러오고 있다는 의미로 CircularProgressIndicator를 표시합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eUserLoadedState\u003c/code\u003e일 때는 데이터 목록을 반환합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eUserErrorState\u003c/code\u003e일 때는 오류 메시지를 반환합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이제 애플리케이션을 실행하면 bloc 라이브러리를 사용하여 데이터가 검색될 것입니다.\u003c/p\u003e\n\u003cp\u003e단점을 확인하려면 잘못된 종단점을 만들어 보실 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e이 글에서 Bloc 및 Bloc 작업 메커니즘에 대해 설명했습니다. 필요에 맞게 코드를 조정하여 사용해 보세요. 새 페이지를 만들어 보는 것도 좋은 방법입니다. Bloc 아키텍처는 대규모 프로젝트에 매우 유용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 블로그 게시물이 앞으로의 프로젝트에서 bloc 라이브러리와 아키텍처를 사용하는 데 충분한 중요한 정보를 제공해 줄 것을 바랍니다.\u003c/p\u003e\n\u003cp\u003e❤ ❤ 이 글 읽어주셔서 감사합니다 ❤ ❤\u003c/p\u003e\n\u003cp\u003e만약 이 글을 좋아하셨다면 👏 두 번 치세요.\u003c/p\u003e\n\u003cp\u003e또한, 업데이트되는 흥미로운 글과 프로젝트를 확인하려면 팔로우하세요.\u003c/p\u003e\n\u003cp\u003e무엇인가 잘못된 점이 있다면? 댓글로 알려주세요. 개선해나가겠습니다.\u003c/p\u003e\n\u003ch1\u003e함께 연결해요\u003c/h1\u003e\n\u003cp\u003e우리 친구가 되어요. 페이스북, 링크드인, 깃허브, 유튜브, BuyMeACoffee, 그리고 인스타그램에서 찾아요.\u003c/p\u003e\n\u003cp\u003e방문하기: Flutter Junction\u003c/p\u003e\n\u003cp\u003e기여하기: BuyMeACoffee\u003c/p\u003e\n\u003cp\u003e다음 링크에서 전체 코드를 확인하세요:\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-21-FetchAPIWithBloCinFlutter"},"buildId":"fyfGyRz00q80ZdkogiVCt","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>