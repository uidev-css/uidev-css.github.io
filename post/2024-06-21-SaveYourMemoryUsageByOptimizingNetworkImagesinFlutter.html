<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Flutter에서 네트워크 이미지 최적화로 메모리 사용량 줄이는 방법 | uidev-css</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://uidev-css.github.io///post/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Flutter에서 네트워크 이미지 최적화로 메모리 사용량 줄이는 방법 | uidev-css" data-gatsby-head="true"/><meta property="og:title" content="Flutter에서 네트워크 이미지 최적화로 메모리 사용량 줄이는 방법 | uidev-css" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://uidev-css.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://uidev-css.github.io///post/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter" data-gatsby-head="true"/><meta name="twitter:title" content="Flutter에서 네트워크 이미지 최적화로 메모리 사용량 줄이는 방법 | uidev-css" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | uidev-css" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-21 21:32" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b75a4bf98ee956a8.js" defer=""></script><script src="/_next/static/-yEBofE4jMl3RL1kr5c4Y/_buildManifest.js" defer=""></script><script src="/_next/static/-yEBofE4jMl3RL1kr5c4Y/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UIDEV CSS</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Flutter에서 네트워크 이미지 최적화로 메모리 사용량 줄이는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Flutter에서 네트워크 이미지 최적화로 메모리 사용량 줄이는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UIDEV CSS</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 21, 2024</span><span class="posts_reading_time__f7YPP">10<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter_0.png" alt="이미지"></p>
<p>플러터에서 네트워크 이미지를 가져와 표시할 때 기억해야 할 중요한 요소는 무엇인가요?</p>
<p>이미지 위젯을 사용할 때 더 나은 사용자 경험(UX)을 제공하기 위해 네트워크에서 이미지를로드하기 전에 페이드-인 애니메이션을 적용하거나 로딩 표시기를 표시하는 것을 고려할 수 있습니다.</p>
<p>이러한 UX 고려사항이 중요하지만 네트워크 이미지를 렌더링할 때 메모리 사용량을 줄이는 것도 중요합니다. 이는 더 큰 이미지가 렌더링 프로세스 중에 상당한 양의 메모리를 요구하기 때문입니다.</p>
<p>이를 설명하기 위해 개인 프로젝트 예시를 공유하고 싶습니다. 내 앱에서 화면이 버벅거리고 비정상적으로 종료되는 문제가 발생했습니다. 앞서 언급했듯이, 문제의 원인은 화면에 고해상도 네트워크 이미지를 표시할 때 과도한 메모리 사용이었습니다.</p>
<p><img src="/assets/img/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter_1.png" alt="이미지"></p>
<p>동일한 실수를 피하려면, 화면에 이미지를 로드할 때 렌더링을 최적화하는 방법을 이해해야 합니다. 이 게시물에서는 메모리 사용량을 줄이면서 효과적으로 네트워크 이미지를 렌더링하는 방법을 소개하겠습니다. 유용한 팁을 모아두세요!</p>
<h1>과도하게 큰 이미지 진단하기</h1>
<p>먼저, 네트워크 이미지를 렌더링할 때 메모리 사용량이 과도한지 진단하는 것이 중요합니다. 간단한 예를 통해 이를 확인해 보겠습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Image</span>.<span class="hljs-title function_">network</span>(
    imageUrl,
    <span class="hljs-attr">width</span>: <span class="hljs-number">250</span>,
),
</code></pre>
<p>위의 이미지 위젯이 효율적으로 렌더링되었습니까? 알아내는 간단한 방법이 있습니다.</p>
<p>아래는 Markdown 형식으로 변경한 표입니다.</p>
<p><img src="/assets/img/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter_3.png" alt="이미지1"></p>
<p>Flutter Inspector에서 "Highlight oversized images" 버튼을 활성화하세요.</p>
<p><img src="/assets/img/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter_4.png" alt="이미지2"></p>
<p>그러면 화면에 표시된 이미지가 색상이 반전되고 수직으로 뒤집힌 것을 알 수 있습니다. 이는 이미지 디코딩 과정에서 필요한 것보다 더 많은 메모리가 사용되었다는 것을 나타냅니다.</p>
<h1>화면 크기 및 디코딩 크기</h1>
<p>에러 로그를 확인하면 더 구체적인 정보를 얻을 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Image</span> [...]의 화면 크기는 <span class="hljs-number">750</span>×<span class="hljs-number">421</span>이지만 디코딩 크기는 <span class="hljs-number">3840</span>×<span class="hljs-number">2160</span>으로,
기기 픽셀 비율이 <span class="hljs-number">3.0</span>을 가정했을 때 추가적인 41552KB를 사용합니다.
</code></pre>
<p>화면에 표시된 이미지의 크기는 750x421이지만, 디코딩된 크기는 3840×2160으로, 추가로 41552KB의 메모리를 사용하고 있습니다.</p>
<p>디스플레이 크기는 이미지를 디코딩하는 크기를 나타냅니다. 다시 말해, 화면에 실제로 표시될 때, 필요한 디스플레이 크기는 750×421에 불과합니다. 따라서 이미지의 전체 원본 크기, 3840×2160(디코드 크기),를 디코딩하는 것은 불필요합니다.</p>
<p>더 쉽게 이해하기 위해 비유를 들어보겠습니다.</p>
<p><img src="/assets/img/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter_5.png" alt="이미지"></p>
<p>친구와 찍은 사진을 기반으로 화가에게 그림을 그리도록 부탁했다고 상상해보세요. 화가에게 사진을 제공할 때, 그림을 만드는 데 필요한 것보다 훨씬 큰 대형 게시판 크기의 사진을 제공할 필요는 없습니다. 사실, 그러한 큰 사진은 화가의 작업을 방해할 수 있습니다.</p>
<p><img src="/assets/img/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter_6.png" alt="이미지"></p>
<p>정확하고 빠른 그림을 그리려면 예당 크기의 사진만 있으면 됩니다. 이 개념은 Flutter에서 네트워크 이미지를 로드할 때도 적용됩니다. 이미지의 크기가 화면에 표시될 크기(표시 크기)보다 훨씬 크면 Flutter 엔진이 디코딩 프로세스 중에 메모리를 낭비합니다.</p>
<h1>이미지 크기 조정</h1>
<p>그렇다면 이미지의 크기를 어떻게 조정해야 할까요? 다음 오류 로그는 이미지 크기를 조정하는 방법에 대한 안내를 제공합니다.</p>
<pre><code class="hljs language-js">이제 코드 수정을 통해 기록에 기반한 변경을 가해보겠습니다.

<span class="hljs-title class_">Image</span>.<span class="hljs-title function_">network</span>(
  imageUrl,
  <span class="hljs-attr">width</span>: <span class="hljs-number">250</span>,
  <span class="hljs-attr">cacheWidth</span>: <span class="hljs-number">750</span>,
),
<span class="hljs-keyword">const</span> <span class="hljs-title class_">Divider</span>(),
<span class="hljs-title class_">Image</span>.<span class="hljs-title function_">network</span>(
  imageUrl,
  <span class="hljs-attr">width</span>: <span class="hljs-number">250</span>,
),

<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"content-ad"</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>

비교를 위해 cacheWidth 속성이 설정되지 않은 위젯을 추가했습니다. (한 가지 캐시 속성을 설정하면 다른 이미지도 비율을 유지하면서 크기를 조정할 수 있습니다)

![image](<span class="hljs-regexp">/assets/img</span><span class="hljs-regexp">/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter_7.png)

cacheWidth를 설정한 이미지는 과도한 오류 없이 표시되지만, 다른 이미지는 색상과 방향이 반전되고 수직으로 뒤집힙니다. cacheWidth를 올바르게 설정함으로써 이미지의 크기를 조정하여 디코딩 프로세스에서 메모리 사용량을 최적화했습니다.

# 장치별 화소 비율

&#x3C;div class="content-ad">&#x3C;/</span>div>

그러나 여전히 문제가 발생할 수 있습니다.

![image](<span class="hljs-regexp">/assets/img</span><span class="hljs-regexp">/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter_8.png)

cacheWidth가 설정된 동일한 코드에서 iPhone 12 mini에서 이미지가 올바르게 표시되지만, 화면 크기가 작은 iPhone SE에서는 여전히 크기가 너무 크다는 표시가 있습니다.

이 문제가 발생하는 이유는 무엇일까요? 오류 로그를 다시 확인해 보죠.

&#x3C;div class="content-ad">&#x3C;/</span>div>

## iPhone <span class="hljs-number">12</span> 미니

<span class="hljs-title class_">Image</span> [...]의 디스플레이 크기는 <span class="hljs-number">750</span>×<span class="hljs-number">421</span>이지만 디코딩 크기는 <span class="hljs-number">3840</span>×<span class="hljs-number">2160</span>으로, 기기 픽셀 비율을 <span class="hljs-number">3.0</span>으로 가정할 때 추가 41552KB가 사용됩니다.

미리 자산의 크기를 조정하거나 cacheWidth 매개변수를 <span class="hljs-number">750</span>, cacheHeight 매개변수를 <span class="hljs-number">421</span>로 제공하거나 <span class="hljs-title class_">ResizeImage</span>를 사용하는 것을 고려해보세요.

iPhone <span class="hljs-number">12</span> 미니의 경우, 이미지의 디스플레이 폭은 <span class="hljs-number">750</span>이며, 기기 픽셀 비율은 <span class="hljs-number">3.0</span>입니다.

## iPhone <span class="hljs-variable constant_">SE</span>

&#x3C;div <span class="hljs-keyword">class</span>=<span class="hljs-string">"content-ad"</span>>&#x3C;/div>

이미지 [...]는 표시 크기가 <span class="hljs-number">500</span>×<span class="hljs-number">281</span>이지만 디코딩 크기는 <span class="hljs-number">3840</span>×<span class="hljs-number">2160</span> 이며, 장치 픽셀 비율이 <span class="hljs-number">2.0</span>일 때 추가로 42467KB를 사용합니다.

미리 에셋 크기를 조정하고, cacheWidth 매개변수를 <span class="hljs-number">500</span>, cacheHeight 매개변수를 <span class="hljs-number">281</span>로 제공하거나 <span class="hljs-title class_">ResizeImage</span>를 사용하는 것을 고려해보세요.

반면에 iPhone <span class="hljs-variable constant_">SE</span>의 경우, 이미지의 표시 크기는 <span class="hljs-number">500</span>이며, 장치 픽셀 비율은 <span class="hljs-number">2.0</span>입니다.

이 차이는 각 장치의 다른 디바이스 픽셀 비율 때문에 발생합니다.

디바이스 픽셀 비율은 디바이스 화면에 표시되는 픽셀 밀도를 나타내며, 특정 장치의 화면 크기 당 픽셀 수를 나타냅니다.
</code></pre>
<p><img src="/assets/img/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter_9.png" alt="image"></p>
<p>화소 밀도는 일반적으로 특정 디바이스의 화면 크기에 따라 다양한 값을 갖는 ppi(인치당 픽셀)로 측정됩니다. 예를 들어 고해상도 장치는 화면 크기 당 픽셀이 더 많아 더 높은 화소 밀도를 가지게 됩니다.</p>
<p>요약하자면, iPhone SE는 디바이스 픽셀 비율이 2.0이며, 이는 물리적 픽셀 당 2개의 픽셀을 표시한다는 것을 의미하며, iPhone 12 mini는 디바이스 픽셀 비율이 3.0이며, 즉 물리적 픽셀 당 3개의 픽셀을 표시합니다. 따라서 iPhone 12 mini를 기준으로 cacheWidth를 설정할 때, iPhone SE의 낮은 픽셀 비율로 인해 여전히 불필요한 디코딩 크기가 남아 있습니다.</p>
<h1>이미지 캐시 크기 동적으로 결정하기</h1>
<p>이제 모든 단서가 모였으니, 기기의 픽셀 비율을 기반으로 cacheWidth 값을 계산할 수 있어요.</p>
<pre><code class="hljs language-js"><span class="hljs-number">250</span> (위젯 크기) X <span class="hljs-number">2</span> (iPhone <span class="hljs-variable constant_">SE</span> 기기 픽셀 비율) = <span class="hljs-number">500</span> (캐시 크기)
</code></pre>
<p>250의 목표 위젯 크기와 iPhone SE의 1인치 당 2픽셀의 표시 방법을 고려하여, 위젯 크기에 기기 픽셀 비율을 곱하면 적절한 디스플레이 크기인 500이 나옵니다.</p>
<p>다음은 코드 표현입니다.</p>
<p>이미지 네트워크 (
imageUrl,
width: 250,
cacheWidth: (250 * MediaQuery.of(context).devicePixelRatio).round(),
)</p>
<p>MediaQuery를 사용하여 장치의 픽셀 비율을 결정하고 이미지 위젯의 너비와 곱하여 cacheWidth 값을 설정합니다. cacheWidth 속성은 정수 값을 필요로 하므로 round 메소드를 사용하여 가장 가까운 정수로 반올림합니다. 이 코드를 사용하면 장치의 픽셀 비율에 따라 이미지 크기를 조정할 수 있습니다.</p>
<p>더불어 코드를 더 간결하게 만들기 위해 이미지 크기 계산을 확장(extension)으로 구현할 수 있습니다. 확장을 사용한 코드 예시는 다음과 같습니다.</p>
<p>확장 ImageExtension on num {
int cacheSize(BuildContext context) {
return (this * MediaQuery.of(context).devicePixelRatio).round();
}
}</p>
<p>그럼, 이미지 위젯의 확장 기능을 사용하여 필요한 캐시 값을 간결하게 설정할 수 있어요.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Image</span>.<span class="hljs-title function_">network</span>(  
  imageUrl,  
  <span class="hljs-attr">width</span>: <span class="hljs-number">250</span>,  
  <span class="hljs-attr">cacheWidth</span>: <span class="hljs-number">250.</span><span class="hljs-title function_">cacheSize</span>(context),  
)
</code></pre>
<h1>캐시 크기 지정 고려 사항</h1>
<p>원본 이미지의 종횡비가 대상 위젯의 종횡비와 다를 때, 그리고 이미지 위젯에 fit: BoxFit.cover를 사용할 때 캐시 크기를 설정할 때 특정 측면을 고려해야 해요. 일반적으로 fit: BoxFit.cover를 사용하면 이미지가 위젯에 맞게 잘립니다. 이러한 경우에는 이미지의 표시 크기를 결정할 때 종횡비를 고려해야 해요.</p>
<p>만약 원본 이미지와 위젯의 종횡비가 다르다면, 이미지를 최적화하는 동안 원본 이미지의 종횡비를 유지하기 위해 작은 차원(너비 또는 높이)을 기준으로 캐시 크기를 설정해야 합니다.</p>
<p>그 반대로 설정하면 해상도가 낮은 이미지가 표시될 수 있습니다.</p>
<p>예를 살펴보겠습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Image</span>.<span class="hljs-title function_">network</span>(  
  imageUrl,  
  <span class="hljs-attr">width</span>: <span class="hljs-number">250</span>,  
  <span class="hljs-attr">height</span>: <span class="hljs-number">250</span>,  
  <span class="hljs-attr">cacheWidth</span>: <span class="hljs-number">250.</span><span class="hljs-title function_">cacheSize</span>(context),  
  <span class="hljs-attr">fit</span>: <span class="hljs-title class_">BoxFit</span>.<span class="hljs-property">cover</span>,
)
</code></pre>
<p><img src="/assets/img/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter_10.png" alt="Network Images in Flutter"></p>
<ul>
<li>이미지 크기: 3000 x 1688</li>
<li>이미지 가로 세로 비율: 1.7</li>
<li>디코딩된 이미지의 표시 크기: 500 x 282</li>
<li>이미지 위젯 크기: 250 x 250</li>
<li>이미지 위젯 가로 세로 비율: 1</li>
</ul>
<p>이미지 위젯은 250 x 250 크기이며 디바이스의 픽셀 비율을 곱한 값인 500을 cacheWidth로 설정하면 이미지의 표시 높이를 자동으로 결정하고 이미지의 가로 세로 비율을 유지합니다. 그러나 원본 이미지의 가로가 세로보다 큰 비율을 가지고 있고, 이는 위젯의 표시에 필요한 가로 세로 비율과 다르기 때문에, 디코딩된 이미지의 표시 높이(281)가 목표 표시 높이(500)보다 낮아져 이미지가 흐릿하게 보일 수 있습니다. 예시 사진에 나와 있습니다.</p>
<p>반면, cacheHeight를 설정하면…</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Image</span>.<span class="hljs-title function_">network</span>(
  imageUrl,
  <span class="hljs-attr">width</span>: <span class="hljs-number">250</span>,
  <span class="hljs-attr">height</span>: <span class="hljs-number">250</span>,
  <span class="hljs-attr">cacheHeight</span>: <span class="hljs-number">250.</span><span class="hljs-title function_">cacheSize</span>(context),
  <span class="hljs-attr">fit</span>: <span class="hljs-title class_">BoxFit</span>.<span class="hljs-property">cover</span>,
)
</code></pre>
<p>캐시 높이를 설정하면 이미지의 종횡비를 유지하면서 최소 표시 크기로 크기를 조정하여 이미지의 해상도를 유지합니다.</p>
<p>기존의 오버사이즈된 오류 로그는 여전히 발생하지만, 이미지의 크기를 크게 줄이고 종횡비를 유지하여 선명한 이미지를 제공하도록 최적화되었습니다.</p>
<h1>이미지 종횡비를 고려한 캐시 크기 동적 설정</h1>
<p>대부분의 경우에는 프런트엔드 개발자가 네트워크 이미지의 종횡비를 사전에 알지 못합니다. 이러한 상황에서는 원본 이미지의 종횡비가 0보다 큰지 여부를 기반으로 캐시 크기를 동적으로 결정할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Builder</span>(  
  <span class="hljs-attr">builder</span>: (context) {  
    int? cacheWidth, cacheHeight;  
    <span class="hljs-title class_">Size</span> targetSize = <span class="hljs-keyword">const</span> <span class="hljs-title class_">Size</span>(<span class="hljs-number">250</span>, <span class="hljs-number">250</span>);  
    <span class="hljs-keyword">const</span> double originImgAspectRatio = <span class="hljs-number">1.7</span>;  
   
    <span class="hljs-comment">// 원본 이미지의 종횡비가 0보다 큰 경우, 이미지가 세로보다 넓은 것을 의미합니다.</span>
    <span class="hljs-keyword">if</span> (originImgAspectRatio > <span class="hljs-number">0</span>) {  
      cacheHeight = targetSize.<span class="hljs-property">height</span>.<span class="hljs-title function_">cacheSize</span>(context);  
    } <span class="hljs-keyword">else</span> {  
      cacheWidth = targetSize.<span class="hljs-property">width</span>.<span class="hljs-title function_">cacheSize</span>(context);  
    }  
  
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Image</span>.<span class="hljs-title function_">network</span>(  
      imageUrl,  
      <span class="hljs-attr">width</span>: targetSize.<span class="hljs-property">width</span>,  
      <span class="hljs-attr">height</span>: targetSize.<span class="hljs-property">height</span>,  
      <span class="hljs-attr">cacheWidth</span>: cacheWidth,  
      <span class="hljs-attr">cacheHeight</span>: cacheHeight,  
      <span class="hljs-attr">fit</span>: <span class="hljs-title class_">BoxFit</span>.<span class="hljs-property">cover</span>,  
    );  
  },  
)
</code></pre>
<p>위 코드에서는 원본 이미지의 종횡비(originImgAspectRatio)를 사용하여 조건부로 cacheWidth 또는 cacheHeight를 캐시 크기로 설정합니다. 앞서 언급한 대로 캐시 크기 속성 중 하나만 설정하면 이미지가 종횡비에 맞게 크기가 조정되므로 다른 속성을 null로 설정해도 괜찮습니다.</p>
<h1>CacheNetworkImage 패키지</h1>
<p>Flutter는 네트워크에서 이미지를로드하기 위한 Image.network 위젯을 제공하지만 이미지 캐싱에는 cached_network_image 패키지를 사용하는 것이 좋습니다. 이 패키지는 세밀한 캐싱 제어를 제공하여 성능을 향상시킬 수 있습니다. 아래는 cached_network_image 패키지를 사용하는 예시입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">CachedNetworkImage</span>(  
  <span class="hljs-attr">imageUrl</span>: imageUrl,  
  <span class="hljs-attr">memCacheHeight</span>: <span class="hljs-number">320.</span><span class="hljs-title function_">cacheSize</span>(context),  
  <span class="hljs-attr">memCacheWidth</span>: <span class="hljs-number">250.</span><span class="hljs-title function_">cacheSize</span>(context),  
)
</code></pre>
<p>CachedNetworkImage 위젯을 사용하면 Image.network 위젯과 유사하게 캐시 크기를 지정하기 위해 memCacheHeight 및 memCacheWidth 속성을 사용할 수 있습니다.</p>
<h1>결론</h1>
<p>이 글에서는 Flutter에서 네트워크 이미지를 효율적으로 로드하고 메모리 사용량을 최적화하는 방법을 살펴보았습니다. 앱 개발 중 가장 중요한 측면 중 하나이지만 쉽게 간과될 수 있는 문제로, 특히 애플리케이션에서 고해상도 이미지를 다룰 때 부드러운 사용자 경험을 위해 중요합니다.</p>
<p>Flutter에서 이미지 처리에 대한 더 많은 팁과 모범 사례에 관심이 있다면, 잘 문서화된 "Flutter를 사용한 최상의 UX 성능을 위한 12가지 이미지 팁과 모범 사례" 문서를 참고하실 수 있습니다.</p>
<p>본 글에서 논의된 예제 코드에 대해 궁금하시다면, 제 GitHub 저장소에서 확인하실 수 있습니다.</p>
<p>위 내용을 읽어 주셔서 감사합니다!</p>
<h1>참고 자료</h1>
<ul>
<li><a href="https://www.themoviedb.org/tv/1396-breaking-bad/images/backdrops?language=ko" rel="nofollow" target="_blank">https://www.themoviedb.org/tv/1396-breaking-bad/images/backdrops?language=ko</a></li>
<li><a href="https://api.flutter.dev/flutter/painting/debugInvertOversizedImages.html" rel="nofollow" target="_blank">https://api.flutter.dev/flutter/painting/debugInvertOversizedImages.html</a></li>
<li><a href="https://github.com/flutter/flutter/issues/56239" rel="nofollow" target="_blank">https://github.com/flutter/flutter/issues/56239</a></li>
</ul>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Flutter에서 네트워크 이미지 최적화로 메모리 사용량 줄이는 방법","description":"","date":"2024-06-21 21:32","slug":"2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter","content":"\n\n\n![이미지](/assets/img/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter_0.png)\n\n플러터에서 네트워크 이미지를 가져와 표시할 때 기억해야 할 중요한 요소는 무엇인가요?\n\n이미지 위젯을 사용할 때 더 나은 사용자 경험(UX)을 제공하기 위해 네트워크에서 이미지를로드하기 전에 페이드-인 애니메이션을 적용하거나 로딩 표시기를 표시하는 것을 고려할 수 있습니다.\n\n이러한 UX 고려사항이 중요하지만 네트워크 이미지를 렌더링할 때 메모리 사용량을 줄이는 것도 중요합니다. 이는 더 큰 이미지가 렌더링 프로세스 중에 상당한 양의 메모리를 요구하기 때문입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이를 설명하기 위해 개인 프로젝트 예시를 공유하고 싶습니다. 내 앱에서 화면이 버벅거리고 비정상적으로 종료되는 문제가 발생했습니다. 앞서 언급했듯이, 문제의 원인은 화면에 고해상도 네트워크 이미지를 표시할 때 과도한 메모리 사용이었습니다.\n\n![이미지](/assets/img/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter_1.png)\n\n동일한 실수를 피하려면, 화면에 이미지를 로드할 때 렌더링을 최적화하는 방법을 이해해야 합니다. 이 게시물에서는 메모리 사용량을 줄이면서 효과적으로 네트워크 이미지를 렌더링하는 방법을 소개하겠습니다. 유용한 팁을 모아두세요!\n\n# 과도하게 큰 이미지 진단하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저, 네트워크 이미지를 렌더링할 때 메모리 사용량이 과도한지 진단하는 것이 중요합니다. 간단한 예를 통해 이를 확인해 보겠습니다.\n\n\u003cimg src=\"/assets/img/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter_2.png\" /\u003e\n\n```js\nImage.network(\n    imageUrl,\n    width: 250,\n),\n```\n\n위의 이미지 위젯이 효율적으로 렌더링되었습니까? 알아내는 간단한 방법이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 Markdown 형식으로 변경한 표입니다.\n\n![이미지1](/assets/img/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter_3.png)\n\nFlutter Inspector에서 \"Highlight oversized images\" 버튼을 활성화하세요.\n\n![이미지2](/assets/img/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter_4.png)\n\n그러면 화면에 표시된 이미지가 색상이 반전되고 수직으로 뒤집힌 것을 알 수 있습니다. 이는 이미지 디코딩 과정에서 필요한 것보다 더 많은 메모리가 사용되었다는 것을 나타냅니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 화면 크기 및 디코딩 크기\n\n에러 로그를 확인하면 더 구체적인 정보를 얻을 수 있습니다.\n\n```js\nImage [...]의 화면 크기는 750×421이지만 디코딩 크기는 3840×2160으로,\n기기 픽셀 비율이 3.0을 가정했을 때 추가적인 41552KB를 사용합니다.\n```\n\n화면에 표시된 이미지의 크기는 750x421이지만, 디코딩된 크기는 3840×2160으로, 추가로 41552KB의 메모리를 사용하고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n디스플레이 크기는 이미지를 디코딩하는 크기를 나타냅니다. 다시 말해, 화면에 실제로 표시될 때, 필요한 디스플레이 크기는 750×421에 불과합니다. 따라서 이미지의 전체 원본 크기, 3840×2160(디코드 크기),를 디코딩하는 것은 불필요합니다.\n\n더 쉽게 이해하기 위해 비유를 들어보겠습니다.\n\n![이미지](/assets/img/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter_5.png)\n\n친구와 찍은 사진을 기반으로 화가에게 그림을 그리도록 부탁했다고 상상해보세요. 화가에게 사진을 제공할 때, 그림을 만드는 데 필요한 것보다 훨씬 큰 대형 게시판 크기의 사진을 제공할 필요는 없습니다. 사실, 그러한 큰 사진은 화가의 작업을 방해할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter_6.png)\n\n정확하고 빠른 그림을 그리려면 예당 크기의 사진만 있으면 됩니다. 이 개념은 Flutter에서 네트워크 이미지를 로드할 때도 적용됩니다. 이미지의 크기가 화면에 표시될 크기(표시 크기)보다 훨씬 크면 Flutter 엔진이 디코딩 프로세스 중에 메모리를 낭비합니다.\n\n# 이미지 크기 조정\n\n그렇다면 이미지의 크기를 어떻게 조정해야 할까요? 다음 오류 로그는 이미지 크기를 조정하는 방법에 대한 안내를 제공합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n이제 코드 수정을 통해 기록에 기반한 변경을 가해보겠습니다.\n\nImage.network(\n  imageUrl,\n  width: 250,\n  cacheWidth: 750,\n),\nconst Divider(),\nImage.network(\n  imageUrl,\n  width: 250,\n),\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n비교를 위해 cacheWidth 속성이 설정되지 않은 위젯을 추가했습니다. (한 가지 캐시 속성을 설정하면 다른 이미지도 비율을 유지하면서 크기를 조정할 수 있습니다)\n\n![image](/assets/img/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter_7.png)\n\ncacheWidth를 설정한 이미지는 과도한 오류 없이 표시되지만, 다른 이미지는 색상과 방향이 반전되고 수직으로 뒤집힙니다. cacheWidth를 올바르게 설정함으로써 이미지의 크기를 조정하여 디코딩 프로세스에서 메모리 사용량을 최적화했습니다.\n\n# 장치별 화소 비율\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러나 여전히 문제가 발생할 수 있습니다.\n\n![image](/assets/img/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter_8.png)\n\ncacheWidth가 설정된 동일한 코드에서 iPhone 12 mini에서 이미지가 올바르게 표시되지만, 화면 크기가 작은 iPhone SE에서는 여전히 크기가 너무 크다는 표시가 있습니다.\n\n이 문제가 발생하는 이유는 무엇일까요? 오류 로그를 다시 확인해 보죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## iPhone 12 미니\n\nImage [...]의 디스플레이 크기는 750×421이지만 디코딩 크기는 3840×2160으로, 기기 픽셀 비율을 3.0으로 가정할 때 추가 41552KB가 사용됩니다.\n\n미리 자산의 크기를 조정하거나 cacheWidth 매개변수를 750, cacheHeight 매개변수를 421로 제공하거나 ResizeImage를 사용하는 것을 고려해보세요.\n\niPhone 12 미니의 경우, 이미지의 디스플레이 폭은 750이며, 기기 픽셀 비율은 3.0입니다.\n\n## iPhone SE\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이미지 [...]는 표시 크기가 500×281이지만 디코딩 크기는 3840×2160 이며, 장치 픽셀 비율이 2.0일 때 추가로 42467KB를 사용합니다.\n\n미리 에셋 크기를 조정하고, cacheWidth 매개변수를 500, cacheHeight 매개변수를 281로 제공하거나 ResizeImage를 사용하는 것을 고려해보세요.\n\n반면에 iPhone SE의 경우, 이미지의 표시 크기는 500이며, 장치 픽셀 비율은 2.0입니다.\n\n이 차이는 각 장치의 다른 디바이스 픽셀 비율 때문에 발생합니다.\n\n디바이스 픽셀 비율은 디바이스 화면에 표시되는 픽셀 밀도를 나타내며, 특정 장치의 화면 크기 당 픽셀 수를 나타냅니다.\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![image](/assets/img/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter_9.png)\n\n화소 밀도는 일반적으로 특정 디바이스의 화면 크기에 따라 다양한 값을 갖는 ppi(인치당 픽셀)로 측정됩니다. 예를 들어 고해상도 장치는 화면 크기 당 픽셀이 더 많아 더 높은 화소 밀도를 가지게 됩니다.\n\n요약하자면, iPhone SE는 디바이스 픽셀 비율이 2.0이며, 이는 물리적 픽셀 당 2개의 픽셀을 표시한다는 것을 의미하며, iPhone 12 mini는 디바이스 픽셀 비율이 3.0이며, 즉 물리적 픽셀 당 3개의 픽셀을 표시합니다. 따라서 iPhone 12 mini를 기준으로 cacheWidth를 설정할 때, iPhone SE의 낮은 픽셀 비율로 인해 여전히 불필요한 디코딩 크기가 남아 있습니다.\n\n# 이미지 캐시 크기 동적으로 결정하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 모든 단서가 모였으니, 기기의 픽셀 비율을 기반으로 cacheWidth 값을 계산할 수 있어요.\n\n```js\n250 (위젯 크기) X 2 (iPhone SE 기기 픽셀 비율) = 500 (캐시 크기)\n```\n\n250의 목표 위젯 크기와 iPhone SE의 1인치 당 2픽셀의 표시 방법을 고려하여, 위젯 크기에 기기 픽셀 비율을 곱하면 적절한 디스플레이 크기인 500이 나옵니다.\n\n다음은 코드 표현입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n이미지 네트워크 (\n  imageUrl,\n  width: 250,\n  cacheWidth: (250 * MediaQuery.of(context).devicePixelRatio).round(),\n)\n\n\nMediaQuery를 사용하여 장치의 픽셀 비율을 결정하고 이미지 위젯의 너비와 곱하여 cacheWidth 값을 설정합니다. cacheWidth 속성은 정수 값을 필요로 하므로 round 메소드를 사용하여 가장 가까운 정수로 반올림합니다. 이 코드를 사용하면 장치의 픽셀 비율에 따라 이미지 크기를 조정할 수 있습니다.\n\n더불어 코드를 더 간결하게 만들기 위해 이미지 크기 계산을 확장(extension)으로 구현할 수 있습니다. 확장을 사용한 코드 예시는 다음과 같습니다.\n\n\n확장 ImageExtension on num {\n  int cacheSize(BuildContext context) {\n    return (this * MediaQuery.of(context).devicePixelRatio).round();\n  }\n}\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그럼, 이미지 위젯의 확장 기능을 사용하여 필요한 캐시 값을 간결하게 설정할 수 있어요.\n\n```js\nImage.network(  \n  imageUrl,  \n  width: 250,  \n  cacheWidth: 250.cacheSize(context),  \n)\n```\n\n# 캐시 크기 지정 고려 사항\n\n원본 이미지의 종횡비가 대상 위젯의 종횡비와 다를 때, 그리고 이미지 위젯에 fit: BoxFit.cover를 사용할 때 캐시 크기를 설정할 때 특정 측면을 고려해야 해요. 일반적으로 fit: BoxFit.cover를 사용하면 이미지가 위젯에 맞게 잘립니다. 이러한 경우에는 이미지의 표시 크기를 결정할 때 종횡비를 고려해야 해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 원본 이미지와 위젯의 종횡비가 다르다면, 이미지를 최적화하는 동안 원본 이미지의 종횡비를 유지하기 위해 작은 차원(너비 또는 높이)을 기준으로 캐시 크기를 설정해야 합니다.\n\n그 반대로 설정하면 해상도가 낮은 이미지가 표시될 수 있습니다.\n\n예를 살펴보겠습니다.\n\n```js\nImage.network(  \n  imageUrl,  \n  width: 250,  \n  height: 250,  \n  cacheWidth: 250.cacheSize(context),  \n  fit: BoxFit.cover,\n)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Network Images in Flutter](/assets/img/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter_10.png)\n\n- 이미지 크기: 3000 x 1688\n- 이미지 가로 세로 비율: 1.7\n- 디코딩된 이미지의 표시 크기: 500 x 282\n- 이미지 위젯 크기: 250 x 250\n- 이미지 위젯 가로 세로 비율: 1\n\n이미지 위젯은 250 x 250 크기이며 디바이스의 픽셀 비율을 곱한 값인 500을 cacheWidth로 설정하면 이미지의 표시 높이를 자동으로 결정하고 이미지의 가로 세로 비율을 유지합니다. 그러나 원본 이미지의 가로가 세로보다 큰 비율을 가지고 있고, 이는 위젯의 표시에 필요한 가로 세로 비율과 다르기 때문에, 디코딩된 이미지의 표시 높이(281)가 목표 표시 높이(500)보다 낮아져 이미지가 흐릿하게 보일 수 있습니다. 예시 사진에 나와 있습니다.\n\n반면, cacheHeight를 설정하면…\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nImage.network(\n  imageUrl,\n  width: 250,\n  height: 250,\n  cacheHeight: 250.cacheSize(context),\n  fit: BoxFit.cover,\n)\n```\n\n\u003cimg src=\"/assets/img/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter_11.png\" /\u003e\n\n캐시 높이를 설정하면 이미지의 종횡비를 유지하면서 최소 표시 크기로 크기를 조정하여 이미지의 해상도를 유지합니다.\n\n기존의 오버사이즈된 오류 로그는 여전히 발생하지만, 이미지의 크기를 크게 줄이고 종횡비를 유지하여 선명한 이미지를 제공하도록 최적화되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 이미지 종횡비를 고려한 캐시 크기 동적 설정\n\n대부분의 경우에는 프런트엔드 개발자가 네트워크 이미지의 종횡비를 사전에 알지 못합니다. 이러한 상황에서는 원본 이미지의 종횡비가 0보다 큰지 여부를 기반으로 캐시 크기를 동적으로 결정할 수 있습니다.\n\n```js\nBuilder(  \n  builder: (context) {  \n    int? cacheWidth, cacheHeight;  \n    Size targetSize = const Size(250, 250);  \n    const double originImgAspectRatio = 1.7;  \n   \n    // 원본 이미지의 종횡비가 0보다 큰 경우, 이미지가 세로보다 넓은 것을 의미합니다.\n    if (originImgAspectRatio \u003e 0) {  \n      cacheHeight = targetSize.height.cacheSize(context);  \n    } else {  \n      cacheWidth = targetSize.width.cacheSize(context);  \n    }  \n  \n    return Image.network(  \n      imageUrl,  \n      width: targetSize.width,  \n      height: targetSize.height,  \n      cacheWidth: cacheWidth,  \n      cacheHeight: cacheHeight,  \n      fit: BoxFit.cover,  \n    );  \n  },  \n)\n```\n\n위 코드에서는 원본 이미지의 종횡비(originImgAspectRatio)를 사용하여 조건부로 cacheWidth 또는 cacheHeight를 캐시 크기로 설정합니다. 앞서 언급한 대로 캐시 크기 속성 중 하나만 설정하면 이미지가 종횡비에 맞게 크기가 조정되므로 다른 속성을 null로 설정해도 괜찮습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# CacheNetworkImage 패키지\n\nFlutter는 네트워크에서 이미지를로드하기 위한 Image.network 위젯을 제공하지만 이미지 캐싱에는 cached_network_image 패키지를 사용하는 것이 좋습니다. 이 패키지는 세밀한 캐싱 제어를 제공하여 성능을 향상시킬 수 있습니다. 아래는 cached_network_image 패키지를 사용하는 예시입니다.\n\n```js\nCachedNetworkImage(  \n  imageUrl: imageUrl,  \n  memCacheHeight: 320.cacheSize(context),  \n  memCacheWidth: 250.cacheSize(context),  \n)\n```\n\nCachedNetworkImage 위젯을 사용하면 Image.network 위젯과 유사하게 캐시 크기를 지정하기 위해 memCacheHeight 및 memCacheWidth 속성을 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n이 글에서는 Flutter에서 네트워크 이미지를 효율적으로 로드하고 메모리 사용량을 최적화하는 방법을 살펴보았습니다. 앱 개발 중 가장 중요한 측면 중 하나이지만 쉽게 간과될 수 있는 문제로, 특히 애플리케이션에서 고해상도 이미지를 다룰 때 부드러운 사용자 경험을 위해 중요합니다.\n\nFlutter에서 이미지 처리에 대한 더 많은 팁과 모범 사례에 관심이 있다면, 잘 문서화된 \"Flutter를 사용한 최상의 UX 성능을 위한 12가지 이미지 팁과 모범 사례\" 문서를 참고하실 수 있습니다.\n\n본 글에서 논의된 예제 코드에 대해 궁금하시다면, 제 GitHub 저장소에서 확인하실 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 내용을 읽어 주셔서 감사합니다!\n\n# 참고 자료\n\n- https://www.themoviedb.org/tv/1396-breaking-bad/images/backdrops?language=ko\n- https://api.flutter.dev/flutter/painting/debugInvertOversizedImages.html\n- https://github.com/flutter/flutter/issues/56239","ogImage":{"url":"/assets/img/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter_0.png"},"coverImage":"/assets/img/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter_0.png","tag":["Tech"],"readingTime":10},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e플러터에서 네트워크 이미지를 가져와 표시할 때 기억해야 할 중요한 요소는 무엇인가요?\u003c/p\u003e\n\u003cp\u003e이미지 위젯을 사용할 때 더 나은 사용자 경험(UX)을 제공하기 위해 네트워크에서 이미지를로드하기 전에 페이드-인 애니메이션을 적용하거나 로딩 표시기를 표시하는 것을 고려할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이러한 UX 고려사항이 중요하지만 네트워크 이미지를 렌더링할 때 메모리 사용량을 줄이는 것도 중요합니다. 이는 더 큰 이미지가 렌더링 프로세스 중에 상당한 양의 메모리를 요구하기 때문입니다.\u003c/p\u003e\n\u003cp\u003e이를 설명하기 위해 개인 프로젝트 예시를 공유하고 싶습니다. 내 앱에서 화면이 버벅거리고 비정상적으로 종료되는 문제가 발생했습니다. 앞서 언급했듯이, 문제의 원인은 화면에 고해상도 네트워크 이미지를 표시할 때 과도한 메모리 사용이었습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e동일한 실수를 피하려면, 화면에 이미지를 로드할 때 렌더링을 최적화하는 방법을 이해해야 합니다. 이 게시물에서는 메모리 사용량을 줄이면서 효과적으로 네트워크 이미지를 렌더링하는 방법을 소개하겠습니다. 유용한 팁을 모아두세요!\u003c/p\u003e\n\u003ch1\u003e과도하게 큰 이미지 진단하기\u003c/h1\u003e\n\u003cp\u003e먼저, 네트워크 이미지를 렌더링할 때 메모리 사용량이 과도한지 진단하는 것이 중요합니다. 간단한 예를 통해 이를 확인해 보겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enetwork\u003c/span\u003e(\n    imageUrl,\n    \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e250\u003c/span\u003e,\n),\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위의 이미지 위젯이 효율적으로 렌더링되었습니까? 알아내는 간단한 방법이 있습니다.\u003c/p\u003e\n\u003cp\u003e아래는 Markdown 형식으로 변경한 표입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter_3.png\" alt=\"이미지1\"\u003e\u003c/p\u003e\n\u003cp\u003eFlutter Inspector에서 \"Highlight oversized images\" 버튼을 활성화하세요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter_4.png\" alt=\"이미지2\"\u003e\u003c/p\u003e\n\u003cp\u003e그러면 화면에 표시된 이미지가 색상이 반전되고 수직으로 뒤집힌 것을 알 수 있습니다. 이는 이미지 디코딩 과정에서 필요한 것보다 더 많은 메모리가 사용되었다는 것을 나타냅니다.\u003c/p\u003e\n\u003ch1\u003e화면 크기 및 디코딩 크기\u003c/h1\u003e\n\u003cp\u003e에러 로그를 확인하면 더 구체적인 정보를 얻을 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e [...]의 화면 크기는 \u003cspan class=\"hljs-number\"\u003e750\u003c/span\u003e×\u003cspan class=\"hljs-number\"\u003e421\u003c/span\u003e이지만 디코딩 크기는 \u003cspan class=\"hljs-number\"\u003e3840\u003c/span\u003e×\u003cspan class=\"hljs-number\"\u003e2160\u003c/span\u003e으로,\n기기 픽셀 비율이 \u003cspan class=\"hljs-number\"\u003e3.0\u003c/span\u003e을 가정했을 때 추가적인 41552KB를 사용합니다.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e화면에 표시된 이미지의 크기는 750x421이지만, 디코딩된 크기는 3840×2160으로, 추가로 41552KB의 메모리를 사용하고 있습니다.\u003c/p\u003e\n\u003cp\u003e디스플레이 크기는 이미지를 디코딩하는 크기를 나타냅니다. 다시 말해, 화면에 실제로 표시될 때, 필요한 디스플레이 크기는 750×421에 불과합니다. 따라서 이미지의 전체 원본 크기, 3840×2160(디코드 크기),를 디코딩하는 것은 불필요합니다.\u003c/p\u003e\n\u003cp\u003e더 쉽게 이해하기 위해 비유를 들어보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter_5.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e친구와 찍은 사진을 기반으로 화가에게 그림을 그리도록 부탁했다고 상상해보세요. 화가에게 사진을 제공할 때, 그림을 만드는 데 필요한 것보다 훨씬 큰 대형 게시판 크기의 사진을 제공할 필요는 없습니다. 사실, 그러한 큰 사진은 화가의 작업을 방해할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter_6.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e정확하고 빠른 그림을 그리려면 예당 크기의 사진만 있으면 됩니다. 이 개념은 Flutter에서 네트워크 이미지를 로드할 때도 적용됩니다. 이미지의 크기가 화면에 표시될 크기(표시 크기)보다 훨씬 크면 Flutter 엔진이 디코딩 프로세스 중에 메모리를 낭비합니다.\u003c/p\u003e\n\u003ch1\u003e이미지 크기 조정\u003c/h1\u003e\n\u003cp\u003e그렇다면 이미지의 크기를 어떻게 조정해야 할까요? 다음 오류 로그는 이미지 크기를 조정하는 방법에 대한 안내를 제공합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e이제 코드 수정을 통해 기록에 기반한 변경을 가해보겠습니다.\n\n\u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enetwork\u003c/span\u003e(\n  imageUrl,\n  \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e250\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003ecacheWidth\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e750\u003c/span\u003e,\n),\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDivider\u003c/span\u003e(),\n\u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enetwork\u003c/span\u003e(\n  imageUrl,\n  \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e250\u003c/span\u003e,\n),\n\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"content-ad\"\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\n비교를 위해 cacheWidth 속성이 설정되지 않은 위젯을 추가했습니다. (한 가지 캐시 속성을 설정하면 다른 이미지도 비율을 유지하면서 크기를 조정할 수 있습니다)\n\n![image](\u003cspan class=\"hljs-regexp\"\u003e/assets/img\u003c/span\u003e\u003cspan class=\"hljs-regexp\"\u003e/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter_7.png)\n\ncacheWidth를 설정한 이미지는 과도한 오류 없이 표시되지만, 다른 이미지는 색상과 방향이 반전되고 수직으로 뒤집힙니다. cacheWidth를 올바르게 설정함으로써 이미지의 크기를 조정하여 디코딩 프로세스에서 메모리 사용량을 최적화했습니다.\n\n# 장치별 화소 비율\n\n\u0026#x3C;div class=\"content-ad\"\u003e\u0026#x3C;/\u003c/span\u003ediv\u003e\n\n그러나 여전히 문제가 발생할 수 있습니다.\n\n![image](\u003cspan class=\"hljs-regexp\"\u003e/assets/img\u003c/span\u003e\u003cspan class=\"hljs-regexp\"\u003e/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter_8.png)\n\ncacheWidth가 설정된 동일한 코드에서 iPhone 12 mini에서 이미지가 올바르게 표시되지만, 화면 크기가 작은 iPhone SE에서는 여전히 크기가 너무 크다는 표시가 있습니다.\n\n이 문제가 발생하는 이유는 무엇일까요? 오류 로그를 다시 확인해 보죠.\n\n\u0026#x3C;div class=\"content-ad\"\u003e\u0026#x3C;/\u003c/span\u003ediv\u003e\n\n## iPhone \u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e 미니\n\n\u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e [...]의 디스플레이 크기는 \u003cspan class=\"hljs-number\"\u003e750\u003c/span\u003e×\u003cspan class=\"hljs-number\"\u003e421\u003c/span\u003e이지만 디코딩 크기는 \u003cspan class=\"hljs-number\"\u003e3840\u003c/span\u003e×\u003cspan class=\"hljs-number\"\u003e2160\u003c/span\u003e으로, 기기 픽셀 비율을 \u003cspan class=\"hljs-number\"\u003e3.0\u003c/span\u003e으로 가정할 때 추가 41552KB가 사용됩니다.\n\n미리 자산의 크기를 조정하거나 cacheWidth 매개변수를 \u003cspan class=\"hljs-number\"\u003e750\u003c/span\u003e, cacheHeight 매개변수를 \u003cspan class=\"hljs-number\"\u003e421\u003c/span\u003e로 제공하거나 \u003cspan class=\"hljs-title class_\"\u003eResizeImage\u003c/span\u003e를 사용하는 것을 고려해보세요.\n\niPhone \u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e 미니의 경우, 이미지의 디스플레이 폭은 \u003cspan class=\"hljs-number\"\u003e750\u003c/span\u003e이며, 기기 픽셀 비율은 \u003cspan class=\"hljs-number\"\u003e3.0\u003c/span\u003e입니다.\n\n## iPhone \u003cspan class=\"hljs-variable constant_\"\u003eSE\u003c/span\u003e\n\n\u0026#x3C;div \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"content-ad\"\u003c/span\u003e\u003e\u0026#x3C;/div\u003e\n\n이미지 [...]는 표시 크기가 \u003cspan class=\"hljs-number\"\u003e500\u003c/span\u003e×\u003cspan class=\"hljs-number\"\u003e281\u003c/span\u003e이지만 디코딩 크기는 \u003cspan class=\"hljs-number\"\u003e3840\u003c/span\u003e×\u003cspan class=\"hljs-number\"\u003e2160\u003c/span\u003e 이며, 장치 픽셀 비율이 \u003cspan class=\"hljs-number\"\u003e2.0\u003c/span\u003e일 때 추가로 42467KB를 사용합니다.\n\n미리 에셋 크기를 조정하고, cacheWidth 매개변수를 \u003cspan class=\"hljs-number\"\u003e500\u003c/span\u003e, cacheHeight 매개변수를 \u003cspan class=\"hljs-number\"\u003e281\u003c/span\u003e로 제공하거나 \u003cspan class=\"hljs-title class_\"\u003eResizeImage\u003c/span\u003e를 사용하는 것을 고려해보세요.\n\n반면에 iPhone \u003cspan class=\"hljs-variable constant_\"\u003eSE\u003c/span\u003e의 경우, 이미지의 표시 크기는 \u003cspan class=\"hljs-number\"\u003e500\u003c/span\u003e이며, 장치 픽셀 비율은 \u003cspan class=\"hljs-number\"\u003e2.0\u003c/span\u003e입니다.\n\n이 차이는 각 장치의 다른 디바이스 픽셀 비율 때문에 발생합니다.\n\n디바이스 픽셀 비율은 디바이스 화면에 표시되는 픽셀 밀도를 나타내며, 특정 장치의 화면 크기 당 픽셀 수를 나타냅니다.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter_9.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e화소 밀도는 일반적으로 특정 디바이스의 화면 크기에 따라 다양한 값을 갖는 ppi(인치당 픽셀)로 측정됩니다. 예를 들어 고해상도 장치는 화면 크기 당 픽셀이 더 많아 더 높은 화소 밀도를 가지게 됩니다.\u003c/p\u003e\n\u003cp\u003e요약하자면, iPhone SE는 디바이스 픽셀 비율이 2.0이며, 이는 물리적 픽셀 당 2개의 픽셀을 표시한다는 것을 의미하며, iPhone 12 mini는 디바이스 픽셀 비율이 3.0이며, 즉 물리적 픽셀 당 3개의 픽셀을 표시합니다. 따라서 iPhone 12 mini를 기준으로 cacheWidth를 설정할 때, iPhone SE의 낮은 픽셀 비율로 인해 여전히 불필요한 디코딩 크기가 남아 있습니다.\u003c/p\u003e\n\u003ch1\u003e이미지 캐시 크기 동적으로 결정하기\u003c/h1\u003e\n\u003cp\u003e이제 모든 단서가 모였으니, 기기의 픽셀 비율을 기반으로 cacheWidth 값을 계산할 수 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-number\"\u003e250\u003c/span\u003e (위젯 크기) X \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e (iPhone \u003cspan class=\"hljs-variable constant_\"\u003eSE\u003c/span\u003e 기기 픽셀 비율) = \u003cspan class=\"hljs-number\"\u003e500\u003c/span\u003e (캐시 크기)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e250의 목표 위젯 크기와 iPhone SE의 1인치 당 2픽셀의 표시 방법을 고려하여, 위젯 크기에 기기 픽셀 비율을 곱하면 적절한 디스플레이 크기인 500이 나옵니다.\u003c/p\u003e\n\u003cp\u003e다음은 코드 표현입니다.\u003c/p\u003e\n\u003cp\u003e이미지 네트워크 (\nimageUrl,\nwidth: 250,\ncacheWidth: (250 * MediaQuery.of(context).devicePixelRatio).round(),\n)\u003c/p\u003e\n\u003cp\u003eMediaQuery를 사용하여 장치의 픽셀 비율을 결정하고 이미지 위젯의 너비와 곱하여 cacheWidth 값을 설정합니다. cacheWidth 속성은 정수 값을 필요로 하므로 round 메소드를 사용하여 가장 가까운 정수로 반올림합니다. 이 코드를 사용하면 장치의 픽셀 비율에 따라 이미지 크기를 조정할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e더불어 코드를 더 간결하게 만들기 위해 이미지 크기 계산을 확장(extension)으로 구현할 수 있습니다. 확장을 사용한 코드 예시는 다음과 같습니다.\u003c/p\u003e\n\u003cp\u003e확장 ImageExtension on num {\nint cacheSize(BuildContext context) {\nreturn (this * MediaQuery.of(context).devicePixelRatio).round();\n}\n}\u003c/p\u003e\n\u003cp\u003e그럼, 이미지 위젯의 확장 기능을 사용하여 필요한 캐시 값을 간결하게 설정할 수 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enetwork\u003c/span\u003e(  \n  imageUrl,  \n  \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e250\u003c/span\u003e,  \n  \u003cspan class=\"hljs-attr\"\u003ecacheWidth\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e250.\u003c/span\u003e\u003cspan class=\"hljs-title function_\"\u003ecacheSize\u003c/span\u003e(context),  \n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e캐시 크기 지정 고려 사항\u003c/h1\u003e\n\u003cp\u003e원본 이미지의 종횡비가 대상 위젯의 종횡비와 다를 때, 그리고 이미지 위젯에 fit: BoxFit.cover를 사용할 때 캐시 크기를 설정할 때 특정 측면을 고려해야 해요. 일반적으로 fit: BoxFit.cover를 사용하면 이미지가 위젯에 맞게 잘립니다. 이러한 경우에는 이미지의 표시 크기를 결정할 때 종횡비를 고려해야 해요.\u003c/p\u003e\n\u003cp\u003e만약 원본 이미지와 위젯의 종횡비가 다르다면, 이미지를 최적화하는 동안 원본 이미지의 종횡비를 유지하기 위해 작은 차원(너비 또는 높이)을 기준으로 캐시 크기를 설정해야 합니다.\u003c/p\u003e\n\u003cp\u003e그 반대로 설정하면 해상도가 낮은 이미지가 표시될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e예를 살펴보겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enetwork\u003c/span\u003e(  \n  imageUrl,  \n  \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e250\u003c/span\u003e,  \n  \u003cspan class=\"hljs-attr\"\u003eheight\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e250\u003c/span\u003e,  \n  \u003cspan class=\"hljs-attr\"\u003ecacheWidth\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e250.\u003c/span\u003e\u003cspan class=\"hljs-title function_\"\u003ecacheSize\u003c/span\u003e(context),  \n  \u003cspan class=\"hljs-attr\"\u003efit\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eBoxFit\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecover\u003c/span\u003e,\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter_10.png\" alt=\"Network Images in Flutter\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e이미지 크기: 3000 x 1688\u003c/li\u003e\n\u003cli\u003e이미지 가로 세로 비율: 1.7\u003c/li\u003e\n\u003cli\u003e디코딩된 이미지의 표시 크기: 500 x 282\u003c/li\u003e\n\u003cli\u003e이미지 위젯 크기: 250 x 250\u003c/li\u003e\n\u003cli\u003e이미지 위젯 가로 세로 비율: 1\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이미지 위젯은 250 x 250 크기이며 디바이스의 픽셀 비율을 곱한 값인 500을 cacheWidth로 설정하면 이미지의 표시 높이를 자동으로 결정하고 이미지의 가로 세로 비율을 유지합니다. 그러나 원본 이미지의 가로가 세로보다 큰 비율을 가지고 있고, 이는 위젯의 표시에 필요한 가로 세로 비율과 다르기 때문에, 디코딩된 이미지의 표시 높이(281)가 목표 표시 높이(500)보다 낮아져 이미지가 흐릿하게 보일 수 있습니다. 예시 사진에 나와 있습니다.\u003c/p\u003e\n\u003cp\u003e반면, cacheHeight를 설정하면…\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enetwork\u003c/span\u003e(\n  imageUrl,\n  \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e250\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eheight\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e250\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003ecacheHeight\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e250.\u003c/span\u003e\u003cspan class=\"hljs-title function_\"\u003ecacheSize\u003c/span\u003e(context),\n  \u003cspan class=\"hljs-attr\"\u003efit\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eBoxFit\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecover\u003c/span\u003e,\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e캐시 높이를 설정하면 이미지의 종횡비를 유지하면서 최소 표시 크기로 크기를 조정하여 이미지의 해상도를 유지합니다.\u003c/p\u003e\n\u003cp\u003e기존의 오버사이즈된 오류 로그는 여전히 발생하지만, 이미지의 크기를 크게 줄이고 종횡비를 유지하여 선명한 이미지를 제공하도록 최적화되었습니다.\u003c/p\u003e\n\u003ch1\u003e이미지 종횡비를 고려한 캐시 크기 동적 설정\u003c/h1\u003e\n\u003cp\u003e대부분의 경우에는 프런트엔드 개발자가 네트워크 이미지의 종횡비를 사전에 알지 못합니다. 이러한 상황에서는 원본 이미지의 종횡비가 0보다 큰지 여부를 기반으로 캐시 크기를 동적으로 결정할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eBuilder\u003c/span\u003e(  \n  \u003cspan class=\"hljs-attr\"\u003ebuilder\u003c/span\u003e: (context) {  \n    int? cacheWidth, cacheHeight;  \n    \u003cspan class=\"hljs-title class_\"\u003eSize\u003c/span\u003e targetSize = \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSize\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e250\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e250\u003c/span\u003e);  \n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e double originImgAspectRatio = \u003cspan class=\"hljs-number\"\u003e1.7\u003c/span\u003e;  \n   \n    \u003cspan class=\"hljs-comment\"\u003e// 원본 이미지의 종횡비가 0보다 큰 경우, 이미지가 세로보다 넓은 것을 의미합니다.\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (originImgAspectRatio \u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) {  \n      cacheHeight = targetSize.\u003cspan class=\"hljs-property\"\u003eheight\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecacheSize\u003c/span\u003e(context);  \n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {  \n      cacheWidth = targetSize.\u003cspan class=\"hljs-property\"\u003ewidth\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecacheSize\u003c/span\u003e(context);  \n    }  \n  \n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enetwork\u003c/span\u003e(  \n      imageUrl,  \n      \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e: targetSize.\u003cspan class=\"hljs-property\"\u003ewidth\u003c/span\u003e,  \n      \u003cspan class=\"hljs-attr\"\u003eheight\u003c/span\u003e: targetSize.\u003cspan class=\"hljs-property\"\u003eheight\u003c/span\u003e,  \n      \u003cspan class=\"hljs-attr\"\u003ecacheWidth\u003c/span\u003e: cacheWidth,  \n      \u003cspan class=\"hljs-attr\"\u003ecacheHeight\u003c/span\u003e: cacheHeight,  \n      \u003cspan class=\"hljs-attr\"\u003efit\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eBoxFit\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecover\u003c/span\u003e,  \n    );  \n  },  \n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드에서는 원본 이미지의 종횡비(originImgAspectRatio)를 사용하여 조건부로 cacheWidth 또는 cacheHeight를 캐시 크기로 설정합니다. 앞서 언급한 대로 캐시 크기 속성 중 하나만 설정하면 이미지가 종횡비에 맞게 크기가 조정되므로 다른 속성을 null로 설정해도 괜찮습니다.\u003c/p\u003e\n\u003ch1\u003eCacheNetworkImage 패키지\u003c/h1\u003e\n\u003cp\u003eFlutter는 네트워크에서 이미지를로드하기 위한 Image.network 위젯을 제공하지만 이미지 캐싱에는 cached_network_image 패키지를 사용하는 것이 좋습니다. 이 패키지는 세밀한 캐싱 제어를 제공하여 성능을 향상시킬 수 있습니다. 아래는 cached_network_image 패키지를 사용하는 예시입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eCachedNetworkImage\u003c/span\u003e(  \n  \u003cspan class=\"hljs-attr\"\u003eimageUrl\u003c/span\u003e: imageUrl,  \n  \u003cspan class=\"hljs-attr\"\u003ememCacheHeight\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e320.\u003c/span\u003e\u003cspan class=\"hljs-title function_\"\u003ecacheSize\u003c/span\u003e(context),  \n  \u003cspan class=\"hljs-attr\"\u003ememCacheWidth\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e250.\u003c/span\u003e\u003cspan class=\"hljs-title function_\"\u003ecacheSize\u003c/span\u003e(context),  \n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCachedNetworkImage 위젯을 사용하면 Image.network 위젯과 유사하게 캐시 크기를 지정하기 위해 memCacheHeight 및 memCacheWidth 속성을 사용할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e이 글에서는 Flutter에서 네트워크 이미지를 효율적으로 로드하고 메모리 사용량을 최적화하는 방법을 살펴보았습니다. 앱 개발 중 가장 중요한 측면 중 하나이지만 쉽게 간과될 수 있는 문제로, 특히 애플리케이션에서 고해상도 이미지를 다룰 때 부드러운 사용자 경험을 위해 중요합니다.\u003c/p\u003e\n\u003cp\u003eFlutter에서 이미지 처리에 대한 더 많은 팁과 모범 사례에 관심이 있다면, 잘 문서화된 \"Flutter를 사용한 최상의 UX 성능을 위한 12가지 이미지 팁과 모범 사례\" 문서를 참고하실 수 있습니다.\u003c/p\u003e\n\u003cp\u003e본 글에서 논의된 예제 코드에 대해 궁금하시다면, 제 GitHub 저장소에서 확인하실 수 있습니다.\u003c/p\u003e\n\u003cp\u003e위 내용을 읽어 주셔서 감사합니다!\u003c/p\u003e\n\u003ch1\u003e참고 자료\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.themoviedb.org/tv/1396-breaking-bad/images/backdrops?language=ko\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://www.themoviedb.org/tv/1396-breaking-bad/images/backdrops?language=ko\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://api.flutter.dev/flutter/painting/debugInvertOversizedImages.html\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://api.flutter.dev/flutter/painting/debugInvertOversizedImages.html\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/flutter/flutter/issues/56239\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://github.com/flutter/flutter/issues/56239\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter"},"buildId":"-yEBofE4jMl3RL1kr5c4Y","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>