<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Serverpod 시작하기 인증  첫 번째 파트 | uidev-css</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://uidev-css.github.io///post/2024-06-21-GettingStartedwithServerpodAuthenticationPart1" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Serverpod 시작하기 인증  첫 번째 파트 | uidev-css" data-gatsby-head="true"/><meta property="og:title" content="Serverpod 시작하기 인증  첫 번째 파트 | uidev-css" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-21-GettingStartedwithServerpodAuthenticationPart1_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://uidev-css.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://uidev-css.github.io///post/2024-06-21-GettingStartedwithServerpodAuthenticationPart1" data-gatsby-head="true"/><meta name="twitter:title" content="Serverpod 시작하기 인증  첫 번째 파트 | uidev-css" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-21-GettingStartedwithServerpodAuthenticationPart1_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | uidev-css" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-21 21:49" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b4eed7811784bdd3.js" defer=""></script><script src="/_next/static/9ddMoNNI_mr3kv4sKx3b_/_buildManifest.js" defer=""></script><script src="/_next/static/9ddMoNNI_mr3kv4sKx3b_/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UIDEV CSS</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Serverpod 시작하기 인증  첫 번째 파트</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Serverpod 시작하기 인증  첫 번째 파트" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UIDEV CSS</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 21, 2024</span><span class="posts_reading_time__f7YPP">24<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-21-GettingStartedwithServerpodAuthenticationPart1&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>서버파드에서 이메일 및 비밀번호 인증 구현 단계별 가이드</h2>
<p><img src="/assets/img/2024-06-21-GettingStartedwithServerpodAuthenticationPart1_0.png" alt="이미지"></p>
<h1>인증 시리즈</h1>
<p>부분 1 — 이메일 및 비밀번호 인증
부분 2 — 구글 인증
부분 2.5 — 구글 API
부분 3 — 애플 인증</p>
<div class="content-ad"></div>
<h1>소개</h1>
<p>서버포드에서 인증에 관한 시리즈의 제1부에 오신 것을 환영합니다! 본 문서에서는 서버포드 및 플러터 애플리케이션에서 이메일 및 비밀번호 인증을 구현하는 데 초점을 맞춥니다. 이메일 및 비밀번호 인증은 대부분의 애플리케이션에 있어 일반적이고 필수적인 기능으로, 사용자가 계정을 만들고 로그인하여 데이터에 안전하게 접근할 수 있게 합니다.</p>
<p>우리는 서버포드 프로젝트를 생성부터 서버포드 인증 모듈을 설정하는 과정까지 전체 과정을 안내해 드리겠습니다. 또한 서버 측 코드 설정과 제3자 메일 서버와 통합하는 방법, 사용자 인터페이스를 구축하고 서버와 연결하는 방법에 대한 지침도 제공할 것입니다.</p>
<p>본 문서를 마치면 서버포드-플러터 애플리케이션에서 이메일 및 비밀번호 인증을 어떻게 구현하는지에 대한 탄탄한 이해를 갖추게 되며, 향후 시리즈 뒷부분의 추가적인 인증 방법 탐색을 위한 기초가 마련될 것입니다.</p>
<div class="content-ad"></div>
<p>이 튜토리얼에서 생성하는 완전한 예제 프로젝트는 여기에서 확인할 수 있습니다.</p>
<p>시작해 봅시다!</p>
<h2>전제 조건</h2>
<p>Serverpod로 이메일 및 비밀번호 인증을 구현하기 전에 필요한 몇 가지 전제 조건이 있습니다. 이미 Serverpod CLI 및 Docker를 비롯한 필요한 도구를 설치했다고 가정합니다. 아직 이 도구들을 설정하지 않은 경우, 공식 Serverpod 문서를 참고하여 시작하십시오.</p>
<div class="content-ad"></div>
<p>또한, 이 글에서 나중에 생성할 데이터베이스 및 테이블을 검토하기 위해 Postico2, PgAdmin, 또는 DBeaver와 같은 데이터베이스 뷰어를 다운로드하고 설치하는 것을 권장합니다. 선호하는 데이터베이스 뷰어를 사용할 수 있습니다. 이 글에서는 Postico2를 사용할 예정입니다.</p>
<h1>서버포드 프로젝트 만들기</h1>
<p>새로운 서버포드 프로젝트를 생성합니다: 다음 명령을 실행하여 새로운 서버포드 프로젝트를 만듭니다:</p>
<pre><code class="hljs language-js">serverpod create my_project
</code></pre>
<div class="content-ad"></div>
<p>프로젝트 디렉토리로 이동하세요: 프로젝트 내 서버 디렉토리로 작업 디렉토리를 변경하세요:</p>
<pre><code class="hljs language-js">cd my_project/my_project_server
</code></pre>
<p>Windows 환경에서: 윈도우 환경이라면, 서버팟을 위한 필요한 데이터베이스 테이블을 만들기 위해 설정 중에 이 추가 단계를 수행해야 합니다. 서버 프로젝트 내에서 setup-tables.cmd라는 cmd 파일을 찾을 수 있을 것입니다. 이 스크립트를 실행하세요! 이는 generate/tables-serverpod.pgsql에 위치한 psql 파일을 실행할 것입니다. 리눅스와 맥에서는 프로젝트를 생성할 때 이 단계가 자동으로 수행됩니다.</p>
<p>컨테이너 시작하기: 서버팟 프로젝트에 필요한 Docker 컨테이너를 시작하기 위해 다음 명령을 실행하세요:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">docker-compose up --build --detach
</code></pre>
<h1>서버팟_인증 모듈 설치 및 구성하기</h1>
<p>서버팟<em>인증 모듈은 Serverpod 프로젝트에서 인증을 관리하는 데 필수적인 기능을 제공합니다. 사용자 등록, 로그인, 비밀번호 해싱 및 세션 관리와 같은 기능이 포함되어 있습니다. 이 섹션에서는 서버팟</em>인증 모듈 설치 및 구성 프로세스를 안내하고 데이터베이스를 업데이트하는 방법을 안내합니다.</p>
<h2>서버 쪽 설정</h2>
<div class="content-ad"></div>
<p>서버파드 프로젝트(my_project_server)의 pubspec.yaml 파일을 열고 다음 줄을 의존성 섹션 아래에 추가해주세요:</p>
<pre><code class="hljs language-js"><span class="hljs-attr">dependencies</span>:
  <span class="hljs-attr">serverpod_auth_server</span>: ^<span class="hljs-number">2.0</span><span class="hljs-number">.0</span>
</code></pre>
<p>참고: 모든 서버파드 종속성의 버전은 동일해야 합니다! serverpod_auth를 버전 2.0.0으로 추가하는 경우, serverpod와 설치한 다른 서버파드 패키지도 2.0.0이어야 합니다.</p>
<p>버전 2.0 이상인 경우 서버파드 객체에 authenticationHandler를 등록하세요: main.dart 파일에 다음 코드를 추가해주세요. 이 콜백은 클라이언트로부터 수신된 요청을 인증하는 데 사용됩니다. 이전 버전은 이 단계를 완료할 필요가 없습니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-string">'package:serverpod_auth_server/serverpod_auth_server.dart'</span> <span class="hljs-keyword">as</span> auth;

<span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span>(<span class="hljs-title class_">List</span>&#x3C;<span class="hljs-title class_">String</span>> args) <span class="hljs-keyword">async</span> {
  <span class="hljs-keyword">var</span> pod = <span class="hljs-title class_">Serverpod</span>(
    args,
    <span class="hljs-title class_">Protocol</span>(),
    <span class="hljs-title class_">Endpoints</span>(),
    <span class="hljs-attr">authenticationHandler</span>: auth.<span class="hljs-property">authenticationHandler</span>, <span class="hljs-comment">// 이 줄을 추가하세요</span>
  );

  <span class="hljs-keyword">await</span> pod.<span class="hljs-title function_">start</span>();
}
</code></pre>
<p>의존성 가져오고 필요한 파일 생성하기: 프로젝트의 루트 디렉토리에서 다음 명령을 실행하여 새로운 종속성을 가져오고 서버 구성에 따라 필요한 파일을 생성하세요:</p>
<pre><code class="hljs language-js">dart pub get
serverpod generate
</code></pre>
<p>기존 데이터베이스에 필요한 테이블 업데이트하기: Serverpod auth 모듈에는 모듈이 작동하는 데 필요한 데이터베이스 테이블 세트가 함께 제공됩니다. 이를 생성해봅시다.</p>
<div class="content-ad"></div>
<p>만약 Serverpod 버전 1.2 이상을 사용하고 있다면, 마이그레이션 시스템을 사용해야 해요! 다음 명령어로 새 마이그레이션을 만들어보세요:</p>
<pre><code class="hljs language-js">serverpod create-migration
</code></pre>
<p>그리고 새 마이그레이션을 적용하려면 아래 명령어를 사용하세요:</p>
<pre><code class="hljs language-js">dart bin/main.<span class="hljs-property">dart</span> --apply-migrations --role=maintenance
</code></pre>
<div class="content-ad"></div>
<p>유지 관리 역할을 설정하면 서버가 부팅되어 데이터베이스에 연결한 후 종료됩니다.</p>
<p>버전 1.1 이하:</p>
<ul>
<li>새 SQL 파일 만들기: 기존 tables-serverpod.pgsql 파일이 있는 폴더에 tables-serverpod-auth.pgsql이라는 새 파일을 만듭니다. 이 파일에는 새 테이블을 생성하는 SQL 코드가 포함될 것입니다.</li>
<li>SQL 코드 복사: serverpod_auth 모듈의 테이블을 생성하는 SQL 코드에 액세스하려면 다음 링크를 엽니다: serverpod_auth tables.pgsql. 파일 전체 내용을 복사합니다.</li>
<li>SQL 코드를 새 파일에 붙여넣기: 새로 생성된 tables-serverpod-auth.pgsql 파일을 열고 복사한 SQL 코드를 붙여넣습니다.</li>
<li>Docker 컨테이너 이름 찾기: <code>docker ps</code>를 실행하거나 Docker 대시보드를 확인하여 Docker 컨테이너 이름을 찾습니다. 아래 스크린샷을 참고할 수도 있습니다.</li>
</ul>
<p><img src="/assets/img/2024-06-21-GettingStartedwithServerpodAuthenticationPart1_1.png" alt="이미지"></p>
<div class="content-ad"></div>
<p>포스트그레SQL 파일을 컨테이너로 복사하고 SQL 코드를 실행하려면 다음 단계를 따르세요: <code>container_name</code>을(를) Docker 컨테이너 이름으로 바꿔주세요.</p>
<pre><code class="hljs language-js">docker cp ./tables-serverpod-auth.<span class="hljs-property">pgsql</span> &#x3C;container_name>:<span class="hljs-regexp">/docker-entrypoint-initdb.d/</span>tables-serverpod-auth.<span class="hljs-property">pgsql</span>

docker exec -u postgres &#x3C;container_name> psql my_project postgres -f /docker-entrypoint-initdb.<span class="hljs-property">d</span>/tables-serverpod-auth.<span class="hljs-property">pgsql</span>
</code></pre>
<h2>데이터베이스에 Postico 연결하기</h2>
<p>시작하려면 Postico2를 열고 "새 서버"를 클릭하여 새 연결을 만드세요. 로컬 포스트그레SQL 서버의 연결 세부 정보를 입력해야 합니다. 이 정보는 Serverpod 프로젝트의 config/development.yaml 및 config/passwords.yaml 파일에서 찾을 수 있습니다.</p>
<div class="content-ad"></div>
<p>아래는 Markdown 형식으로 표 태그를 변경한 내용입니다.</p>
<p><img src="/assets/img/2024-06-21-GettingStartedwithServerpodAuthenticationPart1_2.png" alt="GettingStartedwithServerpodAuthenticationPart1_2"></p>
<p><img src="/assets/img/2024-06-21-GettingStartedwithServerpodAuthenticationPart1_3.png" alt="GettingStartedwithServerpodAuthenticationPart1_3"></p>
<p>모든 테이블이 성공적으로 생성되었습니다. 다음 단계로 넘어가겠습니다.</p>
<h2>클라이언트 라이브러리 설정</h2>
<div class="content-ad"></div>
<p>클라이언트 측에서 serverpod_auth 모듈을 사용하려면 클라이언트 프로젝트에 serverpod_auth_client 종속성을 추가해야 합니다.</p>
<p>클라이언트 프로젝트의 pubspec.yaml 파일을 열고 다음 라인을 dependencies 섹션 아래에 추가하세요:</p>
<pre><code class="hljs language-js"><span class="hljs-attr">dependencies</span>:
  ...
  <span class="hljs-attr">serverpod_auth_client</span>: ^<span class="hljs-number">2.0</span><span class="hljs-number">.0</span>
</code></pre>
<p>이 패키지에는 서버로 이메일 및 비밀번호 인증을 위한 API 호출을 만들기 위해 필요한 클라이언트 측 라이브러리 코드가 포함되어 있습니다. serverpod_auth_email_flutter가 제공하는 미리 빌드된 UI 구성 요소를 사용 중이라면 해당 종속성은 엄격히 필요하지는 않지만 모든 생성된 인증 엔드포인트가 포함되어 있어 상호 작용할 수 있으므로 여기에 추가하는 것이 좋습니다.</p>
<div class="content-ad"></div>
<h2>플러터 앱 설정</h2>
<p>Serverpod를 사용하여 이메일 및 비밀번호 인증에 필요한 서버 측 변경 사항을 구현한 후, 다음 단계는 Flutter 앱과 통합하는 것입니다. 다행히도 Serverpod는 이 프로세스를 가능한한 원활하게 만들기 위해 미리 구축된 UI 컴포넌트를 제공합니다.</p>
<p>먼저, Flutter 앱에 필요한 클라이언트 측 종속성을 추가해야 합니다. Serverpod 프로젝트(my_project_flutter)의 pubspec.yaml 파일을 열고 다음과 같은 라인을 dependencies 섹션 아래 추가해주세요:</p>
<pre><code class="hljs language-js"><span class="hljs-attr">dependencies</span>:
  ...
  <span class="hljs-attr">serverpod_auth_email_flutter</span>: ^<span class="hljs-number">2.0</span><span class="hljs-number">.0</span>
  <span class="hljs-attr">serverpod_auth_shared_flutter</span>: ^<span class="hljs-number">2.0</span><span class="hljs-number">.0</span>
</code></pre>
<div class="content-ad"></div>
<p>pubspec.yaml 파일에 필요한 종속성을 추가한 후에는 터미널에서 flutter pub get을 실행하여 종속성을 업데이트해야 합니다.</p>
<p>이러한 패키지에는 사전 제작된 UI 구성 요소 및 서버 통합을 최대한 간단하게 만드는 기타 도구가 포함되어 있습니다. 그러나 자체 UI 구성 요소를 만들기를 선호하는 경우, 생성된 클라이언트 라이브러리와 통합할 수 있고 이 경우에는 이러한 종속성이 필요하지 않습니다.</p>
<h1>서버 시작 및 클라이언트 실행</h1>
<p>축하합니다! 이제 모든 필요한 종속성이 설정된 프로젝트가 있습니다. 다음으로 진행하기 전에 모든 것이 올바르게 작동하는지 확인해 봅시다.</p>
<div class="content-ad"></div>
<p>서버를 시작하려면 터미널에서 my_project_server 디렉토리로 이동한 다음 다음 명령어를 실행하세요:</p>
<pre><code class="hljs language-js">cd my_project_server
dart bin/main.<span class="hljs-property">dart</span>
</code></pre>
<img src="/assets/img/2024-06-21-GettingStartedwithServerpodAuthenticationPart1_4.png">
<p>다음으로, 새 터미널 창에서 my_project_flutter 디렉토리로 이동한 다음 다음 명령어를 실행하여 Flutter 앱을 시작하세요:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">cd my_project_flutter
flutter run
</code></pre>
<p>크롬에서 실행하여 메시지를 보내는 테스트를 선택하세요!</p>
<img src="/assets/img/2024-06-21-GettingStartedwithServerpodAuthenticationPart1_5.png">
<h2>문제 해결</h2>
<div class="content-ad"></div>
<p>문제가 발생하면 문제를 진단하는 데 도움이 되는 몇 가지를 확인할 수 있습니다:</p>
<ul>
<li>이 가이드의 이전 단계를 모두 올바르게 따랐는지 확인하세요.</li>
<li>서버가 오류 없이 실행 중인지 확인하세요. 오류가 있으면 서버를 시작한 터미널에 표시됩니다.</li>
<li>필요한 데이터베이스 테이블이 모두 생성되었는지 확인하세요. 이를 확인하려면 Postgres나 pgAdmin과 같은 도구를 사용하여 데이터베이스에 연결하고 public 스키마에있는 테이블을 확인하세요. 테이블이 누락 된 경우 해당 테이블을 만들기 위해 SQL 스크립트를 실행했는지 확인하세요.</li>
<li>여전히 문제가 발생하는 경우 앱의 콘솔 또는 로그에서 추가 컨텍스트를 제공 할 수있는 오류 메시지를 확인하세요.</li>
</ul>
<h1>이메일/비밀번호 인증 구현</h1>
<p>이제 서버와 클라이언트 라이브러리를 설정 했으므로 Flutter 앱에서 인증을 구현할 시간입니다. 이전에 추가 한 serverpod_auth_email_flutter 및 serverpod_auth_shared_flutter 패키지를 사용합니다.</p>
<div class="content-ad"></div>
<p>첫 번째 단계는 Client 및 SessionManager 객체를 초기화하는 것입니다. 먼저 my_project_flutter/lib/src/ 폴더 안에 serverpod_client.dart 파일을 생성해보세요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-string">'package:my_project_client/my_project_client.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:serverpod_auth_shared_flutter/serverpod_auth_shared_flutter.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:serverpod_flutter/serverpod_flutter.dart'</span>;

late <span class="hljs-title class_">SessionManager</span> sessionManager;
late <span class="hljs-title class_">Client</span> client;

<span class="hljs-title class_">Future</span>&#x3C;<span class="hljs-keyword">void</span>> <span class="hljs-title function_">initializeServerpodClient</span>() <span class="hljs-keyword">async</span> {
  <span class="hljs-comment">// 안드로이드 에뮬레이터는 기본적으로 로컬호스트에 액세스할 수 없습니다.</span>
  <span class="hljs-comment">// const ipAddress = '10.0.2.2'; // 호스트에 대한 안드로이드 에뮬레이터 IP 주소</span>

  <span class="hljs-comment">// 실제 장치에서는 ipAddress를 컴퓨터의 IP 주소로 대체하십시오.</span>
  <span class="hljs-keyword">const</span> ipAddress = <span class="hljs-string">'localhost'</span>;

  <span class="hljs-comment">// 어플리케이션 어디서든 사용할 수 있는 싱글톤 클라이언트 객체를 설정합니다.</span>
  <span class="hljs-comment">// 해당 클라이언트는 서버 코드에서 생성됩니다.</span>
  <span class="hljs-comment">// 클라이언트는 로컬 서버의 기본 포트에서 실행 중인 Serverpod에 연결하도록 설정됩니다.</span>
  <span class="hljs-comment">// 스테이징이나 프로덕션 서버에 연결하려면 수정해야 합니다.</span>
  client = <span class="hljs-title class_">Client</span>(
    <span class="hljs-string">'http://$ipAddress:8080/'</span>,
    <span class="hljs-attr">authenticationKeyManager</span>: <span class="hljs-title class_">FlutterAuthenticationKeyManager</span>(),
  )..<span class="hljs-property">connectivityMonitor</span> = <span class="hljs-title class_">FlutterConnectivityMonitor</span>();

  <span class="hljs-comment">// 세션 관리자는 사용자의 로그인 상태를 추적합니다.</span>
  <span class="hljs-comment">// 사용자가 현재 로그인되어 있는지 확인하고 사용자 정보를 가져올 수 있습니다.</span>
  sessionManager = <span class="hljs-title class_">SessionManager</span>(
    <span class="hljs-attr">caller</span>: client.<span class="hljs-property">modules</span>.<span class="hljs-property">auth</span>,
  );

  <span class="hljs-keyword">await</span> sessionManager.<span class="hljs-title function_">initialize</span>();
}
</code></pre>
<p>본 함수는 클라이언트와 서버 간 통신에 사용되는 싱글톤 Client 객체를 설정하고, 사용자의 로그인 상태를 추적하는 SessionManager 객체를 초기화합니다.</p>
<p>이전 단계에서 생성된 Client 객체를 사용하려면 main() 함수에서 싱글톤 인스턴스로 초기화해야 합니다. 이를 위해 main.dart 파일의 main() 함수에서 WidgetsFlutterBinding.ensureInitialized()를 호출하여 Flutter가 완전히 초기화된 후에 SessionManager를 사용할 수 있도록 해야 합니다. 그 후에 방금 만든 initializeServerpodClient() 함수를 호출할 수 있습니다. 마지막으로 runApp() 함수를 호출하여 어플리케이션을 시작할 수 있습니다. 아래는 업데이트된 main() 함수의 예시입니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>() <span class="hljs-keyword">async</span> {
  <span class="hljs-comment">// runApp을 호출하기 전에 Flutter 바인딩을 사용하는 SessionManager를 호출해야 합니다.</span>
  <span class="hljs-title class_">WidgetsFlutterBinding</span>.<span class="hljs-title function_">ensureInitialized</span>();

  <span class="hljs-keyword">await</span> <span class="hljs-title function_">initializeServerpodClient</span>();

  <span class="hljs-title function_">runApp</span>(<span class="hljs-keyword">const</span> <span class="hljs-title class_">MyApp</span>());
}
</code></pre>
<p>다음으로 사용자에게 로그인 양식을 표시할 SignInPage 위젯을 만들겠습니다. 또한 사용자가 성공적으로 로그인한 후에 표시될 AccountPage 위젯도 만들겠습니다.</p>
<h2>SignIn 페이지 생성</h2>
<p>Flutter 앱에서 이메일 및 비밀번호 인증을 활성화하기 위해 serverpod_auth_email_flutter 패키지에서 제공하는 SignInWithEmailButton이라는 미리 만들어진 위젯을 사용하여 로그인 페이지를 생성할 것입니다. 이 위젯은 로그인 버튼을 생성하며 로그인 흐름을 처리하는 대화 상자를 제공합니다.</p>
<div class="content-ad"></div>
<p>먼저, Flutter 앱의 lib/src/widgets 폴더에 sign_in_page.dart란 이름의 새 파일을 만들어주세요.</p>
<p>다음으로, StatelessWidget을 확장하는 SignInPage라는 새 클래스를 만들어주세요. 이 클래스는 Dialog 위젯으로 감싸진 로그인 버튼을 반환할 것입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter/material.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:serverpod_auth_email_flutter/serverpod_auth_email_flutter.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:my_project_flutter/src/serverpod_client.dart'</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">SignInPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">StatelessWidget</span> {
  <span class="hljs-keyword">const</span> <span class="hljs-title class_">SignInPage</span>({<span class="hljs-title class_">Key</span>? key}) : <span class="hljs-variable language_">super</span>(<span class="hljs-attr">key</span>: key);

  @override
  <span class="hljs-title class_">Widget</span> <span class="hljs-title function_">build</span>(<span class="hljs-params">BuildContext context</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Center</span>(
      <span class="hljs-attr">child</span>: <span class="hljs-title class_">Dialog</span>(
        <span class="hljs-attr">child</span>: <span class="hljs-title class_">Container</span>(
          <span class="hljs-attr">width</span>: <span class="hljs-number">260</span>,
          <span class="hljs-attr">padding</span>: <span class="hljs-keyword">const</span> <span class="hljs-title class_">EdgeInsets</span>.<span class="hljs-title function_">all</span>(<span class="hljs-number">16</span>),
          <span class="hljs-attr">child</span>: <span class="hljs-title class_">Column</span>(
            <span class="hljs-attr">mainAxisSize</span>: <span class="hljs-title class_">MainAxisSize</span>.<span class="hljs-property">min</span>,
            <span class="hljs-attr">crossAxisAlignment</span>: <span class="hljs-title class_">CrossAxisAlignment</span>.<span class="hljs-property">stretch</span>,
            <span class="hljs-attr">children</span>: [
              <span class="hljs-title class_">SignInWithEmailButton</span>(
                <span class="hljs-attr">caller</span>: client.<span class="hljs-property">modules</span>.<span class="hljs-property">auth</span>,
              ),
            ],
          ),
        ),
      ),
    );
  }
}
</code></pre>
<p>위 코드에서, SignInWithEmailButton 위젯은 caller라는 인자를 가져오는데, 이는 Serverpod에서 제공하는 생성된 클라이언트 라이브러리의 인스턴스입니다. 이를 통해 위젯이 Serverpod 서버와 통신할 수 있게 됩니다.</p>
<div class="content-ad"></div>
<h2>홈페이지에 SignInPage 추가하기</h2>
<p>앱의 홈페이지에 SignInPage를 추가하려면 lib/ 폴더의 루트에 위치한 main.dart 파일 내에 정의된 MyHomePage 클래스를 수정해야 합니다.</p>
<p>기존의 MyHomePage 클래스를 다음 코드로 변경하세요. 이 클래스 아래에 있는 내용은 모두 제거해도 됩니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyHomePageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">State</span>&#x3C;<span class="hljs-title class_">MyHomePage</span>> {
  @override
  <span class="hljs-title class_">Widget</span> <span class="hljs-title function_">build</span>(<span class="hljs-params">BuildContext context</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Scaffold</span>(
      <span class="hljs-attr">appBar</span>: <span class="hljs-title class_">AppBar</span>(
        <span class="hljs-attr">title</span>: <span class="hljs-title class_">Text</span>(widget.<span class="hljs-property">title</span>),
      ),
      <span class="hljs-attr">body</span>: <span class="hljs-keyword">const</span> <span class="hljs-title class_">SignInPage</span>(),
    );
  }
}
</code></pre>
<div class="content-ad"></div>
<p>잊지 말고 SignInPage 위젯에 대한 import 문을 추가해주세요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-string">"package:my_project_flutter/src/widgets/sign_in_page.dart"</span>;
</code></pre>
<p>전체 main.dart 파일은 다음과 같이 보여야 합니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-string">'package:my_project_flutter/src/serverpod_client.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:my_project_flutter/src/widgets/sign_in_page.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter/material.dart'</span>;

<span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>() <span class="hljs-keyword">async</span> {
  <span class="hljs-comment">// runApp을 호출하기 전에 Flutter 바인딩을 사용하는 SessionManager를 초기화해야 합니다.</span>
  <span class="hljs-title class_">WidgetsFlutterBinding</span>.<span class="hljs-title function_">ensureInitialized</span>();

  <span class="hljs-keyword">await</span> <span class="hljs-title function_">initializeServerpodClient</span>();

  <span class="hljs-title function_">runApp</span>(<span class="hljs-keyword">const</span> <span class="hljs-title class_">MyApp</span>());
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">StatelessWidget</span> {
  <span class="hljs-keyword">const</span> <span class="hljs-title class_">MyApp</span>({<span class="hljs-title class_">Key</span>? key}) : <span class="hljs-variable language_">super</span>(<span class="hljs-attr">key</span>: key);

  @override
  <span class="hljs-title class_">Widget</span> <span class="hljs-title function_">build</span>(<span class="hljs-params">BuildContext context</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">MaterialApp</span>(
      <span class="hljs-attr">title</span>: <span class="hljs-string">'Serverpod demo'</span>,
      <span class="hljs-attr">theme</span>: <span class="hljs-title class_">ThemeData</span>(
        <span class="hljs-attr">primarySwatch</span>: <span class="hljs-title class_">Colors</span>.<span class="hljs-property">blue</span>,
      ),
      <span class="hljs-attr">home</span>: <span class="hljs-keyword">const</span> <span class="hljs-title class_">MyHomePage</span>(<span class="hljs-attr">title</span>: <span class="hljs-string">'Serverpod Example'</span>),
    );
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyHomePage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">StatefulWidget</span> {
  <span class="hljs-keyword">const</span> <span class="hljs-title class_">MyHomePage</span>({<span class="hljs-title class_">Key</span>? key, required <span class="hljs-variable language_">this</span>.<span class="hljs-property">title</span>}) : <span class="hljs-variable language_">super</span>(<span class="hljs-attr">key</span>: key);

  final <span class="hljs-title class_">String</span> title;

  @override
  <span class="hljs-title class_">MyHomePageState</span> <span class="hljs-title function_">createState</span>() => <span class="hljs-title class_">MyHomePageState</span>();
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyHomePageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">State</span>&#x3C;<span class="hljs-title class_">MyHomePage</span>> {
  @override
  <span class="hljs-title class_">Widget</span> <span class="hljs-title function_">build</span>(<span class="hljs-params">BuildContext context</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Scaffold</span>(
      <span class="hljs-attr">appBar</span>: <span class="hljs-title class_">AppBar</span>(
        <span class="hljs-attr">title</span>: <span class="hljs-title class_">Text</span>(widget.<span class="hljs-property">title</span>),
      ),
      <span class="hljs-attr">body</span>: <span class="hljs-keyword">const</span> <span class="hljs-title class_">SignInPage</span>()
    );
  }
}
</code></pre>
<div class="content-ad"></div>
<p>앱을 새로고침하면 이제 로그인 버튼을 볼 수 있어요! 아직 끝나지 않았지만 실제로 서버와 통신할 수 있어야 해요!</p>
<p><img src="/assets/img/2024-06-21-GettingStartedwithServerpodAuthenticationPart1_6.png" alt="이미지"></p>
<p>이제 우리 앱의 홈 페이지에 로그인 페이지를 통합했고 계정을 생성할 수 있어요. 그러나 로그인 프로세스를 완료하기 위해 서버에서 전송된 인증 코드가 필요해요. 계정 등록을 위해 사용자는 회원 가입 페이지의 필수 필드를 작성하고 양식을 제출할 수 있어요. 제출하면 서버가 제공된 이메일 주소로 인증 코드를 보내줄 거에요. 현재 우리는 인증 코드에 액세스하지 못하므로 로그인 프로세스를 아직 완료할 수 없어요. 이 문제를 해결해 봐요!</p>
<h2>이메일 인증 콜백 통합하기</h2>
<div class="content-ad"></div>
<p>회원 가입 프로세스를 완료하려면 검증 이메일을 보내는 콜백을 추가해야 합니다. Serverpod은 회원 가입을 위한 검증 코드 및 비밀번호 재설정을 위한 메일을 보내는 데 유용한 몇 가지 콜백을 제공합니다. 지금은 콘솔에 코드를 출력하여 기능을 테스트하기 위한 빠르고 간단한 솔루션을 구현해 봅시다.</p>
<p>서버 프로젝트의 server.dart 파일에 다음 구성을 추가하여 콜백을 설정할 수 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-string">'package:serverpod_auth_server/module.dart'</span> <span class="hljs-keyword">as</span> auth;

<span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span>(<span class="hljs-title class_">List</span>&#x3C;<span class="hljs-title class_">String</span>> args) <span class="hljs-keyword">async</span> {
  ...
  auth.<span class="hljs-property">AuthConfig</span>.<span class="hljs-title function_">set</span>(auth.<span class="hljs-title class_">AuthConfig</span>(
    <span class="hljs-attr">sendValidationEmail</span>: (session, email, validationCode) <span class="hljs-keyword">async</span> {
      <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 메일 서버와 연동</span>
      <span class="hljs-title function_">print</span>(<span class="hljs-string">'검증 코드: $validationCode'</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    },
    <span class="hljs-attr">sendPasswordResetEmail</span>: (session, userInfo, validationCode) <span class="hljs-keyword">async</span> {
      <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 메일 서버와 연동</span>
      <span class="hljs-title function_">print</span>(<span class="hljs-string">'검증 코드: $validationCode'</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    },
  ));

  ...
  <span class="hljs-keyword">await</span> pod.<span class="hljs-title function_">start</span>();
}
</code></pre>
<p>run() 메서드 내에서 pod.start()를 호출하기 전에 이 코드를 추가하여 콜백이 제대로 설정되도록 해줍니다.</p>
<div class="content-ad"></div>
<p>위에 바꾼 사항들이 적용되도록 하려면 Serverpod 서버를 다시 시작해야 합니다. 서버를 시작한 터미널로 이동하여 "CTRL + C"를 눌러 중지한 후, "dart bin/main.dart"를 실행하여 서버를 다시 시작합니다.</p>
<p>지금 테스트해 봅시다!</p>
<p>로그인 버튼을 생성하고 정보를 입력해 봅시다!</p>
<p><img src="/assets/img/2024-06-21-GettingStartedwithServerpodAuthenticationPart1_7.png" alt="이미지"></p>
<div class="content-ad"></div>
<p>지금은 이메일을 받지 않을 거에요. 대신에 서버를 실행한 터미널에서 확인 코드를 찾아보셔야 해요.</p>
<p>마크다운(Markdown) 형식으로 테이블 태그를 변경해주세요.</p>
<p><img src="/assets/img/2024-06-21-GettingStartedwithServerpodAuthenticationPart1_8.png" alt="이미지 1"></p>
<p><img src="/assets/img/2024-06-21-GettingStartedwithServerpodAuthenticationPart1_9.png" alt="이미지 2"></p>
<h1>데이터베이스에서 사용자 생성 확인</h1>
<div class="content-ad"></div>
<p>이제 어플리케이션에 가입 기능을 설정했으니, 사용자 데이터가 데이터베이스에 올바르게 저장되는지 확인해야 합니다. 아직 Flutter 앱에서 사용자 페이지를 구현하지 않았으므로 Postico2를 사용하여 사용자 생성을 확인할 수 있습니다.</p>
<p>Postico2를 열고 이전에 설정 섹션에서 한 것과 같이 데이터베이스에 연결하십시오. 데이터베이스에 연결한 후 'serverpod_user_info' 테이블을 클릭하십시오. 방금 생성한 사용자를 확인할 수 있어야 합니다.</p>
<img src="/assets/img/2024-06-21-GettingStartedwithServerpodAuthenticationPart1_10.png">
<h1>계정 페이지 구현</h1>
<div class="content-ad"></div>
<p>지금 로그인 페이지가 작동되고 있다면, 이제 계정 페이지를 구현해 보겠습니다. 이 페이지는 현재 로그인한 사용자에 대한 정보를 보여줄 것입니다. 이를 위해 이전에 만들었던 SessionManager 객체를 사용할 것입니다. SessionManager는 사용자의 로그인 상태를 추적하고 사용자에 대한 정보에 액세스할 수 있는 기능을 제공합니다.</p>
<p>SessionManager가 제공하는 일부 함수를 살펴보겠습니다:</p>
<ul>
<li>isSignedIn(): 이 함수는 사용자가 현재 로그인되어 있는 경우 true를 반환하고 그렇지 않으면 false를 반환합니다.</li>
<li>getSignedInUser(): 이 함수는 현재 로그인한 사용자에 대한 정보(이메일 주소 및 표시 이름과 같은)가 포함된 UserInfo 유형의 객체를 반환합니다.</li>
<li>signOut(): 이 함수는 사용자를 로그아웃하고 인증 상태를 지웁니다.</li>
</ul>
<p>CircularUserImage 위젯은 Serverpod 프레임워크가 제공하는 사전 제작된 위젯으로, UserInfo 객체를 입력으로 받아서 원형 프로필 이미지를 표시합니다. sessionManager와 이 위젯을 조합하여 멋진 디자인의 계정 페이지를 만들 수 있습니다.</p>
<div class="content-ad"></div>
<p>lib/src/widgets 디렉토리 안에 account_page.dart라는 새 파일을 만들고 다음 코드를 추가할 거에요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter/material.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:serverpod_auth_shared_flutter/serverpod_auth_shared_flutter.dart'</span>;

<span class="hljs-keyword">import</span> <span class="hljs-string">'package:my_project_flutter/src/serverpod_client.dart'</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">StatelessWidget</span> {
  <span class="hljs-keyword">const</span> <span class="hljs-title class_">AccountPage</span>({<span class="hljs-title class_">Key</span>? key}) : <span class="hljs-variable language_">super</span>(<span class="hljs-attr">key</span>: key);

  @override
  <span class="hljs-title class_">Widget</span> <span class="hljs-title function_">build</span>(<span class="hljs-params">BuildContext context</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">ListView</span>(
      <span class="hljs-attr">children</span>: [
        <span class="hljs-title class_">ListTile</span>(
          <span class="hljs-attr">contentPadding</span>:
              <span class="hljs-keyword">const</span> <span class="hljs-title class_">EdgeInsets</span>.<span class="hljs-title function_">symmetric</span>(<span class="hljs-attr">vertical</span>: <span class="hljs-number">8</span>, <span class="hljs-attr">horizontal</span>: <span class="hljs-number">16</span>),
          <span class="hljs-attr">leading</span>: <span class="hljs-title class_">CircularUserImage</span>(
            <span class="hljs-attr">userInfo</span>: sessionManager.<span class="hljs-property">signedInUser</span>,
            <span class="hljs-attr">size</span>: <span class="hljs-number">42</span>,
          ),
          <span class="hljs-attr">title</span>: <span class="hljs-title class_">Text</span>(sessionManager.<span class="hljs-property">signedInUser</span>!.<span class="hljs-property">userName</span>),
          <span class="hljs-attr">subtitle</span>: <span class="hljs-title class_">Text</span>(sessionManager.<span class="hljs-property">signedInUser</span>!.<span class="hljs-property">email</span> ?? <span class="hljs-string">''</span>),
        ),
        <span class="hljs-title class_">Padding</span>(
          <span class="hljs-attr">padding</span>: <span class="hljs-keyword">const</span> <span class="hljs-title class_">EdgeInsets</span>.<span class="hljs-title function_">all</span>(<span class="hljs-number">16</span>),
          <span class="hljs-attr">child</span>: <span class="hljs-title class_">ElevatedButton</span>(
            <span class="hljs-attr">onPressed</span>: () {
              sessionManager.<span class="hljs-title function_">signOut</span>();
            },
            <span class="hljs-attr">child</span>: <span class="hljs-keyword">const</span> <span class="hljs-title class_">Text</span>(<span class="hljs-string">'로그아웃'</span>),
          ),
        ),
      ],
    );
  }
}
</code></pre>
<p>UserInfo 객체를 사용하여 사용자의 이름과 이메일을 가져와 UI에 표시할 수 있어요. 또한 사용자가 Sign out 버튼을 누르면 sessionManager.signOut();이 호출되어 응용프로그램에서 로그아웃할 수 있어요.</p>
<p>이제 사용자가 로그인한 경우 AccountPage를 표시해야 해요. 사용자가 로그인했는지 여부에 따라 로그인 페이지와 계정 페이지를 전환하기 위해 main.dart 파일을 수정하고 build 메서드 내에서 const SignInPage()를 이 코드로 바꿔주세요:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">sessionManager.<span class="hljs-property">isSignedIn</span> ? <span class="hljs-keyword">const</span> <span class="hljs-title class_">AccountPage</span>() : <span class="hljs-keyword">const</span> <span class="hljs-title class_">SignInPage</span>(),
</code></pre>
<p>사용자가 로그인한 경우 AccountPage()를 렌더링하고, 로그인되지 않은 경우 SignInPage()를 렌더링합니다.</p>
<p>세션 상태 변경에 따라 사용자 인터페이스를 업데이트하려면 main.dart의 MyHomePageState 내에 다음 코드를 추가해야 합니다.</p>
<pre><code class="hljs language-js">@override
<span class="hljs-keyword">void</span> <span class="hljs-title function_">initState</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">initState</span>();

  <span class="hljs-comment">// 로그인 상태 변경 시 페이지를 다시 빌드하도록 합니다.</span>
  sessionManager.<span class="hljs-title function_">addListener</span>(() {
    <span class="hljs-title function_">setState</span>(() {});
  });
}
</code></pre>
<div class="content-ad"></div>
<p>이 코드는 sessionManager에 리스너를 설정하여 세션 상태 변경 시 페이지를 다시 빌드합니다. 이렇게 함으로써 사용자가 로그인했는지 여부에 따라 앱이 사용자 인터페이스를 업데이트할 수 있도록 합니다.</p>
<p>전체 클래스는 다음과 같이 보여야 합니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyHomePageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">State</span>&#x3C;<span class="hljs-title class_">MyHomePage</span>> {
  @override
  <span class="hljs-keyword">void</span> <span class="hljs-title function_">initState</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">initState</span>();

    <span class="hljs-comment">// 사용자 로그인 상태 변경 시 페이지 다시 빌드하도록 설정</span>
    sessionManager.<span class="hljs-title function_">addListener</span>(() {
      <span class="hljs-title function_">setState</span>(() {});
    });
  }

  @override
  <span class="hljs-title class_">Widget</span> <span class="hljs-title function_">build</span>(<span class="hljs-params">BuildContext context</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Scaffold</span>(
      <span class="hljs-attr">appBar</span>: <span class="hljs-title class_">AppBar</span>(
        <span class="hljs-attr">title</span>: <span class="hljs-title class_">Text</span>(widget.<span class="hljs-property">title</span>),
      ),
      <span class="hljs-attr">body</span>:
          sessionManager.<span class="hljs-property">isSignedIn</span> ? <span class="hljs-keyword">const</span> <span class="hljs-title class_">AccountPage</span>() : <span class="hljs-keyword">const</span> <span class="hljs-title class_">SignInPage</span>(),
    );
  }
}
</code></pre>
<p>이러한 변경 사항을 통해 사용자가 로그인하지 않은 경우 로그인 페이지가 표시되고, 로그인한 경우 사용자 계정 페이지가 표시됩니다.</p>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-06-21-GettingStartedwithServerpodAuthenticationPart1_11.png" alt="2024-06-21-GettingStartedwithServerpodAuthenticationPart1_11"></p>
<p>이제 직접 해보세요! 이제 데이터베이스에 사용자 데이터가 저장되는 완전한 기능을 갖춘 가입 및 로그인 흐름이 구현되었습니다! 마지막 단계는 이제까지 연기해 왔던 메일 서버 통합입니다.</p>
<h1>메일 서버 통합</h1>
<p>인증 코드와 비밀번호 재설정 링크를 보내기 위해 앱을 외부 메일 서버와 통합해야 합니다. SendGrid, Mailjet 등 여러 옵션이 있지만, 이 튜토리얼의 목적을 위해 Gmail을 메일 서버로 사용할 것입니다.</p>
<div class="content-ad"></div>
<p>프로덕션 앱에는 좋지 않은 솔루션이라는 것을 알아두는 것이 중요합니다. 앱에서 Gmail을 사용하여 이메일을 보내면 전달 문제가 발생할 수 있습니다. 스팸으로 지목당하거나 계정이 제한될 수도 있습니다. 프로덕션 앱에 대해서는 전문적인 이메일 서비스를 사용하는 것을 강력히 권장합니다.</p>
<p>그렇다면, 이제 Gmail을 사용하여 앱을 통합해 봅시다.</p>
<p>먼저, 서버 프로젝트에 mailer 패키지를 추가해야 합니다. 터미널에서 다음 명령을 실행하여 이 작업을 수행할 수 있습니다:</p>
<pre><code class="hljs language-js">dart pub add mailer
</code></pre>
<div class="content-ad"></div>
<p>다음으로, 이메일을 보내는 데 사용할 Gmail 계정을 설정해야 합니다. Gmail 계정이 없는 경우 무료로 하나 만들 수 있습니다. <a href="https://accounts.google.com/signup" rel="nofollow" target="_blank">https://accounts.google.com/signup</a> 에서 만들어보세요.</p>
<p>Gmail 계정을 만든 후 다음 단계를 따르세요:</p>
<ul>
<li>Google 계정 보안 페이지로 이동합니다.</li>
<li>"Google에 로그인하는 방법" 아래에서 "2단계 인증"을 켭니다.</li>
<li>계정에 2단계 인증을 설정하기 위해 안내에 따라 진행합니다. 확인 코드를 받을 전화번호를 제공해야 합니다.</li>
<li>2단계 인증을 설정한 후, 계정용 앱 비밀번호를 만듭니다. 이 비밀번호는 우리 앱이 이메일을 보내는 데 사용할 것입니다.</li>
</ul>
<img src="/assets/img/2024-06-21-GettingStartedwithServerpodAuthenticationPart1_12.png">
<div class="content-ad"></div>
<img src="/assets/img/2024-06-21-GettingStartedwithServerpodAuthenticationPart1_13.png">
<p>이제 서버팟 프로젝트의 passwords 파일에 암호를 추가해 보겠습니다. 이 파일은 config/passwords.yaml 경로에 있습니다. 여기서 주의할 점은 이 파일을 버전 관리에 저장하지 마십시오. 실제로 서버팟 프로젝트는 이 파일을 .gitignore에 추가하여 사전 구성되어 있습니다. 대신에 항상 프로젝트 외부에서 비밀을 관리하고, 프로덕션 배포 시에는 CI/CD 파이프라인의 비밀 변수로 유지하십시오.</p>
<p>key/valuesgmailEmail 및 gmailPassword를 추가하세요.</p>
<pre><code class="hljs language-js"># 이들은 개발 모드에서 로컬 서버를 실행할 때 사용되는 암호입니다.
<span class="hljs-attr">development</span>:
  <span class="hljs-attr">database</span>: <span class="hljs-string">'9S8rYW7XeIA8bmGY9FBzOSLwQZtQEFNr'</span>
  <span class="hljs-attr">redis</span>: <span class="hljs-string">'V7YogaG9K2rnIpS1odXIKrqsW8kkfddt'</span>
  <span class="hljs-attr">gmailEmail</span>: <span class="hljs-string">'&#x3C;your gmail email>'</span>
  <span class="hljs-attr">gmailPassword</span>: <span class="hljs-string">'&#x3C;your gmail key>'</span>

  # 서비스 비밀은 서버 간 통신 및 서비스 프로토콜에 액세스하는 데 사용됩니다.
  <span class="hljs-attr">serviceSecret</span>: <span class="hljs-string">'IWtaP1Z-Db-F70IBJpWGf3D7x9F3AYGg'</span>
</code></pre>
<div class="content-ad"></div>
<p>우리는 비밀번호 파일에 키를 추가하여 나중에 코드에서 쉽게 가져와 사용할 수 있습니다. 이렇게 하면 서버에 시크릿을 삽입하는 편리한 방법입니다.</p>
<p>이제 Gmail 계정과 설정한 시크릿이 준비되었으니, 이메일로 validationCode를 보내는 로직을 구현할 수 있습니다. 이를 위해 이전에 서버 프로젝트 내 server.dart에 만들어둔 AuthConfig를 수정해야 합니다.</p>
<p>먼저, session.serverpod 객체에서 getPassword 함수를 호출하여 Gmail SMTP 서버의 자격 증명을 가져옵니다. 이 함수는 이전 단계에서 추가한 시크릿을 가져올 것입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 자격 증명 가져오기</span>
final gmailEmail = session.<span class="hljs-property">serverpod</span>.<span class="hljs-title function_">getPassword</span>(<span class="hljs-string">'gmailEmail'</span>)!;
final gmailPassword = session.<span class="hljs-property">serverpod</span>.<span class="hljs-title function_">getPassword</span>(<span class="hljs-string">'gmailPassword'</span>)!;
</code></pre>
<div class="content-ad"></div>
<p>그럼, 우리는 검색한 이메일과 비밀번호를 사용하여 Gmail용 SMTP 클라이언트를 생성합니다:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// Gmail용 SMTP 클라이언트 생성</span>
final smtpServer = <span class="hljs-title function_">gmail</span>(gmailEmail, gmailPassword);
</code></pre>
<p>그런 다음, 유효성 코드를 사용하여 이메일 메시지를 만듭니다:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 검증 코드를 포함한 이메일 메시지 생성</span>
final message = <span class="hljs-title class_">Message</span>()
  ..<span class="hljs-property">from</span> = <span class="hljs-title class_">Address</span>(gmailEmail)
  ..<span class="hljs-property">recipients</span>.<span class="hljs-title function_">add</span>(email)
  ..<span class="hljs-property">subject</span> = <span class="hljs-string">'Serverpod를 위한 검증 코드'</span>
  ..<span class="hljs-property">html</span> = <span class="hljs-string">'귀하의 검증 코드는 다음과 같습니다: $validationCode'</span>;
</code></pre>
<div class="content-ad"></div>
<p>마지막으로, mailer 패키지의 send 함수를 사용하여 이메일 메시지를 전송하는 시도를 합니다. 이메일 전송에 실패하면 false를 반환합니다:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 이메일 메시지를 전송합니다.</span>
<span class="hljs-keyword">try</span> {
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">send</span>(message, smtpServer);
} <span class="hljs-keyword">catch</span> (_) {
  <span class="hljs-comment">// 이메일 전송에 실패한 경우 false를 반환합니다.</span>
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}

<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
</code></pre>
<p>모든 코드를 한데 모아서 sendValidationEmail 및 sendPasswordResetEmail을 구현할 때 아래와 같이 코드가 보여야 합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 이메일로 로그인하는 경우의 구성.</span>
auth.<span class="hljs-property">AuthConfig</span>.<span class="hljs-title function_">set</span>(auth.<span class="hljs-title class_">AuthConfig</span>(
  <span class="hljs-attr">sendValidationEmail</span>: (session, email, validationCode) <span class="hljs-keyword">async</span> {
    <span class="hljs-comment">// 자격 증명 가져오기</span>
    final gmailEmail = session.<span class="hljs-property">serverpod</span>.<span class="hljs-title function_">getPassword</span>(<span class="hljs-string">'gmailEmail'</span>)!;
    final gmailPassword = session.<span class="hljs-property">serverpod</span>.<span class="hljs-title function_">getPassword</span>(<span class="hljs-string">'gmailPassword'</span>)!;

    <span class="hljs-comment">// Gmail용 SMTP 클라이언트 생성</span>
    final smtpServer = <span class="hljs-title function_">gmail</span>(gmailEmail, gmailPassword);

    <span class="hljs-comment">// 검증 코드가 포함된 이메일 메시지 생성</span>
    final message = <span class="hljs-title class_">Message</span>()
      ..<span class="hljs-property">from</span> = <span class="hljs-title class_">Address</span>(gmailEmail)
      ..<span class="hljs-property">recipients</span>.<span class="hljs-title function_">add</span>(email)
      ..<span class="hljs-property">subject</span> = <span class="hljs-string">'Serverpod의 인증 코드'</span>
      ..<span class="hljs-property">html</span> = <span class="hljs-string">'귀하의 인증 코드는 다음과 같습니다: $validationCode'</span>;

    <span class="hljs-comment">// 이메일 메시지 전송</span>
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">await</span> <span class="hljs-title function_">send</span>(message, smtpServer);
    } <span class="hljs-keyword">catch</span> (_) {
      <span class="hljs-comment">// 이메일 전송에 실패한 경우 false를 반환합니다.</span>
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  },
  <span class="hljs-attr">sendPasswordResetEmail</span>: (session, userInfo, validationCode) <span class="hljs-keyword">async</span> {
    <span class="hljs-comment">// 자격 증명 가져오기</span>
    final gmailEmail = session.<span class="hljs-property">serverpod</span>.<span class="hljs-title function_">getPassword</span>(<span class="hljs-string">'gmailEmail'</span>)!;
    final gmailPassword = session.<span class="hljs-property">serverpod</span>.<span class="hljs-title function_">getPassword</span>(<span class="hljs-string">'gmailPassword'</span>)!;

    <span class="hljs-comment">// Gmail용 SMTP 클라이언트 생성</span>
    final smtpServer = <span class="hljs-title function_">gmail</span>(gmailEmail, gmailPassword);

    <span class="hljs-comment">// 비밀번호 재설정 링크가 포함된 이메일 메시지 생성</span>
    final message = <span class="hljs-title class_">Message</span>()
      ..<span class="hljs-property">from</span> = <span class="hljs-title class_">Address</span>(gmailEmail)
      ..<span class="hljs-property">recipients</span>.<span class="hljs-title function_">add</span>(userInfo.<span class="hljs-property">email</span>!)
      ..<span class="hljs-property">subject</span> = <span class="hljs-string">'Serverpod의 비밀번호 재설정 링크'</span>
      ..<span class="hljs-property">html</span> = <span class="hljs-string">'다음은 비밀번호 재설정 코드입니다: $validationCode'</span>;

    <span class="hljs-comment">// 이메일 메시지 전송</span>
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">await</span> <span class="hljs-title function_">send</span>(message, smtpServer);
    } <span class="hljs-keyword">catch</span> (_) {
      <span class="hljs-comment">// 이메일 전송에 실패한 경우 false를 반환합니다.</span>
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  },
));
</code></pre>
<div class="content-ad"></div>
<p>새 변경 사항이 적용되었는지 확인하려면 서버를 다시 시작하는 것을 잊지 마세요. 그러고 나면 테스트해 보는 시간입니다! 새 계정을 만들어서 이메일을 통해 인증 코드를 받는지 확인해 보세요. 모든 것이 기대한 대로 작동한다면, 축하합니다! 이메일 서비스 제공 업체와 Serverpod를 성공적으로 통합했습니다.</p>
<h1>결론</h1>
<p>이 튜토리얼에서는 serverpod_auth_google_flutter를 Flutter 앱과 통합하는 기본 사항을 다뤘습니다. 이를 통해 사용자 계정을 만들고 로그인하고 이메일 주소를 인증할 수 있었습니다. 또한, 메일 서버 통합과 테스트 목적으로 Gmail을 보내는 사람으로 사용하는 mailer 패키지를 간단히 논의했습니다.</p>
<p>다음 시리즈에서는 Google 소셜 로그인을 serverpod_auth_google_flutter와 통합하는 방법에 대해 논의할 것입니다. 이를 통해 사용자가 새로운 계정을 만들 필요 없이 Google 계정으로 로그인하도록 설정하여 사용자가 간편하고 편리하게 가입하고 로그인할 수 있도록 지원할 수 있게 될 것입니다.</p>
<div class="content-ad"></div>
<p>이 시리즈를 마치면 serverpod_auth를 사용하여 플러터 앱에 인증을 통합하는 견고한 기반을 갖추게 될 것입니다. 이를 통해 사용자가 계정을 만들고 로그인하여 안전한 콘텐츠에 액세스할 수 있습니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Serverpod 시작하기 인증  첫 번째 파트","description":"","date":"2024-06-21 21:49","slug":"2024-06-21-GettingStartedwithServerpodAuthenticationPart1","content":"\n## 서버파드에서 이메일 및 비밀번호 인증 구현 단계별 가이드\n\n![이미지](/assets/img/2024-06-21-GettingStartedwithServerpodAuthenticationPart1_0.png)\n\n# 인증 시리즈\n\n부분 1 — 이메일 및 비밀번호 인증\n부분 2 — 구글 인증\n부분 2.5 — 구글 API\n부분 3 — 애플 인증\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 소개\n\n서버포드에서 인증에 관한 시리즈의 제1부에 오신 것을 환영합니다! 본 문서에서는 서버포드 및 플러터 애플리케이션에서 이메일 및 비밀번호 인증을 구현하는 데 초점을 맞춥니다. 이메일 및 비밀번호 인증은 대부분의 애플리케이션에 있어 일반적이고 필수적인 기능으로, 사용자가 계정을 만들고 로그인하여 데이터에 안전하게 접근할 수 있게 합니다.\n\n우리는 서버포드 프로젝트를 생성부터 서버포드 인증 모듈을 설정하는 과정까지 전체 과정을 안내해 드리겠습니다. 또한 서버 측 코드 설정과 제3자 메일 서버와 통합하는 방법, 사용자 인터페이스를 구축하고 서버와 연결하는 방법에 대한 지침도 제공할 것입니다.\n\n본 문서를 마치면 서버포드-플러터 애플리케이션에서 이메일 및 비밀번호 인증을 어떻게 구현하는지에 대한 탄탄한 이해를 갖추게 되며, 향후 시리즈 뒷부분의 추가적인 인증 방법 탐색을 위한 기초가 마련될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 튜토리얼에서 생성하는 완전한 예제 프로젝트는 여기에서 확인할 수 있습니다.\n\n시작해 봅시다!\n\n## 전제 조건\n\nServerpod로 이메일 및 비밀번호 인증을 구현하기 전에 필요한 몇 가지 전제 조건이 있습니다. 이미 Serverpod CLI 및 Docker를 비롯한 필요한 도구를 설치했다고 가정합니다. 아직 이 도구들을 설정하지 않은 경우, 공식 Serverpod 문서를 참고하여 시작하십시오.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n또한, 이 글에서 나중에 생성할 데이터베이스 및 테이블을 검토하기 위해 Postico2, PgAdmin, 또는 DBeaver와 같은 데이터베이스 뷰어를 다운로드하고 설치하는 것을 권장합니다. 선호하는 데이터베이스 뷰어를 사용할 수 있습니다. 이 글에서는 Postico2를 사용할 예정입니다.\n\n# 서버포드 프로젝트 만들기\n\n새로운 서버포드 프로젝트를 생성합니다: 다음 명령을 실행하여 새로운 서버포드 프로젝트를 만듭니다:\n\n```js\nserverpod create my_project\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로젝트 디렉토리로 이동하세요: 프로젝트 내 서버 디렉토리로 작업 디렉토리를 변경하세요:\n\n```js\ncd my_project/my_project_server\n```\n\nWindows 환경에서: 윈도우 환경이라면, 서버팟을 위한 필요한 데이터베이스 테이블을 만들기 위해 설정 중에 이 추가 단계를 수행해야 합니다. 서버 프로젝트 내에서 setup-tables.cmd라는 cmd 파일을 찾을 수 있을 것입니다. 이 스크립트를 실행하세요! 이는 generate/tables-serverpod.pgsql에 위치한 psql 파일을 실행할 것입니다. 리눅스와 맥에서는 프로젝트를 생성할 때 이 단계가 자동으로 수행됩니다.\n\n컨테이너 시작하기: 서버팟 프로젝트에 필요한 Docker 컨테이너를 시작하기 위해 다음 명령을 실행하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ndocker-compose up --build --detach\n```\n\n# 서버팟\\_인증 모듈 설치 및 구성하기\n\n서버팟*인증 모듈은 Serverpod 프로젝트에서 인증을 관리하는 데 필수적인 기능을 제공합니다. 사용자 등록, 로그인, 비밀번호 해싱 및 세션 관리와 같은 기능이 포함되어 있습니다. 이 섹션에서는 서버팟*인증 모듈 설치 및 구성 프로세스를 안내하고 데이터베이스를 업데이트하는 방법을 안내합니다.\n\n## 서버 쪽 설정\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n서버파드 프로젝트(my_project_server)의 pubspec.yaml 파일을 열고 다음 줄을 의존성 섹션 아래에 추가해주세요:\n\n```js\ndependencies:\n  serverpod_auth_server: ^2.0.0\n```\n\n참고: 모든 서버파드 종속성의 버전은 동일해야 합니다! serverpod_auth를 버전 2.0.0으로 추가하는 경우, serverpod와 설치한 다른 서버파드 패키지도 2.0.0이어야 합니다.\n\n버전 2.0 이상인 경우 서버파드 객체에 authenticationHandler를 등록하세요: main.dart 파일에 다음 코드를 추가해주세요. 이 콜백은 클라이언트로부터 수신된 요청을 인증하는 데 사용됩니다. 이전 버전은 이 단계를 완료할 필요가 없습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport 'package:serverpod_auth_server/serverpod_auth_server.dart' as auth;\n\nvoid run(List\u003cString\u003e args) async {\n  var pod = Serverpod(\n    args,\n    Protocol(),\n    Endpoints(),\n    authenticationHandler: auth.authenticationHandler, // 이 줄을 추가하세요\n  );\n\n  await pod.start();\n}\n```\n\n의존성 가져오고 필요한 파일 생성하기: 프로젝트의 루트 디렉토리에서 다음 명령을 실행하여 새로운 종속성을 가져오고 서버 구성에 따라 필요한 파일을 생성하세요:\n\n```js\ndart pub get\nserverpod generate\n```\n\n기존 데이터베이스에 필요한 테이블 업데이트하기: Serverpod auth 모듈에는 모듈이 작동하는 데 필요한 데이터베이스 테이블 세트가 함께 제공됩니다. 이를 생성해봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 Serverpod 버전 1.2 이상을 사용하고 있다면, 마이그레이션 시스템을 사용해야 해요! 다음 명령어로 새 마이그레이션을 만들어보세요:\n\n```js\nserverpod create-migration\n```\n\n그리고 새 마이그레이션을 적용하려면 아래 명령어를 사용하세요:\n\n```js\ndart bin/main.dart --apply-migrations --role=maintenance\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n유지 관리 역할을 설정하면 서버가 부팅되어 데이터베이스에 연결한 후 종료됩니다.\n\n버전 1.1 이하:\n\n- 새 SQL 파일 만들기: 기존 tables-serverpod.pgsql 파일이 있는 폴더에 tables-serverpod-auth.pgsql이라는 새 파일을 만듭니다. 이 파일에는 새 테이블을 생성하는 SQL 코드가 포함될 것입니다.\n- SQL 코드 복사: serverpod_auth 모듈의 테이블을 생성하는 SQL 코드에 액세스하려면 다음 링크를 엽니다: serverpod_auth tables.pgsql. 파일 전체 내용을 복사합니다.\n- SQL 코드를 새 파일에 붙여넣기: 새로 생성된 tables-serverpod-auth.pgsql 파일을 열고 복사한 SQL 코드를 붙여넣습니다.\n- Docker 컨테이너 이름 찾기: `docker ps`를 실행하거나 Docker 대시보드를 확인하여 Docker 컨테이너 이름을 찾습니다. 아래 스크린샷을 참고할 수도 있습니다.\n\n![이미지](/assets/img/2024-06-21-GettingStartedwithServerpodAuthenticationPart1_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n포스트그레SQL 파일을 컨테이너로 복사하고 SQL 코드를 실행하려면 다음 단계를 따르세요: `container_name`을(를) Docker 컨테이너 이름으로 바꿔주세요.\n\n```js\ndocker cp ./tables-serverpod-auth.pgsql \u003ccontainer_name\u003e:/docker-entrypoint-initdb.d/tables-serverpod-auth.pgsql\n\ndocker exec -u postgres \u003ccontainer_name\u003e psql my_project postgres -f /docker-entrypoint-initdb.d/tables-serverpod-auth.pgsql\n```\n\n## 데이터베이스에 Postico 연결하기\n\n시작하려면 Postico2를 열고 \"새 서버\"를 클릭하여 새 연결을 만드세요. 로컬 포스트그레SQL 서버의 연결 세부 정보를 입력해야 합니다. 이 정보는 Serverpod 프로젝트의 config/development.yaml 및 config/passwords.yaml 파일에서 찾을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 Markdown 형식으로 표 태그를 변경한 내용입니다.\n\n![GettingStartedwithServerpodAuthenticationPart1_2](/assets/img/2024-06-21-GettingStartedwithServerpodAuthenticationPart1_2.png)\n\n![GettingStartedwithServerpodAuthenticationPart1_3](/assets/img/2024-06-21-GettingStartedwithServerpodAuthenticationPart1_3.png)\n\n모든 테이블이 성공적으로 생성되었습니다. 다음 단계로 넘어가겠습니다.\n\n## 클라이언트 라이브러리 설정\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n클라이언트 측에서 serverpod_auth 모듈을 사용하려면 클라이언트 프로젝트에 serverpod_auth_client 종속성을 추가해야 합니다.\n\n클라이언트 프로젝트의 pubspec.yaml 파일을 열고 다음 라인을 dependencies 섹션 아래에 추가하세요:\n\n```js\ndependencies:\n  ...\n  serverpod_auth_client: ^2.0.0\n```\n\n이 패키지에는 서버로 이메일 및 비밀번호 인증을 위한 API 호출을 만들기 위해 필요한 클라이언트 측 라이브러리 코드가 포함되어 있습니다. serverpod_auth_email_flutter가 제공하는 미리 빌드된 UI 구성 요소를 사용 중이라면 해당 종속성은 엄격히 필요하지는 않지만 모든 생성된 인증 엔드포인트가 포함되어 있어 상호 작용할 수 있으므로 여기에 추가하는 것이 좋습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 플러터 앱 설정\n\nServerpod를 사용하여 이메일 및 비밀번호 인증에 필요한 서버 측 변경 사항을 구현한 후, 다음 단계는 Flutter 앱과 통합하는 것입니다. 다행히도 Serverpod는 이 프로세스를 가능한한 원활하게 만들기 위해 미리 구축된 UI 컴포넌트를 제공합니다.\n\n먼저, Flutter 앱에 필요한 클라이언트 측 종속성을 추가해야 합니다. Serverpod 프로젝트(my_project_flutter)의 pubspec.yaml 파일을 열고 다음과 같은 라인을 dependencies 섹션 아래 추가해주세요:\n\n```js\ndependencies:\n  ...\n  serverpod_auth_email_flutter: ^2.0.0\n  serverpod_auth_shared_flutter: ^2.0.0\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\npubspec.yaml 파일에 필요한 종속성을 추가한 후에는 터미널에서 flutter pub get을 실행하여 종속성을 업데이트해야 합니다.\n\n이러한 패키지에는 사전 제작된 UI 구성 요소 및 서버 통합을 최대한 간단하게 만드는 기타 도구가 포함되어 있습니다. 그러나 자체 UI 구성 요소를 만들기를 선호하는 경우, 생성된 클라이언트 라이브러리와 통합할 수 있고 이 경우에는 이러한 종속성이 필요하지 않습니다.\n\n# 서버 시작 및 클라이언트 실행\n\n축하합니다! 이제 모든 필요한 종속성이 설정된 프로젝트가 있습니다. 다음으로 진행하기 전에 모든 것이 올바르게 작동하는지 확인해 봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n서버를 시작하려면 터미널에서 my_project_server 디렉토리로 이동한 다음 다음 명령어를 실행하세요:\n\n```js\ncd my_project_server\ndart bin/main.dart\n```\n\n\u003cimg src=\"/assets/img/2024-06-21-GettingStartedwithServerpodAuthenticationPart1_4.png\" /\u003e\n\n다음으로, 새 터미널 창에서 my_project_flutter 디렉토리로 이동한 다음 다음 명령어를 실행하여 Flutter 앱을 시작하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ncd my_project_flutter\nflutter run\n```\n\n크롬에서 실행하여 메시지를 보내는 테스트를 선택하세요!\n\n\u003cimg src=\"/assets/img/2024-06-21-GettingStartedwithServerpodAuthenticationPart1_5.png\" /\u003e\n\n## 문제 해결\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제가 발생하면 문제를 진단하는 데 도움이 되는 몇 가지를 확인할 수 있습니다:\n\n- 이 가이드의 이전 단계를 모두 올바르게 따랐는지 확인하세요.\n- 서버가 오류 없이 실행 중인지 확인하세요. 오류가 있으면 서버를 시작한 터미널에 표시됩니다.\n- 필요한 데이터베이스 테이블이 모두 생성되었는지 확인하세요. 이를 확인하려면 Postgres나 pgAdmin과 같은 도구를 사용하여 데이터베이스에 연결하고 public 스키마에있는 테이블을 확인하세요. 테이블이 누락 된 경우 해당 테이블을 만들기 위해 SQL 스크립트를 실행했는지 확인하세요.\n- 여전히 문제가 발생하는 경우 앱의 콘솔 또는 로그에서 추가 컨텍스트를 제공 할 수있는 오류 메시지를 확인하세요.\n\n# 이메일/비밀번호 인증 구현\n\n이제 서버와 클라이언트 라이브러리를 설정 했으므로 Flutter 앱에서 인증을 구현할 시간입니다. 이전에 추가 한 serverpod_auth_email_flutter 및 serverpod_auth_shared_flutter 패키지를 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n첫 번째 단계는 Client 및 SessionManager 객체를 초기화하는 것입니다. 먼저 my_project_flutter/lib/src/ 폴더 안에 serverpod_client.dart 파일을 생성해보세요.\n\n```js\nimport 'package:my_project_client/my_project_client.dart';\nimport 'package:serverpod_auth_shared_flutter/serverpod_auth_shared_flutter.dart';\nimport 'package:serverpod_flutter/serverpod_flutter.dart';\n\nlate SessionManager sessionManager;\nlate Client client;\n\nFuture\u003cvoid\u003e initializeServerpodClient() async {\n  // 안드로이드 에뮬레이터는 기본적으로 로컬호스트에 액세스할 수 없습니다.\n  // const ipAddress = '10.0.2.2'; // 호스트에 대한 안드로이드 에뮬레이터 IP 주소\n\n  // 실제 장치에서는 ipAddress를 컴퓨터의 IP 주소로 대체하십시오.\n  const ipAddress = 'localhost';\n\n  // 어플리케이션 어디서든 사용할 수 있는 싱글톤 클라이언트 객체를 설정합니다.\n  // 해당 클라이언트는 서버 코드에서 생성됩니다.\n  // 클라이언트는 로컬 서버의 기본 포트에서 실행 중인 Serverpod에 연결하도록 설정됩니다.\n  // 스테이징이나 프로덕션 서버에 연결하려면 수정해야 합니다.\n  client = Client(\n    'http://$ipAddress:8080/',\n    authenticationKeyManager: FlutterAuthenticationKeyManager(),\n  )..connectivityMonitor = FlutterConnectivityMonitor();\n\n  // 세션 관리자는 사용자의 로그인 상태를 추적합니다.\n  // 사용자가 현재 로그인되어 있는지 확인하고 사용자 정보를 가져올 수 있습니다.\n  sessionManager = SessionManager(\n    caller: client.modules.auth,\n  );\n\n  await sessionManager.initialize();\n}\n```\n\n본 함수는 클라이언트와 서버 간 통신에 사용되는 싱글톤 Client 객체를 설정하고, 사용자의 로그인 상태를 추적하는 SessionManager 객체를 초기화합니다.\n\n이전 단계에서 생성된 Client 객체를 사용하려면 main() 함수에서 싱글톤 인스턴스로 초기화해야 합니다. 이를 위해 main.dart 파일의 main() 함수에서 WidgetsFlutterBinding.ensureInitialized()를 호출하여 Flutter가 완전히 초기화된 후에 SessionManager를 사용할 수 있도록 해야 합니다. 그 후에 방금 만든 initializeServerpodClient() 함수를 호출할 수 있습니다. 마지막으로 runApp() 함수를 호출하여 어플리케이션을 시작할 수 있습니다. 아래는 업데이트된 main() 함수의 예시입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nvoid main() async {\n  // runApp을 호출하기 전에 Flutter 바인딩을 사용하는 SessionManager를 호출해야 합니다.\n  WidgetsFlutterBinding.ensureInitialized();\n\n  await initializeServerpodClient();\n\n  runApp(const MyApp());\n}\n```\n\n다음으로 사용자에게 로그인 양식을 표시할 SignInPage 위젯을 만들겠습니다. 또한 사용자가 성공적으로 로그인한 후에 표시될 AccountPage 위젯도 만들겠습니다.\n\n## SignIn 페이지 생성\n\nFlutter 앱에서 이메일 및 비밀번호 인증을 활성화하기 위해 serverpod_auth_email_flutter 패키지에서 제공하는 SignInWithEmailButton이라는 미리 만들어진 위젯을 사용하여 로그인 페이지를 생성할 것입니다. 이 위젯은 로그인 버튼을 생성하며 로그인 흐름을 처리하는 대화 상자를 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저, Flutter 앱의 lib/src/widgets 폴더에 sign_in_page.dart란 이름의 새 파일을 만들어주세요.\n\n다음으로, StatelessWidget을 확장하는 SignInPage라는 새 클래스를 만들어주세요. 이 클래스는 Dialog 위젯으로 감싸진 로그인 버튼을 반환할 것입니다:\n\n```js\nimport 'package:flutter/material.dart';\nimport 'package:serverpod_auth_email_flutter/serverpod_auth_email_flutter.dart';\nimport 'package:my_project_flutter/src/serverpod_client.dart';\n\nclass SignInPage extends StatelessWidget {\n  const SignInPage({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Dialog(\n        child: Container(\n          width: 260,\n          padding: const EdgeInsets.all(16),\n          child: Column(\n            mainAxisSize: MainAxisSize.min,\n            crossAxisAlignment: CrossAxisAlignment.stretch,\n            children: [\n              SignInWithEmailButton(\n                caller: client.modules.auth,\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n```\n\n위 코드에서, SignInWithEmailButton 위젯은 caller라는 인자를 가져오는데, 이는 Serverpod에서 제공하는 생성된 클라이언트 라이브러리의 인스턴스입니다. 이를 통해 위젯이 Serverpod 서버와 통신할 수 있게 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 홈페이지에 SignInPage 추가하기\n\n앱의 홈페이지에 SignInPage를 추가하려면 lib/ 폴더의 루트에 위치한 main.dart 파일 내에 정의된 MyHomePage 클래스를 수정해야 합니다.\n\n기존의 MyHomePage 클래스를 다음 코드로 변경하세요. 이 클래스 아래에 있는 내용은 모두 제거해도 됩니다.\n\n```js\nclass MyHomePageState extends State\u003cMyHomePage\u003e {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(widget.title),\n      ),\n      body: const SignInPage(),\n    );\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n잊지 말고 SignInPage 위젯에 대한 import 문을 추가해주세요:\n\n```js\nimport \"package:my_project_flutter/src/widgets/sign_in_page.dart\";\n```\n\n전체 main.dart 파일은 다음과 같이 보여야 합니다:\n\n```js\nimport 'package:my_project_flutter/src/serverpod_client.dart';\nimport 'package:my_project_flutter/src/widgets/sign_in_page.dart';\nimport 'package:flutter/material.dart';\n\nvoid main() async {\n  // runApp을 호출하기 전에 Flutter 바인딩을 사용하는 SessionManager를 초기화해야 합니다.\n  WidgetsFlutterBinding.ensureInitialized();\n\n  await initializeServerpodClient();\n\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Serverpod demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: const MyHomePage(title: 'Serverpod Example'),\n    );\n  }\n}\n\nclass MyHomePage extends StatefulWidget {\n  const MyHomePage({Key? key, required this.title}) : super(key: key);\n\n  final String title;\n\n  @override\n  MyHomePageState createState() =\u003e MyHomePageState();\n}\n\nclass MyHomePageState extends State\u003cMyHomePage\u003e {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(widget.title),\n      ),\n      body: const SignInPage()\n    );\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앱을 새로고침하면 이제 로그인 버튼을 볼 수 있어요! 아직 끝나지 않았지만 실제로 서버와 통신할 수 있어야 해요!\n\n![이미지](/assets/img/2024-06-21-GettingStartedwithServerpodAuthenticationPart1_6.png)\n\n이제 우리 앱의 홈 페이지에 로그인 페이지를 통합했고 계정을 생성할 수 있어요. 그러나 로그인 프로세스를 완료하기 위해 서버에서 전송된 인증 코드가 필요해요. 계정 등록을 위해 사용자는 회원 가입 페이지의 필수 필드를 작성하고 양식을 제출할 수 있어요. 제출하면 서버가 제공된 이메일 주소로 인증 코드를 보내줄 거에요. 현재 우리는 인증 코드에 액세스하지 못하므로 로그인 프로세스를 아직 완료할 수 없어요. 이 문제를 해결해 봐요!\n\n## 이메일 인증 콜백 통합하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n회원 가입 프로세스를 완료하려면 검증 이메일을 보내는 콜백을 추가해야 합니다. Serverpod은 회원 가입을 위한 검증 코드 및 비밀번호 재설정을 위한 메일을 보내는 데 유용한 몇 가지 콜백을 제공합니다. 지금은 콘솔에 코드를 출력하여 기능을 테스트하기 위한 빠르고 간단한 솔루션을 구현해 봅시다.\n\n서버 프로젝트의 server.dart 파일에 다음 구성을 추가하여 콜백을 설정할 수 있습니다:\n\n```js\nimport 'package:serverpod_auth_server/module.dart' as auth;\n\nvoid run(List\u003cString\u003e args) async {\n  ...\n  auth.AuthConfig.set(auth.AuthConfig(\n    sendValidationEmail: (session, email, validationCode) async {\n      // TODO: 메일 서버와 연동\n      print('검증 코드: $validationCode');\n      return true;\n    },\n    sendPasswordResetEmail: (session, userInfo, validationCode) async {\n      // TODO: 메일 서버와 연동\n      print('검증 코드: $validationCode');\n      return true;\n    },\n  ));\n\n  ...\n  await pod.start();\n}\n```\n\nrun() 메서드 내에서 pod.start()를 호출하기 전에 이 코드를 추가하여 콜백이 제대로 설정되도록 해줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위에 바꾼 사항들이 적용되도록 하려면 Serverpod 서버를 다시 시작해야 합니다. 서버를 시작한 터미널로 이동하여 \"CTRL + C\"를 눌러 중지한 후, \"dart bin/main.dart\"를 실행하여 서버를 다시 시작합니다.\n\n지금 테스트해 봅시다!\n\n로그인 버튼을 생성하고 정보를 입력해 봅시다!\n\n![이미지](/assets/img/2024-06-21-GettingStartedwithServerpodAuthenticationPart1_7.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금은 이메일을 받지 않을 거에요. 대신에 서버를 실행한 터미널에서 확인 코드를 찾아보셔야 해요.\n\n마크다운(Markdown) 형식으로 테이블 태그를 변경해주세요.\n\n![이미지 1](/assets/img/2024-06-21-GettingStartedwithServerpodAuthenticationPart1_8.png)\n\n![이미지 2](/assets/img/2024-06-21-GettingStartedwithServerpodAuthenticationPart1_9.png)\n\n# 데이터베이스에서 사용자 생성 확인\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 어플리케이션에 가입 기능을 설정했으니, 사용자 데이터가 데이터베이스에 올바르게 저장되는지 확인해야 합니다. 아직 Flutter 앱에서 사용자 페이지를 구현하지 않았으므로 Postico2를 사용하여 사용자 생성을 확인할 수 있습니다.\n\nPostico2를 열고 이전에 설정 섹션에서 한 것과 같이 데이터베이스에 연결하십시오. 데이터베이스에 연결한 후 'serverpod_user_info' 테이블을 클릭하십시오. 방금 생성한 사용자를 확인할 수 있어야 합니다.\n\n\u003cimg src=\"/assets/img/2024-06-21-GettingStartedwithServerpodAuthenticationPart1_10.png\" /\u003e\n\n# 계정 페이지 구현\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금 로그인 페이지가 작동되고 있다면, 이제 계정 페이지를 구현해 보겠습니다. 이 페이지는 현재 로그인한 사용자에 대한 정보를 보여줄 것입니다. 이를 위해 이전에 만들었던 SessionManager 객체를 사용할 것입니다. SessionManager는 사용자의 로그인 상태를 추적하고 사용자에 대한 정보에 액세스할 수 있는 기능을 제공합니다.\n\nSessionManager가 제공하는 일부 함수를 살펴보겠습니다:\n\n- isSignedIn(): 이 함수는 사용자가 현재 로그인되어 있는 경우 true를 반환하고 그렇지 않으면 false를 반환합니다.\n- getSignedInUser(): 이 함수는 현재 로그인한 사용자에 대한 정보(이메일 주소 및 표시 이름과 같은)가 포함된 UserInfo 유형의 객체를 반환합니다.\n- signOut(): 이 함수는 사용자를 로그아웃하고 인증 상태를 지웁니다.\n\nCircularUserImage 위젯은 Serverpod 프레임워크가 제공하는 사전 제작된 위젯으로, UserInfo 객체를 입력으로 받아서 원형 프로필 이미지를 표시합니다. sessionManager와 이 위젯을 조합하여 멋진 디자인의 계정 페이지를 만들 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nlib/src/widgets 디렉토리 안에 account_page.dart라는 새 파일을 만들고 다음 코드를 추가할 거에요:\n\n```js\nimport 'package:flutter/material.dart';\nimport 'package:serverpod_auth_shared_flutter/serverpod_auth_shared_flutter.dart';\n\nimport 'package:my_project_flutter/src/serverpod_client.dart';\n\nclass AccountPage extends StatelessWidget {\n  const AccountPage({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return ListView(\n      children: [\n        ListTile(\n          contentPadding:\n              const EdgeInsets.symmetric(vertical: 8, horizontal: 16),\n          leading: CircularUserImage(\n            userInfo: sessionManager.signedInUser,\n            size: 42,\n          ),\n          title: Text(sessionManager.signedInUser!.userName),\n          subtitle: Text(sessionManager.signedInUser!.email ?? ''),\n        ),\n        Padding(\n          padding: const EdgeInsets.all(16),\n          child: ElevatedButton(\n            onPressed: () {\n              sessionManager.signOut();\n            },\n            child: const Text('로그아웃'),\n          ),\n        ),\n      ],\n    );\n  }\n}\n```\n\nUserInfo 객체를 사용하여 사용자의 이름과 이메일을 가져와 UI에 표시할 수 있어요. 또한 사용자가 Sign out 버튼을 누르면 sessionManager.signOut();이 호출되어 응용프로그램에서 로그아웃할 수 있어요.\n\n이제 사용자가 로그인한 경우 AccountPage를 표시해야 해요. 사용자가 로그인했는지 여부에 따라 로그인 페이지와 계정 페이지를 전환하기 위해 main.dart 파일을 수정하고 build 메서드 내에서 const SignInPage()를 이 코드로 바꿔주세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nsessionManager.isSignedIn ? const AccountPage() : const SignInPage(),\n```\n\n사용자가 로그인한 경우 AccountPage()를 렌더링하고, 로그인되지 않은 경우 SignInPage()를 렌더링합니다.\n\n세션 상태 변경에 따라 사용자 인터페이스를 업데이트하려면 main.dart의 MyHomePageState 내에 다음 코드를 추가해야 합니다.\n\n```js\n@override\nvoid initState() {\n  super.initState();\n\n  // 로그인 상태 변경 시 페이지를 다시 빌드하도록 합니다.\n  sessionManager.addListener(() {\n    setState(() {});\n  });\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 코드는 sessionManager에 리스너를 설정하여 세션 상태 변경 시 페이지를 다시 빌드합니다. 이렇게 함으로써 사용자가 로그인했는지 여부에 따라 앱이 사용자 인터페이스를 업데이트할 수 있도록 합니다.\n\n전체 클래스는 다음과 같이 보여야 합니다:\n\n```js\nclass MyHomePageState extends State\u003cMyHomePage\u003e {\n  @override\n  void initState() {\n    super.initState();\n\n    // 사용자 로그인 상태 변경 시 페이지 다시 빌드하도록 설정\n    sessionManager.addListener(() {\n      setState(() {});\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(widget.title),\n      ),\n      body:\n          sessionManager.isSignedIn ? const AccountPage() : const SignInPage(),\n    );\n  }\n}\n```\n\n이러한 변경 사항을 통해 사용자가 로그인하지 않은 경우 로그인 페이지가 표시되고, 로그인한 경우 사용자 계정 페이지가 표시됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![2024-06-21-GettingStartedwithServerpodAuthenticationPart1_11](/assets/img/2024-06-21-GettingStartedwithServerpodAuthenticationPart1_11.png)\n\n이제 직접 해보세요! 이제 데이터베이스에 사용자 데이터가 저장되는 완전한 기능을 갖춘 가입 및 로그인 흐름이 구현되었습니다! 마지막 단계는 이제까지 연기해 왔던 메일 서버 통합입니다.\n\n# 메일 서버 통합\n\n인증 코드와 비밀번호 재설정 링크를 보내기 위해 앱을 외부 메일 서버와 통합해야 합니다. SendGrid, Mailjet 등 여러 옵션이 있지만, 이 튜토리얼의 목적을 위해 Gmail을 메일 서버로 사용할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로덕션 앱에는 좋지 않은 솔루션이라는 것을 알아두는 것이 중요합니다. 앱에서 Gmail을 사용하여 이메일을 보내면 전달 문제가 발생할 수 있습니다. 스팸으로 지목당하거나 계정이 제한될 수도 있습니다. 프로덕션 앱에 대해서는 전문적인 이메일 서비스를 사용하는 것을 강력히 권장합니다.\n\n그렇다면, 이제 Gmail을 사용하여 앱을 통합해 봅시다.\n\n먼저, 서버 프로젝트에 mailer 패키지를 추가해야 합니다. 터미널에서 다음 명령을 실행하여 이 작업을 수행할 수 있습니다:\n\n```js\ndart pub add mailer\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음으로, 이메일을 보내는 데 사용할 Gmail 계정을 설정해야 합니다. Gmail 계정이 없는 경우 무료로 하나 만들 수 있습니다. https://accounts.google.com/signup 에서 만들어보세요.\n\nGmail 계정을 만든 후 다음 단계를 따르세요:\n\n- Google 계정 보안 페이지로 이동합니다.\n- \"Google에 로그인하는 방법\" 아래에서 \"2단계 인증\"을 켭니다.\n- 계정에 2단계 인증을 설정하기 위해 안내에 따라 진행합니다. 확인 코드를 받을 전화번호를 제공해야 합니다.\n- 2단계 인증을 설정한 후, 계정용 앱 비밀번호를 만듭니다. 이 비밀번호는 우리 앱이 이메일을 보내는 데 사용할 것입니다.\n\n\u003cimg src=\"/assets/img/2024-06-21-GettingStartedwithServerpodAuthenticationPart1_12.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-21-GettingStartedwithServerpodAuthenticationPart1_13.png\" /\u003e\n\n이제 서버팟 프로젝트의 passwords 파일에 암호를 추가해 보겠습니다. 이 파일은 config/passwords.yaml 경로에 있습니다. 여기서 주의할 점은 이 파일을 버전 관리에 저장하지 마십시오. 실제로 서버팟 프로젝트는 이 파일을 .gitignore에 추가하여 사전 구성되어 있습니다. 대신에 항상 프로젝트 외부에서 비밀을 관리하고, 프로덕션 배포 시에는 CI/CD 파이프라인의 비밀 변수로 유지하십시오.\n\nkey/valuesgmailEmail 및 gmailPassword를 추가하세요.\n\n```js\n# 이들은 개발 모드에서 로컬 서버를 실행할 때 사용되는 암호입니다.\ndevelopment:\n  database: '9S8rYW7XeIA8bmGY9FBzOSLwQZtQEFNr'\n  redis: 'V7YogaG9K2rnIpS1odXIKrqsW8kkfddt'\n  gmailEmail: '\u003cyour gmail email\u003e'\n  gmailPassword: '\u003cyour gmail key\u003e'\n\n  # 서비스 비밀은 서버 간 통신 및 서비스 프로토콜에 액세스하는 데 사용됩니다.\n  serviceSecret: 'IWtaP1Z-Db-F70IBJpWGf3D7x9F3AYGg'\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 비밀번호 파일에 키를 추가하여 나중에 코드에서 쉽게 가져와 사용할 수 있습니다. 이렇게 하면 서버에 시크릿을 삽입하는 편리한 방법입니다.\n\n이제 Gmail 계정과 설정한 시크릿이 준비되었으니, 이메일로 validationCode를 보내는 로직을 구현할 수 있습니다. 이를 위해 이전에 서버 프로젝트 내 server.dart에 만들어둔 AuthConfig를 수정해야 합니다.\n\n먼저, session.serverpod 객체에서 getPassword 함수를 호출하여 Gmail SMTP 서버의 자격 증명을 가져옵니다. 이 함수는 이전 단계에서 추가한 시크릿을 가져올 것입니다.\n\n```js\n// 자격 증명 가져오기\nfinal gmailEmail = session.serverpod.getPassword('gmailEmail')!;\nfinal gmailPassword = session.serverpod.getPassword('gmailPassword')!;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그럼, 우리는 검색한 이메일과 비밀번호를 사용하여 Gmail용 SMTP 클라이언트를 생성합니다:\n\n```js\n// Gmail용 SMTP 클라이언트 생성\nfinal smtpServer = gmail(gmailEmail, gmailPassword);\n```\n\n그런 다음, 유효성 코드를 사용하여 이메일 메시지를 만듭니다:\n\n```js\n// 검증 코드를 포함한 이메일 메시지 생성\nfinal message = Message()\n  ..from = Address(gmailEmail)\n  ..recipients.add(email)\n  ..subject = 'Serverpod를 위한 검증 코드'\n  ..html = '귀하의 검증 코드는 다음과 같습니다: $validationCode';\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마지막으로, mailer 패키지의 send 함수를 사용하여 이메일 메시지를 전송하는 시도를 합니다. 이메일 전송에 실패하면 false를 반환합니다:\n\n```js\n// 이메일 메시지를 전송합니다.\ntry {\n  await send(message, smtpServer);\n} catch (_) {\n  // 이메일 전송에 실패한 경우 false를 반환합니다.\n  return false;\n}\n\nreturn true;\n```\n\n모든 코드를 한데 모아서 sendValidationEmail 및 sendPasswordResetEmail을 구현할 때 아래와 같이 코드가 보여야 합니다.\n\n```js\n// 이메일로 로그인하는 경우의 구성.\nauth.AuthConfig.set(auth.AuthConfig(\n  sendValidationEmail: (session, email, validationCode) async {\n    // 자격 증명 가져오기\n    final gmailEmail = session.serverpod.getPassword('gmailEmail')!;\n    final gmailPassword = session.serverpod.getPassword('gmailPassword')!;\n\n    // Gmail용 SMTP 클라이언트 생성\n    final smtpServer = gmail(gmailEmail, gmailPassword);\n\n    // 검증 코드가 포함된 이메일 메시지 생성\n    final message = Message()\n      ..from = Address(gmailEmail)\n      ..recipients.add(email)\n      ..subject = 'Serverpod의 인증 코드'\n      ..html = '귀하의 인증 코드는 다음과 같습니다: $validationCode';\n\n    // 이메일 메시지 전송\n    try {\n      await send(message, smtpServer);\n    } catch (_) {\n      // 이메일 전송에 실패한 경우 false를 반환합니다.\n      return false;\n    }\n\n    return true;\n  },\n  sendPasswordResetEmail: (session, userInfo, validationCode) async {\n    // 자격 증명 가져오기\n    final gmailEmail = session.serverpod.getPassword('gmailEmail')!;\n    final gmailPassword = session.serverpod.getPassword('gmailPassword')!;\n\n    // Gmail용 SMTP 클라이언트 생성\n    final smtpServer = gmail(gmailEmail, gmailPassword);\n\n    // 비밀번호 재설정 링크가 포함된 이메일 메시지 생성\n    final message = Message()\n      ..from = Address(gmailEmail)\n      ..recipients.add(userInfo.email!)\n      ..subject = 'Serverpod의 비밀번호 재설정 링크'\n      ..html = '다음은 비밀번호 재설정 코드입니다: $validationCode';\n\n    // 이메일 메시지 전송\n    try {\n      await send(message, smtpServer);\n    } catch (_) {\n      // 이메일 전송에 실패한 경우 false를 반환합니다.\n      return false;\n    }\n\n    return true;\n  },\n));\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n새 변경 사항이 적용되었는지 확인하려면 서버를 다시 시작하는 것을 잊지 마세요. 그러고 나면 테스트해 보는 시간입니다! 새 계정을 만들어서 이메일을 통해 인증 코드를 받는지 확인해 보세요. 모든 것이 기대한 대로 작동한다면, 축하합니다! 이메일 서비스 제공 업체와 Serverpod를 성공적으로 통합했습니다.\n\n# 결론\n\n이 튜토리얼에서는 serverpod_auth_google_flutter를 Flutter 앱과 통합하는 기본 사항을 다뤘습니다. 이를 통해 사용자 계정을 만들고 로그인하고 이메일 주소를 인증할 수 있었습니다. 또한, 메일 서버 통합과 테스트 목적으로 Gmail을 보내는 사람으로 사용하는 mailer 패키지를 간단히 논의했습니다.\n\n다음 시리즈에서는 Google 소셜 로그인을 serverpod_auth_google_flutter와 통합하는 방법에 대해 논의할 것입니다. 이를 통해 사용자가 새로운 계정을 만들 필요 없이 Google 계정으로 로그인하도록 설정하여 사용자가 간편하고 편리하게 가입하고 로그인할 수 있도록 지원할 수 있게 될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 시리즈를 마치면 serverpod_auth를 사용하여 플러터 앱에 인증을 통합하는 견고한 기반을 갖추게 될 것입니다. 이를 통해 사용자가 계정을 만들고 로그인하여 안전한 콘텐츠에 액세스할 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-21-GettingStartedwithServerpodAuthenticationPart1_0.png"},"coverImage":"/assets/img/2024-06-21-GettingStartedwithServerpodAuthenticationPart1_0.png","tag":["Tech"],"readingTime":24},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003e서버파드에서 이메일 및 비밀번호 인증 구현 단계별 가이드\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-GettingStartedwithServerpodAuthenticationPart1_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch1\u003e인증 시리즈\u003c/h1\u003e\n\u003cp\u003e부분 1 — 이메일 및 비밀번호 인증\n부분 2 — 구글 인증\n부분 2.5 — 구글 API\n부분 3 — 애플 인증\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e소개\u003c/h1\u003e\n\u003cp\u003e서버포드에서 인증에 관한 시리즈의 제1부에 오신 것을 환영합니다! 본 문서에서는 서버포드 및 플러터 애플리케이션에서 이메일 및 비밀번호 인증을 구현하는 데 초점을 맞춥니다. 이메일 및 비밀번호 인증은 대부분의 애플리케이션에 있어 일반적이고 필수적인 기능으로, 사용자가 계정을 만들고 로그인하여 데이터에 안전하게 접근할 수 있게 합니다.\u003c/p\u003e\n\u003cp\u003e우리는 서버포드 프로젝트를 생성부터 서버포드 인증 모듈을 설정하는 과정까지 전체 과정을 안내해 드리겠습니다. 또한 서버 측 코드 설정과 제3자 메일 서버와 통합하는 방법, 사용자 인터페이스를 구축하고 서버와 연결하는 방법에 대한 지침도 제공할 것입니다.\u003c/p\u003e\n\u003cp\u003e본 문서를 마치면 서버포드-플러터 애플리케이션에서 이메일 및 비밀번호 인증을 어떻게 구현하는지에 대한 탄탄한 이해를 갖추게 되며, 향후 시리즈 뒷부분의 추가적인 인증 방법 탐색을 위한 기초가 마련될 것입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 튜토리얼에서 생성하는 완전한 예제 프로젝트는 여기에서 확인할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e시작해 봅시다!\u003c/p\u003e\n\u003ch2\u003e전제 조건\u003c/h2\u003e\n\u003cp\u003eServerpod로 이메일 및 비밀번호 인증을 구현하기 전에 필요한 몇 가지 전제 조건이 있습니다. 이미 Serverpod CLI 및 Docker를 비롯한 필요한 도구를 설치했다고 가정합니다. 아직 이 도구들을 설정하지 않은 경우, 공식 Serverpod 문서를 참고하여 시작하십시오.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e또한, 이 글에서 나중에 생성할 데이터베이스 및 테이블을 검토하기 위해 Postico2, PgAdmin, 또는 DBeaver와 같은 데이터베이스 뷰어를 다운로드하고 설치하는 것을 권장합니다. 선호하는 데이터베이스 뷰어를 사용할 수 있습니다. 이 글에서는 Postico2를 사용할 예정입니다.\u003c/p\u003e\n\u003ch1\u003e서버포드 프로젝트 만들기\u003c/h1\u003e\n\u003cp\u003e새로운 서버포드 프로젝트를 생성합니다: 다음 명령을 실행하여 새로운 서버포드 프로젝트를 만듭니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eserverpod create my_project\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e프로젝트 디렉토리로 이동하세요: 프로젝트 내 서버 디렉토리로 작업 디렉토리를 변경하세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ecd my_project/my_project_server\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWindows 환경에서: 윈도우 환경이라면, 서버팟을 위한 필요한 데이터베이스 테이블을 만들기 위해 설정 중에 이 추가 단계를 수행해야 합니다. 서버 프로젝트 내에서 setup-tables.cmd라는 cmd 파일을 찾을 수 있을 것입니다. 이 스크립트를 실행하세요! 이는 generate/tables-serverpod.pgsql에 위치한 psql 파일을 실행할 것입니다. 리눅스와 맥에서는 프로젝트를 생성할 때 이 단계가 자동으로 수행됩니다.\u003c/p\u003e\n\u003cp\u003e컨테이너 시작하기: 서버팟 프로젝트에 필요한 Docker 컨테이너를 시작하기 위해 다음 명령을 실행하세요:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edocker-compose up --build --detach\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e서버팟_인증 모듈 설치 및 구성하기\u003c/h1\u003e\n\u003cp\u003e서버팟\u003cem\u003e인증 모듈은 Serverpod 프로젝트에서 인증을 관리하는 데 필수적인 기능을 제공합니다. 사용자 등록, 로그인, 비밀번호 해싱 및 세션 관리와 같은 기능이 포함되어 있습니다. 이 섹션에서는 서버팟\u003c/em\u003e인증 모듈 설치 및 구성 프로세스를 안내하고 데이터베이스를 업데이트하는 방법을 안내합니다.\u003c/p\u003e\n\u003ch2\u003e서버 쪽 설정\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e서버파드 프로젝트(my_project_server)의 pubspec.yaml 파일을 열고 다음 줄을 의존성 섹션 아래에 추가해주세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-attr\"\u003edependencies\u003c/span\u003e:\n  \u003cspan class=\"hljs-attr\"\u003eserverpod_auth_server\u003c/span\u003e: ^\u003cspan class=\"hljs-number\"\u003e2.0\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.0\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e참고: 모든 서버파드 종속성의 버전은 동일해야 합니다! serverpod_auth를 버전 2.0.0으로 추가하는 경우, serverpod와 설치한 다른 서버파드 패키지도 2.0.0이어야 합니다.\u003c/p\u003e\n\u003cp\u003e버전 2.0 이상인 경우 서버파드 객체에 authenticationHandler를 등록하세요: main.dart 파일에 다음 코드를 추가해주세요. 이 콜백은 클라이언트로부터 수신된 요청을 인증하는 데 사용됩니다. 이전 버전은 이 단계를 완료할 필요가 없습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:serverpod_auth_server/serverpod_auth_server.dart'\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e auth;\n\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erun\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e\u003e args) \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e pod = \u003cspan class=\"hljs-title class_\"\u003eServerpod\u003c/span\u003e(\n    args,\n    \u003cspan class=\"hljs-title class_\"\u003eProtocol\u003c/span\u003e(),\n    \u003cspan class=\"hljs-title class_\"\u003eEndpoints\u003c/span\u003e(),\n    \u003cspan class=\"hljs-attr\"\u003eauthenticationHandler\u003c/span\u003e: auth.\u003cspan class=\"hljs-property\"\u003eauthenticationHandler\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 이 줄을 추가하세요\u003c/span\u003e\n  );\n\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e pod.\u003cspan class=\"hljs-title function_\"\u003estart\u003c/span\u003e();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e의존성 가져오고 필요한 파일 생성하기: 프로젝트의 루트 디렉토리에서 다음 명령을 실행하여 새로운 종속성을 가져오고 서버 구성에 따라 필요한 파일을 생성하세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edart pub get\nserverpod generate\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e기존 데이터베이스에 필요한 테이블 업데이트하기: Serverpod auth 모듈에는 모듈이 작동하는 데 필요한 데이터베이스 테이블 세트가 함께 제공됩니다. 이를 생성해봅시다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e만약 Serverpod 버전 1.2 이상을 사용하고 있다면, 마이그레이션 시스템을 사용해야 해요! 다음 명령어로 새 마이그레이션을 만들어보세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eserverpod create-migration\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 새 마이그레이션을 적용하려면 아래 명령어를 사용하세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edart bin/main.\u003cspan class=\"hljs-property\"\u003edart\u003c/span\u003e --apply-migrations --role=maintenance\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e유지 관리 역할을 설정하면 서버가 부팅되어 데이터베이스에 연결한 후 종료됩니다.\u003c/p\u003e\n\u003cp\u003e버전 1.1 이하:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e새 SQL 파일 만들기: 기존 tables-serverpod.pgsql 파일이 있는 폴더에 tables-serverpod-auth.pgsql이라는 새 파일을 만듭니다. 이 파일에는 새 테이블을 생성하는 SQL 코드가 포함될 것입니다.\u003c/li\u003e\n\u003cli\u003eSQL 코드 복사: serverpod_auth 모듈의 테이블을 생성하는 SQL 코드에 액세스하려면 다음 링크를 엽니다: serverpod_auth tables.pgsql. 파일 전체 내용을 복사합니다.\u003c/li\u003e\n\u003cli\u003eSQL 코드를 새 파일에 붙여넣기: 새로 생성된 tables-serverpod-auth.pgsql 파일을 열고 복사한 SQL 코드를 붙여넣습니다.\u003c/li\u003e\n\u003cli\u003eDocker 컨테이너 이름 찾기: \u003ccode\u003edocker ps\u003c/code\u003e를 실행하거나 Docker 대시보드를 확인하여 Docker 컨테이너 이름을 찾습니다. 아래 스크린샷을 참고할 수도 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-GettingStartedwithServerpodAuthenticationPart1_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e포스트그레SQL 파일을 컨테이너로 복사하고 SQL 코드를 실행하려면 다음 단계를 따르세요: \u003ccode\u003econtainer_name\u003c/code\u003e을(를) Docker 컨테이너 이름으로 바꿔주세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edocker cp ./tables-serverpod-auth.\u003cspan class=\"hljs-property\"\u003epgsql\u003c/span\u003e \u0026#x3C;container_name\u003e:\u003cspan class=\"hljs-regexp\"\u003e/docker-entrypoint-initdb.d/\u003c/span\u003etables-serverpod-auth.\u003cspan class=\"hljs-property\"\u003epgsql\u003c/span\u003e\n\ndocker exec -u postgres \u0026#x3C;container_name\u003e psql my_project postgres -f /docker-entrypoint-initdb.\u003cspan class=\"hljs-property\"\u003ed\u003c/span\u003e/tables-serverpod-auth.\u003cspan class=\"hljs-property\"\u003epgsql\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e데이터베이스에 Postico 연결하기\u003c/h2\u003e\n\u003cp\u003e시작하려면 Postico2를 열고 \"새 서버\"를 클릭하여 새 연결을 만드세요. 로컬 포스트그레SQL 서버의 연결 세부 정보를 입력해야 합니다. 이 정보는 Serverpod 프로젝트의 config/development.yaml 및 config/passwords.yaml 파일에서 찾을 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e아래는 Markdown 형식으로 표 태그를 변경한 내용입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-GettingStartedwithServerpodAuthenticationPart1_2.png\" alt=\"GettingStartedwithServerpodAuthenticationPart1_2\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-GettingStartedwithServerpodAuthenticationPart1_3.png\" alt=\"GettingStartedwithServerpodAuthenticationPart1_3\"\u003e\u003c/p\u003e\n\u003cp\u003e모든 테이블이 성공적으로 생성되었습니다. 다음 단계로 넘어가겠습니다.\u003c/p\u003e\n\u003ch2\u003e클라이언트 라이브러리 설정\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e클라이언트 측에서 serverpod_auth 모듈을 사용하려면 클라이언트 프로젝트에 serverpod_auth_client 종속성을 추가해야 합니다.\u003c/p\u003e\n\u003cp\u003e클라이언트 프로젝트의 pubspec.yaml 파일을 열고 다음 라인을 dependencies 섹션 아래에 추가하세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-attr\"\u003edependencies\u003c/span\u003e:\n  ...\n  \u003cspan class=\"hljs-attr\"\u003eserverpod_auth_client\u003c/span\u003e: ^\u003cspan class=\"hljs-number\"\u003e2.0\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.0\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 패키지에는 서버로 이메일 및 비밀번호 인증을 위한 API 호출을 만들기 위해 필요한 클라이언트 측 라이브러리 코드가 포함되어 있습니다. serverpod_auth_email_flutter가 제공하는 미리 빌드된 UI 구성 요소를 사용 중이라면 해당 종속성은 엄격히 필요하지는 않지만 모든 생성된 인증 엔드포인트가 포함되어 있어 상호 작용할 수 있으므로 여기에 추가하는 것이 좋습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e플러터 앱 설정\u003c/h2\u003e\n\u003cp\u003eServerpod를 사용하여 이메일 및 비밀번호 인증에 필요한 서버 측 변경 사항을 구현한 후, 다음 단계는 Flutter 앱과 통합하는 것입니다. 다행히도 Serverpod는 이 프로세스를 가능한한 원활하게 만들기 위해 미리 구축된 UI 컴포넌트를 제공합니다.\u003c/p\u003e\n\u003cp\u003e먼저, Flutter 앱에 필요한 클라이언트 측 종속성을 추가해야 합니다. Serverpod 프로젝트(my_project_flutter)의 pubspec.yaml 파일을 열고 다음과 같은 라인을 dependencies 섹션 아래 추가해주세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-attr\"\u003edependencies\u003c/span\u003e:\n  ...\n  \u003cspan class=\"hljs-attr\"\u003eserverpod_auth_email_flutter\u003c/span\u003e: ^\u003cspan class=\"hljs-number\"\u003e2.0\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.0\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003eserverpod_auth_shared_flutter\u003c/span\u003e: ^\u003cspan class=\"hljs-number\"\u003e2.0\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.0\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003epubspec.yaml 파일에 필요한 종속성을 추가한 후에는 터미널에서 flutter pub get을 실행하여 종속성을 업데이트해야 합니다.\u003c/p\u003e\n\u003cp\u003e이러한 패키지에는 사전 제작된 UI 구성 요소 및 서버 통합을 최대한 간단하게 만드는 기타 도구가 포함되어 있습니다. 그러나 자체 UI 구성 요소를 만들기를 선호하는 경우, 생성된 클라이언트 라이브러리와 통합할 수 있고 이 경우에는 이러한 종속성이 필요하지 않습니다.\u003c/p\u003e\n\u003ch1\u003e서버 시작 및 클라이언트 실행\u003c/h1\u003e\n\u003cp\u003e축하합니다! 이제 모든 필요한 종속성이 설정된 프로젝트가 있습니다. 다음으로 진행하기 전에 모든 것이 올바르게 작동하는지 확인해 봅시다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e서버를 시작하려면 터미널에서 my_project_server 디렉토리로 이동한 다음 다음 명령어를 실행하세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ecd my_project_server\ndart bin/main.\u003cspan class=\"hljs-property\"\u003edart\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-06-21-GettingStartedwithServerpodAuthenticationPart1_4.png\"\u003e\n\u003cp\u003e다음으로, 새 터미널 창에서 my_project_flutter 디렉토리로 이동한 다음 다음 명령어를 실행하여 Flutter 앱을 시작하세요:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ecd my_project_flutter\nflutter run\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e크롬에서 실행하여 메시지를 보내는 테스트를 선택하세요!\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-06-21-GettingStartedwithServerpodAuthenticationPart1_5.png\"\u003e\n\u003ch2\u003e문제 해결\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e문제가 발생하면 문제를 진단하는 데 도움이 되는 몇 가지를 확인할 수 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e이 가이드의 이전 단계를 모두 올바르게 따랐는지 확인하세요.\u003c/li\u003e\n\u003cli\u003e서버가 오류 없이 실행 중인지 확인하세요. 오류가 있으면 서버를 시작한 터미널에 표시됩니다.\u003c/li\u003e\n\u003cli\u003e필요한 데이터베이스 테이블이 모두 생성되었는지 확인하세요. 이를 확인하려면 Postgres나 pgAdmin과 같은 도구를 사용하여 데이터베이스에 연결하고 public 스키마에있는 테이블을 확인하세요. 테이블이 누락 된 경우 해당 테이블을 만들기 위해 SQL 스크립트를 실행했는지 확인하세요.\u003c/li\u003e\n\u003cli\u003e여전히 문제가 발생하는 경우 앱의 콘솔 또는 로그에서 추가 컨텍스트를 제공 할 수있는 오류 메시지를 확인하세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e이메일/비밀번호 인증 구현\u003c/h1\u003e\n\u003cp\u003e이제 서버와 클라이언트 라이브러리를 설정 했으므로 Flutter 앱에서 인증을 구현할 시간입니다. 이전에 추가 한 serverpod_auth_email_flutter 및 serverpod_auth_shared_flutter 패키지를 사용합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e첫 번째 단계는 Client 및 SessionManager 객체를 초기화하는 것입니다. 먼저 my_project_flutter/lib/src/ 폴더 안에 serverpod_client.dart 파일을 생성해보세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:my_project_client/my_project_client.dart'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:serverpod_auth_shared_flutter/serverpod_auth_shared_flutter.dart'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:serverpod_flutter/serverpod_flutter.dart'\u003c/span\u003e;\n\nlate \u003cspan class=\"hljs-title class_\"\u003eSessionManager\u003c/span\u003e sessionManager;\nlate \u003cspan class=\"hljs-title class_\"\u003eClient\u003c/span\u003e client;\n\n\u003cspan class=\"hljs-title class_\"\u003eFuture\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e\u003e \u003cspan class=\"hljs-title function_\"\u003einitializeServerpodClient\u003c/span\u003e() \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e// 안드로이드 에뮬레이터는 기본적으로 로컬호스트에 액세스할 수 없습니다.\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// const ipAddress = '10.0.2.2'; // 호스트에 대한 안드로이드 에뮬레이터 IP 주소\u003c/span\u003e\n\n  \u003cspan class=\"hljs-comment\"\u003e// 실제 장치에서는 ipAddress를 컴퓨터의 IP 주소로 대체하십시오.\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e ipAddress = \u003cspan class=\"hljs-string\"\u003e'localhost'\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-comment\"\u003e// 어플리케이션 어디서든 사용할 수 있는 싱글톤 클라이언트 객체를 설정합니다.\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// 해당 클라이언트는 서버 코드에서 생성됩니다.\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// 클라이언트는 로컬 서버의 기본 포트에서 실행 중인 Serverpod에 연결하도록 설정됩니다.\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// 스테이징이나 프로덕션 서버에 연결하려면 수정해야 합니다.\u003c/span\u003e\n  client = \u003cspan class=\"hljs-title class_\"\u003eClient\u003c/span\u003e(\n    \u003cspan class=\"hljs-string\"\u003e'http://$ipAddress:8080/'\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eauthenticationKeyManager\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eFlutterAuthenticationKeyManager\u003c/span\u003e(),\n  )..\u003cspan class=\"hljs-property\"\u003econnectivityMonitor\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eFlutterConnectivityMonitor\u003c/span\u003e();\n\n  \u003cspan class=\"hljs-comment\"\u003e// 세션 관리자는 사용자의 로그인 상태를 추적합니다.\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// 사용자가 현재 로그인되어 있는지 확인하고 사용자 정보를 가져올 수 있습니다.\u003c/span\u003e\n  sessionManager = \u003cspan class=\"hljs-title class_\"\u003eSessionManager\u003c/span\u003e(\n    \u003cspan class=\"hljs-attr\"\u003ecaller\u003c/span\u003e: client.\u003cspan class=\"hljs-property\"\u003emodules\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eauth\u003c/span\u003e,\n  );\n\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e sessionManager.\u003cspan class=\"hljs-title function_\"\u003einitialize\u003c/span\u003e();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e본 함수는 클라이언트와 서버 간 통신에 사용되는 싱글톤 Client 객체를 설정하고, 사용자의 로그인 상태를 추적하는 SessionManager 객체를 초기화합니다.\u003c/p\u003e\n\u003cp\u003e이전 단계에서 생성된 Client 객체를 사용하려면 main() 함수에서 싱글톤 인스턴스로 초기화해야 합니다. 이를 위해 main.dart 파일의 main() 함수에서 WidgetsFlutterBinding.ensureInitialized()를 호출하여 Flutter가 완전히 초기화된 후에 SessionManager를 사용할 수 있도록 해야 합니다. 그 후에 방금 만든 initializeServerpodClient() 함수를 호출할 수 있습니다. 마지막으로 runApp() 함수를 호출하여 어플리케이션을 시작할 수 있습니다. 아래는 업데이트된 main() 함수의 예시입니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e() \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e// runApp을 호출하기 전에 Flutter 바인딩을 사용하는 SessionManager를 호출해야 합니다.\u003c/span\u003e\n  \u003cspan class=\"hljs-title class_\"\u003eWidgetsFlutterBinding\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eensureInitialized\u003c/span\u003e();\n\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003einitializeServerpodClient\u003c/span\u003e();\n\n  \u003cspan class=\"hljs-title function_\"\u003erunApp\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyApp\u003c/span\u003e());\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음으로 사용자에게 로그인 양식을 표시할 SignInPage 위젯을 만들겠습니다. 또한 사용자가 성공적으로 로그인한 후에 표시될 AccountPage 위젯도 만들겠습니다.\u003c/p\u003e\n\u003ch2\u003eSignIn 페이지 생성\u003c/h2\u003e\n\u003cp\u003eFlutter 앱에서 이메일 및 비밀번호 인증을 활성화하기 위해 serverpod_auth_email_flutter 패키지에서 제공하는 SignInWithEmailButton이라는 미리 만들어진 위젯을 사용하여 로그인 페이지를 생성할 것입니다. 이 위젯은 로그인 버튼을 생성하며 로그인 흐름을 처리하는 대화 상자를 제공합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e먼저, Flutter 앱의 lib/src/widgets 폴더에 sign_in_page.dart란 이름의 새 파일을 만들어주세요.\u003c/p\u003e\n\u003cp\u003e다음으로, StatelessWidget을 확장하는 SignInPage라는 새 클래스를 만들어주세요. 이 클래스는 Dialog 위젯으로 감싸진 로그인 버튼을 반환할 것입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:flutter/material.dart'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:serverpod_auth_email_flutter/serverpod_auth_email_flutter.dart'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:my_project_flutter/src/serverpod_client.dart'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSignInPage\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eStatelessWidget\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSignInPage\u003c/span\u003e({\u003cspan class=\"hljs-title class_\"\u003eKey\u003c/span\u003e? key}) : \u003cspan class=\"hljs-variable language_\"\u003esuper\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e: key);\n\n  @override\n  \u003cspan class=\"hljs-title class_\"\u003eWidget\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebuild\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eBuildContext context\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCenter\u003c/span\u003e(\n      \u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDialog\u003c/span\u003e(\n        \u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eContainer\u003c/span\u003e(\n          \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e260\u003c/span\u003e,\n          \u003cspan class=\"hljs-attr\"\u003epadding\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eEdgeInsets\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eall\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e),\n          \u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eColumn\u003c/span\u003e(\n            \u003cspan class=\"hljs-attr\"\u003emainAxisSize\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eMainAxisSize\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emin\u003c/span\u003e,\n            \u003cspan class=\"hljs-attr\"\u003ecrossAxisAlignment\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCrossAxisAlignment\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003estretch\u003c/span\u003e,\n            \u003cspan class=\"hljs-attr\"\u003echildren\u003c/span\u003e: [\n              \u003cspan class=\"hljs-title class_\"\u003eSignInWithEmailButton\u003c/span\u003e(\n                \u003cspan class=\"hljs-attr\"\u003ecaller\u003c/span\u003e: client.\u003cspan class=\"hljs-property\"\u003emodules\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eauth\u003c/span\u003e,\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드에서, SignInWithEmailButton 위젯은 caller라는 인자를 가져오는데, 이는 Serverpod에서 제공하는 생성된 클라이언트 라이브러리의 인스턴스입니다. 이를 통해 위젯이 Serverpod 서버와 통신할 수 있게 됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e홈페이지에 SignInPage 추가하기\u003c/h2\u003e\n\u003cp\u003e앱의 홈페이지에 SignInPage를 추가하려면 lib/ 폴더의 루트에 위치한 main.dart 파일 내에 정의된 MyHomePage 클래스를 수정해야 합니다.\u003c/p\u003e\n\u003cp\u003e기존의 MyHomePage 클래스를 다음 코드로 변경하세요. 이 클래스 아래에 있는 내용은 모두 제거해도 됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyHomePageState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eState\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eMyHomePage\u003c/span\u003e\u003e {\n  @override\n  \u003cspan class=\"hljs-title class_\"\u003eWidget\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebuild\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eBuildContext context\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eScaffold\u003c/span\u003e(\n      \u003cspan class=\"hljs-attr\"\u003eappBar\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eAppBar\u003c/span\u003e(\n        \u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(widget.\u003cspan class=\"hljs-property\"\u003etitle\u003c/span\u003e),\n      ),\n      \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSignInPage\u003c/span\u003e(),\n    );\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e잊지 말고 SignInPage 위젯에 대한 import 문을 추가해주세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"package:my_project_flutter/src/widgets/sign_in_page.dart\"\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e전체 main.dart 파일은 다음과 같이 보여야 합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:my_project_flutter/src/serverpod_client.dart'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:my_project_flutter/src/widgets/sign_in_page.dart'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:flutter/material.dart'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e() \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e// runApp을 호출하기 전에 Flutter 바인딩을 사용하는 SessionManager를 초기화해야 합니다.\u003c/span\u003e\n  \u003cspan class=\"hljs-title class_\"\u003eWidgetsFlutterBinding\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eensureInitialized\u003c/span\u003e();\n\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003einitializeServerpodClient\u003c/span\u003e();\n\n  \u003cspan class=\"hljs-title function_\"\u003erunApp\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyApp\u003c/span\u003e());\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyApp\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eStatelessWidget\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyApp\u003c/span\u003e({\u003cspan class=\"hljs-title class_\"\u003eKey\u003c/span\u003e? key}) : \u003cspan class=\"hljs-variable language_\"\u003esuper\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e: key);\n\n  @override\n  \u003cspan class=\"hljs-title class_\"\u003eWidget\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebuild\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eBuildContext context\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMaterialApp\u003c/span\u003e(\n      \u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'Serverpod demo'\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003etheme\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eThemeData\u003c/span\u003e(\n        \u003cspan class=\"hljs-attr\"\u003eprimarySwatch\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eColors\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eblue\u003c/span\u003e,\n      ),\n      \u003cspan class=\"hljs-attr\"\u003ehome\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyHomePage\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'Serverpod Example'\u003c/span\u003e),\n    );\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyHomePage\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eStatefulWidget\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyHomePage\u003c/span\u003e({\u003cspan class=\"hljs-title class_\"\u003eKey\u003c/span\u003e? key, required \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etitle\u003c/span\u003e}) : \u003cspan class=\"hljs-variable language_\"\u003esuper\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e: key);\n\n  final \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e title;\n\n  @override\n  \u003cspan class=\"hljs-title class_\"\u003eMyHomePageState\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecreateState\u003c/span\u003e() =\u003e \u003cspan class=\"hljs-title class_\"\u003eMyHomePageState\u003c/span\u003e();\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyHomePageState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eState\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eMyHomePage\u003c/span\u003e\u003e {\n  @override\n  \u003cspan class=\"hljs-title class_\"\u003eWidget\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebuild\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eBuildContext context\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eScaffold\u003c/span\u003e(\n      \u003cspan class=\"hljs-attr\"\u003eappBar\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eAppBar\u003c/span\u003e(\n        \u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(widget.\u003cspan class=\"hljs-property\"\u003etitle\u003c/span\u003e),\n      ),\n      \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSignInPage\u003c/span\u003e()\n    );\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e앱을 새로고침하면 이제 로그인 버튼을 볼 수 있어요! 아직 끝나지 않았지만 실제로 서버와 통신할 수 있어야 해요!\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-GettingStartedwithServerpodAuthenticationPart1_6.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e이제 우리 앱의 홈 페이지에 로그인 페이지를 통합했고 계정을 생성할 수 있어요. 그러나 로그인 프로세스를 완료하기 위해 서버에서 전송된 인증 코드가 필요해요. 계정 등록을 위해 사용자는 회원 가입 페이지의 필수 필드를 작성하고 양식을 제출할 수 있어요. 제출하면 서버가 제공된 이메일 주소로 인증 코드를 보내줄 거에요. 현재 우리는 인증 코드에 액세스하지 못하므로 로그인 프로세스를 아직 완료할 수 없어요. 이 문제를 해결해 봐요!\u003c/p\u003e\n\u003ch2\u003e이메일 인증 콜백 통합하기\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e회원 가입 프로세스를 완료하려면 검증 이메일을 보내는 콜백을 추가해야 합니다. Serverpod은 회원 가입을 위한 검증 코드 및 비밀번호 재설정을 위한 메일을 보내는 데 유용한 몇 가지 콜백을 제공합니다. 지금은 콘솔에 코드를 출력하여 기능을 테스트하기 위한 빠르고 간단한 솔루션을 구현해 봅시다.\u003c/p\u003e\n\u003cp\u003e서버 프로젝트의 server.dart 파일에 다음 구성을 추가하여 콜백을 설정할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:serverpod_auth_server/module.dart'\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e auth;\n\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erun\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e\u003e args) \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n  ...\n  auth.\u003cspan class=\"hljs-property\"\u003eAuthConfig\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eset\u003c/span\u003e(auth.\u003cspan class=\"hljs-title class_\"\u003eAuthConfig\u003c/span\u003e(\n    \u003cspan class=\"hljs-attr\"\u003esendValidationEmail\u003c/span\u003e: (session, email, validationCode) \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n      \u003cspan class=\"hljs-comment\"\u003e// \u003cspan class=\"hljs-doctag\"\u003eTODO:\u003c/span\u003e 메일 서버와 연동\u003c/span\u003e\n      \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'검증 코드: $validationCode'\u003c/span\u003e);\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n    },\n    \u003cspan class=\"hljs-attr\"\u003esendPasswordResetEmail\u003c/span\u003e: (session, userInfo, validationCode) \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n      \u003cspan class=\"hljs-comment\"\u003e// \u003cspan class=\"hljs-doctag\"\u003eTODO:\u003c/span\u003e 메일 서버와 연동\u003c/span\u003e\n      \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'검증 코드: $validationCode'\u003c/span\u003e);\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n    },\n  ));\n\n  ...\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e pod.\u003cspan class=\"hljs-title function_\"\u003estart\u003c/span\u003e();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003erun() 메서드 내에서 pod.start()를 호출하기 전에 이 코드를 추가하여 콜백이 제대로 설정되도록 해줍니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e위에 바꾼 사항들이 적용되도록 하려면 Serverpod 서버를 다시 시작해야 합니다. 서버를 시작한 터미널로 이동하여 \"CTRL + C\"를 눌러 중지한 후, \"dart bin/main.dart\"를 실행하여 서버를 다시 시작합니다.\u003c/p\u003e\n\u003cp\u003e지금 테스트해 봅시다!\u003c/p\u003e\n\u003cp\u003e로그인 버튼을 생성하고 정보를 입력해 봅시다!\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-GettingStartedwithServerpodAuthenticationPart1_7.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e지금은 이메일을 받지 않을 거에요. 대신에 서버를 실행한 터미널에서 확인 코드를 찾아보셔야 해요.\u003c/p\u003e\n\u003cp\u003e마크다운(Markdown) 형식으로 테이블 태그를 변경해주세요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-GettingStartedwithServerpodAuthenticationPart1_8.png\" alt=\"이미지 1\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-GettingStartedwithServerpodAuthenticationPart1_9.png\" alt=\"이미지 2\"\u003e\u003c/p\u003e\n\u003ch1\u003e데이터베이스에서 사용자 생성 확인\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이제 어플리케이션에 가입 기능을 설정했으니, 사용자 데이터가 데이터베이스에 올바르게 저장되는지 확인해야 합니다. 아직 Flutter 앱에서 사용자 페이지를 구현하지 않았으므로 Postico2를 사용하여 사용자 생성을 확인할 수 있습니다.\u003c/p\u003e\n\u003cp\u003ePostico2를 열고 이전에 설정 섹션에서 한 것과 같이 데이터베이스에 연결하십시오. 데이터베이스에 연결한 후 'serverpod_user_info' 테이블을 클릭하십시오. 방금 생성한 사용자를 확인할 수 있어야 합니다.\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-06-21-GettingStartedwithServerpodAuthenticationPart1_10.png\"\u003e\n\u003ch1\u003e계정 페이지 구현\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e지금 로그인 페이지가 작동되고 있다면, 이제 계정 페이지를 구현해 보겠습니다. 이 페이지는 현재 로그인한 사용자에 대한 정보를 보여줄 것입니다. 이를 위해 이전에 만들었던 SessionManager 객체를 사용할 것입니다. SessionManager는 사용자의 로그인 상태를 추적하고 사용자에 대한 정보에 액세스할 수 있는 기능을 제공합니다.\u003c/p\u003e\n\u003cp\u003eSessionManager가 제공하는 일부 함수를 살펴보겠습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eisSignedIn(): 이 함수는 사용자가 현재 로그인되어 있는 경우 true를 반환하고 그렇지 않으면 false를 반환합니다.\u003c/li\u003e\n\u003cli\u003egetSignedInUser(): 이 함수는 현재 로그인한 사용자에 대한 정보(이메일 주소 및 표시 이름과 같은)가 포함된 UserInfo 유형의 객체를 반환합니다.\u003c/li\u003e\n\u003cli\u003esignOut(): 이 함수는 사용자를 로그아웃하고 인증 상태를 지웁니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eCircularUserImage 위젯은 Serverpod 프레임워크가 제공하는 사전 제작된 위젯으로, UserInfo 객체를 입력으로 받아서 원형 프로필 이미지를 표시합니다. sessionManager와 이 위젯을 조합하여 멋진 디자인의 계정 페이지를 만들 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003elib/src/widgets 디렉토리 안에 account_page.dart라는 새 파일을 만들고 다음 코드를 추가할 거에요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:flutter/material.dart'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:serverpod_auth_shared_flutter/serverpod_auth_shared_flutter.dart'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:my_project_flutter/src/serverpod_client.dart'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAccountPage\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eStatelessWidget\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAccountPage\u003c/span\u003e({\u003cspan class=\"hljs-title class_\"\u003eKey\u003c/span\u003e? key}) : \u003cspan class=\"hljs-variable language_\"\u003esuper\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e: key);\n\n  @override\n  \u003cspan class=\"hljs-title class_\"\u003eWidget\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebuild\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eBuildContext context\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eListView\u003c/span\u003e(\n      \u003cspan class=\"hljs-attr\"\u003echildren\u003c/span\u003e: [\n        \u003cspan class=\"hljs-title class_\"\u003eListTile\u003c/span\u003e(\n          \u003cspan class=\"hljs-attr\"\u003econtentPadding\u003c/span\u003e:\n              \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eEdgeInsets\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003esymmetric\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003evertical\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ehorizontal\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e),\n          \u003cspan class=\"hljs-attr\"\u003eleading\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCircularUserImage\u003c/span\u003e(\n            \u003cspan class=\"hljs-attr\"\u003euserInfo\u003c/span\u003e: sessionManager.\u003cspan class=\"hljs-property\"\u003esignedInUser\u003c/span\u003e,\n            \u003cspan class=\"hljs-attr\"\u003esize\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e42\u003c/span\u003e,\n          ),\n          \u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(sessionManager.\u003cspan class=\"hljs-property\"\u003esignedInUser\u003c/span\u003e!.\u003cspan class=\"hljs-property\"\u003euserName\u003c/span\u003e),\n          \u003cspan class=\"hljs-attr\"\u003esubtitle\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(sessionManager.\u003cspan class=\"hljs-property\"\u003esignedInUser\u003c/span\u003e!.\u003cspan class=\"hljs-property\"\u003eemail\u003c/span\u003e ?? \u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e),\n        ),\n        \u003cspan class=\"hljs-title class_\"\u003ePadding\u003c/span\u003e(\n          \u003cspan class=\"hljs-attr\"\u003epadding\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eEdgeInsets\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eall\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e),\n          \u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eElevatedButton\u003c/span\u003e(\n            \u003cspan class=\"hljs-attr\"\u003eonPressed\u003c/span\u003e: () {\n              sessionManager.\u003cspan class=\"hljs-title function_\"\u003esignOut\u003c/span\u003e();\n            },\n            \u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'로그아웃'\u003c/span\u003e),\n          ),\n        ),\n      ],\n    );\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eUserInfo 객체를 사용하여 사용자의 이름과 이메일을 가져와 UI에 표시할 수 있어요. 또한 사용자가 Sign out 버튼을 누르면 sessionManager.signOut();이 호출되어 응용프로그램에서 로그아웃할 수 있어요.\u003c/p\u003e\n\u003cp\u003e이제 사용자가 로그인한 경우 AccountPage를 표시해야 해요. 사용자가 로그인했는지 여부에 따라 로그인 페이지와 계정 페이지를 전환하기 위해 main.dart 파일을 수정하고 build 메서드 내에서 const SignInPage()를 이 코드로 바꿔주세요:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003esessionManager.\u003cspan class=\"hljs-property\"\u003eisSignedIn\u003c/span\u003e ? \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAccountPage\u003c/span\u003e() : \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSignInPage\u003c/span\u003e(),\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e사용자가 로그인한 경우 AccountPage()를 렌더링하고, 로그인되지 않은 경우 SignInPage()를 렌더링합니다.\u003c/p\u003e\n\u003cp\u003e세션 상태 변경에 따라 사용자 인터페이스를 업데이트하려면 main.dart의 MyHomePageState 내에 다음 코드를 추가해야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@override\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003einitState\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003esuper\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003einitState\u003c/span\u003e();\n\n  \u003cspan class=\"hljs-comment\"\u003e// 로그인 상태 변경 시 페이지를 다시 빌드하도록 합니다.\u003c/span\u003e\n  sessionManager.\u003cspan class=\"hljs-title function_\"\u003eaddListener\u003c/span\u003e(() {\n    \u003cspan class=\"hljs-title function_\"\u003esetState\u003c/span\u003e(() {});\n  });\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 코드는 sessionManager에 리스너를 설정하여 세션 상태 변경 시 페이지를 다시 빌드합니다. 이렇게 함으로써 사용자가 로그인했는지 여부에 따라 앱이 사용자 인터페이스를 업데이트할 수 있도록 합니다.\u003c/p\u003e\n\u003cp\u003e전체 클래스는 다음과 같이 보여야 합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyHomePageState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eState\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eMyHomePage\u003c/span\u003e\u003e {\n  @override\n  \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003einitState\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003esuper\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003einitState\u003c/span\u003e();\n\n    \u003cspan class=\"hljs-comment\"\u003e// 사용자 로그인 상태 변경 시 페이지 다시 빌드하도록 설정\u003c/span\u003e\n    sessionManager.\u003cspan class=\"hljs-title function_\"\u003eaddListener\u003c/span\u003e(() {\n      \u003cspan class=\"hljs-title function_\"\u003esetState\u003c/span\u003e(() {});\n    });\n  }\n\n  @override\n  \u003cspan class=\"hljs-title class_\"\u003eWidget\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebuild\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eBuildContext context\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eScaffold\u003c/span\u003e(\n      \u003cspan class=\"hljs-attr\"\u003eappBar\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eAppBar\u003c/span\u003e(\n        \u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(widget.\u003cspan class=\"hljs-property\"\u003etitle\u003c/span\u003e),\n      ),\n      \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e:\n          sessionManager.\u003cspan class=\"hljs-property\"\u003eisSignedIn\u003c/span\u003e ? \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAccountPage\u003c/span\u003e() : \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSignInPage\u003c/span\u003e(),\n    );\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이러한 변경 사항을 통해 사용자가 로그인하지 않은 경우 로그인 페이지가 표시되고, 로그인한 경우 사용자 계정 페이지가 표시됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-GettingStartedwithServerpodAuthenticationPart1_11.png\" alt=\"2024-06-21-GettingStartedwithServerpodAuthenticationPart1_11\"\u003e\u003c/p\u003e\n\u003cp\u003e이제 직접 해보세요! 이제 데이터베이스에 사용자 데이터가 저장되는 완전한 기능을 갖춘 가입 및 로그인 흐름이 구현되었습니다! 마지막 단계는 이제까지 연기해 왔던 메일 서버 통합입니다.\u003c/p\u003e\n\u003ch1\u003e메일 서버 통합\u003c/h1\u003e\n\u003cp\u003e인증 코드와 비밀번호 재설정 링크를 보내기 위해 앱을 외부 메일 서버와 통합해야 합니다. SendGrid, Mailjet 등 여러 옵션이 있지만, 이 튜토리얼의 목적을 위해 Gmail을 메일 서버로 사용할 것입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e프로덕션 앱에는 좋지 않은 솔루션이라는 것을 알아두는 것이 중요합니다. 앱에서 Gmail을 사용하여 이메일을 보내면 전달 문제가 발생할 수 있습니다. 스팸으로 지목당하거나 계정이 제한될 수도 있습니다. 프로덕션 앱에 대해서는 전문적인 이메일 서비스를 사용하는 것을 강력히 권장합니다.\u003c/p\u003e\n\u003cp\u003e그렇다면, 이제 Gmail을 사용하여 앱을 통합해 봅시다.\u003c/p\u003e\n\u003cp\u003e먼저, 서버 프로젝트에 mailer 패키지를 추가해야 합니다. 터미널에서 다음 명령을 실행하여 이 작업을 수행할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edart pub add mailer\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e다음으로, 이메일을 보내는 데 사용할 Gmail 계정을 설정해야 합니다. Gmail 계정이 없는 경우 무료로 하나 만들 수 있습니다. \u003ca href=\"https://accounts.google.com/signup\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://accounts.google.com/signup\u003c/a\u003e 에서 만들어보세요.\u003c/p\u003e\n\u003cp\u003eGmail 계정을 만든 후 다음 단계를 따르세요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eGoogle 계정 보안 페이지로 이동합니다.\u003c/li\u003e\n\u003cli\u003e\"Google에 로그인하는 방법\" 아래에서 \"2단계 인증\"을 켭니다.\u003c/li\u003e\n\u003cli\u003e계정에 2단계 인증을 설정하기 위해 안내에 따라 진행합니다. 확인 코드를 받을 전화번호를 제공해야 합니다.\u003c/li\u003e\n\u003cli\u003e2단계 인증을 설정한 후, 계정용 앱 비밀번호를 만듭니다. 이 비밀번호는 우리 앱이 이메일을 보내는 데 사용할 것입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cimg src=\"/assets/img/2024-06-21-GettingStartedwithServerpodAuthenticationPart1_12.png\"\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cimg src=\"/assets/img/2024-06-21-GettingStartedwithServerpodAuthenticationPart1_13.png\"\u003e\n\u003cp\u003e이제 서버팟 프로젝트의 passwords 파일에 암호를 추가해 보겠습니다. 이 파일은 config/passwords.yaml 경로에 있습니다. 여기서 주의할 점은 이 파일을 버전 관리에 저장하지 마십시오. 실제로 서버팟 프로젝트는 이 파일을 .gitignore에 추가하여 사전 구성되어 있습니다. 대신에 항상 프로젝트 외부에서 비밀을 관리하고, 프로덕션 배포 시에는 CI/CD 파이프라인의 비밀 변수로 유지하십시오.\u003c/p\u003e\n\u003cp\u003ekey/valuesgmailEmail 및 gmailPassword를 추가하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 이들은 개발 모드에서 로컬 서버를 실행할 때 사용되는 암호입니다.\n\u003cspan class=\"hljs-attr\"\u003edevelopment\u003c/span\u003e:\n  \u003cspan class=\"hljs-attr\"\u003edatabase\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'9S8rYW7XeIA8bmGY9FBzOSLwQZtQEFNr'\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003eredis\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'V7YogaG9K2rnIpS1odXIKrqsW8kkfddt'\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003egmailEmail\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'\u0026#x3C;your gmail email\u003e'\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003egmailPassword\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'\u0026#x3C;your gmail key\u003e'\u003c/span\u003e\n\n  # 서비스 비밀은 서버 간 통신 및 서비스 프로토콜에 액세스하는 데 사용됩니다.\n  \u003cspan class=\"hljs-attr\"\u003eserviceSecret\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'IWtaP1Z-Db-F70IBJpWGf3D7x9F3AYGg'\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e우리는 비밀번호 파일에 키를 추가하여 나중에 코드에서 쉽게 가져와 사용할 수 있습니다. 이렇게 하면 서버에 시크릿을 삽입하는 편리한 방법입니다.\u003c/p\u003e\n\u003cp\u003e이제 Gmail 계정과 설정한 시크릿이 준비되었으니, 이메일로 validationCode를 보내는 로직을 구현할 수 있습니다. 이를 위해 이전에 서버 프로젝트 내 server.dart에 만들어둔 AuthConfig를 수정해야 합니다.\u003c/p\u003e\n\u003cp\u003e먼저, session.serverpod 객체에서 getPassword 함수를 호출하여 Gmail SMTP 서버의 자격 증명을 가져옵니다. 이 함수는 이전 단계에서 추가한 시크릿을 가져올 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 자격 증명 가져오기\u003c/span\u003e\nfinal gmailEmail = session.\u003cspan class=\"hljs-property\"\u003eserverpod\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetPassword\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'gmailEmail'\u003c/span\u003e)!;\nfinal gmailPassword = session.\u003cspan class=\"hljs-property\"\u003eserverpod\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetPassword\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'gmailPassword'\u003c/span\u003e)!;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e그럼, 우리는 검색한 이메일과 비밀번호를 사용하여 Gmail용 SMTP 클라이언트를 생성합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// Gmail용 SMTP 클라이언트 생성\u003c/span\u003e\nfinal smtpServer = \u003cspan class=\"hljs-title function_\"\u003egmail\u003c/span\u003e(gmailEmail, gmailPassword);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그런 다음, 유효성 코드를 사용하여 이메일 메시지를 만듭니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 검증 코드를 포함한 이메일 메시지 생성\u003c/span\u003e\nfinal message = \u003cspan class=\"hljs-title class_\"\u003eMessage\u003c/span\u003e()\n  ..\u003cspan class=\"hljs-property\"\u003efrom\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eAddress\u003c/span\u003e(gmailEmail)\n  ..\u003cspan class=\"hljs-property\"\u003erecipients\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(email)\n  ..\u003cspan class=\"hljs-property\"\u003esubject\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e'Serverpod를 위한 검증 코드'\u003c/span\u003e\n  ..\u003cspan class=\"hljs-property\"\u003ehtml\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e'귀하의 검증 코드는 다음과 같습니다: $validationCode'\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e마지막으로, mailer 패키지의 send 함수를 사용하여 이메일 메시지를 전송하는 시도를 합니다. 이메일 전송에 실패하면 false를 반환합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 이메일 메시지를 전송합니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esend\u003c/span\u003e(message, smtpServer);\n} \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (_) {\n  \u003cspan class=\"hljs-comment\"\u003e// 이메일 전송에 실패한 경우 false를 반환합니다.\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n}\n\n\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e모든 코드를 한데 모아서 sendValidationEmail 및 sendPasswordResetEmail을 구현할 때 아래와 같이 코드가 보여야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 이메일로 로그인하는 경우의 구성.\u003c/span\u003e\nauth.\u003cspan class=\"hljs-property\"\u003eAuthConfig\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eset\u003c/span\u003e(auth.\u003cspan class=\"hljs-title class_\"\u003eAuthConfig\u003c/span\u003e(\n  \u003cspan class=\"hljs-attr\"\u003esendValidationEmail\u003c/span\u003e: (session, email, validationCode) \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// 자격 증명 가져오기\u003c/span\u003e\n    final gmailEmail = session.\u003cspan class=\"hljs-property\"\u003eserverpod\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetPassword\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'gmailEmail'\u003c/span\u003e)!;\n    final gmailPassword = session.\u003cspan class=\"hljs-property\"\u003eserverpod\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetPassword\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'gmailPassword'\u003c/span\u003e)!;\n\n    \u003cspan class=\"hljs-comment\"\u003e// Gmail용 SMTP 클라이언트 생성\u003c/span\u003e\n    final smtpServer = \u003cspan class=\"hljs-title function_\"\u003egmail\u003c/span\u003e(gmailEmail, gmailPassword);\n\n    \u003cspan class=\"hljs-comment\"\u003e// 검증 코드가 포함된 이메일 메시지 생성\u003c/span\u003e\n    final message = \u003cspan class=\"hljs-title class_\"\u003eMessage\u003c/span\u003e()\n      ..\u003cspan class=\"hljs-property\"\u003efrom\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eAddress\u003c/span\u003e(gmailEmail)\n      ..\u003cspan class=\"hljs-property\"\u003erecipients\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(email)\n      ..\u003cspan class=\"hljs-property\"\u003esubject\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e'Serverpod의 인증 코드'\u003c/span\u003e\n      ..\u003cspan class=\"hljs-property\"\u003ehtml\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e'귀하의 인증 코드는 다음과 같습니다: $validationCode'\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-comment\"\u003e// 이메일 메시지 전송\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esend\u003c/span\u003e(message, smtpServer);\n    } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (_) {\n      \u003cspan class=\"hljs-comment\"\u003e// 이메일 전송에 실패한 경우 false를 반환합니다.\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n  },\n  \u003cspan class=\"hljs-attr\"\u003esendPasswordResetEmail\u003c/span\u003e: (session, userInfo, validationCode) \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// 자격 증명 가져오기\u003c/span\u003e\n    final gmailEmail = session.\u003cspan class=\"hljs-property\"\u003eserverpod\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetPassword\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'gmailEmail'\u003c/span\u003e)!;\n    final gmailPassword = session.\u003cspan class=\"hljs-property\"\u003eserverpod\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetPassword\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'gmailPassword'\u003c/span\u003e)!;\n\n    \u003cspan class=\"hljs-comment\"\u003e// Gmail용 SMTP 클라이언트 생성\u003c/span\u003e\n    final smtpServer = \u003cspan class=\"hljs-title function_\"\u003egmail\u003c/span\u003e(gmailEmail, gmailPassword);\n\n    \u003cspan class=\"hljs-comment\"\u003e// 비밀번호 재설정 링크가 포함된 이메일 메시지 생성\u003c/span\u003e\n    final message = \u003cspan class=\"hljs-title class_\"\u003eMessage\u003c/span\u003e()\n      ..\u003cspan class=\"hljs-property\"\u003efrom\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eAddress\u003c/span\u003e(gmailEmail)\n      ..\u003cspan class=\"hljs-property\"\u003erecipients\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(userInfo.\u003cspan class=\"hljs-property\"\u003eemail\u003c/span\u003e!)\n      ..\u003cspan class=\"hljs-property\"\u003esubject\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e'Serverpod의 비밀번호 재설정 링크'\u003c/span\u003e\n      ..\u003cspan class=\"hljs-property\"\u003ehtml\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e'다음은 비밀번호 재설정 코드입니다: $validationCode'\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-comment\"\u003e// 이메일 메시지 전송\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esend\u003c/span\u003e(message, smtpServer);\n    } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (_) {\n      \u003cspan class=\"hljs-comment\"\u003e// 이메일 전송에 실패한 경우 false를 반환합니다.\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n  },\n));\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e새 변경 사항이 적용되었는지 확인하려면 서버를 다시 시작하는 것을 잊지 마세요. 그러고 나면 테스트해 보는 시간입니다! 새 계정을 만들어서 이메일을 통해 인증 코드를 받는지 확인해 보세요. 모든 것이 기대한 대로 작동한다면, 축하합니다! 이메일 서비스 제공 업체와 Serverpod를 성공적으로 통합했습니다.\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e이 튜토리얼에서는 serverpod_auth_google_flutter를 Flutter 앱과 통합하는 기본 사항을 다뤘습니다. 이를 통해 사용자 계정을 만들고 로그인하고 이메일 주소를 인증할 수 있었습니다. 또한, 메일 서버 통합과 테스트 목적으로 Gmail을 보내는 사람으로 사용하는 mailer 패키지를 간단히 논의했습니다.\u003c/p\u003e\n\u003cp\u003e다음 시리즈에서는 Google 소셜 로그인을 serverpod_auth_google_flutter와 통합하는 방법에 대해 논의할 것입니다. 이를 통해 사용자가 새로운 계정을 만들 필요 없이 Google 계정으로 로그인하도록 설정하여 사용자가 간편하고 편리하게 가입하고 로그인할 수 있도록 지원할 수 있게 될 것입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 시리즈를 마치면 serverpod_auth를 사용하여 플러터 앱에 인증을 통합하는 견고한 기반을 갖추게 될 것입니다. 이를 통해 사용자가 계정을 만들고 로그인하여 안전한 콘텐츠에 액세스할 수 있습니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-21-GettingStartedwithServerpodAuthenticationPart1"},"buildId":"9ddMoNNI_mr3kv4sKx3b_","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>