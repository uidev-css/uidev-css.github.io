<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>엘로퀀트 깊숙한 학습 라라벨 개발자가 반드시 알아야 할 40가지 잘 사용되지 않는 엘로퀀트 ORM 메서드 | uidev-css</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://uidev-css.github.io///post/2024-06-19-DeepDiveintoEloquent40RarelyUsedEloquentORMMethodsEveryLaravelDeveloperMUSTKnow" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="엘로퀀트 깊숙한 학습 라라벨 개발자가 반드시 알아야 할 40가지 잘 사용되지 않는 엘로퀀트 ORM 메서드 | uidev-css" data-gatsby-head="true"/><meta property="og:title" content="엘로퀀트 깊숙한 학습 라라벨 개발자가 반드시 알아야 할 40가지 잘 사용되지 않는 엘로퀀트 ORM 메서드 | uidev-css" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-19-DeepDiveintoEloquent40RarelyUsedEloquentORMMethodsEveryLaravelDeveloperMUSTKnow_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://uidev-css.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://uidev-css.github.io///post/2024-06-19-DeepDiveintoEloquent40RarelyUsedEloquentORMMethodsEveryLaravelDeveloperMUSTKnow" data-gatsby-head="true"/><meta name="twitter:title" content="엘로퀀트 깊숙한 학습 라라벨 개발자가 반드시 알아야 할 40가지 잘 사용되지 않는 엘로퀀트 ORM 메서드 | uidev-css" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-19-DeepDiveintoEloquent40RarelyUsedEloquentORMMethodsEveryLaravelDeveloperMUSTKnow_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | uidev-css" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-19 14:42" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b75a4bf98ee956a8.js" defer=""></script><script src="/_next/static/-8k4Xu2rlgTZWfP5qtaGa/_buildManifest.js" defer=""></script><script src="/_next/static/-8k4Xu2rlgTZWfP5qtaGa/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UIDEV CSS</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">엘로퀀트 깊숙한 학습 라라벨 개발자가 반드시 알아야 할 40가지 잘 사용되지 않는 엘로퀀트 ORM 메서드</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="엘로퀀트 깊숙한 학습 라라벨 개발자가 반드시 알아야 할 40가지 잘 사용되지 않는 엘로퀀트 ORM 메서드" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UIDEV CSS</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 19, 2024</span><span class="posts_reading_time__f7YPP">16<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-19-DeepDiveintoEloquent40RarelyUsedEloquentORMMethodsEveryLaravelDeveloperMUSTKnow&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>안녕하세요! 엘로퀀트에 대해 얼마나 잘 아시나요?</p>
<p>라라벨의 엘로퀀트 ORM은 매우 강력한 도구로, 표현력이 풍부하고 우아한 구문을 사용하여 데이터베이스와 상호 작용할 수 있는 기능을 제공합니다. 많은 개발자들이 find(), where(), first(), get(), save()와 같은 일반적인 메서드를 잘 알고 있지만, 워크플로우를 크게 향상시킬 수 있는 몇 가지 잘 알려지지 않은 메서드들이 있습니다. 이 글에서는 이러한 잘 알려지지 않지만 매우 유용한 엘로퀀트 ORM 메서드 중 일부를 살펴보겠습니다.</p>
<p>일반적인 메서드부터 시작해서 가장 좋은 메서드로 이동해보겠습니다. 여러분은 응용 프로그램의 속도와 효율성을 실제로 향상시킬 수 있는 많은 아름다운 메서드를 보게 될 것입니다. 함께 알아보도록 하죠.</p>
<h1>1. tap()</h1>
<p>왜: 모델에 변경사항을 적용하고 메서드 체이닝을 위해 모델 자체를 반환합니다.</p>
<p>언제: 객체를 수정하고 즉시 다른 작업에 사용하고 싶을 때 사용하세요.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">User</span>::<span class="hljs-title function_">find</span>(<span class="hljs-number">1</span>)-><span class="hljs-title function_">tap</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">$user</span>) {
    $user->name = <span class="hljs-string">'Updated Name'</span>;
})-><span class="hljs-title function_">save</span>();
</code></pre>
<h1>2. firstOrFail()</h1>
<p>왜: 유효한 결과를 얻거나 결과가 없는 경우를 처리하기 위해 사용합니다.</p>
<p>언제: 특정 레코드를 가져 와서 존재하지 않는 경우에 오류를 throw하고 싶을 때 사용합니다.</p>
<pre><code class="hljs language-js">$user = <span class="hljs-title class_">User</span>::<span class="hljs-title function_">where</span>(<span class="hljs-string">'email'</span>, <span class="hljs-string">'example@example.com'</span>)-><span class="hljs-title function_">firstOrFail</span>();
<span class="hljs-comment">// 사용자 세부 정보 처리</span>
</code></pre>
<h1>3. updateOrCreate()</h1>
<p>왜: 기존 레코드를 업데이트하거나 새로운 레코드를 생성하여 중복 항목을 방지하기 위해서입니다.</p>
<p>언제: 레코드가 존재하지 않으면 생성되고, 존재한다면 업데이트되도록 하고 싶을 때 사용합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">User</span>::<span class="hljs-title function_">updateOrCreate</span>(
    [<span class="hljs-string">'email'</span> => <span class="hljs-string">'example@example.com'</span>],
    [<span class="hljs-string">'name'</span> => <span class="hljs-string">'John Doe'</span>]
);
</code></pre>
<h1>4. increment() / decrement()</h1>
<p>이 부분을 정말 좋아해요. 직관적이고 아름다워요. 언제 사용하나요?
언제 사용: 숫자 열을 하나 이상 증가시키거나 감소시킬 때 사용합니다.</p>
<p>왜 사용하나요: 숫자 열의 값을 효율적으로 업데이트하기 위해.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">User</span>::<span class="hljs-title function_">where</span>(<span class="hljs-string">'id'</span>, <span class="hljs-number">1</span>)-><span class="hljs-title function_">increment</span>(<span class="hljs-string">'points'</span>); <span class="hljs-comment">// 만약 points가 7이면 이제 8이 될 것입니다</span>
<span class="hljs-title class_">User</span>::<span class="hljs-title function_">where</span>(<span class="hljs-string">'id'</span>, <span class="hljs-number">1</span>)-><span class="hljs-title function_">decrement</span>(<span class="hljs-string">'points'</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// 만약 7이면 2가 될 것입니다</span>
</code></pre>
<h1>5. withTrashed() / onlyTrashed() / restore()</h1>
<p>이 그룹의 메소드들은 라라벨에서 Soft Deletes 기능을 관리하는 데 사용됩니다.
나는 Soft Deletes에 관한 모든 것을 다룬 매우 상세한 기사를 썼어.</p>
<p>왜: Soft 삭제된 레코드를 관리하기 위해.
언제: 이러한 메소드를 사용하여 Soft 삭제된 레코드를 포함하거나 오직 포함하거나 되찾을 때.</p>
<pre><code class="hljs language-js">$users = <span class="hljs-title class_">User</span>::<span class="hljs-title function_">withTrashed</span>()-><span class="hljs-title function_">get</span>();
$trashedUsers = <span class="hljs-title class_">User</span>::<span class="hljs-title function_">onlyTrashed</span>()-><span class="hljs-title function_">get</span>();
<span class="hljs-title class_">User</span>::<span class="hljs-title function_">withTrashed</span>()-><span class="hljs-title function_">where</span>(<span class="hljs-string">'id'</span>, <span class="hljs-number">1</span>)-><span class="hljs-title function_">restore</span>();
</code></pre>
<h1>6. withoutEvents()</h1>
<p>왜: 이벤트 리스너가 작동하는 것을 방지합니다.
언제: 일괄 가져오기와 같이 이벤트를 발생시키지 않아야 하는 작업을 수행할 때 사용합니다.</p>
<p>외부 시스템에서 대량의 사용자를 가져오고 각 가져온 사용자에 대해 UserCreated 이벤트를 트리거하고 싶지 않아서 환영 이메일을 보내거나 생성마다 로깅하는 것을 피하려고 한다고 상상해보세요.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">User</span>::<span class="hljs-title function_">withoutEvents</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-title class_">User</span>::<span class="hljs-title function_">create</span>([
      <span class="hljs-string">'name'</span> => <span class="hljs-string">'John Doe'</span>, 
      <span class="hljs-string">'email'</span> => <span class="hljs-string">'john@example.com'</span>
    ]);
    <span class="hljs-title class_">User</span>::<span class="hljs-title function_">create</span>([
      <span class="hljs-string">'name'</span> => <span class="hljs-string">'Jane Doe'</span>, 
      <span class="hljs-string">'email'</span> => <span class="hljs-string">'jane@example.com'</span>
    ]);
});
</code></pre>
<h1>7. withoutGlobalScopes()</h1>
<p><strong>왜 사용하나요:</strong> 전역 쿼리 제약을 우회하기 위해 사용합니다.
<strong>언제 사용하나요:</strong> is_published와 같은 전역 스코프를 무시하고 모든 레코드를 가져와야 할 때 사용합니다.</p>
<p>당신의 애플리케이션에는 발행된 게시물만 포함하는 전역 스코프를 가진 Post 모델이 있는 상황을 상상해보세요. 관리자는 컨텐츠를 효율적으로 관리하기 위해 초안 및 미게시된 게시물을 포함한 모든 게시물을 볼 수도 있어야 할 것입니다.</p>
<p>전역 스코프를 무시하고 모든 게시물을 가져오기:</p>
<pre><code class="hljs language-js">$allPosts = <span class="hljs-title class_">Post</span>::<span class="hljs-title function_">withoutGlobalScopes</span>()-><span class="hljs-title function_">get</span>();
foreach ($allPosts <span class="hljs-keyword">as</span> $post) {
    echo $post->title . ($post->is_published ? <span class="hljs-string">' (Published)'</span> : <span class="hljs-string">' (Draft)'</span>) . <span class="hljs-string">"\n"</span>;
}
</code></pre>
<p>위 예시에서 withoutGlobalScopes()를 사용하면 관리자가 미게시된 포스트를 필터링하는 전역 범위를 우회하여 모든 포스트를 볼 수 있습니다.</p>
<p>withoutGlobalScopes()를 사용하는 것은 데이터에 대한 종합적인 액세스가 필요한 관리 작업이나 글로벌 제약 조건이 쿼리에 영향을 미치지 않도록 디버깅 및 테스트 중에 특히 유용합니다.</p>
<h1>10. is() / isNot()</h1>
<p>이것도 좋아요. 비교와 조건을 확인할 때 매우 간편하고 유용합니다.</p>
<p>왜 필요한가: 두 모델 인스턴스를 비교하기 위해.
언제 사용하는가: 두 모델이 동일한 인스턴스인지 확인할 때 사용합니다.</p>
<pre><code class="hljs language-js">$user1 = <span class="hljs-title class_">User</span>::<span class="hljs-title function_">find</span>(<span class="hljs-number">1</span>);
$user2 = <span class="hljs-title class_">User</span>::<span class="hljs-title function_">find</span>(<span class="hljs-number">2</span>);

<span class="hljs-keyword">if</span> ($user1-><span class="hljs-title function_">is</span>($user2)) {
    <span class="hljs-comment">// 동일한 사용자</span>
}

<span class="hljs-keyword">if</span> ($user1-><span class="hljs-title function_">isNot</span>($user2)) {
    <span class="hljs-comment">// 동일한 사용자가 아님</span>
}
</code></pre>
<h1>11. loadMissing()</h1>
<p>예시: User 모델이 있는데 그 모델은 게시물(posts) 관계를 갖고 있습니다. 사용자와 그들의 게시물을 함께 로드하고 싶지만, 게시물 관계가 이미 로드되었는지 확실하지 않을 때가 있습니다.</p>
<p>왜: 이미 로드되지 않은 관계를 조건부로 eager load하여 데이터베이스 쿼리를 최적화하고 N+1 쿼리 문제를 피하기 위해서입니다.</p>
<p>언제: loadMissing()을 사용할 때는 모델 인스턴스에 관계를 로드하고 싶지만 이미 로드되어 있지 않은 경우에만 사용합니다. 특히 특정 조건에 따라 동적으로 로드하고 싶은 조건부 관계 또는 이미 로드된 것들이 섞인 루프에서 관계를 로드할 때 유용합니다.</p>
<pre><code class="hljs language-js">$user = <span class="hljs-title class_">User</span>::<span class="hljs-title function_">find</span>(<span class="hljs-number">1</span>);

<span class="hljs-comment">// 'posts' 관계가 이미 로드되었는지 확인</span>
<span class="hljs-keyword">if</span> (!$user-><span class="hljs-title function_">relationLoaded</span>(<span class="hljs-string">'posts'</span>)) {
    <span class="hljs-comment">// 'posts' 관계는 이미 로드되어 있지 않다면 로드</span>
    $user-><span class="hljs-title function_">loadMissing</span>(<span class="hljs-string">'posts'</span>);
}

<span class="hljs-comment">// 이제 중복 쿼리 걱정 없이 'posts' 관계에 접근할 수 있습니다</span>
foreach ($user->posts <span class="hljs-keyword">as</span> $post) {
    echo $post->title . <span class="hljs-string">"\n"</span>;
}
</code></pre>
<h1>12. makeHidden() / makeVisible()</h1>
<p>왜: 모델 속성의 가시성을 제어하기 위해서입니다.
언제: 임시로 속성을 숨기거나 보여줄 때 사용합니다. 예를 들어 API 응답에서 사용합니다.</p>
<pre><code class="hljs language-js">$user = <span class="hljs-title class_">User</span>::<span class="hljs-title function_">find</span>(<span class="hljs-number">1</span>);
$user-><span class="hljs-title function_">makeHidden</span>(<span class="hljs-string">'email'</span>);
$user-><span class="hljs-title function_">makeVisible</span>(<span class="hljs-string">'email'</span>);
</code></pre>
<h1>13. touch()</h1>
<p>왜: updated_at 타임스탬프를 업데이트하려고.
언제: 다른 속성을 변경하지 않고 레코드를 업데이트된 것으로 표시하려면 사용하세요.</p>
<pre><code class="hljs language-js">$user = <span class="hljs-title class_">User</span>::<span class="hljs-title function_">find</span>(<span class="hljs-number">1</span>);
$user-><span class="hljs-title function_">touch</span>();
</code></pre>
<h1>14. append()</h1>
<p>왜: 모델의 배열이나 JSON 형식에 사용자 정의 속성을 추가하려고.
언제: 모델의 표현에 추가적인 계산된 속성을 포함하고 싶을 때 사용하세요.</p>
<pre><code class="hljs language-php"><span class="hljs-variable">$user</span> = <span class="hljs-title class_">User</span>::<span class="hljs-title function_ invoke__">find</span>(<span class="hljs-number">1</span>);
<span class="hljs-variable">$user</span>-><span class="hljs-title function_ invoke__">append</span>(<span class="hljs-string">'custom_attribute'</span>);
</code></pre>
<p>안녕하세요! Laravel에서 Json 데이터를 관리하는 방법에 대한 매우 포괄적이고 단계별 자습서를 작성했습니다.</p>
<h1>15. replicate()</h1>
<p>왜: 모델 인스턴스를 복제하기 위함.
언제: 템플릿을 복제하는 것과 같이 동일한 속성을 가진 새 인스턴스를 생성할 때 사용합니다.</p>
<pre><code class="hljs language-php"><span class="hljs-variable">$user</span> = <span class="hljs-title class_">User</span>::<span class="hljs-title function_ invoke__">find</span>(<span class="hljs-number">1</span>);
<span class="hljs-variable">$newUser</span> = <span class="hljs-variable">$user</span>-><span class="hljs-title function_ invoke__">replicate</span>(); <span class="hljs-comment">// $newUser is matches to $user</span>
<span class="hljs-variable">$newUser</span>-><span class="hljs-title function_ invoke__">save</span>();
</code></pre>
<h2>16. chunkById()</h2>
<p>테이블에 20,000,000개의 레코드가 있는 상황을 상상해보세요. 각 레코드에 대해 작업을 수행해야합니다. 이를 어떻게 해야 할까요?</p>
<p>왜: 대규모 데이터 세트를 효율적으로 처리하는 데 사용합니다.
언제: 대규모 데이터 세트를 처리하여 메모리를 효율적으로 처리하고 대형 테이블에서 더 나은 성능을 얻을 수 있습니다.</p>
<p>특정 작업을 수행해야 하는 20,000,000개 레코드가 있는 데이터베이스 테이블이 있다고 가정해보세요.</p>
<pre><code class="hljs language-js">use <span class="hljs-title class_">App</span>\<span class="hljs-title class_">Models</span>\<span class="hljs-title class_">YourModel</span>;

<span class="hljs-title class_">YourModel</span>::<span class="hljs-title function_">orderBy</span>(<span class="hljs-string">'id'</span>)-><span class="hljs-title function_">chunkById</span>(<span class="hljs-number">1000</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">$records</span>) {
    foreach ($records <span class="hljs-keyword">as</span> $record) {
        <span class="hljs-comment">// 각 레코드 처리</span>
    }
});
</code></pre>
<p>참고: chunk()라는 유사한 메소드가 있습니다. 이러한 두 메소드는 유사한 작업을 수행하지만 차이점이 있습니다. 두 가지 모두 대규모 데이터셋을 효율적으로 일괄 처리하여 메모리 과부하를 방지하고 성능을 최적화합니다. 두 메소드는 한 번에 전체 데이터셋을 한꺼번에 메모리로 로드하지 않고 대규모 데이터셋을 이터레이션할 수 있도록 허용합니다. 그러나 데이터 배치를 결정하는 방식에서 차이가 있습니다:</p>
<p>chunk():</p>
<ul>
<li>chunk()은 첫 번째 매개변수로 지정된 청크 당 레코드 수에 따라 데이터 세트를 청크로 나눕니다.</li>
<li>특정한 순서를 고려하지 않고 데이터베이스 테이블에서 레코드를 순차적으로 검색합니다.</li>
<li>각 청크의 레코드는 데이터베이스에서 검색된 순서에 기반하여 가져오며, 주로 기본 키 순서에 따라 순서가 지정되지 않을 수 있습니다.</li>
<li>처리 순서가 중요하지 않거나 데이터를 작은 관리 가능한 청크로 처리해야 할 때이 유용한 방법입니다.</li>
</ul>
<p>chunkById():</p>
<ul>
<li>chunkById()는 레코드의 기본 키(일반적으로 id) 순서를 기반으로 데이터 세트를 청크로 나눕니다.</li>
<li>데이터베이스 테이블에서 레코드를 기본 키 순서에 따라 순차적으로 검색합니다.</li>
<li>각 청크에는 지정된 범위 내의 기본 키를 갖고 있는 레코드가 포함되어, 레코드가 기본 키 순서로 처리되도록 보장합니다.</li>
<li>데이터 마이그레이션이나 기본 키 순서를 기반으로 순차 처리가 필요한 데이터 업데이트와 같은 작업을 수행할 때 유용한 방법입니다.</li>
</ul>
<h1>17. existsOr()</h1>
<p><strong>왜</strong>: 모델이 존재하는 경우 콜백을 실행하거나 기본값을 반환합니다.<br>
<strong>언제</strong>: 사용자 정의 로직으로 존재 여부를 처리해야 할 때 사용합니다.</p>
<pre><code class="hljs language-js">$exists = <span class="hljs-title class_">User</span>::<span class="hljs-title function_">where</span>(<span class="hljs-string">'email'</span>, <span class="hljs-string">'example@example.com'</span>)-><span class="hljs-title function_">existsOr</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'User does not exist'</span>;
});
</code></pre>
<h1>18. firstOrCreate()</h1>
<p><strong>왜</strong>: 단계를 한 번에 기록을 검색하거나 생성하기 위해 사용합니다.<br>
<strong>언제</strong>: 필요한 경우 레코드를 업데이트하거나 생성하여 중복된 항목을 피하기 위해 사용합니다.</p>
<pre><code class="hljs language-js">$user = <span class="hljs-title class_">User</span>::<span class="hljs-title function_">firstOrCreate</span>([<span class="hljs-string">'email'</span> => <span class="hljs-string">'example@example.com'</span>], [<span class="hljs-string">'name'</span> => <span class="hljs-string">'John Doe'</span>]);
</code></pre>
<h1>19. firstOrNew()</h1>
<p>왜: 저장하지 않고 기존 레코드를 검색하거나 새 레코드를 만들기 위해 사용합니다.
언제: 기존 레코드를 가져 오거나 영구적으로 저장하지 않고 새 인스턴스를 만들기 위해 사용합니다.</p>
<pre><code class="hljs language-js">$user = <span class="hljs-title class_">User</span>::<span class="hljs-title function_">firstOrNew</span>([<span class="hljs-string">'email'</span> => <span class="hljs-string">'example@example.com'</span>], [<span class="hljs-string">'name'</span> => <span class="hljs-string">'John Doe'</span>]);
</code></pre>
<h1>20. <code>sole()</code></h1>
<p>왜: 하나의 레코드만 가져오거나 예외를 발생시키기 위해 사용합니다.
언제 사용: 단일하고 고유한 결과를 예상하고 중복을 오류로 처리하고 싶은 경우에 사용합니다.</p>
<pre><code class="hljs language-js">$user = <span class="hljs-title class_">User</span>::<span class="hljs-title function_">where</span>(<span class="hljs-string">'email'</span>, <span class="hljs-string">'example@example.com'</span>)-><span class="hljs-title function_">sole</span>();
</code></pre>
<h1>21. <code>findMany()</code></h1>
<p>테이블 태그를 Markdown 형식으로 변경하세요.</p>
<p>Why: 여러 개의 기본 키로 레코드를 검색하기 위해 사용합니다.
When: 여러 개의 ID가 포함된 배열을 사용하여 한 번에 여러 레코드를 가져오는 데 사용합니다.</p>
<pre><code class="hljs language-js">$users = <span class="hljs-title class_">User</span>::<span class="hljs-title function_">findMany</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);
</code></pre>
<h2>22. update()</h2>
<p>Why: 한 번에 여러 레코드를 업데이트하기 위해 사용합니다.
When: 대량 업데이트를 효율적으로 수행하기 위해 사용합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">User</span>::<span class="hljs-title function_">where</span>(<span class="hljs-string">'status'</span>, <span class="hljs-string">'active'</span>)-><span class="hljs-title function_">update</span>([<span class="hljs-string">'status'</span> => <span class="hljs-string">'inactive'</span>]);
</code></pre>
<h1>23. forceDelete()</h1>
<p>Why: 소프트 삭제된 모델을 영구적으로 삭제하려면 사용하세요.
When: 레코드를 완전히 제거하여 소프트 삭제를 우회할 때 사용하세요.</p>
<pre><code class="hljs language-js">$user = <span class="hljs-title class_">User</span>::<span class="hljs-title function_">withTrashed</span>()-><span class="hljs-title function_">find</span>(<span class="hljs-number">1</span>);
$user-><span class="hljs-title function_">forceDelete</span>();
</code></pre>
<h1>24. getDirty()</h1>
<p>이 함수 정말 좋아요. 이 함수를 사용하면 데이터베이스에 저장되기 전 모델에서 변경된 모든 내용을 알 수 있어요.</p>
<p>왜: 변경된 속성들을 확인하려고요.
언제: 저장하기 전에 수정된 속성들을 확인할 때 사용하세요.</p>
<pre><code class="hljs language-js">$user = <span class="hljs-title class_">User</span>::<span class="hljs-title function_">find</span>(<span class="hljs-number">1</span>);
$user->name = <span class="hljs-string">'새로운 이름'</span>;
$dirty = $user-><span class="hljs-title function_">getDirty</span>();
</code></pre>
<h1>25. getOriginal()</h1>
<p>왜: 모델 속성의 원래 값 가져오기 위해 사용합니다.
언제: 변경 전 현재 값과 원래 값 비교할 때 사용합니다.</p>
<pre><code class="hljs language-js">$user = <span class="hljs-title class_">User</span>::<span class="hljs-title function_">find</span>(<span class="hljs-number">1</span>);
$original = $user-><span class="hljs-title function_">getOriginal</span>(<span class="hljs-string">'name'</span>);
</code></pre>
<h1>26. setRelation()</h1>
<p>왜: 모델에 특정 관계를 설정하기 위해 사용합니다.
언제: 모델 인스턴스에 수동으로 관계를 정의할 때 사용합니다.</p>
<pre><code class="hljs language-js">$user = <span class="hljs-title class_">User</span>::<span class="hljs-title function_">find</span>(<span class="hljs-number">1</span>);
$user-><span class="hljs-title function_">setRelation</span>(<span class="hljs-string">'posts'</span>, $posts);
</code></pre>
<h1>27. without()</h1>
<p>왜: 쿼리에서 특정 관계를 제외하기 위해 사용합니다.
언제: 불필요한 관계를 제외하여 쿼리를 최적화할 때 사용합니다.</p>
<pre><code class="hljs language-javascript">$user = <span class="hljs-title class_">User</span>::<span class="hljs-title function_">with</span>(<span class="hljs-string">'posts'</span>, <span class="hljs-string">'comments'</span>)-><span class="hljs-title function_">without</span>(<span class="hljs-string">'comments'</span>)-><span class="hljs-title function_">find</span>(<span class="hljs-number">1</span>);
</code></pre>
<h2>28. preventLazyLoading()</h2>
<p>왜: 관계의 게으른 로딩을 방지합니다.
언제: 개발 중에 의도하지 않은 게으른 로딩을 방지하려면 사용하세요.</p>
<pre><code class="hljs language-javascript"><span class="hljs-title class_">Model</span>::<span class="hljs-title function_">preventLazyLoading</span>(!<span class="hljs-title function_">app</span>()-><span class="hljs-title function_">isProduction</span>());
</code></pre>
<h1>29. withoutTimestamps()</h1>
<p>왜: created_at 및 updated_at 타임스탬프의 업데이트를 비활성화합니다.
언제: 가져오기와 같이 타임스탬프 업데이트를 트리거해서는 안 되는 작업에 사용합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">User</span>::<span class="hljs-title function_">withoutTimestamps</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-title class_">User</span>::<span class="hljs-title function_">create</span>([<span class="hljs-string">'name'</span> => <span class="hljs-string">'John Doe'</span>]);
});
</code></pre>
<h1>30. withCasts()</h1>
<p>라라벨은 모델 속성에 동적으로 캐스팅 규칙을 적용할 수 있습니다. 특정 조건이나 런타임 시나리오에 따라 속성을 어떻게 캐스팅할지 실시간으로 변경할 필요가 있을 때 유용합니다. 예를 들어 사용자 입력이나 데이터베이스 값에 따라 속성을 다른 유형으로 캐스팅할 수 있어 데이터 일관성과 애플리케이션의 유연성을 보장할 수 있습니다.</p>
<p>왜: 캐스팅 규칙을 동적으로 적용하기 위해.
언제: 속성을 실시간으로 어떻게 캐스팅할지 변경할 때.</p>
<pre><code class="hljs language-js">$user = <span class="hljs-title class_">User</span>::<span class="hljs-title function_">withCasts</span>([<span class="hljs-string">'is_admin'</span> => <span class="hljs-string">'boolean'</span>])-><span class="hljs-title function_">find</span>(<span class="hljs-number">1</span>);
</code></pre>
<h1>31. upsert()</h1>
<p>왜: 일치하는 기준에 따라 레코드를 삽입하거나 업데이트하기 위해서입니다.
언제: 대량 삽입 또는 업데이트를 수행하여 중복 항목을 피하기 위해 사용합니다.</p>
<p>고유 식별자로 이메일 열을 갖는 사용자 테이블이 있다고 가정해보세요. 해당 테이블에 이메일이 이미 존재하지 않는 경우 새 사용자를 삽입하거나 이미 존재하는 경우 이메일에 해당하는 이름을 업데이트하려고 합니다.</p>
<pre><code class="hljs language-js">use <span class="hljs-title class_">App</span>\<span class="hljs-title class_">Models</span>\<span class="hljs-title class_">User</span>;

<span class="hljs-title class_">User</span>::<span class="hljs-title function_">upsert</span>([
    [<span class="hljs-string">'email'</span> => <span class="hljs-string">'john@example.com'</span>, <span class="hljs-string">'name'</span> => <span class="hljs-string">'John Doe'</span>],
    [<span class="hljs-string">'email'</span> => <span class="hljs-string">'jane@example.com'</span>, <span class="hljs-string">'name'</span> => <span class="hljs-string">'Jane Doe'</span>]
], [<span class="hljs-string">'email'</span>], [<span class="hljs-string">'name'</span>]);
</code></pre>
<h1>32. 스코프</h1>
<p>왜: 재사용 가능한 쿼리 스코프를 정의하는 데 사용합니다.
언제: 여러 쿼리에 일반적인 쿼리 제약을 적용하는 데 사용합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 사용자 모델에서</span>
public <span class="hljs-keyword">function</span> <span class="hljs-title function_">scopeActive</span>(<span class="hljs-params">$query</span>)
{
    <span class="hljs-keyword">return</span> $query-><span class="hljs-title function_">where</span>(<span class="hljs-string">'status'</span>, <span class="hljs-string">'active'</span>);
}

<span class="hljs-comment">// 사용 방법</span>
$activeUsers = <span class="hljs-title class_">User</span>::<span class="hljs-title function_">active</span>()-><span class="hljs-title function_">get</span>();
</code></pre>
<h1>33. macro()</h1>
<p>이 메소드를 너무 좋아합니다. 원하는대로 사용자 정의한 고유한 메소드를 생성하는 데 사용할 수 있습니다.</p>
<p>왜: Eloquent 쿼리 빌더에 사용자 정의 메서드를 정의하기 위해.
언제: 쿼리 빌더를 확장하여 자체 메서드를 추가하는 데 사용됩니다.</p>
<p>당신의 응용 프로그램에서 사용자의 역할에 따라 사용자를 필터링해야 하는 경우가 자주 있습니다. 이 작업을 간단히 하기 위해 쿼리 빌더에 role()이라는 사용자 지정 매크로를 정의할 수 있습니다.</p>
<pre><code class="hljs language-js">use <span class="hljs-title class_">Illuminate</span>\<span class="hljs-title class_">Database</span>\<span class="hljs-title class_">Eloquent</span>\<span class="hljs-title class_">Builder</span>;

<span class="hljs-comment">// 'role' 매크로 정의</span>
<span class="hljs-title class_">Builder</span>::<span class="hljs-title function_">macro</span>(<span class="hljs-string">'role'</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">$role</span>) {
    <span class="hljs-keyword">return</span> $this-><span class="hljs-title function_">where</span>(<span class="hljs-string">'role'</span>, $role);
});

<span class="hljs-comment">// 사용 예</span>
$admins = <span class="hljs-title class_">User</span>::<span class="hljs-title function_">role</span>(<span class="hljs-string">'admin'</span>)-><span class="hljs-title function_">get</span>();
$customers = <span class="hljs-title class_">User</span>::<span class="hljs-title function_">role</span>(<span class="hljs-string">'customer'</span>)-><span class="hljs-title function_">get</span>();
</code></pre>
<h1>34. filter()</h1>
<p><strong>왜</strong>: 동적 쿼리 필터를 적용하기 위해 사용합니다.
<strong>언제</strong>: 요청 매개변수를 기반으로 여러 필터를 적용하기 위해 사용하세요.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 사용자 모델 내부에서</span>
public <span class="hljs-keyword">function</span> <span class="hljs-title function_">scopeFilter</span>(<span class="hljs-params">$query, $filters</span>)
{
    <span class="hljs-keyword">return</span> $filters-><span class="hljs-title function_">apply</span>($query);
}

<span class="hljs-comment">// 사용법</span>
$filters = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserFilters</span>([<span class="hljs-string">'status'</span> => <span class="hljs-string">'active'</span>]);
$filteredUsers = <span class="hljs-title class_">User</span>::<span class="hljs-title function_">filter</span>($filters)-><span class="hljs-title function_">get</span>();
</code></pre>
<p>이 예제에서는 User 모델에 filter() scope를 정의하여 필터 세트를 전달 받습니다. 이러한 필터는 UserFilters 객체의 apply() 메서드를 사용하여 쿼리에 적용될 수 있습니다. 이를 통해 $filters 변수에 지정된 다양한 기준에 따라 사용자를 동적으로 필터링할 수 있습니다.</p>
<p>filter()를 사용하면 데이터베이스 쿼리를 변화하는 요구 사항과 사용자 입력에 더 적응 가능하게 만들어 Laravel 애플리케이션에서 더 유연하고 동적인 데이터 검색이 가능해집니다.</p>
<h1>35. whereJsonContains()</h1>
<p>왜: 특정 값을 가진 JSON 열을 조회하기 위해 사용합니다.
언제: 배열 또는 객체를 포함하는 JSON 열을 조회할 때 사용합니다.</p>
<pre><code class="hljs language-js">$users = <span class="hljs-title class_">User</span>::<span class="hljs-title function_">whereJsonContains</span>(<span class="hljs-string">'options->languages'</span>, <span class="hljs-string">'en'</span>)-><span class="hljs-title function_">get</span>();
</code></pre>
<p>라라벨에서 JSON에 관한 모든 것에 대한 문서가 있습니다. 이 곳을 확인해보세요.</p>
<h1>36. findOr()</h1>
<p>왜: 모델을 검색하거나 찾을 수 없을 때 콜백을 실행하는 데 사용합니다.
언제: 레코드가 없을 때 사용자 정의 로직을 처리할 때 사용하세요.</p>
<pre><code class="hljs language-js">$user = <span class="hljs-title class_">User</span>::<span class="hljs-title function_">findOr</span>(<span class="hljs-number">1</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'사용자를 찾을 수 없습니다'</span>;
});
</code></pre>
<h1>37. lockForUpdate()</h1>
<p>Laravel의 Eloquent ORM에 있는 lockForUpdate() 메서드는 트랜잭션 내에서 데이터베이스 행을 업데이트하기 위해 잠그는 데 사용됩니다. 이 메서드를 쿼리에 적용하면 현재 트랜잭션이 완료될 때까지 선택된 행을 수정하는 다른 데이터베이스 트랜잭션이 방지됩니다. 이를 통해 데이터 일관성을 유지하고 여러 트랜잭션이 동시에 같은 행을 업데이트하려고 할 때 충돌을 방지합니다.</p>
<p>왜: 쿼리에 "for update" 잠금을 적용합니다.
언제: 여러 트랜잭션이 귀하의 트랜잭션 중에 행을 수정하는 것을 방지할 때 사용합니다.</p>
<pre><code class="hljs language-js">$user = <span class="hljs-title class_">User</span>::<span class="hljs-title function_">where</span>(<span class="hljs-string">'email'</span>, <span class="hljs-string">'example@example.com'</span>)-><span class="hljs-title function_">lockForUpdate</span>()-><span class="hljs-title function_">first</span>();
</code></pre>
<h1>38. sharedLock()</h1>
<p>왜: 쿼리에 "공유 락"을 적용하려면
언제: 트랜잭션 기간 동안 선택한 행을 잠그는 데 사용합니다.</p>
<p>금융 애플리케이션이 있다고 가정해보겠습니다. 사용자가 계정 잔액을 볼 수 있는 애플리케이션입니다. 사용자가 잔액을 확인할 때, 다른 트랜잭션이 동시에 계정 잔액을 업데이트하더라도 표시된 금액이 일관되게 유지되도록 보장하고 싶습니다. 이러한 경우에는 트랜잭션 중 사용자 계정에 해당하는 행을 잠글 때 sharedLock()을 사용할 수 있습니다.</p>
<pre><code class="hljs language-js">use <span class="hljs-title class_">App</span>\<span class="hljs-title class_">Models</span>\<span class="hljs-title class_">Account</span>;

<span class="hljs-attr">DB</span>::<span class="hljs-title function_">transaction</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) use ($userId) {
    $account = <span class="hljs-title class_">Account</span>::<span class="hljs-title function_">where</span>(<span class="hljs-string">'user_id'</span>, $userId)-><span class="hljs-title function_">sharedLock</span>()-><span class="hljs-title function_">first</span>();
    <span class="hljs-comment">// 사용자의 계정 잔액 표시</span>
});
</code></pre>
<h1>39. withSum()</h1>
<p>왜: 관련 모델 속성의 합계를 결과에 추가하려고 합니다.
언제: 주문 총액을 합산하는 등 관련 모델에서 데이터를 집계해야 할 때 사용합니다.</p>
<pre><code class="hljs language-js">$users = <span class="hljs-title class_">User</span>::<span class="hljs-title function_">withSum</span>(<span class="hljs-string">'posts'</span>, <span class="hljs-string">'views'</span>)-><span class="hljs-title function_">get</span>(); <span class="hljs-comment">// 총 게시물</span>
</code></pre>
<p>예를 들어 User 모델이 있고 각 사용자가 여러 주문을 가질 수 있다고 가정합니다. 사용자 목록과 주문 금액의 총 합을 함께 검색하려면 withSum()을 사용할 수 있습니다.</p>
<pre><code class="hljs language-js">use <span class="hljs-title class_">App</span>\<span class="hljs-title class_">Models</span>\<span class="hljs-title class_">User</span>;

$usersWithTotalOrderAmount = <span class="hljs-title class_">User</span>::<span class="hljs-title function_">withSum</span>(<span class="hljs-string">'orders'</span>, <span class="hljs-string">'amount'</span>)-><span class="hljs-title function_">get</span>();

foreach ($usersWithTotalOrderAmount <span class="hljs-keyword">as</span> $user) {
    echo <span class="hljs-string">"User: {$user->name}, Total Order Amount: {$user->orders_sum_amount}\n"</span>;
}
</code></pre>
<p>이 예제에서는 <code>orders</code> 관계에서 각 사용자의 금액 열의 총 합계를 검색하기 위해 withSum(<code>orders</code>, <code>amount</code>)이 사용됩니다. 집계된 합계는 각 사용자 객체의 동적으로 생성된 속성 (orders_sum_amount)으로 사용할 수 있습니다.</p>
<p>withSum()을 사용하여 주 쿼리 결과와 관련된 모델에서 집계된 데이터를 효율적으로 검색하여 코드를 간단하게하고 성능을 향상시킬 수 있습니다.</p>
<h1>40. withCount()</h1>
<p>Laravel의 Eloquent ORM에서 withCount() 메서드는 관련된 모델과 관련 모델의 수를 함께 검색하는 데 사용됩니다. 이것은 추가 쿼리를 수행하거나 수동 계산을 필요로하지 않고 연결된 레코드 수를 검색하려는 경우 유용합니다.</p>
<p>왜: 관련된 모델의 수를 셀 때 사용합니다.
언제: 사용자 당 게시물 수와 같이 관련 레코드 수를 얻을 때 사용합니다.</p>
<pre><code class="hljs language-js">use <span class="hljs-title class_">App</span>\<span class="hljs-title class_">Models</span>\<span class="hljs-title class_">User</span>;

$usersWithPostCounts = <span class="hljs-title class_">User</span>::<span class="hljs-title function_">withCount</span>(<span class="hljs-string">'posts'</span>)-><span class="hljs-title function_">get</span>();

foreach ($usersWithPostCounts <span class="hljs-keyword">as</span> $user) {
    echo <span class="hljs-string">"User: {$user->name}, Post Count: {$user->posts_count}\n"</span>;
}
</code></pre>
<p>위 예시에서 withCount('posts')는 각 사용자와 관련된 게시물 수를 검색하는 데 사용됩니다. 게시물 수는 각 사용자 객체의 동적으로 생성된 속성(posts_count)로 사용할 수 있습니다.</p>
<p>withCount()를 사용하면 주 쿼리 결과와 함께 데이터베이스로부터 관련 레코드의 수를 효율적으로 검색하여 코드를 단순화하고 성능을 향상시킬 수 있습니다.</p>
<h1>결론</h1>
<p>우리는 Eloquent에 대해 정말 깊게 알아보았습니다. Laravel 개발자라면 꼭 알아야 할 40가지 사용 빈도가 적은 Eloquent ORM 메서드를 논의했으니 즐기세요!</p>
<p>하지만 마지막까지 읽어준 선물로, 여기 워크플로우를 향상시키고 생산성을 향상시킬 10가지 더 많은 메서드가 있습니다.</p>
<ul>
<li>oldest(): 지정된 열을 기준으로 쿼리 결과를 오름차순으로 정렬합니다.</li>
<li>latest(): 지정된 열을 기준으로 쿼리 결과를 내림차순으로 정렬합니다.</li>
<li>has(): 관계가 있는 레코드만 포함하도록 쿼리를 필터링합니다.</li>
<li>whereHas(): 특정 조건과 일치하는 관계가 있는 레코드만 포함하도록 쿼리를 필터링합니다.</li>
<li>doesntHave(): 관계가 없는 레코드만 포함하도록 쿼리를 필터링합니다.</li>
<li>whereDoesntHave(): 특정 조건과 일치하는 관계가 없는 레코드만 포함하도록 쿼리를 필터링합니다.</li>
<li>withPivot(): 중간 테이블 열을 쿼리할 때 추가 피벗 테이블 열을 지정합니다.</li>
<li>morphTo(): 관련된 모델이 여러 소스 모델에 속할 수 있는 다형 관계를 정의합니다.</li>
<li>morphMany(): 관련된 모델이 여러 소스 모델에 속할 수 있는 다형 일대다 관계를 정의합니다.</li>
<li>morphToMany(): 관련된 모델이 여러 소스 모델에 속할 수 있는 다형 다대다 관계를 정의합니다.</li>
</ul>
<p>즐겁게 보내세요.</p>
<p>계속 주목하세요!!! 다음 기사에서는 멋진 Laravel 튜토리얼을 더 소개할 예정이에요. 기사가 마음에 드셨길 바래요. 저를 팔로우해주세요 😇 그리고 박수를 좀 👏 부탁드려요. 궁금한 점이 있으면 언제든지 댓글을 남겨주세요.</p>
<p>감사합니다.</p>
<p>끝까지 읽어주셔서 정말 감사합니다. 저를 팔로우하거나 연락할 수 있는 곳:
Twitter: <a href="https://twitter.com/EjimaduPrevail" rel="nofollow" target="_blank">https://twitter.com/EjimaduPrevail</a>
Email: <a href="mailto:prevailexcellent@gmail.com">prevailexcellent@gmail.com</a>
Github: <a href="https://github.com/PrevailExcel" rel="nofollow" target="_blank">https://github.com/PrevailExcel</a>
LinkedIn: <a href="https://www.linkedin.com/in/chimeremeze-prevail-ejimadu-3a3535219" rel="nofollow" target="_blank">https://www.linkedin.com/in/chimeremeze-prevail-ejimadu-3a3535219</a>
BuyMeCoffee: <a href="https://www.buymeacoffee.com/prevail" rel="nofollow" target="_blank">https://www.buymeacoffee.com/prevail</a>
Chimeremeze Prevail Ejimadu</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"엘로퀀트 깊숙한 학습 라라벨 개발자가 반드시 알아야 할 40가지 잘 사용되지 않는 엘로퀀트 ORM 메서드","description":"","date":"2024-06-19 14:42","slug":"2024-06-19-DeepDiveintoEloquent40RarelyUsedEloquentORMMethodsEveryLaravelDeveloperMUSTKnow","content":"\n\n\u003cimg src=\"/assets/img/2024-06-19-DeepDiveintoEloquent40RarelyUsedEloquentORMMethodsEveryLaravelDeveloperMUSTKnow_0.png\" /\u003e\n\n안녕하세요! 엘로퀀트에 대해 얼마나 잘 아시나요?\n\n라라벨의 엘로퀀트 ORM은 매우 강력한 도구로, 표현력이 풍부하고 우아한 구문을 사용하여 데이터베이스와 상호 작용할 수 있는 기능을 제공합니다. 많은 개발자들이 find(), where(), first(), get(), save()와 같은 일반적인 메서드를 잘 알고 있지만, 워크플로우를 크게 향상시킬 수 있는 몇 가지 잘 알려지지 않은 메서드들이 있습니다. 이 글에서는 이러한 잘 알려지지 않지만 매우 유용한 엘로퀀트 ORM 메서드 중 일부를 살펴보겠습니다.\n\n일반적인 메서드부터 시작해서 가장 좋은 메서드로 이동해보겠습니다. 여러분은 응용 프로그램의 속도와 효율성을 실제로 향상시킬 수 있는 많은 아름다운 메서드를 보게 될 것입니다. 함께 알아보도록 하죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 1. tap()\n\n왜: 모델에 변경사항을 적용하고 메서드 체이닝을 위해 모델 자체를 반환합니다.\n\n언제: 객체를 수정하고 즉시 다른 작업에 사용하고 싶을 때 사용하세요.\n\n```js\nUser::find(1)-\u003etap(function ($user) {\n    $user-\u003ename = 'Updated Name';\n})-\u003esave();\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 2. firstOrFail()\n\n왜: 유효한 결과를 얻거나 결과가 없는 경우를 처리하기 위해 사용합니다.\n\n언제: 특정 레코드를 가져 와서 존재하지 않는 경우에 오류를 throw하고 싶을 때 사용합니다.\n\n```js\n$user = User::where('email', 'example@example.com')-\u003efirstOrFail();\n// 사용자 세부 정보 처리\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 3. updateOrCreate()\n\n왜: 기존 레코드를 업데이트하거나 새로운 레코드를 생성하여 중복 항목을 방지하기 위해서입니다.\n\n언제: 레코드가 존재하지 않으면 생성되고, 존재한다면 업데이트되도록 하고 싶을 때 사용합니다.\n\n```js\nUser::updateOrCreate(\n    ['email' =\u003e 'example@example.com'],\n    ['name' =\u003e 'John Doe']\n);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 4. increment() / decrement()\n\n이 부분을 정말 좋아해요. 직관적이고 아름다워요. 언제 사용하나요?\n언제 사용: 숫자 열을 하나 이상 증가시키거나 감소시킬 때 사용합니다.\n\n왜 사용하나요: 숫자 열의 값을 효율적으로 업데이트하기 위해.\n\n```js\nUser::where('id', 1)-\u003eincrement('points'); // 만약 points가 7이면 이제 8이 될 것입니다\nUser::where('id', 1)-\u003edecrement('points', 5); // 만약 7이면 2가 될 것입니다\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 5. withTrashed() / onlyTrashed() / restore()\n\n이 그룹의 메소드들은 라라벨에서 Soft Deletes 기능을 관리하는 데 사용됩니다.\n나는 Soft Deletes에 관한 모든 것을 다룬 매우 상세한 기사를 썼어.\n\n왜: Soft 삭제된 레코드를 관리하기 위해.\n언제: 이러한 메소드를 사용하여 Soft 삭제된 레코드를 포함하거나 오직 포함하거나 되찾을 때.\n\n\n```js\n$users = User::withTrashed()-\u003eget();\n$trashedUsers = User::onlyTrashed()-\u003eget();\nUser::withTrashed()-\u003ewhere('id', 1)-\u003erestore();\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 6. withoutEvents()\n\n왜: 이벤트 리스너가 작동하는 것을 방지합니다.\n언제: 일괄 가져오기와 같이 이벤트를 발생시키지 않아야 하는 작업을 수행할 때 사용합니다.\n\n외부 시스템에서 대량의 사용자를 가져오고 각 가져온 사용자에 대해 UserCreated 이벤트를 트리거하고 싶지 않아서 환영 이메일을 보내거나 생성마다 로깅하는 것을 피하려고 한다고 상상해보세요.\n\n```js\nUser::withoutEvents(function () {\n    User::create([\n      'name' =\u003e 'John Doe', \n      'email' =\u003e 'john@example.com'\n    ]);\n    User::create([\n      'name' =\u003e 'Jane Doe', \n      'email' =\u003e 'jane@example.com'\n    ]);\n});\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 7. withoutGlobalScopes()\n\n**왜 사용하나요:** 전역 쿼리 제약을 우회하기 위해 사용합니다.\n**언제 사용하나요:** is_published와 같은 전역 스코프를 무시하고 모든 레코드를 가져와야 할 때 사용합니다.\n\n당신의 애플리케이션에는 발행된 게시물만 포함하는 전역 스코프를 가진 Post 모델이 있는 상황을 상상해보세요. 관리자는 컨텐츠를 효율적으로 관리하기 위해 초안 및 미게시된 게시물을 포함한 모든 게시물을 볼 수도 있어야 할 것입니다.\n\n전역 스코프를 무시하고 모든 게시물을 가져오기:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n$allPosts = Post::withoutGlobalScopes()-\u003eget();\nforeach ($allPosts as $post) {\n    echo $post-\u003etitle . ($post-\u003eis_published ? ' (Published)' : ' (Draft)') . \"\\n\";\n}\n```\n\n위 예시에서 withoutGlobalScopes()를 사용하면 관리자가 미게시된 포스트를 필터링하는 전역 범위를 우회하여 모든 포스트를 볼 수 있습니다.\n\nwithoutGlobalScopes()를 사용하는 것은 데이터에 대한 종합적인 액세스가 필요한 관리 작업이나 글로벌 제약 조건이 쿼리에 영향을 미치지 않도록 디버깅 및 테스트 중에 특히 유용합니다.\n\n# 10. is() / isNot()\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이것도 좋아요. 비교와 조건을 확인할 때 매우 간편하고 유용합니다.\n\n왜 필요한가: 두 모델 인스턴스를 비교하기 위해.\n언제 사용하는가: 두 모델이 동일한 인스턴스인지 확인할 때 사용합니다.\n\n```js\n$user1 = User::find(1);\n$user2 = User::find(2);\n\nif ($user1-\u003eis($user2)) {\n    // 동일한 사용자\n}\n\nif ($user1-\u003eisNot($user2)) {\n    // 동일한 사용자가 아님\n}\n```\n\n# 11. loadMissing()\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예시: User 모델이 있는데 그 모델은 게시물(posts) 관계를 갖고 있습니다. 사용자와 그들의 게시물을 함께 로드하고 싶지만, 게시물 관계가 이미 로드되었는지 확실하지 않을 때가 있습니다.\n\n왜: 이미 로드되지 않은 관계를 조건부로 eager load하여 데이터베이스 쿼리를 최적화하고 N+1 쿼리 문제를 피하기 위해서입니다.\n\n언제: loadMissing()을 사용할 때는 모델 인스턴스에 관계를 로드하고 싶지만 이미 로드되어 있지 않은 경우에만 사용합니다. 특히 특정 조건에 따라 동적으로 로드하고 싶은 조건부 관계 또는 이미 로드된 것들이 섞인 루프에서 관계를 로드할 때 유용합니다.\n\n```js\n$user = User::find(1);\n\n// 'posts' 관계가 이미 로드되었는지 확인\nif (!$user-\u003erelationLoaded('posts')) {\n    // 'posts' 관계는 이미 로드되어 있지 않다면 로드\n    $user-\u003eloadMissing('posts');\n}\n\n// 이제 중복 쿼리 걱정 없이 'posts' 관계에 접근할 수 있습니다\nforeach ($user-\u003eposts as $post) {\n    echo $post-\u003etitle . \"\\n\";\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 12. makeHidden() / makeVisible()\n\n왜: 모델 속성의 가시성을 제어하기 위해서입니다.\n언제: 임시로 속성을 숨기거나 보여줄 때 사용합니다. 예를 들어 API 응답에서 사용합니다.\n\n```js\n$user = User::find(1);\n$user-\u003emakeHidden('email');\n$user-\u003emakeVisible('email');\n```\n\n# 13. touch()\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n왜: updated_at 타임스탬프를 업데이트하려고.\n언제: 다른 속성을 변경하지 않고 레코드를 업데이트된 것으로 표시하려면 사용하세요.\n\n```js\n$user = User::find(1);\n$user-\u003etouch();\n```\n\n# 14. append()\n\n왜: 모델의 배열이나 JSON 형식에 사용자 정의 속성을 추가하려고.\n언제: 모델의 표현에 추가적인 계산된 속성을 포함하고 싶을 때 사용하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```php\n$user = User::find(1);\n$user-\u003eappend('custom_attribute');\n```\n\n안녕하세요! Laravel에서 Json 데이터를 관리하는 방법에 대한 매우 포괄적이고 단계별 자습서를 작성했습니다.\n\n# 15. replicate()\n\n왜: 모델 인스턴스를 복제하기 위함.\n언제: 템플릿을 복제하는 것과 같이 동일한 속성을 가진 새 인스턴스를 생성할 때 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```php\n$user = User::find(1);\n$newUser = $user-\u003ereplicate(); // $newUser is matches to $user\n$newUser-\u003esave();\n```\n\n## 16. chunkById()\n\n테이블에 20,000,000개의 레코드가 있는 상황을 상상해보세요. 각 레코드에 대해 작업을 수행해야합니다. 이를 어떻게 해야 할까요?\n\n왜: 대규모 데이터 세트를 효율적으로 처리하는 데 사용합니다.\n언제: 대규모 데이터 세트를 처리하여 메모리를 효율적으로 처리하고 대형 테이블에서 더 나은 성능을 얻을 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n특정 작업을 수행해야 하는 20,000,000개 레코드가 있는 데이터베이스 테이블이 있다고 가정해보세요.\n\n```js\nuse App\\Models\\YourModel;\n\nYourModel::orderBy('id')-\u003echunkById(1000, function ($records) {\n    foreach ($records as $record) {\n        // 각 레코드 처리\n    }\n});\n```\n\n참고: chunk()라는 유사한 메소드가 있습니다. 이러한 두 메소드는 유사한 작업을 수행하지만 차이점이 있습니다. 두 가지 모두 대규모 데이터셋을 효율적으로 일괄 처리하여 메모리 과부하를 방지하고 성능을 최적화합니다. 두 메소드는 한 번에 전체 데이터셋을 한꺼번에 메모리로 로드하지 않고 대규모 데이터셋을 이터레이션할 수 있도록 허용합니다. 그러나 데이터 배치를 결정하는 방식에서 차이가 있습니다:\n\nchunk():\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- chunk()은 첫 번째 매개변수로 지정된 청크 당 레코드 수에 따라 데이터 세트를 청크로 나눕니다.\n- 특정한 순서를 고려하지 않고 데이터베이스 테이블에서 레코드를 순차적으로 검색합니다.\n- 각 청크의 레코드는 데이터베이스에서 검색된 순서에 기반하여 가져오며, 주로 기본 키 순서에 따라 순서가 지정되지 않을 수 있습니다.\n- 처리 순서가 중요하지 않거나 데이터를 작은 관리 가능한 청크로 처리해야 할 때이 유용한 방법입니다.\n\nchunkById():\n\n- chunkById()는 레코드의 기본 키(일반적으로 id) 순서를 기반으로 데이터 세트를 청크로 나눕니다.\n- 데이터베이스 테이블에서 레코드를 기본 키 순서에 따라 순차적으로 검색합니다.\n- 각 청크에는 지정된 범위 내의 기본 키를 갖고 있는 레코드가 포함되어, 레코드가 기본 키 순서로 처리되도록 보장합니다.\n- 데이터 마이그레이션이나 기본 키 순서를 기반으로 순차 처리가 필요한 데이터 업데이트와 같은 작업을 수행할 때 유용한 방법입니다.\n\n# 17. existsOr()\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n**왜**: 모델이 존재하는 경우 콜백을 실행하거나 기본값을 반환합니다.  \n**언제**: 사용자 정의 로직으로 존재 여부를 처리해야 할 때 사용합니다.\n\n```js\n$exists = User::where('email', 'example@example.com')-\u003eexistsOr(function () {\n    return 'User does not exist';\n});\n```\n\n# 18. firstOrCreate()\n\n**왜**: 단계를 한 번에 기록을 검색하거나 생성하기 위해 사용합니다.  \n**언제**: 필요한 경우 레코드를 업데이트하거나 생성하여 중복된 항목을 피하기 위해 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n$user = User::firstOrCreate(['email' =\u003e 'example@example.com'], ['name' =\u003e 'John Doe']);\n```\n\n# 19. firstOrNew()\n\n왜: 저장하지 않고 기존 레코드를 검색하거나 새 레코드를 만들기 위해 사용합니다.\n언제: 기존 레코드를 가져 오거나 영구적으로 저장하지 않고 새 인스턴스를 만들기 위해 사용합니다.\n\n```js\n$user = User::firstOrNew(['email' =\u003e 'example@example.com'], ['name' =\u003e 'John Doe']);\n```  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 20. `sole()`\n\n왜: 하나의 레코드만 가져오거나 예외를 발생시키기 위해 사용합니다.\n언제 사용: 단일하고 고유한 결과를 예상하고 중복을 오류로 처리하고 싶은 경우에 사용합니다.\n\n```js\n$user = User::where('email', 'example@example.com')-\u003esole();\n```\n\n# 21. `findMany()`\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 Markdown 형식으로 변경하세요.\n\n\nWhy: 여러 개의 기본 키로 레코드를 검색하기 위해 사용합니다. \nWhen: 여러 개의 ID가 포함된 배열을 사용하여 한 번에 여러 레코드를 가져오는 데 사용합니다.\n\n```js\n$users = User::findMany([1, 2, 3]);\n```\n\n## 22. update()\n\nWhy: 한 번에 여러 레코드를 업데이트하기 위해 사용합니다.\nWhen: 대량 업데이트를 효율적으로 수행하기 위해 사용합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nUser::where('status', 'active')-\u003eupdate(['status' =\u003e 'inactive']);\n```\n\n# 23. forceDelete()\n\nWhy: 소프트 삭제된 모델을 영구적으로 삭제하려면 사용하세요.\nWhen: 레코드를 완전히 제거하여 소프트 삭제를 우회할 때 사용하세요.\n\n```js\n$user = User::withTrashed()-\u003efind(1);\n$user-\u003eforceDelete();\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 24. getDirty()\n\n이 함수 정말 좋아요. 이 함수를 사용하면 데이터베이스에 저장되기 전 모델에서 변경된 모든 내용을 알 수 있어요.\n\n왜: 변경된 속성들을 확인하려고요.\n언제: 저장하기 전에 수정된 속성들을 확인할 때 사용하세요.\n\n```js\n$user = User::find(1);\n$user-\u003ename = '새로운 이름';\n$dirty = $user-\u003egetDirty();\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 25. getOriginal()\n\n왜: 모델 속성의 원래 값 가져오기 위해 사용합니다.\n언제: 변경 전 현재 값과 원래 값 비교할 때 사용합니다.\n\n```js\n$user = User::find(1);\n$original = $user-\u003egetOriginal('name');\n```\n\n# 26. setRelation()\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n왜: 모델에 특정 관계를 설정하기 위해 사용합니다.\n언제: 모델 인스턴스에 수동으로 관계를 정의할 때 사용합니다.\n\n```js\n$user = User::find(1);\n$user-\u003esetRelation('posts', $posts);\n```\n\n# 27. without()\n\n왜: 쿼리에서 특정 관계를 제외하기 위해 사용합니다.\n언제: 불필요한 관계를 제외하여 쿼리를 최적화할 때 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```javascript\n$user = User::with('posts', 'comments')-\u003ewithout('comments')-\u003efind(1);\n```\n\n## 28. preventLazyLoading()\n\n왜: 관계의 게으른 로딩을 방지합니다.\n언제: 개발 중에 의도하지 않은 게으른 로딩을 방지하려면 사용하세요.\n\n```javascript\nModel::preventLazyLoading(!app()-\u003eisProduction());\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 29. withoutTimestamps()\n\n왜: created_at 및 updated_at 타임스탬프의 업데이트를 비활성화합니다.\n언제: 가져오기와 같이 타임스탬프 업데이트를 트리거해서는 안 되는 작업에 사용합니다.\n\n```js\nUser::withoutTimestamps(function () {\n    User::create(['name' =\u003e 'John Doe']);\n});\n```\n\n# 30. withCasts()\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n라라벨은 모델 속성에 동적으로 캐스팅 규칙을 적용할 수 있습니다. 특정 조건이나 런타임 시나리오에 따라 속성을 어떻게 캐스팅할지 실시간으로 변경할 필요가 있을 때 유용합니다. 예를 들어 사용자 입력이나 데이터베이스 값에 따라 속성을 다른 유형으로 캐스팅할 수 있어 데이터 일관성과 애플리케이션의 유연성을 보장할 수 있습니다.\n\n왜: 캐스팅 규칙을 동적으로 적용하기 위해.\n언제: 속성을 실시간으로 어떻게 캐스팅할지 변경할 때.\n\n```js\n$user = User::withCasts(['is_admin' =\u003e 'boolean'])-\u003efind(1);\n```\n\n# 31. upsert()\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n왜: 일치하는 기준에 따라 레코드를 삽입하거나 업데이트하기 위해서입니다.\n언제: 대량 삽입 또는 업데이트를 수행하여 중복 항목을 피하기 위해 사용합니다.\n\n고유 식별자로 이메일 열을 갖는 사용자 테이블이 있다고 가정해보세요. 해당 테이블에 이메일이 이미 존재하지 않는 경우 새 사용자를 삽입하거나 이미 존재하는 경우 이메일에 해당하는 이름을 업데이트하려고 합니다.\n\n```js\nuse App\\Models\\User;\n\nUser::upsert([\n    ['email' =\u003e 'john@example.com', 'name' =\u003e 'John Doe'],\n    ['email' =\u003e 'jane@example.com', 'name' =\u003e 'Jane Doe']\n], ['email'], ['name']);\n```\n\n# 32. 스코프\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n왜: 재사용 가능한 쿼리 스코프를 정의하는 데 사용합니다.\n언제: 여러 쿼리에 일반적인 쿼리 제약을 적용하는 데 사용합니다.\n\n```js\n// 사용자 모델에서\npublic function scopeActive($query)\n{\n    return $query-\u003ewhere('status', 'active');\n}\n\n// 사용 방법\n$activeUsers = User::active()-\u003eget();\n```\n\n# 33. macro()\n\n이 메소드를 너무 좋아합니다. 원하는대로 사용자 정의한 고유한 메소드를 생성하는 데 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n왜: Eloquent 쿼리 빌더에 사용자 정의 메서드를 정의하기 위해.\n언제: 쿼리 빌더를 확장하여 자체 메서드를 추가하는 데 사용됩니다.\n\n당신의 응용 프로그램에서 사용자의 역할에 따라 사용자를 필터링해야 하는 경우가 자주 있습니다. 이 작업을 간단히 하기 위해 쿼리 빌더에 role()이라는 사용자 지정 매크로를 정의할 수 있습니다.\n\n```js\nuse Illuminate\\Database\\Eloquent\\Builder;\n\n// 'role' 매크로 정의\nBuilder::macro('role', function ($role) {\n    return $this-\u003ewhere('role', $role);\n});\n\n// 사용 예\n$admins = User::role('admin')-\u003eget();\n$customers = User::role('customer')-\u003eget();\n```\n\n# 34. filter()\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n**왜**: 동적 쿼리 필터를 적용하기 위해 사용합니다.\n**언제**: 요청 매개변수를 기반으로 여러 필터를 적용하기 위해 사용하세요.\n\n```js\n// 사용자 모델 내부에서\npublic function scopeFilter($query, $filters)\n{\n    return $filters-\u003eapply($query);\n}\n\n// 사용법\n$filters = new UserFilters(['status' =\u003e 'active']);\n$filteredUsers = User::filter($filters)-\u003eget();\n```\n\n이 예제에서는 User 모델에 filter() scope를 정의하여 필터 세트를 전달 받습니다. 이러한 필터는 UserFilters 객체의 apply() 메서드를 사용하여 쿼리에 적용될 수 있습니다. 이를 통해 $filters 변수에 지정된 다양한 기준에 따라 사용자를 동적으로 필터링할 수 있습니다.\n\nfilter()를 사용하면 데이터베이스 쿼리를 변화하는 요구 사항과 사용자 입력에 더 적응 가능하게 만들어 Laravel 애플리케이션에서 더 유연하고 동적인 데이터 검색이 가능해집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 35. whereJsonContains()\n\n왜: 특정 값을 가진 JSON 열을 조회하기 위해 사용합니다.\n언제: 배열 또는 객체를 포함하는 JSON 열을 조회할 때 사용합니다.\n\n```js\n$users = User::whereJsonContains('options-\u003elanguages', 'en')-\u003eget();\n```\n\n라라벨에서 JSON에 관한 모든 것에 대한 문서가 있습니다. 이 곳을 확인해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 36. findOr()\n\n왜: 모델을 검색하거나 찾을 수 없을 때 콜백을 실행하는 데 사용합니다.\n언제: 레코드가 없을 때 사용자 정의 로직을 처리할 때 사용하세요.\n\n```js\n$user = User::findOr(1, function () {\n    return '사용자를 찾을 수 없습니다';\n});\n```\n\n# 37. lockForUpdate()\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nLaravel의 Eloquent ORM에 있는 lockForUpdate() 메서드는 트랜잭션 내에서 데이터베이스 행을 업데이트하기 위해 잠그는 데 사용됩니다. 이 메서드를 쿼리에 적용하면 현재 트랜잭션이 완료될 때까지 선택된 행을 수정하는 다른 데이터베이스 트랜잭션이 방지됩니다. 이를 통해 데이터 일관성을 유지하고 여러 트랜잭션이 동시에 같은 행을 업데이트하려고 할 때 충돌을 방지합니다.\n\n왜: 쿼리에 \"for update\" 잠금을 적용합니다.\n언제: 여러 트랜잭션이 귀하의 트랜잭션 중에 행을 수정하는 것을 방지할 때 사용합니다.\n\n```js\n$user = User::where('email', 'example@example.com')-\u003elockForUpdate()-\u003efirst();\n```\n\n# 38. sharedLock()\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n왜: 쿼리에 \"공유 락\"을 적용하려면\n언제: 트랜잭션 기간 동안 선택한 행을 잠그는 데 사용합니다.\n\n금융 애플리케이션이 있다고 가정해보겠습니다. 사용자가 계정 잔액을 볼 수 있는 애플리케이션입니다. 사용자가 잔액을 확인할 때, 다른 트랜잭션이 동시에 계정 잔액을 업데이트하더라도 표시된 금액이 일관되게 유지되도록 보장하고 싶습니다. 이러한 경우에는 트랜잭션 중 사용자 계정에 해당하는 행을 잠글 때 sharedLock()을 사용할 수 있습니다. \n\n```js\nuse App\\Models\\Account;\n\nDB::transaction(function () use ($userId) {\n    $account = Account::where('user_id', $userId)-\u003esharedLock()-\u003efirst();\n    // 사용자의 계정 잔액 표시\n});\n```\n\n# 39. withSum()\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n왜: 관련 모델 속성의 합계를 결과에 추가하려고 합니다.\n언제: 주문 총액을 합산하는 등 관련 모델에서 데이터를 집계해야 할 때 사용합니다.\n\n```js\n$users = User::withSum('posts', 'views')-\u003eget(); // 총 게시물\n```\n\n예를 들어 User 모델이 있고 각 사용자가 여러 주문을 가질 수 있다고 가정합니다. 사용자 목록과 주문 금액의 총 합을 함께 검색하려면 withSum()을 사용할 수 있습니다.\n\n```js\nuse App\\Models\\User;\n\n$usersWithTotalOrderAmount = User::withSum('orders', 'amount')-\u003eget();\n\nforeach ($usersWithTotalOrderAmount as $user) {\n    echo \"User: {$user-\u003ename}, Total Order Amount: {$user-\u003eorders_sum_amount}\\n\";\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예제에서는 `orders` 관계에서 각 사용자의 금액 열의 총 합계를 검색하기 위해 withSum(`orders`, `amount`)이 사용됩니다. 집계된 합계는 각 사용자 객체의 동적으로 생성된 속성 (orders_sum_amount)으로 사용할 수 있습니다.\n\nwithSum()을 사용하여 주 쿼리 결과와 관련된 모델에서 집계된 데이터를 효율적으로 검색하여 코드를 간단하게하고 성능을 향상시킬 수 있습니다.\n\n# 40. withCount()\n\nLaravel의 Eloquent ORM에서 withCount() 메서드는 관련된 모델과 관련 모델의 수를 함께 검색하는 데 사용됩니다. 이것은 추가 쿼리를 수행하거나 수동 계산을 필요로하지 않고 연결된 레코드 수를 검색하려는 경우 유용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n왜: 관련된 모델의 수를 셀 때 사용합니다.\n언제: 사용자 당 게시물 수와 같이 관련 레코드 수를 얻을 때 사용합니다.\n\n```js\nuse App\\Models\\User;\n\n$usersWithPostCounts = User::withCount('posts')-\u003eget();\n\nforeach ($usersWithPostCounts as $user) {\n    echo \"User: {$user-\u003ename}, Post Count: {$user-\u003eposts_count}\\n\";\n}\n```\n\n위 예시에서 withCount('posts')는 각 사용자와 관련된 게시물 수를 검색하는 데 사용됩니다. 게시물 수는 각 사용자 객체의 동적으로 생성된 속성(posts_count)로 사용할 수 있습니다.\n\nwithCount()를 사용하면 주 쿼리 결과와 함께 데이터베이스로부터 관련 레코드의 수를 효율적으로 검색하여 코드를 단순화하고 성능을 향상시킬 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n우리는 Eloquent에 대해 정말 깊게 알아보았습니다. Laravel 개발자라면 꼭 알아야 할 40가지 사용 빈도가 적은 Eloquent ORM 메서드를 논의했으니 즐기세요!\n\n하지만 마지막까지 읽어준 선물로, 여기 워크플로우를 향상시키고 생산성을 향상시킬 10가지 더 많은 메서드가 있습니다.\n\n- oldest(): 지정된 열을 기준으로 쿼리 결과를 오름차순으로 정렬합니다.\n- latest(): 지정된 열을 기준으로 쿼리 결과를 내림차순으로 정렬합니다.\n- has(): 관계가 있는 레코드만 포함하도록 쿼리를 필터링합니다.\n- whereHas(): 특정 조건과 일치하는 관계가 있는 레코드만 포함하도록 쿼리를 필터링합니다.\n- doesntHave(): 관계가 없는 레코드만 포함하도록 쿼리를 필터링합니다.\n- whereDoesntHave(): 특정 조건과 일치하는 관계가 없는 레코드만 포함하도록 쿼리를 필터링합니다.\n- withPivot(): 중간 테이블 열을 쿼리할 때 추가 피벗 테이블 열을 지정합니다.\n- morphTo(): 관련된 모델이 여러 소스 모델에 속할 수 있는 다형 관계를 정의합니다.\n- morphMany(): 관련된 모델이 여러 소스 모델에 속할 수 있는 다형 일대다 관계를 정의합니다.\n- morphToMany(): 관련된 모델이 여러 소스 모델에 속할 수 있는 다형 다대다 관계를 정의합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n즐겁게 보내세요.\n\n계속 주목하세요!!! 다음 기사에서는 멋진 Laravel 튜토리얼을 더 소개할 예정이에요. 기사가 마음에 드셨길 바래요. 저를 팔로우해주세요 😇 그리고 박수를 좀 👏 부탁드려요. 궁금한 점이 있으면 언제든지 댓글을 남겨주세요.\n\n감사합니다.\n\n끝까지 읽어주셔서 정말 감사합니다. 저를 팔로우하거나 연락할 수 있는 곳:\nTwitter: https://twitter.com/EjimaduPrevail\nEmail: prevailexcellent@gmail.com\nGithub: https://github.com/PrevailExcel\nLinkedIn: https://www.linkedin.com/in/chimeremeze-prevail-ejimadu-3a3535219\nBuyMeCoffee: https://www.buymeacoffee.com/prevail\nChimeremeze Prevail Ejimadu","ogImage":{"url":"/assets/img/2024-06-19-DeepDiveintoEloquent40RarelyUsedEloquentORMMethodsEveryLaravelDeveloperMUSTKnow_0.png"},"coverImage":"/assets/img/2024-06-19-DeepDiveintoEloquent40RarelyUsedEloquentORMMethodsEveryLaravelDeveloperMUSTKnow_0.png","tag":["Tech"],"readingTime":16},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e안녕하세요! 엘로퀀트에 대해 얼마나 잘 아시나요?\u003c/p\u003e\n\u003cp\u003e라라벨의 엘로퀀트 ORM은 매우 강력한 도구로, 표현력이 풍부하고 우아한 구문을 사용하여 데이터베이스와 상호 작용할 수 있는 기능을 제공합니다. 많은 개발자들이 find(), where(), first(), get(), save()와 같은 일반적인 메서드를 잘 알고 있지만, 워크플로우를 크게 향상시킬 수 있는 몇 가지 잘 알려지지 않은 메서드들이 있습니다. 이 글에서는 이러한 잘 알려지지 않지만 매우 유용한 엘로퀀트 ORM 메서드 중 일부를 살펴보겠습니다.\u003c/p\u003e\n\u003cp\u003e일반적인 메서드부터 시작해서 가장 좋은 메서드로 이동해보겠습니다. 여러분은 응용 프로그램의 속도와 효율성을 실제로 향상시킬 수 있는 많은 아름다운 메서드를 보게 될 것입니다. 함께 알아보도록 하죠.\u003c/p\u003e\n\u003ch1\u003e1. tap()\u003c/h1\u003e\n\u003cp\u003e왜: 모델에 변경사항을 적용하고 메서드 체이닝을 위해 모델 자체를 반환합니다.\u003c/p\u003e\n\u003cp\u003e언제: 객체를 수정하고 즉시 다른 작업에 사용하고 싶을 때 사용하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003efind\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)-\u003e\u003cspan class=\"hljs-title function_\"\u003etap\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e$user\u003c/span\u003e) {\n    $user-\u003ename = \u003cspan class=\"hljs-string\"\u003e'Updated Name'\u003c/span\u003e;\n})-\u003e\u003cspan class=\"hljs-title function_\"\u003esave\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e2. firstOrFail()\u003c/h1\u003e\n\u003cp\u003e왜: 유효한 결과를 얻거나 결과가 없는 경우를 처리하기 위해 사용합니다.\u003c/p\u003e\n\u003cp\u003e언제: 특정 레코드를 가져 와서 존재하지 않는 경우에 오류를 throw하고 싶을 때 사용합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e$user = \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003ewhere\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'email'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'example@example.com'\u003c/span\u003e)-\u003e\u003cspan class=\"hljs-title function_\"\u003efirstOrFail\u003c/span\u003e();\n\u003cspan class=\"hljs-comment\"\u003e// 사용자 세부 정보 처리\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e3. updateOrCreate()\u003c/h1\u003e\n\u003cp\u003e왜: 기존 레코드를 업데이트하거나 새로운 레코드를 생성하여 중복 항목을 방지하기 위해서입니다.\u003c/p\u003e\n\u003cp\u003e언제: 레코드가 존재하지 않으면 생성되고, 존재한다면 업데이트되도록 하고 싶을 때 사용합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003eupdateOrCreate\u003c/span\u003e(\n    [\u003cspan class=\"hljs-string\"\u003e'email'\u003c/span\u003e =\u003e \u003cspan class=\"hljs-string\"\u003e'example@example.com'\u003c/span\u003e],\n    [\u003cspan class=\"hljs-string\"\u003e'name'\u003c/span\u003e =\u003e \u003cspan class=\"hljs-string\"\u003e'John Doe'\u003c/span\u003e]\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e4. increment() / decrement()\u003c/h1\u003e\n\u003cp\u003e이 부분을 정말 좋아해요. 직관적이고 아름다워요. 언제 사용하나요?\n언제 사용: 숫자 열을 하나 이상 증가시키거나 감소시킬 때 사용합니다.\u003c/p\u003e\n\u003cp\u003e왜 사용하나요: 숫자 열의 값을 효율적으로 업데이트하기 위해.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003ewhere\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'id'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)-\u003e\u003cspan class=\"hljs-title function_\"\u003eincrement\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'points'\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 만약 points가 7이면 이제 8이 될 것입니다\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003ewhere\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'id'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)-\u003e\u003cspan class=\"hljs-title function_\"\u003edecrement\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'points'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 만약 7이면 2가 될 것입니다\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e5. withTrashed() / onlyTrashed() / restore()\u003c/h1\u003e\n\u003cp\u003e이 그룹의 메소드들은 라라벨에서 Soft Deletes 기능을 관리하는 데 사용됩니다.\n나는 Soft Deletes에 관한 모든 것을 다룬 매우 상세한 기사를 썼어.\u003c/p\u003e\n\u003cp\u003e왜: Soft 삭제된 레코드를 관리하기 위해.\n언제: 이러한 메소드를 사용하여 Soft 삭제된 레코드를 포함하거나 오직 포함하거나 되찾을 때.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e$users = \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003ewithTrashed\u003c/span\u003e()-\u003e\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e();\n$trashedUsers = \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003eonlyTrashed\u003c/span\u003e()-\u003e\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e();\n\u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003ewithTrashed\u003c/span\u003e()-\u003e\u003cspan class=\"hljs-title function_\"\u003ewhere\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'id'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)-\u003e\u003cspan class=\"hljs-title function_\"\u003erestore\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e6. withoutEvents()\u003c/h1\u003e\n\u003cp\u003e왜: 이벤트 리스너가 작동하는 것을 방지합니다.\n언제: 일괄 가져오기와 같이 이벤트를 발생시키지 않아야 하는 작업을 수행할 때 사용합니다.\u003c/p\u003e\n\u003cp\u003e외부 시스템에서 대량의 사용자를 가져오고 각 가져온 사용자에 대해 UserCreated 이벤트를 트리거하고 싶지 않아서 환영 이메일을 보내거나 생성마다 로깅하는 것을 피하려고 한다고 상상해보세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003ewithoutEvents\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003ecreate\u003c/span\u003e([\n      \u003cspan class=\"hljs-string\"\u003e'name'\u003c/span\u003e =\u003e \u003cspan class=\"hljs-string\"\u003e'John Doe'\u003c/span\u003e, \n      \u003cspan class=\"hljs-string\"\u003e'email'\u003c/span\u003e =\u003e \u003cspan class=\"hljs-string\"\u003e'john@example.com'\u003c/span\u003e\n    ]);\n    \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003ecreate\u003c/span\u003e([\n      \u003cspan class=\"hljs-string\"\u003e'name'\u003c/span\u003e =\u003e \u003cspan class=\"hljs-string\"\u003e'Jane Doe'\u003c/span\u003e, \n      \u003cspan class=\"hljs-string\"\u003e'email'\u003c/span\u003e =\u003e \u003cspan class=\"hljs-string\"\u003e'jane@example.com'\u003c/span\u003e\n    ]);\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e7. withoutGlobalScopes()\u003c/h1\u003e\n\u003cp\u003e\u003cstrong\u003e왜 사용하나요:\u003c/strong\u003e 전역 쿼리 제약을 우회하기 위해 사용합니다.\n\u003cstrong\u003e언제 사용하나요:\u003c/strong\u003e is_published와 같은 전역 스코프를 무시하고 모든 레코드를 가져와야 할 때 사용합니다.\u003c/p\u003e\n\u003cp\u003e당신의 애플리케이션에는 발행된 게시물만 포함하는 전역 스코프를 가진 Post 모델이 있는 상황을 상상해보세요. 관리자는 컨텐츠를 효율적으로 관리하기 위해 초안 및 미게시된 게시물을 포함한 모든 게시물을 볼 수도 있어야 할 것입니다.\u003c/p\u003e\n\u003cp\u003e전역 스코프를 무시하고 모든 게시물을 가져오기:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e$allPosts = \u003cspan class=\"hljs-title class_\"\u003ePost\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003ewithoutGlobalScopes\u003c/span\u003e()-\u003e\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e();\nforeach ($allPosts \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e $post) {\n    echo $post-\u003etitle . ($post-\u003eis_published ? \u003cspan class=\"hljs-string\"\u003e' (Published)'\u003c/span\u003e : \u003cspan class=\"hljs-string\"\u003e' (Draft)'\u003c/span\u003e) . \u003cspan class=\"hljs-string\"\u003e\"\\n\"\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 예시에서 withoutGlobalScopes()를 사용하면 관리자가 미게시된 포스트를 필터링하는 전역 범위를 우회하여 모든 포스트를 볼 수 있습니다.\u003c/p\u003e\n\u003cp\u003ewithoutGlobalScopes()를 사용하는 것은 데이터에 대한 종합적인 액세스가 필요한 관리 작업이나 글로벌 제약 조건이 쿼리에 영향을 미치지 않도록 디버깅 및 테스트 중에 특히 유용합니다.\u003c/p\u003e\n\u003ch1\u003e10. is() / isNot()\u003c/h1\u003e\n\u003cp\u003e이것도 좋아요. 비교와 조건을 확인할 때 매우 간편하고 유용합니다.\u003c/p\u003e\n\u003cp\u003e왜 필요한가: 두 모델 인스턴스를 비교하기 위해.\n언제 사용하는가: 두 모델이 동일한 인스턴스인지 확인할 때 사용합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e$user1 = \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003efind\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n$user2 = \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003efind\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e);\n\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e ($user1-\u003e\u003cspan class=\"hljs-title function_\"\u003eis\u003c/span\u003e($user2)) {\n    \u003cspan class=\"hljs-comment\"\u003e// 동일한 사용자\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e ($user1-\u003e\u003cspan class=\"hljs-title function_\"\u003eisNot\u003c/span\u003e($user2)) {\n    \u003cspan class=\"hljs-comment\"\u003e// 동일한 사용자가 아님\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e11. loadMissing()\u003c/h1\u003e\n\u003cp\u003e예시: User 모델이 있는데 그 모델은 게시물(posts) 관계를 갖고 있습니다. 사용자와 그들의 게시물을 함께 로드하고 싶지만, 게시물 관계가 이미 로드되었는지 확실하지 않을 때가 있습니다.\u003c/p\u003e\n\u003cp\u003e왜: 이미 로드되지 않은 관계를 조건부로 eager load하여 데이터베이스 쿼리를 최적화하고 N+1 쿼리 문제를 피하기 위해서입니다.\u003c/p\u003e\n\u003cp\u003e언제: loadMissing()을 사용할 때는 모델 인스턴스에 관계를 로드하고 싶지만 이미 로드되어 있지 않은 경우에만 사용합니다. 특히 특정 조건에 따라 동적으로 로드하고 싶은 조건부 관계 또는 이미 로드된 것들이 섞인 루프에서 관계를 로드할 때 유용합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e$user = \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003efind\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// 'posts' 관계가 이미 로드되었는지 확인\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!$user-\u003e\u003cspan class=\"hljs-title function_\"\u003erelationLoaded\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'posts'\u003c/span\u003e)) {\n    \u003cspan class=\"hljs-comment\"\u003e// 'posts' 관계는 이미 로드되어 있지 않다면 로드\u003c/span\u003e\n    $user-\u003e\u003cspan class=\"hljs-title function_\"\u003eloadMissing\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'posts'\u003c/span\u003e);\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 이제 중복 쿼리 걱정 없이 'posts' 관계에 접근할 수 있습니다\u003c/span\u003e\nforeach ($user-\u003eposts \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e $post) {\n    echo $post-\u003etitle . \u003cspan class=\"hljs-string\"\u003e\"\\n\"\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e12. makeHidden() / makeVisible()\u003c/h1\u003e\n\u003cp\u003e왜: 모델 속성의 가시성을 제어하기 위해서입니다.\n언제: 임시로 속성을 숨기거나 보여줄 때 사용합니다. 예를 들어 API 응답에서 사용합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e$user = \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003efind\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n$user-\u003e\u003cspan class=\"hljs-title function_\"\u003emakeHidden\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'email'\u003c/span\u003e);\n$user-\u003e\u003cspan class=\"hljs-title function_\"\u003emakeVisible\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'email'\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e13. touch()\u003c/h1\u003e\n\u003cp\u003e왜: updated_at 타임스탬프를 업데이트하려고.\n언제: 다른 속성을 변경하지 않고 레코드를 업데이트된 것으로 표시하려면 사용하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e$user = \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003efind\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n$user-\u003e\u003cspan class=\"hljs-title function_\"\u003etouch\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e14. append()\u003c/h1\u003e\n\u003cp\u003e왜: 모델의 배열이나 JSON 형식에 사용자 정의 속성을 추가하려고.\n언제: 모델의 표현에 추가적인 계산된 속성을 포함하고 싶을 때 사용하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-php\"\u003e\u003cspan class=\"hljs-variable\"\u003e$user\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e::\u003cspan class=\"hljs-title function_ invoke__\"\u003efind\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n\u003cspan class=\"hljs-variable\"\u003e$user\u003c/span\u003e-\u003e\u003cspan class=\"hljs-title function_ invoke__\"\u003eappend\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'custom_attribute'\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e안녕하세요! Laravel에서 Json 데이터를 관리하는 방법에 대한 매우 포괄적이고 단계별 자습서를 작성했습니다.\u003c/p\u003e\n\u003ch1\u003e15. replicate()\u003c/h1\u003e\n\u003cp\u003e왜: 모델 인스턴스를 복제하기 위함.\n언제: 템플릿을 복제하는 것과 같이 동일한 속성을 가진 새 인스턴스를 생성할 때 사용합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-php\"\u003e\u003cspan class=\"hljs-variable\"\u003e$user\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e::\u003cspan class=\"hljs-title function_ invoke__\"\u003efind\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n\u003cspan class=\"hljs-variable\"\u003e$newUser\u003c/span\u003e = \u003cspan class=\"hljs-variable\"\u003e$user\u003c/span\u003e-\u003e\u003cspan class=\"hljs-title function_ invoke__\"\u003ereplicate\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// $newUser is matches to $user\u003c/span\u003e\n\u003cspan class=\"hljs-variable\"\u003e$newUser\u003c/span\u003e-\u003e\u003cspan class=\"hljs-title function_ invoke__\"\u003esave\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e16. chunkById()\u003c/h2\u003e\n\u003cp\u003e테이블에 20,000,000개의 레코드가 있는 상황을 상상해보세요. 각 레코드에 대해 작업을 수행해야합니다. 이를 어떻게 해야 할까요?\u003c/p\u003e\n\u003cp\u003e왜: 대규모 데이터 세트를 효율적으로 처리하는 데 사용합니다.\n언제: 대규모 데이터 세트를 처리하여 메모리를 효율적으로 처리하고 대형 테이블에서 더 나은 성능을 얻을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e특정 작업을 수행해야 하는 20,000,000개 레코드가 있는 데이터베이스 테이블이 있다고 가정해보세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003euse \u003cspan class=\"hljs-title class_\"\u003eApp\u003c/span\u003e\\\u003cspan class=\"hljs-title class_\"\u003eModels\u003c/span\u003e\\\u003cspan class=\"hljs-title class_\"\u003eYourModel\u003c/span\u003e;\n\n\u003cspan class=\"hljs-title class_\"\u003eYourModel\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003eorderBy\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'id'\u003c/span\u003e)-\u003e\u003cspan class=\"hljs-title function_\"\u003echunkById\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e, \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e$records\u003c/span\u003e) {\n    foreach ($records \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e $record) {\n        \u003cspan class=\"hljs-comment\"\u003e// 각 레코드 처리\u003c/span\u003e\n    }\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e참고: chunk()라는 유사한 메소드가 있습니다. 이러한 두 메소드는 유사한 작업을 수행하지만 차이점이 있습니다. 두 가지 모두 대규모 데이터셋을 효율적으로 일괄 처리하여 메모리 과부하를 방지하고 성능을 최적화합니다. 두 메소드는 한 번에 전체 데이터셋을 한꺼번에 메모리로 로드하지 않고 대규모 데이터셋을 이터레이션할 수 있도록 허용합니다. 그러나 데이터 배치를 결정하는 방식에서 차이가 있습니다:\u003c/p\u003e\n\u003cp\u003echunk():\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003echunk()은 첫 번째 매개변수로 지정된 청크 당 레코드 수에 따라 데이터 세트를 청크로 나눕니다.\u003c/li\u003e\n\u003cli\u003e특정한 순서를 고려하지 않고 데이터베이스 테이블에서 레코드를 순차적으로 검색합니다.\u003c/li\u003e\n\u003cli\u003e각 청크의 레코드는 데이터베이스에서 검색된 순서에 기반하여 가져오며, 주로 기본 키 순서에 따라 순서가 지정되지 않을 수 있습니다.\u003c/li\u003e\n\u003cli\u003e처리 순서가 중요하지 않거나 데이터를 작은 관리 가능한 청크로 처리해야 할 때이 유용한 방법입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003echunkById():\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003echunkById()는 레코드의 기본 키(일반적으로 id) 순서를 기반으로 데이터 세트를 청크로 나눕니다.\u003c/li\u003e\n\u003cli\u003e데이터베이스 테이블에서 레코드를 기본 키 순서에 따라 순차적으로 검색합니다.\u003c/li\u003e\n\u003cli\u003e각 청크에는 지정된 범위 내의 기본 키를 갖고 있는 레코드가 포함되어, 레코드가 기본 키 순서로 처리되도록 보장합니다.\u003c/li\u003e\n\u003cli\u003e데이터 마이그레이션이나 기본 키 순서를 기반으로 순차 처리가 필요한 데이터 업데이트와 같은 작업을 수행할 때 유용한 방법입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e17. existsOr()\u003c/h1\u003e\n\u003cp\u003e\u003cstrong\u003e왜\u003c/strong\u003e: 모델이 존재하는 경우 콜백을 실행하거나 기본값을 반환합니다.\u003cbr\u003e\n\u003cstrong\u003e언제\u003c/strong\u003e: 사용자 정의 로직으로 존재 여부를 처리해야 할 때 사용합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e$exists = \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003ewhere\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'email'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'example@example.com'\u003c/span\u003e)-\u003e\u003cspan class=\"hljs-title function_\"\u003eexistsOr\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'User does not exist'\u003c/span\u003e;\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e18. firstOrCreate()\u003c/h1\u003e\n\u003cp\u003e\u003cstrong\u003e왜\u003c/strong\u003e: 단계를 한 번에 기록을 검색하거나 생성하기 위해 사용합니다.\u003cbr\u003e\n\u003cstrong\u003e언제\u003c/strong\u003e: 필요한 경우 레코드를 업데이트하거나 생성하여 중복된 항목을 피하기 위해 사용합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e$user = \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003efirstOrCreate\u003c/span\u003e([\u003cspan class=\"hljs-string\"\u003e'email'\u003c/span\u003e =\u003e \u003cspan class=\"hljs-string\"\u003e'example@example.com'\u003c/span\u003e], [\u003cspan class=\"hljs-string\"\u003e'name'\u003c/span\u003e =\u003e \u003cspan class=\"hljs-string\"\u003e'John Doe'\u003c/span\u003e]);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e19. firstOrNew()\u003c/h1\u003e\n\u003cp\u003e왜: 저장하지 않고 기존 레코드를 검색하거나 새 레코드를 만들기 위해 사용합니다.\n언제: 기존 레코드를 가져 오거나 영구적으로 저장하지 않고 새 인스턴스를 만들기 위해 사용합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e$user = \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003efirstOrNew\u003c/span\u003e([\u003cspan class=\"hljs-string\"\u003e'email'\u003c/span\u003e =\u003e \u003cspan class=\"hljs-string\"\u003e'example@example.com'\u003c/span\u003e], [\u003cspan class=\"hljs-string\"\u003e'name'\u003c/span\u003e =\u003e \u003cspan class=\"hljs-string\"\u003e'John Doe'\u003c/span\u003e]);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e20. \u003ccode\u003esole()\u003c/code\u003e\u003c/h1\u003e\n\u003cp\u003e왜: 하나의 레코드만 가져오거나 예외를 발생시키기 위해 사용합니다.\n언제 사용: 단일하고 고유한 결과를 예상하고 중복을 오류로 처리하고 싶은 경우에 사용합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e$user = \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003ewhere\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'email'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'example@example.com'\u003c/span\u003e)-\u003e\u003cspan class=\"hljs-title function_\"\u003esole\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e21. \u003ccode\u003efindMany()\u003c/code\u003e\u003c/h1\u003e\n\u003cp\u003e테이블 태그를 Markdown 형식으로 변경하세요.\u003c/p\u003e\n\u003cp\u003eWhy: 여러 개의 기본 키로 레코드를 검색하기 위해 사용합니다.\nWhen: 여러 개의 ID가 포함된 배열을 사용하여 한 번에 여러 레코드를 가져오는 데 사용합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e$users = \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003efindMany\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e]);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e22. update()\u003c/h2\u003e\n\u003cp\u003eWhy: 한 번에 여러 레코드를 업데이트하기 위해 사용합니다.\nWhen: 대량 업데이트를 효율적으로 수행하기 위해 사용합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003ewhere\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'status'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'active'\u003c/span\u003e)-\u003e\u003cspan class=\"hljs-title function_\"\u003eupdate\u003c/span\u003e([\u003cspan class=\"hljs-string\"\u003e'status'\u003c/span\u003e =\u003e \u003cspan class=\"hljs-string\"\u003e'inactive'\u003c/span\u003e]);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e23. forceDelete()\u003c/h1\u003e\n\u003cp\u003eWhy: 소프트 삭제된 모델을 영구적으로 삭제하려면 사용하세요.\nWhen: 레코드를 완전히 제거하여 소프트 삭제를 우회할 때 사용하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e$user = \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003ewithTrashed\u003c/span\u003e()-\u003e\u003cspan class=\"hljs-title function_\"\u003efind\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n$user-\u003e\u003cspan class=\"hljs-title function_\"\u003eforceDelete\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e24. getDirty()\u003c/h1\u003e\n\u003cp\u003e이 함수 정말 좋아요. 이 함수를 사용하면 데이터베이스에 저장되기 전 모델에서 변경된 모든 내용을 알 수 있어요.\u003c/p\u003e\n\u003cp\u003e왜: 변경된 속성들을 확인하려고요.\n언제: 저장하기 전에 수정된 속성들을 확인할 때 사용하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e$user = \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003efind\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n$user-\u003ename = \u003cspan class=\"hljs-string\"\u003e'새로운 이름'\u003c/span\u003e;\n$dirty = $user-\u003e\u003cspan class=\"hljs-title function_\"\u003egetDirty\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e25. getOriginal()\u003c/h1\u003e\n\u003cp\u003e왜: 모델 속성의 원래 값 가져오기 위해 사용합니다.\n언제: 변경 전 현재 값과 원래 값 비교할 때 사용합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e$user = \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003efind\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n$original = $user-\u003e\u003cspan class=\"hljs-title function_\"\u003egetOriginal\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'name'\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e26. setRelation()\u003c/h1\u003e\n\u003cp\u003e왜: 모델에 특정 관계를 설정하기 위해 사용합니다.\n언제: 모델 인스턴스에 수동으로 관계를 정의할 때 사용합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e$user = \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003efind\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n$user-\u003e\u003cspan class=\"hljs-title function_\"\u003esetRelation\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'posts'\u003c/span\u003e, $posts);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e27. without()\u003c/h1\u003e\n\u003cp\u003e왜: 쿼리에서 특정 관계를 제외하기 위해 사용합니다.\n언제: 불필요한 관계를 제외하여 쿼리를 최적화할 때 사용합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e$user = \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003ewith\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'posts'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'comments'\u003c/span\u003e)-\u003e\u003cspan class=\"hljs-title function_\"\u003ewithout\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'comments'\u003c/span\u003e)-\u003e\u003cspan class=\"hljs-title function_\"\u003efind\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e28. preventLazyLoading()\u003c/h2\u003e\n\u003cp\u003e왜: 관계의 게으른 로딩을 방지합니다.\n언제: 개발 중에 의도하지 않은 게으른 로딩을 방지하려면 사용하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-title class_\"\u003eModel\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003epreventLazyLoading\u003c/span\u003e(!\u003cspan class=\"hljs-title function_\"\u003eapp\u003c/span\u003e()-\u003e\u003cspan class=\"hljs-title function_\"\u003eisProduction\u003c/span\u003e());\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e29. withoutTimestamps()\u003c/h1\u003e\n\u003cp\u003e왜: created_at 및 updated_at 타임스탬프의 업데이트를 비활성화합니다.\n언제: 가져오기와 같이 타임스탬프 업데이트를 트리거해서는 안 되는 작업에 사용합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003ewithoutTimestamps\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003ecreate\u003c/span\u003e([\u003cspan class=\"hljs-string\"\u003e'name'\u003c/span\u003e =\u003e \u003cspan class=\"hljs-string\"\u003e'John Doe'\u003c/span\u003e]);\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e30. withCasts()\u003c/h1\u003e\n\u003cp\u003e라라벨은 모델 속성에 동적으로 캐스팅 규칙을 적용할 수 있습니다. 특정 조건이나 런타임 시나리오에 따라 속성을 어떻게 캐스팅할지 실시간으로 변경할 필요가 있을 때 유용합니다. 예를 들어 사용자 입력이나 데이터베이스 값에 따라 속성을 다른 유형으로 캐스팅할 수 있어 데이터 일관성과 애플리케이션의 유연성을 보장할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e왜: 캐스팅 규칙을 동적으로 적용하기 위해.\n언제: 속성을 실시간으로 어떻게 캐스팅할지 변경할 때.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e$user = \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003ewithCasts\u003c/span\u003e([\u003cspan class=\"hljs-string\"\u003e'is_admin'\u003c/span\u003e =\u003e \u003cspan class=\"hljs-string\"\u003e'boolean'\u003c/span\u003e])-\u003e\u003cspan class=\"hljs-title function_\"\u003efind\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e31. upsert()\u003c/h1\u003e\n\u003cp\u003e왜: 일치하는 기준에 따라 레코드를 삽입하거나 업데이트하기 위해서입니다.\n언제: 대량 삽입 또는 업데이트를 수행하여 중복 항목을 피하기 위해 사용합니다.\u003c/p\u003e\n\u003cp\u003e고유 식별자로 이메일 열을 갖는 사용자 테이블이 있다고 가정해보세요. 해당 테이블에 이메일이 이미 존재하지 않는 경우 새 사용자를 삽입하거나 이미 존재하는 경우 이메일에 해당하는 이름을 업데이트하려고 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003euse \u003cspan class=\"hljs-title class_\"\u003eApp\u003c/span\u003e\\\u003cspan class=\"hljs-title class_\"\u003eModels\u003c/span\u003e\\\u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e;\n\n\u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003eupsert\u003c/span\u003e([\n    [\u003cspan class=\"hljs-string\"\u003e'email'\u003c/span\u003e =\u003e \u003cspan class=\"hljs-string\"\u003e'john@example.com'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'name'\u003c/span\u003e =\u003e \u003cspan class=\"hljs-string\"\u003e'John Doe'\u003c/span\u003e],\n    [\u003cspan class=\"hljs-string\"\u003e'email'\u003c/span\u003e =\u003e \u003cspan class=\"hljs-string\"\u003e'jane@example.com'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'name'\u003c/span\u003e =\u003e \u003cspan class=\"hljs-string\"\u003e'Jane Doe'\u003c/span\u003e]\n], [\u003cspan class=\"hljs-string\"\u003e'email'\u003c/span\u003e], [\u003cspan class=\"hljs-string\"\u003e'name'\u003c/span\u003e]);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e32. 스코프\u003c/h1\u003e\n\u003cp\u003e왜: 재사용 가능한 쿼리 스코프를 정의하는 데 사용합니다.\n언제: 여러 쿼리에 일반적인 쿼리 제약을 적용하는 데 사용합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 사용자 모델에서\u003c/span\u003e\npublic \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003escopeActive\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e$query\u003c/span\u003e)\n{\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e $query-\u003e\u003cspan class=\"hljs-title function_\"\u003ewhere\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'status'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'active'\u003c/span\u003e);\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 사용 방법\u003c/span\u003e\n$activeUsers = \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003eactive\u003c/span\u003e()-\u003e\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e33. macro()\u003c/h1\u003e\n\u003cp\u003e이 메소드를 너무 좋아합니다. 원하는대로 사용자 정의한 고유한 메소드를 생성하는 데 사용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e왜: Eloquent 쿼리 빌더에 사용자 정의 메서드를 정의하기 위해.\n언제: 쿼리 빌더를 확장하여 자체 메서드를 추가하는 데 사용됩니다.\u003c/p\u003e\n\u003cp\u003e당신의 응용 프로그램에서 사용자의 역할에 따라 사용자를 필터링해야 하는 경우가 자주 있습니다. 이 작업을 간단히 하기 위해 쿼리 빌더에 role()이라는 사용자 지정 매크로를 정의할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003euse \u003cspan class=\"hljs-title class_\"\u003eIlluminate\u003c/span\u003e\\\u003cspan class=\"hljs-title class_\"\u003eDatabase\u003c/span\u003e\\\u003cspan class=\"hljs-title class_\"\u003eEloquent\u003c/span\u003e\\\u003cspan class=\"hljs-title class_\"\u003eBuilder\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e// 'role' 매크로 정의\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eBuilder\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003emacro\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'role'\u003c/span\u003e, \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e$role\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e $this-\u003e\u003cspan class=\"hljs-title function_\"\u003ewhere\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'role'\u003c/span\u003e, $role);\n});\n\n\u003cspan class=\"hljs-comment\"\u003e// 사용 예\u003c/span\u003e\n$admins = \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003erole\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'admin'\u003c/span\u003e)-\u003e\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e();\n$customers = \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003erole\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'customer'\u003c/span\u003e)-\u003e\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e34. filter()\u003c/h1\u003e\n\u003cp\u003e\u003cstrong\u003e왜\u003c/strong\u003e: 동적 쿼리 필터를 적용하기 위해 사용합니다.\n\u003cstrong\u003e언제\u003c/strong\u003e: 요청 매개변수를 기반으로 여러 필터를 적용하기 위해 사용하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 사용자 모델 내부에서\u003c/span\u003e\npublic \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003escopeFilter\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e$query, $filters\u003c/span\u003e)\n{\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e $filters-\u003e\u003cspan class=\"hljs-title function_\"\u003eapply\u003c/span\u003e($query);\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 사용법\u003c/span\u003e\n$filters = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUserFilters\u003c/span\u003e([\u003cspan class=\"hljs-string\"\u003e'status'\u003c/span\u003e =\u003e \u003cspan class=\"hljs-string\"\u003e'active'\u003c/span\u003e]);\n$filteredUsers = \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003efilter\u003c/span\u003e($filters)-\u003e\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예제에서는 User 모델에 filter() scope를 정의하여 필터 세트를 전달 받습니다. 이러한 필터는 UserFilters 객체의 apply() 메서드를 사용하여 쿼리에 적용될 수 있습니다. 이를 통해 $filters 변수에 지정된 다양한 기준에 따라 사용자를 동적으로 필터링할 수 있습니다.\u003c/p\u003e\n\u003cp\u003efilter()를 사용하면 데이터베이스 쿼리를 변화하는 요구 사항과 사용자 입력에 더 적응 가능하게 만들어 Laravel 애플리케이션에서 더 유연하고 동적인 데이터 검색이 가능해집니다.\u003c/p\u003e\n\u003ch1\u003e35. whereJsonContains()\u003c/h1\u003e\n\u003cp\u003e왜: 특정 값을 가진 JSON 열을 조회하기 위해 사용합니다.\n언제: 배열 또는 객체를 포함하는 JSON 열을 조회할 때 사용합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e$users = \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003ewhereJsonContains\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'options-\u003elanguages'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'en'\u003c/span\u003e)-\u003e\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e라라벨에서 JSON에 관한 모든 것에 대한 문서가 있습니다. 이 곳을 확인해보세요.\u003c/p\u003e\n\u003ch1\u003e36. findOr()\u003c/h1\u003e\n\u003cp\u003e왜: 모델을 검색하거나 찾을 수 없을 때 콜백을 실행하는 데 사용합니다.\n언제: 레코드가 없을 때 사용자 정의 로직을 처리할 때 사용하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e$user = \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003efindOr\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'사용자를 찾을 수 없습니다'\u003c/span\u003e;\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e37. lockForUpdate()\u003c/h1\u003e\n\u003cp\u003eLaravel의 Eloquent ORM에 있는 lockForUpdate() 메서드는 트랜잭션 내에서 데이터베이스 행을 업데이트하기 위해 잠그는 데 사용됩니다. 이 메서드를 쿼리에 적용하면 현재 트랜잭션이 완료될 때까지 선택된 행을 수정하는 다른 데이터베이스 트랜잭션이 방지됩니다. 이를 통해 데이터 일관성을 유지하고 여러 트랜잭션이 동시에 같은 행을 업데이트하려고 할 때 충돌을 방지합니다.\u003c/p\u003e\n\u003cp\u003e왜: 쿼리에 \"for update\" 잠금을 적용합니다.\n언제: 여러 트랜잭션이 귀하의 트랜잭션 중에 행을 수정하는 것을 방지할 때 사용합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e$user = \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003ewhere\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'email'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'example@example.com'\u003c/span\u003e)-\u003e\u003cspan class=\"hljs-title function_\"\u003elockForUpdate\u003c/span\u003e()-\u003e\u003cspan class=\"hljs-title function_\"\u003efirst\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e38. sharedLock()\u003c/h1\u003e\n\u003cp\u003e왜: 쿼리에 \"공유 락\"을 적용하려면\n언제: 트랜잭션 기간 동안 선택한 행을 잠그는 데 사용합니다.\u003c/p\u003e\n\u003cp\u003e금융 애플리케이션이 있다고 가정해보겠습니다. 사용자가 계정 잔액을 볼 수 있는 애플리케이션입니다. 사용자가 잔액을 확인할 때, 다른 트랜잭션이 동시에 계정 잔액을 업데이트하더라도 표시된 금액이 일관되게 유지되도록 보장하고 싶습니다. 이러한 경우에는 트랜잭션 중 사용자 계정에 해당하는 행을 잠글 때 sharedLock()을 사용할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003euse \u003cspan class=\"hljs-title class_\"\u003eApp\u003c/span\u003e\\\u003cspan class=\"hljs-title class_\"\u003eModels\u003c/span\u003e\\\u003cspan class=\"hljs-title class_\"\u003eAccount\u003c/span\u003e;\n\n\u003cspan class=\"hljs-attr\"\u003eDB\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003etransaction\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) use ($userId) {\n    $account = \u003cspan class=\"hljs-title class_\"\u003eAccount\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003ewhere\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'user_id'\u003c/span\u003e, $userId)-\u003e\u003cspan class=\"hljs-title function_\"\u003esharedLock\u003c/span\u003e()-\u003e\u003cspan class=\"hljs-title function_\"\u003efirst\u003c/span\u003e();\n    \u003cspan class=\"hljs-comment\"\u003e// 사용자의 계정 잔액 표시\u003c/span\u003e\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e39. withSum()\u003c/h1\u003e\n\u003cp\u003e왜: 관련 모델 속성의 합계를 결과에 추가하려고 합니다.\n언제: 주문 총액을 합산하는 등 관련 모델에서 데이터를 집계해야 할 때 사용합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e$users = \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003ewithSum\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'posts'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'views'\u003c/span\u003e)-\u003e\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// 총 게시물\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e예를 들어 User 모델이 있고 각 사용자가 여러 주문을 가질 수 있다고 가정합니다. 사용자 목록과 주문 금액의 총 합을 함께 검색하려면 withSum()을 사용할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003euse \u003cspan class=\"hljs-title class_\"\u003eApp\u003c/span\u003e\\\u003cspan class=\"hljs-title class_\"\u003eModels\u003c/span\u003e\\\u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e;\n\n$usersWithTotalOrderAmount = \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003ewithSum\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'orders'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'amount'\u003c/span\u003e)-\u003e\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e();\n\nforeach ($usersWithTotalOrderAmount \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e $user) {\n    echo \u003cspan class=\"hljs-string\"\u003e\"User: {$user-\u003ename}, Total Order Amount: {$user-\u003eorders_sum_amount}\\n\"\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예제에서는 \u003ccode\u003eorders\u003c/code\u003e 관계에서 각 사용자의 금액 열의 총 합계를 검색하기 위해 withSum(\u003ccode\u003eorders\u003c/code\u003e, \u003ccode\u003eamount\u003c/code\u003e)이 사용됩니다. 집계된 합계는 각 사용자 객체의 동적으로 생성된 속성 (orders_sum_amount)으로 사용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003ewithSum()을 사용하여 주 쿼리 결과와 관련된 모델에서 집계된 데이터를 효율적으로 검색하여 코드를 간단하게하고 성능을 향상시킬 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e40. withCount()\u003c/h1\u003e\n\u003cp\u003eLaravel의 Eloquent ORM에서 withCount() 메서드는 관련된 모델과 관련 모델의 수를 함께 검색하는 데 사용됩니다. 이것은 추가 쿼리를 수행하거나 수동 계산을 필요로하지 않고 연결된 레코드 수를 검색하려는 경우 유용합니다.\u003c/p\u003e\n\u003cp\u003e왜: 관련된 모델의 수를 셀 때 사용합니다.\n언제: 사용자 당 게시물 수와 같이 관련 레코드 수를 얻을 때 사용합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003euse \u003cspan class=\"hljs-title class_\"\u003eApp\u003c/span\u003e\\\u003cspan class=\"hljs-title class_\"\u003eModels\u003c/span\u003e\\\u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e;\n\n$usersWithPostCounts = \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003ewithCount\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'posts'\u003c/span\u003e)-\u003e\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e();\n\nforeach ($usersWithPostCounts \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e $user) {\n    echo \u003cspan class=\"hljs-string\"\u003e\"User: {$user-\u003ename}, Post Count: {$user-\u003eposts_count}\\n\"\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 예시에서 withCount('posts')는 각 사용자와 관련된 게시물 수를 검색하는 데 사용됩니다. 게시물 수는 각 사용자 객체의 동적으로 생성된 속성(posts_count)로 사용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003ewithCount()를 사용하면 주 쿼리 결과와 함께 데이터베이스로부터 관련 레코드의 수를 효율적으로 검색하여 코드를 단순화하고 성능을 향상시킬 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e우리는 Eloquent에 대해 정말 깊게 알아보았습니다. Laravel 개발자라면 꼭 알아야 할 40가지 사용 빈도가 적은 Eloquent ORM 메서드를 논의했으니 즐기세요!\u003c/p\u003e\n\u003cp\u003e하지만 마지막까지 읽어준 선물로, 여기 워크플로우를 향상시키고 생산성을 향상시킬 10가지 더 많은 메서드가 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eoldest(): 지정된 열을 기준으로 쿼리 결과를 오름차순으로 정렬합니다.\u003c/li\u003e\n\u003cli\u003elatest(): 지정된 열을 기준으로 쿼리 결과를 내림차순으로 정렬합니다.\u003c/li\u003e\n\u003cli\u003ehas(): 관계가 있는 레코드만 포함하도록 쿼리를 필터링합니다.\u003c/li\u003e\n\u003cli\u003ewhereHas(): 특정 조건과 일치하는 관계가 있는 레코드만 포함하도록 쿼리를 필터링합니다.\u003c/li\u003e\n\u003cli\u003edoesntHave(): 관계가 없는 레코드만 포함하도록 쿼리를 필터링합니다.\u003c/li\u003e\n\u003cli\u003ewhereDoesntHave(): 특정 조건과 일치하는 관계가 없는 레코드만 포함하도록 쿼리를 필터링합니다.\u003c/li\u003e\n\u003cli\u003ewithPivot(): 중간 테이블 열을 쿼리할 때 추가 피벗 테이블 열을 지정합니다.\u003c/li\u003e\n\u003cli\u003emorphTo(): 관련된 모델이 여러 소스 모델에 속할 수 있는 다형 관계를 정의합니다.\u003c/li\u003e\n\u003cli\u003emorphMany(): 관련된 모델이 여러 소스 모델에 속할 수 있는 다형 일대다 관계를 정의합니다.\u003c/li\u003e\n\u003cli\u003emorphToMany(): 관련된 모델이 여러 소스 모델에 속할 수 있는 다형 다대다 관계를 정의합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e즐겁게 보내세요.\u003c/p\u003e\n\u003cp\u003e계속 주목하세요!!! 다음 기사에서는 멋진 Laravel 튜토리얼을 더 소개할 예정이에요. 기사가 마음에 드셨길 바래요. 저를 팔로우해주세요 😇 그리고 박수를 좀 👏 부탁드려요. 궁금한 점이 있으면 언제든지 댓글을 남겨주세요.\u003c/p\u003e\n\u003cp\u003e감사합니다.\u003c/p\u003e\n\u003cp\u003e끝까지 읽어주셔서 정말 감사합니다. 저를 팔로우하거나 연락할 수 있는 곳:\nTwitter: \u003ca href=\"https://twitter.com/EjimaduPrevail\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://twitter.com/EjimaduPrevail\u003c/a\u003e\nEmail: \u003ca href=\"mailto:prevailexcellent@gmail.com\"\u003eprevailexcellent@gmail.com\u003c/a\u003e\nGithub: \u003ca href=\"https://github.com/PrevailExcel\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://github.com/PrevailExcel\u003c/a\u003e\nLinkedIn: \u003ca href=\"https://www.linkedin.com/in/chimeremeze-prevail-ejimadu-3a3535219\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://www.linkedin.com/in/chimeremeze-prevail-ejimadu-3a3535219\u003c/a\u003e\nBuyMeCoffee: \u003ca href=\"https://www.buymeacoffee.com/prevail\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://www.buymeacoffee.com/prevail\u003c/a\u003e\nChimeremeze Prevail Ejimadu\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-19-DeepDiveintoEloquent40RarelyUsedEloquentORMMethodsEveryLaravelDeveloperMUSTKnow"},"buildId":"-8k4Xu2rlgTZWfP5qtaGa","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>