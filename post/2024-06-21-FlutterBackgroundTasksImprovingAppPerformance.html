<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Flutter 백그라운드 작업 앱 성능 향상 방법 | uidev-css</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://uidev-css.github.io///post/2024-06-21-FlutterBackgroundTasksImprovingAppPerformance" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Flutter 백그라운드 작업 앱 성능 향상 방법 | uidev-css" data-gatsby-head="true"/><meta property="og:title" content="Flutter 백그라운드 작업 앱 성능 향상 방법 | uidev-css" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-21-FlutterBackgroundTasksImprovingAppPerformance_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://uidev-css.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://uidev-css.github.io///post/2024-06-21-FlutterBackgroundTasksImprovingAppPerformance" data-gatsby-head="true"/><meta name="twitter:title" content="Flutter 백그라운드 작업 앱 성능 향상 방법 | uidev-css" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-21-FlutterBackgroundTasksImprovingAppPerformance_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | uidev-css" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-21 23:32" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b75a4bf98ee956a8.js" defer=""></script><script src="/_next/static/CfGULpm6qSb4RqH-Y7KhT/_buildManifest.js" defer=""></script><script src="/_next/static/CfGULpm6qSb4RqH-Y7KhT/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UIDEV CSS</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Flutter 백그라운드 작업 앱 성능 향상 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Flutter 백그라운드 작업 앱 성능 향상 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UIDEV CSS</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 21, 2024</span><span class="posts_reading_time__f7YPP">11<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-21-FlutterBackgroundTasksImprovingAppPerformance&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>요즘의 빠르게 변화하는 디지턈 세계에서 사용자들은 모바일 어플리케이션이 효율적이고 반응성이 있기를 원합니다. 개발자들은 이러한 요구를 충족시키기 위해 어플리케이션의 성능을 향상시키기 위한 다양한 전략을 사용해야 합니다. 그 중 하나는 백그라운드 작업을 실행하는 것인데, 이를 통해 Flutter 어플리케이션이 사용자 경험을 방해하지 않으면서 고통스러운 작업을 처리할 수 있습니다. 이 블로그 글에서 Flutter의 백그라운드 작업과 중요성을 살펴보고, 구현하는 방법을 보여줄 코딩 예제를 제공해보겠습니다.</p>
<h2>백그라운드 작업이 중요한 이유</h2>
<p>사용자 경험이 원활하고 끊김없이 유지되려면 백그라운드 프로세스가 필수적입니다. 이를 통해 프로그래머들은 동기화, 데이터 수집, 처리와 같이 자원 집약적인 작업을 주 UI 스레드를 방해하지 않고 백그라운드에서 처리할 수 있습니다. 이러한 작업들은 백그라운드 프로세스로 이동되어 어플리케이션이 반응적으로 유지되고 사용자들에게 원활한 경험을 제공합니다.</p>
<h2>Flutter 백그라운드 작업 구현</h2>
<p>플러터는 배경 작업을 효과적으로 수행하기 위한 다양한 도구와 모듈을 제공합니다. 자주 사용되는 두 가지 방법을 살펴봅시다:</p>
<p>Isolate를 기반으로 하는 배경 작업:</p>
<p>메인 UI 스레드와 병렬로 작동하는 경량 별도 실행 스레드인 아이솔레이트는 배경 작업을 메인 스레드에 간섭하지 않고 수행할 수 있도록 합니다. 다음은 아이솔레이트가 배경 작업에 사용되는 예시입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-string">'dart:async'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'dart:isolate'</span>;

<span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) {
  <span class="hljs-title function_">runApp</span>(<span class="hljs-title class_">MyApp</span>());
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">StatefulWidget</span> {
  @override
  _MyAppState <span class="hljs-title function_">createState</span>() => <span class="hljs-title function_">_MyAppState</span>();
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">_MyAppState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">State</span>&#x3C;<span class="hljs-title class_">MyApp</span>> {
  <span class="hljs-title class_">ReceivePort</span> _port = <span class="hljs-title class_">ReceivePort</span>();

  @override
  <span class="hljs-keyword">void</span> <span class="hljs-title function_">initState</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">initState</span>();
    <span class="hljs-title function_">_startBackgroundTask</span>();
  }

  <span class="hljs-keyword">void</span> <span class="hljs-title function_">_startBackgroundTask</span>() <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">await</span> <span class="hljs-title class_">Isolate</span>.<span class="hljs-title function_">spawn</span>(_backgroundTask, _port.<span class="hljs-property">sendPort</span>);
    _port.<span class="hljs-title function_">listen</span>((message) {
      <span class="hljs-comment">// 배경 작업 완료 처리</span>
      <span class="hljs-title function_">print</span>(<span class="hljs-string">'배경 작업 완료: $message'</span>);
    });
  }

  <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">_backgroundTask</span>(<span class="hljs-params">SendPort sendPort</span>) {
    <span class="hljs-comment">// 시간이 많이 소요되는 작업 수행</span>
    <span class="hljs-comment">// ...</span>

    <span class="hljs-comment">// 결과를 메인 UI 아이솔레이트로 전송</span>
    sendPort.<span class="hljs-title function_">send</span>(<span class="hljs-string">'작업 성공적으로 완료!'</span>);
  }

  @override
  <span class="hljs-title class_">Widget</span> <span class="hljs-title function_">build</span>(<span class="hljs-params">BuildContext context</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">MaterialApp</span>(
      <span class="hljs-attr">home</span>: <span class="hljs-title class_">Scaffold</span>(
        <span class="hljs-attr">appBar</span>: <span class="hljs-title class_">AppBar</span>(
          <span class="hljs-attr">title</span>: <span class="hljs-title class_">Text</span>(<span class="hljs-string">'플러터의 배경 작업'</span>),
        ),
        <span class="hljs-attr">body</span>: <span class="hljs-title class_">Center</span>(
          <span class="hljs-attr">child</span>: <span class="hljs-title class_">Text</span>(<span class="hljs-string">'배경 작업 실행 중...'</span>),
        ),
      ),
    );
  }
}
</code></pre>
<p>플러터의 배경 작업 가져오기:</p>
<p>앱이 닫혀 있거나 사용 중이 아닌 경우에도, 개발자는 플러터 배경 작업 가져오기 플러그인을 사용하여 주기적인 배경 작업을 계획할 수 있습니다. 이는 데이터 동기화나 앱 컨텐츠 업데이트와 같은 상황에서 유용합니다. 플러터 배경 작업 가져오기 패키지를 사용하는 예제는 다음과 같습니다:</p>
<pre><code class="hljs language-dart"><span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter/material.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter_background_fetch/flutter_background_fetch.dart'</span>;

<span class="hljs-keyword">void</span> main() {
  runApp(MyApp());
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-keyword">return</span> MaterialApp(
      home: Scaffold(
        appBar: AppBar(
          title: Text(<span class="hljs-string">'플러터에서 배경 작업 실행'</span>),
        ),
        body: Center(
          child: Text(<span class="hljs-string">'배경 작업 실행 중...'</span>),
        ),
      ),
    );
  }
}

<span class="hljs-keyword">void</span> backgroundFetchHeadlessTask(<span class="hljs-built_in">String</span> taskId) <span class="hljs-keyword">async</span> {
  <span class="hljs-comment">// 여기에서 시간이 오래 걸리는 작업을 수행합니다</span>
  <span class="hljs-comment">// ...</span>

  FlutterBackgroundFetch.finish(taskId);
}

<span class="hljs-keyword">void</span> initBackgroundFetch() {
  FlutterBackgroundFetch.configure(
    minimumFetchInterval: <span class="hljs-number">15</span>,
    stopOnTerminate: <span class="hljs-keyword">false</span>,
    startOnBoot: <span class="hljs-keyword">true</span>,
    enableHeadless: <span class="hljs-keyword">true</span>,
    requiresBatteryNotLow: <span class="hljs-keyword">false</span>,
    requiresCharging: <span class="hljs-keyword">false</span>,
    requiresStorageNotLow: <span class="hljs-keyword">false</span>,
    requiresDeviceIdle: <span class="hljs-keyword">false</span>,
    requiredNetworkType: NetworkType.NONE,
  );
  FlutterBackgroundFetch.registerHeadlessTask(backgroundFetchHeadlessTask);
}
</code></pre>
<p>플랫폼 채널:</p>
<p>플랫폼 채널을 통해 Flutter는 네이티브 플랫폼 코드와 통신할 수 있습니다. 코틀린 또는 스위프트로 플랫폼별 코드를 작성하면 백그라운드 작업을 수행할 수 있는 플랫폼 채널을 사용할 수 있습니다. 필요한 작업은 그런 다음 네이티브 코드에서 백그라운드에서 수행될 수 있고, Flutter 앱에서 결과를 얻을 수 있습니다. 이 접근 방식으로 유연성과 플랫폼별 API에 접근할 수 있습니다.</p>
<p>배경 작업을 실행하여 플랫폼별 코드를 사용하여 기기의 현재 위치를 획득하는 활동을 실행하려고 상상해보세요. 이렇게 플랫폼 채널이 사용되는 방법을 설명하기 위한 것입니다.</p>
<p>Flutter 앱에서 플랫폼별 코드를 실행하는 메서드를 만들어보세요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter/services.dart'</span>;

<span class="hljs-title class_">Future</span>&#x3C;<span class="hljs-title class_">String</span>> <span class="hljs-title function_">getCurrentLocation</span>() <span class="hljs-keyword">async</span> {
  <span class="hljs-keyword">const</span> platform = <span class="hljs-title class_">MethodChannel</span>(<span class="hljs-string">'your_channel_name'</span>);
  <span class="hljs-keyword">try</span> {
    final <span class="hljs-title class_">String</span> result = <span class="hljs-keyword">await</span> platform.<span class="hljs-title function_">invokeMethod</span>(<span class="hljs-string">'getCurrentLocation'</span>);
    <span class="hljs-keyword">return</span> result;
  } <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'Failed to get location: $e'</span>;
  }
}
</code></pre>
<p>플랫폼별 언어로 위치 검색 기능을 구현해보세요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> : <span class="hljs-title class_">FlutterActivity</span>() {
    private val <span class="hljs-variable constant_">CHANNEL</span> = <span class="hljs-string">"your_channel_name"</span>

    override fun <span class="hljs-title function_">configureFlutterEngine</span>(<span class="hljs-params">flutterEngine: FlutterEngine</span>) {
        <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">configureFlutterEngine</span>(flutterEngine)
        <span class="hljs-title class_">MethodChannel</span>(flutterEngine.<span class="hljs-property">dartExecutor</span>.<span class="hljs-property">binaryMessenger</span>, <span class="hljs-variable constant_">CHANNEL</span>).<span class="hljs-property">setMethodCallHandler</span> { call, result ->
            <span class="hljs-keyword">if</span> (call.<span class="hljs-property">method</span> == <span class="hljs-string">"getCurrentLocation"</span>) {
                <span class="hljs-comment">// 백그라운드에서 위치를 검색합니다</span>
                val location = <span class="hljs-title function_">getLocation</span>()
                result.<span class="hljs-title function_">success</span>(location)
            } <span class="hljs-keyword">else</span> {
                result.<span class="hljs-title function_">notImplemented</span>()
            }
        }
    }

    private fun <span class="hljs-title function_">getLocation</span>(): <span class="hljs-title class_">String</span> {
        <span class="hljs-comment">// 안드로이드 특화 API를 사용하여 위치를 가져옵니다</span>
        <span class="hljs-comment">// ...</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">"위도: 20.5937, 경도: 78.9629"</span>
    }
}
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">UIKit</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Flutter</span>

@<span class="hljs-title class_">UIApplicationMain</span>
@objc <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppDelegate</span>: <span class="hljs-title class_">FlutterAppDelegate</span> {
    <span class="hljs-keyword">let</span> <span class="hljs-variable constant_">CHANNEL</span> = <span class="hljs-string">"your_channel_name"</span>

    override func <span class="hljs-title function_">application</span>(
        _ <span class="hljs-attr">application</span>: <span class="hljs-title class_">UIApplication</span>,
        didFinishLaunchingWithOptions <span class="hljs-attr">launchOptions</span>: [<span class="hljs-title class_">UIApplication</span>.<span class="hljs-property">LaunchOptionsKey</span>: <span class="hljs-title class_">Any</span>]?
    ) -> <span class="hljs-title class_">Bool</span> {
        <span class="hljs-keyword">let</span> controller = <span class="hljs-variable language_">window</span>?.<span class="hljs-property">rootViewController</span> <span class="hljs-keyword">as</span>! <span class="hljs-title class_">FlutterViewController</span>
        <span class="hljs-keyword">let</span> channel = <span class="hljs-title class_">FlutterMethodChannel</span>(<span class="hljs-attr">name</span>: <span class="hljs-variable constant_">CHANNEL</span>, <span class="hljs-attr">binaryMessenger</span>: controller.<span class="hljs-property">binaryMessenger</span>)
        channel.<span class="hljs-property">setMethodCallHandler</span> { [weak self] call, result <span class="hljs-keyword">in</span>
            <span class="hljs-keyword">if</span> call.<span class="hljs-property">method</span> == <span class="hljs-string">"getCurrentLocation"</span> {
                <span class="hljs-comment">// 백그라운드에서 위치를 검색합니다</span>
                <span class="hljs-keyword">let</span> location = self?.<span class="hljs-title function_">getLocation</span>() ?? <span class="hljs-string">""</span>
                <span class="hljs-title function_">result</span>(location)
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-title function_">result</span>(<span class="hljs-title class_">FlutterMethodNotImplemented</span>)
            }
        }

        <span class="hljs-title class_">GeneratedPluginRegistrant</span>.<span class="hljs-title function_">register</span>(<span class="hljs-attr">with</span>: self)
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">application</span>(application, <span class="hljs-attr">didFinishLaunchingWithOptions</span>: launchOptions)
    }

    private func <span class="hljs-title function_">getLocation</span>() -> <span class="hljs-title class_">String</span> {
        <span class="hljs-comment">// iOS 특화 API를 사용하여 위치를 가져옵니다</span>
        <span class="hljs-comment">// ...</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">"위도: 123.456, 경도: 78.901"</span>
    }
}
</code></pre>
<p>WorkManager(안드로이드) 및 BackgroundFetch(iOS)에서 사용하세요.</p>
<p>주어진 플랫폼에서 백그라운드 작업을 보다 효과적으로 처리하기 위해 WorkManager(안드로이드)와 BackgroundFetch(iOS)와 같은 플랫폼별 라이브러리를 사용할 수 있습니다. 이러한 라이브러리에는 작업 스케줄링, 반복 및 네트워크 의존 프로세스 관리, 그리고 작업이 완료되었을 때 Flutter 앱에 콜백을 제공하는 기능이 포함되어 있습니다.</p>
<p>만약 이 방법을 보여주기 위해 서버에서 데이터를 정기적으로 다운로드하는 백그라운드 활동을 예약하려고 한다면 다음과 같이 할 수 있습니다.</p>
<p>WorkManager를 사용하기 위해 android/app/build.gradle 파일에 필요한 종속성을 추가하세요:</p>
<pre><code class="hljs language-js">dependencies {
    def work_version = <span class="hljs-string">"2.6.0"</span>

    implementation <span class="hljs-string">"androidx.work:work-runtime:$work_version"</span>
}
</code></pre>
<p>워커 클래스를 만들어 백그라운드 작업을 설명해 보겠습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 플러터 측</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter_background_fetch/flutter_background_fetch.dart'</span>;

<span class="hljs-keyword">void</span> <span class="hljs-title function_">initBackgroundFetch</span>(<span class="hljs-params"></span>) {
  <span class="hljs-title class_">FlutterBackgroundFetch</span>.<span class="hljs-title function_">configure</span>(
    <span class="hljs-attr">minimumFetchInterval</span>: <span class="hljs-number">15</span>,
    <span class="hljs-attr">stopOnTerminate</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">startOnBoot</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">enableHeadless</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">requiresBatteryNotLow</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">requiresCharging</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">requiresStorageNotLow</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">requiresDeviceIdle</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">requiredNetworkType</span>: <span class="hljs-title class_">NetworkType</span>.<span class="hljs-property">NONE</span>,
  );
  <span class="hljs-title class_">FlutterBackgroundFetch</span>.<span class="hljs-title function_">registerHeadlessTask</span>(backgroundFetchHeadlessTask);
}

<span class="hljs-keyword">void</span> <span class="hljs-title function_">backgroundFetchHeadlessTask</span>(<span class="hljs-title class_">String</span> taskId) <span class="hljs-keyword">async</span> {
  <span class="hljs-comment">// 여기서 시간이 많이 소요되는 작업(예: 데이터 가져오기)을 수행합니다</span>
  <span class="hljs-comment">// ...</span>

  <span class="hljs-title class_">FlutterBackgroundFetch</span>.<span class="hljs-title function_">finish</span>(taskId);
}
</code></pre>
<p>BackgroundFetch를 사용하려면 pubspec.yaml 파일에 다음 종속성을 추가하세요:</p>
<pre><code class="hljs language-js"><span class="hljs-attr">dependencies</span>:
  <span class="hljs-attr">background_fetch</span>: ^<span class="hljs-number">0.9</span><span class="hljs-number">.0</span>
</code></pre>
<p>다음 백그라운드 작업을 구현해보세요:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 플러터 측</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter/material.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:background_fetch/background_fetch.dart'</span>;

<span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) {
  <span class="hljs-title function_">runApp</span>(<span class="hljs-title class_">MyApp</span>());
  <span class="hljs-title function_">initBackgroundFetch</span>();
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">StatelessWidget</span> {
  @override
  <span class="hljs-title class_">Widget</span> <span class="hljs-title function_">build</span>(<span class="hljs-params">BuildContext context</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">MaterialApp</span>(
      <span class="hljs-attr">home</span>: <span class="hljs-title class_">Scaffold</span>(
        <span class="hljs-attr">appBar</span>: <span class="hljs-title class_">AppBar</span>(
          <span class="hljs-attr">title</span>: <span class="hljs-title class_">Text</span>(<span class="hljs-string">'Flutter에서 백그라운드 작업'</span>),
        ),
        <span class="hljs-attr">body</span>: <span class="hljs-title class_">Center</span>(
          <span class="hljs-attr">child</span>: <span class="hljs-title class_">Text</span>(<span class="hljs-string">'백그라운드 작업 실행 중...'</span>),
        ),
      ),
    );
  }
}

<span class="hljs-keyword">void</span> <span class="hljs-title function_">initBackgroundFetch</span>(<span class="hljs-params"></span>) {
  <span class="hljs-title class_">BackgroundFetch</span>.<span class="hljs-title function_">configure</span>(
    <span class="hljs-title class_">BackgroundFetchConfig</span>(
      <span class="hljs-attr">minimumFetchInterval</span>: <span class="hljs-number">15</span>,
      <span class="hljs-attr">stopOnTerminate</span>: <span class="hljs-literal">false</span>,
      <span class="hljs-attr">startOnBoot</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">enableHeadless</span>: <span class="hljs-literal">true</span>,
    ),
    (<span class="hljs-title class_">String</span> taskId) <span class="hljs-keyword">async</span> {
      <span class="hljs-comment">// 여기서 시간이 많이 소요되는 작업(예: 데이터 가져오기) 수행하기</span>
      <span class="hljs-comment">// ...</span>

      <span class="hljs-title class_">BackgroundFetch</span>.<span class="hljs-title function_">finish</span>(taskId);
    },
  );
}
</code></pre>
<h2>타이머:</h2>
<p>항상 번거로운 백그라운드 작업을 실행할 필요는 없을 수 있습니다. 대신 플러터 프로그램에 내장된 타이머를 활용할 수도 있습니다. Dart 프로그래밍 언어에는 백그라운드 작업을 계획하고 수행할 수 있는 Timer 클래스가 함께 제공되며, 플랫폼별 추가 기능이 필요하지 않은 프로젝트에 적합합니다.</p>
<p>이 예시를 위해, 플러터 앱에서 매 시간마다 공지를 표시하고 싶다고 가정해 봅시다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-string">'dart:async'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter/material.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter_local_notifications/flutter_local_notifications.dart'</span>;

<span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) {
  <span class="hljs-title function_">runApp</span>(<span class="hljs-title class_">MyApp</span>());
  <span class="hljs-title function_">scheduleNotifications</span>();
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">StatelessWidget</span> {
  @override
  <span class="hljs-title class_">Widget</span> <span class="hljs-title function_">build</span>(<span class="hljs-params">BuildContext context</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">MaterialApp</span>(
      <span class="hljs-attr">home</span>: <span class="hljs-title class_">Scaffold</span>(
        <span class="hljs-attr">appBar</span>: <span class="hljs-title class_">AppBar</span>(
          <span class="hljs-attr">title</span>: <span class="hljs-title class_">Text</span>(<span class="hljs-string">'플러터에서 백그라운드 작업하기'</span>),
        ),
        <span class="hljs-attr">body</span>: <span class="hljs-title class_">Center</span>(
          <span class="hljs-attr">child</span>: <span class="hljs-title class_">Text</span>(<span class="hljs-string">'백그라운드 작업 실행 중...'</span>),
        ),
      ),
    );
  }
}

<span class="hljs-keyword">void</span> <span class="hljs-title function_">scheduleNotifications</span>(<span class="hljs-params"></span>) {
  <span class="hljs-title class_">Timer</span>.<span class="hljs-title function_">periodic</span>(<span class="hljs-title class_">Duration</span>(<span class="hljs-attr">hours</span>: <span class="hljs-number">1</span>), (<span class="hljs-title class_">Timer</span> timer) {
    <span class="hljs-title function_">showNotification</span>();
  });
}

<span class="hljs-keyword">void</span> <span class="hljs-title function_">showNotification</span>(<span class="hljs-params"></span>) {
  <span class="hljs-title class_">FlutterLocalNotificationsPlugin</span> flutterLocalNotificationsPlugin =
      <span class="hljs-title class_">FlutterLocalNotificationsPlugin</span>();
  <span class="hljs-comment">// 플러그인 설정 초기화</span>
  <span class="hljs-comment">// ...</span>

  flutterLocalNotificationsPlugin.<span class="hljs-title function_">show</span>(
    <span class="hljs-number">0</span>,
    <span class="hljs-string">'매 시간 알림'</span>,
    <span class="hljs-string">'매 시간 트리거되는 알림입니다.'</span>,
    <span class="hljs-title class_">NotificationDetails</span>(
      <span class="hljs-attr">android</span>: <span class="hljs-title class_">AndroidNotificationDetails</span>(
        <span class="hljs-string">'채널 ID'</span>,
        <span class="hljs-string">'채널 이름'</span>,
        <span class="hljs-string">'채널 설명'</span>,
      ),
      <span class="hljs-attr">iOS</span>: <span class="hljs-title class_">IOSNotificationDetails</span>(),
    ),
  );
}
</code></pre>
<h2>Firebase Cloud Messaging (FCM):</h2>
<p>Firebase Cloud Messaging (FCM)은 서버 이벤트에 의해 유발된 경보를 보내거나 활동을 수행하는 백그라운드 활동에 도움이 될 수 있습니다. 플러터 앱이 열리지 않거나 사용되지 않아도 FCM을 통해 서버에서 메시지를 전송할 수 있습니다. 이 신호에 응답하고 필요한 백그라운드 작업을 수행할 수 있습니다.</p>
<p>이 예제를 기준으로 FCM 알림을 수신할 때마다 백그라운드 프로세스를 실행하려고 한다고 가정해 봅시다.</p>
<pre><code class="hljs language-dart"><span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter/material.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:firebase_messaging/firebase_messaging.dart'</span>;

<span class="hljs-keyword">void</span> main() {
  runApp(MyApp());
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-keyword">return</span> MaterialApp(
      home: Scaffold(
        appBar: AppBar(
          title: Text(<span class="hljs-string">'Flutter에서 백그라운드 작업'</span>),
        ),
        body: Center(
          child: Text(<span class="hljs-string">'백그라운드 작업 실행 중...'</span>),
        ),
      ),
    );
  }
}

<span class="hljs-keyword">void</span> initFirebaseMessaging() {
  FirebaseMessaging messaging = FirebaseMessaging.instance;
  messaging.configure(
    onMessage: (message) {
      <span class="hljs-comment">// 메시지를 수신할 때 백그라운드 작업 수행</span>
      <span class="hljs-comment">// ...</span>
      <span class="hljs-keyword">return</span>;
    },
    onResume: (message) {
      <span class="hljs-comment">// 앱이 백그라운드에서 다시 활성화될 때 백그라운드 작업 수행</span>
      <span class="hljs-comment">// ...</span>
      <span class="hljs-keyword">return</span>;
    },
    onLaunch: (message) {
      <span class="hljs-comment">// 앱이 종료된 상태에서 다시 실행될 때 백그라운드 작업 수행</span>
      <span class="hljs-comment">// ...</span>
      <span class="hljs-keyword">return</span>;
    },
  );
}
</code></pre>
<h2>결론:</h2>
<p>Flutter 애플리케이션의 효율성을 향상시키는 중요한 구성 요소 중 하나는 백그라운드 활동입니다. 시간이 오래 걸리는 작업을 백그라운드에서 실행함으로써 원활한 사용자 경험을 제공하고 UI가 느려지는 것을 방지할 수 있습니다. 이 블로그 글에서는 아이솔레이트와 Flutter Background Fetch 패키지의 사용법을 살펴보았습니다. 이러한 전략을 Flutter 애플리케이션에 구현하여 앱의 속도를 향상시키고 우수한 사용자 경험을 제공할 수 있습니다.</p>
<p>앱 기능과 효율성을 균형 있게 유지하기 위해 백그라운드 작업을 구현할 때 장치 자원, 배터리 수명 및 네트워크 이용량과 같은 요소를 고려하는 것이 중요합니다.</p>
<h2>코딩 즐기세요!!!…</h2>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Flutter 백그라운드 작업 앱 성능 향상 방법","description":"","date":"2024-06-21 23:32","slug":"2024-06-21-FlutterBackgroundTasksImprovingAppPerformance","content":"\n\n요즘의 빠르게 변화하는 디지턈 세계에서 사용자들은 모바일 어플리케이션이 효율적이고 반응성이 있기를 원합니다. 개발자들은 이러한 요구를 충족시키기 위해 어플리케이션의 성능을 향상시키기 위한 다양한 전략을 사용해야 합니다. 그 중 하나는 백그라운드 작업을 실행하는 것인데, 이를 통해 Flutter 어플리케이션이 사용자 경험을 방해하지 않으면서 고통스러운 작업을 처리할 수 있습니다. 이 블로그 글에서 Flutter의 백그라운드 작업과 중요성을 살펴보고, 구현하는 방법을 보여줄 코딩 예제를 제공해보겠습니다.\n\n## 백그라운드 작업이 중요한 이유\n\n사용자 경험이 원활하고 끊김없이 유지되려면 백그라운드 프로세스가 필수적입니다. 이를 통해 프로그래머들은 동기화, 데이터 수집, 처리와 같이 자원 집약적인 작업을 주 UI 스레드를 방해하지 않고 백그라운드에서 처리할 수 있습니다. 이러한 작업들은 백그라운드 프로세스로 이동되어 어플리케이션이 반응적으로 유지되고 사용자들에게 원활한 경험을 제공합니다.\n\n## Flutter 백그라운드 작업 구현\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플러터는 배경 작업을 효과적으로 수행하기 위한 다양한 도구와 모듈을 제공합니다. 자주 사용되는 두 가지 방법을 살펴봅시다:\n\nIsolate를 기반으로 하는 배경 작업:\n\n메인 UI 스레드와 병렬로 작동하는 경량 별도 실행 스레드인 아이솔레이트는 배경 작업을 메인 스레드에 간섭하지 않고 수행할 수 있도록 합니다. 다음은 아이솔레이트가 배경 작업에 사용되는 예시입니다:\n\n```js\nimport 'dart:async';\nimport 'dart:isolate';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatefulWidget {\n  @override\n  _MyAppState createState() =\u003e _MyAppState();\n}\n\nclass _MyAppState extends State\u003cMyApp\u003e {\n  ReceivePort _port = ReceivePort();\n\n  @override\n  void initState() {\n    super.initState();\n    _startBackgroundTask();\n  }\n\n  void _startBackgroundTask() async {\n    await Isolate.spawn(_backgroundTask, _port.sendPort);\n    _port.listen((message) {\n      // 배경 작업 완료 처리\n      print('배경 작업 완료: $message');\n    });\n  }\n\n  static void _backgroundTask(SendPort sendPort) {\n    // 시간이 많이 소요되는 작업 수행\n    // ...\n\n    // 결과를 메인 UI 아이솔레이트로 전송\n    sendPort.send('작업 성공적으로 완료!');\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text('플러터의 배경 작업'),\n        ),\n        body: Center(\n          child: Text('배경 작업 실행 중...'),\n        ),\n      ),\n    );\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플러터의 배경 작업 가져오기:\n\n앱이 닫혀 있거나 사용 중이 아닌 경우에도, 개발자는 플러터 배경 작업 가져오기 플러그인을 사용하여 주기적인 배경 작업을 계획할 수 있습니다. 이는 데이터 동기화나 앱 컨텐츠 업데이트와 같은 상황에서 유용합니다. 플러터 배경 작업 가져오기 패키지를 사용하는 예제는 다음과 같습니다:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_background_fetch/flutter_background_fetch.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text('플러터에서 배경 작업 실행'),\n        ),\n        body: Center(\n          child: Text('배경 작업 실행 중...'),\n        ),\n      ),\n    );\n  }\n}\n\nvoid backgroundFetchHeadlessTask(String taskId) async {\n  // 여기에서 시간이 오래 걸리는 작업을 수행합니다\n  // ...\n\n  FlutterBackgroundFetch.finish(taskId);\n}\n\nvoid initBackgroundFetch() {\n  FlutterBackgroundFetch.configure(\n    minimumFetchInterval: 15,\n    stopOnTerminate: false,\n    startOnBoot: true,\n    enableHeadless: true,\n    requiresBatteryNotLow: false,\n    requiresCharging: false,\n    requiresStorageNotLow: false,\n    requiresDeviceIdle: false,\n    requiredNetworkType: NetworkType.NONE,\n  );\n  FlutterBackgroundFetch.registerHeadlessTask(backgroundFetchHeadlessTask);\n}\n```\n\n플랫폼 채널:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플랫폼 채널을 통해 Flutter는 네이티브 플랫폼 코드와 통신할 수 있습니다. 코틀린 또는 스위프트로 플랫폼별 코드를 작성하면 백그라운드 작업을 수행할 수 있는 플랫폼 채널을 사용할 수 있습니다. 필요한 작업은 그런 다음 네이티브 코드에서 백그라운드에서 수행될 수 있고, Flutter 앱에서 결과를 얻을 수 있습니다. 이 접근 방식으로 유연성과 플랫폼별 API에 접근할 수 있습니다.\n\n배경 작업을 실행하여 플랫폼별 코드를 사용하여 기기의 현재 위치를 획득하는 활동을 실행하려고 상상해보세요. 이렇게 플랫폼 채널이 사용되는 방법을 설명하기 위한 것입니다.\n\nFlutter 앱에서 플랫폼별 코드를 실행하는 메서드를 만들어보세요:\n\n```js\nimport 'package:flutter/services.dart';\n\nFuture\u003cString\u003e getCurrentLocation() async {\n  const platform = MethodChannel('your_channel_name');\n  try {\n    final String result = await platform.invokeMethod('getCurrentLocation');\n    return result;\n  } catch (e) {\n    return 'Failed to get location: $e';\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플랫폼별 언어로 위치 검색 기능을 구현해보세요:\n\n```js\nclass MainActivity : FlutterActivity() {\n    private val CHANNEL = \"your_channel_name\"\n\n    override fun configureFlutterEngine(flutterEngine: FlutterEngine) {\n        super.configureFlutterEngine(flutterEngine)\n        MethodChannel(flutterEngine.dartExecutor.binaryMessenger, CHANNEL).setMethodCallHandler { call, result -\u003e\n            if (call.method == \"getCurrentLocation\") {\n                // 백그라운드에서 위치를 검색합니다\n                val location = getLocation()\n                result.success(location)\n            } else {\n                result.notImplemented()\n            }\n        }\n    }\n\n    private fun getLocation(): String {\n        // 안드로이드 특화 API를 사용하여 위치를 가져옵니다\n        // ...\n        return \"위도: 20.5937, 경도: 78.9629\"\n    }\n}\n```\n\n```js\nimport UIKit\nimport Flutter\n\n@UIApplicationMain\n@objc class AppDelegate: FlutterAppDelegate {\n    let CHANNEL = \"your_channel_name\"\n\n    override func application(\n        _ application: UIApplication,\n        didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?\n    ) -\u003e Bool {\n        let controller = window?.rootViewController as! FlutterViewController\n        let channel = FlutterMethodChannel(name: CHANNEL, binaryMessenger: controller.binaryMessenger)\n        channel.setMethodCallHandler { [weak self] call, result in\n            if call.method == \"getCurrentLocation\" {\n                // 백그라운드에서 위치를 검색합니다\n                let location = self?.getLocation() ?? \"\"\n                result(location)\n            } else {\n                result(FlutterMethodNotImplemented)\n            }\n        }\n\n        GeneratedPluginRegistrant.register(with: self)\n        return super.application(application, didFinishLaunchingWithOptions: launchOptions)\n    }\n\n    private func getLocation() -\u003e String {\n        // iOS 특화 API를 사용하여 위치를 가져옵니다\n        // ...\n        return \"위도: 123.456, 경도: 78.901\"\n    }\n}\n```\n\nWorkManager(안드로이드) 및 BackgroundFetch(iOS)에서 사용하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n주어진 플랫폼에서 백그라운드 작업을 보다 효과적으로 처리하기 위해 WorkManager(안드로이드)와 BackgroundFetch(iOS)와 같은 플랫폼별 라이브러리를 사용할 수 있습니다. 이러한 라이브러리에는 작업 스케줄링, 반복 및 네트워크 의존 프로세스 관리, 그리고 작업이 완료되었을 때 Flutter 앱에 콜백을 제공하는 기능이 포함되어 있습니다.\n\n만약 이 방법을 보여주기 위해 서버에서 데이터를 정기적으로 다운로드하는 백그라운드 활동을 예약하려고 한다면 다음과 같이 할 수 있습니다.\n\nWorkManager를 사용하기 위해 android/app/build.gradle 파일에 필요한 종속성을 추가하세요:\n\n```js\ndependencies {\n    def work_version = \"2.6.0\"\n\n    implementation \"androidx.work:work-runtime:$work_version\"\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n워커 클래스를 만들어 백그라운드 작업을 설명해 보겠습니다:\n\n```js\n// 플러터 측\nimport 'package:flutter_background_fetch/flutter_background_fetch.dart';\n\nvoid initBackgroundFetch() {\n  FlutterBackgroundFetch.configure(\n    minimumFetchInterval: 15,\n    stopOnTerminate: false,\n    startOnBoot: true,\n    enableHeadless: true,\n    requiresBatteryNotLow: false,\n    requiresCharging: false,\n    requiresStorageNotLow: false,\n    requiresDeviceIdle: false,\n    requiredNetworkType: NetworkType.NONE,\n  );\n  FlutterBackgroundFetch.registerHeadlessTask(backgroundFetchHeadlessTask);\n}\n\nvoid backgroundFetchHeadlessTask(String taskId) async {\n  // 여기서 시간이 많이 소요되는 작업(예: 데이터 가져오기)을 수행합니다\n  // ...\n\n  FlutterBackgroundFetch.finish(taskId);\n}\n```\n\nBackgroundFetch를 사용하려면 pubspec.yaml 파일에 다음 종속성을 추가하세요:\n\n```js\ndependencies:\n  background_fetch: ^0.9.0\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 백그라운드 작업을 구현해보세요:\n\n```js\n// 플러터 측\nimport 'package:flutter/material.dart';\nimport 'package:background_fetch/background_fetch.dart';\n\nvoid main() {\n  runApp(MyApp());\n  initBackgroundFetch();\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text('Flutter에서 백그라운드 작업'),\n        ),\n        body: Center(\n          child: Text('백그라운드 작업 실행 중...'),\n        ),\n      ),\n    );\n  }\n}\n\nvoid initBackgroundFetch() {\n  BackgroundFetch.configure(\n    BackgroundFetchConfig(\n      minimumFetchInterval: 15,\n      stopOnTerminate: false,\n      startOnBoot: true,\n      enableHeadless: true,\n    ),\n    (String taskId) async {\n      // 여기서 시간이 많이 소요되는 작업(예: 데이터 가져오기) 수행하기\n      // ...\n\n      BackgroundFetch.finish(taskId);\n    },\n  );\n}\n```\n\n## 타이머:\n\n항상 번거로운 백그라운드 작업을 실행할 필요는 없을 수 있습니다. 대신 플러터 프로그램에 내장된 타이머를 활용할 수도 있습니다. Dart 프로그래밍 언어에는 백그라운드 작업을 계획하고 수행할 수 있는 Timer 클래스가 함께 제공되며, 플랫폼별 추가 기능이 필요하지 않은 프로젝트에 적합합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예시를 위해, 플러터 앱에서 매 시간마다 공지를 표시하고 싶다고 가정해 봅시다.\n\n```js\nimport 'dart:async';\nimport 'package:flutter/material.dart';\nimport 'package:flutter_local_notifications/flutter_local_notifications.dart';\n\nvoid main() {\n  runApp(MyApp());\n  scheduleNotifications();\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text('플러터에서 백그라운드 작업하기'),\n        ),\n        body: Center(\n          child: Text('백그라운드 작업 실행 중...'),\n        ),\n      ),\n    );\n  }\n}\n\nvoid scheduleNotifications() {\n  Timer.periodic(Duration(hours: 1), (Timer timer) {\n    showNotification();\n  });\n}\n\nvoid showNotification() {\n  FlutterLocalNotificationsPlugin flutterLocalNotificationsPlugin =\n      FlutterLocalNotificationsPlugin();\n  // 플러그인 설정 초기화\n  // ...\n\n  flutterLocalNotificationsPlugin.show(\n    0,\n    '매 시간 알림',\n    '매 시간 트리거되는 알림입니다.',\n    NotificationDetails(\n      android: AndroidNotificationDetails(\n        '채널 ID',\n        '채널 이름',\n        '채널 설명',\n      ),\n      iOS: IOSNotificationDetails(),\n    ),\n  );\n}\n```\n\n## Firebase Cloud Messaging (FCM):\n\nFirebase Cloud Messaging (FCM)은 서버 이벤트에 의해 유발된 경보를 보내거나 활동을 수행하는 백그라운드 활동에 도움이 될 수 있습니다. 플러터 앱이 열리지 않거나 사용되지 않아도 FCM을 통해 서버에서 메시지를 전송할 수 있습니다. 이 신호에 응답하고 필요한 백그라운드 작업을 수행할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예제를 기준으로 FCM 알림을 수신할 때마다 백그라운드 프로세스를 실행하려고 한다고 가정해 봅시다.\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:firebase_messaging/firebase_messaging.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text('Flutter에서 백그라운드 작업'),\n        ),\n        body: Center(\n          child: Text('백그라운드 작업 실행 중...'),\n        ),\n      ),\n    );\n  }\n}\n\nvoid initFirebaseMessaging() {\n  FirebaseMessaging messaging = FirebaseMessaging.instance;\n  messaging.configure(\n    onMessage: (message) {\n      // 메시지를 수신할 때 백그라운드 작업 수행\n      // ...\n      return;\n    },\n    onResume: (message) {\n      // 앱이 백그라운드에서 다시 활성화될 때 백그라운드 작업 수행\n      // ...\n      return;\n    },\n    onLaunch: (message) {\n      // 앱이 종료된 상태에서 다시 실행될 때 백그라운드 작업 수행\n      // ...\n      return;\n    },\n  );\n}\n```\n\n## 결론:\n\nFlutter 애플리케이션의 효율성을 향상시키는 중요한 구성 요소 중 하나는 백그라운드 활동입니다. 시간이 오래 걸리는 작업을 백그라운드에서 실행함으로써 원활한 사용자 경험을 제공하고 UI가 느려지는 것을 방지할 수 있습니다. 이 블로그 글에서는 아이솔레이트와 Flutter Background Fetch 패키지의 사용법을 살펴보았습니다. 이러한 전략을 Flutter 애플리케이션에 구현하여 앱의 속도를 향상시키고 우수한 사용자 경험을 제공할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앱 기능과 효율성을 균형 있게 유지하기 위해 백그라운드 작업을 구현할 때 장치 자원, 배터리 수명 및 네트워크 이용량과 같은 요소를 고려하는 것이 중요합니다.\n\n## 코딩 즐기세요!!!…","ogImage":{"url":"/assets/img/2024-06-21-FlutterBackgroundTasksImprovingAppPerformance_0.png"},"coverImage":"/assets/img/2024-06-21-FlutterBackgroundTasksImprovingAppPerformance_0.png","tag":["Tech"],"readingTime":11},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e요즘의 빠르게 변화하는 디지턈 세계에서 사용자들은 모바일 어플리케이션이 효율적이고 반응성이 있기를 원합니다. 개발자들은 이러한 요구를 충족시키기 위해 어플리케이션의 성능을 향상시키기 위한 다양한 전략을 사용해야 합니다. 그 중 하나는 백그라운드 작업을 실행하는 것인데, 이를 통해 Flutter 어플리케이션이 사용자 경험을 방해하지 않으면서 고통스러운 작업을 처리할 수 있습니다. 이 블로그 글에서 Flutter의 백그라운드 작업과 중요성을 살펴보고, 구현하는 방법을 보여줄 코딩 예제를 제공해보겠습니다.\u003c/p\u003e\n\u003ch2\u003e백그라운드 작업이 중요한 이유\u003c/h2\u003e\n\u003cp\u003e사용자 경험이 원활하고 끊김없이 유지되려면 백그라운드 프로세스가 필수적입니다. 이를 통해 프로그래머들은 동기화, 데이터 수집, 처리와 같이 자원 집약적인 작업을 주 UI 스레드를 방해하지 않고 백그라운드에서 처리할 수 있습니다. 이러한 작업들은 백그라운드 프로세스로 이동되어 어플리케이션이 반응적으로 유지되고 사용자들에게 원활한 경험을 제공합니다.\u003c/p\u003e\n\u003ch2\u003eFlutter 백그라운드 작업 구현\u003c/h2\u003e\n\u003cp\u003e플러터는 배경 작업을 효과적으로 수행하기 위한 다양한 도구와 모듈을 제공합니다. 자주 사용되는 두 가지 방법을 살펴봅시다:\u003c/p\u003e\n\u003cp\u003eIsolate를 기반으로 하는 배경 작업:\u003c/p\u003e\n\u003cp\u003e메인 UI 스레드와 병렬로 작동하는 경량 별도 실행 스레드인 아이솔레이트는 배경 작업을 메인 스레드에 간섭하지 않고 수행할 수 있도록 합니다. 다음은 아이솔레이트가 배경 작업에 사용되는 예시입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'dart:async'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'dart:isolate'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-title function_\"\u003erunApp\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eMyApp\u003c/span\u003e());\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyApp\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eStatefulWidget\u003c/span\u003e {\n  @override\n  _MyAppState \u003cspan class=\"hljs-title function_\"\u003ecreateState\u003c/span\u003e() =\u003e \u003cspan class=\"hljs-title function_\"\u003e_MyAppState\u003c/span\u003e();\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003e_MyAppState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eState\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eMyApp\u003c/span\u003e\u003e {\n  \u003cspan class=\"hljs-title class_\"\u003eReceivePort\u003c/span\u003e _port = \u003cspan class=\"hljs-title class_\"\u003eReceivePort\u003c/span\u003e();\n\n  @override\n  \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003einitState\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003esuper\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003einitState\u003c/span\u003e();\n    \u003cspan class=\"hljs-title function_\"\u003e_startBackgroundTask\u003c/span\u003e();\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e_startBackgroundTask\u003c/span\u003e() \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eIsolate\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003espawn\u003c/span\u003e(_backgroundTask, _port.\u003cspan class=\"hljs-property\"\u003esendPort\u003c/span\u003e);\n    _port.\u003cspan class=\"hljs-title function_\"\u003elisten\u003c/span\u003e((message) {\n      \u003cspan class=\"hljs-comment\"\u003e// 배경 작업 완료 처리\u003c/span\u003e\n      \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'배경 작업 완료: $message'\u003c/span\u003e);\n    });\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e_backgroundTask\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eSendPort sendPort\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// 시간이 많이 소요되는 작업 수행\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n\n    \u003cspan class=\"hljs-comment\"\u003e// 결과를 메인 UI 아이솔레이트로 전송\u003c/span\u003e\n    sendPort.\u003cspan class=\"hljs-title function_\"\u003esend\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'작업 성공적으로 완료!'\u003c/span\u003e);\n  }\n\n  @override\n  \u003cspan class=\"hljs-title class_\"\u003eWidget\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebuild\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eBuildContext context\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMaterialApp\u003c/span\u003e(\n      \u003cspan class=\"hljs-attr\"\u003ehome\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eScaffold\u003c/span\u003e(\n        \u003cspan class=\"hljs-attr\"\u003eappBar\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eAppBar\u003c/span\u003e(\n          \u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'플러터의 배경 작업'\u003c/span\u003e),\n        ),\n        \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCenter\u003c/span\u003e(\n          \u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'배경 작업 실행 중...'\u003c/span\u003e),\n        ),\n      ),\n    );\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e플러터의 배경 작업 가져오기:\u003c/p\u003e\n\u003cp\u003e앱이 닫혀 있거나 사용 중이 아닌 경우에도, 개발자는 플러터 배경 작업 가져오기 플러그인을 사용하여 주기적인 배경 작업을 계획할 수 있습니다. 이는 데이터 동기화나 앱 컨텐츠 업데이트와 같은 상황에서 유용합니다. 플러터 배경 작업 가져오기 패키지를 사용하는 예제는 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-dart\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:flutter/material.dart'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:flutter_background_fetch/flutter_background_fetch.dart'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e main() {\n  runApp(MyApp());\n}\n\n\u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eMyApp\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eStatelessWidget\u003c/span\u003e \u003c/span\u003e{\n  \u003cspan class=\"hljs-meta\"\u003e@override\u003c/span\u003e\n  Widget build(BuildContext context) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text(\u003cspan class=\"hljs-string\"\u003e'플러터에서 배경 작업 실행'\u003c/span\u003e),\n        ),\n        body: Center(\n          child: Text(\u003cspan class=\"hljs-string\"\u003e'배경 작업 실행 중...'\u003c/span\u003e),\n        ),\n      ),\n    );\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e backgroundFetchHeadlessTask(\u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e taskId) \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e// 여기에서 시간이 오래 걸리는 작업을 수행합니다\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n\n  FlutterBackgroundFetch.finish(taskId);\n}\n\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e initBackgroundFetch() {\n  FlutterBackgroundFetch.configure(\n    minimumFetchInterval: \u003cspan class=\"hljs-number\"\u003e15\u003c/span\u003e,\n    stopOnTerminate: \u003cspan class=\"hljs-keyword\"\u003efalse\u003c/span\u003e,\n    startOnBoot: \u003cspan class=\"hljs-keyword\"\u003etrue\u003c/span\u003e,\n    enableHeadless: \u003cspan class=\"hljs-keyword\"\u003etrue\u003c/span\u003e,\n    requiresBatteryNotLow: \u003cspan class=\"hljs-keyword\"\u003efalse\u003c/span\u003e,\n    requiresCharging: \u003cspan class=\"hljs-keyword\"\u003efalse\u003c/span\u003e,\n    requiresStorageNotLow: \u003cspan class=\"hljs-keyword\"\u003efalse\u003c/span\u003e,\n    requiresDeviceIdle: \u003cspan class=\"hljs-keyword\"\u003efalse\u003c/span\u003e,\n    requiredNetworkType: NetworkType.NONE,\n  );\n  FlutterBackgroundFetch.registerHeadlessTask(backgroundFetchHeadlessTask);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e플랫폼 채널:\u003c/p\u003e\n\u003cp\u003e플랫폼 채널을 통해 Flutter는 네이티브 플랫폼 코드와 통신할 수 있습니다. 코틀린 또는 스위프트로 플랫폼별 코드를 작성하면 백그라운드 작업을 수행할 수 있는 플랫폼 채널을 사용할 수 있습니다. 필요한 작업은 그런 다음 네이티브 코드에서 백그라운드에서 수행될 수 있고, Flutter 앱에서 결과를 얻을 수 있습니다. 이 접근 방식으로 유연성과 플랫폼별 API에 접근할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e배경 작업을 실행하여 플랫폼별 코드를 사용하여 기기의 현재 위치를 획득하는 활동을 실행하려고 상상해보세요. 이렇게 플랫폼 채널이 사용되는 방법을 설명하기 위한 것입니다.\u003c/p\u003e\n\u003cp\u003eFlutter 앱에서 플랫폼별 코드를 실행하는 메서드를 만들어보세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:flutter/services.dart'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-title class_\"\u003eFuture\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e\u003e \u003cspan class=\"hljs-title function_\"\u003egetCurrentLocation\u003c/span\u003e() \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e platform = \u003cspan class=\"hljs-title class_\"\u003eMethodChannel\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'your_channel_name'\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n    final \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e result = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e platform.\u003cspan class=\"hljs-title function_\"\u003einvokeMethod\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'getCurrentLocation'\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e result;\n  } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'Failed to get location: $e'\u003c/span\u003e;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e플랫폼별 언어로 위치 검색 기능을 구현해보세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMainActivity\u003c/span\u003e : \u003cspan class=\"hljs-title class_\"\u003eFlutterActivity\u003c/span\u003e() {\n    private val \u003cspan class=\"hljs-variable constant_\"\u003eCHANNEL\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"your_channel_name\"\u003c/span\u003e\n\n    override fun \u003cspan class=\"hljs-title function_\"\u003econfigureFlutterEngine\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eflutterEngine: FlutterEngine\u003c/span\u003e) {\n        \u003cspan class=\"hljs-variable language_\"\u003esuper\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003econfigureFlutterEngine\u003c/span\u003e(flutterEngine)\n        \u003cspan class=\"hljs-title class_\"\u003eMethodChannel\u003c/span\u003e(flutterEngine.\u003cspan class=\"hljs-property\"\u003edartExecutor\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ebinaryMessenger\u003c/span\u003e, \u003cspan class=\"hljs-variable constant_\"\u003eCHANNEL\u003c/span\u003e).\u003cspan class=\"hljs-property\"\u003esetMethodCallHandler\u003c/span\u003e { call, result -\u003e\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (call.\u003cspan class=\"hljs-property\"\u003emethod\u003c/span\u003e == \u003cspan class=\"hljs-string\"\u003e\"getCurrentLocation\"\u003c/span\u003e) {\n                \u003cspan class=\"hljs-comment\"\u003e// 백그라운드에서 위치를 검색합니다\u003c/span\u003e\n                val location = \u003cspan class=\"hljs-title function_\"\u003egetLocation\u003c/span\u003e()\n                result.\u003cspan class=\"hljs-title function_\"\u003esuccess\u003c/span\u003e(location)\n            } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n                result.\u003cspan class=\"hljs-title function_\"\u003enotImplemented\u003c/span\u003e()\n            }\n        }\n    }\n\n    private fun \u003cspan class=\"hljs-title function_\"\u003egetLocation\u003c/span\u003e(): \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e {\n        \u003cspan class=\"hljs-comment\"\u003e// 안드로이드 특화 API를 사용하여 위치를 가져옵니다\u003c/span\u003e\n        \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"위도: 20.5937, 경도: 78.9629\"\u003c/span\u003e\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUIKit\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFlutter\u003c/span\u003e\n\n@\u003cspan class=\"hljs-title class_\"\u003eUIApplicationMain\u003c/span\u003e\n@objc \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAppDelegate\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eFlutterAppDelegate\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eCHANNEL\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"your_channel_name\"\u003c/span\u003e\n\n    override func \u003cspan class=\"hljs-title function_\"\u003eapplication\u003c/span\u003e(\n        _ \u003cspan class=\"hljs-attr\"\u003eapplication\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eUIApplication\u003c/span\u003e,\n        didFinishLaunchingWithOptions \u003cspan class=\"hljs-attr\"\u003elaunchOptions\u003c/span\u003e: [\u003cspan class=\"hljs-title class_\"\u003eUIApplication\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eLaunchOptionsKey\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eAny\u003c/span\u003e]?\n    ) -\u003e \u003cspan class=\"hljs-title class_\"\u003eBool\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e controller = \u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e?.\u003cspan class=\"hljs-property\"\u003erootViewController\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e! \u003cspan class=\"hljs-title class_\"\u003eFlutterViewController\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e channel = \u003cspan class=\"hljs-title class_\"\u003eFlutterMethodChannel\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-variable constant_\"\u003eCHANNEL\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ebinaryMessenger\u003c/span\u003e: controller.\u003cspan class=\"hljs-property\"\u003ebinaryMessenger\u003c/span\u003e)\n        channel.\u003cspan class=\"hljs-property\"\u003esetMethodCallHandler\u003c/span\u003e { [weak self] call, result \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e call.\u003cspan class=\"hljs-property\"\u003emethod\u003c/span\u003e == \u003cspan class=\"hljs-string\"\u003e\"getCurrentLocation\"\u003c/span\u003e {\n                \u003cspan class=\"hljs-comment\"\u003e// 백그라운드에서 위치를 검색합니다\u003c/span\u003e\n                \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e location = self?.\u003cspan class=\"hljs-title function_\"\u003egetLocation\u003c/span\u003e() ?? \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n                \u003cspan class=\"hljs-title function_\"\u003eresult\u003c/span\u003e(location)\n            } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n                \u003cspan class=\"hljs-title function_\"\u003eresult\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eFlutterMethodNotImplemented\u003c/span\u003e)\n            }\n        }\n\n        \u003cspan class=\"hljs-title class_\"\u003eGeneratedPluginRegistrant\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eregister\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ewith\u003c/span\u003e: self)\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003esuper\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eapplication\u003c/span\u003e(application, \u003cspan class=\"hljs-attr\"\u003edidFinishLaunchingWithOptions\u003c/span\u003e: launchOptions)\n    }\n\n    private func \u003cspan class=\"hljs-title function_\"\u003egetLocation\u003c/span\u003e() -\u003e \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e {\n        \u003cspan class=\"hljs-comment\"\u003e// iOS 특화 API를 사용하여 위치를 가져옵니다\u003c/span\u003e\n        \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"위도: 123.456, 경도: 78.901\"\u003c/span\u003e\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWorkManager(안드로이드) 및 BackgroundFetch(iOS)에서 사용하세요.\u003c/p\u003e\n\u003cp\u003e주어진 플랫폼에서 백그라운드 작업을 보다 효과적으로 처리하기 위해 WorkManager(안드로이드)와 BackgroundFetch(iOS)와 같은 플랫폼별 라이브러리를 사용할 수 있습니다. 이러한 라이브러리에는 작업 스케줄링, 반복 및 네트워크 의존 프로세스 관리, 그리고 작업이 완료되었을 때 Flutter 앱에 콜백을 제공하는 기능이 포함되어 있습니다.\u003c/p\u003e\n\u003cp\u003e만약 이 방법을 보여주기 위해 서버에서 데이터를 정기적으로 다운로드하는 백그라운드 활동을 예약하려고 한다면 다음과 같이 할 수 있습니다.\u003c/p\u003e\n\u003cp\u003eWorkManager를 사용하기 위해 android/app/build.gradle 파일에 필요한 종속성을 추가하세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edependencies {\n    def work_version = \u003cspan class=\"hljs-string\"\u003e\"2.6.0\"\u003c/span\u003e\n\n    implementation \u003cspan class=\"hljs-string\"\u003e\"androidx.work:work-runtime:$work_version\"\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e워커 클래스를 만들어 백그라운드 작업을 설명해 보겠습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 플러터 측\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:flutter_background_fetch/flutter_background_fetch.dart'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003einitBackgroundFetch\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-title class_\"\u003eFlutterBackgroundFetch\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003econfigure\u003c/span\u003e(\n    \u003cspan class=\"hljs-attr\"\u003eminimumFetchInterval\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e15\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003estopOnTerminate\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003estartOnBoot\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eenableHeadless\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003erequiresBatteryNotLow\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003erequiresCharging\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003erequiresStorageNotLow\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003erequiresDeviceIdle\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003erequiredNetworkType\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eNetworkType\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eNONE\u003c/span\u003e,\n  );\n  \u003cspan class=\"hljs-title class_\"\u003eFlutterBackgroundFetch\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eregisterHeadlessTask\u003c/span\u003e(backgroundFetchHeadlessTask);\n}\n\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebackgroundFetchHeadlessTask\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e taskId) \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e// 여기서 시간이 많이 소요되는 작업(예: 데이터 가져오기)을 수행합니다\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n\n  \u003cspan class=\"hljs-title class_\"\u003eFlutterBackgroundFetch\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efinish\u003c/span\u003e(taskId);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBackgroundFetch를 사용하려면 pubspec.yaml 파일에 다음 종속성을 추가하세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-attr\"\u003edependencies\u003c/span\u003e:\n  \u003cspan class=\"hljs-attr\"\u003ebackground_fetch\u003c/span\u003e: ^\u003cspan class=\"hljs-number\"\u003e0.9\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.0\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음 백그라운드 작업을 구현해보세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 플러터 측\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:flutter/material.dart'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:background_fetch/background_fetch.dart'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-title function_\"\u003erunApp\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eMyApp\u003c/span\u003e());\n  \u003cspan class=\"hljs-title function_\"\u003einitBackgroundFetch\u003c/span\u003e();\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyApp\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eStatelessWidget\u003c/span\u003e {\n  @override\n  \u003cspan class=\"hljs-title class_\"\u003eWidget\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebuild\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eBuildContext context\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMaterialApp\u003c/span\u003e(\n      \u003cspan class=\"hljs-attr\"\u003ehome\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eScaffold\u003c/span\u003e(\n        \u003cspan class=\"hljs-attr\"\u003eappBar\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eAppBar\u003c/span\u003e(\n          \u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Flutter에서 백그라운드 작업'\u003c/span\u003e),\n        ),\n        \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCenter\u003c/span\u003e(\n          \u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'백그라운드 작업 실행 중...'\u003c/span\u003e),\n        ),\n      ),\n    );\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003einitBackgroundFetch\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-title class_\"\u003eBackgroundFetch\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003econfigure\u003c/span\u003e(\n    \u003cspan class=\"hljs-title class_\"\u003eBackgroundFetchConfig\u003c/span\u003e(\n      \u003cspan class=\"hljs-attr\"\u003eminimumFetchInterval\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e15\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003estopOnTerminate\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003estartOnBoot\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003eenableHeadless\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n    ),\n    (\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e taskId) \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n      \u003cspan class=\"hljs-comment\"\u003e// 여기서 시간이 많이 소요되는 작업(예: 데이터 가져오기) 수행하기\u003c/span\u003e\n      \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n\n      \u003cspan class=\"hljs-title class_\"\u003eBackgroundFetch\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efinish\u003c/span\u003e(taskId);\n    },\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e타이머:\u003c/h2\u003e\n\u003cp\u003e항상 번거로운 백그라운드 작업을 실행할 필요는 없을 수 있습니다. 대신 플러터 프로그램에 내장된 타이머를 활용할 수도 있습니다. Dart 프로그래밍 언어에는 백그라운드 작업을 계획하고 수행할 수 있는 Timer 클래스가 함께 제공되며, 플랫폼별 추가 기능이 필요하지 않은 프로젝트에 적합합니다.\u003c/p\u003e\n\u003cp\u003e이 예시를 위해, 플러터 앱에서 매 시간마다 공지를 표시하고 싶다고 가정해 봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'dart:async'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:flutter/material.dart'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:flutter_local_notifications/flutter_local_notifications.dart'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-title function_\"\u003erunApp\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eMyApp\u003c/span\u003e());\n  \u003cspan class=\"hljs-title function_\"\u003escheduleNotifications\u003c/span\u003e();\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyApp\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eStatelessWidget\u003c/span\u003e {\n  @override\n  \u003cspan class=\"hljs-title class_\"\u003eWidget\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebuild\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eBuildContext context\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMaterialApp\u003c/span\u003e(\n      \u003cspan class=\"hljs-attr\"\u003ehome\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eScaffold\u003c/span\u003e(\n        \u003cspan class=\"hljs-attr\"\u003eappBar\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eAppBar\u003c/span\u003e(\n          \u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'플러터에서 백그라운드 작업하기'\u003c/span\u003e),\n        ),\n        \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCenter\u003c/span\u003e(\n          \u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'백그라운드 작업 실행 중...'\u003c/span\u003e),\n        ),\n      ),\n    );\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003escheduleNotifications\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-title class_\"\u003eTimer\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eperiodic\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eDuration\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ehours\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e), (\u003cspan class=\"hljs-title class_\"\u003eTimer\u003c/span\u003e timer) {\n    \u003cspan class=\"hljs-title function_\"\u003eshowNotification\u003c/span\u003e();\n  });\n}\n\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eshowNotification\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-title class_\"\u003eFlutterLocalNotificationsPlugin\u003c/span\u003e flutterLocalNotificationsPlugin =\n      \u003cspan class=\"hljs-title class_\"\u003eFlutterLocalNotificationsPlugin\u003c/span\u003e();\n  \u003cspan class=\"hljs-comment\"\u003e// 플러그인 설정 초기화\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n\n  flutterLocalNotificationsPlugin.\u003cspan class=\"hljs-title function_\"\u003eshow\u003c/span\u003e(\n    \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e'매 시간 알림'\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e'매 시간 트리거되는 알림입니다.'\u003c/span\u003e,\n    \u003cspan class=\"hljs-title class_\"\u003eNotificationDetails\u003c/span\u003e(\n      \u003cspan class=\"hljs-attr\"\u003eandroid\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eAndroidNotificationDetails\u003c/span\u003e(\n        \u003cspan class=\"hljs-string\"\u003e'채널 ID'\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e'채널 이름'\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e'채널 설명'\u003c/span\u003e,\n      ),\n      \u003cspan class=\"hljs-attr\"\u003eiOS\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eIOSNotificationDetails\u003c/span\u003e(),\n    ),\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eFirebase Cloud Messaging (FCM):\u003c/h2\u003e\n\u003cp\u003eFirebase Cloud Messaging (FCM)은 서버 이벤트에 의해 유발된 경보를 보내거나 활동을 수행하는 백그라운드 활동에 도움이 될 수 있습니다. 플러터 앱이 열리지 않거나 사용되지 않아도 FCM을 통해 서버에서 메시지를 전송할 수 있습니다. 이 신호에 응답하고 필요한 백그라운드 작업을 수행할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 예제를 기준으로 FCM 알림을 수신할 때마다 백그라운드 프로세스를 실행하려고 한다고 가정해 봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-dart\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:flutter/material.dart'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:firebase_messaging/firebase_messaging.dart'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e main() {\n  runApp(MyApp());\n}\n\n\u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eMyApp\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eStatelessWidget\u003c/span\u003e \u003c/span\u003e{\n  \u003cspan class=\"hljs-meta\"\u003e@override\u003c/span\u003e\n  Widget build(BuildContext context) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text(\u003cspan class=\"hljs-string\"\u003e'Flutter에서 백그라운드 작업'\u003c/span\u003e),\n        ),\n        body: Center(\n          child: Text(\u003cspan class=\"hljs-string\"\u003e'백그라운드 작업 실행 중...'\u003c/span\u003e),\n        ),\n      ),\n    );\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e initFirebaseMessaging() {\n  FirebaseMessaging messaging = FirebaseMessaging.instance;\n  messaging.configure(\n    onMessage: (message) {\n      \u003cspan class=\"hljs-comment\"\u003e// 메시지를 수신할 때 백그라운드 작업 수행\u003c/span\u003e\n      \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n    },\n    onResume: (message) {\n      \u003cspan class=\"hljs-comment\"\u003e// 앱이 백그라운드에서 다시 활성화될 때 백그라운드 작업 수행\u003c/span\u003e\n      \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n    },\n    onLaunch: (message) {\n      \u003cspan class=\"hljs-comment\"\u003e// 앱이 종료된 상태에서 다시 실행될 때 백그라운드 작업 수행\u003c/span\u003e\n      \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n    },\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e결론:\u003c/h2\u003e\n\u003cp\u003eFlutter 애플리케이션의 효율성을 향상시키는 중요한 구성 요소 중 하나는 백그라운드 활동입니다. 시간이 오래 걸리는 작업을 백그라운드에서 실행함으로써 원활한 사용자 경험을 제공하고 UI가 느려지는 것을 방지할 수 있습니다. 이 블로그 글에서는 아이솔레이트와 Flutter Background Fetch 패키지의 사용법을 살펴보았습니다. 이러한 전략을 Flutter 애플리케이션에 구현하여 앱의 속도를 향상시키고 우수한 사용자 경험을 제공할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e앱 기능과 효율성을 균형 있게 유지하기 위해 백그라운드 작업을 구현할 때 장치 자원, 배터리 수명 및 네트워크 이용량과 같은 요소를 고려하는 것이 중요합니다.\u003c/p\u003e\n\u003ch2\u003e코딩 즐기세요!!!…\u003c/h2\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-21-FlutterBackgroundTasksImprovingAppPerformance"},"buildId":"CfGULpm6qSb4RqH-Y7KhT","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>