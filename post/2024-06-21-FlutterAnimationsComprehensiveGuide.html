<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Flutter 애니메이션 종합 가이드 | uidev-css</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://uidev-css.github.io///post/2024-06-21-FlutterAnimationsComprehensiveGuide" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Flutter 애니메이션 종합 가이드 | uidev-css" data-gatsby-head="true"/><meta property="og:title" content="Flutter 애니메이션 종합 가이드 | uidev-css" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-21-FlutterAnimationsComprehensiveGuide_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://uidev-css.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://uidev-css.github.io///post/2024-06-21-FlutterAnimationsComprehensiveGuide" data-gatsby-head="true"/><meta name="twitter:title" content="Flutter 애니메이션 종합 가이드 | uidev-css" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-21-FlutterAnimationsComprehensiveGuide_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | uidev-css" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-21 22:15" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b75a4bf98ee956a8.js" defer=""></script><script src="/_next/static/-yEBofE4jMl3RL1kr5c4Y/_buildManifest.js" defer=""></script><script src="/_next/static/-yEBofE4jMl3RL1kr5c4Y/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UIDEV CSS</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Flutter 애니메이션 종합 가이드</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Flutter 애니메이션 종합 가이드" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UIDEV CSS</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 21, 2024</span><span class="posts_reading_time__f7YPP">12<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-21-FlutterAnimationsComprehensiveGuide&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>이 기사에서는 플러터 애니메이션에 대해 자세히 설명하고 여러 예제와 함께 다루어보겠습니다. 이 기사를 끝까지 읽으면 다양한 복잡성을 갖는 애니메이션을 플러터 앱에 추가할 수 있을 것입니다. 또한 플러터에서 제공하는 다양한 접근 방법 중에서 여러분의 애니메이션 목표에 가장 적합한 것을 알게 될 것입니다. 그럼 바로 시작해 봅시다!</p>
<p><img src="/assets/img/2024-06-21-FlutterAnimationsComprehensiveGuide_0.png" alt="Flutter Animations"></p>
<h2>목차:</h2>
<ul>
<li>소개</li>
<li>암시적 애니메이션 - AnimatedFoo 위젯</li>
<li>암시적 애니메이션 - TweenAnimationBuilder 위젯</li>
<li>명시적 애니메이션 - FooTransition 위젯</li>
<li>AnimationController</li>
<li>명시적 애니메이션 - AnimatedBuilder 위젯</li>
<li>명시적 애니메이션 - AnimatedWidget 클래스</li>
<li>올바른 애니메이션 접근 방법 선택하기</li>
<li>서드파티 패키지를 사용한 애니메이션</li>
</ul>
<h2>TL;DR</h2>
<p>이 튜토리얼에서 모든 애니메이션의 코드를 DartPad에서 볼 수 있어요. 코드를 손대면서 실험해보세요.</p>
<p>최근에는 이 튜토리얼을 요약한 트위터 스레드도 올렸어요. 한 번 확인해보세요.</p>
<h1>소개</h1>
<p>플러터 앱에서 애니메이션은 기본적으로 두 가지 유형으로 볼 수 있어요: 그리기 기반 애니메이션과 코드 기반 애니메이션이에요. 그리기 기반 애니메이션은 애니메이션된 그래픽, 벡터, 캐릭터 또는 "그려진" 모든 것을 말해요. 한편, 코드 기반 애니메이션은 위젯 레이아웃 및 스타일(리스트, 색상, 텍스트 등)에 중점을 두었어요. 이 글의 끝에는 그리기 기반 애니메이션에 대해 간략히 다뤄볼 거에요. 그러나 그들은 보통 3rd party 프레임워크/패키지를 사용하여 달성되므로, 우리는 코드 기반 애니메이션에보다 초점을 맞출 거예요. 코드 기반 애니메이션은 제한적이라는 의미가 아니라, 그 반대로 플러터 애니메이션을 통해 완전히 멋진, 창의적이고 매우 복잡한 애니메이션을 만들 수 있어요. 3rd party 패키지가 필요하지 않아요!</p>
<p>플러터의 코드 기반 애니메이션에는 암시적 애니메이션 및 명시적 애니메이션이 두 가지 유형이 있어요. 이러한 유형 각각에서 준비된 위젯을 사용하거나 직접 위젯을 만들 수 있어요. 각 유형에 대해 몇 가지 예제와 함께 더 자세히 알아보겠어요.</p>
<h1>1. 암시적 애니메이션</h1>
<p>맨 위로 이동하기 👆🏼</p>
<p>가장 간단하고 사용하기 쉬운 애니메이션입니다. 값만 변경하면 애니메이션이 트리거되고, Flutter가 모든 것을 자동으로 처리해줍니다.</p>
<h2>1.1 준비된 위젯으로 암묵적 애니메이션</h2>
<p>이들은 AnimatedFoo 위젯이라고 불립니다. 여기서 Foo는 애니메이션 속성을 나타냅니다. 대부분은 이미 알고 사용하는 위젯의 애니메이션 버전입니다. 예를 들어 Container/AnimatedContainer, Padding/AnimatedPadding, Positioned/AnimatedPositioned 등이 있습니다.</p>
<p>예를 들어, 다음 애니메이션을 확인해보세요:</p>
<p>이 애니메이션은 AnimatedContainer, AnimatedPositioned 및 AnimatedDefaultTextStyle 위젯만을 사용하여 구현되었습니다. 지속 시간 값을 지정하고 변경 가능한 변수를 제공하면 끝입니다!</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">AnimatedPositioned</span>(
  <span class="hljs-attr">top</span>: selectedItemIndex * itemHeight,
  <span class="hljs-attr">left</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">right</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">duration</span>: <span class="hljs-keyword">const</span> <span class="hljs-title class_">Duration</span>(<span class="hljs-attr">milliseconds</span>: <span class="hljs-number">200</span>),
  <span class="hljs-attr">curve</span>: <span class="hljs-title class_">Curves</span>.<span class="hljs-property">easeInOut</span>,
  <span class="hljs-attr">child</span>: <span class="hljs-comment">//...</span>
),
<span class="hljs-comment">//...</span>
<span class="hljs-title class_">AnimatedContainer</span>(
  <span class="hljs-attr">duration</span>: <span class="hljs-keyword">const</span> <span class="hljs-title class_">Duration</span>(<span class="hljs-attr">milliseconds</span>: <span class="hljs-number">200</span>),
  <span class="hljs-attr">curve</span>: <span class="hljs-title class_">Curves</span>.<span class="hljs-property">easeInOut</span>,
  <span class="hljs-attr">decoration</span>: <span class="hljs-title class_">BoxDecoration</span>(
    <span class="hljs-attr">color</span>: selectedItemIndex == i ? yellow : pink,
    <span class="hljs-attr">border</span>: <span class="hljs-title class_">Border</span>.<span class="hljs-title function_">all</span>(
      <span class="hljs-attr">color</span>: selectedItemIndex == i
          ? <span class="hljs-title class_">Colors</span>.<span class="hljs-property">white</span>
          : <span class="hljs-title class_">Colors</span>.<span class="hljs-property">transparent</span>,
      <span class="hljs-attr">width</span>: <span class="hljs-number">2</span>,
    ),
  ),
  <span class="hljs-attr">child</span>: <span class="hljs-title class_">AnimatedDefaultTextStyle</span>(
    <span class="hljs-attr">duration</span>: <span class="hljs-keyword">const</span> <span class="hljs-title class_">Duration</span>(<span class="hljs-attr">milliseconds</span>: <span class="hljs-number">200</span>),
    <span class="hljs-attr">style</span>: <span class="hljs-title class_">TextStyle</span>(
      <span class="hljs-attr">color</span>: selectedItemIndex == i
          ? <span class="hljs-title class_">Colors</span>.<span class="hljs-property">black</span>
          : <span class="hljs-title class_">Colors</span>.<span class="hljs-property">white</span>,
    ),
    <span class="hljs-attr">child</span>: <span class="hljs-keyword">const</span> <span class="hljs-title class_">Text</span>(<span class="hljs-string">'Featured!'</span>),
  ),
),
</code></pre>
<p>그리고 간단히 각 목록 항목은 아래와 같은 onTap 메서드가 있는 InkWell 위젯으로 래핑되어 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-attr">onTap</span>: <span class="hljs-function">() =></span> <span class="hljs-title function_">setState</span>(<span class="hljs-function">() =></span> selectedItemIndex = i),
</code></pre>
<p>이렇게 하면 애니메이션을 트리거할 수 있어요!</p>
<p>여기 사용 가능한 AnimatedFoo 위젯 전체 목록이 있어요.</p>
<p>따라서 우리는 AnimatedFoo 위젯을 투명도, 패딩, 정렬, 위치와 같은 속성용으로 가지고 있어요. 하지만 다른 속성을 애니메이션화하고 싶을 때 어떡하나요? 그럼 여전히 쉽고 빠르게 사용하고 싶어요.</p>
<h2>1.2. TweenAnimationBuilder를 사용한 암시적 애니메이션</h2>
<p>화면 맨 위로 이동 👆🏼</p>
<p>TweenAnimationBuilder를 사용하면 Tween 클래스를 사용하여 모든 위젯의 속성을 암시적으로 애니메이트할 수 있습니다. Tween 클래스의 이름은 "Between"에서 따왔습니다. 기본적으로 애니메이트해야 할 시작 및 끝 값을 제공합니다. 그리고 TweenAnimationBuilder 위젯의 빌더는 애니메이션 값으로 제공되며 이 값을 해당 빌더에서 반환하는 위젯의 어떤 속성에 적용할 수 있습니다.</p>
<p>다음은 예시 애니메이션입니다:</p>
<p>아래는 해당 코드입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">TweenAnimationBuilder</span>(
  <span class="hljs-attr">duration</span>: <span class="hljs-keyword">const</span> <span class="hljs-title class_">Duration</span>(<span class="hljs-attr">milliseconds</span>: <span class="hljs-number">200</span>),
  <span class="hljs-attr">tween</span>: <span class="hljs-title class_">Tween</span>&#x3C;double>(<span class="hljs-attr">begin</span>: <span class="hljs-number">0.01</span>, <span class="hljs-attr">end</span>: _sliderValue),
  <span class="hljs-attr">child</span>: <span class="hljs-title class_">Container</span>(
    <span class="hljs-attr">decoration</span>: <span class="hljs-title class_">BoxDecoration</span>(
      <span class="hljs-comment">//...</span>
    ),
    <span class="hljs-attr">child</span>: <span class="hljs-title class_">Slider</span>(
      <span class="hljs-attr">value</span>: _sliderValue,
      <span class="hljs-attr">min</span>: <span class="hljs-number">0.01</span>,
      <span class="hljs-attr">onChanged</span>: (value) {
        <span class="hljs-title function_">setState</span>(<span class="hljs-function">() =></span> _sliderValue = value);
      },
    ),
  ),
  <span class="hljs-attr">builder</span>: (<span class="hljs-title class_">BuildContext</span> context, double? value, <span class="hljs-title class_">Widget</span>? child) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">ClipRect</span>(
      <span class="hljs-attr">child</span>: <span class="hljs-title class_">BackdropFilter</span>(
        <span class="hljs-attr">filter</span>: <span class="hljs-title class_">ImageFilter</span>.<span class="hljs-title function_">blur</span>(
          <span class="hljs-attr">sigmaX</span>: <span class="hljs-number">40</span> * (value ?? <span class="hljs-number">0.01</span>),
          <span class="hljs-attr">sigmaY</span>: <span class="hljs-number">40</span> * (value ?? <span class="hljs-number">0.01</span>),
        ),
        <span class="hljs-attr">child</span>: child,
      ),
    );
  },
);
</code></pre>
<p>_sliderValue 변수는 0.01에서 1로 변경됩니다. 따라서 각 값의 변경마다 애니메이션이 트리거되며 BackdropFilter 위젯의 sigmaX 및 sigmaY 속성을 위한 새 값으로 다시 빌더 함수가 재구성됩니다. (0 값을 주면 BackdropFilter 위젯이 웹에서 오류를 발생시키기 때문에 0.01을 사용했습니다.)</p>
<p>TweenAnimationBuilder의 child 매개변수를 사용하여 더 나은 성능을 위해 빌더를 활용하고 있어요. 이 child는 애니메이션이 트리거될 때마다 다시 빌드하는 대신 한 번만 다시 빌드되어요.</p>
<p>좋아요, 쉬운 내용은 끝났습니다. 이제 본격적인 내용을 시작해볼까요?</p>
<h1>2. 명시적 애니메이션</h1>
<p>맨 위로 돌아가기 👆🏼</p>
<p>암시적 애니메이션에서 AnimatedFoo 또는 TweenAnimationBuilder 위젯 내부의 값만 변경하면 애니메이션이 트리거되었던 것을 기억하시나요? 그러나 명시적 애니메이션은 "명시적으로" 애니메이트할 때까지 애니메이션을 트리거하지 않습니다. 애니메이션을 시작하고 어떻게 애니메이트할지 및 AnimationController를 사용하여 애니메이션을 "제어"하는 방법을 알려주어야 합니다.</p>
<p>명시적 애니메이션 역시 암시적 애니메이션과 유사하게 사용하기 쉬운 위젯과 사용자 정의 수준이 추가된 위젯이 준비되어 있어 자유롭게 사용할 수 있습니다!</p>
<p>그런데, AnimationController가 무엇인지 궁금하시죠? 이를 사용하는 명시적 애니메이션 위젯에 대해 알아보기 전에 먼저 AnimationController에 대해 학습해 보겠습니다.</p>
<h2>AnimationController</h2>
<p>위로 이동 👆🏼</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">AnimationController</span>({
  double? value,
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">duration</span>,
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">reverseDuration</span>,
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">debugLabel</span>,
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">lowerBound</span> = <span class="hljs-number">0.0</span>,
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">upperBound</span> = <span class="hljs-number">1.0</span>,
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">animationBehavior</span> = <span class="hljs-title class_">AnimationBehavior</span>.<span class="hljs-property">normal</span>,
  required <span class="hljs-title class_">TickerProvider</span> vsync,
})
</code></pre>
<p>이전에 언급했듯이 AnimationController를 사용하면 애니메이션을 "제어"할 수 있습니다. 그를 위해서는 vsync 값이 TickerProvider 유형이 필요합니다. Ticker는 기본적으로 Flutter의 프레임 렌더링을 추적하고 컨트롤러가 해당 티커를 따라가서 지정된 기간 내에 '애니메이션'할 수 있도록 허용하며, 기본적으로 0과 1인 lowerBound 및 upperBound 값 사이에서 선형으로 값들을 생성합니다.</p>
<p>결과적으로, AnimationController를 사용하면 다음을 할 수 있습니다:</p>
<ul>
<li>forward()을 호출하여 애니메이션을 앞으로 재생합니다.</li>
<li>reverse()를 호출하여 애니메이션을 역방향으로 재생합니다.</li>
<li>stop()을 호출하여 애니메이션을 멈춥니다.</li>
<li>repeat()을 호출하여 애니메이션을 가시 상태인 한 계속 반복합니다.</li>
<li>reset()을 호출하여 애니메이션을 lowerBound로 재설정합니다.</li>
<li>값을 설정합니다.</li>
<li>isAnimating, isCompleted, isDismissed 등과 같이 애니메이션의 상태를 알아내기 위해 다양한 get 함수에 액세스합니다.</li>
</ul>
<p>자, 이 멋진 놈을 사용하여 실제 작업을 확인해 보겠습니다 🎬</p>
<h2>2.1. 준비된 위젯을 사용한 명시적 애니메이션</h2>
<p>맨 위로 이동 👆🏼</p>
<p>그들은 FooTransition 위젯이라고 불립니다. 이 때 Foo는 위젯의 애니메이션 속성입니다. 일부는 당신이 사용하는 일반 위젯의 애니메이션 가능한 위젯들입니다. 예를 들어, AlignTransition, PositionedTransition가 있습니다.</p>
<p>이 애니메이션을 확인해보세요:</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*GYCKdoQEUQeblnBoyoEHjQ.gif" alt="animation"></p>
<p>이것은 AlignTransition 및 RotationTransition 위젯을 사용하여 달성되었습니다.</p>
<p>코드 분석:</p>
<ul>
<li>
<p>10번 줄 및 17번 줄: AnimationController를 초기화하고 정의합니다.</p>
</li>
<li>
<p>AnimationController의 vsync 값 (19번 줄)은 SingleTickerProviderStateMixin(9번 줄)에서 가져온 값입니다. 이 mixin은 우리에게 이야기한 TickerProvider를 제공합니다. 또한 위젯이 보이는 상태일 때만 애니메이션이 실행되도록 보장합니다.</p>
</li>
<li>
<p>11번 줄 및 22번 줄: AlignTransition 위젯의 Animation을 초기화하고 정의합니다 (51번 줄). AlignmentGeometry 유형의 Tween을 사용하여 애니메이션을 정의합니다. 결국, 애니메이션은 Alignment.centerLeft에서 Alignment.centerRight로 애니메이션될 것임을 알려주고 Tween의 animate 메서드를 호출하여 이 애니메이션을 AnimationController와 연결한 후 AlignmentGeometry 유형의 Animation을 반환합니다. 이렇게 하면 AnimationController의 하한 및 상한이 아니라 Tween의 시작 및 종료 값 사이에서 애니메이션이 작동합니다.</p>
</li>
<li>
<p>12번 줄 및 32번 줄: RotationTransition 위젯의 회전 속성(turns)의 애니메이션을 초기화하고 정의합니다 (53번 줄). 따라서 0부터 2까지의 시작 및 종료 값이 있으므로, 애니메이션이 끝나면 위젯은 두 번 회전할 것입니다.</p>
</li>
<li>
<p>20번 줄: AnimationController에 반복을 호출하여 애니메이션이 계속되도록 만듭니다. 그리고 reverse를 true로 설정하면 애니메이션이 순방향으로 시작하여 반대로, 다시 순방향으로, ... 이렇게 반복됩니다.</p>
</li>
<li>
<p>42번 줄: 위젯의 상태가 dispose되는 시점에 AnimationController를 폐기(dispose)합니다. 메모리 누수를 방지하기 위해 AnimationController를 dispose하는 것은 항상 중요합니다!</p>
</li>
</ul>
<p>하지만 걱정하지 마세요. 조금의 연습으로 매우 쉬워지고 익숙해질 것입니다!</p>
<p>가능한 모든 FooTransition 위젯 목록입니다:</p>
<p>암시적 애니메이션에서 AnimatedFoo 위젯이 애니메이션 목적에 충분하지 않을 때 어떻게 했는지 기억하나요? AnimatedFoo 위젯으로 처리되지 않은 속성을 애니메이션화하기 위해 TweenAnimationBuilder를 사용했습니다. 비슷하게, 명시적 애니메이션에서는 AnimatedBuilder 위젯을 사용하여 어떤 위젯 속성을 애니메이션화할 수 있습니다. 또는 더 나아가서 직접 FooTransition을 만들기 위해 AnimatedWidget 클래스를 사용할 수도 있습니다!</p>
<h2>2.2 AnimatedBuilder 위젯을 사용한 명시적 애니메이션</h2>
<p>맨 위로 이동 👆🏼</p>
<p>다음 애니메이션을 확인해보세요:</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*whGvEQM5o0b4W0hZIkgu_A.gif" alt="Animation"></p>
<p>GradientTransition 위젯이 없죠? 그럼 어떻게 만들었을까요? AnimatedBuilder 위젯을 이용했어요! 여기에 코드가 있어요:</p>
<p>우리는 AnimationController를 초기화하고 정의했고 이를 AnimatedBuilder 위젯의 애니메이션 값으로 사용했어요. 이제 AnimatedBuilder는 컨트롤러의 값이 변경될 때마다 "다시 빌드(build)"되고 빌더를 호출하여 업데이트된 _controller.value 값을 가진 새 위젯을 반환해요. 이로써 그라데이션이 애니메이션 되게 만들었어요.</p>
<p>물론, AnimationController의 lowerBound 및 upperBound 값 이외의 것을 원한다면, 자체 Animation을 만들고 AnimationController에 연결한 다음 AnimatedBuilder 위젯에 전달할 수 있습니다.</p>
<pre><code class="hljs language-dart">_animation = Tween&#x3C;<span class="hljs-built_in">double</span>>(begin: <span class="hljs-number">0</span>, end: <span class="hljs-number">0.5</span>).animate(_controller);
<span class="hljs-comment">//...</span>
AnimatedBuilder(
  animation: _animation,
  builder: (context, child) {
     <span class="hljs-comment">//... 값 사용하기: _animation.value</span>
  }
)
</code></pre>
<p>또한 AnimatedBuilder 위젯의 child 매개변수를 사용하여 성능을 향상시킬 수 있습니다. 이렇게 하면 매번 애니메이션 값이 변경될 때마다 다시 구축되지 않습니다.</p>
<p>아직 따라오고 있나요? 조금만 더 힘내세요! 거의 끝났습니다!</p>
<p>이제 한 걸음 더 나아가서 AnimatedWidget 클래스를 사용하여 우리만의 FooTransition 위젯을 만들어보겠습니다!</p>
<h2>2.3 AnimatedWidget 클래스를 사용한 명시적 애니메이션</h2>
<p>맨 위로 이동 👆🏼</p>
<p>아주 비밀스러운 비밀을 하나 알려줄게요. 어떤 FooTransition 위젯의 소스 코드로 가 보세요, 무엇을 보게 될까요?</p>
<p><img src="/assets/img/2024-06-21-FlutterAnimationsComprehensiveGuide_1.png" alt="Image 1"></p>
<p>😱 It extends an AnimatedWidget class, and from what we see, the Animation type parameter (in this case turns) is passed as a listenable to the super class:</p>
<p><img src="/assets/img/2024-06-21-FlutterAnimationsComprehensiveGuide_2.png" alt="Image 2"></p>
<p>And the AnimatedWidget is basically a StatefulWidget! So we can do the exact same!</p>
<p>우리만의 GradientTransition 위젯을 만들어봅시다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GradientTransition</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">AnimatedWidget</span> {
  final <span class="hljs-title class_">Animation</span>&#x3C;double> stop;

  <span class="hljs-keyword">const</span> <span class="hljs-title class_">GradientTransition</span>({
    <span class="hljs-title class_">Key</span>? key,
    required <span class="hljs-variable language_">this</span>.<span class="hljs-property">stop</span>,
  }) : <span class="hljs-variable language_">super</span>(<span class="hljs-attr">key</span>: key, <span class="hljs-attr">listenable</span>: stop);

  @override
  <span class="hljs-title class_">Widget</span> <span class="hljs-title function_">build</span>(<span class="hljs-params">BuildContext context</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Container</span>(
      <span class="hljs-attr">height</span>: <span class="hljs-number">100</span>,
      <span class="hljs-attr">decoration</span>: <span class="hljs-title class_">BoxDecoration</span>(
        <span class="hljs-attr">gradient</span>: <span class="hljs-title class_">LinearGradient</span>(
          <span class="hljs-attr">colors</span>: <span class="hljs-keyword">const</span> [purple, pink, yellow],
          <span class="hljs-attr">stops</span>: [<span class="hljs-number">0</span>, stop.<span class="hljs-property">value</span>, <span class="hljs-number">1</span>],
        ),
      ),
    );
  }
}
</code></pre>
<p>그리고 사용하기 위해서는 AnimationController를 그대로 전달하면 됩니다:</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">GradientTransition</span>(<span class="hljs-attr">stop</span>: _controller),
</code></pre>
<p>그게 다야!</p>
<p>여기까지 버텨내 왔다면, 매우 간단한 것부터 매우 복잡한 것까지 다양한 플러터 애니메이션을 만들기에 충분한 지식을 가지고 있습니다. 필요한 건 조금의 연습뿐이며, 하늘이 한계입니다!</p>
<h1>적절한 애니메이션 접근 방식 선택</h1>
<p>맨 위로 이동 👆🏼</p>
<p>하지만 잠시만 기다려봐요. 위에서 다룬 여러 방법 중에서 어떤 애니메이션을 선택해야 하는지 어떻게 알 수 있을까요? 플러터(Flutter) 팀의 멋진 분들이 도와주기 위해 비디오와 의사결정 트리를 만들었어요. 제가 최대한 요약해 드릴게요.</p>
<h2>1. 그림 기반 vs. 코드 기반</h2>
<p>첫 번째 선택은 그림 기반 및 코드 기반 애니메이션 사이에서 이루어질 거예요. 이를 위해 자신에게 물어보세요. 만약 당신의 애니메이션이 그림처럼 더 비스무런가요(그림 기반 사용, 3rd party 패키지 사용, 곧 설명할 거예요) 아니면 레이아웃, 위젯, 위젯 스타일, 색상, 테두리, 텍스트 등과 관련이 있는가요(코드 기반 사용, 위에서 설명한 것)?</p>
<h2>2. 암시적(Implicit) vs. 명시적(Explicit)</h2>
<p>다음 선택은 암시적 및 명시적 애니메이션 중 하나가 될 것입니다. 선택을 하는 데 고려해야 할 여러 기준이 있습니다:</p>
<ul>
<li>무한히 반복되는 애니메이션</li>
<li>연속되지 않는 애니메이션: 애니메이션이 시작 지점으로 돌아가지 않음</li>
<li>여러 위젯이 함께 애니메이션화되는 경우</li>
</ul>
<p>만약 애니메이션이 위의 기준 중 하나라도 가지고 있다면, 명시적 애니메이션을 사용해야 합니다.</p>
<h2>3. 내장 위젯 대 사용자 정의 위젯</h2>
<p>마지막 선택 사항은 내장 위젯(AnimatedFoo 및 FooTransition 위젯)과 사용자 지정 위젯(TweenAnimationBuilder 및 AnimatedBuilder/AnimatedWidget) 사이에서 합니다. 이것은 이 목록을 보고 원하는 속성을 애니메이션화하기 위해 이미 내장된 위젯이 있는지 여부를 고려하는 것만큼 간단합니다. 해당 내장 위젯을 사용하거나 (그렇지 않으면 직접 생성)</p>
<h1>3rd Party 패키지를 사용한 애니메이션</h1>
<p>하지만 앱에서 그림을 기반으로 한 애니메이션을 사용하고 싶다면 어떨까요? 여기서는 코딩이 절약되었네요 🫢, 또한 플러터는 여기에서도 놀라울 정도로 좋습니다! Rive 및 Lottie와 같은 훌륭한 패키지들이 있어서 3rd party 애니메이션을 원활하게 통합하고 앱에 추가할 수 있습니다. 제공되는 애니메이션을 그래픽 디자이너/모션 그래픽 디자이너와 함께 사용하거나 커뮤니티에서 만든 애니메이션을 다운로드/구매하여 빠르고 쉽게 앱에 사용할 수 있습니다.</p>
<p>3rd party 패키지를 사용하여 Flutter에서 애니메이션을 만드는 데 관한 전용 기사를 작성할 예정이에요. 지금 당장 유용한 링크 몇 개를 공유해 드릴게요:</p>
<ul>
<li>사용 준비가 된 멋진 애니메이션을 볼 수 있는 Rive 커뮤니티 쇼케이스</li>
<li>Rive Flutter 패키지</li>
<li>무료 LottieFiles 애니메이션</li>
<li>LottieFiles Flutter 패키지</li>
</ul>
<p>여기까지가 제 글이에요! 이 기사를 읽어 주셔서 감사합니다. 이것이 Flutter 앱에 애니메이션을 추가하고 싶을 때 여러분의 정보원이 되었으면 좋겠어요. 그럼 여러분도 애니메이션을 넣을 때 즐겁게 시도해 보세요!</p>
<p><a href="https://twitter.com/FlutterComm" rel="nofollow" target="_blank">https://twitter.com/FlutterComm</a></p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Flutter 애니메이션 종합 가이드","description":"","date":"2024-06-21 22:15","slug":"2024-06-21-FlutterAnimationsComprehensiveGuide","content":"\n\n이 기사에서는 플러터 애니메이션에 대해 자세히 설명하고 여러 예제와 함께 다루어보겠습니다. 이 기사를 끝까지 읽으면 다양한 복잡성을 갖는 애니메이션을 플러터 앱에 추가할 수 있을 것입니다. 또한 플러터에서 제공하는 다양한 접근 방법 중에서 여러분의 애니메이션 목표에 가장 적합한 것을 알게 될 것입니다. 그럼 바로 시작해 봅시다!\n\n![Flutter Animations](/assets/img/2024-06-21-FlutterAnimationsComprehensiveGuide_0.png)\n\n## 목차:\n\n- 소개\n- 암시적 애니메이션 - AnimatedFoo 위젯\n- 암시적 애니메이션 - TweenAnimationBuilder 위젯\n- 명시적 애니메이션 - FooTransition 위젯\n- AnimationController\n- 명시적 애니메이션 - AnimatedBuilder 위젯\n- 명시적 애니메이션 - AnimatedWidget 클래스\n- 올바른 애니메이션 접근 방법 선택하기\n- 서드파티 패키지를 사용한 애니메이션\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## TL;DR\n\n이 튜토리얼에서 모든 애니메이션의 코드를 DartPad에서 볼 수 있어요. 코드를 손대면서 실험해보세요.\n\n최근에는 이 튜토리얼을 요약한 트위터 스레드도 올렸어요. 한 번 확인해보세요.\n\n# 소개\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플러터 앱에서 애니메이션은 기본적으로 두 가지 유형으로 볼 수 있어요: 그리기 기반 애니메이션과 코드 기반 애니메이션이에요. 그리기 기반 애니메이션은 애니메이션된 그래픽, 벡터, 캐릭터 또는 \"그려진\" 모든 것을 말해요. 한편, 코드 기반 애니메이션은 위젯 레이아웃 및 스타일(리스트, 색상, 텍스트 등)에 중점을 두었어요. 이 글의 끝에는 그리기 기반 애니메이션에 대해 간략히 다뤄볼 거에요. 그러나 그들은 보통 3rd party 프레임워크/패키지를 사용하여 달성되므로, 우리는 코드 기반 애니메이션에보다 초점을 맞출 거예요. 코드 기반 애니메이션은 제한적이라는 의미가 아니라, 그 반대로 플러터 애니메이션을 통해 완전히 멋진, 창의적이고 매우 복잡한 애니메이션을 만들 수 있어요. 3rd party 패키지가 필요하지 않아요!\n\n플러터의 코드 기반 애니메이션에는 암시적 애니메이션 및 명시적 애니메이션이 두 가지 유형이 있어요. 이러한 유형 각각에서 준비된 위젯을 사용하거나 직접 위젯을 만들 수 있어요. 각 유형에 대해 몇 가지 예제와 함께 더 자세히 알아보겠어요.\n\n# 1. 암시적 애니메이션\n\n맨 위로 이동하기 👆🏼\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가장 간단하고 사용하기 쉬운 애니메이션입니다. 값만 변경하면 애니메이션이 트리거되고, Flutter가 모든 것을 자동으로 처리해줍니다.\n\n## 1.1 준비된 위젯으로 암묵적 애니메이션\n\n이들은 AnimatedFoo 위젯이라고 불립니다. 여기서 Foo는 애니메이션 속성을 나타냅니다. 대부분은 이미 알고 사용하는 위젯의 애니메이션 버전입니다. 예를 들어 Container/AnimatedContainer, Padding/AnimatedPadding, Positioned/AnimatedPositioned 등이 있습니다.\n\n예를 들어, 다음 애니메이션을 확인해보세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:930/1*cjoraoQHodaUhNx7z2n1aA.gif\" /\u003e\n\n이 애니메이션은 AnimatedContainer, AnimatedPositioned 및 AnimatedDefaultTextStyle 위젯만을 사용하여 구현되었습니다. 지속 시간 값을 지정하고 변경 가능한 변수를 제공하면 끝입니다!\n\n```js\nAnimatedPositioned(\n  top: selectedItemIndex * itemHeight,\n  left: 0,\n  right: 0,\n  duration: const Duration(milliseconds: 200),\n  curve: Curves.easeInOut,\n  child: //...\n),\n//...\nAnimatedContainer(\n  duration: const Duration(milliseconds: 200),\n  curve: Curves.easeInOut,\n  decoration: BoxDecoration(\n    color: selectedItemIndex == i ? yellow : pink,\n    border: Border.all(\n      color: selectedItemIndex == i\n          ? Colors.white\n          : Colors.transparent,\n      width: 2,\n    ),\n  ),\n  child: AnimatedDefaultTextStyle(\n    duration: const Duration(milliseconds: 200),\n    style: TextStyle(\n      color: selectedItemIndex == i\n          ? Colors.black\n          : Colors.white,\n    ),\n    child: const Text('Featured!'),\n  ),\n),\n```\n\n그리고 간단히 각 목록 항목은 아래와 같은 onTap 메서드가 있는 InkWell 위젯으로 래핑되어 있습니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nonTap: () =\u003e setState(() =\u003e selectedItemIndex = i),\n```\n\n이렇게 하면 애니메이션을 트리거할 수 있어요!\n\n여기 사용 가능한 AnimatedFoo 위젯 전체 목록이 있어요.\n\n따라서 우리는 AnimatedFoo 위젯을 투명도, 패딩, 정렬, 위치와 같은 속성용으로 가지고 있어요. 하지만 다른 속성을 애니메이션화하고 싶을 때 어떡하나요? 그럼 여전히 쉽고 빠르게 사용하고 싶어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 1.2. TweenAnimationBuilder를 사용한 암시적 애니메이션\n\n화면 맨 위로 이동 👆🏼\n\nTweenAnimationBuilder를 사용하면 Tween 클래스를 사용하여 모든 위젯의 속성을 암시적으로 애니메이트할 수 있습니다. Tween 클래스의 이름은 \"Between\"에서 따왔습니다. 기본적으로 애니메이트해야 할 시작 및 끝 값을 제공합니다. 그리고 TweenAnimationBuilder 위젯의 빌더는 애니메이션 값으로 제공되며 이 값을 해당 빌더에서 반환하는 위젯의 어떤 속성에 적용할 수 있습니다.\n\n다음은 예시 애니메이션입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 해당 코드입니다:\n\n```js\nTweenAnimationBuilder(\n  duration: const Duration(milliseconds: 200),\n  tween: Tween\u003cdouble\u003e(begin: 0.01, end: _sliderValue),\n  child: Container(\n    decoration: BoxDecoration(\n      //...\n    ),\n    child: Slider(\n      value: _sliderValue,\n      min: 0.01,\n      onChanged: (value) {\n        setState(() =\u003e _sliderValue = value);\n      },\n    ),\n  ),\n  builder: (BuildContext context, double? value, Widget? child) {\n    return ClipRect(\n      child: BackdropFilter(\n        filter: ImageFilter.blur(\n          sigmaX: 40 * (value ?? 0.01),\n          sigmaY: 40 * (value ?? 0.01),\n        ),\n        child: child,\n      ),\n    );\n  },\n);\n```\n\n_sliderValue 변수는 0.01에서 1로 변경됩니다. 따라서 각 값의 변경마다 애니메이션이 트리거되며 BackdropFilter 위젯의 sigmaX 및 sigmaY 속성을 위한 새 값으로 다시 빌더 함수가 재구성됩니다. (0 값을 주면 BackdropFilter 위젯이 웹에서 오류를 발생시키기 때문에 0.01을 사용했습니다.)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nTweenAnimationBuilder의 child 매개변수를 사용하여 더 나은 성능을 위해 빌더를 활용하고 있어요. 이 child는 애니메이션이 트리거될 때마다 다시 빌드하는 대신 한 번만 다시 빌드되어요.\n\n좋아요, 쉬운 내용은 끝났습니다. 이제 본격적인 내용을 시작해볼까요?\n\n# 2. 명시적 애니메이션\n\n맨 위로 돌아가기 👆🏼\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n암시적 애니메이션에서 AnimatedFoo 또는 TweenAnimationBuilder 위젯 내부의 값만 변경하면 애니메이션이 트리거되었던 것을 기억하시나요? 그러나 명시적 애니메이션은 \"명시적으로\" 애니메이트할 때까지 애니메이션을 트리거하지 않습니다. 애니메이션을 시작하고 어떻게 애니메이트할지 및 AnimationController를 사용하여 애니메이션을 \"제어\"하는 방법을 알려주어야 합니다.\n\n명시적 애니메이션 역시 암시적 애니메이션과 유사하게 사용하기 쉬운 위젯과 사용자 정의 수준이 추가된 위젯이 준비되어 있어 자유롭게 사용할 수 있습니다!\n\n그런데, AnimationController가 무엇인지 궁금하시죠? 이를 사용하는 명시적 애니메이션 위젯에 대해 알아보기 전에 먼저 AnimationController에 대해 학습해 보겠습니다.\n\n## AnimationController\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위로 이동 👆🏼\n\n```js\nAnimationController({\n  double? value,\n  this.duration,\n  this.reverseDuration,\n  this.debugLabel,\n  this.lowerBound = 0.0,\n  this.upperBound = 1.0,\n  this.animationBehavior = AnimationBehavior.normal,\n  required TickerProvider vsync,\n})\n```\n\n이전에 언급했듯이 AnimationController를 사용하면 애니메이션을 \"제어\"할 수 있습니다. 그를 위해서는 vsync 값이 TickerProvider 유형이 필요합니다. Ticker는 기본적으로 Flutter의 프레임 렌더링을 추적하고 컨트롤러가 해당 티커를 따라가서 지정된 기간 내에 '애니메이션'할 수 있도록 허용하며, 기본적으로 0과 1인 lowerBound 및 upperBound 값 사이에서 선형으로 값들을 생성합니다.\n\n결과적으로, AnimationController를 사용하면 다음을 할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- forward()을 호출하여 애니메이션을 앞으로 재생합니다.\n- reverse()를 호출하여 애니메이션을 역방향으로 재생합니다.\n- stop()을 호출하여 애니메이션을 멈춥니다.\n- repeat()을 호출하여 애니메이션을 가시 상태인 한 계속 반복합니다.\n- reset()을 호출하여 애니메이션을 lowerBound로 재설정합니다.\n- 값을 설정합니다.\n- isAnimating, isCompleted, isDismissed 등과 같이 애니메이션의 상태를 알아내기 위해 다양한 get 함수에 액세스합니다.\n\n자, 이 멋진 놈을 사용하여 실제 작업을 확인해 보겠습니다 🎬\n\n## 2.1. 준비된 위젯을 사용한 명시적 애니메이션\n\n맨 위로 이동 👆🏼\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그들은 FooTransition 위젯이라고 불립니다. 이 때 Foo는 위젯의 애니메이션 속성입니다. 일부는 당신이 사용하는 일반 위젯의 애니메이션 가능한 위젯들입니다. 예를 들어, AlignTransition, PositionedTransition가 있습니다.\n\n이 애니메이션을 확인해보세요:\n\n![animation](https://miro.medium.com/v2/resize:fit:1400/1*GYCKdoQEUQeblnBoyoEHjQ.gif)\n\n이것은 AlignTransition 및 RotationTransition 위젯을 사용하여 달성되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n코드 분석:\n\n- 10번 줄 및 17번 줄: AnimationController를 초기화하고 정의합니다.\n- AnimationController의 vsync 값 (19번 줄)은 SingleTickerProviderStateMixin(9번 줄)에서 가져온 값입니다. 이 mixin은 우리에게 이야기한 TickerProvider를 제공합니다. 또한 위젯이 보이는 상태일 때만 애니메이션이 실행되도록 보장합니다.\n- 11번 줄 및 22번 줄: AlignTransition 위젯의 Animation을 초기화하고 정의합니다 (51번 줄). AlignmentGeometry 유형의 Tween을 사용하여 애니메이션을 정의합니다. 결국, 애니메이션은 Alignment.centerLeft에서 Alignment.centerRight로 애니메이션될 것임을 알려주고 Tween의 animate 메서드를 호출하여 이 애니메이션을 AnimationController와 연결한 후 AlignmentGeometry 유형의 Animation을 반환합니다. 이렇게 하면 AnimationController의 하한 및 상한이 아니라 Tween의 시작 및 종료 값 사이에서 애니메이션이 작동합니다.\n\n- 12번 줄 및 32번 줄: RotationTransition 위젯의 회전 속성(turns)의 애니메이션을 초기화하고 정의합니다 (53번 줄). 따라서 0부터 2까지의 시작 및 종료 값이 있으므로, 애니메이션이 끝나면 위젯은 두 번 회전할 것입니다.\n- 20번 줄: AnimationController에 반복을 호출하여 애니메이션이 계속되도록 만듭니다. 그리고 reverse를 true로 설정하면 애니메이션이 순방향으로 시작하여 반대로, 다시 순방향으로, ... 이렇게 반복됩니다.\n- 42번 줄: 위젯의 상태가 dispose되는 시점에 AnimationController를 폐기(dispose)합니다. 메모리 누수를 방지하기 위해 AnimationController를 dispose하는 것은 항상 중요합니다!\n\n하지만 걱정하지 마세요. 조금의 연습으로 매우 쉬워지고 익숙해질 것입니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가능한 모든 FooTransition 위젯 목록입니다:\n\n암시적 애니메이션에서 AnimatedFoo 위젯이 애니메이션 목적에 충분하지 않을 때 어떻게 했는지 기억하나요? AnimatedFoo 위젯으로 처리되지 않은 속성을 애니메이션화하기 위해 TweenAnimationBuilder를 사용했습니다. 비슷하게, 명시적 애니메이션에서는 AnimatedBuilder 위젯을 사용하여 어떤 위젯 속성을 애니메이션화할 수 있습니다. 또는 더 나아가서 직접 FooTransition을 만들기 위해 AnimatedWidget 클래스를 사용할 수도 있습니다!\n\n## 2.2 AnimatedBuilder 위젯을 사용한 명시적 애니메이션\n\n맨 위로 이동 👆🏼\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 애니메이션을 확인해보세요:\n\n![Animation](https://miro.medium.com/v2/resize:fit:1400/1*whGvEQM5o0b4W0hZIkgu_A.gif)\n\nGradientTransition 위젯이 없죠? 그럼 어떻게 만들었을까요? AnimatedBuilder 위젯을 이용했어요! 여기에 코드가 있어요:\n\n우리는 AnimationController를 초기화하고 정의했고 이를 AnimatedBuilder 위젯의 애니메이션 값으로 사용했어요. 이제 AnimatedBuilder는 컨트롤러의 값이 변경될 때마다 \"다시 빌드(build)\"되고 빌더를 호출하여 업데이트된 _controller.value 값을 가진 새 위젯을 반환해요. 이로써 그라데이션이 애니메이션 되게 만들었어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n물론, AnimationController의 lowerBound 및 upperBound 값 이외의 것을 원한다면, 자체 Animation을 만들고 AnimationController에 연결한 다음 AnimatedBuilder 위젯에 전달할 수 있습니다.\n\n```dart\n_animation = Tween\u003cdouble\u003e(begin: 0, end: 0.5).animate(_controller);\n//...\nAnimatedBuilder(\n  animation: _animation,\n  builder: (context, child) {\n     //... 값 사용하기: _animation.value\n  }\n)\n```\n\n또한 AnimatedBuilder 위젯의 child 매개변수를 사용하여 성능을 향상시킬 수 있습니다. 이렇게 하면 매번 애니메이션 값이 변경될 때마다 다시 구축되지 않습니다.\n\n아직 따라오고 있나요? 조금만 더 힘내세요! 거의 끝났습니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 한 걸음 더 나아가서 AnimatedWidget 클래스를 사용하여 우리만의 FooTransition 위젯을 만들어보겠습니다!\n\n## 2.3 AnimatedWidget 클래스를 사용한 명시적 애니메이션\n\n맨 위로 이동 👆🏼\n\n아주 비밀스러운 비밀을 하나 알려줄게요. 어떤 FooTransition 위젯의 소스 코드로 가 보세요, 무엇을 보게 될까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image 1](/assets/img/2024-06-21-FlutterAnimationsComprehensiveGuide_1.png)\n\n😱 It extends an AnimatedWidget class, and from what we see, the Animation type parameter (in this case turns) is passed as a listenable to the super class:\n\n![Image 2](/assets/img/2024-06-21-FlutterAnimationsComprehensiveGuide_2.png)\n\nAnd the AnimatedWidget is basically a StatefulWidget! So we can do the exact same!\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리만의 GradientTransition 위젯을 만들어봅시다:\n\n```js\nclass GradientTransition extends AnimatedWidget {\n  final Animation\u003cdouble\u003e stop;\n\n  const GradientTransition({\n    Key? key,\n    required this.stop,\n  }) : super(key: key, listenable: stop);\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      height: 100,\n      decoration: BoxDecoration(\n        gradient: LinearGradient(\n          colors: const [purple, pink, yellow],\n          stops: [0, stop.value, 1],\n        ),\n      ),\n    );\n  }\n}\n```\n\n그리고 사용하기 위해서는 AnimationController를 그대로 전달하면 됩니다:\n\n```js\nGradientTransition(stop: _controller),\n```  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그게 다야!\n\n여기까지 버텨내 왔다면, 매우 간단한 것부터 매우 복잡한 것까지 다양한 플러터 애니메이션을 만들기에 충분한 지식을 가지고 있습니다. 필요한 건 조금의 연습뿐이며, 하늘이 한계입니다!\n\n# 적절한 애니메이션 접근 방식 선택\n\n맨 위로 이동 👆🏼\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 잠시만 기다려봐요. 위에서 다룬 여러 방법 중에서 어떤 애니메이션을 선택해야 하는지 어떻게 알 수 있을까요? 플러터(Flutter) 팀의 멋진 분들이 도와주기 위해 비디오와 의사결정 트리를 만들었어요. 제가 최대한 요약해 드릴게요.\n\n## 1. 그림 기반 vs. 코드 기반\n\n첫 번째 선택은 그림 기반 및 코드 기반 애니메이션 사이에서 이루어질 거예요. 이를 위해 자신에게 물어보세요. 만약 당신의 애니메이션이 그림처럼 더 비스무런가요(그림 기반 사용, 3rd party 패키지 사용, 곧 설명할 거예요) 아니면 레이아웃, 위젯, 위젯 스타일, 색상, 테두리, 텍스트 등과 관련이 있는가요(코드 기반 사용, 위에서 설명한 것)?\n\n## 2. 암시적(Implicit) vs. 명시적(Explicit)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 선택은 암시적 및 명시적 애니메이션 중 하나가 될 것입니다. 선택을 하는 데 고려해야 할 여러 기준이 있습니다:\n\n- 무한히 반복되는 애니메이션\n- 연속되지 않는 애니메이션: 애니메이션이 시작 지점으로 돌아가지 않음\n- 여러 위젯이 함께 애니메이션화되는 경우\n\n만약 애니메이션이 위의 기준 중 하나라도 가지고 있다면, 명시적 애니메이션을 사용해야 합니다.\n\n## 3. 내장 위젯 대 사용자 정의 위젯\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마지막 선택 사항은 내장 위젯(AnimatedFoo 및 FooTransition 위젯)과 사용자 지정 위젯(TweenAnimationBuilder 및 AnimatedBuilder/AnimatedWidget) 사이에서 합니다. 이것은 이 목록을 보고 원하는 속성을 애니메이션화하기 위해 이미 내장된 위젯이 있는지 여부를 고려하는 것만큼 간단합니다. 해당 내장 위젯을 사용하거나 (그렇지 않으면 직접 생성)\n\n# 3rd Party 패키지를 사용한 애니메이션\n\n하지만 앱에서 그림을 기반으로 한 애니메이션을 사용하고 싶다면 어떨까요? 여기서는 코딩이 절약되었네요 🫢, 또한 플러터는 여기에서도 놀라울 정도로 좋습니다! Rive 및 Lottie와 같은 훌륭한 패키지들이 있어서 3rd party 애니메이션을 원활하게 통합하고 앱에 추가할 수 있습니다. 제공되는 애니메이션을 그래픽 디자이너/모션 그래픽 디자이너와 함께 사용하거나 커뮤니티에서 만든 애니메이션을 다운로드/구매하여 빠르고 쉽게 앱에 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3rd party 패키지를 사용하여 Flutter에서 애니메이션을 만드는 데 관한 전용 기사를 작성할 예정이에요. 지금 당장 유용한 링크 몇 개를 공유해 드릴게요:\n\n- 사용 준비가 된 멋진 애니메이션을 볼 수 있는 Rive 커뮤니티 쇼케이스\n- Rive Flutter 패키지\n- 무료 LottieFiles 애니메이션\n- LottieFiles Flutter 패키지\n\n여기까지가 제 글이에요! 이 기사를 읽어 주셔서 감사합니다. 이것이 Flutter 앱에 애니메이션을 추가하고 싶을 때 여러분의 정보원이 되었으면 좋겠어요. 그럼 여러분도 애니메이션을 넣을 때 즐겁게 시도해 보세요!\n\nhttps://twitter.com/FlutterComm","ogImage":{"url":"/assets/img/2024-06-21-FlutterAnimationsComprehensiveGuide_0.png"},"coverImage":"/assets/img/2024-06-21-FlutterAnimationsComprehensiveGuide_0.png","tag":["Tech"],"readingTime":12},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e이 기사에서는 플러터 애니메이션에 대해 자세히 설명하고 여러 예제와 함께 다루어보겠습니다. 이 기사를 끝까지 읽으면 다양한 복잡성을 갖는 애니메이션을 플러터 앱에 추가할 수 있을 것입니다. 또한 플러터에서 제공하는 다양한 접근 방법 중에서 여러분의 애니메이션 목표에 가장 적합한 것을 알게 될 것입니다. 그럼 바로 시작해 봅시다!\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-FlutterAnimationsComprehensiveGuide_0.png\" alt=\"Flutter Animations\"\u003e\u003c/p\u003e\n\u003ch2\u003e목차:\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e소개\u003c/li\u003e\n\u003cli\u003e암시적 애니메이션 - AnimatedFoo 위젯\u003c/li\u003e\n\u003cli\u003e암시적 애니메이션 - TweenAnimationBuilder 위젯\u003c/li\u003e\n\u003cli\u003e명시적 애니메이션 - FooTransition 위젯\u003c/li\u003e\n\u003cli\u003eAnimationController\u003c/li\u003e\n\u003cli\u003e명시적 애니메이션 - AnimatedBuilder 위젯\u003c/li\u003e\n\u003cli\u003e명시적 애니메이션 - AnimatedWidget 클래스\u003c/li\u003e\n\u003cli\u003e올바른 애니메이션 접근 방법 선택하기\u003c/li\u003e\n\u003cli\u003e서드파티 패키지를 사용한 애니메이션\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eTL;DR\u003c/h2\u003e\n\u003cp\u003e이 튜토리얼에서 모든 애니메이션의 코드를 DartPad에서 볼 수 있어요. 코드를 손대면서 실험해보세요.\u003c/p\u003e\n\u003cp\u003e최근에는 이 튜토리얼을 요약한 트위터 스레드도 올렸어요. 한 번 확인해보세요.\u003c/p\u003e\n\u003ch1\u003e소개\u003c/h1\u003e\n\u003cp\u003e플러터 앱에서 애니메이션은 기본적으로 두 가지 유형으로 볼 수 있어요: 그리기 기반 애니메이션과 코드 기반 애니메이션이에요. 그리기 기반 애니메이션은 애니메이션된 그래픽, 벡터, 캐릭터 또는 \"그려진\" 모든 것을 말해요. 한편, 코드 기반 애니메이션은 위젯 레이아웃 및 스타일(리스트, 색상, 텍스트 등)에 중점을 두었어요. 이 글의 끝에는 그리기 기반 애니메이션에 대해 간략히 다뤄볼 거에요. 그러나 그들은 보통 3rd party 프레임워크/패키지를 사용하여 달성되므로, 우리는 코드 기반 애니메이션에보다 초점을 맞출 거예요. 코드 기반 애니메이션은 제한적이라는 의미가 아니라, 그 반대로 플러터 애니메이션을 통해 완전히 멋진, 창의적이고 매우 복잡한 애니메이션을 만들 수 있어요. 3rd party 패키지가 필요하지 않아요!\u003c/p\u003e\n\u003cp\u003e플러터의 코드 기반 애니메이션에는 암시적 애니메이션 및 명시적 애니메이션이 두 가지 유형이 있어요. 이러한 유형 각각에서 준비된 위젯을 사용하거나 직접 위젯을 만들 수 있어요. 각 유형에 대해 몇 가지 예제와 함께 더 자세히 알아보겠어요.\u003c/p\u003e\n\u003ch1\u003e1. 암시적 애니메이션\u003c/h1\u003e\n\u003cp\u003e맨 위로 이동하기 👆🏼\u003c/p\u003e\n\u003cp\u003e가장 간단하고 사용하기 쉬운 애니메이션입니다. 값만 변경하면 애니메이션이 트리거되고, Flutter가 모든 것을 자동으로 처리해줍니다.\u003c/p\u003e\n\u003ch2\u003e1.1 준비된 위젯으로 암묵적 애니메이션\u003c/h2\u003e\n\u003cp\u003e이들은 AnimatedFoo 위젯이라고 불립니다. 여기서 Foo는 애니메이션 속성을 나타냅니다. 대부분은 이미 알고 사용하는 위젯의 애니메이션 버전입니다. 예를 들어 Container/AnimatedContainer, Padding/AnimatedPadding, Positioned/AnimatedPositioned 등이 있습니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, 다음 애니메이션을 확인해보세요:\u003c/p\u003e\n\u003cp\u003e이 애니메이션은 AnimatedContainer, AnimatedPositioned 및 AnimatedDefaultTextStyle 위젯만을 사용하여 구현되었습니다. 지속 시간 값을 지정하고 변경 가능한 변수를 제공하면 끝입니다!\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eAnimatedPositioned\u003c/span\u003e(\n  \u003cspan class=\"hljs-attr\"\u003etop\u003c/span\u003e: selectedItemIndex * itemHeight,\n  \u003cspan class=\"hljs-attr\"\u003eleft\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eright\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eduration\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDuration\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003emilliseconds\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e),\n  \u003cspan class=\"hljs-attr\"\u003ecurve\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCurves\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eeaseInOut\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-comment\"\u003e//...\u003c/span\u003e\n),\n\u003cspan class=\"hljs-comment\"\u003e//...\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eAnimatedContainer\u003c/span\u003e(\n  \u003cspan class=\"hljs-attr\"\u003eduration\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDuration\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003emilliseconds\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e),\n  \u003cspan class=\"hljs-attr\"\u003ecurve\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCurves\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eeaseInOut\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003edecoration\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eBoxDecoration\u003c/span\u003e(\n    \u003cspan class=\"hljs-attr\"\u003ecolor\u003c/span\u003e: selectedItemIndex == i ? yellow : pink,\n    \u003cspan class=\"hljs-attr\"\u003eborder\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eBorder\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eall\u003c/span\u003e(\n      \u003cspan class=\"hljs-attr\"\u003ecolor\u003c/span\u003e: selectedItemIndex == i\n          ? \u003cspan class=\"hljs-title class_\"\u003eColors\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ewhite\u003c/span\u003e\n          : \u003cspan class=\"hljs-title class_\"\u003eColors\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etransparent\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,\n    ),\n  ),\n  \u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eAnimatedDefaultTextStyle\u003c/span\u003e(\n    \u003cspan class=\"hljs-attr\"\u003eduration\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDuration\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003emilliseconds\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e),\n    \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eTextStyle\u003c/span\u003e(\n      \u003cspan class=\"hljs-attr\"\u003ecolor\u003c/span\u003e: selectedItemIndex == i\n          ? \u003cspan class=\"hljs-title class_\"\u003eColors\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eblack\u003c/span\u003e\n          : \u003cspan class=\"hljs-title class_\"\u003eColors\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ewhite\u003c/span\u003e,\n    ),\n    \u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Featured!'\u003c/span\u003e),\n  ),\n),\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 간단히 각 목록 항목은 아래와 같은 onTap 메서드가 있는 InkWell 위젯으로 래핑되어 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-attr\"\u003eonTap\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esetState\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e selectedItemIndex = i),\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 하면 애니메이션을 트리거할 수 있어요!\u003c/p\u003e\n\u003cp\u003e여기 사용 가능한 AnimatedFoo 위젯 전체 목록이 있어요.\u003c/p\u003e\n\u003cp\u003e따라서 우리는 AnimatedFoo 위젯을 투명도, 패딩, 정렬, 위치와 같은 속성용으로 가지고 있어요. 하지만 다른 속성을 애니메이션화하고 싶을 때 어떡하나요? 그럼 여전히 쉽고 빠르게 사용하고 싶어요.\u003c/p\u003e\n\u003ch2\u003e1.2. TweenAnimationBuilder를 사용한 암시적 애니메이션\u003c/h2\u003e\n\u003cp\u003e화면 맨 위로 이동 👆🏼\u003c/p\u003e\n\u003cp\u003eTweenAnimationBuilder를 사용하면 Tween 클래스를 사용하여 모든 위젯의 속성을 암시적으로 애니메이트할 수 있습니다. Tween 클래스의 이름은 \"Between\"에서 따왔습니다. 기본적으로 애니메이트해야 할 시작 및 끝 값을 제공합니다. 그리고 TweenAnimationBuilder 위젯의 빌더는 애니메이션 값으로 제공되며 이 값을 해당 빌더에서 반환하는 위젯의 어떤 속성에 적용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e다음은 예시 애니메이션입니다:\u003c/p\u003e\n\u003cp\u003e아래는 해당 코드입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eTweenAnimationBuilder\u003c/span\u003e(\n  \u003cspan class=\"hljs-attr\"\u003eduration\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDuration\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003emilliseconds\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e),\n  \u003cspan class=\"hljs-attr\"\u003etween\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eTween\u003c/span\u003e\u0026#x3C;double\u003e(\u003cspan class=\"hljs-attr\"\u003ebegin\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0.01\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eend\u003c/span\u003e: _sliderValue),\n  \u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eContainer\u003c/span\u003e(\n    \u003cspan class=\"hljs-attr\"\u003edecoration\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eBoxDecoration\u003c/span\u003e(\n      \u003cspan class=\"hljs-comment\"\u003e//...\u003c/span\u003e\n    ),\n    \u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eSlider\u003c/span\u003e(\n      \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e: _sliderValue,\n      \u003cspan class=\"hljs-attr\"\u003emin\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0.01\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003eonChanged\u003c/span\u003e: (value) {\n        \u003cspan class=\"hljs-title function_\"\u003esetState\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e _sliderValue = value);\n      },\n    ),\n  ),\n  \u003cspan class=\"hljs-attr\"\u003ebuilder\u003c/span\u003e: (\u003cspan class=\"hljs-title class_\"\u003eBuildContext\u003c/span\u003e context, double? value, \u003cspan class=\"hljs-title class_\"\u003eWidget\u003c/span\u003e? child) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eClipRect\u003c/span\u003e(\n      \u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eBackdropFilter\u003c/span\u003e(\n        \u003cspan class=\"hljs-attr\"\u003efilter\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eImageFilter\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eblur\u003c/span\u003e(\n          \u003cspan class=\"hljs-attr\"\u003esigmaX\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e40\u003c/span\u003e * (value ?? \u003cspan class=\"hljs-number\"\u003e0.01\u003c/span\u003e),\n          \u003cspan class=\"hljs-attr\"\u003esigmaY\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e40\u003c/span\u003e * (value ?? \u003cspan class=\"hljs-number\"\u003e0.01\u003c/span\u003e),\n        ),\n        \u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: child,\n      ),\n    );\n  },\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e_sliderValue 변수는 0.01에서 1로 변경됩니다. 따라서 각 값의 변경마다 애니메이션이 트리거되며 BackdropFilter 위젯의 sigmaX 및 sigmaY 속성을 위한 새 값으로 다시 빌더 함수가 재구성됩니다. (0 값을 주면 BackdropFilter 위젯이 웹에서 오류를 발생시키기 때문에 0.01을 사용했습니다.)\u003c/p\u003e\n\u003cp\u003eTweenAnimationBuilder의 child 매개변수를 사용하여 더 나은 성능을 위해 빌더를 활용하고 있어요. 이 child는 애니메이션이 트리거될 때마다 다시 빌드하는 대신 한 번만 다시 빌드되어요.\u003c/p\u003e\n\u003cp\u003e좋아요, 쉬운 내용은 끝났습니다. 이제 본격적인 내용을 시작해볼까요?\u003c/p\u003e\n\u003ch1\u003e2. 명시적 애니메이션\u003c/h1\u003e\n\u003cp\u003e맨 위로 돌아가기 👆🏼\u003c/p\u003e\n\u003cp\u003e암시적 애니메이션에서 AnimatedFoo 또는 TweenAnimationBuilder 위젯 내부의 값만 변경하면 애니메이션이 트리거되었던 것을 기억하시나요? 그러나 명시적 애니메이션은 \"명시적으로\" 애니메이트할 때까지 애니메이션을 트리거하지 않습니다. 애니메이션을 시작하고 어떻게 애니메이트할지 및 AnimationController를 사용하여 애니메이션을 \"제어\"하는 방법을 알려주어야 합니다.\u003c/p\u003e\n\u003cp\u003e명시적 애니메이션 역시 암시적 애니메이션과 유사하게 사용하기 쉬운 위젯과 사용자 정의 수준이 추가된 위젯이 준비되어 있어 자유롭게 사용할 수 있습니다!\u003c/p\u003e\n\u003cp\u003e그런데, AnimationController가 무엇인지 궁금하시죠? 이를 사용하는 명시적 애니메이션 위젯에 대해 알아보기 전에 먼저 AnimationController에 대해 학습해 보겠습니다.\u003c/p\u003e\n\u003ch2\u003eAnimationController\u003c/h2\u003e\n\u003cp\u003e위로 이동 👆🏼\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eAnimationController\u003c/span\u003e({\n  double? value,\n  \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eduration\u003c/span\u003e,\n  \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ereverseDuration\u003c/span\u003e,\n  \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edebugLabel\u003c/span\u003e,\n  \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003elowerBound\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e,\n  \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eupperBound\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e,\n  \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eanimationBehavior\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eAnimationBehavior\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003enormal\u003c/span\u003e,\n  required \u003cspan class=\"hljs-title class_\"\u003eTickerProvider\u003c/span\u003e vsync,\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이전에 언급했듯이 AnimationController를 사용하면 애니메이션을 \"제어\"할 수 있습니다. 그를 위해서는 vsync 값이 TickerProvider 유형이 필요합니다. Ticker는 기본적으로 Flutter의 프레임 렌더링을 추적하고 컨트롤러가 해당 티커를 따라가서 지정된 기간 내에 '애니메이션'할 수 있도록 허용하며, 기본적으로 0과 1인 lowerBound 및 upperBound 값 사이에서 선형으로 값들을 생성합니다.\u003c/p\u003e\n\u003cp\u003e결과적으로, AnimationController를 사용하면 다음을 할 수 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eforward()을 호출하여 애니메이션을 앞으로 재생합니다.\u003c/li\u003e\n\u003cli\u003ereverse()를 호출하여 애니메이션을 역방향으로 재생합니다.\u003c/li\u003e\n\u003cli\u003estop()을 호출하여 애니메이션을 멈춥니다.\u003c/li\u003e\n\u003cli\u003erepeat()을 호출하여 애니메이션을 가시 상태인 한 계속 반복합니다.\u003c/li\u003e\n\u003cli\u003ereset()을 호출하여 애니메이션을 lowerBound로 재설정합니다.\u003c/li\u003e\n\u003cli\u003e값을 설정합니다.\u003c/li\u003e\n\u003cli\u003eisAnimating, isCompleted, isDismissed 등과 같이 애니메이션의 상태를 알아내기 위해 다양한 get 함수에 액세스합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e자, 이 멋진 놈을 사용하여 실제 작업을 확인해 보겠습니다 🎬\u003c/p\u003e\n\u003ch2\u003e2.1. 준비된 위젯을 사용한 명시적 애니메이션\u003c/h2\u003e\n\u003cp\u003e맨 위로 이동 👆🏼\u003c/p\u003e\n\u003cp\u003e그들은 FooTransition 위젯이라고 불립니다. 이 때 Foo는 위젯의 애니메이션 속성입니다. 일부는 당신이 사용하는 일반 위젯의 애니메이션 가능한 위젯들입니다. 예를 들어, AlignTransition, PositionedTransition가 있습니다.\u003c/p\u003e\n\u003cp\u003e이 애니메이션을 확인해보세요:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*GYCKdoQEUQeblnBoyoEHjQ.gif\" alt=\"animation\"\u003e\u003c/p\u003e\n\u003cp\u003e이것은 AlignTransition 및 RotationTransition 위젯을 사용하여 달성되었습니다.\u003c/p\u003e\n\u003cp\u003e코드 분석:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e10번 줄 및 17번 줄: AnimationController를 초기화하고 정의합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eAnimationController의 vsync 값 (19번 줄)은 SingleTickerProviderStateMixin(9번 줄)에서 가져온 값입니다. 이 mixin은 우리에게 이야기한 TickerProvider를 제공합니다. 또한 위젯이 보이는 상태일 때만 애니메이션이 실행되도록 보장합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e11번 줄 및 22번 줄: AlignTransition 위젯의 Animation을 초기화하고 정의합니다 (51번 줄). AlignmentGeometry 유형의 Tween을 사용하여 애니메이션을 정의합니다. 결국, 애니메이션은 Alignment.centerLeft에서 Alignment.centerRight로 애니메이션될 것임을 알려주고 Tween의 animate 메서드를 호출하여 이 애니메이션을 AnimationController와 연결한 후 AlignmentGeometry 유형의 Animation을 반환합니다. 이렇게 하면 AnimationController의 하한 및 상한이 아니라 Tween의 시작 및 종료 값 사이에서 애니메이션이 작동합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e12번 줄 및 32번 줄: RotationTransition 위젯의 회전 속성(turns)의 애니메이션을 초기화하고 정의합니다 (53번 줄). 따라서 0부터 2까지의 시작 및 종료 값이 있으므로, 애니메이션이 끝나면 위젯은 두 번 회전할 것입니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e20번 줄: AnimationController에 반복을 호출하여 애니메이션이 계속되도록 만듭니다. 그리고 reverse를 true로 설정하면 애니메이션이 순방향으로 시작하여 반대로, 다시 순방향으로, ... 이렇게 반복됩니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e42번 줄: 위젯의 상태가 dispose되는 시점에 AnimationController를 폐기(dispose)합니다. 메모리 누수를 방지하기 위해 AnimationController를 dispose하는 것은 항상 중요합니다!\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e하지만 걱정하지 마세요. 조금의 연습으로 매우 쉬워지고 익숙해질 것입니다!\u003c/p\u003e\n\u003cp\u003e가능한 모든 FooTransition 위젯 목록입니다:\u003c/p\u003e\n\u003cp\u003e암시적 애니메이션에서 AnimatedFoo 위젯이 애니메이션 목적에 충분하지 않을 때 어떻게 했는지 기억하나요? AnimatedFoo 위젯으로 처리되지 않은 속성을 애니메이션화하기 위해 TweenAnimationBuilder를 사용했습니다. 비슷하게, 명시적 애니메이션에서는 AnimatedBuilder 위젯을 사용하여 어떤 위젯 속성을 애니메이션화할 수 있습니다. 또는 더 나아가서 직접 FooTransition을 만들기 위해 AnimatedWidget 클래스를 사용할 수도 있습니다!\u003c/p\u003e\n\u003ch2\u003e2.2 AnimatedBuilder 위젯을 사용한 명시적 애니메이션\u003c/h2\u003e\n\u003cp\u003e맨 위로 이동 👆🏼\u003c/p\u003e\n\u003cp\u003e다음 애니메이션을 확인해보세요:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*whGvEQM5o0b4W0hZIkgu_A.gif\" alt=\"Animation\"\u003e\u003c/p\u003e\n\u003cp\u003eGradientTransition 위젯이 없죠? 그럼 어떻게 만들었을까요? AnimatedBuilder 위젯을 이용했어요! 여기에 코드가 있어요:\u003c/p\u003e\n\u003cp\u003e우리는 AnimationController를 초기화하고 정의했고 이를 AnimatedBuilder 위젯의 애니메이션 값으로 사용했어요. 이제 AnimatedBuilder는 컨트롤러의 값이 변경될 때마다 \"다시 빌드(build)\"되고 빌더를 호출하여 업데이트된 _controller.value 값을 가진 새 위젯을 반환해요. 이로써 그라데이션이 애니메이션 되게 만들었어요.\u003c/p\u003e\n\u003cp\u003e물론, AnimationController의 lowerBound 및 upperBound 값 이외의 것을 원한다면, 자체 Animation을 만들고 AnimationController에 연결한 다음 AnimatedBuilder 위젯에 전달할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-dart\"\u003e_animation = Tween\u0026#x3C;\u003cspan class=\"hljs-built_in\"\u003edouble\u003c/span\u003e\u003e(begin: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, end: \u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e).animate(_controller);\n\u003cspan class=\"hljs-comment\"\u003e//...\u003c/span\u003e\nAnimatedBuilder(\n  animation: _animation,\n  builder: (context, child) {\n     \u003cspan class=\"hljs-comment\"\u003e//... 값 사용하기: _animation.value\u003c/span\u003e\n  }\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e또한 AnimatedBuilder 위젯의 child 매개변수를 사용하여 성능을 향상시킬 수 있습니다. 이렇게 하면 매번 애니메이션 값이 변경될 때마다 다시 구축되지 않습니다.\u003c/p\u003e\n\u003cp\u003e아직 따라오고 있나요? 조금만 더 힘내세요! 거의 끝났습니다!\u003c/p\u003e\n\u003cp\u003e이제 한 걸음 더 나아가서 AnimatedWidget 클래스를 사용하여 우리만의 FooTransition 위젯을 만들어보겠습니다!\u003c/p\u003e\n\u003ch2\u003e2.3 AnimatedWidget 클래스를 사용한 명시적 애니메이션\u003c/h2\u003e\n\u003cp\u003e맨 위로 이동 👆🏼\u003c/p\u003e\n\u003cp\u003e아주 비밀스러운 비밀을 하나 알려줄게요. 어떤 FooTransition 위젯의 소스 코드로 가 보세요, 무엇을 보게 될까요?\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-FlutterAnimationsComprehensiveGuide_1.png\" alt=\"Image 1\"\u003e\u003c/p\u003e\n\u003cp\u003e😱 It extends an AnimatedWidget class, and from what we see, the Animation type parameter (in this case turns) is passed as a listenable to the super class:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-FlutterAnimationsComprehensiveGuide_2.png\" alt=\"Image 2\"\u003e\u003c/p\u003e\n\u003cp\u003eAnd the AnimatedWidget is basically a StatefulWidget! So we can do the exact same!\u003c/p\u003e\n\u003cp\u003e우리만의 GradientTransition 위젯을 만들어봅시다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eGradientTransition\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eAnimatedWidget\u003c/span\u003e {\n  final \u003cspan class=\"hljs-title class_\"\u003eAnimation\u003c/span\u003e\u0026#x3C;double\u003e stop;\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eGradientTransition\u003c/span\u003e({\n    \u003cspan class=\"hljs-title class_\"\u003eKey\u003c/span\u003e? key,\n    required \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003estop\u003c/span\u003e,\n  }) : \u003cspan class=\"hljs-variable language_\"\u003esuper\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e: key, \u003cspan class=\"hljs-attr\"\u003elistenable\u003c/span\u003e: stop);\n\n  @override\n  \u003cspan class=\"hljs-title class_\"\u003eWidget\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebuild\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eBuildContext context\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eContainer\u003c/span\u003e(\n      \u003cspan class=\"hljs-attr\"\u003eheight\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003edecoration\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eBoxDecoration\u003c/span\u003e(\n        \u003cspan class=\"hljs-attr\"\u003egradient\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eLinearGradient\u003c/span\u003e(\n          \u003cspan class=\"hljs-attr\"\u003ecolors\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [purple, pink, yellow],\n          \u003cspan class=\"hljs-attr\"\u003estops\u003c/span\u003e: [\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, stop.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e],\n        ),\n      ),\n    );\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 사용하기 위해서는 AnimationController를 그대로 전달하면 됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eGradientTransition\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003estop\u003c/span\u003e: _controller),\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그게 다야!\u003c/p\u003e\n\u003cp\u003e여기까지 버텨내 왔다면, 매우 간단한 것부터 매우 복잡한 것까지 다양한 플러터 애니메이션을 만들기에 충분한 지식을 가지고 있습니다. 필요한 건 조금의 연습뿐이며, 하늘이 한계입니다!\u003c/p\u003e\n\u003ch1\u003e적절한 애니메이션 접근 방식 선택\u003c/h1\u003e\n\u003cp\u003e맨 위로 이동 👆🏼\u003c/p\u003e\n\u003cp\u003e하지만 잠시만 기다려봐요. 위에서 다룬 여러 방법 중에서 어떤 애니메이션을 선택해야 하는지 어떻게 알 수 있을까요? 플러터(Flutter) 팀의 멋진 분들이 도와주기 위해 비디오와 의사결정 트리를 만들었어요. 제가 최대한 요약해 드릴게요.\u003c/p\u003e\n\u003ch2\u003e1. 그림 기반 vs. 코드 기반\u003c/h2\u003e\n\u003cp\u003e첫 번째 선택은 그림 기반 및 코드 기반 애니메이션 사이에서 이루어질 거예요. 이를 위해 자신에게 물어보세요. 만약 당신의 애니메이션이 그림처럼 더 비스무런가요(그림 기반 사용, 3rd party 패키지 사용, 곧 설명할 거예요) 아니면 레이아웃, 위젯, 위젯 스타일, 색상, 테두리, 텍스트 등과 관련이 있는가요(코드 기반 사용, 위에서 설명한 것)?\u003c/p\u003e\n\u003ch2\u003e2. 암시적(Implicit) vs. 명시적(Explicit)\u003c/h2\u003e\n\u003cp\u003e다음 선택은 암시적 및 명시적 애니메이션 중 하나가 될 것입니다. 선택을 하는 데 고려해야 할 여러 기준이 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e무한히 반복되는 애니메이션\u003c/li\u003e\n\u003cli\u003e연속되지 않는 애니메이션: 애니메이션이 시작 지점으로 돌아가지 않음\u003c/li\u003e\n\u003cli\u003e여러 위젯이 함께 애니메이션화되는 경우\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e만약 애니메이션이 위의 기준 중 하나라도 가지고 있다면, 명시적 애니메이션을 사용해야 합니다.\u003c/p\u003e\n\u003ch2\u003e3. 내장 위젯 대 사용자 정의 위젯\u003c/h2\u003e\n\u003cp\u003e마지막 선택 사항은 내장 위젯(AnimatedFoo 및 FooTransition 위젯)과 사용자 지정 위젯(TweenAnimationBuilder 및 AnimatedBuilder/AnimatedWidget) 사이에서 합니다. 이것은 이 목록을 보고 원하는 속성을 애니메이션화하기 위해 이미 내장된 위젯이 있는지 여부를 고려하는 것만큼 간단합니다. 해당 내장 위젯을 사용하거나 (그렇지 않으면 직접 생성)\u003c/p\u003e\n\u003ch1\u003e3rd Party 패키지를 사용한 애니메이션\u003c/h1\u003e\n\u003cp\u003e하지만 앱에서 그림을 기반으로 한 애니메이션을 사용하고 싶다면 어떨까요? 여기서는 코딩이 절약되었네요 🫢, 또한 플러터는 여기에서도 놀라울 정도로 좋습니다! Rive 및 Lottie와 같은 훌륭한 패키지들이 있어서 3rd party 애니메이션을 원활하게 통합하고 앱에 추가할 수 있습니다. 제공되는 애니메이션을 그래픽 디자이너/모션 그래픽 디자이너와 함께 사용하거나 커뮤니티에서 만든 애니메이션을 다운로드/구매하여 빠르고 쉽게 앱에 사용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e3rd party 패키지를 사용하여 Flutter에서 애니메이션을 만드는 데 관한 전용 기사를 작성할 예정이에요. 지금 당장 유용한 링크 몇 개를 공유해 드릴게요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e사용 준비가 된 멋진 애니메이션을 볼 수 있는 Rive 커뮤니티 쇼케이스\u003c/li\u003e\n\u003cli\u003eRive Flutter 패키지\u003c/li\u003e\n\u003cli\u003e무료 LottieFiles 애니메이션\u003c/li\u003e\n\u003cli\u003eLottieFiles Flutter 패키지\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e여기까지가 제 글이에요! 이 기사를 읽어 주셔서 감사합니다. 이것이 Flutter 앱에 애니메이션을 추가하고 싶을 때 여러분의 정보원이 되었으면 좋겠어요. 그럼 여러분도 애니메이션을 넣을 때 즐겁게 시도해 보세요!\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://twitter.com/FlutterComm\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://twitter.com/FlutterComm\u003c/a\u003e\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-21-FlutterAnimationsComprehensiveGuide"},"buildId":"-yEBofE4jMl3RL1kr5c4Y","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>