<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Flutter 앱에서 메모리 사용 최적화 방법 파트 1 | uidev-css</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://uidev-css.github.io///post/2024-06-27-OptimizingMemoryUsageinFlutterAppsPart-1" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Flutter 앱에서 메모리 사용 최적화 방법 파트 1 | uidev-css" data-gatsby-head="true"/><meta property="og:title" content="Flutter 앱에서 메모리 사용 최적화 방법 파트 1 | uidev-css" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-27-OptimizingMemoryUsageinFlutterAppsPart-1_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://uidev-css.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://uidev-css.github.io///post/2024-06-27-OptimizingMemoryUsageinFlutterAppsPart-1" data-gatsby-head="true"/><meta name="twitter:title" content="Flutter 앱에서 메모리 사용 최적화 방법 파트 1 | uidev-css" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-27-OptimizingMemoryUsageinFlutterAppsPart-1_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | uidev-css" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-27 18:29" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b4eed7811784bdd3.js" defer=""></script><script src="/_next/static/ckvP8zvWyPnScUqpsTElP/_buildManifest.js" defer=""></script><script src="/_next/static/ckvP8zvWyPnScUqpsTElP/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UIDEV CSS</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Flutter 앱에서 메모리 사용 최적화 방법 파트 1</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Flutter 앱에서 메모리 사용 최적화 방법 파트 1" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UIDEV CSS</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 27, 2024</span><span class="posts_reading_time__f7YPP">4<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-27-OptimizingMemoryUsageinFlutterAppsPart-1&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<img src="/assets/img/2024-06-27-OptimizingMemoryUsageinFlutterAppsPart-1_0.png">
<p>안녕하세요 Medium 독자 여러분, 오늘은 플러터 애플리케이션의 메모리 최적화에 대해 이야기하려고 합니다. 메모리 사용을 최적화하면 부드럽고 반응성 있는 앱을 보장하여 사용자 경험을 향상시킵니다.</p>
<h1>프로파일링 기술 (Flutter DevTools)</h1>
<p>Flutter DevTools의 메모리 탭을 사용하여 플러터 앱이 메모리를 실시간으로 어떻게 사용하는지 분석하세요. 이를 통해 메모리 사용에 대한 자세한 정보를 얻을 수 있습니다.</p>
<div class="content-ad"></div>
<p>메모리 그래프를 확인하여 메모리 사용 방식을 파악하고 문제가 발생하는 영역을 찾아보세요. 너무 많은 메모리 사용이나 누수를 나타내는 패턴을 찾아보세요. 또한 메모리 사용량이 급증하는 부분을 확인하여 어플리케이션의 어떤 부분이 이러한 현상을 유발하는지 파악해보세요. 빈번한 메모리 사용량 변동이 있다면 메모리가 효율적으로 사용되고 있지 않을 수 있습니다.</p>
<h1>메모리 최적화 기술</h1>
<p>기본적으로 메모리 최적화 기술에는 2가지 방법이 있습니다.</p>
<h2>풀링 및 객체 재사용으로 할당량 줄이기</h2>
<div class="content-ad"></div>
<p>객체 풀링(Object Pooling): 반복적으로 새로운 객체를 만드는 대신에 객체를 재사용합니다. 이는 메모리 사용량을 크게 줄이고 가비지 수집 작업을 줄일 수 있습니다.</p>
<p>기본적인 객체 풀링의 예시를 살펴봅시다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 예시: Worker 객체를 사용한 객체 풀링</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> {
  int id;
  <span class="hljs-title class_">Worker</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span>);

  <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWork</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">print</span>(<span class="hljs-string">'Worker $id is doing work'</span>);
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectPool</span>&#x3C;T> {
  final <span class="hljs-title class_">List</span>&#x3C;T> _available = [];
  final <span class="hljs-title class_">List</span>&#x3C;T> _inUse = [];
  int _counter = <span class="hljs-number">0</span>;

  T <span class="hljs-title function_">getObject</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">if</span> (_available.<span class="hljs-property">isEmpty</span>) {
      _available.<span class="hljs-title function_">add</span>(<span class="hljs-title function_">_createObject</span>());
    }
    final obj = _available.<span class="hljs-title function_">removeLast</span>();
    _inUse.<span class="hljs-title function_">add</span>(obj);
    <span class="hljs-keyword">return</span> obj;
  }

  <span class="hljs-keyword">void</span> <span class="hljs-title function_">releaseObject</span>(<span class="hljs-params">T obj</span>) {
    _inUse.<span class="hljs-title function_">remove</span>(obj);
    _available.<span class="hljs-title function_">add</span>(obj);
  }

  T <span class="hljs-title function_">_createObject</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// 고유 ID를 가진 Worker 객체 생성</span>
    _counter++;
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Worker</span>(_counter) <span class="hljs-keyword">as</span> T;
  }
}

<span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) {
  final workerPool = <span class="hljs-title class_">ObjectPool</span>&#x3C;<span class="hljs-title class_">Worker</span>>();

  <span class="hljs-comment">// 풀에서 Worker를 가져와서 작업을 수행합니다</span>
  <span class="hljs-title class_">Worker</span> worker1 = workerPool.<span class="hljs-title function_">getObject</span>();
  worker1.<span class="hljs-title function_">doWork</span>();

  <span class="hljs-comment">// 다른 Worker를 풀에서 가져와서 작업을 수행합니다</span>
  <span class="hljs-title class_">Worker</span> worker2 = workerPool.<span class="hljs-title function_">getObject</span>();
  worker2.<span class="hljs-title function_">doWork</span>();

  <span class="hljs-comment">// 첫 번째 Worker를 풀에 반환합니다</span>
  workerPool.<span class="hljs-title function_">releaseObject</span>(worker1);

  <span class="hljs-comment">// 풀에서 다른 Worker를 가져옵니다 (이전에 반환된 Worker를 재사용해야 합니다)</span>
  <span class="hljs-title class_">Worker</span> worker3 = workerPool.<span class="hljs-title function_">getObject</span>();
  worker3.<span class="hljs-title function_">doWork</span>();

  <span class="hljs-comment">// 나머지 Worker들을 풀에 반환합니다</span>
  workerPool.<span class="hljs-title function_">releaseObject</span>(worker2);
  workerPool.<span class="hljs-title function_">releaseObject</span>(worker3);
}
</code></pre>
<p>Worker 클래스에는 Worker가 일을 하는 상황을 알리는 메시지를 간단히 출력하는 doWork 메소드가 있습니다. Object Pool 클래스에서는 Worker 객체의 재사용을 관리하여 메모리 할당과 가비지 수집을 최소화합니다.</p>
<div class="content-ad"></div>
<ul>
<li>Object Pool 클래스에는 두 개의 리스트인 _available(재사용 가능한 객체)와 _inUse(현재 사용 중인 객체)가 포함되어 있습니다.</li>
<li>_counter는 새로 생성된 Worker 객체에 고유 ID를 할당하는 데 도움을 줍니다.</li>
<li>getObject() 메서드는 풀에서 객체를 가져옵니다. 리스트가 비어 있다면 새로운 객체를 생성하고 _available에서 가져온 객체를 _inUse로 이동합니다.</li>
</ul>
<p>Release object는 객체를 _inUse에서 가져와 _available로 다시 반환합니다.</p>
<p>_createObject 메서드는 고유 ID가 있는 새 Worker 객체를 생성하고, 각 Worker가 고유 ID를 받을 수 있도록 _counter를 증가시킵니다.</p>
<p>이제 main 함수인 void main()으로 넘어가 봅시다.</p>
<div class="content-ad"></div>
<p>우선 Worker 객체를 위한 ObjectPool을 생성합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) {
  final workerPool = <span class="hljs-title class_">ObjectPool</span>&#x3C;<span class="hljs-title class_">Worker</span>>();
</code></pre>
<p>풀에서 Worker를 가져와 작업을 수행합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 풀에서 Worker를 가져와 작업을 수행합니다</span>
<span class="hljs-title class_">Worker</span> worker1 = workerPool.<span class="hljs-title function_">getObject</span>();
worker1.<span class="hljs-title function_">doWork</span>();
</code></pre>
<div class="content-ad"></div>
<p>위 코드에서 getObject 메서드는 기존 Worker를 재사용하거나 새로운 Worker를 생성한 후에 Worker의 doWork 메서드를 호출합니다.</p>
<p>다음으로 풀에서 또 다른 Worker를 가져와 작업을 수행합니다.</p>
<pre><code class="hljs language-js">  <span class="hljs-comment">// 풀에서 또 다른 Worker를 가져와 작업 수행</span>
  <span class="hljs-title class_">Worker</span> worker2 = workerPool.<span class="hljs-title function_">getObject</span>();
  worker2.<span class="hljs-title function_">doWork</span>();
</code></pre>
<p>첫 번째 Worker를 풀로 반납하세요.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-comment">// 첫 번째 워커를 풀에 반환합니다</span>
workerPool.<span class="hljs-title function_">releaseObject</span>(worker1);
</code></pre>
<p>이제 풀에서 다른 워커를 가져옵니다. 여기서 워커는 다시 사용되어야 합니다 (이 경우 worker1).</p>
<pre><code class="hljs language-js">  <span class="hljs-comment">// 풀에서 다른 워커를 가져옵니다 (반환된 워커를 재사용해야 함)</span>
  <span class="hljs-title class_">Worker</span> worker3 = workerPool.<span class="hljs-title function_">getObject</span>();
  worker3.<span class="hljs-title function_">doWork</span>();
</code></pre>
<p>나머지 워커들을 풀에 반납합니다</p>
<div class="content-ad"></div>
<p>워커 객체가 모두 풀로 반환되도록 보장합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 나머지 워커를 풀로 반환합니다</span>
workerPool.<span class="hljs-title function_">releaseObject</span>(worker2);
workerPool.<span class="hljs-title function_">releaseObject</span>(worker3);
}
</code></pre>
<h1>요약 :</h1>
<ul>
<li>객체 풀링은 객체를 반복적으로 생성하고 파괴하는 대신 재사용하는 디자인 패턴입니다.</li>
<li>이점: 메모리 할당 오버헤드를 줄이고 가비지 컬렉션을 최소화합니다.</li>
</ul>
<div class="content-ad"></div>
<h1>결론:</h1>
<p>이번에는 Dart에서 객체 풀링에 대해 논의했습니다. 이는 빈번한 생성과 소멸 대신 객체를 재사용하는 데 도움이 됩니다. 이 기사의 다음 부분에서 메모리를 더 최적화하는 방법을 더 알아볼 수 있습니다. Dart 패드에서 코드를 자유롭게 테스트해보세요.</p>
<p>이 기사를 즐겁게 읽으셨길 바랍니다!</p>
<p>만약 이 기사가 도움이 되었다면 👏를 눌러주세요.</p>
<div class="content-ad"></div>
<p>안녕히 가세요!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Flutter 앱에서 메모리 사용 최적화 방법 파트 1","description":"","date":"2024-06-27 18:29","slug":"2024-06-27-OptimizingMemoryUsageinFlutterAppsPart-1","content":"\n\u003cimg src=\"/assets/img/2024-06-27-OptimizingMemoryUsageinFlutterAppsPart-1_0.png\" /\u003e\n\n안녕하세요 Medium 독자 여러분, 오늘은 플러터 애플리케이션의 메모리 최적화에 대해 이야기하려고 합니다. 메모리 사용을 최적화하면 부드럽고 반응성 있는 앱을 보장하여 사용자 경험을 향상시킵니다.\n\n# 프로파일링 기술 (Flutter DevTools)\n\nFlutter DevTools의 메모리 탭을 사용하여 플러터 앱이 메모리를 실시간으로 어떻게 사용하는지 분석하세요. 이를 통해 메모리 사용에 대한 자세한 정보를 얻을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n메모리 그래프를 확인하여 메모리 사용 방식을 파악하고 문제가 발생하는 영역을 찾아보세요. 너무 많은 메모리 사용이나 누수를 나타내는 패턴을 찾아보세요. 또한 메모리 사용량이 급증하는 부분을 확인하여 어플리케이션의 어떤 부분이 이러한 현상을 유발하는지 파악해보세요. 빈번한 메모리 사용량 변동이 있다면 메모리가 효율적으로 사용되고 있지 않을 수 있습니다.\n\n# 메모리 최적화 기술\n\n기본적으로 메모리 최적화 기술에는 2가지 방법이 있습니다.\n\n## 풀링 및 객체 재사용으로 할당량 줄이기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n객체 풀링(Object Pooling): 반복적으로 새로운 객체를 만드는 대신에 객체를 재사용합니다. 이는 메모리 사용량을 크게 줄이고 가비지 수집 작업을 줄일 수 있습니다.\n\n기본적인 객체 풀링의 예시를 살펴봅시다.\n\n```js\n// 예시: Worker 객체를 사용한 객체 풀링\n\nclass Worker {\n  int id;\n  Worker(this.id);\n\n  void doWork() {\n    print('Worker $id is doing work');\n  }\n}\n\nclass ObjectPool\u003cT\u003e {\n  final List\u003cT\u003e _available = [];\n  final List\u003cT\u003e _inUse = [];\n  int _counter = 0;\n\n  T getObject() {\n    if (_available.isEmpty) {\n      _available.add(_createObject());\n    }\n    final obj = _available.removeLast();\n    _inUse.add(obj);\n    return obj;\n  }\n\n  void releaseObject(T obj) {\n    _inUse.remove(obj);\n    _available.add(obj);\n  }\n\n  T _createObject() {\n    // 고유 ID를 가진 Worker 객체 생성\n    _counter++;\n    return Worker(_counter) as T;\n  }\n}\n\nvoid main() {\n  final workerPool = ObjectPool\u003cWorker\u003e();\n\n  // 풀에서 Worker를 가져와서 작업을 수행합니다\n  Worker worker1 = workerPool.getObject();\n  worker1.doWork();\n\n  // 다른 Worker를 풀에서 가져와서 작업을 수행합니다\n  Worker worker2 = workerPool.getObject();\n  worker2.doWork();\n\n  // 첫 번째 Worker를 풀에 반환합니다\n  workerPool.releaseObject(worker1);\n\n  // 풀에서 다른 Worker를 가져옵니다 (이전에 반환된 Worker를 재사용해야 합니다)\n  Worker worker3 = workerPool.getObject();\n  worker3.doWork();\n\n  // 나머지 Worker들을 풀에 반환합니다\n  workerPool.releaseObject(worker2);\n  workerPool.releaseObject(worker3);\n}\n```\n\nWorker 클래스에는 Worker가 일을 하는 상황을 알리는 메시지를 간단히 출력하는 doWork 메소드가 있습니다. Object Pool 클래스에서는 Worker 객체의 재사용을 관리하여 메모리 할당과 가비지 수집을 최소화합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Object Pool 클래스에는 두 개의 리스트인 \\_available(재사용 가능한 객체)와 \\_inUse(현재 사용 중인 객체)가 포함되어 있습니다.\n- \\_counter는 새로 생성된 Worker 객체에 고유 ID를 할당하는 데 도움을 줍니다.\n- getObject() 메서드는 풀에서 객체를 가져옵니다. 리스트가 비어 있다면 새로운 객체를 생성하고 \\_available에서 가져온 객체를 \\_inUse로 이동합니다.\n\nRelease object는 객체를 \\_inUse에서 가져와 \\_available로 다시 반환합니다.\n\n\\_createObject 메서드는 고유 ID가 있는 새 Worker 객체를 생성하고, 각 Worker가 고유 ID를 받을 수 있도록 \\_counter를 증가시킵니다.\n\n이제 main 함수인 void main()으로 넘어가 봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우선 Worker 객체를 위한 ObjectPool을 생성합니다.\n\n```js\nvoid main() {\n  final workerPool = ObjectPool\u003cWorker\u003e();\n```\n\n풀에서 Worker를 가져와 작업을 수행합니다.\n\n```js\n// 풀에서 Worker를 가져와 작업을 수행합니다\nWorker worker1 = workerPool.getObject();\nworker1.doWork();\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 코드에서 getObject 메서드는 기존 Worker를 재사용하거나 새로운 Worker를 생성한 후에 Worker의 doWork 메서드를 호출합니다.\n\n다음으로 풀에서 또 다른 Worker를 가져와 작업을 수행합니다.\n\n```js\n  // 풀에서 또 다른 Worker를 가져와 작업 수행\n  Worker worker2 = workerPool.getObject();\n  worker2.doWork();\n```\n\n첫 번째 Worker를 풀로 반납하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 첫 번째 워커를 풀에 반환합니다\nworkerPool.releaseObject(worker1);\n```\n\n이제 풀에서 다른 워커를 가져옵니다. 여기서 워커는 다시 사용되어야 합니다 (이 경우 worker1).\n\n```js\n  // 풀에서 다른 워커를 가져옵니다 (반환된 워커를 재사용해야 함)\n  Worker worker3 = workerPool.getObject();\n  worker3.doWork();\n```\n\n나머지 워커들을 풀에 반납합니다\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n워커 객체가 모두 풀로 반환되도록 보장합니다.\n\n```js\n// 나머지 워커를 풀로 반환합니다\nworkerPool.releaseObject(worker2);\nworkerPool.releaseObject(worker3);\n}\n```\n\n# 요약 :\n\n- 객체 풀링은 객체를 반복적으로 생성하고 파괴하는 대신 재사용하는 디자인 패턴입니다.\n- 이점: 메모리 할당 오버헤드를 줄이고 가비지 컬렉션을 최소화합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론:\n\n이번에는 Dart에서 객체 풀링에 대해 논의했습니다. 이는 빈번한 생성과 소멸 대신 객체를 재사용하는 데 도움이 됩니다. 이 기사의 다음 부분에서 메모리를 더 최적화하는 방법을 더 알아볼 수 있습니다. Dart 패드에서 코드를 자유롭게 테스트해보세요.\n\n이 기사를 즐겁게 읽으셨길 바랍니다!\n\n만약 이 기사가 도움이 되었다면 👏를 눌러주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안녕히 가세요!\n","ogImage":{"url":"/assets/img/2024-06-27-OptimizingMemoryUsageinFlutterAppsPart-1_0.png"},"coverImage":"/assets/img/2024-06-27-OptimizingMemoryUsageinFlutterAppsPart-1_0.png","tag":["Tech"],"readingTime":4},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cimg src=\"/assets/img/2024-06-27-OptimizingMemoryUsageinFlutterAppsPart-1_0.png\"\u003e\n\u003cp\u003e안녕하세요 Medium 독자 여러분, 오늘은 플러터 애플리케이션의 메모리 최적화에 대해 이야기하려고 합니다. 메모리 사용을 최적화하면 부드럽고 반응성 있는 앱을 보장하여 사용자 경험을 향상시킵니다.\u003c/p\u003e\n\u003ch1\u003e프로파일링 기술 (Flutter DevTools)\u003c/h1\u003e\n\u003cp\u003eFlutter DevTools의 메모리 탭을 사용하여 플러터 앱이 메모리를 실시간으로 어떻게 사용하는지 분석하세요. 이를 통해 메모리 사용에 대한 자세한 정보를 얻을 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e메모리 그래프를 확인하여 메모리 사용 방식을 파악하고 문제가 발생하는 영역을 찾아보세요. 너무 많은 메모리 사용이나 누수를 나타내는 패턴을 찾아보세요. 또한 메모리 사용량이 급증하는 부분을 확인하여 어플리케이션의 어떤 부분이 이러한 현상을 유발하는지 파악해보세요. 빈번한 메모리 사용량 변동이 있다면 메모리가 효율적으로 사용되고 있지 않을 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e메모리 최적화 기술\u003c/h1\u003e\n\u003cp\u003e기본적으로 메모리 최적화 기술에는 2가지 방법이 있습니다.\u003c/p\u003e\n\u003ch2\u003e풀링 및 객체 재사용으로 할당량 줄이기\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e객체 풀링(Object Pooling): 반복적으로 새로운 객체를 만드는 대신에 객체를 재사용합니다. 이는 메모리 사용량을 크게 줄이고 가비지 수집 작업을 줄일 수 있습니다.\u003c/p\u003e\n\u003cp\u003e기본적인 객체 풀링의 예시를 살펴봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 예시: Worker 객체를 사용한 객체 풀링\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eWorker\u003c/span\u003e {\n  int id;\n  \u003cspan class=\"hljs-title class_\"\u003eWorker\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edoWork\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Worker $id is doing work'\u003c/span\u003e);\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eObjectPool\u003c/span\u003e\u0026#x3C;T\u003e {\n  final \u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e\u0026#x3C;T\u003e _available = [];\n  final \u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e\u0026#x3C;T\u003e _inUse = [];\n  int _counter = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n\n  T \u003cspan class=\"hljs-title function_\"\u003egetObject\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (_available.\u003cspan class=\"hljs-property\"\u003eisEmpty\u003c/span\u003e) {\n      _available.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003e_createObject\u003c/span\u003e());\n    }\n    final obj = _available.\u003cspan class=\"hljs-title function_\"\u003eremoveLast\u003c/span\u003e();\n    _inUse.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(obj);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e obj;\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ereleaseObject\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eT obj\u003c/span\u003e) {\n    _inUse.\u003cspan class=\"hljs-title function_\"\u003eremove\u003c/span\u003e(obj);\n    _available.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(obj);\n  }\n\n  T \u003cspan class=\"hljs-title function_\"\u003e_createObject\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// 고유 ID를 가진 Worker 객체 생성\u003c/span\u003e\n    _counter++;\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eWorker\u003c/span\u003e(_counter) \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e T;\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  final workerPool = \u003cspan class=\"hljs-title class_\"\u003eObjectPool\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eWorker\u003c/span\u003e\u003e();\n\n  \u003cspan class=\"hljs-comment\"\u003e// 풀에서 Worker를 가져와서 작업을 수행합니다\u003c/span\u003e\n  \u003cspan class=\"hljs-title class_\"\u003eWorker\u003c/span\u003e worker1 = workerPool.\u003cspan class=\"hljs-title function_\"\u003egetObject\u003c/span\u003e();\n  worker1.\u003cspan class=\"hljs-title function_\"\u003edoWork\u003c/span\u003e();\n\n  \u003cspan class=\"hljs-comment\"\u003e// 다른 Worker를 풀에서 가져와서 작업을 수행합니다\u003c/span\u003e\n  \u003cspan class=\"hljs-title class_\"\u003eWorker\u003c/span\u003e worker2 = workerPool.\u003cspan class=\"hljs-title function_\"\u003egetObject\u003c/span\u003e();\n  worker2.\u003cspan class=\"hljs-title function_\"\u003edoWork\u003c/span\u003e();\n\n  \u003cspan class=\"hljs-comment\"\u003e// 첫 번째 Worker를 풀에 반환합니다\u003c/span\u003e\n  workerPool.\u003cspan class=\"hljs-title function_\"\u003ereleaseObject\u003c/span\u003e(worker1);\n\n  \u003cspan class=\"hljs-comment\"\u003e// 풀에서 다른 Worker를 가져옵니다 (이전에 반환된 Worker를 재사용해야 합니다)\u003c/span\u003e\n  \u003cspan class=\"hljs-title class_\"\u003eWorker\u003c/span\u003e worker3 = workerPool.\u003cspan class=\"hljs-title function_\"\u003egetObject\u003c/span\u003e();\n  worker3.\u003cspan class=\"hljs-title function_\"\u003edoWork\u003c/span\u003e();\n\n  \u003cspan class=\"hljs-comment\"\u003e// 나머지 Worker들을 풀에 반환합니다\u003c/span\u003e\n  workerPool.\u003cspan class=\"hljs-title function_\"\u003ereleaseObject\u003c/span\u003e(worker2);\n  workerPool.\u003cspan class=\"hljs-title function_\"\u003ereleaseObject\u003c/span\u003e(worker3);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWorker 클래스에는 Worker가 일을 하는 상황을 알리는 메시지를 간단히 출력하는 doWork 메소드가 있습니다. Object Pool 클래스에서는 Worker 객체의 재사용을 관리하여 메모리 할당과 가비지 수집을 최소화합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003eObject Pool 클래스에는 두 개의 리스트인 _available(재사용 가능한 객체)와 _inUse(현재 사용 중인 객체)가 포함되어 있습니다.\u003c/li\u003e\n\u003cli\u003e_counter는 새로 생성된 Worker 객체에 고유 ID를 할당하는 데 도움을 줍니다.\u003c/li\u003e\n\u003cli\u003egetObject() 메서드는 풀에서 객체를 가져옵니다. 리스트가 비어 있다면 새로운 객체를 생성하고 _available에서 가져온 객체를 _inUse로 이동합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eRelease object는 객체를 _inUse에서 가져와 _available로 다시 반환합니다.\u003c/p\u003e\n\u003cp\u003e_createObject 메서드는 고유 ID가 있는 새 Worker 객체를 생성하고, 각 Worker가 고유 ID를 받을 수 있도록 _counter를 증가시킵니다.\u003c/p\u003e\n\u003cp\u003e이제 main 함수인 void main()으로 넘어가 봅시다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e우선 Worker 객체를 위한 ObjectPool을 생성합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  final workerPool = \u003cspan class=\"hljs-title class_\"\u003eObjectPool\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eWorker\u003c/span\u003e\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e풀에서 Worker를 가져와 작업을 수행합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 풀에서 Worker를 가져와 작업을 수행합니다\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eWorker\u003c/span\u003e worker1 = workerPool.\u003cspan class=\"hljs-title function_\"\u003egetObject\u003c/span\u003e();\nworker1.\u003cspan class=\"hljs-title function_\"\u003edoWork\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e위 코드에서 getObject 메서드는 기존 Worker를 재사용하거나 새로운 Worker를 생성한 후에 Worker의 doWork 메서드를 호출합니다.\u003c/p\u003e\n\u003cp\u003e다음으로 풀에서 또 다른 Worker를 가져와 작업을 수행합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e  \u003cspan class=\"hljs-comment\"\u003e// 풀에서 또 다른 Worker를 가져와 작업 수행\u003c/span\u003e\n  \u003cspan class=\"hljs-title class_\"\u003eWorker\u003c/span\u003e worker2 = workerPool.\u003cspan class=\"hljs-title function_\"\u003egetObject\u003c/span\u003e();\n  worker2.\u003cspan class=\"hljs-title function_\"\u003edoWork\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e첫 번째 Worker를 풀로 반납하세요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 첫 번째 워커를 풀에 반환합니다\u003c/span\u003e\nworkerPool.\u003cspan class=\"hljs-title function_\"\u003ereleaseObject\u003c/span\u003e(worker1);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 풀에서 다른 워커를 가져옵니다. 여기서 워커는 다시 사용되어야 합니다 (이 경우 worker1).\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e  \u003cspan class=\"hljs-comment\"\u003e// 풀에서 다른 워커를 가져옵니다 (반환된 워커를 재사용해야 함)\u003c/span\u003e\n  \u003cspan class=\"hljs-title class_\"\u003eWorker\u003c/span\u003e worker3 = workerPool.\u003cspan class=\"hljs-title function_\"\u003egetObject\u003c/span\u003e();\n  worker3.\u003cspan class=\"hljs-title function_\"\u003edoWork\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e나머지 워커들을 풀에 반납합니다\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e워커 객체가 모두 풀로 반환되도록 보장합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 나머지 워커를 풀로 반환합니다\u003c/span\u003e\nworkerPool.\u003cspan class=\"hljs-title function_\"\u003ereleaseObject\u003c/span\u003e(worker2);\nworkerPool.\u003cspan class=\"hljs-title function_\"\u003ereleaseObject\u003c/span\u003e(worker3);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e요약 :\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e객체 풀링은 객체를 반복적으로 생성하고 파괴하는 대신 재사용하는 디자인 패턴입니다.\u003c/li\u003e\n\u003cli\u003e이점: 메모리 할당 오버헤드를 줄이고 가비지 컬렉션을 최소화합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e결론:\u003c/h1\u003e\n\u003cp\u003e이번에는 Dart에서 객체 풀링에 대해 논의했습니다. 이는 빈번한 생성과 소멸 대신 객체를 재사용하는 데 도움이 됩니다. 이 기사의 다음 부분에서 메모리를 더 최적화하는 방법을 더 알아볼 수 있습니다. Dart 패드에서 코드를 자유롭게 테스트해보세요.\u003c/p\u003e\n\u003cp\u003e이 기사를 즐겁게 읽으셨길 바랍니다!\u003c/p\u003e\n\u003cp\u003e만약 이 기사가 도움이 되었다면 👏를 눌러주세요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e안녕히 가세요!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-27-OptimizingMemoryUsageinFlutterAppsPart-1"},"buildId":"ckvP8zvWyPnScUqpsTElP","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>