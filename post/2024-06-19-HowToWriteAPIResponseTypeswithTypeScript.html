<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>TypeScript로 API 응답 유형 작성하는 방법 | uidev-css</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://uidev-css.github.io///post/2024-06-19-HowToWriteAPIResponseTypeswithTypeScript" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="TypeScript로 API 응답 유형 작성하는 방법 | uidev-css" data-gatsby-head="true"/><meta property="og:title" content="TypeScript로 API 응답 유형 작성하는 방법 | uidev-css" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-19-HowToWriteAPIResponseTypeswithTypeScript_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://uidev-css.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://uidev-css.github.io///post/2024-06-19-HowToWriteAPIResponseTypeswithTypeScript" data-gatsby-head="true"/><meta name="twitter:title" content="TypeScript로 API 응답 유형 작성하는 방법 | uidev-css" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-19-HowToWriteAPIResponseTypeswithTypeScript_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | uidev-css" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-19 00:30" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b75a4bf98ee956a8.js" defer=""></script><script src="/_next/static/CfGULpm6qSb4RqH-Y7KhT/_buildManifest.js" defer=""></script><script src="/_next/static/CfGULpm6qSb4RqH-Y7KhT/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UIDEV CSS</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">TypeScript로 API 응답 유형 작성하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="TypeScript로 API 응답 유형 작성하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UIDEV CSS</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 19, 2024</span><span class="posts_reading_time__f7YPP">3<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-19-HowToWriteAPIResponseTypeswithTypeScript&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>API 응답을 위한 TypeScript 타입을 구성하여 훌륭한 개발 경험, 코드 유지 및 명백한 코딩 오류를 피하세요.</h2>
<p><img src="/assets/img/2024-06-19-HowToWriteAPIResponseTypeswithTypeScript_0.png" alt="이미지"></p>
<p>클라이언트 애플리케이션 개발자들은 매일 API와 작업합니다. 작업의 성공 또는 비즈니스 로직에 따라 API 응답을 표준화하는 것이 좋은 습관입니다. 일반적으로 응답은 상태, 오류 등과 같은 표준 필드를 포함합니다.</p>
<p>이러한 표준 필드를 사용하면 개발자들이 작업 상태에 대응하고 애플리케이션과의 추가 사용자 상호작용을 구축할 수 있습니다. 등록이 성공하면 폼이 닫히고 성공 메시지가 표시되어야 합니다. 그러나 데이터 형식이 잘못된 경우 유효성 검사 오류가 폼에 표시되어야 합니다.</p>
<p>프로젝트에서 응답 유형을 편리하고 빠르게 유연하게 설명하는 방법에 대한 질문이 발생합니다.</p>
<h1>마주한 문제</h1>
<p>가끔 프로젝트에서 응답 유형은 하나의 유형만 사용하여 여러 선택적 매개변수로 설명됩니다. 대부분의 경우 이것만으로 충분할 수도 있고, TypeScript는 코드를 작성할 때 이러한 매개변수를 제안해 줄 것입니다. 그러나 이러한 매개변수의 존재를 확인하는 추가적인 검사가 필요할 수도 있습니다. 이것이 그러한 유형의 예입니다:</p>
<p>이 접근 방식의 유일한 장점은 단순성입니다. 우리는 ApiData 유형을 어떤 응답 유형에 추가해도 충분합니다.</p>
<p>그러나 내가 생각하기론, 한 가지 장점은 상당한 단점에 비해 상쇄된다고 믿습니다. 이 방식의 단점은 투명성의 부족입니다.</p>
<p>또한, 이러한 유형을 응답 유형에 추가함으로써 특정 요청의 응답이 정확히 무엇인지 알 수 없게 됩니다. 예를 들어, POST 요청에 대해 API로부터 제한된 응답 시나리오가 나올 수 있다고 상상해봅시다.</p>
<p>다음과 같은 시나리오들이 있을 수 있습니다:</p>
<ul>
<li>상태가 <code>ok</code>이고 일부 데이터를 가진 성공한 작업</li>
<li>상태가 <code>form_errors</code>이고 오류가 ['', '']인 유효성 오류, 그게 전부입니다</li>
</ul>
<p>이 경우에는 <code>redirect</code> 상태가 가능한 응답 시나리오로 나타나지 않을 것이에요. 또한 GET 요청의 응답에 왜 errors 매개변수가 필요한지 궁금할 수도 있겠죠?</p>
<p>응답 유형을 보고 정확한 응답 옵션을 알 수 없다는 점이 밝혀졌어요. 모든 가능한 응답 변형을 이해하려면 요청을 보내고 응답을 처리하는 함수의 코드를 열어봐야 해요.</p>
<h1>응답 유형을 위한 유틸리티 타입</h1>
<p>위에서 설명한 단점은 사용자 정의 유틸리티 타입을 사용하여 해결할 수 있어요. 각 시나리오마다 별도의 타입이 있습니다: 성공적인 작업, 서버 오류, 유효성 검사 오류 또는 강제 리디렉션을 위한 개별 타입이 있답니다.</p>
<p>각 유형은 특정 응답에 대한 모든 가능한 응답 옵션을 반영하기 위해 개별적으로 또는 결합하여 사용할 수 있습니다. 각 유형은 해당 응답에 해당하는 데이터 유형을 전달할 수 있도록 일반 사항을 갖게 될 것입니다.</p>
<p>게다가, 제가 일반적인 ApiRespinse 유형을 만들었습니다. 이 유형에는 여러 유틸리티 유형이 포함되어 있습니다. 각 POST 요청에 대한 모든 시나리오를 추가하는 데 시간을 절약할 수 있게 될 것입니다.</p>
<p>아래는 다양한 시나리오에 대해 이러한 유틸리티 유형을 사용하는 예시입니다:</p>
<h1>실용적인 차이</h1>
<p>아래는 사용자 프로필의 유형과 사용자 프로필 업데이트 기능에서 반환된 응답의 예시입니다.</p>
<p>이 코드를 TypeScript로 어떻게 린트하는지 보여주는 이미지가 있습니다:</p>
<p><img src="/assets/img/2024-06-19-HowToWriteAPIResponseTypeswithTypeScript_1.png" alt="이미지"></p>
<p>그림에서 TypeScript가 하이라이트한 대로, 표준 응답의 기대 값 중 일부인 오류, 오류 또는 URL과 같은 값들은 일반적으로 정의되지 않을 수 있다고 linter가 고려합니다. 이는 상태와 함께 추가로 체크가 필요하지만, 이미 이 접근 방식의 문제를 보여줍니다.</p>
<p>테이블 태그를 마크다운 형식으로 변경해주세요.</p>
<p>이 경우에는 모든 것이 예상대로 작동합니다:</p>
<ul>
<li>TypeScript는 해당 상태에 대응하는 표준 필드가 있을 것이라고 이해합니다.</li>
<li>사용자 값이 성공적인 경우를 제외한 모든 응답 유형에서 정의되지 않을 수 있음을 나타냅니다. 그러나 응답의 성공을 확인한 후에는 이 값이 강조되지 않고 정의됩니다.</li>
</ul>
<h1>결론</h1>
<p>이 유틸리티 타입을 프로젝트에 구현한 후 개발자 경험이 크게 향상되었습니다. 이제 타입이 API가 제공할 수 있는 가능한 응답 시나리오와 완전히 일치합니다.</p>
<p>위에 표 표시 형식을 Markdown 형식으로 변경하면 특정 응답 유형에서 사용할 수 없는 값이 사용되어 잠재적인 오류를 방지할 수 있습니다. 사용자 값과 같은 경우가 있습니다.</p>
<p>또한 코드에서 응답 처리 구현을 살펴 볼 필요가 없습니다. 실제 응답 유형을 이해하려면 코드를 참고하면 됩니다. 전체 그림을 즉시 확인할 수 있습니다.</p>
<p>이 유틸리티 유형의 작동 방식에 관심이 있다면 Typescript Playground 페이지를 확인해보세요.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"TypeScript로 API 응답 유형 작성하는 방법","description":"","date":"2024-06-19 00:30","slug":"2024-06-19-HowToWriteAPIResponseTypeswithTypeScript","content":"\n\n## API 응답을 위한 TypeScript 타입을 구성하여 훌륭한 개발 경험, 코드 유지 및 명백한 코딩 오류를 피하세요.\n\n![이미지](/assets/img/2024-06-19-HowToWriteAPIResponseTypeswithTypeScript_0.png)\n\n클라이언트 애플리케이션 개발자들은 매일 API와 작업합니다. 작업의 성공 또는 비즈니스 로직에 따라 API 응답을 표준화하는 것이 좋은 습관입니다. 일반적으로 응답은 상태, 오류 등과 같은 표준 필드를 포함합니다.\n\n이러한 표준 필드를 사용하면 개발자들이 작업 상태에 대응하고 애플리케이션과의 추가 사용자 상호작용을 구축할 수 있습니다. 등록이 성공하면 폼이 닫히고 성공 메시지가 표시되어야 합니다. 그러나 데이터 형식이 잘못된 경우 유효성 검사 오류가 폼에 표시되어야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로젝트에서 응답 유형을 편리하고 빠르게 유연하게 설명하는 방법에 대한 질문이 발생합니다.\n\n# 마주한 문제\n\n가끔 프로젝트에서 응답 유형은 하나의 유형만 사용하여 여러 선택적 매개변수로 설명됩니다. 대부분의 경우 이것만으로 충분할 수도 있고, TypeScript는 코드를 작성할 때 이러한 매개변수를 제안해 줄 것입니다. 그러나 이러한 매개변수의 존재를 확인하는 추가적인 검사가 필요할 수도 있습니다. 이것이 그러한 유형의 예입니다:\n\n이 접근 방식의 유일한 장점은 단순성입니다. 우리는 ApiData 유형을 어떤 응답 유형에 추가해도 충분합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러나 내가 생각하기론, 한 가지 장점은 상당한 단점에 비해 상쇄된다고 믿습니다. 이 방식의 단점은 투명성의 부족입니다.\n\n또한, 이러한 유형을 응답 유형에 추가함으로써 특정 요청의 응답이 정확히 무엇인지 알 수 없게 됩니다. 예를 들어, POST 요청에 대해 API로부터 제한된 응답 시나리오가 나올 수 있다고 상상해봅시다.\n\n다음과 같은 시나리오들이 있을 수 있습니다:\n\n- 상태가 `ok`이고 일부 데이터를 가진 성공한 작업\n- 상태가 `form_errors`이고 오류가 ['', '']인 유효성 오류, 그게 전부입니다\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 경우에는 `redirect` 상태가 가능한 응답 시나리오로 나타나지 않을 것이에요. 또한 GET 요청의 응답에 왜 errors 매개변수가 필요한지 궁금할 수도 있겠죠?\n\n응답 유형을 보고 정확한 응답 옵션을 알 수 없다는 점이 밝혀졌어요. 모든 가능한 응답 변형을 이해하려면 요청을 보내고 응답을 처리하는 함수의 코드를 열어봐야 해요.\n\n# 응답 유형을 위한 유틸리티 타입\n\n위에서 설명한 단점은 사용자 정의 유틸리티 타입을 사용하여 해결할 수 있어요. 각 시나리오마다 별도의 타입이 있습니다: 성공적인 작업, 서버 오류, 유효성 검사 오류 또는 강제 리디렉션을 위한 개별 타입이 있답니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n각 유형은 특정 응답에 대한 모든 가능한 응답 옵션을 반영하기 위해 개별적으로 또는 결합하여 사용할 수 있습니다. 각 유형은 해당 응답에 해당하는 데이터 유형을 전달할 수 있도록 일반 사항을 갖게 될 것입니다.\n\n게다가, 제가 일반적인 ApiRespinse 유형을 만들었습니다. 이 유형에는 여러 유틸리티 유형이 포함되어 있습니다. 각 POST 요청에 대한 모든 시나리오를 추가하는 데 시간을 절약할 수 있게 될 것입니다.\n\n아래는 다양한 시나리오에 대해 이러한 유틸리티 유형을 사용하는 예시입니다:\n\n# 실용적인 차이\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 사용자 프로필의 유형과 사용자 프로필 업데이트 기능에서 반환된 응답의 예시입니다.\n\n이 코드를 TypeScript로 어떻게 린트하는지 보여주는 이미지가 있습니다:\n\n![이미지](/assets/img/2024-06-19-HowToWriteAPIResponseTypeswithTypeScript_1.png)\n\n그림에서 TypeScript가 하이라이트한 대로, 표준 응답의 기대 값 중 일부인 오류, 오류 또는 URL과 같은 값들은 일반적으로 정의되지 않을 수 있다고 linter가 고려합니다. 이는 상태와 함께 추가로 체크가 필요하지만, 이미 이 접근 방식의 문제를 보여줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 마크다운 형식으로 변경해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 경우에는 모든 것이 예상대로 작동합니다:\n\n- TypeScript는 해당 상태에 대응하는 표준 필드가 있을 것이라고 이해합니다.\n- 사용자 값이 성공적인 경우를 제외한 모든 응답 유형에서 정의되지 않을 수 있음을 나타냅니다. 그러나 응답의 성공을 확인한 후에는 이 값이 강조되지 않고 정의됩니다.\n\n# 결론\n\n이 유틸리티 타입을 프로젝트에 구현한 후 개발자 경험이 크게 향상되었습니다. 이제 타입이 API가 제공할 수 있는 가능한 응답 시나리오와 완전히 일치합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위에 표 표시 형식을 Markdown 형식으로 변경하면 특정 응답 유형에서 사용할 수 없는 값이 사용되어 잠재적인 오류를 방지할 수 있습니다. 사용자 값과 같은 경우가 있습니다.\n\n또한 코드에서 응답 처리 구현을 살펴 볼 필요가 없습니다. 실제 응답 유형을 이해하려면 코드를 참고하면 됩니다. 전체 그림을 즉시 확인할 수 있습니다.\n\n이 유틸리티 유형의 작동 방식에 관심이 있다면 Typescript Playground 페이지를 확인해보세요.","ogImage":{"url":"/assets/img/2024-06-19-HowToWriteAPIResponseTypeswithTypeScript_0.png"},"coverImage":"/assets/img/2024-06-19-HowToWriteAPIResponseTypeswithTypeScript_0.png","tag":["Tech"],"readingTime":3},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003eAPI 응답을 위한 TypeScript 타입을 구성하여 훌륭한 개발 경험, 코드 유지 및 명백한 코딩 오류를 피하세요.\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-HowToWriteAPIResponseTypeswithTypeScript_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e클라이언트 애플리케이션 개발자들은 매일 API와 작업합니다. 작업의 성공 또는 비즈니스 로직에 따라 API 응답을 표준화하는 것이 좋은 습관입니다. 일반적으로 응답은 상태, 오류 등과 같은 표준 필드를 포함합니다.\u003c/p\u003e\n\u003cp\u003e이러한 표준 필드를 사용하면 개발자들이 작업 상태에 대응하고 애플리케이션과의 추가 사용자 상호작용을 구축할 수 있습니다. 등록이 성공하면 폼이 닫히고 성공 메시지가 표시되어야 합니다. 그러나 데이터 형식이 잘못된 경우 유효성 검사 오류가 폼에 표시되어야 합니다.\u003c/p\u003e\n\u003cp\u003e프로젝트에서 응답 유형을 편리하고 빠르게 유연하게 설명하는 방법에 대한 질문이 발생합니다.\u003c/p\u003e\n\u003ch1\u003e마주한 문제\u003c/h1\u003e\n\u003cp\u003e가끔 프로젝트에서 응답 유형은 하나의 유형만 사용하여 여러 선택적 매개변수로 설명됩니다. 대부분의 경우 이것만으로 충분할 수도 있고, TypeScript는 코드를 작성할 때 이러한 매개변수를 제안해 줄 것입니다. 그러나 이러한 매개변수의 존재를 확인하는 추가적인 검사가 필요할 수도 있습니다. 이것이 그러한 유형의 예입니다:\u003c/p\u003e\n\u003cp\u003e이 접근 방식의 유일한 장점은 단순성입니다. 우리는 ApiData 유형을 어떤 응답 유형에 추가해도 충분합니다.\u003c/p\u003e\n\u003cp\u003e그러나 내가 생각하기론, 한 가지 장점은 상당한 단점에 비해 상쇄된다고 믿습니다. 이 방식의 단점은 투명성의 부족입니다.\u003c/p\u003e\n\u003cp\u003e또한, 이러한 유형을 응답 유형에 추가함으로써 특정 요청의 응답이 정확히 무엇인지 알 수 없게 됩니다. 예를 들어, POST 요청에 대해 API로부터 제한된 응답 시나리오가 나올 수 있다고 상상해봅시다.\u003c/p\u003e\n\u003cp\u003e다음과 같은 시나리오들이 있을 수 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e상태가 \u003ccode\u003eok\u003c/code\u003e이고 일부 데이터를 가진 성공한 작업\u003c/li\u003e\n\u003cli\u003e상태가 \u003ccode\u003eform_errors\u003c/code\u003e이고 오류가 ['', '']인 유효성 오류, 그게 전부입니다\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 경우에는 \u003ccode\u003eredirect\u003c/code\u003e 상태가 가능한 응답 시나리오로 나타나지 않을 것이에요. 또한 GET 요청의 응답에 왜 errors 매개변수가 필요한지 궁금할 수도 있겠죠?\u003c/p\u003e\n\u003cp\u003e응답 유형을 보고 정확한 응답 옵션을 알 수 없다는 점이 밝혀졌어요. 모든 가능한 응답 변형을 이해하려면 요청을 보내고 응답을 처리하는 함수의 코드를 열어봐야 해요.\u003c/p\u003e\n\u003ch1\u003e응답 유형을 위한 유틸리티 타입\u003c/h1\u003e\n\u003cp\u003e위에서 설명한 단점은 사용자 정의 유틸리티 타입을 사용하여 해결할 수 있어요. 각 시나리오마다 별도의 타입이 있습니다: 성공적인 작업, 서버 오류, 유효성 검사 오류 또는 강제 리디렉션을 위한 개별 타입이 있답니다.\u003c/p\u003e\n\u003cp\u003e각 유형은 특정 응답에 대한 모든 가능한 응답 옵션을 반영하기 위해 개별적으로 또는 결합하여 사용할 수 있습니다. 각 유형은 해당 응답에 해당하는 데이터 유형을 전달할 수 있도록 일반 사항을 갖게 될 것입니다.\u003c/p\u003e\n\u003cp\u003e게다가, 제가 일반적인 ApiRespinse 유형을 만들었습니다. 이 유형에는 여러 유틸리티 유형이 포함되어 있습니다. 각 POST 요청에 대한 모든 시나리오를 추가하는 데 시간을 절약할 수 있게 될 것입니다.\u003c/p\u003e\n\u003cp\u003e아래는 다양한 시나리오에 대해 이러한 유틸리티 유형을 사용하는 예시입니다:\u003c/p\u003e\n\u003ch1\u003e실용적인 차이\u003c/h1\u003e\n\u003cp\u003e아래는 사용자 프로필의 유형과 사용자 프로필 업데이트 기능에서 반환된 응답의 예시입니다.\u003c/p\u003e\n\u003cp\u003e이 코드를 TypeScript로 어떻게 린트하는지 보여주는 이미지가 있습니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-HowToWriteAPIResponseTypeswithTypeScript_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e그림에서 TypeScript가 하이라이트한 대로, 표준 응답의 기대 값 중 일부인 오류, 오류 또는 URL과 같은 값들은 일반적으로 정의되지 않을 수 있다고 linter가 고려합니다. 이는 상태와 함께 추가로 체크가 필요하지만, 이미 이 접근 방식의 문제를 보여줍니다.\u003c/p\u003e\n\u003cp\u003e테이블 태그를 마크다운 형식으로 변경해주세요.\u003c/p\u003e\n\u003cp\u003e이 경우에는 모든 것이 예상대로 작동합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTypeScript는 해당 상태에 대응하는 표준 필드가 있을 것이라고 이해합니다.\u003c/li\u003e\n\u003cli\u003e사용자 값이 성공적인 경우를 제외한 모든 응답 유형에서 정의되지 않을 수 있음을 나타냅니다. 그러나 응답의 성공을 확인한 후에는 이 값이 강조되지 않고 정의됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e이 유틸리티 타입을 프로젝트에 구현한 후 개발자 경험이 크게 향상되었습니다. 이제 타입이 API가 제공할 수 있는 가능한 응답 시나리오와 완전히 일치합니다.\u003c/p\u003e\n\u003cp\u003e위에 표 표시 형식을 Markdown 형식으로 변경하면 특정 응답 유형에서 사용할 수 없는 값이 사용되어 잠재적인 오류를 방지할 수 있습니다. 사용자 값과 같은 경우가 있습니다.\u003c/p\u003e\n\u003cp\u003e또한 코드에서 응답 처리 구현을 살펴 볼 필요가 없습니다. 실제 응답 유형을 이해하려면 코드를 참고하면 됩니다. 전체 그림을 즉시 확인할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 유틸리티 유형의 작동 방식에 관심이 있다면 Typescript Playground 페이지를 확인해보세요.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-19-HowToWriteAPIResponseTypeswithTypeScript"},"buildId":"CfGULpm6qSb4RqH-Y7KhT","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>