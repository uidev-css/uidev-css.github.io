<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Flutter 상태 관리 BLoC와 Provider 비교 어떤 걸 선택해야 할까 | uidev-css</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://uidev-css.github.io///post/2024-06-22-FlutterStateManagementBLoCVSProvider" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Flutter 상태 관리 BLoC와 Provider 비교 어떤 걸 선택해야 할까 | uidev-css" data-gatsby-head="true"/><meta property="og:title" content="Flutter 상태 관리 BLoC와 Provider 비교 어떤 걸 선택해야 할까 | uidev-css" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-22-FlutterStateManagementBLoCVSProvider_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://uidev-css.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://uidev-css.github.io///post/2024-06-22-FlutterStateManagementBLoCVSProvider" data-gatsby-head="true"/><meta name="twitter:title" content="Flutter 상태 관리 BLoC와 Provider 비교 어떤 걸 선택해야 할까 | uidev-css" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-22-FlutterStateManagementBLoCVSProvider_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | uidev-css" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-22 15:47" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b4eed7811784bdd3.js" defer=""></script><script src="/_next/static/9ddMoNNI_mr3kv4sKx3b_/_buildManifest.js" defer=""></script><script src="/_next/static/9ddMoNNI_mr3kv4sKx3b_/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UIDEV CSS</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Flutter 상태 관리 BLoC와 Provider 비교 어떤 걸 선택해야 할까</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Flutter 상태 관리 BLoC와 Provider 비교 어떤 걸 선택해야 할까" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UIDEV CSS</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 22, 2024</span><span class="posts_reading_time__f7YPP">8<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-22-FlutterStateManagementBLoCVSProvider&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>세부 비교</p>
<p><img src="/assets/img/2024-06-22-FlutterStateManagementBLoCVSProvider_0.png" alt="flutter-state-management"></p>
<p>상태 관리는 모든 애플리케이션을 구축하는 중요한 측면이며 특히 모바일 앱에서 중요합니다. 플러터(Flutter)에서 상태 관리는 앱에서 변경될 수 있는 데이터를 관리하고 해당 데이터를 사용자 인터페이스에 반영하는 과정입니다.</p>
<p>플러터에서 상태 관리에는 여러 패턴이 있지만, 가장 인기 있는 두 가지는 BLoC (Business Logic Component)와 Provider입니다. 이 두 패턴은 모두 플러터 앱의 상태를 관리하기 쉽게 만들어 주지만 각각 다른 방식으로 작동하며 다른 사용 사례에 적합합니다.</p>
<div class="content-ad"></div>
<p>BLoC(Business Logic Component)은 애플리케이션의 비즈니스 로직을 사용자 인터페이스에서 분리하는 디자인 패턴입니다. 이는 UI와 BLoC 간에 데이터를 전달하는 데 스트림을 사용하며, 애플리케이션의 상태를 관리하기 위해 Provider 패키지와 함께 사용할 수 있습니다.</p>
<p>반면에 Provider는 애플리케이션의 상태를 관리하기 위한 패키지입니다. InheritedWidget을 사용하여 상태를 위젯 트리 아래로 전파합니다. BLoC를 사용하는 더 단순하고 가벼운 대안이지만, 덜 강력하고 유연하지 않습니다.</p>
<p>이 블로그 포스트에서는 이 두 상태 관리 패턴을 자세히 살펴보고, Flutter 앱에서 언제 사용해야 하는지, 어떻게 작동하는지, 또한 BLoC와 Provider를 상세히 비교하고 각 패턴의 장점과 단점을 논의할 것입니다.</p>
<p>BLoC(Business Logic Component) 패턴은 애플리케이션의 비즈니스 로직을 사용자 인터페이스에서 분리하는 방법입니다. UI와 BLoC 간에 데이터를 전달하기 위해 스트림을 사용하여 Flutter 앱의 상태를 쉽게 관리할 수 있습니다.</p>
<div class="content-ad"></div>
<p>BLoC 패턴의 기본 구성 요소는 BLoC 자체입니다. 이는 비즈니스 로직을 처리하는 역할을 담당합니다. BLoC는 이벤트 스트림(예: 사용자 입력)을 가져와서 상태 스트림을 업데이트하는 데 사용합니다. 그런 다음 UI는 상태 스트림을 청취하고 그에 따라 업데이트할 수 있습니다.</p>
<p>다음은 카운터를 증가하는 간단한 BLoC 예제입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CounterBloc</span> {
  final _counterController = <span class="hljs-title class_">StreamController</span>&#x3C;int>();
  <span class="hljs-title class_">Stream</span>&#x3C;int> get counter => _counterController.<span class="hljs-property">stream</span>;
  <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) {
    _counterController.<span class="hljs-property">sink</span>.<span class="hljs-title function_">add</span>(_counterController.<span class="hljs-property">value</span> + <span class="hljs-number">1</span>);
  }
  <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispose</span>(<span class="hljs-params"></span>) {
    _counterController.<span class="hljs-title function_">close</span>();
  }
}
</code></pre>
<p>이 예제에서 CounterBloc 클래스에는 비공개 _counterController StreamController와 공개 counter 스트림이 있습니다. increment 메서드는 이벤트를 가져와 스트림의 현재 값에 1을 추가하고, dispose는 더 이상 필요하지 않을 때 스트림을 닫는 데 사용됩니다.</p>
<div class="content-ad"></div>
<p>BLoC 사용의 장점은 다음과 같습니다:</p>
<ul>
<li>코드 구성: BLoC는 비즈니스 로직과 UI 로직을 분리하여 유지 관리, 테스트, 가독성을 높입니다.</li>
<li>확장성: BLoC의 모듈식 접근 방식은 앱을 성장시킬 때 확장하기 쉽게 만듭니다.</li>
</ul>
<p>다음은 위의 BLoC를 플러터 위젯 트리에 구현하는 예시입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">StatelessWidget</span> {
  @override
  <span class="hljs-title class_">Widget</span> <span class="hljs-title function_">build</span>(<span class="hljs-params">BuildContext context</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">BlocProvider</span>&#x3C;<span class="hljs-title class_">CounterBloc</span>>(
      <span class="hljs-attr">create</span>: <span class="hljs-function">(<span class="hljs-params">context</span>) =></span> <span class="hljs-title class_">CounterBloc</span>(),
      <span class="hljs-attr">child</span>: <span class="hljs-title class_">MaterialApp</span>(
        <span class="hljs-attr">home</span>: <span class="hljs-title class_">CounterPage</span>(),
      ),
    );
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">CounterPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">StatelessWidget</span> {
  @override
  <span class="hljs-title class_">Widget</span> <span class="hljs-title function_">build</span>(<span class="hljs-params">BuildContext context</span>) {
    final bloc = <span class="hljs-title class_">BlocProvider</span>.<span class="hljs-property">of</span>&#x3C;<span class="hljs-title class_">CounterBloc</span>>(context);

    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Scaffold</span>(
      <span class="hljs-attr">body</span>: <span class="hljs-title class_">Center</span>(
        <span class="hljs-attr">child</span>: <span class="hljs-title class_">StreamBuilder</span>&#x3C;int>(
          <span class="hljs-attr">stream</span>: bloc.<span class="hljs-property">counter</span>,
          <span class="hljs-attr">initialData</span>: <span class="hljs-number">0</span>,
          <span class="hljs-attr">builder</span>: (context, snapshot) {
            <span class="hljs-keyword">return</span> <span class="hljs-title class_">Text</span>(<span class="hljs-string">'${snapshot.data}'</span>);
          },
        ),
      ),
      <span class="hljs-attr">floatingActionButton</span>: <span class="hljs-title class_">FloatingActionButton</span>(
        <span class="hljs-attr">onPressed</span>: () {
          bloc.<span class="hljs-title function_">increment</span>();
        },
        <span class="hljs-attr">child</span>: <span class="hljs-title class_">Icon</span>(<span class="hljs-title class_">Icons</span>.<span class="hljs-property">add</span>),
      ),
    );
  }
}
</code></pre>
<div class="content-ad"></div>
<p>BLoC을 사용하는 한 가지 단점은 설정 및 사용이 더 복잡할 수 있고 구현하는 데 더 많은 시간과 노력이 필요할 수 있다는 것입니다. 또한 몇 가지 경우에는 단순한 경우에 스트림 컨트롤러 및 스트림 빌더의 필요가 하나의 Provider가 더 적합한 경우도 있을 수 있습니다.</p>
<p>Provider 패턴은 Flutter 애플리케이션의 상태를 관리하기 위한 패키지입니다. InheritedWidget을 사용하여 상태를 위젯 트리 아래로 전파하여 앱 전체에서 상태에 쉽게 액세스하고 업데이트할 수 있도록 돕습니다.</p>
<p>Provider에서 앱 상태를 보유하는 ChangeNotifier와 ChangeNotifier를 보유하는 ChangeNotifierProvider가 있습니다. ChangeNotifierProvider는 ChangeNotifier의 인스턴스를 취하고 위젯 트리 안에 있는 위젯에 노출합니다.</p>
<p>다음은 Provider를 사용한 간단한 Counter 앱 예시입니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CounterModel</span> <span class="hljs-keyword">with</span> <span class="hljs-title class_">ChangeNotifier</span> {
  int _count = <span class="hljs-number">0</span>;

  int get count => _count;

  <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) {
    _count++;
    <span class="hljs-title function_">notifyListeners</span>();
  }
}
</code></pre>
<p>이 예시에서 CounterModel 클래스는 카운터를 나타내는 int 값이 있는 ChangeNotifier이며, 카운터를 업데이트하는 increment 메서드와 UI에 변경 사항을 알리기 위해 notifyListeners()를 호출하는 기능을 가지고 있습니다.</p>
<p>위의 CounterModel을 Flutter 위젯 트리에 구현하는 예시는 아래와 같습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">StatelessWidget</span> {
  @override
  <span class="hljs-title class_">Widget</span> <span class="hljs-title function_">build</span>(<span class="hljs-params">BuildContext context</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">ChangeNotifierProvider</span>(
      <span class="hljs-attr">create</span>: <span class="hljs-function">(<span class="hljs-params">_</span>) =></span> <span class="hljs-title class_">CounterModel</span>(),
      <span class="hljs-attr">child</span>: <span class="hljs-title class_">MaterialApp</span>(
        <span class="hljs-attr">home</span>: <span class="hljs-title class_">CounterPage</span>(),
      ),
    );
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">CounterPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">StatelessWidget</span> {
  @override
  <span class="hljs-title class_">Widget</span> <span class="hljs-title function_">build</span>(<span class="hljs-params">BuildContext context</span>) {
    final counter = <span class="hljs-title class_">Provider</span>.<span class="hljs-property">of</span>&#x3C;<span class="hljs-title class_">CounterModel</span>>(context);

    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Scaffold</span>(
      <span class="hljs-attr">body</span>: <span class="hljs-title class_">Center</span>(
        <span class="hljs-attr">child</span>: <span class="hljs-title class_">Text</span>(<span class="hljs-string">'${counter.count}'</span>),
      ),
      <span class="hljs-attr">floatingActionButton</span>: <span class="hljs-title class_">FloatingActionButton</span>(
        <span class="hljs-attr">onPressed</span>: () {
          counter.<span class="hljs-title function_">increment</span>();
        },
        <span class="hljs-attr">child</span>: <span class="hljs-title class_">Icon</span>(<span class="hljs-title class_">Icons</span>.<span class="hljs-property">add</span>),
      ),
    );
  }
}
</code></pre>
<div class="content-ad"></div>
<p>Provider를 사용하는 장점 중 하나는 사용하기 쉽고 간단하다는 것입니다. 특히 작고 간단한 앱에 사용하기에 매우 간편합니다.</p>
<p>하지만, Provider는 BLoC에 비해 강력하고 유연성이 부족하며, 더 크고 복잡한 앱의 상태를 관리하기 어려울 수 있습니다. 또한 코드 구성을 위한 구체적인 구조를 제공하지 않아 애플리케이션이 성장함에 따라 더 복잡하고 이해하기 어려운 코드로 이어질 수 있습니다.</p>
<p>이 섹션에서는 BLoC (비즈니스 로직 컴포넌트)와 Provider를 아키텍처, 코드 구성, 사용 편의성, 확장성 및 디버깅/테스트 측면에서 비교할 것입니다.</p>
<ul>
<li>BLoC는 응용 프로그램의 비즈니스 로직을 사용자 인터페이스에서 분리하는 더 복잡하고 강력한 패턴입니다. UI와 BLoC 간에 데이터를 통신하는 데 스트림을 사용하며, Provider 패키지와 함께 사용할 수 있습니다. 반면에 Provider는 InheritedWidget을 사용하여 상태를 위젯 트리 아래로 전파하는 더 간단하고 가벼운 패턴입니다.</li>
</ul>
<div class="content-ad"></div>
<ul>
<li>
<p>BLoC은 비즈니스 로직과 UI 로직을 분리하여 상태를 관리하는 더 모듈화되고 조직적인 방식을 따릅니다. 이로 인해 코드가 유지보수 가능하고 테스트 가능하며 가독성이 높아집니다. Provider는 간단한 해결책이지만 애플리케이션이 커짐에 따라 더 복잡하고 이해하기 어려운 코드로 이어질 수 있습니다. Provider는 특정 구조를 제공하지 않기 때문입니다.</p>
</li>
<li>
<p>Provider는 일반적으로 설정하고 사용하기 쉽다고 여겨지며 특히 작고 간단한 앱에 적합합니다. 반면에 BLoC은 설정하고 사용하기에 더 복잡할 수 있으며 구현하는 데 더 많은 시간과 노력을 필요로 할 수 있습니다.</p>
</li>
<li>
<p>BLoC은 더 크고 복잡한 앱에 더 적합하며, 상태를 관리하는 더 조직화되고 모듈화된 방식을 허용하여 앱이 성장할수록 더 쉽게 확장할 수 있습니다. 반면에 Provider는 작거나 간단한 앱에 더 적합하며 큰 앱의 복잡성을 쉽게 처리하지 못할 수 있습니다.</p>
</li>
<li>
<p>BLoC 아키텍처는 버그를 감지하고 코드를 테스트하고 다른 부분에 영향을 주지 않고 변경하는 것이 쉽습니다. Provider는 BLoC만큼 디버깅과 테스트하기에 적합하지 않으며 독립성과 모듈성의 수준을 제공하지 않기 때문입니다.</p>
</li>
</ul>
<div class="content-ad"></div>
<p>이 문서에서는 플러터 앱용 두 가지 인기있는 상태 관리 패턴인 BLoC (Business Logic Component)과 Provider에 대해 논의했습니다. 이 두 패턴은 플러터 앱의 상태를 더 쉽게 관리할 수 있도록 설계되었지만, 접근 방식이 다르며 다른 사용 사례에 적합합니다.</p>
<p>BLoC는 애플리케이션의 비즈니스 로직을 사용자 인터페이스와 분리하는 강력하고 유연한 패턴입니다. 이는 UI와 BLoC 간에 데이터를 통신하는 데 스트림을 사용하며, 대규모 및 복잡한 앱에 적합합니다. 반면 Provider는 더 간단하고 가벼운 패턴으로, InheritedWidget을 사용하여 상태를 위젯 트리 아래로 전파합니다. 이는 더 작거나 간단한 앱에 적합합니다.</p>
<p>이 글의 주요 요점은 다음과 같습니다:</p>
<ul>
<li>BLoC는 대규모 및 복잡한 앱에 적합한 강력하고 유연한 패턴입니다.</li>
<li>Provider는 더 작거나 더 간단한 앱에 적합한 더 간단하고 가벼운 패턴입니다.</li>
<li>BLoC와 Provider는 플러터 앱의 상태를 관리하는 데 유용하며, 다른 사용 사례에 적합합니다.</li>
<li>상태 관리 패턴을 선택할 때 앱의 특정 요구 사항을 고려하는 것이 중요합니다. 이는 앱의 크기와 복잡성뿐만 아니라 그로 인해 달성하려는 목표도 포함해야 합니다.</li>
</ul>
<div class="content-ad"></div>
<p>만약 당신의 앱이 작고 간단하며 비즈니스 로직과 UI 로직을 분리할 필요가 없다면, Provider가 좋은 선택일 것입니다. 만약 당신의 앱이 더 복잡하거나 비즈니스 로직과 UI 로직을 분리하고 싶다면, BLoC가 더 나은 선택일 것입니다. 그러나 결국, 당신의 앱의 구체적인 요구사항을 평가하고 사용 사례에 가장 잘 맞는 상태 관리 패턴을 선택하는 것이 항상 더 나은 방법입니다.</p>
<p>이 블로그 게시물 작성 시 다음 소스가 사용되었습니다:</p>
<ul>
<li>Flutter 상태 관리 문서: <a href="https://flutter.dev/docs/development/data-and-backend/state-mgmt" rel="nofollow" target="_blank">https://flutter.dev/docs/development/data-and-backend/state-mgmt</a></li>
<li>BLoC 패턴: <a href="https://www.didierboelens.com/2018/08/reactive-programming---streams---bloc/" rel="nofollow" target="_blank">https://www.didierboelens.com/2018/08/reactive-programming---streams---bloc/</a></li>
<li>Provider 패키지: <a href="https://pub.dev/packages/provider" rel="nofollow" target="_blank">https://pub.dev/packages/provider</a></li>
</ul>
<p>Flutter에서 상태 관리에 대해 더 자세히 알고 싶은 독자들을 위해 다음 리소스들이 유용할 수 있습니다:</p>
<div class="content-ad"></div>
<ul>
<li><strong>Provider 패키지에 대한 Flutter 문서</strong>: <a href="https://pub.dev/packages/provider#-readme-tab" rel="nofollow" target="_blank">여기</a></li>
<li><strong>BLoC 패턴에 대한 Flutter 문서</strong>: <a href="https://flutter.dev/docs/development/data-and-backend/state-mgmt/options#bloc--rx" rel="nofollow" target="_blank">여기</a></li>
<li><strong>Flutter에서의 고급 상태 관리</strong>: <a href="https://www.youtube.com/watch?v=RS36gBEp8OI&#x26;t=898s" rel="nofollow" target="_blank">여기</a></li>
</ul>
<p>그 외 다양한 Flutter 상태 관리 옵션과 패키지가 있다는 점도 알아두면 좋아요. 필요에 따라 몇 가지 다른 옵션들을 탐색해보실 수도 있습니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Flutter 상태 관리 BLoC와 Provider 비교 어떤 걸 선택해야 할까","description":"","date":"2024-06-22 15:47","slug":"2024-06-22-FlutterStateManagementBLoCVSProvider","content":"\n세부 비교\n\n![flutter-state-management](/assets/img/2024-06-22-FlutterStateManagementBLoCVSProvider_0.png)\n\n상태 관리는 모든 애플리케이션을 구축하는 중요한 측면이며 특히 모바일 앱에서 중요합니다. 플러터(Flutter)에서 상태 관리는 앱에서 변경될 수 있는 데이터를 관리하고 해당 데이터를 사용자 인터페이스에 반영하는 과정입니다.\n\n플러터에서 상태 관리에는 여러 패턴이 있지만, 가장 인기 있는 두 가지는 BLoC (Business Logic Component)와 Provider입니다. 이 두 패턴은 모두 플러터 앱의 상태를 관리하기 쉽게 만들어 주지만 각각 다른 방식으로 작동하며 다른 사용 사례에 적합합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nBLoC(Business Logic Component)은 애플리케이션의 비즈니스 로직을 사용자 인터페이스에서 분리하는 디자인 패턴입니다. 이는 UI와 BLoC 간에 데이터를 전달하는 데 스트림을 사용하며, 애플리케이션의 상태를 관리하기 위해 Provider 패키지와 함께 사용할 수 있습니다.\n\n반면에 Provider는 애플리케이션의 상태를 관리하기 위한 패키지입니다. InheritedWidget을 사용하여 상태를 위젯 트리 아래로 전파합니다. BLoC를 사용하는 더 단순하고 가벼운 대안이지만, 덜 강력하고 유연하지 않습니다.\n\n이 블로그 포스트에서는 이 두 상태 관리 패턴을 자세히 살펴보고, Flutter 앱에서 언제 사용해야 하는지, 어떻게 작동하는지, 또한 BLoC와 Provider를 상세히 비교하고 각 패턴의 장점과 단점을 논의할 것입니다.\n\nBLoC(Business Logic Component) 패턴은 애플리케이션의 비즈니스 로직을 사용자 인터페이스에서 분리하는 방법입니다. UI와 BLoC 간에 데이터를 전달하기 위해 스트림을 사용하여 Flutter 앱의 상태를 쉽게 관리할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nBLoC 패턴의 기본 구성 요소는 BLoC 자체입니다. 이는 비즈니스 로직을 처리하는 역할을 담당합니다. BLoC는 이벤트 스트림(예: 사용자 입력)을 가져와서 상태 스트림을 업데이트하는 데 사용합니다. 그런 다음 UI는 상태 스트림을 청취하고 그에 따라 업데이트할 수 있습니다.\n\n다음은 카운터를 증가하는 간단한 BLoC 예제입니다:\n\n```js\nclass CounterBloc {\n  final _counterController = StreamController\u003cint\u003e();\n  Stream\u003cint\u003e get counter =\u003e _counterController.stream;\n  void increment() {\n    _counterController.sink.add(_counterController.value + 1);\n  }\n  void dispose() {\n    _counterController.close();\n  }\n}\n```\n\n이 예제에서 CounterBloc 클래스에는 비공개 \\_counterController StreamController와 공개 counter 스트림이 있습니다. increment 메서드는 이벤트를 가져와 스트림의 현재 값에 1을 추가하고, dispose는 더 이상 필요하지 않을 때 스트림을 닫는 데 사용됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nBLoC 사용의 장점은 다음과 같습니다:\n\n- 코드 구성: BLoC는 비즈니스 로직과 UI 로직을 분리하여 유지 관리, 테스트, 가독성을 높입니다.\n- 확장성: BLoC의 모듈식 접근 방식은 앱을 성장시킬 때 확장하기 쉽게 만듭니다.\n\n다음은 위의 BLoC를 플러터 위젯 트리에 구현하는 예시입니다:\n\n```js\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return BlocProvider\u003cCounterBloc\u003e(\n      create: (context) =\u003e CounterBloc(),\n      child: MaterialApp(\n        home: CounterPage(),\n      ),\n    );\n  }\n}\n\nclass CounterPage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    final bloc = BlocProvider.of\u003cCounterBloc\u003e(context);\n\n    return Scaffold(\n      body: Center(\n        child: StreamBuilder\u003cint\u003e(\n          stream: bloc.counter,\n          initialData: 0,\n          builder: (context, snapshot) {\n            return Text('${snapshot.data}');\n          },\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          bloc.increment();\n        },\n        child: Icon(Icons.add),\n      ),\n    );\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nBLoC을 사용하는 한 가지 단점은 설정 및 사용이 더 복잡할 수 있고 구현하는 데 더 많은 시간과 노력이 필요할 수 있다는 것입니다. 또한 몇 가지 경우에는 단순한 경우에 스트림 컨트롤러 및 스트림 빌더의 필요가 하나의 Provider가 더 적합한 경우도 있을 수 있습니다.\n\nProvider 패턴은 Flutter 애플리케이션의 상태를 관리하기 위한 패키지입니다. InheritedWidget을 사용하여 상태를 위젯 트리 아래로 전파하여 앱 전체에서 상태에 쉽게 액세스하고 업데이트할 수 있도록 돕습니다.\n\nProvider에서 앱 상태를 보유하는 ChangeNotifier와 ChangeNotifier를 보유하는 ChangeNotifierProvider가 있습니다. ChangeNotifierProvider는 ChangeNotifier의 인스턴스를 취하고 위젯 트리 안에 있는 위젯에 노출합니다.\n\n다음은 Provider를 사용한 간단한 Counter 앱 예시입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nclass CounterModel with ChangeNotifier {\n  int _count = 0;\n\n  int get count =\u003e _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n```\n\n이 예시에서 CounterModel 클래스는 카운터를 나타내는 int 값이 있는 ChangeNotifier이며, 카운터를 업데이트하는 increment 메서드와 UI에 변경 사항을 알리기 위해 notifyListeners()를 호출하는 기능을 가지고 있습니다.\n\n위의 CounterModel을 Flutter 위젯 트리에 구현하는 예시는 아래와 같습니다.\n\n```js\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return ChangeNotifierProvider(\n      create: (_) =\u003e CounterModel(),\n      child: MaterialApp(\n        home: CounterPage(),\n      ),\n    );\n  }\n}\n\nclass CounterPage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    final counter = Provider.of\u003cCounterModel\u003e(context);\n\n    return Scaffold(\n      body: Center(\n        child: Text('${counter.count}'),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          counter.increment();\n        },\n        child: Icon(Icons.add),\n      ),\n    );\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nProvider를 사용하는 장점 중 하나는 사용하기 쉽고 간단하다는 것입니다. 특히 작고 간단한 앱에 사용하기에 매우 간편합니다.\n\n하지만, Provider는 BLoC에 비해 강력하고 유연성이 부족하며, 더 크고 복잡한 앱의 상태를 관리하기 어려울 수 있습니다. 또한 코드 구성을 위한 구체적인 구조를 제공하지 않아 애플리케이션이 성장함에 따라 더 복잡하고 이해하기 어려운 코드로 이어질 수 있습니다.\n\n이 섹션에서는 BLoC (비즈니스 로직 컴포넌트)와 Provider를 아키텍처, 코드 구성, 사용 편의성, 확장성 및 디버깅/테스트 측면에서 비교할 것입니다.\n\n- BLoC는 응용 프로그램의 비즈니스 로직을 사용자 인터페이스에서 분리하는 더 복잡하고 강력한 패턴입니다. UI와 BLoC 간에 데이터를 통신하는 데 스트림을 사용하며, Provider 패키지와 함께 사용할 수 있습니다. 반면에 Provider는 InheritedWidget을 사용하여 상태를 위젯 트리 아래로 전파하는 더 간단하고 가벼운 패턴입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- BLoC은 비즈니스 로직과 UI 로직을 분리하여 상태를 관리하는 더 모듈화되고 조직적인 방식을 따릅니다. 이로 인해 코드가 유지보수 가능하고 테스트 가능하며 가독성이 높아집니다. Provider는 간단한 해결책이지만 애플리케이션이 커짐에 따라 더 복잡하고 이해하기 어려운 코드로 이어질 수 있습니다. Provider는 특정 구조를 제공하지 않기 때문입니다.\n\n- Provider는 일반적으로 설정하고 사용하기 쉽다고 여겨지며 특히 작고 간단한 앱에 적합합니다. 반면에 BLoC은 설정하고 사용하기에 더 복잡할 수 있으며 구현하는 데 더 많은 시간과 노력을 필요로 할 수 있습니다.\n\n- BLoC은 더 크고 복잡한 앱에 더 적합하며, 상태를 관리하는 더 조직화되고 모듈화된 방식을 허용하여 앱이 성장할수록 더 쉽게 확장할 수 있습니다. 반면에 Provider는 작거나 간단한 앱에 더 적합하며 큰 앱의 복잡성을 쉽게 처리하지 못할 수 있습니다.\n\n- BLoC 아키텍처는 버그를 감지하고 코드를 테스트하고 다른 부분에 영향을 주지 않고 변경하는 것이 쉽습니다. Provider는 BLoC만큼 디버깅과 테스트하기에 적합하지 않으며 독립성과 모듈성의 수준을 제공하지 않기 때문입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 문서에서는 플러터 앱용 두 가지 인기있는 상태 관리 패턴인 BLoC (Business Logic Component)과 Provider에 대해 논의했습니다. 이 두 패턴은 플러터 앱의 상태를 더 쉽게 관리할 수 있도록 설계되었지만, 접근 방식이 다르며 다른 사용 사례에 적합합니다.\n\nBLoC는 애플리케이션의 비즈니스 로직을 사용자 인터페이스와 분리하는 강력하고 유연한 패턴입니다. 이는 UI와 BLoC 간에 데이터를 통신하는 데 스트림을 사용하며, 대규모 및 복잡한 앱에 적합합니다. 반면 Provider는 더 간단하고 가벼운 패턴으로, InheritedWidget을 사용하여 상태를 위젯 트리 아래로 전파합니다. 이는 더 작거나 간단한 앱에 적합합니다.\n\n이 글의 주요 요점은 다음과 같습니다:\n\n- BLoC는 대규모 및 복잡한 앱에 적합한 강력하고 유연한 패턴입니다.\n- Provider는 더 작거나 더 간단한 앱에 적합한 더 간단하고 가벼운 패턴입니다.\n- BLoC와 Provider는 플러터 앱의 상태를 관리하는 데 유용하며, 다른 사용 사례에 적합합니다.\n- 상태 관리 패턴을 선택할 때 앱의 특정 요구 사항을 고려하는 것이 중요합니다. 이는 앱의 크기와 복잡성뿐만 아니라 그로 인해 달성하려는 목표도 포함해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 당신의 앱이 작고 간단하며 비즈니스 로직과 UI 로직을 분리할 필요가 없다면, Provider가 좋은 선택일 것입니다. 만약 당신의 앱이 더 복잡하거나 비즈니스 로직과 UI 로직을 분리하고 싶다면, BLoC가 더 나은 선택일 것입니다. 그러나 결국, 당신의 앱의 구체적인 요구사항을 평가하고 사용 사례에 가장 잘 맞는 상태 관리 패턴을 선택하는 것이 항상 더 나은 방법입니다.\n\n이 블로그 게시물 작성 시 다음 소스가 사용되었습니다:\n\n- Flutter 상태 관리 문서: https://flutter.dev/docs/development/data-and-backend/state-mgmt\n- BLoC 패턴: https://www.didierboelens.com/2018/08/reactive-programming---streams---bloc/\n- Provider 패키지: https://pub.dev/packages/provider\n\nFlutter에서 상태 관리에 대해 더 자세히 알고 싶은 독자들을 위해 다음 리소스들이 유용할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- **Provider 패키지에 대한 Flutter 문서**: [여기](https://pub.dev/packages/provider#-readme-tab)\n- **BLoC 패턴에 대한 Flutter 문서**: [여기](https://flutter.dev/docs/development/data-and-backend/state-mgmt/options#bloc--rx)\n- **Flutter에서의 고급 상태 관리**: [여기](https://www.youtube.com/watch?v=RS36gBEp8OI\u0026t=898s)\n\n그 외 다양한 Flutter 상태 관리 옵션과 패키지가 있다는 점도 알아두면 좋아요. 필요에 따라 몇 가지 다른 옵션들을 탐색해보실 수도 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-22-FlutterStateManagementBLoCVSProvider_0.png"},"coverImage":"/assets/img/2024-06-22-FlutterStateManagementBLoCVSProvider_0.png","tag":["Tech"],"readingTime":8},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e세부 비교\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-FlutterStateManagementBLoCVSProvider_0.png\" alt=\"flutter-state-management\"\u003e\u003c/p\u003e\n\u003cp\u003e상태 관리는 모든 애플리케이션을 구축하는 중요한 측면이며 특히 모바일 앱에서 중요합니다. 플러터(Flutter)에서 상태 관리는 앱에서 변경될 수 있는 데이터를 관리하고 해당 데이터를 사용자 인터페이스에 반영하는 과정입니다.\u003c/p\u003e\n\u003cp\u003e플러터에서 상태 관리에는 여러 패턴이 있지만, 가장 인기 있는 두 가지는 BLoC (Business Logic Component)와 Provider입니다. 이 두 패턴은 모두 플러터 앱의 상태를 관리하기 쉽게 만들어 주지만 각각 다른 방식으로 작동하며 다른 사용 사례에 적합합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eBLoC(Business Logic Component)은 애플리케이션의 비즈니스 로직을 사용자 인터페이스에서 분리하는 디자인 패턴입니다. 이는 UI와 BLoC 간에 데이터를 전달하는 데 스트림을 사용하며, 애플리케이션의 상태를 관리하기 위해 Provider 패키지와 함께 사용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e반면에 Provider는 애플리케이션의 상태를 관리하기 위한 패키지입니다. InheritedWidget을 사용하여 상태를 위젯 트리 아래로 전파합니다. BLoC를 사용하는 더 단순하고 가벼운 대안이지만, 덜 강력하고 유연하지 않습니다.\u003c/p\u003e\n\u003cp\u003e이 블로그 포스트에서는 이 두 상태 관리 패턴을 자세히 살펴보고, Flutter 앱에서 언제 사용해야 하는지, 어떻게 작동하는지, 또한 BLoC와 Provider를 상세히 비교하고 각 패턴의 장점과 단점을 논의할 것입니다.\u003c/p\u003e\n\u003cp\u003eBLoC(Business Logic Component) 패턴은 애플리케이션의 비즈니스 로직을 사용자 인터페이스에서 분리하는 방법입니다. UI와 BLoC 간에 데이터를 전달하기 위해 스트림을 사용하여 Flutter 앱의 상태를 쉽게 관리할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eBLoC 패턴의 기본 구성 요소는 BLoC 자체입니다. 이는 비즈니스 로직을 처리하는 역할을 담당합니다. BLoC는 이벤트 스트림(예: 사용자 입력)을 가져와서 상태 스트림을 업데이트하는 데 사용합니다. 그런 다음 UI는 상태 스트림을 청취하고 그에 따라 업데이트할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e다음은 카운터를 증가하는 간단한 BLoC 예제입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCounterBloc\u003c/span\u003e {\n  final _counterController = \u003cspan class=\"hljs-title class_\"\u003eStreamController\u003c/span\u003e\u0026#x3C;int\u003e();\n  \u003cspan class=\"hljs-title class_\"\u003eStream\u003c/span\u003e\u0026#x3C;int\u003e get counter =\u003e _counterController.\u003cspan class=\"hljs-property\"\u003estream\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eincrement\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    _counterController.\u003cspan class=\"hljs-property\"\u003esink\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(_counterController.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n  }\n  \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edispose\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    _counterController.\u003cspan class=\"hljs-title function_\"\u003eclose\u003c/span\u003e();\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예제에서 CounterBloc 클래스에는 비공개 _counterController StreamController와 공개 counter 스트림이 있습니다. increment 메서드는 이벤트를 가져와 스트림의 현재 값에 1을 추가하고, dispose는 더 이상 필요하지 않을 때 스트림을 닫는 데 사용됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eBLoC 사용의 장점은 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e코드 구성: BLoC는 비즈니스 로직과 UI 로직을 분리하여 유지 관리, 테스트, 가독성을 높입니다.\u003c/li\u003e\n\u003cli\u003e확장성: BLoC의 모듈식 접근 방식은 앱을 성장시킬 때 확장하기 쉽게 만듭니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e다음은 위의 BLoC를 플러터 위젯 트리에 구현하는 예시입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyApp\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eStatelessWidget\u003c/span\u003e {\n  @override\n  \u003cspan class=\"hljs-title class_\"\u003eWidget\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebuild\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eBuildContext context\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBlocProvider\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eCounterBloc\u003c/span\u003e\u003e(\n      \u003cspan class=\"hljs-attr\"\u003ecreate\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003econtext\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCounterBloc\u003c/span\u003e(),\n      \u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eMaterialApp\u003c/span\u003e(\n        \u003cspan class=\"hljs-attr\"\u003ehome\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCounterPage\u003c/span\u003e(),\n      ),\n    );\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCounterPage\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eStatelessWidget\u003c/span\u003e {\n  @override\n  \u003cspan class=\"hljs-title class_\"\u003eWidget\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebuild\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eBuildContext context\u003c/span\u003e) {\n    final bloc = \u003cspan class=\"hljs-title class_\"\u003eBlocProvider\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eof\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eCounterBloc\u003c/span\u003e\u003e(context);\n\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eScaffold\u003c/span\u003e(\n      \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCenter\u003c/span\u003e(\n        \u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eStreamBuilder\u003c/span\u003e\u0026#x3C;int\u003e(\n          \u003cspan class=\"hljs-attr\"\u003estream\u003c/span\u003e: bloc.\u003cspan class=\"hljs-property\"\u003ecounter\u003c/span\u003e,\n          \u003cspan class=\"hljs-attr\"\u003einitialData\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\n          \u003cspan class=\"hljs-attr\"\u003ebuilder\u003c/span\u003e: (context, snapshot) {\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'${snapshot.data}'\u003c/span\u003e);\n          },\n        ),\n      ),\n      \u003cspan class=\"hljs-attr\"\u003efloatingActionButton\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eFloatingActionButton\u003c/span\u003e(\n        \u003cspan class=\"hljs-attr\"\u003eonPressed\u003c/span\u003e: () {\n          bloc.\u003cspan class=\"hljs-title function_\"\u003eincrement\u003c/span\u003e();\n        },\n        \u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eIcon\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eIcons\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eadd\u003c/span\u003e),\n      ),\n    );\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eBLoC을 사용하는 한 가지 단점은 설정 및 사용이 더 복잡할 수 있고 구현하는 데 더 많은 시간과 노력이 필요할 수 있다는 것입니다. 또한 몇 가지 경우에는 단순한 경우에 스트림 컨트롤러 및 스트림 빌더의 필요가 하나의 Provider가 더 적합한 경우도 있을 수 있습니다.\u003c/p\u003e\n\u003cp\u003eProvider 패턴은 Flutter 애플리케이션의 상태를 관리하기 위한 패키지입니다. InheritedWidget을 사용하여 상태를 위젯 트리 아래로 전파하여 앱 전체에서 상태에 쉽게 액세스하고 업데이트할 수 있도록 돕습니다.\u003c/p\u003e\n\u003cp\u003eProvider에서 앱 상태를 보유하는 ChangeNotifier와 ChangeNotifier를 보유하는 ChangeNotifierProvider가 있습니다. ChangeNotifierProvider는 ChangeNotifier의 인스턴스를 취하고 위젯 트리 안에 있는 위젯에 노출합니다.\u003c/p\u003e\n\u003cp\u003e다음은 Provider를 사용한 간단한 Counter 앱 예시입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCounterModel\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eChangeNotifier\u003c/span\u003e {\n  int _count = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n\n  int get count =\u003e _count;\n\n  \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eincrement\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    _count++;\n    \u003cspan class=\"hljs-title function_\"\u003enotifyListeners\u003c/span\u003e();\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예시에서 CounterModel 클래스는 카운터를 나타내는 int 값이 있는 ChangeNotifier이며, 카운터를 업데이트하는 increment 메서드와 UI에 변경 사항을 알리기 위해 notifyListeners()를 호출하는 기능을 가지고 있습니다.\u003c/p\u003e\n\u003cp\u003e위의 CounterModel을 Flutter 위젯 트리에 구현하는 예시는 아래와 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyApp\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eStatelessWidget\u003c/span\u003e {\n  @override\n  \u003cspan class=\"hljs-title class_\"\u003eWidget\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebuild\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eBuildContext context\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eChangeNotifierProvider\u003c/span\u003e(\n      \u003cspan class=\"hljs-attr\"\u003ecreate\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e_\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCounterModel\u003c/span\u003e(),\n      \u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eMaterialApp\u003c/span\u003e(\n        \u003cspan class=\"hljs-attr\"\u003ehome\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCounterPage\u003c/span\u003e(),\n      ),\n    );\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCounterPage\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eStatelessWidget\u003c/span\u003e {\n  @override\n  \u003cspan class=\"hljs-title class_\"\u003eWidget\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebuild\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eBuildContext context\u003c/span\u003e) {\n    final counter = \u003cspan class=\"hljs-title class_\"\u003eProvider\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eof\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eCounterModel\u003c/span\u003e\u003e(context);\n\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eScaffold\u003c/span\u003e(\n      \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCenter\u003c/span\u003e(\n        \u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'${counter.count}'\u003c/span\u003e),\n      ),\n      \u003cspan class=\"hljs-attr\"\u003efloatingActionButton\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eFloatingActionButton\u003c/span\u003e(\n        \u003cspan class=\"hljs-attr\"\u003eonPressed\u003c/span\u003e: () {\n          counter.\u003cspan class=\"hljs-title function_\"\u003eincrement\u003c/span\u003e();\n        },\n        \u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eIcon\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eIcons\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eadd\u003c/span\u003e),\n      ),\n    );\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eProvider를 사용하는 장점 중 하나는 사용하기 쉽고 간단하다는 것입니다. 특히 작고 간단한 앱에 사용하기에 매우 간편합니다.\u003c/p\u003e\n\u003cp\u003e하지만, Provider는 BLoC에 비해 강력하고 유연성이 부족하며, 더 크고 복잡한 앱의 상태를 관리하기 어려울 수 있습니다. 또한 코드 구성을 위한 구체적인 구조를 제공하지 않아 애플리케이션이 성장함에 따라 더 복잡하고 이해하기 어려운 코드로 이어질 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 섹션에서는 BLoC (비즈니스 로직 컴포넌트)와 Provider를 아키텍처, 코드 구성, 사용 편의성, 확장성 및 디버깅/테스트 측면에서 비교할 것입니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eBLoC는 응용 프로그램의 비즈니스 로직을 사용자 인터페이스에서 분리하는 더 복잡하고 강력한 패턴입니다. UI와 BLoC 간에 데이터를 통신하는 데 스트림을 사용하며, Provider 패키지와 함께 사용할 수 있습니다. 반면에 Provider는 InheritedWidget을 사용하여 상태를 위젯 트리 아래로 전파하는 더 간단하고 가벼운 패턴입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eBLoC은 비즈니스 로직과 UI 로직을 분리하여 상태를 관리하는 더 모듈화되고 조직적인 방식을 따릅니다. 이로 인해 코드가 유지보수 가능하고 테스트 가능하며 가독성이 높아집니다. Provider는 간단한 해결책이지만 애플리케이션이 커짐에 따라 더 복잡하고 이해하기 어려운 코드로 이어질 수 있습니다. Provider는 특정 구조를 제공하지 않기 때문입니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eProvider는 일반적으로 설정하고 사용하기 쉽다고 여겨지며 특히 작고 간단한 앱에 적합합니다. 반면에 BLoC은 설정하고 사용하기에 더 복잡할 수 있으며 구현하는 데 더 많은 시간과 노력을 필요로 할 수 있습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eBLoC은 더 크고 복잡한 앱에 더 적합하며, 상태를 관리하는 더 조직화되고 모듈화된 방식을 허용하여 앱이 성장할수록 더 쉽게 확장할 수 있습니다. 반면에 Provider는 작거나 간단한 앱에 더 적합하며 큰 앱의 복잡성을 쉽게 처리하지 못할 수 있습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eBLoC 아키텍처는 버그를 감지하고 코드를 테스트하고 다른 부분에 영향을 주지 않고 변경하는 것이 쉽습니다. Provider는 BLoC만큼 디버깅과 테스트하기에 적합하지 않으며 독립성과 모듈성의 수준을 제공하지 않기 때문입니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 문서에서는 플러터 앱용 두 가지 인기있는 상태 관리 패턴인 BLoC (Business Logic Component)과 Provider에 대해 논의했습니다. 이 두 패턴은 플러터 앱의 상태를 더 쉽게 관리할 수 있도록 설계되었지만, 접근 방식이 다르며 다른 사용 사례에 적합합니다.\u003c/p\u003e\n\u003cp\u003eBLoC는 애플리케이션의 비즈니스 로직을 사용자 인터페이스와 분리하는 강력하고 유연한 패턴입니다. 이는 UI와 BLoC 간에 데이터를 통신하는 데 스트림을 사용하며, 대규모 및 복잡한 앱에 적합합니다. 반면 Provider는 더 간단하고 가벼운 패턴으로, InheritedWidget을 사용하여 상태를 위젯 트리 아래로 전파합니다. 이는 더 작거나 간단한 앱에 적합합니다.\u003c/p\u003e\n\u003cp\u003e이 글의 주요 요점은 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eBLoC는 대규모 및 복잡한 앱에 적합한 강력하고 유연한 패턴입니다.\u003c/li\u003e\n\u003cli\u003eProvider는 더 작거나 더 간단한 앱에 적합한 더 간단하고 가벼운 패턴입니다.\u003c/li\u003e\n\u003cli\u003eBLoC와 Provider는 플러터 앱의 상태를 관리하는 데 유용하며, 다른 사용 사례에 적합합니다.\u003c/li\u003e\n\u003cli\u003e상태 관리 패턴을 선택할 때 앱의 특정 요구 사항을 고려하는 것이 중요합니다. 이는 앱의 크기와 복잡성뿐만 아니라 그로 인해 달성하려는 목표도 포함해야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e만약 당신의 앱이 작고 간단하며 비즈니스 로직과 UI 로직을 분리할 필요가 없다면, Provider가 좋은 선택일 것입니다. 만약 당신의 앱이 더 복잡하거나 비즈니스 로직과 UI 로직을 분리하고 싶다면, BLoC가 더 나은 선택일 것입니다. 그러나 결국, 당신의 앱의 구체적인 요구사항을 평가하고 사용 사례에 가장 잘 맞는 상태 관리 패턴을 선택하는 것이 항상 더 나은 방법입니다.\u003c/p\u003e\n\u003cp\u003e이 블로그 게시물 작성 시 다음 소스가 사용되었습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFlutter 상태 관리 문서: \u003ca href=\"https://flutter.dev/docs/development/data-and-backend/state-mgmt\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://flutter.dev/docs/development/data-and-backend/state-mgmt\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eBLoC 패턴: \u003ca href=\"https://www.didierboelens.com/2018/08/reactive-programming---streams---bloc/\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://www.didierboelens.com/2018/08/reactive-programming---streams---bloc/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eProvider 패키지: \u003ca href=\"https://pub.dev/packages/provider\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://pub.dev/packages/provider\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFlutter에서 상태 관리에 대해 더 자세히 알고 싶은 독자들을 위해 다음 리소스들이 유용할 수 있습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eProvider 패키지에 대한 Flutter 문서\u003c/strong\u003e: \u003ca href=\"https://pub.dev/packages/provider#-readme-tab\" rel=\"nofollow\" target=\"_blank\"\u003e여기\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eBLoC 패턴에 대한 Flutter 문서\u003c/strong\u003e: \u003ca href=\"https://flutter.dev/docs/development/data-and-backend/state-mgmt/options#bloc--rx\" rel=\"nofollow\" target=\"_blank\"\u003e여기\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eFlutter에서의 고급 상태 관리\u003c/strong\u003e: \u003ca href=\"https://www.youtube.com/watch?v=RS36gBEp8OI\u0026#x26;t=898s\" rel=\"nofollow\" target=\"_blank\"\u003e여기\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e그 외 다양한 Flutter 상태 관리 옵션과 패키지가 있다는 점도 알아두면 좋아요. 필요에 따라 몇 가지 다른 옵션들을 탐색해보실 수도 있습니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-22-FlutterStateManagementBLoCVSProvider"},"buildId":"9ddMoNNI_mr3kv4sKx3b_","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>