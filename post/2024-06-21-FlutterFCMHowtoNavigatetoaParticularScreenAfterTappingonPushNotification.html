<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Flutter FCM - 푸시 알림 탭 후 특정 화면으로 이동하는 방법 | uidev-css</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://uidev-css.github.io///post/2024-06-21-FlutterFCMHowtoNavigatetoaParticularScreenAfterTappingonPushNotification" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Flutter FCM - 푸시 알림 탭 후 특정 화면으로 이동하는 방법 | uidev-css" data-gatsby-head="true"/><meta property="og:title" content="Flutter FCM - 푸시 알림 탭 후 특정 화면으로 이동하는 방법 | uidev-css" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-21-FlutterFCMHowtoNavigatetoaParticularScreenAfterTappingonPushNotification_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://uidev-css.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://uidev-css.github.io///post/2024-06-21-FlutterFCMHowtoNavigatetoaParticularScreenAfterTappingonPushNotification" data-gatsby-head="true"/><meta name="twitter:title" content="Flutter FCM - 푸시 알림 탭 후 특정 화면으로 이동하는 방법 | uidev-css" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-21-FlutterFCMHowtoNavigatetoaParticularScreenAfterTappingonPushNotification_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | uidev-css" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-21 23:04" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b75a4bf98ee956a8.js" defer=""></script><script src="/_next/static/Is-d56jDFXkc1ZfN4DhBP/_buildManifest.js" defer=""></script><script src="/_next/static/Is-d56jDFXkc1ZfN4DhBP/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UIDEV CSS</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Flutter FCM - 푸시 알림 탭 후 특정 화면으로 이동하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Flutter FCM - 푸시 알림 탭 후 특정 화면으로 이동하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UIDEV CSS</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 21, 2024</span><span class="posts_reading_time__f7YPP">12<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-21-FlutterFCMHowtoNavigatetoaParticularScreenAfterTappingonPushNotification&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>이 게시물에서는 FCM 푸시 알림을 수신하고 사용자가 푸시 알림을 탭했을 때 특정 페이지로 이동하는 방법에 대해 Flutter에서 설명하겠습니다 (서버 측 코드 없음).</p>
<p><img src="/assets/img/2024-06-21-FlutterFCMHowtoNavigatetoaParticularScreenAfterTappingonPushNotification_0.png" alt="Flutter FCM How to Navigate to a Particular Screen After Tapping on Push Notification"></p>
<h2>iOS 설정</h2>
<p>Apple의 플랫폼에서 개발하는 것은 때로 어려울 수 있습니다. 예를 들어 Android와는 달리, 푸시 알림을 테스트하려면 실제 기기가 필요하며 Apple 개발자 프로그램에 관리자 또는 계정 보유자로 등록해야 합니다.</p>
<ul>
<li>Xcode에서 Targets <code>Runner</code> Signing &#x26; Capabilities로 이동하여 푸시 알림을 추가하려면 +를 눌러주세요. 그리고 Background Modes에 Background fetch와 Remote notification도 추가해주세요.</li>
</ul>
<ol start="2">
<li>
<p>Apple Developer Member Center에서 Certificates, Identifiers &#x26; Profile로 이동하여 <code>Keys</code>에서 Apple Push Notification service (APN) 키를 추가해주세요. 그런 다음, 해당 키를 Firebase Console <code>Project Settings</code> Cloud Messaging <code>Apple app configuration</code>에 추가해주세요.</p>
</li>
<li>
<p>나머지는 매우 간단합니다 — 공식 문서를 참조해주세요.</p>
</li>
</ol>
<h2>Android 설정</h2>
<p>Foreground Notification(푸시 알림이 일시적으로 화면 상단에 팝업되는 경우)을 사용하려면 AndroidManifest.xml에 아래의 메타데이터가 필요합니다. 'high_importance_channel'에 대한 고급 중요도 채널은 Firebase 공식 문서에서 제공된 이름을 사용했으며 platformChannelSpecifics에서 (아래에서 자세히 설명함) 채널 이름을 지정할 수 있습니다.</p>
<pre><code class="hljs language-js">&#x3C;meta-data
 <span class="hljs-attr">android</span>:name=<span class="hljs-string">"com.google.firebase.messaging.default_notification_channel_id"</span>
 <span class="hljs-attr">android</span>:value=<span class="hljs-string">"high_importance_channel"</span> />
</code></pre>
<h2>Firebase 초기화</h2>
<p>먼저 필요한 모든 패키지를 추가해주세요.</p>
<pre><code class="hljs language-js">flutter pub add firebase_messaging
flutter pub add firebase_core
flutter pub add flutter_local_notifications
</code></pre>
<p>파일들을 프로바이더와 서비스 파일로 분리하는 것에 익숙하지만, 그렇게 하는 것이 필요하지는 않습니다. Firebase 초기화에 대해 말씀드리면 main 함수에서 해야 합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>() <span class="hljs-keyword">async</span> {
  <span class="hljs-title class_">WidgetsFlutterBinding</span>.<span class="hljs-title function_">ensureInitialized</span>();
  <span class="hljs-keyword">await</span> <span class="hljs-title class_">FirebaseService</span>.<span class="hljs-title function_">initializeFirebase</span>();
  <span class="hljs-title function_">runApp</span>(<span class="hljs-keyword">const</span> <span class="hljs-title class_">MyApp</span>());
}
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-string">'dart:async'</span>;

<span class="hljs-keyword">import</span> <span class="hljs-string">'package:firebase_core/firebase_core.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:firebase_messaging/firebase_messaging.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter_local_notifications/flutter_local_notifications.dart'</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">FirebaseService</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-title class_">FirebaseMessaging</span>? _firebaseMessaging;
  <span class="hljs-keyword">static</span> <span class="hljs-title class_">FirebaseMessaging</span> get firebaseMessaging => <span class="hljs-title class_">FirebaseService</span>.<span class="hljs-property">_firebaseMessaging</span> ?? <span class="hljs-title class_">FirebaseMessaging</span>.<span class="hljs-property">instance</span>;

  <span class="hljs-keyword">static</span> <span class="hljs-title class_">Future</span>&#x3C;<span class="hljs-keyword">void</span>> <span class="hljs-title function_">initializeFirebase</span>() <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">await</span> <span class="hljs-title class_">Firebase</span>.<span class="hljs-title function_">initializeApp</span>(<span class="hljs-attr">options</span>: <span class="hljs-title class_">DefaultFirebaseOptions</span>.<span class="hljs-property">currentPlatform</span>);
    <span class="hljs-title class_">FirebaseService</span>.<span class="hljs-property">_firebaseMessaging</span> = <span class="hljs-title class_">FirebaseMessaging</span>.<span class="hljs-property">instance</span>;
    <span class="hljs-keyword">await</span> <span class="hljs-title class_">FirebaseService</span>.<span class="hljs-title function_">initializeLocalNotifications</span>();
    <span class="hljs-keyword">await</span> <span class="hljs-title class_">FCMProvider</span>.<span class="hljs-title function_">onMessage</span>();
    <span class="hljs-keyword">await</span> <span class="hljs-title class_">FirebaseService</span>.<span class="hljs-title function_">onBackgroundMsg</span>();
  }

  <span class="hljs-title class_">Future</span>&#x3C;<span class="hljs-title class_">String</span>?> <span class="hljs-title function_">getDeviceToken</span>() <span class="hljs-keyword">async</span> => <span class="hljs-keyword">await</span> <span class="hljs-title class_">FirebaseMessaging</span>.<span class="hljs-property">instance</span>.<span class="hljs-title function_">getToken</span>();

  <span class="hljs-keyword">static</span> <span class="hljs-title class_">FlutterLocalNotificationsPlugin</span> _localNotificationsPlugin = <span class="hljs-title class_">FlutterLocalNotificationsPlugin</span>();
  
  <span class="hljs-keyword">static</span> <span class="hljs-title class_">Future</span>&#x3C;<span class="hljs-keyword">void</span>> <span class="hljs-title function_">initializeLocalNotifications</span>() <span class="hljs-keyword">async</span> {
    final <span class="hljs-title class_">InitializationSettings</span> _initSettings = <span class="hljs-title class_">InitializationSettings</span>(
      <span class="hljs-attr">android</span>: <span class="hljs-title class_">AndroidInitializationSettings</span>(<span class="hljs-string">"icon_name"</span>),
      <span class="hljs-attr">iOS</span>: <span class="hljs-title class_">DarwinInitializationSettings</span>()
    );
    <span class="hljs-comment">/// on did receive notification response = for when app is opened via notification while in foreground on android</span>
    <span class="hljs-keyword">await</span> <span class="hljs-title class_">FirebaseService</span>.<span class="hljs-property">localNotificationsPlugin</span>.<span class="hljs-title function_">initialize</span>(_initSettings, <span class="hljs-attr">onDidReceiveNotificationResponse</span>: <span class="hljs-title class_">FCMProvider</span>.<span class="hljs-property">onTapNotification</span>);
    <span class="hljs-comment">/// need this for ios foregournd notification</span>
    <span class="hljs-keyword">await</span> <span class="hljs-title class_">FirebaseService</span>.<span class="hljs-property">firebaseMessaging</span>.<span class="hljs-title function_">setForegroundNotificationPresentationOptions</span>(
      <span class="hljs-attr">alert</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// Required to display a heads up notification</span>
      <span class="hljs-attr">badge</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">sound</span>: <span class="hljs-literal">true</span>,
    );
  }
  
  <span class="hljs-keyword">static</span> <span class="hljs-title class_">NotificationDetails</span> platformChannelSpecifics = <span class="hljs-title class_">NotificationDetails</span>(
    <span class="hljs-attr">android</span>: <span class="hljs-title class_">AndroidNotificationDetails</span>(
      <span class="hljs-string">"high_importance_channel"</span>, <span class="hljs-string">"High Importance Notifications"</span>, <span class="hljs-attr">priority</span>: <span class="hljs-title class_">Priority</span>.<span class="hljs-property">max</span>, <span class="hljs-attr">importance</span>: <span class="hljs-title class_">Importance</span>.<span class="hljs-property">max</span>,
    ),
  );
  
  <span class="hljs-comment">// for receiving message when app is in background or foreground</span>
  <span class="hljs-keyword">static</span> <span class="hljs-title class_">Future</span>&#x3C;<span class="hljs-keyword">void</span>> <span class="hljs-title function_">onMessage</span>() <span class="hljs-keyword">async</span> {
    <span class="hljs-title class_">FirebaseMessaging</span>.<span class="hljs-property">onMessage</span>.<span class="hljs-title function_">listen</span>((<span class="hljs-title class_">RemoteMessage</span> message) <span class="hljs-keyword">async</span> {
      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Platform</span>.<span class="hljs-property">isAndroid</span>) {
        <span class="hljs-comment">// if this is available when Platform.isIOS, you'll receive the notification twice </span>
        <span class="hljs-keyword">await</span> <span class="hljs-title class_">FirebaseService</span>.<span class="hljs-property">_localNotificationsPlugin</span>.<span class="hljs-title function_">show</span>(
          <span class="hljs-number">0</span>, message.<span class="hljs-property">notification</span>!.<span class="hljs-property">title</span>, message.<span class="hljs-property">notification</span>!.<span class="hljs-property">body</span>, <span class="hljs-title class_">FirebaseService</span>.<span class="hljs-property">platformChannelSpecifics</span>,
          <span class="hljs-attr">payload</span>: message.<span class="hljs-property">data</span>.<span class="hljs-title function_">toString</span>(),
        );
      }
    });
  }

  <span class="hljs-keyword">static</span> <span class="hljs-title class_">Future</span>&#x3C;<span class="hljs-keyword">void</span>> <span class="hljs-title function_">onBackgroundMsg</span>() <span class="hljs-keyword">async</span> {
    <span class="hljs-title class_">FirebaseMessaging</span>.<span class="hljs-title function_">onBackgroundMessage</span>(<span class="hljs-title class_">FCMProvider</span>.<span class="hljs-property">backgroundHandler</span>);
  }

}
</code></pre>
<p>FirebaseService.initializeFirebase 메서드 내의 모든 메서드를 살펴보겠습니다.</p>
<p>_firebaseMessaging: 이전 FCM 포스트를 작성하던 중 한국 어딘가에서 FirebaseMessaging.instance를 한 번만 호출하는 것이 좋다는 글을 읽은 적이 있어요. 그래서 이를 initialize 메서드에서 초기화하고, _firebaseMessaging이 null인 경우 적절한 값을 제공해주는 getter를 만들었어요.</p>
<p>initializeLocalNotifications: Foreground Notification을 활용하려면 이 메서드가 필요해요. Android에서는 반드시 전달해야 하는 인자 중 하나가 android/app/src/main/res/drawable에 있어야 하는 아이콘 로고 파일 이름이에요.</p>
<p>전달된 두 번째 인자는 onSelectNotification으로, 사용자가 푸시 알림을 탭했을 때 (앱이 포그라운드에 있을 때) 실행되는 콜백입니다. 이런 처리가 없으면 앱이 열리고 더 이상의 작업이 발생하지 않아요. 이 메서드는 onMessage의 FirebaseMessaging.onMessage.listen(안드로이드용)로부터 페이로드를 받습니다.</p>
<p><code>onMessage</code>: 앱이 활성 상태인 경우에 알림을 받을 때 호출됩니다.</p>
<p><code>onBackgroundMsg</code>: 앱이 백그라운드에 있거나 종료된 상태일 때 알림을 받을 때 호출됩니다.</p>
<h2>디바이스 토큰 받기/확인</h2>
<pre><code class="hljs language-js"><span class="hljs-title class_">Future</span>&#x3C;<span class="hljs-title class_">String</span>?> <span class="hljs-title function_">getDeviceToken</span>() <span class="hljs-keyword">async</span> => <span class="hljs-keyword">await</span> <span class="hljs-title class_">FirebaseService</span>.<span class="hljs-property">firebaseMessaging</span>.<span class="hljs-title function_">getToken</span>();
</code></pre>
<p>기기 토큰을 관리하는 올바른 방법은 없지만 Firebase가 권장하는 방법이 있습니다. 제가 선택한 방법은 sqflite를 사용하여 사용자 기기에 타임스탬프와 함께 기기 토큰을 저장하고 서버로 보내는 것입니다. 앱이 열릴 때마다 기기에 저장된 토큰이 있다면 서버로 전송됩니다. 타임스탬프가 한 달 이상 경과했다는 것을 나타내는 경우, 토큰이 새로 고침되고 새 토큰이 서버로 전송됩니다. (아래 코드는 sqflite를 사용하는 제 sql 파일을 기반으로 합니다.)</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Future</span>&#x3C;<span class="hljs-title class_">String</span>?> <span class="hljs-title function_">checkDeviceToken</span>() <span class="hljs-keyword">async</span> {
    <span class="hljs-title class_">String</span>? _deviceToken;
    final bool _exists = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_sqlService</span>.<span class="hljs-title function_">tableExists</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">_tableName</span>);
    <span class="hljs-keyword">if</span> (_exists) {
        final <span class="hljs-title class_">List</span>&#x3C;<span class="hljs-title class_">Json</span>> _data = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_sqlService</span>.<span class="hljs-title function_">readData</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">_tableName</span>);
        final <span class="hljs-title class_">DateTime</span> _timeStamp = <span class="hljs-title class_">DateTime</span>.<span class="hljs-title function_">parse</span>(_data[<span class="hljs-number">0</span>][<span class="hljs-string">"timeStamp"</span>]);
        <span class="hljs-keyword">if</span> (_timeStamp.<span class="hljs-title function_">difference</span>(<span class="hljs-title class_">DateTime</span>.<span class="hljs-title function_">now</span>()).<span class="hljs-property">inDays</span> > <span class="hljs-number">30</span>) {
            _deviceToken = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_getDeviceToken</span>();
            <span class="hljs-keyword">if</span> (_deviceToken == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// todo error handling</span>
            <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_updateDeviceToken</span>(_deviceToken);
        } <span class="hljs-keyword">else</span> {
            _deviceToken = _data[<span class="hljs-number">0</span>][<span class="hljs-string">"deviceToken"</span>];
        }
    } <span class="hljs-keyword">else</span> {
        _deviceToken = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_getDeviceToken</span>();
        <span class="hljs-keyword">if</span> (_deviceToken == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// todo error handling</span>
        <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_saveDeviceToken</span>(_deviceToken);
    }
    <span class="hljs-keyword">return</span> _deviceToken;
}

<span class="hljs-title class_">Future</span>&#x3C;<span class="hljs-title class_">String</span>?> <span class="hljs-title function_">_getDeviceToken</span>() <span class="hljs-keyword">async</span> => <span class="hljs-keyword">await</span> <span class="hljs-title class_">FirebaseService</span>.<span class="hljs-property">firebaseMessaging</span>.<span class="hljs-title function_">getToken</span>();
  
<span class="hljs-title class_">Future</span>&#x3C;<span class="hljs-keyword">void</span>> <span class="hljs-title function_">_saveDeviceToken</span>(<span class="hljs-title class_">String</span> deviceToken) <span class="hljs-keyword">async</span> {
    final <span class="hljs-title class_">String</span> _createSql = <span class="hljs-string">"CREATE TABLE ${this._tableName}(deviceToken TEXT PRIMARY KEY NOT NULL, timeStamp TEXT NOT NULL)"</span>;
    final <span class="hljs-title class_">List</span>&#x3C;<span class="hljs-title class_">Object</span>> _values = [deviceToken, <span class="hljs-title class_">DateTime</span>.<span class="hljs-title function_">now</span>().<span class="hljs-title function_">toIso8601String</span>()];
    final <span class="hljs-title class_">String</span> _insertSql = <span class="hljs-string">"INSERT INTO ${this._tableName}(deviceToken, timeStamp) VALUES(?, ?)"</span>;
    <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_sqlService</span>.<span class="hljs-title function_">saveData</span>(<span class="hljs-attr">tableName</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">_tableName</span>, <span class="hljs-attr">createSql</span>: _createSql, <span class="hljs-attr">insertSql</span>: _insertSql, <span class="hljs-attr">values</span>: _values);
}

<span class="hljs-title class_">Future</span>&#x3C;<span class="hljs-keyword">void</span>> <span class="hljs-title function_">_updateDeviceToken</span>(<span class="hljs-title class_">String</span> deviceToken) <span class="hljs-keyword">async</span> {
    final <span class="hljs-title class_">String</span> _updateSql = <span class="hljs-string">"UPDATE ${this._tableName} SET deviceToken = ?, timeStamp = ?"</span>;
    final <span class="hljs-title class_">List</span>&#x3C;<span class="hljs-title class_">Object</span>> _values = [deviceToken, <span class="hljs-title class_">DateTime</span>.<span class="hljs-title function_">now</span>().<span class="hljs-title function_">toIso8601String</span>()];
    <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_sqlService</span>.<span class="hljs-title function_">updateData</span>(<span class="hljs-attr">tableName</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">_tableName</span>, <span class="hljs-attr">updateSql</span>: _updateSql, <span class="hljs-attr">values</span>: _values);
}
</code></pre>
<h2>알림 수신</h2>
<p>불행히도 저는 서버 측 코드를 만들지 않아 message.data가 어떻게 작동하는지를 보여줄 수 없습니다. 왜냐하면 Firebase의 테스트 알림은 message.notification.body와 message.notification.title만 허용하기 때문입니다. 더 구체적인 알림을 테스트하려면 백엔드 개발자와 협력해야 합니다.</p>
<p>푸시 알림을 받고 앱을 열 수 있는 세 가지 방법이 있습니다:</p>
<ul>
<li>앱이 화면에 표시될 때</li>
<li>앱이 백그라운드에 있을 때</li>
<li>앱이 종료되었을 때</li>
</ul>
<h2>앱이 화면에 표시될 때 (Android)</h2>
<p>사용자가 알림을 탭하면 기본적으로 앱이 열리게 됩니다. 그러나 때로는 사용자가 특정 페이지를 볼 수 있기를 원할 수도 있습니다. 백엔드 개발자는 이러한 정보를 메시지.data에 제공할 수 있습니다. 해당 정보를 가져오기 위해 제공자를 만들었고, Navigator.of(context).push를 사용하기 위해 첫 화면에서 제공자의 BuildContext 변수를 초기화했습니다.</p>
<p>@override
void init() {
super.initState();
WidgetsBinding.instance.addPostFrameCallback((_) {
FCMProvider.setContext(context);
});
}</p>
<p>import 'package:firebase_messaging/firebase_messaging.dart' show FirebaseMessaging, RemoteMessage;
import 'package:flutter/widgets.dart';
import 'package:pops/helpers/custom_types.dart';</p>
<p>import '../views/store_detail/store_detail_page.dart';</p>
<p>class FCMProvider with ChangeNotifier {
static BuildContext? _context;</p>
<p>static void setContext(BuildContext context) => FCMProvider._context = context;</p>
<p>/// when app is in the foreground
static Future onTapNotification(NotificationResponse? response) async {
if (FCMProvider._context == null || response?.payload == null) return;
final Json _data = FCMProvider.convertPayload(response!.payload!);
if (_data.containsKey(...)){
await Navigator.of(FCMProvider._context!).push(...);
}
}</p>
<p>static Json convertPayload(String payload){
final String _payload = payload.substring(1, payload.length - 1);
List _split = [];
_payload.split(",")..forEach((String s) => _split.addAll(s.split(":")));
Json _mapped = {};
for (int i = 0; i &#x3C; _split.length + 1; i++) {
if (i % 2 == 1) _mapped.addAll({_split[i-1].trim().toString(): _split[i].trim()});
}
return _mapped;
}</p>
<p>static Future onMessage() async {
FirebaseMessaging.onMessage.listen((RemoteMessage message) async {
if (FCMProvider._refreshNotifications != null) await FCMProvider._refreshNotifications!(true);
// if this is available when Platform.isIOS, you'll receive the notification twice
if (Platform.isAndroid) {
await FirebaseService.localNotificationsPlugin.show(
0, message.notification!.title,
message.notification!.body,
FirebaseService.platformChannelSpecifics,
payload: message.data.toString(),
);
}
});
}</p>
<p>static Future backgroundHandler(RemoteMessage message) async {</p>
<p>}
}</p>
<p>앱이 화면에 보일 때 onTapNotification 메서드가 실행되며, localNotificationsPlugin.initialize의 onSelectNotification에 콜백 메서드로 설정됩니다. onTapNotification은 message.data.toString()을 페이로드로 받고(페이로드는 문자열로만 넣을 수 있기 때문에) 페이로드를 다시 맵으로 변환합니다.</p>
<h2>앱이 백그라운드에 있을 때 (Android) 및 앱이 포그라운드 / 백그라운드에 있을 때(iOS)</h2>
<p>첫 번째 페이지에서 initState에 다음 코드를 넣었는데, 안드로이드에서 앱이 백그라운드에 있을 때 작동하는 것으로 보이며, iOS에서는 앱이 포그라운드/백그라운드에 있을 때 작동합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Stream</span>&#x3C;<span class="hljs-title class_">RemoteMessage</span>> _stream = <span class="hljs-title class_">FirebaseMessaging</span>.<span class="hljs-property">onMessageOpenedApp</span>;
_stream.<span class="hljs-title function_">listen</span>((<span class="hljs-title class_">RemoteMessage</span> event) <span class="hljs-keyword">async</span> {
  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">data</span> != <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">await</span> <span class="hljs-title class_">Navigator</span>.<span class="hljs-title function_">of</span>(context).<span class="hljs-title function_">push</span>(...);
  }
});
</code></pre>
<h2>앱이 종료된 경우</h2>
<p>앱이 종료된 경우 main.dart의 main 메소드에서 메시지를 받아와야 하며, 다른 곳에서 시도하면 실패할 것입니다. 저는 이 메시지를 첫 번째 페이지로 전달하고, initState에서 적절한 조치를 취했습니다.</p>
<pre><code class="hljs language-dart"><span class="hljs-comment">// main.dart</span>
<span class="hljs-keyword">void</span> main() <span class="hljs-keyword">async</span> {
  WidgetsFlutterBinding.ensureInitialized();
  <span class="hljs-keyword">await</span> FirebaseService.initializeFirebase();
  <span class="hljs-keyword">final</span> RemoteMessage? _message = <span class="hljs-keyword">await</span> FirebaseService.firebaseMessaging.getInitialMessage();
  runApp(<span class="hljs-keyword">const</span> MyApp(message: _message));
}

<span class="hljs-comment">// 앱이 켜졌을 때 열리는 첫 번째 페이지</span>
<span class="hljs-meta">@override</span>
<span class="hljs-keyword">void</span> initState() {
  <span class="hljs-keyword">super</span>.initState();
  WidgetsBinding.instance.addPostFrameCallback((_) <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.widget.message != <span class="hljs-keyword">null</span>) {
      Future.delayed(<span class="hljs-keyword">const</span> <span class="hljs-built_in">Duration</span>(milliseconds: <span class="hljs-number">1000</span>), () <span class="hljs-keyword">async</span> {
        <span class="hljs-keyword">await</span> Navigator.of(context).pushNamed(...);
      });
    }
  });
}
</code></pre>
<h2>Backend</h2>
<p>iOS에서 소리가 포함된 알림을 받으려면 Cloud 콘솔에 다음이 필요합니다: (깃헙 참조)</p>
<pre><code class="hljs language-js"><span class="hljs-string">"apns: { 
  "</span>payload<span class="hljs-string">": {
    "</span>aps<span class="hljs-string">": {
      "</span>sound<span class="hljs-string">": default
    }
  }
}
</span></code></pre>
<p>도움이 되길 바라요! 즐거운 코딩하세요.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Flutter FCM - 푸시 알림 탭 후 특정 화면으로 이동하는 방법","description":"","date":"2024-06-21 23:04","slug":"2024-06-21-FlutterFCMHowtoNavigatetoaParticularScreenAfterTappingonPushNotification","content":"\n\n이 게시물에서는 FCM 푸시 알림을 수신하고 사용자가 푸시 알림을 탭했을 때 특정 페이지로 이동하는 방법에 대해 Flutter에서 설명하겠습니다 (서버 측 코드 없음).\n\n![Flutter FCM How to Navigate to a Particular Screen After Tapping on Push Notification](/assets/img/2024-06-21-FlutterFCMHowtoNavigatetoaParticularScreenAfterTappingonPushNotification_0.png)\n\n## iOS 설정\n\nApple의 플랫폼에서 개발하는 것은 때로 어려울 수 있습니다. 예를 들어 Android와는 달리, 푸시 알림을 테스트하려면 실제 기기가 필요하며 Apple 개발자 프로그램에 관리자 또는 계정 보유자로 등록해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Xcode에서 Targets ` Runner ` Signing \u0026 Capabilities로 이동하여 푸시 알림을 추가하려면 +를 눌러주세요. 그리고 Background Modes에 Background fetch와 Remote notification도 추가해주세요.\n\n2. Apple Developer Member Center에서 Certificates, Identifiers \u0026 Profile로 이동하여 `Keys`에서 Apple Push Notification service (APN) 키를 추가해주세요. 그런 다음, 해당 키를 Firebase Console `Project Settings` Cloud Messaging `Apple app configuration`에 추가해주세요.\n\n3. 나머지는 매우 간단합니다 — 공식 문서를 참조해주세요.\n\n## Android 설정\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nForeground Notification(푸시 알림이 일시적으로 화면 상단에 팝업되는 경우)을 사용하려면 AndroidManifest.xml에 아래의 메타데이터가 필요합니다. 'high_importance_channel'에 대한 고급 중요도 채널은 Firebase 공식 문서에서 제공된 이름을 사용했으며 platformChannelSpecifics에서 (아래에서 자세히 설명함) 채널 이름을 지정할 수 있습니다.\n\n```js\n\u003cmeta-data\n android:name=\"com.google.firebase.messaging.default_notification_channel_id\"\n android:value=\"high_importance_channel\" /\u003e\n```\n\n## Firebase 초기화\n\n먼저 필요한 모든 패키지를 추가해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nflutter pub add firebase_messaging\nflutter pub add firebase_core\nflutter pub add flutter_local_notifications\n```\n\n파일들을 프로바이더와 서비스 파일로 분리하는 것에 익숙하지만, 그렇게 하는 것이 필요하지는 않습니다. Firebase 초기화에 대해 말씀드리면 main 함수에서 해야 합니다.\n\n```js\nvoid main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n  await FirebaseService.initializeFirebase();\n  runApp(const MyApp());\n}\n```\n\n```js\nimport 'dart:async';\n\nimport 'package:firebase_core/firebase_core.dart';\nimport 'package:firebase_messaging/firebase_messaging.dart';\nimport 'package:flutter_local_notifications/flutter_local_notifications.dart';\n\nclass FirebaseService {\n  static FirebaseMessaging? _firebaseMessaging;\n  static FirebaseMessaging get firebaseMessaging =\u003e FirebaseService._firebaseMessaging ?? FirebaseMessaging.instance;\n\n  static Future\u003cvoid\u003e initializeFirebase() async {\n    await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);\n    FirebaseService._firebaseMessaging = FirebaseMessaging.instance;\n    await FirebaseService.initializeLocalNotifications();\n    await FCMProvider.onMessage();\n    await FirebaseService.onBackgroundMsg();\n  }\n\n  Future\u003cString?\u003e getDeviceToken() async =\u003e await FirebaseMessaging.instance.getToken();\n\n  static FlutterLocalNotificationsPlugin _localNotificationsPlugin = FlutterLocalNotificationsPlugin();\n  \n  static Future\u003cvoid\u003e initializeLocalNotifications() async {\n    final InitializationSettings _initSettings = InitializationSettings(\n      android: AndroidInitializationSettings(\"icon_name\"),\n      iOS: DarwinInitializationSettings()\n    );\n    /// on did receive notification response = for when app is opened via notification while in foreground on android\n    await FirebaseService.localNotificationsPlugin.initialize(_initSettings, onDidReceiveNotificationResponse: FCMProvider.onTapNotification);\n    /// need this for ios foregournd notification\n    await FirebaseService.firebaseMessaging.setForegroundNotificationPresentationOptions(\n      alert: true, // Required to display a heads up notification\n      badge: true,\n      sound: true,\n    );\n  }\n  \n  static NotificationDetails platformChannelSpecifics = NotificationDetails(\n    android: AndroidNotificationDetails(\n      \"high_importance_channel\", \"High Importance Notifications\", priority: Priority.max, importance: Importance.max,\n    ),\n  );\n  \n  // for receiving message when app is in background or foreground\n  static Future\u003cvoid\u003e onMessage() async {\n    FirebaseMessaging.onMessage.listen((RemoteMessage message) async {\n      if (Platform.isAndroid) {\n        // if this is available when Platform.isIOS, you'll receive the notification twice \n        await FirebaseService._localNotificationsPlugin.show(\n          0, message.notification!.title, message.notification!.body, FirebaseService.platformChannelSpecifics,\n          payload: message.data.toString(),\n        );\n      }\n    });\n  }\n\n  static Future\u003cvoid\u003e onBackgroundMsg() async {\n    FirebaseMessaging.onBackgroundMessage(FCMProvider.backgroundHandler);\n  }\n\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nFirebaseService.initializeFirebase 메서드 내의 모든 메서드를 살펴보겠습니다.\n\n_firebaseMessaging: 이전 FCM 포스트를 작성하던 중 한국 어딘가에서 FirebaseMessaging.instance를 한 번만 호출하는 것이 좋다는 글을 읽은 적이 있어요. 그래서 이를 initialize 메서드에서 초기화하고, _firebaseMessaging이 null인 경우 적절한 값을 제공해주는 getter를 만들었어요.\n\ninitializeLocalNotifications: Foreground Notification을 활용하려면 이 메서드가 필요해요. Android에서는 반드시 전달해야 하는 인자 중 하나가 android/app/src/main/res/drawable에 있어야 하는 아이콘 로고 파일 이름이에요.\n\n전달된 두 번째 인자는 onSelectNotification으로, 사용자가 푸시 알림을 탭했을 때 (앱이 포그라운드에 있을 때) 실행되는 콜백입니다. 이런 처리가 없으면 앱이 열리고 더 이상의 작업이 발생하지 않아요. 이 메서드는 onMessage의 FirebaseMessaging.onMessage.listen(안드로이드용)로부터 페이로드를 받습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`onMessage`: 앱이 활성 상태인 경우에 알림을 받을 때 호출됩니다.\n\n`onBackgroundMsg`: 앱이 백그라운드에 있거나 종료된 상태일 때 알림을 받을 때 호출됩니다.\n\n## 디바이스 토큰 받기/확인\n\n```js\nFuture\u003cString?\u003e getDeviceToken() async =\u003e await FirebaseService.firebaseMessaging.getToken();\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기기 토큰을 관리하는 올바른 방법은 없지만 Firebase가 권장하는 방법이 있습니다. 제가 선택한 방법은 sqflite를 사용하여 사용자 기기에 타임스탬프와 함께 기기 토큰을 저장하고 서버로 보내는 것입니다. 앱이 열릴 때마다 기기에 저장된 토큰이 있다면 서버로 전송됩니다. 타임스탬프가 한 달 이상 경과했다는 것을 나타내는 경우, 토큰이 새로 고침되고 새 토큰이 서버로 전송됩니다. (아래 코드는 sqflite를 사용하는 제 sql 파일을 기반으로 합니다.)\n\n```js\nFuture\u003cString?\u003e checkDeviceToken() async {\n    String? _deviceToken;\n    final bool _exists = await this._sqlService.tableExists(this._tableName);\n    if (_exists) {\n        final List\u003cJson\u003e _data = await this._sqlService.readData(this._tableName);\n        final DateTime _timeStamp = DateTime.parse(_data[0][\"timeStamp\"]);\n        if (_timeStamp.difference(DateTime.now()).inDays \u003e 30) {\n            _deviceToken = await this._getDeviceToken();\n            if (_deviceToken == null) return null; // todo error handling\n            await this._updateDeviceToken(_deviceToken);\n        } else {\n            _deviceToken = _data[0][\"deviceToken\"];\n        }\n    } else {\n        _deviceToken = await this._getDeviceToken();\n        if (_deviceToken == null) return null; // todo error handling\n        await this._saveDeviceToken(_deviceToken);\n    }\n    return _deviceToken;\n}\n\nFuture\u003cString?\u003e _getDeviceToken() async =\u003e await FirebaseService.firebaseMessaging.getToken();\n  \nFuture\u003cvoid\u003e _saveDeviceToken(String deviceToken) async {\n    final String _createSql = \"CREATE TABLE ${this._tableName}(deviceToken TEXT PRIMARY KEY NOT NULL, timeStamp TEXT NOT NULL)\";\n    final List\u003cObject\u003e _values = [deviceToken, DateTime.now().toIso8601String()];\n    final String _insertSql = \"INSERT INTO ${this._tableName}(deviceToken, timeStamp) VALUES(?, ?)\";\n    await this._sqlService.saveData(tableName: this._tableName, createSql: _createSql, insertSql: _insertSql, values: _values);\n}\n\nFuture\u003cvoid\u003e _updateDeviceToken(String deviceToken) async {\n    final String _updateSql = \"UPDATE ${this._tableName} SET deviceToken = ?, timeStamp = ?\";\n    final List\u003cObject\u003e _values = [deviceToken, DateTime.now().toIso8601String()];\n    await this._sqlService.updateData(tableName: this._tableName, updateSql: _updateSql, values: _values);\n}\n```\n\n## 알림 수신\n\n불행히도 저는 서버 측 코드를 만들지 않아 message.data가 어떻게 작동하는지를 보여줄 수 없습니다. 왜냐하면 Firebase의 테스트 알림은 message.notification.body와 message.notification.title만 허용하기 때문입니다. 더 구체적인 알림을 테스트하려면 백엔드 개발자와 협력해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n푸시 알림을 받고 앱을 열 수 있는 세 가지 방법이 있습니다:\n\n- 앱이 화면에 표시될 때\n- 앱이 백그라운드에 있을 때\n- 앱이 종료되었을 때\n\n## 앱이 화면에 표시될 때 (Android)\n\n사용자가 알림을 탭하면 기본적으로 앱이 열리게 됩니다. 그러나 때로는 사용자가 특정 페이지를 볼 수 있기를 원할 수도 있습니다. 백엔드 개발자는 이러한 정보를 메시지.data에 제공할 수 있습니다. 해당 정보를 가져오기 위해 제공자를 만들었고, Navigator.of(context).push를 사용하기 위해 첫 화면에서 제공자의 BuildContext 변수를 초기화했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n@override\nvoid init() {\n  super.initState();\n  WidgetsBinding.instance.addPostFrameCallback((_) {\n    FCMProvider.setContext(context);\n  });\n}\n\n\n\nimport 'package:firebase_messaging/firebase_messaging.dart' show FirebaseMessaging, RemoteMessage;\nimport 'package:flutter/widgets.dart';\nimport 'package:pops/helpers/custom_types.dart';\n\nimport '../views/store_detail/store_detail_page.dart';\n\nclass FCMProvider with ChangeNotifier {\n  static BuildContext? _context;\n\n  static void setContext(BuildContext context) =\u003e FCMProvider._context = context;\n\n  /// when app is in the foreground\n  static Future\u003cvoid\u003e onTapNotification(NotificationResponse? response) async {\n    if (FCMProvider._context == null || response?.payload == null) return;\n    final Json _data = FCMProvider.convertPayload(response!.payload!);\n    if (_data.containsKey(...)){\n      await Navigator.of(FCMProvider._context!).push(...);\n    }\n  }\n\n  static Json convertPayload(String payload){\n    final String _payload = payload.substring(1, payload.length - 1);\n    List\u003cString\u003e _split = [];\n    _payload.split(\",\")..forEach((String s) =\u003e _split.addAll(s.split(\":\")));\n    Json _mapped = {};\n    for (int i = 0; i \u003c _split.length + 1; i++) {\n      if (i % 2 == 1) _mapped.addAll({_split[i-1].trim().toString(): _split[i].trim()});\n    }\n    return _mapped;\n  }\n  \n  static Future\u003cvoid\u003e onMessage() async {\n    FirebaseMessaging.onMessage.listen((RemoteMessage message) async {\n      if (FCMProvider._refreshNotifications != null) await FCMProvider._refreshNotifications!(true);\n      // if this is available when Platform.isIOS, you'll receive the notification twice \n      if (Platform.isAndroid) {\n        await FirebaseService.localNotificationsPlugin.show(\n          0, message.notification!.title,\n          message.notification!.body,\n          FirebaseService.platformChannelSpecifics,\n          payload: message.data.toString(),\n        );\n      }\n    });\n  }\n\n  static Future\u003cvoid\u003e backgroundHandler(RemoteMessage message) async {\n\n  }\n}\n\n\n앱이 화면에 보일 때 onTapNotification 메서드가 실행되며, localNotificationsPlugin.initialize의 onSelectNotification에 콜백 메서드로 설정됩니다. onTapNotification은 message.data.toString()을 페이로드로 받고(페이로드는 문자열로만 넣을 수 있기 때문에) 페이로드를 다시 맵으로 변환합니다.\n\n## 앱이 백그라운드에 있을 때 (Android) 및 앱이 포그라운드 / 백그라운드에 있을 때(iOS)\r\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n첫 번째 페이지에서 initState에 다음 코드를 넣었는데, 안드로이드에서 앱이 백그라운드에 있을 때 작동하는 것으로 보이며, iOS에서는 앱이 포그라운드/백그라운드에 있을 때 작동합니다.\n\n```js\nStream\u003cRemoteMessage\u003e _stream = FirebaseMessaging.onMessageOpenedApp;\n_stream.listen((RemoteMessage event) async {\n  if (event.data != null) {\n    await Navigator.of(context).push(...);\n  }\n});\n```\n\n## 앱이 종료된 경우\n\n앱이 종료된 경우 main.dart의 main 메소드에서 메시지를 받아와야 하며, 다른 곳에서 시도하면 실패할 것입니다. 저는 이 메시지를 첫 번째 페이지로 전달하고, initState에서 적절한 조치를 취했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\n// main.dart\nvoid main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n  await FirebaseService.initializeFirebase();\n  final RemoteMessage? _message = await FirebaseService.firebaseMessaging.getInitialMessage();\n  runApp(const MyApp(message: _message));\n}\n\n// 앱이 켜졌을 때 열리는 첫 번째 페이지\n@override\nvoid initState() {\n  super.initState();\n  WidgetsBinding.instance.addPostFrameCallback((_) async {\n    if (this.widget.message != null) {\n      Future.delayed(const Duration(milliseconds: 1000), () async {\n        await Navigator.of(context).pushNamed(...);\n      });\n    }\n  });\n}\n```\n\n## Backend\n\niOS에서 소리가 포함된 알림을 받으려면 Cloud 콘솔에 다음이 필요합니다: (깃헙 참조)\n\n```js\n\"apns: { \n  \"payload\": {\n    \"aps\": {\n      \"sound\": default\n    }\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n도움이 되길 바라요! 즐거운 코딩하세요.","ogImage":{"url":"/assets/img/2024-06-21-FlutterFCMHowtoNavigatetoaParticularScreenAfterTappingonPushNotification_0.png"},"coverImage":"/assets/img/2024-06-21-FlutterFCMHowtoNavigatetoaParticularScreenAfterTappingonPushNotification_0.png","tag":["Tech"],"readingTime":12},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e이 게시물에서는 FCM 푸시 알림을 수신하고 사용자가 푸시 알림을 탭했을 때 특정 페이지로 이동하는 방법에 대해 Flutter에서 설명하겠습니다 (서버 측 코드 없음).\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-FlutterFCMHowtoNavigatetoaParticularScreenAfterTappingonPushNotification_0.png\" alt=\"Flutter FCM How to Navigate to a Particular Screen After Tapping on Push Notification\"\u003e\u003c/p\u003e\n\u003ch2\u003eiOS 설정\u003c/h2\u003e\n\u003cp\u003eApple의 플랫폼에서 개발하는 것은 때로 어려울 수 있습니다. 예를 들어 Android와는 달리, 푸시 알림을 테스트하려면 실제 기기가 필요하며 Apple 개발자 프로그램에 관리자 또는 계정 보유자로 등록해야 합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eXcode에서 Targets \u003ccode\u003eRunner\u003c/code\u003e Signing \u0026#x26; Capabilities로 이동하여 푸시 알림을 추가하려면 +를 눌러주세요. 그리고 Background Modes에 Background fetch와 Remote notification도 추가해주세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e\n\u003cp\u003eApple Developer Member Center에서 Certificates, Identifiers \u0026#x26; Profile로 이동하여 \u003ccode\u003eKeys\u003c/code\u003e에서 Apple Push Notification service (APN) 키를 추가해주세요. 그런 다음, 해당 키를 Firebase Console \u003ccode\u003eProject Settings\u003c/code\u003e Cloud Messaging \u003ccode\u003eApple app configuration\u003c/code\u003e에 추가해주세요.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e나머지는 매우 간단합니다 — 공식 문서를 참조해주세요.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003eAndroid 설정\u003c/h2\u003e\n\u003cp\u003eForeground Notification(푸시 알림이 일시적으로 화면 상단에 팝업되는 경우)을 사용하려면 AndroidManifest.xml에 아래의 메타데이터가 필요합니다. 'high_importance_channel'에 대한 고급 중요도 채널은 Firebase 공식 문서에서 제공된 이름을 사용했으며 platformChannelSpecifics에서 (아래에서 자세히 설명함) 채널 이름을 지정할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;meta-data\n \u003cspan class=\"hljs-attr\"\u003eandroid\u003c/span\u003e:name=\u003cspan class=\"hljs-string\"\u003e\"com.google.firebase.messaging.default_notification_channel_id\"\u003c/span\u003e\n \u003cspan class=\"hljs-attr\"\u003eandroid\u003c/span\u003e:value=\u003cspan class=\"hljs-string\"\u003e\"high_importance_channel\"\u003c/span\u003e /\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eFirebase 초기화\u003c/h2\u003e\n\u003cp\u003e먼저 필요한 모든 패키지를 추가해주세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eflutter pub add firebase_messaging\nflutter pub add firebase_core\nflutter pub add flutter_local_notifications\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e파일들을 프로바이더와 서비스 파일로 분리하는 것에 익숙하지만, 그렇게 하는 것이 필요하지는 않습니다. Firebase 초기화에 대해 말씀드리면 main 함수에서 해야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e() \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n  \u003cspan class=\"hljs-title class_\"\u003eWidgetsFlutterBinding\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eensureInitialized\u003c/span\u003e();\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFirebaseService\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003einitializeFirebase\u003c/span\u003e();\n  \u003cspan class=\"hljs-title function_\"\u003erunApp\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyApp\u003c/span\u003e());\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'dart:async'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:firebase_core/firebase_core.dart'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:firebase_messaging/firebase_messaging.dart'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:flutter_local_notifications/flutter_local_notifications.dart'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFirebaseService\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFirebaseMessaging\u003c/span\u003e? _firebaseMessaging;\n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFirebaseMessaging\u003c/span\u003e get firebaseMessaging =\u003e \u003cspan class=\"hljs-title class_\"\u003eFirebaseService\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e_firebaseMessaging\u003c/span\u003e ?? \u003cspan class=\"hljs-title class_\"\u003eFirebaseMessaging\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003einstance\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFuture\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e\u003e \u003cspan class=\"hljs-title function_\"\u003einitializeFirebase\u003c/span\u003e() \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFirebase\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003einitializeApp\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eoptions\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDefaultFirebaseOptions\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecurrentPlatform\u003c/span\u003e);\n    \u003cspan class=\"hljs-title class_\"\u003eFirebaseService\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e_firebaseMessaging\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eFirebaseMessaging\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003einstance\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFirebaseService\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003einitializeLocalNotifications\u003c/span\u003e();\n    \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFCMProvider\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eonMessage\u003c/span\u003e();\n    \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFirebaseService\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eonBackgroundMsg\u003c/span\u003e();\n  }\n\n  \u003cspan class=\"hljs-title class_\"\u003eFuture\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e?\u003e \u003cspan class=\"hljs-title function_\"\u003egetDeviceToken\u003c/span\u003e() \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e =\u003e \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFirebaseMessaging\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003einstance\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetToken\u003c/span\u003e();\n\n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFlutterLocalNotificationsPlugin\u003c/span\u003e _localNotificationsPlugin = \u003cspan class=\"hljs-title class_\"\u003eFlutterLocalNotificationsPlugin\u003c/span\u003e();\n  \n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFuture\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e\u003e \u003cspan class=\"hljs-title function_\"\u003einitializeLocalNotifications\u003c/span\u003e() \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n    final \u003cspan class=\"hljs-title class_\"\u003eInitializationSettings\u003c/span\u003e _initSettings = \u003cspan class=\"hljs-title class_\"\u003eInitializationSettings\u003c/span\u003e(\n      \u003cspan class=\"hljs-attr\"\u003eandroid\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eAndroidInitializationSettings\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"icon_name\"\u003c/span\u003e),\n      \u003cspan class=\"hljs-attr\"\u003eiOS\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDarwinInitializationSettings\u003c/span\u003e()\n    );\n    \u003cspan class=\"hljs-comment\"\u003e/// on did receive notification response = for when app is opened via notification while in foreground on android\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFirebaseService\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003elocalNotificationsPlugin\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003einitialize\u003c/span\u003e(_initSettings, \u003cspan class=\"hljs-attr\"\u003eonDidReceiveNotificationResponse\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eFCMProvider\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eonTapNotification\u003c/span\u003e);\n    \u003cspan class=\"hljs-comment\"\u003e/// need this for ios foregournd notification\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFirebaseService\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003efirebaseMessaging\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003esetForegroundNotificationPresentationOptions\u003c/span\u003e(\n      \u003cspan class=\"hljs-attr\"\u003ealert\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// Required to display a heads up notification\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003ebadge\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003esound\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n    );\n  }\n  \n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNotificationDetails\u003c/span\u003e platformChannelSpecifics = \u003cspan class=\"hljs-title class_\"\u003eNotificationDetails\u003c/span\u003e(\n    \u003cspan class=\"hljs-attr\"\u003eandroid\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eAndroidNotificationDetails\u003c/span\u003e(\n      \u003cspan class=\"hljs-string\"\u003e\"high_importance_channel\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"High Importance Notifications\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003epriority\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003ePriority\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emax\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eimportance\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eImportance\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emax\u003c/span\u003e,\n    ),\n  );\n  \n  \u003cspan class=\"hljs-comment\"\u003e// for receiving message when app is in background or foreground\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFuture\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e\u003e \u003cspan class=\"hljs-title function_\"\u003eonMessage\u003c/span\u003e() \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n    \u003cspan class=\"hljs-title class_\"\u003eFirebaseMessaging\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eonMessage\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elisten\u003c/span\u003e((\u003cspan class=\"hljs-title class_\"\u003eRemoteMessage\u003c/span\u003e message) \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-title class_\"\u003ePlatform\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eisAndroid\u003c/span\u003e) {\n        \u003cspan class=\"hljs-comment\"\u003e// if this is available when Platform.isIOS, you'll receive the notification twice \u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFirebaseService\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e_localNotificationsPlugin\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eshow\u003c/span\u003e(\n          \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, message.\u003cspan class=\"hljs-property\"\u003enotification\u003c/span\u003e!.\u003cspan class=\"hljs-property\"\u003etitle\u003c/span\u003e, message.\u003cspan class=\"hljs-property\"\u003enotification\u003c/span\u003e!.\u003cspan class=\"hljs-property\"\u003ebody\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eFirebaseService\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eplatformChannelSpecifics\u003c/span\u003e,\n          \u003cspan class=\"hljs-attr\"\u003epayload\u003c/span\u003e: message.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etoString\u003c/span\u003e(),\n        );\n      }\n    });\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFuture\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e\u003e \u003cspan class=\"hljs-title function_\"\u003eonBackgroundMsg\u003c/span\u003e() \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n    \u003cspan class=\"hljs-title class_\"\u003eFirebaseMessaging\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eonBackgroundMessage\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eFCMProvider\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ebackgroundHandler\u003c/span\u003e);\n  }\n\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFirebaseService.initializeFirebase 메서드 내의 모든 메서드를 살펴보겠습니다.\u003c/p\u003e\n\u003cp\u003e_firebaseMessaging: 이전 FCM 포스트를 작성하던 중 한국 어딘가에서 FirebaseMessaging.instance를 한 번만 호출하는 것이 좋다는 글을 읽은 적이 있어요. 그래서 이를 initialize 메서드에서 초기화하고, _firebaseMessaging이 null인 경우 적절한 값을 제공해주는 getter를 만들었어요.\u003c/p\u003e\n\u003cp\u003einitializeLocalNotifications: Foreground Notification을 활용하려면 이 메서드가 필요해요. Android에서는 반드시 전달해야 하는 인자 중 하나가 android/app/src/main/res/drawable에 있어야 하는 아이콘 로고 파일 이름이에요.\u003c/p\u003e\n\u003cp\u003e전달된 두 번째 인자는 onSelectNotification으로, 사용자가 푸시 알림을 탭했을 때 (앱이 포그라운드에 있을 때) 실행되는 콜백입니다. 이런 처리가 없으면 앱이 열리고 더 이상의 작업이 발생하지 않아요. 이 메서드는 onMessage의 FirebaseMessaging.onMessage.listen(안드로이드용)로부터 페이로드를 받습니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eonMessage\u003c/code\u003e: 앱이 활성 상태인 경우에 알림을 받을 때 호출됩니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eonBackgroundMsg\u003c/code\u003e: 앱이 백그라운드에 있거나 종료된 상태일 때 알림을 받을 때 호출됩니다.\u003c/p\u003e\n\u003ch2\u003e디바이스 토큰 받기/확인\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eFuture\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e?\u003e \u003cspan class=\"hljs-title function_\"\u003egetDeviceToken\u003c/span\u003e() \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e =\u003e \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFirebaseService\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003efirebaseMessaging\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetToken\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e기기 토큰을 관리하는 올바른 방법은 없지만 Firebase가 권장하는 방법이 있습니다. 제가 선택한 방법은 sqflite를 사용하여 사용자 기기에 타임스탬프와 함께 기기 토큰을 저장하고 서버로 보내는 것입니다. 앱이 열릴 때마다 기기에 저장된 토큰이 있다면 서버로 전송됩니다. 타임스탬프가 한 달 이상 경과했다는 것을 나타내는 경우, 토큰이 새로 고침되고 새 토큰이 서버로 전송됩니다. (아래 코드는 sqflite를 사용하는 제 sql 파일을 기반으로 합니다.)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eFuture\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e?\u003e \u003cspan class=\"hljs-title function_\"\u003echeckDeviceToken\u003c/span\u003e() \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n    \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e? _deviceToken;\n    final bool _exists = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e_sqlService\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etableExists\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e_tableName\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (_exists) {\n        final \u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eJson\u003c/span\u003e\u003e _data = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e_sqlService\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ereadData\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e_tableName\u003c/span\u003e);\n        final \u003cspan class=\"hljs-title class_\"\u003eDateTime\u003c/span\u003e _timeStamp = \u003cspan class=\"hljs-title class_\"\u003eDateTime\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eparse\u003c/span\u003e(_data[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e][\u003cspan class=\"hljs-string\"\u003e\"timeStamp\"\u003c/span\u003e]);\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (_timeStamp.\u003cspan class=\"hljs-title function_\"\u003edifference\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eDateTime\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enow\u003c/span\u003e()).\u003cspan class=\"hljs-property\"\u003einDays\u003c/span\u003e \u003e \u003cspan class=\"hljs-number\"\u003e30\u003c/span\u003e) {\n            _deviceToken = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003e_getDeviceToken\u003c/span\u003e();\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (_deviceToken == \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// todo error handling\u003c/span\u003e\n            \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003e_updateDeviceToken\u003c/span\u003e(_deviceToken);\n        } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n            _deviceToken = _data[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e][\u003cspan class=\"hljs-string\"\u003e\"deviceToken\"\u003c/span\u003e];\n        }\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n        _deviceToken = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003e_getDeviceToken\u003c/span\u003e();\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (_deviceToken == \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// todo error handling\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003e_saveDeviceToken\u003c/span\u003e(_deviceToken);\n    }\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e _deviceToken;\n}\n\n\u003cspan class=\"hljs-title class_\"\u003eFuture\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e?\u003e \u003cspan class=\"hljs-title function_\"\u003e_getDeviceToken\u003c/span\u003e() \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e =\u003e \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFirebaseService\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003efirebaseMessaging\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetToken\u003c/span\u003e();\n  \n\u003cspan class=\"hljs-title class_\"\u003eFuture\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e\u003e \u003cspan class=\"hljs-title function_\"\u003e_saveDeviceToken\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e deviceToken) \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n    final \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e _createSql = \u003cspan class=\"hljs-string\"\u003e\"CREATE TABLE ${this._tableName}(deviceToken TEXT PRIMARY KEY NOT NULL, timeStamp TEXT NOT NULL)\"\u003c/span\u003e;\n    final \u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e\u003e _values = [deviceToken, \u003cspan class=\"hljs-title class_\"\u003eDateTime\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enow\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003etoIso8601String\u003c/span\u003e()];\n    final \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e _insertSql = \u003cspan class=\"hljs-string\"\u003e\"INSERT INTO ${this._tableName}(deviceToken, timeStamp) VALUES(?, ?)\"\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e_sqlService\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003esaveData\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003etableName\u003c/span\u003e: \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e_tableName\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ecreateSql\u003c/span\u003e: _createSql, \u003cspan class=\"hljs-attr\"\u003einsertSql\u003c/span\u003e: _insertSql, \u003cspan class=\"hljs-attr\"\u003evalues\u003c/span\u003e: _values);\n}\n\n\u003cspan class=\"hljs-title class_\"\u003eFuture\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e\u003e \u003cspan class=\"hljs-title function_\"\u003e_updateDeviceToken\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e deviceToken) \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n    final \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e _updateSql = \u003cspan class=\"hljs-string\"\u003e\"UPDATE ${this._tableName} SET deviceToken = ?, timeStamp = ?\"\u003c/span\u003e;\n    final \u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e\u003e _values = [deviceToken, \u003cspan class=\"hljs-title class_\"\u003eDateTime\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enow\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003etoIso8601String\u003c/span\u003e()];\n    \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e_sqlService\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eupdateData\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003etableName\u003c/span\u003e: \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e_tableName\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eupdateSql\u003c/span\u003e: _updateSql, \u003cspan class=\"hljs-attr\"\u003evalues\u003c/span\u003e: _values);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e알림 수신\u003c/h2\u003e\n\u003cp\u003e불행히도 저는 서버 측 코드를 만들지 않아 message.data가 어떻게 작동하는지를 보여줄 수 없습니다. 왜냐하면 Firebase의 테스트 알림은 message.notification.body와 message.notification.title만 허용하기 때문입니다. 더 구체적인 알림을 테스트하려면 백엔드 개발자와 협력해야 합니다.\u003c/p\u003e\n\u003cp\u003e푸시 알림을 받고 앱을 열 수 있는 세 가지 방법이 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e앱이 화면에 표시될 때\u003c/li\u003e\n\u003cli\u003e앱이 백그라운드에 있을 때\u003c/li\u003e\n\u003cli\u003e앱이 종료되었을 때\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e앱이 화면에 표시될 때 (Android)\u003c/h2\u003e\n\u003cp\u003e사용자가 알림을 탭하면 기본적으로 앱이 열리게 됩니다. 그러나 때로는 사용자가 특정 페이지를 볼 수 있기를 원할 수도 있습니다. 백엔드 개발자는 이러한 정보를 메시지.data에 제공할 수 있습니다. 해당 정보를 가져오기 위해 제공자를 만들었고, Navigator.of(context).push를 사용하기 위해 첫 화면에서 제공자의 BuildContext 변수를 초기화했습니다.\u003c/p\u003e\n\u003cp\u003e@override\nvoid init() {\nsuper.initState();\nWidgetsBinding.instance.addPostFrameCallback((_) {\nFCMProvider.setContext(context);\n});\n}\u003c/p\u003e\n\u003cp\u003eimport 'package:firebase_messaging/firebase_messaging.dart' show FirebaseMessaging, RemoteMessage;\nimport 'package:flutter/widgets.dart';\nimport 'package:pops/helpers/custom_types.dart';\u003c/p\u003e\n\u003cp\u003eimport '../views/store_detail/store_detail_page.dart';\u003c/p\u003e\n\u003cp\u003eclass FCMProvider with ChangeNotifier {\nstatic BuildContext? _context;\u003c/p\u003e\n\u003cp\u003estatic void setContext(BuildContext context) =\u003e FCMProvider._context = context;\u003c/p\u003e\n\u003cp\u003e/// when app is in the foreground\nstatic Future onTapNotification(NotificationResponse? response) async {\nif (FCMProvider._context == null || response?.payload == null) return;\nfinal Json _data = FCMProvider.convertPayload(response!.payload!);\nif (_data.containsKey(...)){\nawait Navigator.of(FCMProvider._context!).push(...);\n}\n}\u003c/p\u003e\n\u003cp\u003estatic Json convertPayload(String payload){\nfinal String _payload = payload.substring(1, payload.length - 1);\nList _split = [];\n_payload.split(\",\")..forEach((String s) =\u003e _split.addAll(s.split(\":\")));\nJson _mapped = {};\nfor (int i = 0; i \u0026#x3C; _split.length + 1; i++) {\nif (i % 2 == 1) _mapped.addAll({_split[i-1].trim().toString(): _split[i].trim()});\n}\nreturn _mapped;\n}\u003c/p\u003e\n\u003cp\u003estatic Future onMessage() async {\nFirebaseMessaging.onMessage.listen((RemoteMessage message) async {\nif (FCMProvider._refreshNotifications != null) await FCMProvider._refreshNotifications!(true);\n// if this is available when Platform.isIOS, you'll receive the notification twice\nif (Platform.isAndroid) {\nawait FirebaseService.localNotificationsPlugin.show(\n0, message.notification!.title,\nmessage.notification!.body,\nFirebaseService.platformChannelSpecifics,\npayload: message.data.toString(),\n);\n}\n});\n}\u003c/p\u003e\n\u003cp\u003estatic Future backgroundHandler(RemoteMessage message) async {\u003c/p\u003e\n\u003cp\u003e}\n}\u003c/p\u003e\n\u003cp\u003e앱이 화면에 보일 때 onTapNotification 메서드가 실행되며, localNotificationsPlugin.initialize의 onSelectNotification에 콜백 메서드로 설정됩니다. onTapNotification은 message.data.toString()을 페이로드로 받고(페이로드는 문자열로만 넣을 수 있기 때문에) 페이로드를 다시 맵으로 변환합니다.\u003c/p\u003e\n\u003ch2\u003e앱이 백그라운드에 있을 때 (Android) 및 앱이 포그라운드 / 백그라운드에 있을 때(iOS)\u003c/h2\u003e\n\u003cp\u003e첫 번째 페이지에서 initState에 다음 코드를 넣었는데, 안드로이드에서 앱이 백그라운드에 있을 때 작동하는 것으로 보이며, iOS에서는 앱이 포그라운드/백그라운드에 있을 때 작동합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eStream\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eRemoteMessage\u003c/span\u003e\u003e _stream = \u003cspan class=\"hljs-title class_\"\u003eFirebaseMessaging\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eonMessageOpenedApp\u003c/span\u003e;\n_stream.\u003cspan class=\"hljs-title function_\"\u003elisten\u003c/span\u003e((\u003cspan class=\"hljs-title class_\"\u003eRemoteMessage\u003c/span\u003e event) \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (event.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e != \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNavigator\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eof\u003c/span\u003e(context).\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e(...);\n  }\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e앱이 종료된 경우\u003c/h2\u003e\n\u003cp\u003e앱이 종료된 경우 main.dart의 main 메소드에서 메시지를 받아와야 하며, 다른 곳에서 시도하면 실패할 것입니다. 저는 이 메시지를 첫 번째 페이지로 전달하고, initState에서 적절한 조치를 취했습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-dart\"\u003e\u003cspan class=\"hljs-comment\"\u003e// main.dart\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e main() \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n  WidgetsFlutterBinding.ensureInitialized();\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e FirebaseService.initializeFirebase();\n  \u003cspan class=\"hljs-keyword\"\u003efinal\u003c/span\u003e RemoteMessage? _message = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e FirebaseService.firebaseMessaging.getInitialMessage();\n  runApp(\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e MyApp(message: _message));\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 앱이 켜졌을 때 열리는 첫 번째 페이지\u003c/span\u003e\n\u003cspan class=\"hljs-meta\"\u003e@override\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e initState() {\n  \u003cspan class=\"hljs-keyword\"\u003esuper\u003c/span\u003e.initState();\n  WidgetsBinding.instance.addPostFrameCallback((_) \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.widget.message != \u003cspan class=\"hljs-keyword\"\u003enull\u003c/span\u003e) {\n      Future.delayed(\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eDuration\u003c/span\u003e(milliseconds: \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e), () \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e Navigator.of(context).pushNamed(...);\n      });\n    }\n  });\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eBackend\u003c/h2\u003e\n\u003cp\u003eiOS에서 소리가 포함된 알림을 받으려면 Cloud 콘솔에 다음이 필요합니다: (깃헙 참조)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e\"apns: { \n  \"\u003c/span\u003epayload\u003cspan class=\"hljs-string\"\u003e\": {\n    \"\u003c/span\u003eaps\u003cspan class=\"hljs-string\"\u003e\": {\n      \"\u003c/span\u003esound\u003cspan class=\"hljs-string\"\u003e\": default\n    }\n  }\n}\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e도움이 되길 바라요! 즐거운 코딩하세요.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-21-FlutterFCMHowtoNavigatetoaParticularScreenAfterTappingonPushNotification"},"buildId":"Is-d56jDFXkc1ZfN4DhBP","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>