<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>클린 아키텍처 기반의 Flutter 폴더 구조 이렇게 해보세요 | uidev-css</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://uidev-css.github.io///post/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="클린 아키텍처 기반의 Flutter 폴더 구조 이렇게 해보세요 | uidev-css" data-gatsby-head="true"/><meta property="og:title" content="클린 아키텍처 기반의 Flutter 폴더 구조 이렇게 해보세요 | uidev-css" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://uidev-css.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://uidev-css.github.io///post/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo" data-gatsby-head="true"/><meta name="twitter:title" content="클린 아키텍처 기반의 Flutter 폴더 구조 이렇게 해보세요 | uidev-css" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | uidev-css" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-21 21:54" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b75a4bf98ee956a8.js" defer=""></script><script src="/_next/static/Is-d56jDFXkc1ZfN4DhBP/_buildManifest.js" defer=""></script><script src="/_next/static/Is-d56jDFXkc1ZfN4DhBP/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UIDEV CSS</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">클린 아키텍처 기반의 Flutter 폴더 구조 이렇게 해보세요</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="클린 아키텍처 기반의 Flutter 폴더 구조 이렇게 해보세요" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UIDEV CSS</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 21, 2024</span><span class="posts_reading_time__f7YPP">8<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>폴더 구조</h2>
<p><img src="/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_0.png" alt="Folder Structure"></p>
<p>폴더와 파일을 정리하는 일은 고통스럽습니다. 특히 수천 개의 파일을 관리해야 하는 대규모 프로젝트에서는 더욱 그렇습니다.</p>
<p>파일은 수백 줄을 포함해서는 안 됩니다. 정신 건강을 위해 높은 결합도를 가질 필요가 없고 단일 책임 원칙을 준수하려고 노력해야 합니다.</p>
<p>고품질의 코드를 작성하면 파일 크기가 작아지고 파일 수가 늘어납니다. 여기서 문제가 발생합니다. 이 모든 파일을 효율적으로 어떻게 정리해야 할까요?</p>
<h1>Clean Architecture으로 작업하기</h1>
<p>"Clean architecture"의 개념은 넓고 모호하지만, "저는 이 프로젝트에 Clean Arch를 사용하고 있어요"라고 말할 때, 나는 명확히 Flutterando의 아키텍처 제안을 말하는 것입니다!</p>
<h2>제안서 간단히 살펴보기</h2>
<p>코드를 4개의 계층으로 분리할 것입니다: Presenter, Domain, Infra, External.</p>
<p><img src="/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_1.png" alt="이미지"></p>
<ul>
<li>Presenter — UI 구성 요소입니다. 실제로 위젯이거나 위젯의 컨트롤러인 모든 것이 여기에 속합니다.</li>
<li>Domain — 앱의 핵심입니다. 모든 엔티티 및 비즈니스 로직이 이 곳에 보관됩니다.</li>
<li>Infra — 외부 레이어에서 오는 데이터를 모델, 저장소 및 서비스를 통해 도메인 레이어를 지원합니다.</li>
<li>External — 타사 라이브러리, 센서, SO, 저장소 및 앱의 다른 외부 종속성의 기능을 래핑하는 클래스입니다.</li>
</ul>
<p>강건한 해결책은 없지만, 저는 대부분의 상황에서 잘 작동하는 깔끔한 아키텍처를 선호합니다. 플러터 앱에서 깔끔한 아키텍처를 개선하기 위해 기술하는 몇 가지 관행을 추가한 이 글을 참고해 주세요.</p>
<p>메모:</p>
<p>이 아키텍처 제안에 익숙하지 않은 분들에게는 "entity", "controller" 등과 같은 구체적인 용어의 의미를 알기 어려울 수 있습니다.</p>
<p>이 글 전체를 통해 더 자세한 설명을 볼 수 있지만, 제안 내용을 설명하는 것이 목표가 아닙니다. 공식 문서를 읽을 필요는 없습니다.</p>
<h2>Clean arch + Modular arch = 행복한 개발자 😀</h2>
<p>모듈화 아키텍처는 관련 콘텐츠를 "모듈"이라고 불리는 한 곳에 모으는 것을 목표로 합니다.</p>
<p>각 모듈은 시스템의 중요한 책임을 나타내며 모든 모듈은 다른 모듈과 통신하는 규제를 갖습니다.</p>
<p>이는 결합도를 줄이고 다른 팀과 전문가들이 동일한 소스 코드로 작업하는 데 도움이 되는 시스템으로 볼 수 있습니다.</p>
<p><img src="/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_2.png" alt="image"></p>
<p>플러터에서 모듈 구조를 만들려면 Angular 프레임워크의 모듈 시스템을 기반으로 한 flutter_modular 패키지를 사용할 수 있어요.</p>
<p>이 패키지는 앱을 모듈로 분할하며, 각각의 모듈은 페이지와 종속성을 가지고 있어요. 사용자가 모듈을 빠져나오면, 해당 모듈의 모든 종속성이 폐기됩니다.</p>
<p>또한, 이 패키지는 의존성 주입 및 시스템 내비게이션을 위한 도구도 함께 제공돼요.</p>
<h1>루트 구조</h1>
<p>pubspec.yaml 파일과 함께 작업해야 할 디렉토리는 lib, assets, test 이렇게 3개가 있습니다.</p>
<p>여기에 새로운 내용은 없습니다! 아마 이미 사용하고 있을 것입니다. lib와 test는 플러터 프로젝트를 생성할 때 자동으로 생성되는 폴더이며, asset 폴더 사용이 플러터 팀에 의해 권장됩니다.</p>
<p>하지만 새로 온 사람들을 위해 그들의 사용법을 정의해야 할 것입니다. 그 이후에는 우리의 관심을 lib 폴더에만 집중할 것입니다.</p>
<h2>에셋 폴더</h2>
<p>이미지, 글꼴, 아이콘, 비디오 등과 같은 모든 코드가 아닌 파일을 보관하는 곳입니다. 앱에서 사용되는 모든 자원이 여기에 포함될 수 있습니다. 여기에는 에셋의 공식적인 정의가 있습니다:</p>
<h2>라이브러리 폴더</h2>
<p>여기에는 당신의 Dart 파일이 위치합니다! 코드를 여기에 넣어주세요. =)</p>
<h2>테스트 폴더</h2>
<p>여러분의 테스트 파일은 여기에 있습니다. 이 구조는 lib 폴더와 동일합니다.</p>
<p>예를 들어, lib/modules/register/presenters/widgets에 있는 위젯 user_register_form.dart에 대한 테스트를 예로 들어보겠습니다.</p>
<p>아래와 같이 만들어야 합니다.</p>
<p>test/modules/register/presenters/widgets/user_register_form_test.dart.</p>
<h1>라이브러리 구조</h1>
<p><img src="/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_4.png" alt="라이브러리 구조"></p>
<h2>메인 폴더</h2>
<p><img src="/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_5.png" alt="이미지"></p>
<p>이 폴더에는 각 Flavor의 주요 기능을 실행하는 파일이 포함되어 있습니다.</p>
<p>또한 모든 Flavor의 일반 명령을 실행하는 common_main.dart 파일도 있습니다.</p>
<p>플레이버를 사용하지 않는 경우, 이 폴더와 해당 내용을 닥스트 파일만 사용할 수 있도록 전환할 수 있습니다.</p>
<h2>i18n 폴더</h2>
<p><img src="/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_6.png" alt="이미지"></p>
<p>잠깐! JSON 파일인가요? assets 폴더에 있어야 하는 게 아닌가요? 네! 그렇습니다! 이것이 제 죄약입니다. JSON 파일을 넣어야 하는 올바른 위치는 assets 폴더입니다. 하지만 localization 패키지는 lib 파일에 유지해야 합니다.</p>
<p>물론이에요, 이건 패키지에서 강요하는 대로 하는 거예요. 그러나 의존성을 변경하고 easy_localization 패키지 등을 사용한다면 lib의 i18n 폴더를 제거해야 해요.</p>
<p>그렇다고 해도, 난 여전히 localization 라이브러리를 선호해요. 사용하기 쉽고 열린 이슈도 적거든요.</p>
<p>easy_localization 패키지 매니저는 더 이상 패키지를 활발하게 유지하지 않겠다고 이미 말했어요. 그래서 사용에 대해 경고하는 신호를 보냈어요.</p>
<h2>Core 폴더</h2>
<p><img src="/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_7.png" alt="Folder structure for Flutter with clean architecture"></p>
<p>다음은 Clean Architecture 레이어로 표현할 수 없는 모든 공유 로직을 배치하는 폴더입니다. 예를 들어, 정규식 문자열, 믹스인 및 유틸리티 클래스의 클래스입니다.</p>
<ul>
<li>Configs: 시스템에 필요한 초기 구성을 저장합니다. 예를 들어, firebase 초기 구성.</li>
<li>Constants: 라우트 이름 및 정규식과 같은 앱 설정 문자열.</li>
<li>Extensions: Dart 확장 기능.</li>
<li>Mixins: Dart 믹스인.</li>
<li>Utils: 통화 포매터 또는 날짜 유틸리티와 같은 유틸리티 클래스.</li>
<li>Validator: 필드, 전화 번호, 문서 등을 유효성 검사하는 클래스입니다.</li>
</ul>
<p>다시 말씀드리지만, 이것은 저의 개인 경험입니다. 일반적으로 이러한 폴더들로 충분히 필요한 모든 클래스를 보관할 수 있습니다. 프로젝트에 따라 utils의 남용을 피하기 위해 다른 폴더를 생성하기도 합니다.</p>
<h2>모듈 폴더</h2>
<p><img src="/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_8.png" alt="모듈 폴더 구성"></p>
<p>앱 모든 모듈을 포함하는 폴더입니다. 각 모듈 내에서는 앱의 각 페이지에 대한 필요한 클린 코드 레이어를 생성합니다.</p>
<p>주 모듈과 루트 위젯도 모듈 폴더 내에서 생성됩니다.</p>
<p>각 레이어에는 특정 유형의 클래스가 저장되어 있습니다. 이들은 다음과 같습니다:</p>
<ul>
<li>프리젠터:
위젯 — 시각적 컴포넌트 클래스.
컨트롤러 — 위젯의 상태 관리 클래스.</li>
<li>도메인:
엔티티 — 데이터를 저장하는 클래스.
유스케이스 — 비즈니스 논리 클래스.</li>
<li>인프라:
모델 — 데이터를 변환하기 위해 엔티티를 확장하는 클래스.
데이터 소스 — 외부 API와 연결하는 클래스 (HTTP 드라이버 사용).
서비스 — 외부 API와 연결하지 않는 클래스 (HTTP 드라이버를 사용하지 않음).</li>
<li>외부:
드라이버 — 외부 라이브러리나 시스템 기능을 격리하는 클래스.</li>
</ul>
<p>외부 레이어에는 클래스 유형이 하나뿐이므로 드라이버 폴더를 직접 만들겠습니다.</p>
<h1>모듈 구조</h1>
<p>모듈 구조의 세부 사항을 분석하기 위한 예시를 살펴보겠습니다. 저는 권한 모듈을 선택했는데, 이는 로그인 및 사용자 등록 양식과 같이 인증되지 않은 사용자가 액세스할 수 있는 모든 화면을 나타냅니다.</p>
<p><img src="/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_9.png" alt="Folder Structure"></p>
<p>각 모듈 폴더 내에서는 해당 모듈에서 사용하는 네비게이션 경로와 의존성을 설명하는 동일한 이름의 모듈 파일이 있을 것입니다.</p>
<p>저는 모듈을 페이지로 분리하는 것을 좋아합니다. 이 경우 사용자는 로그인, 등록 및 비밀번호 복구 3개의 페이지에 액세스할 수 있습니다.</p>
<p>로그인 폴더 내부에는 로그인 페이지에 필요한 클린 아키텍처 레이어가 포함되어 있습니다.</p>
<h2>프리젠터</h2>
<p>모듈은 페이지로 나뉘기 때문에, 프리젠터 폴더의 루트에는 로그인 페이지 위젯과 컨트롤러가 나타납니다.</p>
<p>다른 위젯은 "위젯" 폴더와 같은 다른 폴더에 있습니다. 필요할 때 위젯을 편의에 맞게 정리해보세요.</p>
<p>그리고 "dialogs" 폴더가 있습니다. 또한 페이지를 구성하는 데 PageView 위젯이 필요한 경우 "views" 폴더가 있을 수 있습니다.</p>
<p>위젯과 컨트롤러는 자신의 폴더가 없는 유일한 클래스 유형입니다. 높은 상관 관계 때문에 항상 함께 있어야 합니다.</p>
<h2>도메인</h2>
<p>로그인 기능을 위해 사용자 이름과 비밀번호를 저장하는 AuthEntity 클래스가 있습니다.</p>
<p>Usecase에서는 모든 비즈니스 로직을 실행합니다. 그렇다면 로그인 기능을 위한 가능한 비즈니스 로직은 무엇일까요?</p>
<p>만약 없다면, 단지 데이터 소스를 호출하기 위해 도메인이 필요합니다. 비즈니스 로직이 없다고 해서 아키텍처 규칙을 어기는 것은 변명이 되지 않습니다.</p>
<p>하지만... 사용자가 앱을 닫은 후에도 인증된 상태를 유지하나요? 그렇다면, 로컬에 인증 토큰을 저장해야 하는데, 이것도 비즈니스 로직입니다.</p>
<p>사용자가 로그인할 때 분석 데이터를 보내야 하나요? 이것도 비즈니스 로직입니다.</p>
<h2>인프라</h2>
<p>auth_datasource.dart 및 auth_datasource_impl.dart 파일을 메모해 두었나요?</p>
<p>Datasources, Services, 및 Drivers를 위한 인터페이스가 작성되었습니다. 코드가 있는 위치는 <code>name</code>_<code>layer</code>_impl.dart 파일입니다. 인터페이스 사용은 결합도를 줄이고 Mock 클래스로 테스트를 구축하는 데 도움이 됩니다.</p>
<p>만약 파일의 유형이 데이터 소스인 경우 이미 API를 쿼리한다는 것을 알고 계실 겁니다.</p>
<p>도메인은 데이터 소스에 AuthEntity를 제공하며, 이는 API 형식을 위해 값을 변환하기 위해 AuthModel을 사용합니다.</p>
<h2>Driver (External)</h2>
<p>우리가 API를 호출하면서 HTTP 클라이언트를 위한 드라이버 폴더가 없는 이유는 무엇일까요? 그것이 공유 모듈에 있기 때문이죠!</p>
<h2>공유 모듈</h2>
<p><img src="/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_11.png" alt="이미지"></p>
<p>페이지를 보관하는 모듈 외에도 공유 모듈을 가지고 있습니다.</p>
<p>이 모듈에는 모듈 간에 공유되는 모든 유형의 클래스를 넣을 것입니다. 가장 좋은 예는 HTTP 클라이언트 드라이버입니다.</p>
<p>이것은 버튼, 텍스트 필드, 스위치 등과 같은 테마 위젯을 공유하는 모듈입니다.</p>
<h1>내 폴더 구조 만족스러운가요?</h1>
<p><img src="/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_12.png" alt="image"></p>
<p>아니요! 왜 그래야 하나요?</p>
<p>그 죄악스러운 i18n 폴더, 언젠가는 로컬라이제이션 패키지가 고쳐줄 거에요!</p>
<p>제가 작업 중인 현재 모듈이나 공유 모듈에 원하는 드라이버가 있는지 항상 확신할 수 없네요.</p>
<p>utils 폴더를 봤나요? 유틸리티 클래스의 정확한 정의가 뭔지 아시나요? 제가 프로그래밍한 이유는 제게 유틸리티가 있기 때문이죠. 그저 제대로된 이름을 생각해내지 못해서 그것뿐인 거예요.</p>
<p>이론적으로, 필드 유효성 검증은 비즈니스 로직에 의해 정의되지만, TextField 위젯에 설정해야 합니다. 아마도 입력 유효성 검증은 공유 모듈 내부의 도메인에 있어야 할 것 같아요. 하지만, 그것들은 일반 유틸리티 함수이기 때문에 코어 폴더에 있어요.</p>
<p>머리 아프다! 그래도 과거의 나보다는 나아진 것 같아. 앞으로도 계속 나아졌으면 좋겠다.</p>
<p>그럼, 내가 도울 수 있을까 생각해봐. 나는 같은 문제를 겪는 개발자들을 지원하고 피드백을 얻기 위해 이 지식과 생각을 공유했어.</p>
<p>Flutter 앱을 위한 파일 구조에 대한 더 나은 또는 알려지지 않은 솔루션이 있는지 알고 있니?</p>
<p>내 생각과 프로그래밍 팁을 더 읽고 싶다면, 내 글을 확인하고 앞으로 올 컨텐츠를 팔로우하거나 구독해줘.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"클린 아키텍처 기반의 Flutter 폴더 구조 이렇게 해보세요","description":"","date":"2024-06-21 21:54","slug":"2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo","content":"\n\n## 폴더 구조\n\n![Folder Structure](/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_0.png)\n\n폴더와 파일을 정리하는 일은 고통스럽습니다. 특히 수천 개의 파일을 관리해야 하는 대규모 프로젝트에서는 더욱 그렇습니다.\n\n파일은 수백 줄을 포함해서는 안 됩니다. 정신 건강을 위해 높은 결합도를 가질 필요가 없고 단일 책임 원칙을 준수하려고 노력해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n고품질의 코드를 작성하면 파일 크기가 작아지고 파일 수가 늘어납니다. 여기서 문제가 발생합니다. 이 모든 파일을 효율적으로 어떻게 정리해야 할까요?\n\n# Clean Architecture으로 작업하기\n\n\"Clean architecture\"의 개념은 넓고 모호하지만, \"저는 이 프로젝트에 Clean Arch를 사용하고 있어요\"라고 말할 때, 나는 명확히 Flutterando의 아키텍처 제안을 말하는 것입니다!\n\n## 제안서 간단히 살펴보기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n코드를 4개의 계층으로 분리할 것입니다: Presenter, Domain, Infra, External.\n\n![이미지](/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_1.png)\n\n- Presenter — UI 구성 요소입니다. 실제로 위젯이거나 위젯의 컨트롤러인 모든 것이 여기에 속합니다.\n- Domain — 앱의 핵심입니다. 모든 엔티티 및 비즈니스 로직이 이 곳에 보관됩니다.\n- Infra — 외부 레이어에서 오는 데이터를 모델, 저장소 및 서비스를 통해 도메인 레이어를 지원합니다.\n- External — 타사 라이브러리, 센서, SO, 저장소 및 앱의 다른 외부 종속성의 기능을 래핑하는 클래스입니다.\n\n강건한 해결책은 없지만, 저는 대부분의 상황에서 잘 작동하는 깔끔한 아키텍처를 선호합니다. 플러터 앱에서 깔끔한 아키텍처를 개선하기 위해 기술하는 몇 가지 관행을 추가한 이 글을 참고해 주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n메모:\n\n이 아키텍처 제안에 익숙하지 않은 분들에게는 \"entity\", \"controller\" 등과 같은 구체적인 용어의 의미를 알기 어려울 수 있습니다.\n\n이 글 전체를 통해 더 자세한 설명을 볼 수 있지만, 제안 내용을 설명하는 것이 목표가 아닙니다. 공식 문서를 읽을 필요는 없습니다.\n\n## Clean arch + Modular arch = 행복한 개발자 😀\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모듈화 아키텍처는 관련 콘텐츠를 \"모듈\"이라고 불리는 한 곳에 모으는 것을 목표로 합니다.\n\n각 모듈은 시스템의 중요한 책임을 나타내며 모든 모듈은 다른 모듈과 통신하는 규제를 갖습니다.\n\n이는 결합도를 줄이고 다른 팀과 전문가들이 동일한 소스 코드로 작업하는 데 도움이 되는 시스템으로 볼 수 있습니다.\n\n![image](/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플러터에서 모듈 구조를 만들려면 Angular 프레임워크의 모듈 시스템을 기반으로 한 flutter_modular 패키지를 사용할 수 있어요.\n\n이 패키지는 앱을 모듈로 분할하며, 각각의 모듈은 페이지와 종속성을 가지고 있어요. 사용자가 모듈을 빠져나오면, 해당 모듈의 모든 종속성이 폐기됩니다.\n\n또한, 이 패키지는 의존성 주입 및 시스템 내비게이션을 위한 도구도 함께 제공돼요.\n\n# 루트 구조\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\u003cimg src=\"/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_3.png\" /\u003e\n\npubspec.yaml 파일과 함께 작업해야 할 디렉토리는 lib, assets, test 이렇게 3개가 있습니다.\n\n여기에 새로운 내용은 없습니다! 아마 이미 사용하고 있을 것입니다. lib와 test는 플러터 프로젝트를 생성할 때 자동으로 생성되는 폴더이며, asset 폴더 사용이 플러터 팀에 의해 권장됩니다.\n\n하지만 새로 온 사람들을 위해 그들의 사용법을 정의해야 할 것입니다. 그 이후에는 우리의 관심을 lib 폴더에만 집중할 것입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 에셋 폴더\n\n이미지, 글꼴, 아이콘, 비디오 등과 같은 모든 코드가 아닌 파일을 보관하는 곳입니다. 앱에서 사용되는 모든 자원이 여기에 포함될 수 있습니다. 여기에는 에셋의 공식적인 정의가 있습니다:\n\n## 라이브러리 폴더\n\n여기에는 당신의 Dart 파일이 위치합니다! 코드를 여기에 넣어주세요. =)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 테스트 폴더\n\n여러분의 테스트 파일은 여기에 있습니다. 이 구조는 lib 폴더와 동일합니다.\n\n예를 들어, lib/modules/register/presenters/widgets에 있는 위젯 user_register_form.dart에 대한 테스트를 예로 들어보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래와 같이 만들어야 합니다.\n\ntest/modules/register/presenters/widgets/user_register_form_test.dart.\n\n# 라이브러리 구조\n\n![라이브러리 구조](/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 메인 폴더\n\n![이미지](/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_5.png)\n\n이 폴더에는 각 Flavor의 주요 기능을 실행하는 파일이 포함되어 있습니다.\n\n또한 모든 Flavor의 일반 명령을 실행하는 common_main.dart 파일도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플레이버를 사용하지 않는 경우, 이 폴더와 해당 내용을 닥스트 파일만 사용할 수 있도록 전환할 수 있습니다.\n\n## i18n 폴더\n\n![이미지](/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_6.png)\n\n잠깐! JSON 파일인가요? assets 폴더에 있어야 하는 게 아닌가요? 네! 그렇습니다! 이것이 제 죄약입니다. JSON 파일을 넣어야 하는 올바른 위치는 assets 폴더입니다. 하지만 localization 패키지는 lib 파일에 유지해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n물론이에요, 이건 패키지에서 강요하는 대로 하는 거예요. 그러나 의존성을 변경하고 easy_localization 패키지 등을 사용한다면 lib의 i18n 폴더를 제거해야 해요.\n\n그렇다고 해도, 난 여전히 localization 라이브러리를 선호해요. 사용하기 쉽고 열린 이슈도 적거든요.\n\neasy_localization 패키지 매니저는 더 이상 패키지를 활발하게 유지하지 않겠다고 이미 말했어요. 그래서 사용에 대해 경고하는 신호를 보냈어요.\n\n## Core 폴더\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Folder structure for Flutter with clean architecture](/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_7.png)\n\n다음은 Clean Architecture 레이어로 표현할 수 없는 모든 공유 로직을 배치하는 폴더입니다. 예를 들어, 정규식 문자열, 믹스인 및 유틸리티 클래스의 클래스입니다.\n\n- Configs: 시스템에 필요한 초기 구성을 저장합니다. 예를 들어, firebase 초기 구성.\n- Constants: 라우트 이름 및 정규식과 같은 앱 설정 문자열.\n- Extensions: Dart 확장 기능.\n- Mixins: Dart 믹스인.\n- Utils: 통화 포매터 또는 날짜 유틸리티와 같은 유틸리티 클래스.\n- Validator: 필드, 전화 번호, 문서 등을 유효성 검사하는 클래스입니다.\n\n다시 말씀드리지만, 이것은 저의 개인 경험입니다. 일반적으로 이러한 폴더들로 충분히 필요한 모든 클래스를 보관할 수 있습니다. 프로젝트에 따라 utils의 남용을 피하기 위해 다른 폴더를 생성하기도 합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 모듈 폴더\n\n![모듈 폴더 구성](/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_8.png)\n\n앱 모든 모듈을 포함하는 폴더입니다. 각 모듈 내에서는 앱의 각 페이지에 대한 필요한 클린 코드 레이어를 생성합니다.\n\n주 모듈과 루트 위젯도 모듈 폴더 내에서 생성됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n각 레이어에는 특정 유형의 클래스가 저장되어 있습니다. 이들은 다음과 같습니다:\n\n- 프리젠터:\n위젯 — 시각적 컴포넌트 클래스.\n컨트롤러 — 위젯의 상태 관리 클래스.\r\n- 도메인:\n엔티티 — 데이터를 저장하는 클래스.\n유스케이스 — 비즈니스 논리 클래스.\r\n- 인프라:\n모델 — 데이터를 변환하기 위해 엔티티를 확장하는 클래스.\n데이터 소스 — 외부 API와 연결하는 클래스 (HTTP 드라이버 사용).\n서비스 — 외부 API와 연결하지 않는 클래스 (HTTP 드라이버를 사용하지 않음).\r\n- 외부:\n드라이버 — 외부 라이브러리나 시스템 기능을 격리하는 클래스.\n\n외부 레이어에는 클래스 유형이 하나뿐이므로 드라이버 폴더를 직접 만들겠습니다.\n\n# 모듈 구조\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모듈 구조의 세부 사항을 분석하기 위한 예시를 살펴보겠습니다. 저는 권한 모듈을 선택했는데, 이는 로그인 및 사용자 등록 양식과 같이 인증되지 않은 사용자가 액세스할 수 있는 모든 화면을 나타냅니다.\n\n![Folder Structure](/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_9.png)\n\n각 모듈 폴더 내에서는 해당 모듈에서 사용하는 네비게이션 경로와 의존성을 설명하는 동일한 이름의 모듈 파일이 있을 것입니다.\n\n저는 모듈을 페이지로 분리하는 것을 좋아합니다. 이 경우 사용자는 로그인, 등록 및 비밀번호 복구 3개의 페이지에 액세스할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_10.png\" /\u003e\n\n로그인 폴더 내부에는 로그인 페이지에 필요한 클린 아키텍처 레이어가 포함되어 있습니다.\n\n## 프리젠터\n\n모듈은 페이지로 나뉘기 때문에, 프리젠터 폴더의 루트에는 로그인 페이지 위젯과 컨트롤러가 나타납니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다른 위젯은 \"위젯\" 폴더와 같은 다른 폴더에 있습니다. 필요할 때 위젯을 편의에 맞게 정리해보세요.\n\n그리고 \"dialogs\" 폴더가 있습니다. 또한 페이지를 구성하는 데 PageView 위젯이 필요한 경우 \"views\" 폴더가 있을 수 있습니다.\n\n위젯과 컨트롤러는 자신의 폴더가 없는 유일한 클래스 유형입니다. 높은 상관 관계 때문에 항상 함께 있어야 합니다.\n\n## 도메인\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n로그인 기능을 위해 사용자 이름과 비밀번호를 저장하는 AuthEntity 클래스가 있습니다.\n\nUsecase에서는 모든 비즈니스 로직을 실행합니다. 그렇다면 로그인 기능을 위한 가능한 비즈니스 로직은 무엇일까요?\n\n만약 없다면, 단지 데이터 소스를 호출하기 위해 도메인이 필요합니다. 비즈니스 로직이 없다고 해서 아키텍처 규칙을 어기는 것은 변명이 되지 않습니다.\n\n하지만... 사용자가 앱을 닫은 후에도 인증된 상태를 유지하나요? 그렇다면, 로컬에 인증 토큰을 저장해야 하는데, 이것도 비즈니스 로직입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사용자가 로그인할 때 분석 데이터를 보내야 하나요? 이것도 비즈니스 로직입니다.\n\n## 인프라\n\nauth_datasource.dart 및 auth_datasource_impl.dart 파일을 메모해 두었나요?\n\nDatasources, Services, 및 Drivers를 위한 인터페이스가 작성되었습니다. 코드가 있는 위치는 `name`_`layer`_impl.dart 파일입니다. 인터페이스 사용은 결합도를 줄이고 Mock 클래스로 테스트를 구축하는 데 도움이 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 파일의 유형이 데이터 소스인 경우 이미 API를 쿼리한다는 것을 알고 계실 겁니다.\n\n도메인은 데이터 소스에 AuthEntity를 제공하며, 이는 API 형식을 위해 값을 변환하기 위해 AuthModel을 사용합니다.\n\n## Driver (External)\n\n우리가 API를 호출하면서 HTTP 클라이언트를 위한 드라이버 폴더가 없는 이유는 무엇일까요? 그것이 공유 모듈에 있기 때문이죠!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 공유 모듈\n\n![이미지](/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_11.png)\n\n페이지를 보관하는 모듈 외에도 공유 모듈을 가지고 있습니다.\n\n이 모듈에는 모듈 간에 공유되는 모든 유형의 클래스를 넣을 것입니다. 가장 좋은 예는 HTTP 클라이언트 드라이버입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이것은 버튼, 텍스트 필드, 스위치 등과 같은 테마 위젯을 공유하는 모듈입니다.\n\n# 내 폴더 구조 만족스러운가요?\n\n![image](/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_12.png)\n\n아니요! 왜 그래야 하나요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그 죄악스러운 i18n 폴더, 언젠가는 로컬라이제이션 패키지가 고쳐줄 거에요!\n\n제가 작업 중인 현재 모듈이나 공유 모듈에 원하는 드라이버가 있는지 항상 확신할 수 없네요.\n\nutils 폴더를 봤나요? 유틸리티 클래스의 정확한 정의가 뭔지 아시나요? 제가 프로그래밍한 이유는 제게 유틸리티가 있기 때문이죠. 그저 제대로된 이름을 생각해내지 못해서 그것뿐인 거예요.\n\n이론적으로, 필드 유효성 검증은 비즈니스 로직에 의해 정의되지만, TextField 위젯에 설정해야 합니다. 아마도 입력 유효성 검증은 공유 모듈 내부의 도메인에 있어야 할 것 같아요. 하지만, 그것들은 일반 유틸리티 함수이기 때문에 코어 폴더에 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n머리 아프다! 그래도 과거의 나보다는 나아진 것 같아. 앞으로도 계속 나아졌으면 좋겠다.\n\n그럼, 내가 도울 수 있을까 생각해봐. 나는 같은 문제를 겪는 개발자들을 지원하고 피드백을 얻기 위해 이 지식과 생각을 공유했어.\n\nFlutter 앱을 위한 파일 구조에 대한 더 나은 또는 알려지지 않은 솔루션이 있는지 알고 있니?\n\n내 생각과 프로그래밍 팁을 더 읽고 싶다면, 내 글을 확인하고 앞으로 올 컨텐츠를 팔로우하거나 구독해줘.","ogImage":{"url":"/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_0.png"},"coverImage":"/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_0.png","tag":["Tech"],"readingTime":8},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003e폴더 구조\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_0.png\" alt=\"Folder Structure\"\u003e\u003c/p\u003e\n\u003cp\u003e폴더와 파일을 정리하는 일은 고통스럽습니다. 특히 수천 개의 파일을 관리해야 하는 대규모 프로젝트에서는 더욱 그렇습니다.\u003c/p\u003e\n\u003cp\u003e파일은 수백 줄을 포함해서는 안 됩니다. 정신 건강을 위해 높은 결합도를 가질 필요가 없고 단일 책임 원칙을 준수하려고 노력해야 합니다.\u003c/p\u003e\n\u003cp\u003e고품질의 코드를 작성하면 파일 크기가 작아지고 파일 수가 늘어납니다. 여기서 문제가 발생합니다. 이 모든 파일을 효율적으로 어떻게 정리해야 할까요?\u003c/p\u003e\n\u003ch1\u003eClean Architecture으로 작업하기\u003c/h1\u003e\n\u003cp\u003e\"Clean architecture\"의 개념은 넓고 모호하지만, \"저는 이 프로젝트에 Clean Arch를 사용하고 있어요\"라고 말할 때, 나는 명확히 Flutterando의 아키텍처 제안을 말하는 것입니다!\u003c/p\u003e\n\u003ch2\u003e제안서 간단히 살펴보기\u003c/h2\u003e\n\u003cp\u003e코드를 4개의 계층으로 분리할 것입니다: Presenter, Domain, Infra, External.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePresenter — UI 구성 요소입니다. 실제로 위젯이거나 위젯의 컨트롤러인 모든 것이 여기에 속합니다.\u003c/li\u003e\n\u003cli\u003eDomain — 앱의 핵심입니다. 모든 엔티티 및 비즈니스 로직이 이 곳에 보관됩니다.\u003c/li\u003e\n\u003cli\u003eInfra — 외부 레이어에서 오는 데이터를 모델, 저장소 및 서비스를 통해 도메인 레이어를 지원합니다.\u003c/li\u003e\n\u003cli\u003eExternal — 타사 라이브러리, 센서, SO, 저장소 및 앱의 다른 외부 종속성의 기능을 래핑하는 클래스입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e강건한 해결책은 없지만, 저는 대부분의 상황에서 잘 작동하는 깔끔한 아키텍처를 선호합니다. 플러터 앱에서 깔끔한 아키텍처를 개선하기 위해 기술하는 몇 가지 관행을 추가한 이 글을 참고해 주세요.\u003c/p\u003e\n\u003cp\u003e메모:\u003c/p\u003e\n\u003cp\u003e이 아키텍처 제안에 익숙하지 않은 분들에게는 \"entity\", \"controller\" 등과 같은 구체적인 용어의 의미를 알기 어려울 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 글 전체를 통해 더 자세한 설명을 볼 수 있지만, 제안 내용을 설명하는 것이 목표가 아닙니다. 공식 문서를 읽을 필요는 없습니다.\u003c/p\u003e\n\u003ch2\u003eClean arch + Modular arch = 행복한 개발자 😀\u003c/h2\u003e\n\u003cp\u003e모듈화 아키텍처는 관련 콘텐츠를 \"모듈\"이라고 불리는 한 곳에 모으는 것을 목표로 합니다.\u003c/p\u003e\n\u003cp\u003e각 모듈은 시스템의 중요한 책임을 나타내며 모든 모듈은 다른 모듈과 통신하는 규제를 갖습니다.\u003c/p\u003e\n\u003cp\u003e이는 결합도를 줄이고 다른 팀과 전문가들이 동일한 소스 코드로 작업하는 데 도움이 되는 시스템으로 볼 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_2.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e플러터에서 모듈 구조를 만들려면 Angular 프레임워크의 모듈 시스템을 기반으로 한 flutter_modular 패키지를 사용할 수 있어요.\u003c/p\u003e\n\u003cp\u003e이 패키지는 앱을 모듈로 분할하며, 각각의 모듈은 페이지와 종속성을 가지고 있어요. 사용자가 모듈을 빠져나오면, 해당 모듈의 모든 종속성이 폐기됩니다.\u003c/p\u003e\n\u003cp\u003e또한, 이 패키지는 의존성 주입 및 시스템 내비게이션을 위한 도구도 함께 제공돼요.\u003c/p\u003e\n\u003ch1\u003e루트 구조\u003c/h1\u003e\n\u003cp\u003epubspec.yaml 파일과 함께 작업해야 할 디렉토리는 lib, assets, test 이렇게 3개가 있습니다.\u003c/p\u003e\n\u003cp\u003e여기에 새로운 내용은 없습니다! 아마 이미 사용하고 있을 것입니다. lib와 test는 플러터 프로젝트를 생성할 때 자동으로 생성되는 폴더이며, asset 폴더 사용이 플러터 팀에 의해 권장됩니다.\u003c/p\u003e\n\u003cp\u003e하지만 새로 온 사람들을 위해 그들의 사용법을 정의해야 할 것입니다. 그 이후에는 우리의 관심을 lib 폴더에만 집중할 것입니다.\u003c/p\u003e\n\u003ch2\u003e에셋 폴더\u003c/h2\u003e\n\u003cp\u003e이미지, 글꼴, 아이콘, 비디오 등과 같은 모든 코드가 아닌 파일을 보관하는 곳입니다. 앱에서 사용되는 모든 자원이 여기에 포함될 수 있습니다. 여기에는 에셋의 공식적인 정의가 있습니다:\u003c/p\u003e\n\u003ch2\u003e라이브러리 폴더\u003c/h2\u003e\n\u003cp\u003e여기에는 당신의 Dart 파일이 위치합니다! 코드를 여기에 넣어주세요. =)\u003c/p\u003e\n\u003ch2\u003e테스트 폴더\u003c/h2\u003e\n\u003cp\u003e여러분의 테스트 파일은 여기에 있습니다. 이 구조는 lib 폴더와 동일합니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, lib/modules/register/presenters/widgets에 있는 위젯 user_register_form.dart에 대한 테스트를 예로 들어보겠습니다.\u003c/p\u003e\n\u003cp\u003e아래와 같이 만들어야 합니다.\u003c/p\u003e\n\u003cp\u003etest/modules/register/presenters/widgets/user_register_form_test.dart.\u003c/p\u003e\n\u003ch1\u003e라이브러리 구조\u003c/h1\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_4.png\" alt=\"라이브러리 구조\"\u003e\u003c/p\u003e\n\u003ch2\u003e메인 폴더\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_5.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e이 폴더에는 각 Flavor의 주요 기능을 실행하는 파일이 포함되어 있습니다.\u003c/p\u003e\n\u003cp\u003e또한 모든 Flavor의 일반 명령을 실행하는 common_main.dart 파일도 있습니다.\u003c/p\u003e\n\u003cp\u003e플레이버를 사용하지 않는 경우, 이 폴더와 해당 내용을 닥스트 파일만 사용할 수 있도록 전환할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003ei18n 폴더\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_6.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e잠깐! JSON 파일인가요? assets 폴더에 있어야 하는 게 아닌가요? 네! 그렇습니다! 이것이 제 죄약입니다. JSON 파일을 넣어야 하는 올바른 위치는 assets 폴더입니다. 하지만 localization 패키지는 lib 파일에 유지해야 합니다.\u003c/p\u003e\n\u003cp\u003e물론이에요, 이건 패키지에서 강요하는 대로 하는 거예요. 그러나 의존성을 변경하고 easy_localization 패키지 등을 사용한다면 lib의 i18n 폴더를 제거해야 해요.\u003c/p\u003e\n\u003cp\u003e그렇다고 해도, 난 여전히 localization 라이브러리를 선호해요. 사용하기 쉽고 열린 이슈도 적거든요.\u003c/p\u003e\n\u003cp\u003eeasy_localization 패키지 매니저는 더 이상 패키지를 활발하게 유지하지 않겠다고 이미 말했어요. 그래서 사용에 대해 경고하는 신호를 보냈어요.\u003c/p\u003e\n\u003ch2\u003eCore 폴더\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_7.png\" alt=\"Folder structure for Flutter with clean architecture\"\u003e\u003c/p\u003e\n\u003cp\u003e다음은 Clean Architecture 레이어로 표현할 수 없는 모든 공유 로직을 배치하는 폴더입니다. 예를 들어, 정규식 문자열, 믹스인 및 유틸리티 클래스의 클래스입니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eConfigs: 시스템에 필요한 초기 구성을 저장합니다. 예를 들어, firebase 초기 구성.\u003c/li\u003e\n\u003cli\u003eConstants: 라우트 이름 및 정규식과 같은 앱 설정 문자열.\u003c/li\u003e\n\u003cli\u003eExtensions: Dart 확장 기능.\u003c/li\u003e\n\u003cli\u003eMixins: Dart 믹스인.\u003c/li\u003e\n\u003cli\u003eUtils: 통화 포매터 또는 날짜 유틸리티와 같은 유틸리티 클래스.\u003c/li\u003e\n\u003cli\u003eValidator: 필드, 전화 번호, 문서 등을 유효성 검사하는 클래스입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e다시 말씀드리지만, 이것은 저의 개인 경험입니다. 일반적으로 이러한 폴더들로 충분히 필요한 모든 클래스를 보관할 수 있습니다. 프로젝트에 따라 utils의 남용을 피하기 위해 다른 폴더를 생성하기도 합니다.\u003c/p\u003e\n\u003ch2\u003e모듈 폴더\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_8.png\" alt=\"모듈 폴더 구성\"\u003e\u003c/p\u003e\n\u003cp\u003e앱 모든 모듈을 포함하는 폴더입니다. 각 모듈 내에서는 앱의 각 페이지에 대한 필요한 클린 코드 레이어를 생성합니다.\u003c/p\u003e\n\u003cp\u003e주 모듈과 루트 위젯도 모듈 폴더 내에서 생성됩니다.\u003c/p\u003e\n\u003cp\u003e각 레이어에는 특정 유형의 클래스가 저장되어 있습니다. 이들은 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e프리젠터:\n위젯 — 시각적 컴포넌트 클래스.\n컨트롤러 — 위젯의 상태 관리 클래스.\u003c/li\u003e\n\u003cli\u003e도메인:\n엔티티 — 데이터를 저장하는 클래스.\n유스케이스 — 비즈니스 논리 클래스.\u003c/li\u003e\n\u003cli\u003e인프라:\n모델 — 데이터를 변환하기 위해 엔티티를 확장하는 클래스.\n데이터 소스 — 외부 API와 연결하는 클래스 (HTTP 드라이버 사용).\n서비스 — 외부 API와 연결하지 않는 클래스 (HTTP 드라이버를 사용하지 않음).\u003c/li\u003e\n\u003cli\u003e외부:\n드라이버 — 외부 라이브러리나 시스템 기능을 격리하는 클래스.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e외부 레이어에는 클래스 유형이 하나뿐이므로 드라이버 폴더를 직접 만들겠습니다.\u003c/p\u003e\n\u003ch1\u003e모듈 구조\u003c/h1\u003e\n\u003cp\u003e모듈 구조의 세부 사항을 분석하기 위한 예시를 살펴보겠습니다. 저는 권한 모듈을 선택했는데, 이는 로그인 및 사용자 등록 양식과 같이 인증되지 않은 사용자가 액세스할 수 있는 모든 화면을 나타냅니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_9.png\" alt=\"Folder Structure\"\u003e\u003c/p\u003e\n\u003cp\u003e각 모듈 폴더 내에서는 해당 모듈에서 사용하는 네비게이션 경로와 의존성을 설명하는 동일한 이름의 모듈 파일이 있을 것입니다.\u003c/p\u003e\n\u003cp\u003e저는 모듈을 페이지로 분리하는 것을 좋아합니다. 이 경우 사용자는 로그인, 등록 및 비밀번호 복구 3개의 페이지에 액세스할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e로그인 폴더 내부에는 로그인 페이지에 필요한 클린 아키텍처 레이어가 포함되어 있습니다.\u003c/p\u003e\n\u003ch2\u003e프리젠터\u003c/h2\u003e\n\u003cp\u003e모듈은 페이지로 나뉘기 때문에, 프리젠터 폴더의 루트에는 로그인 페이지 위젯과 컨트롤러가 나타납니다.\u003c/p\u003e\n\u003cp\u003e다른 위젯은 \"위젯\" 폴더와 같은 다른 폴더에 있습니다. 필요할 때 위젯을 편의에 맞게 정리해보세요.\u003c/p\u003e\n\u003cp\u003e그리고 \"dialogs\" 폴더가 있습니다. 또한 페이지를 구성하는 데 PageView 위젯이 필요한 경우 \"views\" 폴더가 있을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e위젯과 컨트롤러는 자신의 폴더가 없는 유일한 클래스 유형입니다. 높은 상관 관계 때문에 항상 함께 있어야 합니다.\u003c/p\u003e\n\u003ch2\u003e도메인\u003c/h2\u003e\n\u003cp\u003e로그인 기능을 위해 사용자 이름과 비밀번호를 저장하는 AuthEntity 클래스가 있습니다.\u003c/p\u003e\n\u003cp\u003eUsecase에서는 모든 비즈니스 로직을 실행합니다. 그렇다면 로그인 기능을 위한 가능한 비즈니스 로직은 무엇일까요?\u003c/p\u003e\n\u003cp\u003e만약 없다면, 단지 데이터 소스를 호출하기 위해 도메인이 필요합니다. 비즈니스 로직이 없다고 해서 아키텍처 규칙을 어기는 것은 변명이 되지 않습니다.\u003c/p\u003e\n\u003cp\u003e하지만... 사용자가 앱을 닫은 후에도 인증된 상태를 유지하나요? 그렇다면, 로컬에 인증 토큰을 저장해야 하는데, 이것도 비즈니스 로직입니다.\u003c/p\u003e\n\u003cp\u003e사용자가 로그인할 때 분석 데이터를 보내야 하나요? 이것도 비즈니스 로직입니다.\u003c/p\u003e\n\u003ch2\u003e인프라\u003c/h2\u003e\n\u003cp\u003eauth_datasource.dart 및 auth_datasource_impl.dart 파일을 메모해 두었나요?\u003c/p\u003e\n\u003cp\u003eDatasources, Services, 및 Drivers를 위한 인터페이스가 작성되었습니다. 코드가 있는 위치는 \u003ccode\u003ename\u003c/code\u003e_\u003ccode\u003elayer\u003c/code\u003e_impl.dart 파일입니다. 인터페이스 사용은 결합도를 줄이고 Mock 클래스로 테스트를 구축하는 데 도움이 됩니다.\u003c/p\u003e\n\u003cp\u003e만약 파일의 유형이 데이터 소스인 경우 이미 API를 쿼리한다는 것을 알고 계실 겁니다.\u003c/p\u003e\n\u003cp\u003e도메인은 데이터 소스에 AuthEntity를 제공하며, 이는 API 형식을 위해 값을 변환하기 위해 AuthModel을 사용합니다.\u003c/p\u003e\n\u003ch2\u003eDriver (External)\u003c/h2\u003e\n\u003cp\u003e우리가 API를 호출하면서 HTTP 클라이언트를 위한 드라이버 폴더가 없는 이유는 무엇일까요? 그것이 공유 모듈에 있기 때문이죠!\u003c/p\u003e\n\u003ch2\u003e공유 모듈\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_11.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e페이지를 보관하는 모듈 외에도 공유 모듈을 가지고 있습니다.\u003c/p\u003e\n\u003cp\u003e이 모듈에는 모듈 간에 공유되는 모든 유형의 클래스를 넣을 것입니다. 가장 좋은 예는 HTTP 클라이언트 드라이버입니다.\u003c/p\u003e\n\u003cp\u003e이것은 버튼, 텍스트 필드, 스위치 등과 같은 테마 위젯을 공유하는 모듈입니다.\u003c/p\u003e\n\u003ch1\u003e내 폴더 구조 만족스러운가요?\u003c/h1\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_12.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e아니요! 왜 그래야 하나요?\u003c/p\u003e\n\u003cp\u003e그 죄악스러운 i18n 폴더, 언젠가는 로컬라이제이션 패키지가 고쳐줄 거에요!\u003c/p\u003e\n\u003cp\u003e제가 작업 중인 현재 모듈이나 공유 모듈에 원하는 드라이버가 있는지 항상 확신할 수 없네요.\u003c/p\u003e\n\u003cp\u003eutils 폴더를 봤나요? 유틸리티 클래스의 정확한 정의가 뭔지 아시나요? 제가 프로그래밍한 이유는 제게 유틸리티가 있기 때문이죠. 그저 제대로된 이름을 생각해내지 못해서 그것뿐인 거예요.\u003c/p\u003e\n\u003cp\u003e이론적으로, 필드 유효성 검증은 비즈니스 로직에 의해 정의되지만, TextField 위젯에 설정해야 합니다. 아마도 입력 유효성 검증은 공유 모듈 내부의 도메인에 있어야 할 것 같아요. 하지만, 그것들은 일반 유틸리티 함수이기 때문에 코어 폴더에 있어요.\u003c/p\u003e\n\u003cp\u003e머리 아프다! 그래도 과거의 나보다는 나아진 것 같아. 앞으로도 계속 나아졌으면 좋겠다.\u003c/p\u003e\n\u003cp\u003e그럼, 내가 도울 수 있을까 생각해봐. 나는 같은 문제를 겪는 개발자들을 지원하고 피드백을 얻기 위해 이 지식과 생각을 공유했어.\u003c/p\u003e\n\u003cp\u003eFlutter 앱을 위한 파일 구조에 대한 더 나은 또는 알려지지 않은 솔루션이 있는지 알고 있니?\u003c/p\u003e\n\u003cp\u003e내 생각과 프로그래밍 팁을 더 읽고 싶다면, 내 글을 확인하고 앞으로 올 컨텐츠를 팔로우하거나 구독해줘.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo"},"buildId":"Is-d56jDFXkc1ZfN4DhBP","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>