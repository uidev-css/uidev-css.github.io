<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>CC 웹 소켓을 활용한 실시간 플러터 앱 구축 | uidev-css</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://uidev-css.github.io///post/2024-06-19-BuildingReal-TimeFlutterAppswithCCWebSocket" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="CC 웹 소켓을 활용한 실시간 플러터 앱 구축 | uidev-css" data-gatsby-head="true"/><meta property="og:title" content="CC 웹 소켓을 활용한 실시간 플러터 앱 구축 | uidev-css" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-19-BuildingReal-TimeFlutterAppswithCCWebSocket_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://uidev-css.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://uidev-css.github.io///post/2024-06-19-BuildingReal-TimeFlutterAppswithCCWebSocket" data-gatsby-head="true"/><meta name="twitter:title" content="CC 웹 소켓을 활용한 실시간 플러터 앱 구축 | uidev-css" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-19-BuildingReal-TimeFlutterAppswithCCWebSocket_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | uidev-css" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-19 14:20" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b4eed7811784bdd3.js" defer=""></script><script src="/_next/static/ckvP8zvWyPnScUqpsTElP/_buildManifest.js" defer=""></script><script src="/_next/static/ckvP8zvWyPnScUqpsTElP/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UIDEV CSS</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">CC 웹 소켓을 활용한 실시간 플러터 앱 구축</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="CC 웹 소켓을 활용한 실시간 플러터 앱 구축" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UIDEV CSS</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 19, 2024</span><span class="posts_reading_time__f7YPP">5<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-19-BuildingReal-TimeFlutterAppswithCCWebSocket&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>환영합니다! 실시간 Flutter 애플리케이션의 세계로 오신 것을 환영합니다! 오늘은 CC Web Socket을 소개할 기쁨이 있습니다. 이 강력하고 유연한 웹소켓 클라이언트는 Flutter 애플리케이션을 위해 특별히 설계되었습니다. 채팅 앱, 라이브 트레이딩 플랫폼, 또는 다른 실시간 애플리케이션을 구축 중이라면 CC Web Socket이 여러분을 도와드릴 것입니다.</p>
<h1>웹소켓이 필요한 이유</h1>
<p>CC Web Socket에 대한 구체적인 내용에 들어가기 전에, 왜 웹소켓이 필요한지 먼저 알아보겠습니다. 전통적인 HTTP 요청은 많은 작업에 좋지만, 실시간 통신에는 한계가 있습니다. 웹소켓은 클라이언트와 서버 간의 지속적인 연결을 제공하여 즉각적인 양방향 데이터 전송이 가능합니다. 이는 정시적인 업데이트가 중요한 애플리케이션에 이상적입니다.</p>
<h1>CC Web Socket 소개</h1>
<div class="content-ad"></div>
<p>CC Web Socket은 Flutter에서 WebSocket 연결을 쉽게 관리할 수 있게 해줍니다. 간단한 설정 옵션, 자세한 로깅 및 모듈식 아키텍처로 설계되어 초보자부터 숙련된 개발자의 요구를 충족시킬 수 있습니다.</p>
<h1>주요 기능</h1>
<ul>
<li>쉬운 초기화: 간편한 구성으로 웹소켓을 즉시 시작할 수 있습니다.</li>
<li>타임아웃 및 핑 설정: 연결 설정을 맞춤화하여 안정성과 반응성을 보장할 수 있습니다.</li>
<li>자동 재연결: 끊긴 연결에 대해 걱정할 필요가 없습니다. CC Web Socket이 재연결을 처리합니다.</li>
<li>자세한 로깅: 내장 로깅으로 연결 상태, 요청 및 응답을 추적할 수 있습니다.</li>
<li>모듈식 구조: 모듈을 사용하여 기능을 확장하고 사용자 정의할 수 있습니다.</li>
</ul>
<h1>시작하기</h1>
<div class="content-ad"></div>
<p>파이썬에 대한 가상 환경을 시작하는 방법을 안내해 드릴게요.</p>
<h1>1. 가상 환경 생성</h1>
<p>가상 환경을 생성하려면 다음 명령어를 사용하세요:</p>
<pre><code class="hljs language-bash">python -m venv myenv
</code></pre>
<h1>2. 가상 환경 활성화</h1>
<p>윈도우에서는 다음 명령어로 가상 환경을 활성화하세요:</p>
<pre><code class="hljs language-bash">myenv\Scripts\activate
</code></pre>
<p>macOS 및 리눅스에서는 다음 명령어로 가상 환경을 활성화하세요:</p>
<pre><code class="hljs language-bash"><span class="hljs-built_in">source</span> myenv/bin/activate
</code></pre>
<p>이제 가상 환경이 활성화되었습니다! 🎉</p>
<div class="content-ad"></div>
<p>그럼 flutter pub get을 실행하여 패키지를 설치하세요.</p>
<h1>초기화</h1>
<p>원하는 설정으로 CC Web Socket을 초기화하십시오. 간단한 예는 다음과 같습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-string">'package:cc_web_socket/cc_web_socket.dart'</span>;

<span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) {
  <span class="hljs-title class_">CCWebSocket</span>.<span class="hljs-title function_">init</span>(
    <span class="hljs-attr">socketOptions</span>: <span class="hljs-title class_">CCSocketOptions</span>(
      <span class="hljs-attr">uri</span>: <span class="hljs-title class_">Uri</span>(
        <span class="hljs-attr">scheme</span>: <span class="hljs-string">"wss"</span>,
        <span class="hljs-attr">host</span>: <span class="hljs-string">"echo.websocket.org"</span>,
        <span class="hljs-attr">port</span>: <span class="hljs-number">443</span>,
        <span class="hljs-attr">path</span>: <span class="hljs-string">".ws"</span>,
      ),
      <span class="hljs-attr">connectTimeout</span>: <span class="hljs-keyword">const</span> <span class="hljs-title class_">Duration</span>(<span class="hljs-attr">seconds</span>: <span class="hljs-number">5</span>),
      <span class="hljs-attr">pingInterval</span>: <span class="hljs-keyword">const</span> <span class="hljs-title class_">Duration</span>(<span class="hljs-attr">seconds</span>: <span class="hljs-number">120</span>),
      <span class="hljs-attr">requestTypeName</span>: <span class="hljs-string">"request_type"</span>,
      <span class="hljs-attr">autoConnect</span>: <span class="hljs-literal">true</span>,
    ),
    <span class="hljs-attr">loggingOptions</span>: <span class="hljs-title class_">CCSocketLogging</span>(
      <span class="hljs-attr">logEnabled</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">onConnection</span>: <span class="hljs-function">(<span class="hljs-params">prompt</span>) =></span> <span class="hljs-title function_">print</span>(<span class="hljs-string">"Connected: $prompt"</span>),
      <span class="hljs-attr">onReconnection</span>: <span class="hljs-function">(<span class="hljs-params">prompt</span>) =></span> <span class="hljs-title function_">print</span>(<span class="hljs-string">"Reconnecting: $prompt"</span>),
      <span class="hljs-attr">onClosed</span>: <span class="hljs-function">(<span class="hljs-params">prompt</span>) =></span> <span class="hljs-title function_">print</span>(<span class="hljs-string">"Connection closed: $prompt"</span>),
      <span class="hljs-attr">onRequest</span>: <span class="hljs-function">(<span class="hljs-params">prompt</span>) =></span> <span class="hljs-title function_">print</span>(<span class="hljs-string">"Request: $prompt"</span>),
      <span class="hljs-attr">onResponse</span>: <span class="hljs-function">(<span class="hljs-params">prompt</span>) =></span> <span class="hljs-title function_">print</span>(<span class="hljs-string">"Response: $prompt"</span>),
      <span class="hljs-attr">onError</span>: <span class="hljs-function">(<span class="hljs-params">prompt</span>) =></span> <span class="hljs-title function_">print</span>(<span class="hljs-string">"Error: $prompt"</span>),
    ),
    <span class="hljs-attr">modules</span>: [
      <span class="hljs-title class_">Example</span>(),
    ],
  );
}
</code></pre>
<div class="content-ad"></div>
<p>이 예제에서는 WebSocket echo 서비스에 연결하고 있습니다. uri, 시간 제한 및 로깅 옵션을 필요에 따라 사용자 정의할 수 있습니다.</p>
<p>참고: requestTypeName 매개변수는 반환된 데이터의 올바른 모듈과 일치하는 JSON 콘텐츠에서의 식별자입니다.</p>
<h1>연결하기</h1>
<p>연결을 설정하려면 다음을 간단히 호출하면 됩니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-title class_">CCWebSocket</span>.<span class="hljs-title function_">connect</span>();
</code></pre>
<h1>모듈 사용하기</h1>
<p>모듈을 사용하면 WebSocket 통신을 효율적으로 구조화할 수 있습니다. 모듈을 통해 요청을 보내는 방법은 다음과 같습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">CCWebSocket</span>.<span class="hljs-property">getModule</span>&#x3C;<span class="hljs-title class_">Example</span>>().<span class="hljs-title function_">request</span>(
  <span class="hljs-attr">body</span>: {
    <span class="hljs-string">"request_type"</span>: <span class="hljs-string">"Unknown"</span>,
  },
);
</code></pre>
<div class="content-ad"></div>
<h1>사용자 정의 모듈 만들기</h1>
<p>사용자 정의 모듈을 만드는 것은 간단합니다. 다음은 사용자 정의 모듈을 정의하는 예시입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">RequestModule</span> {
  @override
  <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span>(<span class="hljs-params">{required <span class="hljs-built_in">Map</span>&#x3C;<span class="hljs-built_in">String</span>, dynamic> body}</span>) {
    <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">request</span>(<span class="hljs-attr">body</span>: body);
  }

  @override
  <span class="hljs-keyword">void</span> <span class="hljs-title function_">response</span>(<span class="hljs-params">dynamic response</span>) {
    <span class="hljs-title function_">print</span>(<span class="hljs-string">"받은 응답: $response"</span>);
  }
}
</code></pre>
<p>모듈에서 요청과 응답 모두를 처리할 수 있어서 관심사 분리를 깔끔하게 유지할 수 있습니다.</p>
<div class="content-ad"></div>
<h1>실제 예시</h1>
<p>실제 예시로 모든 것을 함께 살펴봅시다. 라이브 채팅 애플리케이션을 구축 중이라고 가정해보겠습니다. CC 웹 소켓을 사용하여 이를 설정하는 방법은 다음과 같습니다.</p>
<h1>웹 소켓 초기화</h1>
<pre><code class="hljs language-js"><span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) {
  <span class="hljs-title class_">CCWebSocket</span>.<span class="hljs-title function_">init</span>(
    <span class="hljs-attr">socketOptions</span>: <span class="hljs-title class_">CCSocketOptions</span>(
      <span class="hljs-attr">uri</span>: <span class="hljs-title class_">Uri</span>(
        <span class="hljs-attr">scheme</span>: <span class="hljs-string">"wss"</span>,
        <span class="hljs-attr">host</span>: <span class="hljs-string">"yourchatserver.com"</span>,
        <span class="hljs-attr">port</span>: <span class="hljs-number">443</span>,
        <span class="hljs-attr">path</span>: <span class="hljs-string">"/chat"</span>,
      ),
      <span class="hljs-attr">connectTimeout</span>: <span class="hljs-keyword">const</span> <span class="hljs-title class_">Duration</span>(<span class="hljs-attr">seconds</span>: <span class="hljs-number">5</span>),
      <span class="hljs-attr">pingInterval</span>: <span class="hljs-keyword">const</span> <span class="hljs-title class_">Duration</span>(<span class="hljs-attr">seconds</span>: <span class="hljs-number">60</span>),
      <span class="hljs-attr">requestTypeName</span>: <span class="hljs-string">"message_type"</span>,
      <span class="hljs-attr">autoConnect</span>: <span class="hljs-literal">true</span>,
    ),
    <span class="hljs-attr">loggingOptions</span>: <span class="hljs-title class_">CCSocketLogging</span>(
      <span class="hljs-attr">logEnabled</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">onConnection</span>: <span class="hljs-function">(<span class="hljs-params">prompt</span>) =></span> <span class="hljs-title function_">print</span>(<span class="hljs-string">"채팅 서버에 연결되었습니다."</span>),
      <span class="hljs-attr">onReconnection</span>: <span class="hljs-function">(<span class="hljs-params">prompt</span>) =></span> <span class="hljs-title function_">print</span>(<span class="hljs-string">"채팅 서버 다시 연결 중..."</span>),
      <span class="hljs-attr">onClosed</span>: <span class="hljs-function">(<span class="hljs-params">prompt</span>) =></span> <span class="hljs-title function_">print</span>(<span class="hljs-string">"채팅 서버 연결이 닫혔습니다."</span>),
      <span class="hljs-attr">onRequest</span>: <span class="hljs-function">(<span class="hljs-params">prompt</span>) =></span> <span class="hljs-title function_">print</span>(<span class="hljs-string">"메시지 전송됨: $prompt"</span>),
      <span class="hljs-attr">onResponse</span>: <span class="hljs-function">(<span class="hljs-params">prompt</span>) =></span> <span class="hljs-title function_">print</span>(<span class="hljs-string">"메시지 받음: $prompt"</span>),
      <span class="hljs-attr">onError</span>: <span class="hljs-function">(<span class="hljs-params">prompt</span>) =></span> <span class="hljs-title function_">print</span>(<span class="hljs-string">"채팅 서버 오류: $prompt"</span>),
    ),
    <span class="hljs-attr">modules</span>: [
      <span class="hljs-title class_">ChatModule</span>(),
    ],
  );

  <span class="hljs-title class_">CCWebSocket</span>.<span class="hljs-title function_">connect</span>();
}
</code></pre>
<div class="content-ad"></div>
<h1>채팅 모듈 정의</h1>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChatModule</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">RequestModule</span> {
  @override
  <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span>(<span class="hljs-params">{required <span class="hljs-built_in">Map</span>&#x3C;<span class="hljs-built_in">String</span>, dynamic> body}</span>) {
    <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">request</span>(<span class="hljs-attr">body</span>: body);
  }

  @override
  <span class="hljs-keyword">void</span> <span class="hljs-title function_">response</span>(<span class="hljs-params">dynamic response</span>) {
    <span class="hljs-title function_">print</span>(<span class="hljs-string">"새로운 채팅 메시지: $response"</span>);
  }
}
</code></pre>
<h1>메시지 보내기</h1>
<pre><code class="hljs language-js"><span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> message</span>) {
  <span class="hljs-title class_">CCWebSocket</span>.<span class="hljs-property">getModule</span>&#x3C;<span class="hljs-title class_">ChatModule</span>>().<span class="hljs-title function_">request</span>(
    <span class="hljs-attr">body</span>: {
      <span class="hljs-string">"message_type"</span>: <span class="hljs-string">"chat"</span>,
      <span class="hljs-string">"content"</span>: message,
    },
  );
}
</code></pre>
<div class="content-ad"></div>
<p>이러한 단계를 따라 CC Web Socket을 사용하여 기본 라이브 채팅 애플리케이션을 만들었습니다. 이 모듈식 접근 방식은 코드를 깔끔하고 관리하기 쉽게 유지하며 새로운 기능 추가를 쉽게 만들어 줍니다.</p>
<h1>결론</h1>
<p>CC Web Socket은 어떤 플러터 개발자에게도 강력한 도구로, 애플리케이션에 실시간 기능을 추가하고자 하는 사람들에게 이상적입니다. 사용의 편의성, 강력한 기능, 그리고 모듈식 디자인은 플러터에서 WebSocket 관리의 핵심 선택지로 만들어 줍니다.</p>
<p>이 가이드가 CC Web Socket을 시작하고 멋진 실시간 애플리케이션을 만들도록 영감을 줄 수 있기를 바랍니다. 궁금한 점이나 의견이 있으면 언제든지 문의하거나 프로젝트에 기여해 주세요. 즐거운 코딩되세요!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"CC 웹 소켓을 활용한 실시간 플러터 앱 구축","description":"","date":"2024-06-19 14:20","slug":"2024-06-19-BuildingReal-TimeFlutterAppswithCCWebSocket","content":"\n\n환영합니다! 실시간 Flutter 애플리케이션의 세계로 오신 것을 환영합니다! 오늘은 CC Web Socket을 소개할 기쁨이 있습니다. 이 강력하고 유연한 웹소켓 클라이언트는 Flutter 애플리케이션을 위해 특별히 설계되었습니다. 채팅 앱, 라이브 트레이딩 플랫폼, 또는 다른 실시간 애플리케이션을 구축 중이라면 CC Web Socket이 여러분을 도와드릴 것입니다.\n\n# 웹소켓이 필요한 이유\n\nCC Web Socket에 대한 구체적인 내용에 들어가기 전에, 왜 웹소켓이 필요한지 먼저 알아보겠습니다. 전통적인 HTTP 요청은 많은 작업에 좋지만, 실시간 통신에는 한계가 있습니다. 웹소켓은 클라이언트와 서버 간의 지속적인 연결을 제공하여 즉각적인 양방향 데이터 전송이 가능합니다. 이는 정시적인 업데이트가 중요한 애플리케이션에 이상적입니다.\n\n# CC Web Socket 소개\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nCC Web Socket은 Flutter에서 WebSocket 연결을 쉽게 관리할 수 있게 해줍니다. 간단한 설정 옵션, 자세한 로깅 및 모듈식 아키텍처로 설계되어 초보자부터 숙련된 개발자의 요구를 충족시킬 수 있습니다.\n\n# 주요 기능\n\n- 쉬운 초기화: 간편한 구성으로 웹소켓을 즉시 시작할 수 있습니다.\n- 타임아웃 및 핑 설정: 연결 설정을 맞춤화하여 안정성과 반응성을 보장할 수 있습니다.\n- 자동 재연결: 끊긴 연결에 대해 걱정할 필요가 없습니다. CC Web Socket이 재연결을 처리합니다.\n- 자세한 로깅: 내장 로깅으로 연결 상태, 요청 및 응답을 추적할 수 있습니다.\n- 모듈식 구조: 모듈을 사용하여 기능을 확장하고 사용자 정의할 수 있습니다.\n\n# 시작하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n파이썬에 대한 가상 환경을 시작하는 방법을 안내해 드릴게요.\n\n# 1. 가상 환경 생성\n\n가상 환경을 생성하려면 다음 명령어를 사용하세요:\n\n```bash\npython -m venv myenv\n```\n\n# 2. 가상 환경 활성화\n\n윈도우에서는 다음 명령어로 가상 환경을 활성화하세요:\n\n```bash\nmyenv\\Scripts\\activate\n```\n\nmacOS 및 리눅스에서는 다음 명령어로 가상 환경을 활성화하세요:\n\n```bash\nsource myenv/bin/activate\n```\n\n이제 가상 환경이 활성화되었습니다! 🎉\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그럼 flutter pub get을 실행하여 패키지를 설치하세요.\n\n# 초기화\n\n원하는 설정으로 CC Web Socket을 초기화하십시오. 간단한 예는 다음과 같습니다:\n\n```js\nimport 'package:cc_web_socket/cc_web_socket.dart';\n\nvoid main() {\n  CCWebSocket.init(\n    socketOptions: CCSocketOptions(\n      uri: Uri(\n        scheme: \"wss\",\n        host: \"echo.websocket.org\",\n        port: 443,\n        path: \".ws\",\n      ),\n      connectTimeout: const Duration(seconds: 5),\n      pingInterval: const Duration(seconds: 120),\n      requestTypeName: \"request_type\",\n      autoConnect: true,\n    ),\n    loggingOptions: CCSocketLogging(\n      logEnabled: true,\n      onConnection: (prompt) =\u003e print(\"Connected: $prompt\"),\n      onReconnection: (prompt) =\u003e print(\"Reconnecting: $prompt\"),\n      onClosed: (prompt) =\u003e print(\"Connection closed: $prompt\"),\n      onRequest: (prompt) =\u003e print(\"Request: $prompt\"),\n      onResponse: (prompt) =\u003e print(\"Response: $prompt\"),\n      onError: (prompt) =\u003e print(\"Error: $prompt\"),\n    ),\n    modules: [\n      Example(),\n    ],\n  );\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예제에서는 WebSocket echo 서비스에 연결하고 있습니다. uri, 시간 제한 및 로깅 옵션을 필요에 따라 사용자 정의할 수 있습니다.\n\n참고: requestTypeName 매개변수는 반환된 데이터의 올바른 모듈과 일치하는 JSON 콘텐츠에서의 식별자입니다.\n\n# 연결하기\n\n연결을 설정하려면 다음을 간단히 호출하면 됩니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nCCWebSocket.connect();\n```\n\n# 모듈 사용하기\n\n모듈을 사용하면 WebSocket 통신을 효율적으로 구조화할 수 있습니다. 모듈을 통해 요청을 보내는 방법은 다음과 같습니다:\n\n```js\nCCWebSocket.getModule\u003cExample\u003e().request(\n  body: {\n    \"request_type\": \"Unknown\",\n  },\n);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 사용자 정의 모듈 만들기\n\n사용자 정의 모듈을 만드는 것은 간단합니다. 다음은 사용자 정의 모듈을 정의하는 예시입니다:\n\n```js\nclass Example extends RequestModule {\n  @override\n  void request({required Map\u003cString, dynamic\u003e body}) {\n    super.request(body: body);\n  }\n\n  @override\n  void response(dynamic response) {\n    print(\"받은 응답: $response\");\n  }\n}\n```\n\n모듈에서 요청과 응답 모두를 처리할 수 있어서 관심사 분리를 깔끔하게 유지할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 실제 예시\n\n실제 예시로 모든 것을 함께 살펴봅시다. 라이브 채팅 애플리케이션을 구축 중이라고 가정해보겠습니다. CC 웹 소켓을 사용하여 이를 설정하는 방법은 다음과 같습니다.\n\n# 웹 소켓 초기화\n\n```js\nvoid main() {\n  CCWebSocket.init(\n    socketOptions: CCSocketOptions(\n      uri: Uri(\n        scheme: \"wss\",\n        host: \"yourchatserver.com\",\n        port: 443,\n        path: \"/chat\",\n      ),\n      connectTimeout: const Duration(seconds: 5),\n      pingInterval: const Duration(seconds: 60),\n      requestTypeName: \"message_type\",\n      autoConnect: true,\n    ),\n    loggingOptions: CCSocketLogging(\n      logEnabled: true,\n      onConnection: (prompt) =\u003e print(\"채팅 서버에 연결되었습니다.\"),\n      onReconnection: (prompt) =\u003e print(\"채팅 서버 다시 연결 중...\"),\n      onClosed: (prompt) =\u003e print(\"채팅 서버 연결이 닫혔습니다.\"),\n      onRequest: (prompt) =\u003e print(\"메시지 전송됨: $prompt\"),\n      onResponse: (prompt) =\u003e print(\"메시지 받음: $prompt\"),\n      onError: (prompt) =\u003e print(\"채팅 서버 오류: $prompt\"),\n    ),\n    modules: [\n      ChatModule(),\n    ],\n  );\n\n  CCWebSocket.connect();\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 채팅 모듈 정의\n\n```js\nclass ChatModule extends RequestModule {\n  @override\n  void request({required Map\u003cString, dynamic\u003e body}) {\n    super.request(body: body);\n  }\n\n  @override\n  void response(dynamic response) {\n    print(\"새로운 채팅 메시지: $response\");\n  }\n}\n```\n\n# 메시지 보내기\n\n```js\nvoid sendMessage(String message) {\n  CCWebSocket.getModule\u003cChatModule\u003e().request(\n    body: {\n      \"message_type\": \"chat\",\n      \"content\": message,\n    },\n  );\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이러한 단계를 따라 CC Web Socket을 사용하여 기본 라이브 채팅 애플리케이션을 만들었습니다. 이 모듈식 접근 방식은 코드를 깔끔하고 관리하기 쉽게 유지하며 새로운 기능 추가를 쉽게 만들어 줍니다.\n\n# 결론\n\nCC Web Socket은 어떤 플러터 개발자에게도 강력한 도구로, 애플리케이션에 실시간 기능을 추가하고자 하는 사람들에게 이상적입니다. 사용의 편의성, 강력한 기능, 그리고 모듈식 디자인은 플러터에서 WebSocket 관리의 핵심 선택지로 만들어 줍니다.\n\n이 가이드가 CC Web Socket을 시작하고 멋진 실시간 애플리케이션을 만들도록 영감을 줄 수 있기를 바랍니다. 궁금한 점이나 의견이 있으면 언제든지 문의하거나 프로젝트에 기여해 주세요. 즐거운 코딩되세요!","ogImage":{"url":"/assets/img/2024-06-19-BuildingReal-TimeFlutterAppswithCCWebSocket_0.png"},"coverImage":"/assets/img/2024-06-19-BuildingReal-TimeFlutterAppswithCCWebSocket_0.png","tag":["Tech"],"readingTime":5},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e환영합니다! 실시간 Flutter 애플리케이션의 세계로 오신 것을 환영합니다! 오늘은 CC Web Socket을 소개할 기쁨이 있습니다. 이 강력하고 유연한 웹소켓 클라이언트는 Flutter 애플리케이션을 위해 특별히 설계되었습니다. 채팅 앱, 라이브 트레이딩 플랫폼, 또는 다른 실시간 애플리케이션을 구축 중이라면 CC Web Socket이 여러분을 도와드릴 것입니다.\u003c/p\u003e\n\u003ch1\u003e웹소켓이 필요한 이유\u003c/h1\u003e\n\u003cp\u003eCC Web Socket에 대한 구체적인 내용에 들어가기 전에, 왜 웹소켓이 필요한지 먼저 알아보겠습니다. 전통적인 HTTP 요청은 많은 작업에 좋지만, 실시간 통신에는 한계가 있습니다. 웹소켓은 클라이언트와 서버 간의 지속적인 연결을 제공하여 즉각적인 양방향 데이터 전송이 가능합니다. 이는 정시적인 업데이트가 중요한 애플리케이션에 이상적입니다.\u003c/p\u003e\n\u003ch1\u003eCC Web Socket 소개\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eCC Web Socket은 Flutter에서 WebSocket 연결을 쉽게 관리할 수 있게 해줍니다. 간단한 설정 옵션, 자세한 로깅 및 모듈식 아키텍처로 설계되어 초보자부터 숙련된 개발자의 요구를 충족시킬 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e주요 기능\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e쉬운 초기화: 간편한 구성으로 웹소켓을 즉시 시작할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e타임아웃 및 핑 설정: 연결 설정을 맞춤화하여 안정성과 반응성을 보장할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e자동 재연결: 끊긴 연결에 대해 걱정할 필요가 없습니다. CC Web Socket이 재연결을 처리합니다.\u003c/li\u003e\n\u003cli\u003e자세한 로깅: 내장 로깅으로 연결 상태, 요청 및 응답을 추적할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e모듈식 구조: 모듈을 사용하여 기능을 확장하고 사용자 정의할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e시작하기\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e파이썬에 대한 가상 환경을 시작하는 방법을 안내해 드릴게요.\u003c/p\u003e\n\u003ch1\u003e1. 가상 환경 생성\u003c/h1\u003e\n\u003cp\u003e가상 환경을 생성하려면 다음 명령어를 사용하세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003epython -m venv myenv\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e2. 가상 환경 활성화\u003c/h1\u003e\n\u003cp\u003e윈도우에서는 다음 명령어로 가상 환경을 활성화하세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003emyenv\\Scripts\\activate\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003emacOS 및 리눅스에서는 다음 명령어로 가상 환경을 활성화하세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e\u003cspan class=\"hljs-built_in\"\u003esource\u003c/span\u003e myenv/bin/activate\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 가상 환경이 활성화되었습니다! 🎉\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e그럼 flutter pub get을 실행하여 패키지를 설치하세요.\u003c/p\u003e\n\u003ch1\u003e초기화\u003c/h1\u003e\n\u003cp\u003e원하는 설정으로 CC Web Socket을 초기화하십시오. 간단한 예는 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:cc_web_socket/cc_web_socket.dart'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-title class_\"\u003eCCWebSocket\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003einit\u003c/span\u003e(\n    \u003cspan class=\"hljs-attr\"\u003esocketOptions\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCCSocketOptions\u003c/span\u003e(\n      \u003cspan class=\"hljs-attr\"\u003euri\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eUri\u003c/span\u003e(\n        \u003cspan class=\"hljs-attr\"\u003escheme\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"wss\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003ehost\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"echo.websocket.org\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003eport\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e443\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\".ws\"\u003c/span\u003e,\n      ),\n      \u003cspan class=\"hljs-attr\"\u003econnectTimeout\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDuration\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eseconds\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e),\n      \u003cspan class=\"hljs-attr\"\u003epingInterval\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDuration\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eseconds\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e120\u003c/span\u003e),\n      \u003cspan class=\"hljs-attr\"\u003erequestTypeName\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"request_type\"\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003eautoConnect\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n    ),\n    \u003cspan class=\"hljs-attr\"\u003eloggingOptions\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCCSocketLogging\u003c/span\u003e(\n      \u003cspan class=\"hljs-attr\"\u003elogEnabled\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003eonConnection\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eprompt\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Connected: $prompt\"\u003c/span\u003e),\n      \u003cspan class=\"hljs-attr\"\u003eonReconnection\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eprompt\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Reconnecting: $prompt\"\u003c/span\u003e),\n      \u003cspan class=\"hljs-attr\"\u003eonClosed\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eprompt\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Connection closed: $prompt\"\u003c/span\u003e),\n      \u003cspan class=\"hljs-attr\"\u003eonRequest\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eprompt\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Request: $prompt\"\u003c/span\u003e),\n      \u003cspan class=\"hljs-attr\"\u003eonResponse\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eprompt\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Response: $prompt\"\u003c/span\u003e),\n      \u003cspan class=\"hljs-attr\"\u003eonError\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eprompt\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Error: $prompt\"\u003c/span\u003e),\n    ),\n    \u003cspan class=\"hljs-attr\"\u003emodules\u003c/span\u003e: [\n      \u003cspan class=\"hljs-title class_\"\u003eExample\u003c/span\u003e(),\n    ],\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 예제에서는 WebSocket echo 서비스에 연결하고 있습니다. uri, 시간 제한 및 로깅 옵션을 필요에 따라 사용자 정의할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e참고: requestTypeName 매개변수는 반환된 데이터의 올바른 모듈과 일치하는 JSON 콘텐츠에서의 식별자입니다.\u003c/p\u003e\n\u003ch1\u003e연결하기\u003c/h1\u003e\n\u003cp\u003e연결을 설정하려면 다음을 간단히 호출하면 됩니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eCCWebSocket\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003econnect\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e모듈 사용하기\u003c/h1\u003e\n\u003cp\u003e모듈을 사용하면 WebSocket 통신을 효율적으로 구조화할 수 있습니다. 모듈을 통해 요청을 보내는 방법은 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eCCWebSocket\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003egetModule\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eExample\u003c/span\u003e\u003e().\u003cspan class=\"hljs-title function_\"\u003erequest\u003c/span\u003e(\n  \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: {\n    \u003cspan class=\"hljs-string\"\u003e\"request_type\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Unknown\"\u003c/span\u003e,\n  },\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e사용자 정의 모듈 만들기\u003c/h1\u003e\n\u003cp\u003e사용자 정의 모듈을 만드는 것은 간단합니다. 다음은 사용자 정의 모듈을 정의하는 예시입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eExample\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eRequestModule\u003c/span\u003e {\n  @override\n  \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erequest\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{required \u003cspan class=\"hljs-built_in\"\u003eMap\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e, dynamic\u003e body}\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003esuper\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erequest\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: body);\n  }\n\n  @override\n  \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eresponse\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003edynamic response\u003c/span\u003e) {\n    \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"받은 응답: $response\"\u003c/span\u003e);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e모듈에서 요청과 응답 모두를 처리할 수 있어서 관심사 분리를 깔끔하게 유지할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e실제 예시\u003c/h1\u003e\n\u003cp\u003e실제 예시로 모든 것을 함께 살펴봅시다. 라이브 채팅 애플리케이션을 구축 중이라고 가정해보겠습니다. CC 웹 소켓을 사용하여 이를 설정하는 방법은 다음과 같습니다.\u003c/p\u003e\n\u003ch1\u003e웹 소켓 초기화\u003c/h1\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-title class_\"\u003eCCWebSocket\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003einit\u003c/span\u003e(\n    \u003cspan class=\"hljs-attr\"\u003esocketOptions\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCCSocketOptions\u003c/span\u003e(\n      \u003cspan class=\"hljs-attr\"\u003euri\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eUri\u003c/span\u003e(\n        \u003cspan class=\"hljs-attr\"\u003escheme\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"wss\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003ehost\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"yourchatserver.com\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003eport\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e443\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"/chat\"\u003c/span\u003e,\n      ),\n      \u003cspan class=\"hljs-attr\"\u003econnectTimeout\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDuration\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eseconds\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e),\n      \u003cspan class=\"hljs-attr\"\u003epingInterval\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDuration\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eseconds\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e60\u003c/span\u003e),\n      \u003cspan class=\"hljs-attr\"\u003erequestTypeName\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"message_type\"\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003eautoConnect\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n    ),\n    \u003cspan class=\"hljs-attr\"\u003eloggingOptions\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCCSocketLogging\u003c/span\u003e(\n      \u003cspan class=\"hljs-attr\"\u003elogEnabled\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003eonConnection\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eprompt\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"채팅 서버에 연결되었습니다.\"\u003c/span\u003e),\n      \u003cspan class=\"hljs-attr\"\u003eonReconnection\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eprompt\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"채팅 서버 다시 연결 중...\"\u003c/span\u003e),\n      \u003cspan class=\"hljs-attr\"\u003eonClosed\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eprompt\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"채팅 서버 연결이 닫혔습니다.\"\u003c/span\u003e),\n      \u003cspan class=\"hljs-attr\"\u003eonRequest\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eprompt\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"메시지 전송됨: $prompt\"\u003c/span\u003e),\n      \u003cspan class=\"hljs-attr\"\u003eonResponse\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eprompt\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"메시지 받음: $prompt\"\u003c/span\u003e),\n      \u003cspan class=\"hljs-attr\"\u003eonError\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eprompt\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"채팅 서버 오류: $prompt\"\u003c/span\u003e),\n    ),\n    \u003cspan class=\"hljs-attr\"\u003emodules\u003c/span\u003e: [\n      \u003cspan class=\"hljs-title class_\"\u003eChatModule\u003c/span\u003e(),\n    ],\n  );\n\n  \u003cspan class=\"hljs-title class_\"\u003eCCWebSocket\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003econnect\u003c/span\u003e();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e채팅 모듈 정의\u003c/h1\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eChatModule\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eRequestModule\u003c/span\u003e {\n  @override\n  \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erequest\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{required \u003cspan class=\"hljs-built_in\"\u003eMap\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e, dynamic\u003e body}\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003esuper\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erequest\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: body);\n  }\n\n  @override\n  \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eresponse\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003edynamic response\u003c/span\u003e) {\n    \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"새로운 채팅 메시지: $response\"\u003c/span\u003e);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e메시지 보내기\u003c/h1\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esendMessage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e message\u003c/span\u003e) {\n  \u003cspan class=\"hljs-title class_\"\u003eCCWebSocket\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003egetModule\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eChatModule\u003c/span\u003e\u003e().\u003cspan class=\"hljs-title function_\"\u003erequest\u003c/span\u003e(\n    \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: {\n      \u003cspan class=\"hljs-string\"\u003e\"message_type\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"chat\"\u003c/span\u003e,\n      \u003cspan class=\"hljs-string\"\u003e\"content\"\u003c/span\u003e: message,\n    },\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이러한 단계를 따라 CC Web Socket을 사용하여 기본 라이브 채팅 애플리케이션을 만들었습니다. 이 모듈식 접근 방식은 코드를 깔끔하고 관리하기 쉽게 유지하며 새로운 기능 추가를 쉽게 만들어 줍니다.\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003eCC Web Socket은 어떤 플러터 개발자에게도 강력한 도구로, 애플리케이션에 실시간 기능을 추가하고자 하는 사람들에게 이상적입니다. 사용의 편의성, 강력한 기능, 그리고 모듈식 디자인은 플러터에서 WebSocket 관리의 핵심 선택지로 만들어 줍니다.\u003c/p\u003e\n\u003cp\u003e이 가이드가 CC Web Socket을 시작하고 멋진 실시간 애플리케이션을 만들도록 영감을 줄 수 있기를 바랍니다. 궁금한 점이나 의견이 있으면 언제든지 문의하거나 프로젝트에 기여해 주세요. 즐거운 코딩되세요!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-19-BuildingReal-TimeFlutterAppswithCCWebSocket"},"buildId":"ckvP8zvWyPnScUqpsTElP","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>