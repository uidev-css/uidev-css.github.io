<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>State Management in Flutter  외부 라이브러리 종속성 없이 | uidev-css</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://uidev-css.github.io///post/2024-06-19-StateManagementinFlutterNoThirdPartyDependencies" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="State Management in Flutter  외부 라이브러리 종속성 없이 | uidev-css" data-gatsby-head="true"/><meta property="og:title" content="State Management in Flutter  외부 라이브러리 종속성 없이 | uidev-css" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-19-StateManagementinFlutterNoThirdPartyDependencies_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://uidev-css.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://uidev-css.github.io///post/2024-06-19-StateManagementinFlutterNoThirdPartyDependencies" data-gatsby-head="true"/><meta name="twitter:title" content="State Management in Flutter  외부 라이브러리 종속성 없이 | uidev-css" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-19-StateManagementinFlutterNoThirdPartyDependencies_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | uidev-css" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-19 00:11" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b75a4bf98ee956a8.js" defer=""></script><script src="/_next/static/fyfGyRz00q80ZdkogiVCt/_buildManifest.js" defer=""></script><script src="/_next/static/fyfGyRz00q80ZdkogiVCt/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UIDEV CSS</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">State Management in Flutter  외부 라이브러리 종속성 없이</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="State Management in Flutter  외부 라이브러리 종속성 없이" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UIDEV CSS</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 19, 2024</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-19-StateManagementinFlutterNoThirdPartyDependencies&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>저희가 네이티브 안드로이드 앱을 플러터로 이꟮리는 작업을 시작한 이후로, 프로젝트에 관한 많은 어럽한 결정을 내려야 했습니다. 네이티브 앱을 개발할 때 한 실수를 반복하지 않기 위해서였죠.</p>
<p>Flutter 환경에서 제공되는 모든 상태 관리 솔루션을 다뤄보고 어떤 것을 사용할지 결정해야 했습니다. 이 일은 실제로 힘들었습니다. Provider, Riverpod, Bloc, Cubit, MobX, GetX, Redux 등 다양한 옵션들이 있었기 때문이죠. 각각을 이해하는 데 많은 노력이 필요했고, 다양한 솔루션들을 읽고 시도한 뒤에 우리는 내부에서 너무 많은 마술이 일어나고 있다고 더 확신을 얻을 수 있었습니다.</p>
<p>조사를 진행하다가, 서드파티 라이브러리 없이 상태 관리를 하는 방법을 사용하는 많은 앱들이 상점에 있다는 것을 알게되는 기사를 찾았습니다. 좀 더 조사해보니, 플러터에서 상태 관리를 아주 멋지게 구현한 다른 기사도 찾았습니다. 이러한 콘텐츠에서 영감을 받아 우리는 서드파티 라이브러리 없이 솔루션을 찾기 위해 조사를 시작했습니다. 이어서 저희가 어떻게 앱에서 플러터의 네이티브 자원만을 사용하여 상태 관리를 구현했는지 알려드릴게요.</p>
<h2>앱 패턴</h2>
<p>저희는 Flutter 앱의 아키텍처로 MVVM (Model-View-ViewModel) 패턴을 선택했습니다. 네이티브 안드로이드 앱에서 편안하게 사용했던 이 패턴을 Flutter 프로젝트에도 충분히 적용할 수 있다고 확신했기 때문입니다.</p>
<p>MVVM 패턴은 주로 세 가지 클래스로 구성됩니다:</p>
<ul>
<li>Model: 화면에 표시할 데이터를 보유하는 클래스입니다.</li>
<li>View: Flutter에서는 이것이 화면을 나타내는 위젯입니다.</li>
<li>ViewModel: 여기에는 로직이 포함됩니다. 화면(View)과의 모든 상호작용은 ViewModel에서 메소드 호출을 일으켜야 합니다.</li>
</ul>
<h2>MVVM과 플러터 네이티브 리소스 병합하기</h2>
<p>우선적으로, 우리 예제를 구축하는 데 도움이 되는 몇 개의 클래스를 생성해야 합니다. 아래에는 우리 예제를 재현하기 위해 만들어야 하는 클래스들이 나와 있습니다:</p>
<ul>
<li>user_dto.dart: 이 파일에는 DTO(Data Transfer Object)를 나타내는 클래스가 포함됩니다.</li>
</ul>
<pre><code class="hljs language-dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDto</span> </span>{
  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> name;

  UserDto({<span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.name});
}
</code></pre>
<ol start="2">
<li>user_repository.dart: 이 파일은 HTTP 페치 요청을 담당하는 클래스가 위치할 것입니다.</li>
</ol>
<pre><code class="hljs language-dart"><span class="hljs-keyword">import</span> <span class="hljs-string">'package:teste_artigo/user_dto.dart'</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserRepository</span> </span>{
  Future&#x3C;UserDto> getUserData() <span class="hljs-keyword">async</span> {
    <span class="hljs-comment">// 사용자 데이터를 가져오는 시뮬레이션, API 호출일 수도 있습니다. 리포지토리 파일에 위치할 것입니다.</span>
    <span class="hljs-keyword">await</span> Future.delayed(<span class="hljs-keyword">const</span> <span class="hljs-built_in">Duration</span>(seconds: <span class="hljs-number">2</span>), () {});
    <span class="hljs-keyword">return</span> UserDto(name: <span class="hljs-string">'John Doe'</span>);
  }
}
</code></pre>
<p>그런 다음 우리는 MVVM 구조를 마칠 수 있습니다.</p>
<p>ValueNotifier과 ValueListenableBuilder를 사용하여 Model, View 및 ViewModel 간의 연결을 설정했어요.</p>
<p>먼저 home_screen_state.dart 파일을 만들어볼게요. 각 화면에는 로딩 상태, 오류 상태, 성공 상태 등이 있습니다. 이러한 상태를 클래스 유형을 사용하여 구분할 거에요:</p>
<pre><code class="hljs language-js">abstract <span class="hljs-keyword">class</span> <span class="hljs-title class_">HomeScreenState</span> {}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">HomeScreenLoadingState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">HomeScreenState</span> {}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">HomeScreenSuccessfulState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">HomeScreenState</span> {
  final <span class="hljs-title class_">String</span> userName;

  <span class="hljs-title class_">HomeScreenSuccessfulState</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">userName</span>);
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">HomeScreenErrorState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">HomeScreenState</span> {
  final <span class="hljs-title class_">String</span> errorMessage;

  <span class="hljs-title class_">HomeScreenErrorState</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">errorMessage</span>);
}
</code></pre>
<p>우리는 원하는 만큼 많은 상태를 가질 수 있으며 각 상태는 필요한 변수를 가질 수 있어요. 심지어 abstract HomeScreenState 클래스 내에 공통 변수를 가질 수도 있어요.</p>
<p>다음으로, ViewModel 클래스를 생성해야 합니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter/cupertino.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:teste_artigo/home_screen_state.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:teste_artigo/user_repository.dart'</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">HomeScreenViewModel</span> {
  <span class="hljs-keyword">var</span> state = <span class="hljs-title class_">ValueNotifier</span>&#x3C;<span class="hljs-title class_">HomeScreenState</span>>(<span class="hljs-title class_">HomeScreenLoadingState</span>());
  final userRepository = <span class="hljs-title class_">UserRepository</span>();

  <span class="hljs-title class_">Future</span>&#x3C;<span class="hljs-keyword">void</span>> <span class="hljs-title function_">onInit</span>() <span class="hljs-keyword">async</span> {
    <span class="hljs-title function_">_tryToFetchUserData</span>();
  }

  <span class="hljs-title class_">Future</span>&#x3C;<span class="hljs-keyword">void</span>> <span class="hljs-title function_">onRefreshUserData</span>() <span class="hljs-keyword">async</span> {
    <span class="hljs-title function_">_tryToFetchUserData</span>();
  }

  <span class="hljs-title class_">Future</span>&#x3C;<span class="hljs-keyword">void</span>> <span class="hljs-title function_">_tryToFetchUserData</span>() <span class="hljs-keyword">async</span> {
    <span class="hljs-keyword">try</span> {
      state.<span class="hljs-property">value</span> = <span class="hljs-title class_">HomeScreenLoadingState</span>();
      final response = <span class="hljs-keyword">await</span> userRepository.<span class="hljs-title function_">getUserData</span>();
      state.<span class="hljs-property">value</span> = <span class="hljs-title class_">HomeScreenSuccessfulState</span>(response.<span class="hljs-property">name</span>);
    } <span class="hljs-keyword">catch</span> (e) {
      state.<span class="hljs-property">value</span> = <span class="hljs-title class_">HomeScreenErrorState</span>(<span class="hljs-string">'An error occurred'</span>);
    }
  }
}
</code></pre>
<p>이 클래스에서 우리는 공개 메서드 이름이 UI 클래스에 대한 콜백을 나타내는 것을 확인할 수 있습니다. 메서드 이름에서 사용자 데이터를 가져올 것이라는 것을 명시적으로 명시하지 않습니다.
대신, UI가 초기화되거나 사용자 데이터를 새로 고침하길 요청할 때 특정 메서드가 호출되어야 함을 간단히 나타냅니다. 로직은 UI에서 숨어 있는 비공개 메서드인 <code>_tryToFetchUserData</code> 메서드 내부에 있습니다.</p>
<p>또한, 데이터를 업데이트해야 할 때 적절한 상태 유형 및 매개변수와 함께 state 변수의 값을 업데이트해야 함을 알 수 있습니다.
이 변수는 스트림입니다. 이미 변경되면 청취자에게 알리는 책임을 지고 있습니다.</p>
<p>마지막으로 UI가 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter/material.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:teste_artigo/home_screen_view_model.dart'</span>;

<span class="hljs-keyword">import</span> <span class="hljs-string">'home_screen_state.dart'</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">HomeScreen</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">StatefulWidget</span> {
  <span class="hljs-keyword">const</span> <span class="hljs-title class_">HomeScreen</span>({key});

  @override
  <span class="hljs-title class_">State</span>&#x3C;<span class="hljs-title class_">HomeScreen</span>> <span class="hljs-title function_">createState</span>() => <span class="hljs-title function_">_MyHomePageState</span>();
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">_MyHomePageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">State</span>&#x3C;<span class="hljs-title class_">HomeScreen</span>> {
  late final <span class="hljs-title class_">HomeScreenViewModel</span> _vm;

  @override
  <span class="hljs-keyword">void</span> <span class="hljs-title function_">initState</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">initState</span>();
    _vm = <span class="hljs-title class_">HomeScreenViewModel</span>();
    _vm.<span class="hljs-title function_">onInit</span>();
  }

  @override
  <span class="hljs-title class_">Widget</span> <span class="hljs-title function_">build</span>(<span class="hljs-params">BuildContext context</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Scaffold</span>(
      <span class="hljs-attr">appBar</span>: <span class="hljs-title class_">AppBar</span>(
        <span class="hljs-attr">backgroundColor</span>: <span class="hljs-title class_">Theme</span>.<span class="hljs-title function_">of</span>(context).<span class="hljs-property">colorScheme</span>.<span class="hljs-property">inversePrimary</span>,
        <span class="hljs-attr">title</span>: <span class="hljs-keyword">const</span> <span class="hljs-title class_">Text</span>(<span class="hljs-string">'상태 관리'</span>),
      ),
      <span class="hljs-attr">floatingActionButton</span>: <span class="hljs-title function_">_buildFloatingActionButton</span>(),
      <span class="hljs-attr">body</span>: <span class="hljs-title function_">_buildBody</span>(),
    );
  }

  <span class="hljs-title class_">Widget</span> <span class="hljs-title function_">_buildFloatingActionButton</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">FloatingActionButton</span>(
      <span class="hljs-attr">onPressed</span>: <span class="hljs-function">() =></span> _vm.<span class="hljs-title function_">onRefreshUserData</span>(),
      <span class="hljs-attr">tooltip</span>: <span class="hljs-string">'새로 고침'</span>,
      <span class="hljs-attr">child</span>: <span class="hljs-keyword">const</span> <span class="hljs-title class_">Icon</span>(<span class="hljs-title class_">Icons</span>.<span class="hljs-property">refresh</span>),
    );
  }

  <span class="hljs-title class_">Widget</span> <span class="hljs-title function_">_buildBody</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Column</span>(
      <span class="hljs-attr">mainAxisAlignment</span>: <span class="hljs-title class_">MainAxisAlignment</span>.<span class="hljs-property">center</span>,
      <span class="hljs-attr">children</span>: [
        <span class="hljs-title class_">ValueListenableBuilder</span>(
          <span class="hljs-attr">valueListenable</span>: _vm.<span class="hljs-property">state</span>,
          <span class="hljs-attr">builder</span>: (context, state, _) {
            <span class="hljs-keyword">switch</span> (state.<span class="hljs-property">runtimeType</span>) {
              <span class="hljs-keyword">case</span> <span class="hljs-title class_">HomeScreenLoadingState</span>:
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Center</span>(<span class="hljs-attr">child</span>: <span class="hljs-title class_">CircularProgressIndicator</span>());
              <span class="hljs-keyword">case</span> <span class="hljs-title class_">HomeScreenSuccessfulState</span>:
                final successfulState = state <span class="hljs-keyword">as</span> <span class="hljs-title class_">HomeScreenSuccessfulState</span>;
                <span class="hljs-keyword">return</span> <span class="hljs-title class_">Center</span>(<span class="hljs-attr">child</span>: <span class="hljs-title class_">Text</span>(successfulState.<span class="hljs-property">userName</span>));
              <span class="hljs-keyword">case</span> <span class="hljs-title class_">HomeScreenErrorState</span>:
                final errorState = state <span class="hljs-keyword">as</span> <span class="hljs-title class_">HomeScreenErrorState</span>;
                <span class="hljs-keyword">return</span> <span class="hljs-title class_">Center</span>(<span class="hljs-attr">child</span>: <span class="hljs-title class_">Text</span>(errorState.<span class="hljs-property">errorMessage</span>));
              <span class="hljs-attr">default</span>:
                <span class="hljs-keyword">return</span> <span class="hljs-title class_">Container</span>();
            }
          },
        )
      ],
    );
  }
}
</code></pre>
<p>ValueListenableBuilder 내에서 "마법"이 일어납니다: 상태의 유형에 따라 특정 위젯을 렌더링하여 표시합니다.</p>
<p>빌더 함수는 ViewModel에서 상태 변수가 변경될 때마다 호출되므로 setState를 호출하거나 다른 작업을 걱정할 필요가 없습니다. 코드의 더 깊은 부분에서 ValueListenableBuilder를 사용하여 전체 화면을 다시 렌더링하는 것을 피할 수도 있습니다. 그러나 중요한 점은 그것이 필요하지 않다는 것입니다: Flutter는 이미 전체 화면을 렌더링하도록 최적화되어 있으며, setState를 사용하여 화면을 업데이트하도록 만들어졌기 때문에 기존에 렌더링 된 것을 다시 렌더링하는 방법을 알고 있습니다.</p>
<h2>결론</h2>
<p>이게 다에요!  별도의 외부 의존성이 없어 매우 간단해요.</p>
<p>이것은 아주 간단한 예시라는 것을 이해합니다. 더 복잡한 화면을 만들기 시작하면 더 많은 질문이 생겨나고, 이렇게 간단한 해결책을 유지하는 것이 더 어려워질 수도 있습니다. 그러나 저희는 이 방법을 성공적으로 사용하여 매우 복잡한 화면을 만들고 있습니다 (실제로 회사의 주요 제품인 전체 앱을 Flutter로 이주 중이기도 합니다), 그리고 이 방법이 저희에게 아주 잘 작동하고 있어요.</p>
<p>의문이 있거나 의견을 주고 싶다면, 언제든지 LinkedIn에서 제게 직접 메시지를 남겨주세요. 언제든지 대화를 나누기 위해 친절히 준비되어 있을게요.</p>
<p>이 예제의 코드는 이 저장소에서 찾을 수 있어요.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"State Management in Flutter  외부 라이브러리 종속성 없이","description":"","date":"2024-06-19 00:11","slug":"2024-06-19-StateManagementinFlutterNoThirdPartyDependencies","content":"\n\n\n\u003cimg src=\"/assets/img/2024-06-19-StateManagementinFlutterNoThirdPartyDependencies_0.png\" /\u003e\n\n저희가 네이티브 안드로이드 앱을 플러터로 이꟮리는 작업을 시작한 이후로, 프로젝트에 관한 많은 어럽한 결정을 내려야 했습니다. 네이티브 앱을 개발할 때 한 실수를 반복하지 않기 위해서였죠.\n\nFlutter 환경에서 제공되는 모든 상태 관리 솔루션을 다뤄보고 어떤 것을 사용할지 결정해야 했습니다. 이 일은 실제로 힘들었습니다. Provider, Riverpod, Bloc, Cubit, MobX, GetX, Redux 등 다양한 옵션들이 있었기 때문이죠. 각각을 이해하는 데 많은 노력이 필요했고, 다양한 솔루션들을 읽고 시도한 뒤에 우리는 내부에서 너무 많은 마술이 일어나고 있다고 더 확신을 얻을 수 있었습니다.\n\n조사를 진행하다가, 서드파티 라이브러리 없이 상태 관리를 하는 방법을 사용하는 많은 앱들이 상점에 있다는 것을 알게되는 기사를 찾았습니다. 좀 더 조사해보니, 플러터에서 상태 관리를 아주 멋지게 구현한 다른 기사도 찾았습니다. 이러한 콘텐츠에서 영감을 받아 우리는 서드파티 라이브러리 없이 솔루션을 찾기 위해 조사를 시작했습니다. 이어서 저희가 어떻게 앱에서 플러터의 네이티브 자원만을 사용하여 상태 관리를 구현했는지 알려드릴게요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 앱 패턴\n\n저희는 Flutter 앱의 아키텍처로 MVVM (Model-View-ViewModel) 패턴을 선택했습니다. 네이티브 안드로이드 앱에서 편안하게 사용했던 이 패턴을 Flutter 프로젝트에도 충분히 적용할 수 있다고 확신했기 때문입니다.\n\nMVVM 패턴은 주로 세 가지 클래스로 구성됩니다:\n\n- Model: 화면에 표시할 데이터를 보유하는 클래스입니다.\n- View: Flutter에서는 이것이 화면을 나타내는 위젯입니다.\n- ViewModel: 여기에는 로직이 포함됩니다. 화면(View)과의 모든 상호작용은 ViewModel에서 메소드 호출을 일으켜야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-StateManagementinFlutterNoThirdPartyDependencies_1.png\" /\u003e\n\n## MVVM과 플러터 네이티브 리소스 병합하기\n\n우선적으로, 우리 예제를 구축하는 데 도움이 되는 몇 개의 클래스를 생성해야 합니다. 아래에는 우리 예제를 재현하기 위해 만들어야 하는 클래스들이 나와 있습니다:\n\n- user_dto.dart: 이 파일에는 DTO(Data Transfer Object)를 나타내는 클래스가 포함됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\nclass UserDto {\n  final String name;\n\n  UserDto({required this.name});\n}\n```\n\n2. user_repository.dart: 이 파일은 HTTP 페치 요청을 담당하는 클래스가 위치할 것입니다.\n\n```dart\nimport 'package:teste_artigo/user_dto.dart';\n\nclass UserRepository {\n  Future\u003cUserDto\u003e getUserData() async {\n    // 사용자 데이터를 가져오는 시뮬레이션, API 호출일 수도 있습니다. 리포지토리 파일에 위치할 것입니다.\n    await Future.delayed(const Duration(seconds: 2), () {});\n    return UserDto(name: 'John Doe');\n  }\n}\n```\n\n그런 다음 우리는 MVVM 구조를 마칠 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nValueNotifier과 ValueListenableBuilder를 사용하여 Model, View 및 ViewModel 간의 연결을 설정했어요.\n\n먼저 home_screen_state.dart 파일을 만들어볼게요. 각 화면에는 로딩 상태, 오류 상태, 성공 상태 등이 있습니다. 이러한 상태를 클래스 유형을 사용하여 구분할 거에요:\n\n```js\nabstract class HomeScreenState {}\n\nclass HomeScreenLoadingState extends HomeScreenState {}\n\nclass HomeScreenSuccessfulState extends HomeScreenState {\n  final String userName;\n\n  HomeScreenSuccessfulState(this.userName);\n}\n\nclass HomeScreenErrorState extends HomeScreenState {\n  final String errorMessage;\n\n  HomeScreenErrorState(this.errorMessage);\n}\n```\n\n우리는 원하는 만큼 많은 상태를 가질 수 있으며 각 상태는 필요한 변수를 가질 수 있어요. 심지어 abstract HomeScreenState 클래스 내에 공통 변수를 가질 수도 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음으로, ViewModel 클래스를 생성해야 합니다:\n\n```js\nimport 'package:flutter/cupertino.dart';\nimport 'package:teste_artigo/home_screen_state.dart';\nimport 'package:teste_artigo/user_repository.dart';\n\nclass HomeScreenViewModel {\n  var state = ValueNotifier\u003cHomeScreenState\u003e(HomeScreenLoadingState());\n  final userRepository = UserRepository();\n\n  Future\u003cvoid\u003e onInit() async {\n    _tryToFetchUserData();\n  }\n\n  Future\u003cvoid\u003e onRefreshUserData() async {\n    _tryToFetchUserData();\n  }\n\n  Future\u003cvoid\u003e _tryToFetchUserData() async {\n    try {\n      state.value = HomeScreenLoadingState();\n      final response = await userRepository.getUserData();\n      state.value = HomeScreenSuccessfulState(response.name);\n    } catch (e) {\n      state.value = HomeScreenErrorState('An error occurred');\n    }\n  }\n}\n```\n\n이 클래스에서 우리는 공개 메서드 이름이 UI 클래스에 대한 콜백을 나타내는 것을 확인할 수 있습니다. 메서드 이름에서 사용자 데이터를 가져올 것이라는 것을 명시적으로 명시하지 않습니다.\n대신, UI가 초기화되거나 사용자 데이터를 새로 고침하길 요청할 때 특정 메서드가 호출되어야 함을 간단히 나타냅니다. 로직은 UI에서 숨어 있는 비공개 메서드인 `_tryToFetchUserData` 메서드 내부에 있습니다.\n\n또한, 데이터를 업데이트해야 할 때 적절한 상태 유형 및 매개변수와 함께 state 변수의 값을 업데이트해야 함을 알 수 있습니다.\n이 변수는 스트림입니다. 이미 변경되면 청취자에게 알리는 책임을 지고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마지막으로 UI가 있습니다:\n\n```js\nimport 'package:flutter/material.dart';\nimport 'package:teste_artigo/home_screen_view_model.dart';\n\nimport 'home_screen_state.dart';\n\nclass HomeScreen extends StatefulWidget {\n  const HomeScreen({key});\n\n  @override\n  State\u003cHomeScreen\u003e createState() =\u003e _MyHomePageState();\n}\n\nclass _MyHomePageState extends State\u003cHomeScreen\u003e {\n  late final HomeScreenViewModel _vm;\n\n  @override\n  void initState() {\n    super.initState();\n    _vm = HomeScreenViewModel();\n    _vm.onInit();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        backgroundColor: Theme.of(context).colorScheme.inversePrimary,\n        title: const Text('상태 관리'),\n      ),\n      floatingActionButton: _buildFloatingActionButton(),\n      body: _buildBody(),\n    );\n  }\n\n  Widget _buildFloatingActionButton() {\n    return FloatingActionButton(\n      onPressed: () =\u003e _vm.onRefreshUserData(),\n      tooltip: '새로 고침',\n      child: const Icon(Icons.refresh),\n    );\n  }\n\n  Widget _buildBody() {\n    return Column(\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: [\n        ValueListenableBuilder(\n          valueListenable: _vm.state,\n          builder: (context, state, _) {\n            switch (state.runtimeType) {\n              case HomeScreenLoadingState:\n                return const Center(child: CircularProgressIndicator());\n              case HomeScreenSuccessfulState:\n                final successfulState = state as HomeScreenSuccessfulState;\n                return Center(child: Text(successfulState.userName));\n              case HomeScreenErrorState:\n                final errorState = state as HomeScreenErrorState;\n                return Center(child: Text(errorState.errorMessage));\n              default:\n                return Container();\n            }\n          },\n        )\n      ],\n    );\n  }\n}\n```\n\nValueListenableBuilder 내에서 \"마법\"이 일어납니다: 상태의 유형에 따라 특정 위젯을 렌더링하여 표시합니다.\n\n빌더 함수는 ViewModel에서 상태 변수가 변경될 때마다 호출되므로 setState를 호출하거나 다른 작업을 걱정할 필요가 없습니다. 코드의 더 깊은 부분에서 ValueListenableBuilder를 사용하여 전체 화면을 다시 렌더링하는 것을 피할 수도 있습니다. 그러나 중요한 점은 그것이 필요하지 않다는 것입니다: Flutter는 이미 전체 화면을 렌더링하도록 최적화되어 있으며, setState를 사용하여 화면을 업데이트하도록 만들어졌기 때문에 기존에 렌더링 된 것을 다시 렌더링하는 방법을 알고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 결론\n\n이게 다에요!  별도의 외부 의존성이 없어 매우 간단해요.\n\n이것은 아주 간단한 예시라는 것을 이해합니다. 더 복잡한 화면을 만들기 시작하면 더 많은 질문이 생겨나고, 이렇게 간단한 해결책을 유지하는 것이 더 어려워질 수도 있습니다. 그러나 저희는 이 방법을 성공적으로 사용하여 매우 복잡한 화면을 만들고 있습니다 (실제로 회사의 주요 제품인 전체 앱을 Flutter로 이주 중이기도 합니다), 그리고 이 방법이 저희에게 아주 잘 작동하고 있어요.\n\n의문이 있거나 의견을 주고 싶다면, 언제든지 LinkedIn에서 제게 직접 메시지를 남겨주세요. 언제든지 대화를 나누기 위해 친절히 준비되어 있을게요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예제의 코드는 이 저장소에서 찾을 수 있어요.","ogImage":{"url":"/assets/img/2024-06-19-StateManagementinFlutterNoThirdPartyDependencies_0.png"},"coverImage":"/assets/img/2024-06-19-StateManagementinFlutterNoThirdPartyDependencies_0.png","tag":["Tech"],"readingTime":7},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e저희가 네이티브 안드로이드 앱을 플러터로 이꟮리는 작업을 시작한 이후로, 프로젝트에 관한 많은 어럽한 결정을 내려야 했습니다. 네이티브 앱을 개발할 때 한 실수를 반복하지 않기 위해서였죠.\u003c/p\u003e\n\u003cp\u003eFlutter 환경에서 제공되는 모든 상태 관리 솔루션을 다뤄보고 어떤 것을 사용할지 결정해야 했습니다. 이 일은 실제로 힘들었습니다. Provider, Riverpod, Bloc, Cubit, MobX, GetX, Redux 등 다양한 옵션들이 있었기 때문이죠. 각각을 이해하는 데 많은 노력이 필요했고, 다양한 솔루션들을 읽고 시도한 뒤에 우리는 내부에서 너무 많은 마술이 일어나고 있다고 더 확신을 얻을 수 있었습니다.\u003c/p\u003e\n\u003cp\u003e조사를 진행하다가, 서드파티 라이브러리 없이 상태 관리를 하는 방법을 사용하는 많은 앱들이 상점에 있다는 것을 알게되는 기사를 찾았습니다. 좀 더 조사해보니, 플러터에서 상태 관리를 아주 멋지게 구현한 다른 기사도 찾았습니다. 이러한 콘텐츠에서 영감을 받아 우리는 서드파티 라이브러리 없이 솔루션을 찾기 위해 조사를 시작했습니다. 이어서 저희가 어떻게 앱에서 플러터의 네이티브 자원만을 사용하여 상태 관리를 구현했는지 알려드릴게요.\u003c/p\u003e\n\u003ch2\u003e앱 패턴\u003c/h2\u003e\n\u003cp\u003e저희는 Flutter 앱의 아키텍처로 MVVM (Model-View-ViewModel) 패턴을 선택했습니다. 네이티브 안드로이드 앱에서 편안하게 사용했던 이 패턴을 Flutter 프로젝트에도 충분히 적용할 수 있다고 확신했기 때문입니다.\u003c/p\u003e\n\u003cp\u003eMVVM 패턴은 주로 세 가지 클래스로 구성됩니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eModel: 화면에 표시할 데이터를 보유하는 클래스입니다.\u003c/li\u003e\n\u003cli\u003eView: Flutter에서는 이것이 화면을 나타내는 위젯입니다.\u003c/li\u003e\n\u003cli\u003eViewModel: 여기에는 로직이 포함됩니다. 화면(View)과의 모든 상호작용은 ViewModel에서 메소드 호출을 일으켜야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eMVVM과 플러터 네이티브 리소스 병합하기\u003c/h2\u003e\n\u003cp\u003e우선적으로, 우리 예제를 구축하는 데 도움이 되는 몇 개의 클래스를 생성해야 합니다. 아래에는 우리 예제를 재현하기 위해 만들어야 하는 클래스들이 나와 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003euser_dto.dart: 이 파일에는 DTO(Data Transfer Object)를 나타내는 클래스가 포함됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-dart\"\u003e\u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eUserDto\u003c/span\u003e \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003efinal\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e name;\n\n  UserDto({\u003cspan class=\"hljs-keyword\"\u003erequired\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.name});\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003euser_repository.dart: 이 파일은 HTTP 페치 요청을 담당하는 클래스가 위치할 것입니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-dart\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:teste_artigo/user_dto.dart'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eUserRepository\u003c/span\u003e \u003c/span\u003e{\n  Future\u0026#x3C;UserDto\u003e getUserData() \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// 사용자 데이터를 가져오는 시뮬레이션, API 호출일 수도 있습니다. 리포지토리 파일에 위치할 것입니다.\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e Future.delayed(\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eDuration\u003c/span\u003e(seconds: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e), () {});\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e UserDto(name: \u003cspan class=\"hljs-string\"\u003e'John Doe'\u003c/span\u003e);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그런 다음 우리는 MVVM 구조를 마칠 수 있습니다.\u003c/p\u003e\n\u003cp\u003eValueNotifier과 ValueListenableBuilder를 사용하여 Model, View 및 ViewModel 간의 연결을 설정했어요.\u003c/p\u003e\n\u003cp\u003e먼저 home_screen_state.dart 파일을 만들어볼게요. 각 화면에는 로딩 상태, 오류 상태, 성공 상태 등이 있습니다. 이러한 상태를 클래스 유형을 사용하여 구분할 거에요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eabstract \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHomeScreenState\u003c/span\u003e {}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHomeScreenLoadingState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eHomeScreenState\u003c/span\u003e {}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHomeScreenSuccessfulState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eHomeScreenState\u003c/span\u003e {\n  final \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e userName;\n\n  \u003cspan class=\"hljs-title class_\"\u003eHomeScreenSuccessfulState\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003euserName\u003c/span\u003e);\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHomeScreenErrorState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eHomeScreenState\u003c/span\u003e {\n  final \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e errorMessage;\n\n  \u003cspan class=\"hljs-title class_\"\u003eHomeScreenErrorState\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eerrorMessage\u003c/span\u003e);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e우리는 원하는 만큼 많은 상태를 가질 수 있으며 각 상태는 필요한 변수를 가질 수 있어요. 심지어 abstract HomeScreenState 클래스 내에 공통 변수를 가질 수도 있어요.\u003c/p\u003e\n\u003cp\u003e다음으로, ViewModel 클래스를 생성해야 합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:flutter/cupertino.dart'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:teste_artigo/home_screen_state.dart'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:teste_artigo/user_repository.dart'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHomeScreenViewModel\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e state = \u003cspan class=\"hljs-title class_\"\u003eValueNotifier\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eHomeScreenState\u003c/span\u003e\u003e(\u003cspan class=\"hljs-title class_\"\u003eHomeScreenLoadingState\u003c/span\u003e());\n  final userRepository = \u003cspan class=\"hljs-title class_\"\u003eUserRepository\u003c/span\u003e();\n\n  \u003cspan class=\"hljs-title class_\"\u003eFuture\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e\u003e \u003cspan class=\"hljs-title function_\"\u003eonInit\u003c/span\u003e() \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n    \u003cspan class=\"hljs-title function_\"\u003e_tryToFetchUserData\u003c/span\u003e();\n  }\n\n  \u003cspan class=\"hljs-title class_\"\u003eFuture\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e\u003e \u003cspan class=\"hljs-title function_\"\u003eonRefreshUserData\u003c/span\u003e() \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n    \u003cspan class=\"hljs-title function_\"\u003e_tryToFetchUserData\u003c/span\u003e();\n  }\n\n  \u003cspan class=\"hljs-title class_\"\u003eFuture\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e\u003e \u003cspan class=\"hljs-title function_\"\u003e_tryToFetchUserData\u003c/span\u003e() \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n      state.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eHomeScreenLoadingState\u003c/span\u003e();\n      final response = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e userRepository.\u003cspan class=\"hljs-title function_\"\u003egetUserData\u003c/span\u003e();\n      state.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eHomeScreenSuccessfulState\u003c/span\u003e(response.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e);\n    } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (e) {\n      state.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eHomeScreenErrorState\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'An error occurred'\u003c/span\u003e);\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 클래스에서 우리는 공개 메서드 이름이 UI 클래스에 대한 콜백을 나타내는 것을 확인할 수 있습니다. 메서드 이름에서 사용자 데이터를 가져올 것이라는 것을 명시적으로 명시하지 않습니다.\n대신, UI가 초기화되거나 사용자 데이터를 새로 고침하길 요청할 때 특정 메서드가 호출되어야 함을 간단히 나타냅니다. 로직은 UI에서 숨어 있는 비공개 메서드인 \u003ccode\u003e_tryToFetchUserData\u003c/code\u003e 메서드 내부에 있습니다.\u003c/p\u003e\n\u003cp\u003e또한, 데이터를 업데이트해야 할 때 적절한 상태 유형 및 매개변수와 함께 state 변수의 값을 업데이트해야 함을 알 수 있습니다.\n이 변수는 스트림입니다. 이미 변경되면 청취자에게 알리는 책임을 지고 있습니다.\u003c/p\u003e\n\u003cp\u003e마지막으로 UI가 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:flutter/material.dart'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:teste_artigo/home_screen_view_model.dart'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'home_screen_state.dart'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHomeScreen\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eStatefulWidget\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHomeScreen\u003c/span\u003e({key});\n\n  @override\n  \u003cspan class=\"hljs-title class_\"\u003eState\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eHomeScreen\u003c/span\u003e\u003e \u003cspan class=\"hljs-title function_\"\u003ecreateState\u003c/span\u003e() =\u003e \u003cspan class=\"hljs-title function_\"\u003e_MyHomePageState\u003c/span\u003e();\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003e_MyHomePageState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eState\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eHomeScreen\u003c/span\u003e\u003e {\n  late final \u003cspan class=\"hljs-title class_\"\u003eHomeScreenViewModel\u003c/span\u003e _vm;\n\n  @override\n  \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003einitState\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003esuper\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003einitState\u003c/span\u003e();\n    _vm = \u003cspan class=\"hljs-title class_\"\u003eHomeScreenViewModel\u003c/span\u003e();\n    _vm.\u003cspan class=\"hljs-title function_\"\u003eonInit\u003c/span\u003e();\n  }\n\n  @override\n  \u003cspan class=\"hljs-title class_\"\u003eWidget\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebuild\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eBuildContext context\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eScaffold\u003c/span\u003e(\n      \u003cspan class=\"hljs-attr\"\u003eappBar\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eAppBar\u003c/span\u003e(\n        \u003cspan class=\"hljs-attr\"\u003ebackgroundColor\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eTheme\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eof\u003c/span\u003e(context).\u003cspan class=\"hljs-property\"\u003ecolorScheme\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003einversePrimary\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'상태 관리'\u003c/span\u003e),\n      ),\n      \u003cspan class=\"hljs-attr\"\u003efloatingActionButton\u003c/span\u003e: \u003cspan class=\"hljs-title function_\"\u003e_buildFloatingActionButton\u003c/span\u003e(),\n      \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: \u003cspan class=\"hljs-title function_\"\u003e_buildBody\u003c/span\u003e(),\n    );\n  }\n\n  \u003cspan class=\"hljs-title class_\"\u003eWidget\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e_buildFloatingActionButton\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFloatingActionButton\u003c/span\u003e(\n      \u003cspan class=\"hljs-attr\"\u003eonPressed\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e _vm.\u003cspan class=\"hljs-title function_\"\u003eonRefreshUserData\u003c/span\u003e(),\n      \u003cspan class=\"hljs-attr\"\u003etooltip\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'새로 고침'\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eIcon\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eIcons\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003erefresh\u003c/span\u003e),\n    );\n  }\n\n  \u003cspan class=\"hljs-title class_\"\u003eWidget\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e_buildBody\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eColumn\u003c/span\u003e(\n      \u003cspan class=\"hljs-attr\"\u003emainAxisAlignment\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eMainAxisAlignment\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecenter\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003echildren\u003c/span\u003e: [\n        \u003cspan class=\"hljs-title class_\"\u003eValueListenableBuilder\u003c/span\u003e(\n          \u003cspan class=\"hljs-attr\"\u003evalueListenable\u003c/span\u003e: _vm.\u003cspan class=\"hljs-property\"\u003estate\u003c/span\u003e,\n          \u003cspan class=\"hljs-attr\"\u003ebuilder\u003c/span\u003e: (context, state, _) {\n            \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e (state.\u003cspan class=\"hljs-property\"\u003eruntimeType\u003c/span\u003e) {\n              \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHomeScreenLoadingState\u003c/span\u003e:\n                \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCenter\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCircularProgressIndicator\u003c/span\u003e());\n              \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHomeScreenSuccessfulState\u003c/span\u003e:\n                final successfulState = state \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHomeScreenSuccessfulState\u003c/span\u003e;\n                \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCenter\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(successfulState.\u003cspan class=\"hljs-property\"\u003euserName\u003c/span\u003e));\n              \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHomeScreenErrorState\u003c/span\u003e:\n                final errorState = state \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHomeScreenErrorState\u003c/span\u003e;\n                \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCenter\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(errorState.\u003cspan class=\"hljs-property\"\u003eerrorMessage\u003c/span\u003e));\n              \u003cspan class=\"hljs-attr\"\u003edefault\u003c/span\u003e:\n                \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eContainer\u003c/span\u003e();\n            }\n          },\n        )\n      ],\n    );\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eValueListenableBuilder 내에서 \"마법\"이 일어납니다: 상태의 유형에 따라 특정 위젯을 렌더링하여 표시합니다.\u003c/p\u003e\n\u003cp\u003e빌더 함수는 ViewModel에서 상태 변수가 변경될 때마다 호출되므로 setState를 호출하거나 다른 작업을 걱정할 필요가 없습니다. 코드의 더 깊은 부분에서 ValueListenableBuilder를 사용하여 전체 화면을 다시 렌더링하는 것을 피할 수도 있습니다. 그러나 중요한 점은 그것이 필요하지 않다는 것입니다: Flutter는 이미 전체 화면을 렌더링하도록 최적화되어 있으며, setState를 사용하여 화면을 업데이트하도록 만들어졌기 때문에 기존에 렌더링 된 것을 다시 렌더링하는 방법을 알고 있습니다.\u003c/p\u003e\n\u003ch2\u003e결론\u003c/h2\u003e\n\u003cp\u003e이게 다에요!  별도의 외부 의존성이 없어 매우 간단해요.\u003c/p\u003e\n\u003cp\u003e이것은 아주 간단한 예시라는 것을 이해합니다. 더 복잡한 화면을 만들기 시작하면 더 많은 질문이 생겨나고, 이렇게 간단한 해결책을 유지하는 것이 더 어려워질 수도 있습니다. 그러나 저희는 이 방법을 성공적으로 사용하여 매우 복잡한 화면을 만들고 있습니다 (실제로 회사의 주요 제품인 전체 앱을 Flutter로 이주 중이기도 합니다), 그리고 이 방법이 저희에게 아주 잘 작동하고 있어요.\u003c/p\u003e\n\u003cp\u003e의문이 있거나 의견을 주고 싶다면, 언제든지 LinkedIn에서 제게 직접 메시지를 남겨주세요. 언제든지 대화를 나누기 위해 친절히 준비되어 있을게요.\u003c/p\u003e\n\u003cp\u003e이 예제의 코드는 이 저장소에서 찾을 수 있어요.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-19-StateManagementinFlutterNoThirdPartyDependencies"},"buildId":"fyfGyRz00q80ZdkogiVCt","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>