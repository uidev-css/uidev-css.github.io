<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Flapjax Plotly와 Flask로 웹에서 데이터 시각화 하는 방법 | uidev-css</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://uidev-css.github.io///post/2024-06-23-FlapjaxDataVisualizationontheWebwithPlotlyandFlask" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Flapjax Plotly와 Flask로 웹에서 데이터 시각화 하는 방법 | uidev-css" data-gatsby-head="true"/><meta property="og:title" content="Flapjax Plotly와 Flask로 웹에서 데이터 시각화 하는 방법 | uidev-css" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-23-FlapjaxDataVisualizationontheWebwithPlotlyandFlask_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://uidev-css.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://uidev-css.github.io///post/2024-06-23-FlapjaxDataVisualizationontheWebwithPlotlyandFlask" data-gatsby-head="true"/><meta name="twitter:title" content="Flapjax Plotly와 Flask로 웹에서 데이터 시각화 하는 방법 | uidev-css" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-23-FlapjaxDataVisualizationontheWebwithPlotlyandFlask_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | uidev-css" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-23 15:05" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b4eed7811784bdd3.js" defer=""></script><script src="/_next/static/ckvP8zvWyPnScUqpsTElP/_buildManifest.js" defer=""></script><script src="/_next/static/ckvP8zvWyPnScUqpsTElP/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UIDEV CSS</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Flapjax Plotly와 Flask로 웹에서 데이터 시각화 하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Flapjax Plotly와 Flask로 웹에서 데이터 시각화 하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UIDEV CSS</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 23, 2024</span><span class="posts_reading_time__f7YPP">17<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-23-FlapjaxDataVisualizationontheWebwithPlotlyandFlask&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>데이터 시각화 앱을 구축하는 가장 좋은 프레임워크는 무엇인가요? Streamlit이나 Dash일까요? 아니면 Jupyter Notebook을 Mercury나 Voilá로 변환하여 바로 웹 앱을 만드는 것일까요?</p>
<p>이 모든 것들은 애플리케이션을 만드는 좋은 방법이며 시작하기 쉽습니다. 하지만 시작하기 쉬운 것이 결국 더 모험적인 영역으로 발전할 수 있습니다. 그래서 저는 다시 기초로 돌아가 Python 서버 코드와 HTML 페이지를 함께 사용하는 것이 생각보다 어려운 일이 아니라고 설득하려고 합니다.</p>
<p>우리는 상당량의 보일러플레이트 코드와 템플릿을 활용하여 매력적인 대화형 애플리케이션을 만들 수 있습니다. 이는 여전히 Python 코드에 집중할 수 있게 해주며 HTML 및 JavaScript에 공부할 부담이 적다는 것을 의미합니다. 저는 이 접근 방식을 Flapjax라고 부릅니다 — 나중에 왜 이렇게 부르는지 설명하겠습니다.</p>
<p>Python으로 웹 애플리케이션을 만드는 가장 간단한 방법 중 하나는 Flask를 사용하는 것이므로, 이를 사용하여 아래 이미지와 같은 앱을 만들어보겠습니다.</p>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-06-23-FlapjaxDataVisualizationontheWebwithPlotlyandFlask_0.png" alt="Flask Framework"></p>
<h2>플라스크 프레임워크</h2>
<p>Flask는 웹 애플리케이션을 개발하기 위한 최소주의 프레임워크입니다. Flask 앱에서는 웹 페이지가 일반적으로 템플릿과 파이썬 코드에서 제공된 데이터로 구성됩니다. 이 데이터는 웹 페이지의 내용을 형성하는 텍스트나 그래픽일 수 있습니다. 결과물은 사용자에게 브라우저에서 표시되도록 전송됩니다.</p>
<p>아래 다이어그램은 인터랙티브 앱의 기본 구조를 보여줍니다. 앱이 실행 중일 때, Python 부분은 서버에서 실행되고 브라우저에서 실행되는 HTML로 데이터를 전송합니다. 웹 페이지에서 사용자 입력이 다시 Python 코드로 전달되며, 이후 Python 코드는 더 많은 데이터를 전송하여 사용자가 선택한 새로운 콘텐츠 - 사용자가 선택한 새로운 차트와 같은 - 로 HTML을 업데이트할 수 있습니다.</p>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-06-23-FlapjaxDataVisualizationontheWebwithPlotlyandFlask_1.png" alt="Flapjax Data Visualization on the Web with Plotly and Flask"></p>
<p>웹 애플리케이션을 만드는 가장 쉬운 방법인가요?</p>
<p>내 생각에는 사용자 인터페이스 디자인과 프로그램 로직을 분리하는 것이 정말 쉽게 만드는 방법입니다. 그러나 Streamlit이나 Jupyter Notebooks에서 앱을 만드는 데 익숙하다면, 처음에는 학습 곡선이 존재할 수 있습니다. 그러나 기본 애플리케이션을 위한 패턴을 채택한 후에는 새로운 애플리케이션을 만드는 것이 훨씬 쉬워집니다.</p>
<p>그래서, 우리는 Flask를 사용하여 데이터 시각화 애플리케이션을 개발하고, HTML 페이지를 정의하는 Jinja 템플릿을 사용할 것입니다. 하지만 이 페이지에 나타나는 실제 데이터는 Python 코드에서 정의될 것입니다.</p>
<div class="content-ad"></div>
<p>인터랙티브한 사용자 인터페이스를 만들기 위해서는 일부 UI 구성 요소와 작은 양의 JavaScript가 필요합니다. 그러나 보시다시피 이는 앞으로의 애플리케이션에서 재사용 가능한 코드로 거의 표준 코드라는 것을 확인할 것입니다.</p>
<p>또한 웹 페이지가 왼쪽과 같이 보이는 것으로 만족하는 대신 약간의 노력으로 오른쪽과 같이 만들 수 있기 때문에 Bootstrap 5 UI 구성 요소를 사용할 것입니다.</p>
<p>이 자습서는 두 부분으로 나뉘어 있습니다. 먼저 정적 웹페이지를 만들고 Flask와 HTML이 어떻게 함께 작동하는지 파악한 다음 콜백을 다루어 인터랙티브 페이지를 만들 것입니다.</p>
<p>이 문서의 모든 코드는 내 GitHub 저장소에 있을 것입니다. 발행 후 곧바로 이를 링크할 것입니다.</p>
<div class="content-ad"></div>
<h2>부트스트랩 UI</h2>
<p>부트스트랩을 사용하면 매력적인 웹페이지를 손쉽게 만들 수 있어요. Bootstrap 5 파일을 포함하고 HTML 요소에 몇 가지 속성을 추가하면 기본 HTML을 쉽게 개선할 수 있어요.</p>
<p>부트스트랩 튜토리얼은 아니지만 위 웹페이지의 헤더를 만드는 기본 HTML 코드의 차이를 빨리 보여드릴게요.</p>
<p>기본 HTML</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"># 제목

부트스트랩 속성 추가

&#x3C;header <span class="hljs-keyword">class</span>=<span class="hljs-string">"bg-primary text-white text-center py-2"</span>>
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"display-4"</span>></span>제목<span class="hljs-tag">&#x3C;/<span class="hljs-name">h1</span>></span></span>
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"lead"</span>></span>부제목<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span></span>
&#x3C;/header>

헤더는 <span class="hljs-string">`h1`</span>과 단락 요소 <span class="hljs-string">`p`</span> 두 가지 요소로 구성되어 있습니다. 부트스트랩 버전에서 이들 요소는 추가된 속성을 가지고 있습니다: 헤더 자체는 주요한 배경 색상으로 흰색 텍스트를 가지며, 텍스트는 가운데 정렬되고 위아래 패딩이 <span class="hljs-number">2</span>픽셀로 설정됩니다; 제목 태그는 display-<span class="hljs-number">4</span> 폰트를 사용하고 단락의 폰트는 lead로 설정되어 있습니다— display 폰트는 크고 굵고, lead는 강조해야 하는 일반 텍스트용으로 정의되어 있습니다.

&#x3C;div <span class="hljs-keyword">class</span>=<span class="hljs-string">"content-ad"</span>>&#x3C;/div>

이러한 특성들은 <span class="hljs-variable constant_">HTML</span> <span class="hljs-keyword">class</span> 속성에서 설정됩니다. 코드에서 더 많이 볼 수 있으며, 이해하기 쉽게 될 것입니다. 자세히 설명하지는 않겠지만 부트스트랩 문서에서 관련 정보를 찾을 수 있습니다. 그 웹사이트에서 필요한 모든 정보를 얻을 수 있을 거에요.

## 플라스크 프로젝트

플라스크 프레임워크는 웹 기반 어플리케이션을 만들기 쉽게 도와줍니다. 플라스크 어플리케이션은 일반적으로 적어도 두 개 파일로 구성됩니다: 파이썬 앱과 <span class="hljs-variable constant_">HTML</span> 템플릿입니다.

파이썬 부분에는 어플리케이션 로직이 포함되어 있습니다. 예를 들어, 데이터 시각화 어플리케이션의 경우, 데이터를 <span class="hljs-title class_">Pandas</span> 데이터프레임에로드하고, 분석을 수행하며 <span class="hljs-title class_">Plotly</span>에서 차트를 생성할 수도 있습니다. <span class="hljs-variable constant_">HTML</span> 템플릿은 웹페이지의 레이아웃을 정의하고, 파이썬 프로그램에 의해 표시할 데이터가 제공됩니다.

&#x3C;div <span class="hljs-keyword">class</span>=<span class="hljs-string">"content-ad"</span>>&#x3C;/div>

/project_name
    |--- app.<span class="hljs-property">py</span>
    |
    |--- /templates
            |
            |--- index.<span class="hljs-property">html</span>

위의 다이어그램처럼 만들어야 할 간단한 앱의 디렉토리 구조입니다. 메인 <span class="hljs-title class_">Python</span> 앱은 프로젝트 폴더에 있고 템플릿은 templates라는 서브폴더에 위치해 있습니다.

물론 <span class="hljs-title class_">Flask</span>를 설치해야 합니다:

pip install flask

&#x3C;div <span class="hljs-keyword">class</span>=<span class="hljs-string">"content-ad"</span>>&#x3C;/div>

가상 환경을 먼저 만드시는 것이 좋습니다.

<span class="hljs-title class_">Flask</span> 앱의 <span class="hljs-title class_">Python</span> 부분은 앱이 응답할 하나 이상의 라우트를 정의합니다. 일반적으로 그 라우트 중 하나는 프로젝트의 루트인 <span class="hljs-string">'/'</span>입니다.

아래는 템플릿을 사용하는 최소한의 <span class="hljs-title class_">Python</span> 앱 예시입니다. 템플릿은 index.<span class="hljs-property">html</span>이라는 이름이어야 하며 templates 폴더에 있어야 하며 <span class="hljs-title function_">render_template</span>() 라이브러리 함수를 사용하여 <span class="hljs-title class_">Flask</span>에서 웹페이지로 렌더링됩니다. 웹페이지의 제목에 해당하는 값을 생성하고 이를 함수에 전달하는 것에 유의하세요.

<span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> <span class="hljs-title class_">Flask</span>, render_template

app = <span class="hljs-title class_">Flask</span>(__name__)

@app.<span class="hljs-title function_">route</span>(<span class="hljs-string">'/'</span>)
def <span class="hljs-title function_">index</span>():
    title = <span class="hljs-string">"이것이 제목입니다"</span>
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">render_template</span>(<span class="hljs-string">'index.html'</span>, title=title)

&#x3C;div <span class="hljs-keyword">class</span>=<span class="hljs-string">"content-ad"</span>>&#x3C;/div>

아래는 <span class="hljs-string">`title`</span> 값이 인corporated되어야 하는 index.<span class="hljs-property">html</span> 템플릿입니다. <span class="hljs-string">`h1`</span> 태그 안에 <span class="hljs-string">`title`</span> 식별자가 이중 중괄호로 둘러싸여 있음을 볼 수 있습니다.

&#x3C;!<span class="hljs-variable constant_">DOCTYPE</span> html>
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">html</span>></span>
<span class="hljs-tag">&#x3C;<span class="hljs-name">body</span>></span>
   <span class="hljs-tag">&#x3C;<span class="hljs-name">h1</span>></span>{title}<span class="hljs-tag">&#x3C;/<span class="hljs-name">h1</span>></span>
<span class="hljs-tag">&#x3C;/<span class="hljs-name">body</span>></span>
<span class="hljs-tag">&#x3C;/<span class="hljs-name">html</span>></span></span>

<span class="hljs-title class_">Flask</span>는 <span class="hljs-variable constant_">HTML</span> 템플릿의 플레이스홀더를 <span class="hljs-title function_">render_template</span>()에 전달된 값으로 대체하는 데 <span class="hljs-title class_">Jinja</span> 템플릿 엔진을 사용합니다.

터미널에서 flask run을 입력하여 애플리케이션을 실행하면 아래와 유사한 응답을 받게 됩니다. (만약 애플리케이션을 app.<span class="hljs-property">py</span>로 호출했다면, flask --app app_name run을 입력해야 합니다. 여기서 app_name에는 .<span class="hljs-property">py</span> 확장자를 제외한 앱의 이름을 입력해야 합니다.)

&#x3C;div <span class="hljs-keyword">class</span>=<span class="hljs-string">"content-ad"</span>>&#x3C;/div>

flask run
 * <span class="hljs-title class_">Debug</span> <span class="hljs-attr">mode</span>: off
경고: 이는 개발 서버입니다. 제품 배포에는 사용하지 마십시오. 대신 제품 <span class="hljs-variable constant_">WSGI</span> 서버를 사용하십시오.
 * <span class="hljs-attr">http</span>:<span class="hljs-comment">//127.0.0.1:5000에서 실행 중</span>
<span class="hljs-variable constant_">CTRL</span>+C를 눌러 종료

브라우저에서 <span class="hljs-attr">http</span>:<span class="hljs-comment">//127.0.0.1:5000 또는 localhost:5000을 입력하면, Python 코드에서 정의된 텍스트를 표시하는 간단한 웹 페이지가 표시됩니다.</span>

<span class="hljs-title class_">Flask</span>에 대해 더 알아보려면, <span class="hljs-title class_">Quickstart</span> 튜토리얼을 살펴보는 것에서 시작할 수 있지만, 여기에서 시작하는 데 필요한 모든 정보를 다룰 것을 희망합니다.

# 정적 데이터 시각화 애플리케이션
</code></pre>
<div class="content-ad"></div>
<p>저희 첫 번째 애플리케이션은 지금까지 본 내용을 기반으로 하여 Plotly 차트와 일부 보조 텍스트가 포함된 웹사이트를 생성합니다. 나중에는 상호 작용 기능을 추가할 예정입니다.</p>
<p>파이썬 쪽에 대해 알아보겠습니다. 목록은 아래에 있지만 일단 #### Simple template ####로 시작하는 섹션에 집중해봅시다. 여기서 /simple이라는 경로를 정의했음을 확인할 수 있습니다. 이는 브라우저를 localhost:5000/simple로 가리킴으로써 앱을 호출하게 됩니다. 그리고 데코레이터 아래에 있는 함수 simpleindex()가 실행됩니다.</p>
<p>이 함수에서 웹페이지에 표시할 일부 텍스트와 그래프를 설정합니다. 먼저 일부 변수를 설정하고, 그 변수들을 사용하여 HTML 템플릿이 사용할 매개변수 사전을 작성합니다. 변수들의 이름을 통해 어떻게 사용될지 명확히 알 수 있습니다.</p>
<p>그래프 매개변수는 get_graph() 함수를 사용하여 설정됩니다. 먼저 전역 온도 이상치 데이터를 로드하고, 1881년부터 2022년까지의 데이터가 기후 변화가 시간에 따라 온도에 미치는 영향을 추적합니다 (이에 대한 자세한 내용은 2023년이 역대 최고의 여름이었음을 나타내는 새로운 데이터를 참조하십시오). 데이터는 아래 표에 표시됩니다 (그래프에서 더 잘 나타납니다!).</p>
<div class="content-ad"></div>
<p>정적 앱에는 6월, 7월 및 8월의 온도를 나타내는 단일 열 JJA를 사용할 것입니다. 대화형 앱은 나머지 몇 가지도 사용할 것이므로 현재 앱의 기간 매개변수에 대한 기본값을 설정하여 대화형 앱에서 나중에 변경할 수 있습니다.</p>
<p>데이터는 Plotly 막대 차트를 생성하는 데 사용되며 생성된 도표는 JSON으로 변환됩니다. 그래서 이 JSON 데이터가 반환되어 사전의 매개변수에서 그래프 항목을 설정하는 데 사용됩니다.</p>
<p>이전 함수로 돌아가서 설정한 매개변수를 사용하여 render_template를 호출해야 합니다. 타이핑을 줄이기 위해 template라는 도우미 함수를 만들었습니다. 이 함수는 템플릿 매개변수를 추출하고 모든 데이터를 웹페이지로 전달합니다.</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, request, jsonify, render_template
<span class="hljs-keyword">import</span> json
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> plotly.express <span class="hljs-keyword">as</span> px

app = Flask(__name__)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_graph</span>(<span class="hljs-params">period=<span class="hljs-string">'JJA'</span></span>):
    df = pd.read_csv(<span class="hljs-string">'GlobalTemps1880-2022.csv'</span>)
    fig = px.bar(df, x=<span class="hljs-string">'Year'</span>, y=period, 
                 color=period, title=period, 
                 color_continuous_scale=<span class="hljs-string">'reds'</span>, 
                 template=<span class="hljs-string">'plotly_white'</span>, width=<span class="hljs-number">1000</span>, height=<span class="hljs-number">500</span>)

    graphJSON = fig.to_json()
    <span class="hljs-keyword">return</span> json.dumps(graphJSON)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">template</span>(<span class="hljs-params">params</span>):
    <span class="hljs-keyword">return</span> render_template(params[<span class="hljs-string">'template'</span>], params=params)

<span class="hljs-comment">#### App ####</span>

<span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">'/'</span></span>)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>():
    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">'index.html'</span>)

<span class="hljs-comment">#### Simple template ####</span>

<span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">'/simple'</span></span>)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">simpleindex</span>():
    header = <span class="hljs-string">"Global Temperature"</span>
    subheader = <span class="hljs-string">"Global Temperature changes over the last few centuries"</span>
    description = <span class="hljs-string">"""The graph shows the increase in temperature year on year.
    The data spans the years 1881 to 2022 and includes temperature anomalies 
    for the months June through August.
    """</span>
    params = {
        <span class="hljs-string">'template'</span>: <span class="hljs-string">'simpleindex.html'</span>,
        <span class="hljs-string">'title'</span>: header,
        <span class="hljs-string">'subtitle'</span>: subheader,
        <span class="hljs-string">'content'</span>: description,
        <span class="hljs-string">'graph'</span>: get_graph()
    }
    <span class="hljs-keyword">return</span> template(params)

<span class="hljs-comment">#### Main ####</span>

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    app.run(debug=<span class="hljs-literal">True</span>)
</code></pre>
<div class="content-ad"></div>
<p>이젠 HTML 템플릿에 대해 이야기해볼게요. 아래 목록을 확인하고 좋은 소식은 <code>body</code>...<code>/body</code> 태그 내의 코드를 제외한 모든 것을 무시할 수 있다는 겁니다. 나머지는 Bootstrap과 Plotly를 사용하는 웹페이지에 필요한 보일러플레이트 코드이며, 비슷한 웹페이지에 붙여넣을 수 있습니다. 마지막 <code>script</code> 태그도 Bootstrap Javascript 코드를 포함하고 있어서 안심하고 무시할 수 있어요.</p>
<pre><code class="hljs language-js">    &#x3C;header>
        <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">h1</span>></span>{ params.title }<span class="hljs-tag">&#x3C;/<span class="hljs-name">h1</span>></span></span>
        <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>{ params.subtitle }<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span></span>
    &#x3C;/header>

    <span class="xml">&#x3C;div">
        <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">'chart'</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>{params.content}<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">'text/javascript'</span>></span><span class="javascript">
      <span class="hljs-keyword">var</span> figure = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>({params.<span class="hljs-property">graph</span> | safe})
      <span class="hljs-title class_">Plotly</span>.<span class="hljs-title function_">newPlot</span>(<span class="hljs-string">'chart'</span>, figure, {});
    </span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span></span>
</code></pre>
<div class="content-ad"></div>
<p>이전에도 Jinja 매개변수의 사용법을 보았었는데, 이번에는 몇 가지 매개변수를 params라는 딕셔너리로 묶었다는 점이 다릅니다. 따라서 이번에는 그들을 참조할 때 이름 앞에 딕셔너리의 이름을 붙여주어야 합니다. 따라서 <code>h1</code>'params.title'<code>/h1</code>은 간단히 제목 매개변수를 헤딩 태그 쌍에 넣는 것입니다. 텍스트 매개변수용의 나머지 세 태그도 비슷합니다.</p>
<p>그래프를 그리기 위해서는 그것을 넣을 요소가 필요하며 그 요소에는 id 속성이 있어야 합니다(<code>div id=</code>chart/div`). 이 요소는 제목 아래와 설명 위에 위치합니다.</p>
<p>이를 따르는 아래의 스크립트 요소는 다시 차트를 그리기 위해 Plotly Javascript를 호출하는 보일러플레이트 코드입니다. 여기서 주목해야 할 점은 그래프 매개변수를 포함할 때 safe 키워드를 사용한다는 것입니다. 이는 Jinja에게 그래프에 있는 특수 문자를 해석하지 말고, 그대로 사실 그대로 취급할 것을 지시합니다. 따라서 코드는 다음과 같습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> figure = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>({params.<span class="hljs-property">graph</span> | safe})
</code></pre>
<div class="content-ad"></div>
<p>이제, 템플릿은 프로젝트 디렉토리의 templates 폴더에 있어야 한다는 것을 기억해주세요. 그리고 이 코드가 작동하려면 데이터 파일이 프로젝트 디렉토리 자체에 있어야 합니다. (물론 이동할 수 있지만 Python 프로그램에서 열 때 경로를 변경해야 합니다).</p>
<p>앱을 실행하고 브라우저를 localhost:5000/simple로 이동하여 웹페이지를 보세요. 아마도 아래처럼 웹페이지가 나타날 것입니다.</p>
<p><img src="/assets/img/2024-06-23-FlapjaxDataVisualizationontheWebwithPlotlyandFlask_2.png" alt="웹 앱의 정적 버전"></p>
<p>그리고 이것이 웹 앱의 정적 버전입니다.</p>
<div class="content-ad"></div>
<h1>대화형 데이터 시각화 애플리케이션</h1>
<p>하지만 여름에만 제한되어 있는 것이 아쉽지 않나요? 우리가 JJA 이외의 기간을 선택할 수 있다면 얼마나 좋을까요? 데이터에는 전체 연간, J-D 및 세 달 기간 (DJF, MAM, JJA 및 SON)을 위한 열도 포함되어 있습니다. (알파벳은 영어로 된 월 이름을 나타냅니다: 12월, 1월, 2월; 3월, 4월, 5월; 그 이후로 계속됩니다.)</p>
<p>이를 위해 사용자가 적절한 기간을 선택할 수 있는 사용자 컨트롤을 통합해야 합니다. 저는 다양한 기간을 표시해 줄 드롭다운 메뉴를 선택했습니다. 이전 웹페이지와 꽤 유사하게 보일 것입니다(아래 이미지 참조).</p>
<p><img src="/assets/img/2024-06-23-FlapjaxDataVisualizationontheWebwithPlotlyandFlask_3.png" alt="Image"></p>
<div class="content-ad"></div>
<p>이 코드는 처음에는 꽤 유사합니다. 주요 차이점은 새로운 그래프를 선택할 때 발생합니다.</p>
<p>새 값을 선택하면 Javascript 함수가 호출되어 해당 값을 서버의 콜백 함수로 보내고 응답을 기다립니다. 이 콜백 함수는 새로운 차트를 반환하고, 호출하는 Javascript에 의해 표시됩니다.</p>
<p>먼저 익숙한 내용을 다뤄 봅시다. 아래에 새로운 엔드포인트 /ddsimple을 구현하는 함수가 있습니다.</p>
<pre><code class="hljs language-js">@app.<span class="hljs-title function_">route</span>(<span class="hljs-string">'/ddsimple'</span>)
def <span class="hljs-title function_">ddsimpleindex</span>():
    # <span class="hljs-title class_">Root</span> 엔드포인트는 페이지를 만듭니다.
    header = <span class="hljs-string">"지구 온도"</span>
    subheader = <span class="hljs-string">"지난 몇 세기 동안의 지구 온도 변화"</span>
    description = <span class="hljs-string">""</span><span class="hljs-string">"그래프는 연도별 온도 증가를 보여줍니다.
    데이터는 1881년부터 2022년까지의 기간을 포함하며, 각 연도의 온도 이상치를 표시합니다.
    "</span><span class="hljs-string">""</span>
    menu_label = <span class="hljs-string">"기간을 선택하세요"</span>

    params = {    
        <span class="hljs-string">'template'</span>: <span class="hljs-string">'ddsimpleindex.html'</span>,
        <span class="hljs-string">'title'</span>: header,
        <span class="hljs-string">'subtitle'</span>: subheader,
        <span class="hljs-string">'content'</span> : description,
        <span class="hljs-string">'menu_label'</span>: menu_label,
        <span class="hljs-string">'options'</span> : [{<span class="hljs-string">'code'</span>:<span class="hljs-string">'J-D'</span>, <span class="hljs-string">'desc'</span>:<span class="hljs-string">'전체 연도'</span>},
                     {<span class="hljs-string">'code'</span>:<span class="hljs-string">'DJF'</span>,<span class="hljs-string">'desc'</span>:<span class="hljs-string">'겨울 (북반구)'</span>},
                     {<span class="hljs-string">'code'</span>:<span class="hljs-string">'MAM'</span>,<span class="hljs-string">'desc'</span>:<span class="hljs-string">'봄 (북반구)'</span>},
                     {<span class="hljs-string">'code'</span>:<span class="hljs-string">'JJA'</span>,<span class="hljs-string">'desc'</span>:<span class="hljs-string">'여름 (북반구)'</span>},
                     {<span class="hljs-string">'code'</span>:<span class="hljs-string">'SON'</span>,<span class="hljs-string">'desc'</span>:<span class="hljs-string">'가을 (북반구)'</span>}],
        <span class="hljs-string">'graph'</span>   : <span class="hljs-title function_">get_graph</span>()
    }
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">template</span>(params)
</code></pre>
<div class="content-ad"></div>
<p>위의 코드를 Markdown 형식으로 변경하려면 아래와 같이 변경하실 수 있습니다.</p>
<pre><code class="hljs language-js">&#x3C;form id=<span class="hljs-string">"userForm"</span> name=<span class="hljs-string">"form1"</span> onChange=<span class="hljs-string">"getFormValues('form1')"</span>>
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"mb-3"</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"dropdown"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"form-label lead"</span>></span>{{params.menu_label}}<span class="hljs-tag">&#x3C;/<span class="hljs-name">label</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">select</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"form-select"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dropdown"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"dropdown"</span>></span>
            {% for opt in params.options %}
                <span class="hljs-tag">&#x3C;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"{{opt.code}}"</span>></span>{{opt.desc}}<span class="hljs-tag">&#x3C;/<span class="hljs-name">option</span>></span>
            {% endfor %}
        <span class="hljs-tag">&#x3C;/<span class="hljs-name">select</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
&#x3C;/form>
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
    <span class="hljs-comment">&#x3C;!-- Main Content Area --></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"lead"</span>></span>{{params.content}}<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"graph"</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
</code></pre>
<p>이렇게하면 드롭다운 메뉴가 포함된 양식을 만들 수 있습니다. 양식에는 이전에 본 두 개의 중괄호로 포함된 메뉴에 대한 레이블도 포함되어 있습니다.</p>
<div class="content-ad"></div>
<p>이전 예제와의 주요 차이점은 메뉴가 구성되는 방식입니다. <code>select</code> 요소 내부에는 메뉴에서 제공된 옵션을 나타내는 <code>option</code> 태그 목록을 넣어야 합니다. 옵션 태그에는 값과 설명이 있습니다. 이 값들과 설명들은 우리가 params.options 딕셔너리에 정의한 것입니다. 우리는 이 값을 포함하기 위해 ' for opt in param.options '와 같은 Jinja 반복문을 실행하여 딕셔너리를 반복하며 각 요소를 opt라는 지역 변수에 넣습니다. 그런 다음 opt.code와 opt.desc 값을 사용하여 이 값을 옵션 태그에 삽입합니다.</p>
<p>Flask 튜토리얼: Pythonbasics.org 웹사이트의 Templates에서 Jinja 템플릿의 간단한 예제와 설명을 찾을 수 있습니다.</p>
<p>여기에는 우리 목적에 중요한 form 태그의 다른 부분이 있습니다. form 태그 내부에는 onChange라는 속성이 있는데, 이 속성은 어떤 동작의 값을 취합니다. 이 경우에는 폼의 값이 변경될 때 호출되는 자바스크립트 함수입니다. 이 경우에는 메뉴에서 옵션 중 하나를 선택했을 때입니다.</p>
<p>그리고 재미 있는 부분이 여기에서 시작됩니다.</p>
<div class="content-ad"></div>
<h2>콜백</h2>
<p>웹 페이지를 새 차트로 업데이트하기 위해 콜백 메커니즘을 사용하며 아래 차트는 브라우저와 서버 간의 트랜잭션을 보여줍니다. 새 차트를 요청한 응답은 페이지를 다시로드하는 것이 아니라 업데이트하는 것임을 유의하세요. 이는 빠르며 잠깐의 빈 화면을 보여주지 않아 사용자 경험이 훨씬 더 좋아집니다.</p>
<p><img src="/assets/img/2024-06-23-FlapjaxDataVisualizationontheWebwithPlotlyandFlask_4.png" alt="차트 이미지"></p>
<p>콜백은 웹 페이지의 양식 변경에 의해 호출됩니다, 이전에 언급한대로. 이것을 위한 메커니즘은 양식의 onChange 속성에 식별된 자바스크립트 함수입니다.</p>
<div class="content-ad"></div>
<p>자바스크립트 함수가 어떻게 작동하는지 자세히 설명하려고 합니다. 여기서 기본적으로, 이 함수는 폼에서 값을 가져와 Flask 앱의 콜백 엔드포인트로 보냅니다.</p>
<p>자바스크립트를 작성하는 것이 걱정되시는 분들은 걱정하지 마세요. 이것이 어떻게 작동하는지 알 필요는 없습니다. 그냥 복사해서 사용하면 여러분이 웹 페이지에 포함하고 싶은 어떤 폼이든 작동합니다.</p>
<p>더 자세한 설명을 읽고 싶으신 모험가들을 위해 아래에 설명을 제공하겠지만, 그렇지 않은 분들은 다음 섹션으로 건너뛰어도 괜찮습니다.</p>
<p>실제로 두 개의 함수가 있습니다. 폼에서 값을 가져오는 함수는 아래와 같습니다.</p>
<pre><code class="hljs language-js">        <span class="hljs-keyword">function</span> <span class="hljs-title function_">getFormValues</span>(<span class="hljs-params">f</span>) {
            <span class="hljs-keyword">const</span> form = <span class="hljs-variable language_">document</span>.<span class="hljs-property">forms</span>.<span class="hljs-title function_">namedItem</span>(f);
            <span class="hljs-keyword">const</span> formData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>(form);
            <span class="hljs-keyword">const</span> value = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>(formData.<span class="hljs-title function_">entries</span>());
            <span class="hljs-title function_">postJSON</span>(value);
        }
</code></pre>
<div class="content-ad"></div>
<p>모든 코드는 내장된 JavaScript 함수를 사용합니다: 첫 번째 줄은 문서(즉, 웹 페이지)에서 폼을 가져오고, 두 번째 줄은 폼 데이터를 포함하는 데이터 구조체를 검색하며, 세 번째 줄은 해당 구조체에서 모든 값을 추출합니다.</p>
<p>마지막으로, 이러한 값들은 다른 함수 'postJson'에 전달됩니다.</p>
<pre><code class="hljs language-js">        <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">postJSON</span>(<span class="hljs-params">data</span>) {
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">"/callback"</span>, {
                    <span class="hljs-attr">method</span>: <span class="hljs-string">"POST"</span>,
                    <span class="hljs-attr">headers</span>: {
                        <span class="hljs-string">"Content-Type"</span>: <span class="hljs-string">"application/json"</span>,
                    },
                    <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data),
                });

                <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();
                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Success:"</span>);<span class="hljs-comment">//, result);</span>

                <span class="hljs-title function_">drawGraph</span>(result);
            }
            <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"Error:"</span>, error);
            }
        }
</code></pre>
<p>이 함수는 비동기 함수이므로 호출된 후 프로그램 실행이 즉시 호출한 코드로 돌아가고, 비동기 함수는 별도의 실행 스레드에서 계속 실행됩니다. 즉, 웹 페이지의 실행과 병렬로 수행해야 할 작업을 계속합니다.</p>
<div class="content-ad"></div>
<p>postJSON은 Python 콜백 코드로 전송해야 하는 데이터를 받아서 비동기 fetch 함수를 사용하여 전송합니다. fetch는 데이터가 전달되어야 하는 엔드포인트와 데이터 자체를 매개변수로 받습니다. 데이터를 전송하기 위해 HTTP POST 메커니즘을 사용합니다. postJSON은 fetch가 완료될 때까지 기다린 후, 즉 서버로부터 일부 데이터가 반환될 때까지 기다립니다. 그런 데이터는 그래프를 업데이트하는 drawGraph 함수로 전달됩니다.</p>
<p>코드는 try... catch... 블록에 포함되어 있음을 유의해주세요. 이는 Python 프로그램에서 발견할 수 있는 것과 거의 동일합니다. 즉, try 블록의 코드가 실패하면 — 응답이 없거나 다른 통신 오류가 발생하면 — 해당 실패는 콘솔에 로깅됩니다.</p>
<h2>Python 콜백</h2>
<p>이 모든 것이 작동하려면 Flask 코드에 데이터를 받고 처리한 후(예: 새로운 그래프 만들기) 결과를 다시 보내는 콜백 함수가 필요합니다. 여기에 있습니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-python"><span class="hljs-comment"># 콜백의 엔드포인트를 정의하는 것이 첫 번째 작업입니다. 엔드포인트가 POST 방식으로 데이터를 보내는 것을 명시해야 합니다.</span>

<span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">'/callback'</span>, methods=[<span class="hljs-string">'POST'</span>]</span>)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">callback</span>():
    <span class="hljs-comment"># 콜백은 페이지를 업데이트합니다.</span>
    <span class="hljs-keyword">if</span> request.is_json:
        data = request.get_json() 
        <span class="hljs-keyword">return</span> get_graph(period=data[<span class="hljs-string">'dropdown'</span>])
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">return</span> jsonify({<span class="hljs-string">"error"</span>: <span class="hljs-string">"잘못된 JSON 데이터입니다"</span>}), <span class="hljs-number">400</span>
</code></pre>
<p>콜백의 엔드포인트를 정의하는 것이 첫 번째 작업입니다. 엔드포인트가 POST 방식으로 데이터를 보내는 것을 명시해야 합니다.</p>
<p>또한 데이터가 JSON 형식으로 제공되기를 기대하는데, 그렇지 않은 경우 오류를 반환합니다.</p>
<p>데이터가 JSON이라면 드롭다운 메뉴에서 값을 추출하여 get_graph 함수에 전달하고, 이 함수는 그래프를 그리고 Plotly가 예상하는 JSON 형식으로 반환합니다. 이 그래프 데이터는 웹페이지의 JavaScript 함수에 의해 받아들여지고 페이지가 업데이트됩니다.</p>
<div class="content-ad"></div>
<p>위 코드를 사용하면 상단에 있는 대화형 웹 페이지를 제공합니다.</p>
<h2>Flapjax — 이름의 의미</h2>
<p>정말이지, 이것은 매우 인위적인 이름입니다: Flask, Python, Javascript 및 ax를 나타내며 이 기법을 가능케 하는 비동기 통신을 의미합니다.</p>
<p>미리 작성된 템플릿과 상당량의 보일러플레이트 코드를 사용하여 Python 코드의 로직에 대부분 집중하면서 유용한 대화형 웹 페이지를 만들 수 있다는 점을 보실 수 있기를 바랍니다.</p>
<div class="content-ad"></div>
<p>이 앱에는 사용자가 새 옵션을 선택할 때 업데이트되는 단일 그래프만 포함되어 있지만 HTML 폼에서 수집할 수 있는 값의 수는 무한입니다. 이 값들은 Flask 앱에 의해 처리된 후 새로운 정보로 웹페이지가 업데이트됩니다. (아마 나중에 이에 대해 자세히 다룰 수도 있을 것입니다).</p>
<p>여기에 설명된 모든 코드와 데이터는 제 GitHub 리포지토리에서 다운로드할 수 있습니다. (jinja-article 폴더를 참조해주세요).</p>
<p>업데이트: GitHub 리포지토리의 reuse 폴더에 새 데이터 세트로 새 앱을 생성하는 새 앱을 작성했습니다. HTML 및 Javascript는 동일하며 Python 코드와 데이터만 변경되었습니다:
Flapjax 템플릿 및 코드 재사용</p>
<p>이 정보가 유용하게 느껴지길 바랍니다. 제 작업을 더 알아보고 싶으시면 웹사이트를 방문하시거나 무료 뉴스레터를 구독함으로써 발행 시 알림을 받을 수 있습니다. (여기를 참조해주세요)</p>
<div class="content-ad"></div>
<p>만약 플라스크가 원하는 것이 아니라면, 내가 미디엄 기사를 기반으로 작성한 eBook Streamlit from Scratch을 읽어보세요.</p>
<h2>참고 자료</h2>
<p>이 기사와 앱에서 사용된 데이터는 아래 1번과 2번에서 설명된 것을 기반으로 합니다.</p>
<ul>
<li>GISTEMP 팀, 2023: GISS 표면 온도 분석 (GISTEMP), 버전 4. NASA Goddard 우주 연구소. 데이터 세트는 2023년 9월 19일 data.giss.nasa.gov/gistemp/에서 액세스되었습니다. NASA의 데이터 세트에 대한 구체적인 라이선스가 없음에 유의하십시오. 이러한 데이터는 비상업적 목적으로 NASA에 의해 자유롭게 제공되지만 (위와 같이) 언급이 되어야 합니다.</li>
<li>Lenssen, N., G. Schmidt, J. Hansen, M. Menne, A. Persin, R. Ruedy, and D. Zyss, 2019: GISTEMP 불확실성 모델의 개선. 대기.지구물리학.연구.저널, 124권, 12호, 6307–6326, doi:10.1029/2018JD029522.</li>
</ul>
<div class="content-ad"></div>
<p>저자가 별도로 표기하지 않은 경우, 모든 이미지, 다이어그램, 스크린샷 및 코드는 저자가 제작했습니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Flapjax Plotly와 Flask로 웹에서 데이터 시각화 하는 방법","description":"","date":"2024-06-23 15:05","slug":"2024-06-23-FlapjaxDataVisualizationontheWebwithPlotlyandFlask","content":"\n\n데이터 시각화 앱을 구축하는 가장 좋은 프레임워크는 무엇인가요? Streamlit이나 Dash일까요? 아니면 Jupyter Notebook을 Mercury나 Voilá로 변환하여 바로 웹 앱을 만드는 것일까요?\n\n이 모든 것들은 애플리케이션을 만드는 좋은 방법이며 시작하기 쉽습니다. 하지만 시작하기 쉬운 것이 결국 더 모험적인 영역으로 발전할 수 있습니다. 그래서 저는 다시 기초로 돌아가 Python 서버 코드와 HTML 페이지를 함께 사용하는 것이 생각보다 어려운 일이 아니라고 설득하려고 합니다.\n\n우리는 상당량의 보일러플레이트 코드와 템플릿을 활용하여 매력적인 대화형 애플리케이션을 만들 수 있습니다. 이는 여전히 Python 코드에 집중할 수 있게 해주며 HTML 및 JavaScript에 공부할 부담이 적다는 것을 의미합니다. 저는 이 접근 방식을 Flapjax라고 부릅니다 — 나중에 왜 이렇게 부르는지 설명하겠습니다.\n\nPython으로 웹 애플리케이션을 만드는 가장 간단한 방법 중 하나는 Flask를 사용하는 것이므로, 이를 사용하여 아래 이미지와 같은 앱을 만들어보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Flask Framework](/assets/img/2024-06-23-FlapjaxDataVisualizationontheWebwithPlotlyandFlask_0.png)\n\n## 플라스크 프레임워크\n\nFlask는 웹 애플리케이션을 개발하기 위한 최소주의 프레임워크입니다. Flask 앱에서는 웹 페이지가 일반적으로 템플릿과 파이썬 코드에서 제공된 데이터로 구성됩니다. 이 데이터는 웹 페이지의 내용을 형성하는 텍스트나 그래픽일 수 있습니다. 결과물은 사용자에게 브라우저에서 표시되도록 전송됩니다.\n\n아래 다이어그램은 인터랙티브 앱의 기본 구조를 보여줍니다. 앱이 실행 중일 때, Python 부분은 서버에서 실행되고 브라우저에서 실행되는 HTML로 데이터를 전송합니다. 웹 페이지에서 사용자 입력이 다시 Python 코드로 전달되며, 이후 Python 코드는 더 많은 데이터를 전송하여 사용자가 선택한 새로운 콘텐츠 - 사용자가 선택한 새로운 차트와 같은 - 로 HTML을 업데이트할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Flapjax Data Visualization on the Web with Plotly and Flask](/assets/img/2024-06-23-FlapjaxDataVisualizationontheWebwithPlotlyandFlask_1.png)\n\n웹 애플리케이션을 만드는 가장 쉬운 방법인가요?\n\n내 생각에는 사용자 인터페이스 디자인과 프로그램 로직을 분리하는 것이 정말 쉽게 만드는 방법입니다. 그러나 Streamlit이나 Jupyter Notebooks에서 앱을 만드는 데 익숙하다면, 처음에는 학습 곡선이 존재할 수 있습니다. 그러나 기본 애플리케이션을 위한 패턴을 채택한 후에는 새로운 애플리케이션을 만드는 것이 훨씬 쉬워집니다.\n\n그래서, 우리는 Flask를 사용하여 데이터 시각화 애플리케이션을 개발하고, HTML 페이지를 정의하는 Jinja 템플릿을 사용할 것입니다. 하지만 이 페이지에 나타나는 실제 데이터는 Python 코드에서 정의될 것입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n인터랙티브한 사용자 인터페이스를 만들기 위해서는 일부 UI 구성 요소와 작은 양의 JavaScript가 필요합니다. 그러나 보시다시피 이는 앞으로의 애플리케이션에서 재사용 가능한 코드로 거의 표준 코드라는 것을 확인할 것입니다.\n\n또한 웹 페이지가 왼쪽과 같이 보이는 것으로 만족하는 대신 약간의 노력으로 오른쪽과 같이 만들 수 있기 때문에 Bootstrap 5 UI 구성 요소를 사용할 것입니다.\n\n이 자습서는 두 부분으로 나뉘어 있습니다. 먼저 정적 웹페이지를 만들고 Flask와 HTML이 어떻게 함께 작동하는지 파악한 다음 콜백을 다루어 인터랙티브 페이지를 만들 것입니다.\n\n이 문서의 모든 코드는 내 GitHub 저장소에 있을 것입니다. 발행 후 곧바로 이를 링크할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 부트스트랩 UI\n\n부트스트랩을 사용하면 매력적인 웹페이지를 손쉽게 만들 수 있어요. Bootstrap 5 파일을 포함하고 HTML 요소에 몇 가지 속성을 추가하면 기본 HTML을 쉽게 개선할 수 있어요.\n\n부트스트랩 튜토리얼은 아니지만 위 웹페이지의 헤더를 만드는 기본 HTML 코드의 차이를 빨리 보여드릴게요.\n\n기본 HTML\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 제목\n\n부트스트랩 속성 추가\n\n\u003cheader class=\"bg-primary text-white text-center py-2\"\u003e\n    \u003ch1 class=\"display-4\"\u003e제목\u003c/h1\u003e\n    \u003cp class=\"lead\"\u003e부제목\u003c/p\u003e\n\u003c/header\u003e\n\n헤더는 `h1`과 단락 요소 `p` 두 가지 요소로 구성되어 있습니다. 부트스트랩 버전에서 이들 요소는 추가된 속성을 가지고 있습니다: 헤더 자체는 주요한 배경 색상으로 흰색 텍스트를 가지며, 텍스트는 가운데 정렬되고 위아래 패딩이 2픽셀로 설정됩니다; 제목 태그는 display-4 폰트를 사용하고 단락의 폰트는 lead로 설정되어 있습니다— display 폰트는 크고 굵고, lead는 강조해야 하는 일반 텍스트용으로 정의되어 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이러한 특성들은 HTML class 속성에서 설정됩니다. 코드에서 더 많이 볼 수 있으며, 이해하기 쉽게 될 것입니다. 자세히 설명하지는 않겠지만 부트스트랩 문서에서 관련 정보를 찾을 수 있습니다. 그 웹사이트에서 필요한 모든 정보를 얻을 수 있을 거에요.\n\n## 플라스크 프로젝트\n\n플라스크 프레임워크는 웹 기반 어플리케이션을 만들기 쉽게 도와줍니다. 플라스크 어플리케이션은 일반적으로 적어도 두 개 파일로 구성됩니다: 파이썬 앱과 HTML 템플릿입니다.\n\n파이썬 부분에는 어플리케이션 로직이 포함되어 있습니다. 예를 들어, 데이터 시각화 어플리케이션의 경우, 데이터를 Pandas 데이터프레임에로드하고, 분석을 수행하며 Plotly에서 차트를 생성할 수도 있습니다. HTML 템플릿은 웹페이지의 레이아웃을 정의하고, 파이썬 프로그램에 의해 표시할 데이터가 제공됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n/project_name\n    |--- app.py\n    |\n    |--- /templates\n            |\n            |--- index.html\n\n위의 다이어그램처럼 만들어야 할 간단한 앱의 디렉토리 구조입니다. 메인 Python 앱은 프로젝트 폴더에 있고 템플릿은 templates라는 서브폴더에 위치해 있습니다.\n\n물론 Flask를 설치해야 합니다:\n\npip install flask\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가상 환경을 먼저 만드시는 것이 좋습니다.\n\nFlask 앱의 Python 부분은 앱이 응답할 하나 이상의 라우트를 정의합니다. 일반적으로 그 라우트 중 하나는 프로젝트의 루트인 '/'입니다.\n\n아래는 템플릿을 사용하는 최소한의 Python 앱 예시입니다. 템플릿은 index.html이라는 이름이어야 하며 templates 폴더에 있어야 하며 render_template() 라이브러리 함수를 사용하여 Flask에서 웹페이지로 렌더링됩니다. 웹페이지의 제목에 해당하는 값을 생성하고 이를 함수에 전달하는 것에 유의하세요.\n\nfrom flask import Flask, render_template\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    title = \"이것이 제목입니다\"\n    return render_template('index.html', title=title)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 `title` 값이 인corporated되어야 하는 index.html 템플릿입니다. `h1` 태그 안에 `title` 식별자가 이중 중괄호로 둘러싸여 있음을 볼 수 있습니다.\n\n\u003c!DOCTYPE html\u003e\n\u003chtml\u003e\n\u003cbody\u003e\n   \u003ch1\u003e{title}\u003c/h1\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n\nFlask는 HTML 템플릿의 플레이스홀더를 render_template()에 전달된 값으로 대체하는 데 Jinja 템플릿 엔진을 사용합니다.\n\n터미널에서 flask run을 입력하여 애플리케이션을 실행하면 아래와 유사한 응답을 받게 됩니다. (만약 애플리케이션을 app.py로 호출했다면, flask --app app_name run을 입력해야 합니다. 여기서 app_name에는 .py 확장자를 제외한 앱의 이름을 입력해야 합니다.)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nflask run\n * Debug mode: off\n경고: 이는 개발 서버입니다. 제품 배포에는 사용하지 마십시오. 대신 제품 WSGI 서버를 사용하십시오.\n * http://127.0.0.1:5000에서 실행 중\nCTRL+C를 눌러 종료\n\n브라우저에서 http://127.0.0.1:5000 또는 localhost:5000을 입력하면, Python 코드에서 정의된 텍스트를 표시하는 간단한 웹 페이지가 표시됩니다.\n\nFlask에 대해 더 알아보려면, Quickstart 튜토리얼을 살펴보는 것에서 시작할 수 있지만, 여기에서 시작하는 데 필요한 모든 정보를 다룰 것을 희망합니다.\n\n# 정적 데이터 시각화 애플리케이션\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희 첫 번째 애플리케이션은 지금까지 본 내용을 기반으로 하여 Plotly 차트와 일부 보조 텍스트가 포함된 웹사이트를 생성합니다. 나중에는 상호 작용 기능을 추가할 예정입니다.\n\n파이썬 쪽에 대해 알아보겠습니다. 목록은 아래에 있지만 일단 #### Simple template ####로 시작하는 섹션에 집중해봅시다. 여기서 /simple이라는 경로를 정의했음을 확인할 수 있습니다. 이는 브라우저를 localhost:5000/simple로 가리킴으로써 앱을 호출하게 됩니다. 그리고 데코레이터 아래에 있는 함수 simpleindex()가 실행됩니다.\n\n이 함수에서 웹페이지에 표시할 일부 텍스트와 그래프를 설정합니다. 먼저 일부 변수를 설정하고, 그 변수들을 사용하여 HTML 템플릿이 사용할 매개변수 사전을 작성합니다. 변수들의 이름을 통해 어떻게 사용될지 명확히 알 수 있습니다.\n\n그래프 매개변수는 get_graph() 함수를 사용하여 설정됩니다. 먼저 전역 온도 이상치 데이터를 로드하고, 1881년부터 2022년까지의 데이터가 기후 변화가 시간에 따라 온도에 미치는 영향을 추적합니다 (이에 대한 자세한 내용은 2023년이 역대 최고의 여름이었음을 나타내는 새로운 데이터를 참조하십시오). 데이터는 아래 표에 표시됩니다 (그래프에서 더 잘 나타납니다!).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n정적 앱에는 6월, 7월 및 8월의 온도를 나타내는 단일 열 JJA를 사용할 것입니다. 대화형 앱은 나머지 몇 가지도 사용할 것이므로 현재 앱의 기간 매개변수에 대한 기본값을 설정하여 대화형 앱에서 나중에 변경할 수 있습니다.\n\n데이터는 Plotly 막대 차트를 생성하는 데 사용되며 생성된 도표는 JSON으로 변환됩니다. 그래서 이 JSON 데이터가 반환되어 사전의 매개변수에서 그래프 항목을 설정하는 데 사용됩니다.\n\n이전 함수로 돌아가서 설정한 매개변수를 사용하여 render_template를 호출해야 합니다. 타이핑을 줄이기 위해 template라는 도우미 함수를 만들었습니다. 이 함수는 템플릿 매개변수를 추출하고 모든 데이터를 웹페이지로 전달합니다.\n\n```python\nfrom flask import Flask, request, jsonify, render_template\nimport json\nimport pandas as pd\nimport plotly.express as px\n\napp = Flask(__name__)\n\ndef get_graph(period='JJA'):\n    df = pd.read_csv('GlobalTemps1880-2022.csv')\n    fig = px.bar(df, x='Year', y=period, \n                 color=period, title=period, \n                 color_continuous_scale='reds', \n                 template='plotly_white', width=1000, height=500)\n\n    graphJSON = fig.to_json()\n    return json.dumps(graphJSON)\n\ndef template(params):\n    return render_template(params['template'], params=params)\n\n#### App ####\n\n@app.route('/')\ndef index():\n    return render_template('index.html')\n\n#### Simple template ####\n\n@app.route('/simple')\ndef simpleindex():\n    header = \"Global Temperature\"\n    subheader = \"Global Temperature changes over the last few centuries\"\n    description = \"\"\"The graph shows the increase in temperature year on year.\n    The data spans the years 1881 to 2022 and includes temperature anomalies \n    for the months June through August.\n    \"\"\"\n    params = {\n        'template': 'simpleindex.html',\n        'title': header,\n        'subtitle': subheader,\n        'content': description,\n        'graph': get_graph()\n    }\n    return template(params)\n\n#### Main ####\n\nif __name__ == '__main__':\n    app.run(debug=True)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이젠 HTML 템플릿에 대해 이야기해볼게요. 아래 목록을 확인하고 좋은 소식은 `body`...`/body` 태그 내의 코드를 제외한 모든 것을 무시할 수 있다는 겁니다. 나머지는 Bootstrap과 Plotly를 사용하는 웹페이지에 필요한 보일러플레이트 코드이며, 비슷한 웹페이지에 붙여넣을 수 있습니다. 마지막 `script` 태그도 Bootstrap Javascript 코드를 포함하고 있어서 안심하고 무시할 수 있어요.\n\n```js\n    \u003cheader\u003e\n        \u003ch1\u003e{ params.title }\u003c/h1\u003e\n        \u003cp\u003e{ params.subtitle }\u003c/p\u003e\n    \u003c/header\u003e\n\n    \u003cdiv\"\u003e\n        \u003cdiv id='chart'\u003e\u003c/div\u003e\n        \u003cdiv\u003e{params.content}\u003c/div\u003e\n    \u003c/div\u003e\n    \u003cscript type='text/javascript'\u003e\n      var figure = JSON.parse({params.graph | safe})\n      Plotly.newPlot('chart', figure, {});\n    \u003c/script\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이전에도 Jinja 매개변수의 사용법을 보았었는데, 이번에는 몇 가지 매개변수를 params라는 딕셔너리로 묶었다는 점이 다릅니다. 따라서 이번에는 그들을 참조할 때 이름 앞에 딕셔너리의 이름을 붙여주어야 합니다. 따라서 `h1`'params.title'`/h1`은 간단히 제목 매개변수를 헤딩 태그 쌍에 넣는 것입니다. 텍스트 매개변수용의 나머지 세 태그도 비슷합니다.\n\n그래프를 그리기 위해서는 그것을 넣을 요소가 필요하며 그 요소에는 id 속성이 있어야 합니다(`div id=`chart/div`). 이 요소는 제목 아래와 설명 위에 위치합니다.\n\n이를 따르는 아래의 스크립트 요소는 다시 차트를 그리기 위해 Plotly Javascript를 호출하는 보일러플레이트 코드입니다. 여기서 주목해야 할 점은 그래프 매개변수를 포함할 때 safe 키워드를 사용한다는 것입니다. 이는 Jinja에게 그래프에 있는 특수 문자를 해석하지 말고, 그대로 사실 그대로 취급할 것을 지시합니다. 따라서 코드는 다음과 같습니다:\n\n```js\nvar figure = JSON.parse({params.graph | safe})\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제, 템플릿은 프로젝트 디렉토리의 templates 폴더에 있어야 한다는 것을 기억해주세요. 그리고 이 코드가 작동하려면 데이터 파일이 프로젝트 디렉토리 자체에 있어야 합니다. (물론 이동할 수 있지만 Python 프로그램에서 열 때 경로를 변경해야 합니다).\n\n앱을 실행하고 브라우저를 localhost:5000/simple로 이동하여 웹페이지를 보세요. 아마도 아래처럼 웹페이지가 나타날 것입니다.\n\n![웹 앱의 정적 버전](/assets/img/2024-06-23-FlapjaxDataVisualizationontheWebwithPlotlyandFlask_2.png)\n\n그리고 이것이 웹 앱의 정적 버전입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 대화형 데이터 시각화 애플리케이션\n\n하지만 여름에만 제한되어 있는 것이 아쉽지 않나요? 우리가 JJA 이외의 기간을 선택할 수 있다면 얼마나 좋을까요? 데이터에는 전체 연간, J-D 및 세 달 기간 (DJF, MAM, JJA 및 SON)을 위한 열도 포함되어 있습니다. (알파벳은 영어로 된 월 이름을 나타냅니다: 12월, 1월, 2월; 3월, 4월, 5월; 그 이후로 계속됩니다.)\n\n이를 위해 사용자가 적절한 기간을 선택할 수 있는 사용자 컨트롤을 통합해야 합니다. 저는 다양한 기간을 표시해 줄 드롭다운 메뉴를 선택했습니다. 이전 웹페이지와 꽤 유사하게 보일 것입니다(아래 이미지 참조).\n\n![Image](/assets/img/2024-06-23-FlapjaxDataVisualizationontheWebwithPlotlyandFlask_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 코드는 처음에는 꽤 유사합니다. 주요 차이점은 새로운 그래프를 선택할 때 발생합니다.\n\n새 값을 선택하면 Javascript 함수가 호출되어 해당 값을 서버의 콜백 함수로 보내고 응답을 기다립니다. 이 콜백 함수는 새로운 차트를 반환하고, 호출하는 Javascript에 의해 표시됩니다.\n\n먼저 익숙한 내용을 다뤄 봅시다. 아래에 새로운 엔드포인트 /ddsimple을 구현하는 함수가 있습니다.\n\n```js\n@app.route('/ddsimple')\ndef ddsimpleindex():\n    # Root 엔드포인트는 페이지를 만듭니다.\n    header = \"지구 온도\"\n    subheader = \"지난 몇 세기 동안의 지구 온도 변화\"\n    description = \"\"\"그래프는 연도별 온도 증가를 보여줍니다.\n    데이터는 1881년부터 2022년까지의 기간을 포함하며, 각 연도의 온도 이상치를 표시합니다.\n    \"\"\"\n    menu_label = \"기간을 선택하세요\"\n\n    params = {    \n        'template': 'ddsimpleindex.html',\n        'title': header,\n        'subtitle': subheader,\n        'content' : description,\n        'menu_label': menu_label,\n        'options' : [{'code':'J-D', 'desc':'전체 연도'},\n                     {'code':'DJF','desc':'겨울 (북반구)'},\n                     {'code':'MAM','desc':'봄 (북반구)'},\n                     {'code':'JJA','desc':'여름 (북반구)'},\n                     {'code':'SON','desc':'가을 (북반구)'}],\n        'graph'   : get_graph()\n    }\n    return template(params)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 코드를 Markdown 형식으로 변경하려면 아래와 같이 변경하실 수 있습니다.\n\n```js\n\u003cform id=\"userForm\" name=\"form1\" onChange=\"getFormValues('form1')\"\u003e\n    \u003cdiv class=\"mb-3\"\u003e\n        \u003clabel for=\"dropdown\" class=\"form-label lead\"\u003e{{params.menu_label}}\u003c/label\u003e\n        \u003cselect class=\"form-select\" id=\"dropdown\" name=\"dropdown\"\u003e\n            {% for opt in params.options %}\n                \u003coption value=\"{{opt.code}}\"\u003e{{opt.desc}}\u003c/option\u003e\n            {% endfor %}\n        \u003c/select\u003e\n    \u003c/div\u003e\n\u003c/form\u003e\n\u003cdiv\u003e\n    \u003c!-- Main Content Area --\u003e\n    \u003cp class=\"lead\"\u003e{{params.content}}\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv id=\"graph\"\u003e\u003c/div\u003e\n```\n\n이렇게하면 드롭다운 메뉴가 포함된 양식을 만들 수 있습니다. 양식에는 이전에 본 두 개의 중괄호로 포함된 메뉴에 대한 레이블도 포함되어 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이전 예제와의 주요 차이점은 메뉴가 구성되는 방식입니다. `select` 요소 내부에는 메뉴에서 제공된 옵션을 나타내는 `option` 태그 목록을 넣어야 합니다. 옵션 태그에는 값과 설명이 있습니다. 이 값들과 설명들은 우리가 params.options 딕셔너리에 정의한 것입니다. 우리는 이 값을 포함하기 위해 ' for opt in param.options '와 같은 Jinja 반복문을 실행하여 딕셔너리를 반복하며 각 요소를 opt라는 지역 변수에 넣습니다. 그런 다음 opt.code와 opt.desc 값을 사용하여 이 값을 옵션 태그에 삽입합니다.\n\nFlask 튜토리얼: Pythonbasics.org 웹사이트의 Templates에서 Jinja 템플릿의 간단한 예제와 설명을 찾을 수 있습니다.\n\n여기에는 우리 목적에 중요한 form 태그의 다른 부분이 있습니다. form 태그 내부에는 onChange라는 속성이 있는데, 이 속성은 어떤 동작의 값을 취합니다. 이 경우에는 폼의 값이 변경될 때 호출되는 자바스크립트 함수입니다. 이 경우에는 메뉴에서 옵션 중 하나를 선택했을 때입니다.\n\n그리고 재미 있는 부분이 여기에서 시작됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 콜백\n\n웹 페이지를 새 차트로 업데이트하기 위해 콜백 메커니즘을 사용하며 아래 차트는 브라우저와 서버 간의 트랜잭션을 보여줍니다. 새 차트를 요청한 응답은 페이지를 다시로드하는 것이 아니라 업데이트하는 것임을 유의하세요. 이는 빠르며 잠깐의 빈 화면을 보여주지 않아 사용자 경험이 훨씬 더 좋아집니다.\n\n![차트 이미지](/assets/img/2024-06-23-FlapjaxDataVisualizationontheWebwithPlotlyandFlask_4.png)\n\n콜백은 웹 페이지의 양식 변경에 의해 호출됩니다, 이전에 언급한대로. 이것을 위한 메커니즘은 양식의 onChange 속성에 식별된 자바스크립트 함수입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자바스크립트 함수가 어떻게 작동하는지 자세히 설명하려고 합니다. 여기서 기본적으로, 이 함수는 폼에서 값을 가져와 Flask 앱의 콜백 엔드포인트로 보냅니다.\n\n자바스크립트를 작성하는 것이 걱정되시는 분들은 걱정하지 마세요. 이것이 어떻게 작동하는지 알 필요는 없습니다. 그냥 복사해서 사용하면 여러분이 웹 페이지에 포함하고 싶은 어떤 폼이든 작동합니다. \n\n더 자세한 설명을 읽고 싶으신 모험가들을 위해 아래에 설명을 제공하겠지만, 그렇지 않은 분들은 다음 섹션으로 건너뛰어도 괜찮습니다.\n\n실제로 두 개의 함수가 있습니다. 폼에서 값을 가져오는 함수는 아래와 같습니다.\n\n```js\n        function getFormValues(f) {\n            const form = document.forms.namedItem(f);\n            const formData = new FormData(form);\n            const value = Object.fromEntries(formData.entries());\n            postJSON(value);\n        }\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모든 코드는 내장된 JavaScript 함수를 사용합니다: 첫 번째 줄은 문서(즉, 웹 페이지)에서 폼을 가져오고, 두 번째 줄은 폼 데이터를 포함하는 데이터 구조체를 검색하며, 세 번째 줄은 해당 구조체에서 모든 값을 추출합니다.\n\n마지막으로, 이러한 값들은 다른 함수 'postJson'에 전달됩니다.\n\n```js\n        async function postJSON(data) {\n            try {\n                const response = await fetch(\"/callback\", {\n                    method: \"POST\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                    },\n                    body: JSON.stringify(data),\n                });\n\n                const result = await response.json();\n                console.log(\"Success:\");//, result);\n\n                drawGraph(result);\n            }\n            catch (error) {\n                console.error(\"Error:\", error);\n            }\n        }\n```\n\n이 함수는 비동기 함수이므로 호출된 후 프로그램 실행이 즉시 호출한 코드로 돌아가고, 비동기 함수는 별도의 실행 스레드에서 계속 실행됩니다. 즉, 웹 페이지의 실행과 병렬로 수행해야 할 작업을 계속합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\npostJSON은 Python 콜백 코드로 전송해야 하는 데이터를 받아서 비동기 fetch 함수를 사용하여 전송합니다. fetch는 데이터가 전달되어야 하는 엔드포인트와 데이터 자체를 매개변수로 받습니다. 데이터를 전송하기 위해 HTTP POST 메커니즘을 사용합니다. postJSON은 fetch가 완료될 때까지 기다린 후, 즉 서버로부터 일부 데이터가 반환될 때까지 기다립니다. 그런 데이터는 그래프를 업데이트하는 drawGraph 함수로 전달됩니다.\n\n코드는 try... catch... 블록에 포함되어 있음을 유의해주세요. 이는 Python 프로그램에서 발견할 수 있는 것과 거의 동일합니다. 즉, try 블록의 코드가 실패하면 — 응답이 없거나 다른 통신 오류가 발생하면 — 해당 실패는 콘솔에 로깅됩니다.\n\n## Python 콜백\n\n이 모든 것이 작동하려면 Flask 코드에 데이터를 받고 처리한 후(예: 새로운 그래프 만들기) 결과를 다시 보내는 콜백 함수가 필요합니다. 여기에 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\n# 콜백의 엔드포인트를 정의하는 것이 첫 번째 작업입니다. 엔드포인트가 POST 방식으로 데이터를 보내는 것을 명시해야 합니다.\n\n@app.route('/callback', methods=['POST'])\ndef callback():\n    # 콜백은 페이지를 업데이트합니다.\n    if request.is_json:\n        data = request.get_json() \n        return get_graph(period=data['dropdown'])\n    else:\n        return jsonify({\"error\": \"잘못된 JSON 데이터입니다\"}), 400\n```\n\n콜백의 엔드포인트를 정의하는 것이 첫 번째 작업입니다. 엔드포인트가 POST 방식으로 데이터를 보내는 것을 명시해야 합니다.\n\n또한 데이터가 JSON 형식으로 제공되기를 기대하는데, 그렇지 않은 경우 오류를 반환합니다.\n\n데이터가 JSON이라면 드롭다운 메뉴에서 값을 추출하여 get_graph 함수에 전달하고, 이 함수는 그래프를 그리고 Plotly가 예상하는 JSON 형식으로 반환합니다. 이 그래프 데이터는 웹페이지의 JavaScript 함수에 의해 받아들여지고 페이지가 업데이트됩니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 코드를 사용하면 상단에 있는 대화형 웹 페이지를 제공합니다.\n\n## Flapjax — 이름의 의미\n\n정말이지, 이것은 매우 인위적인 이름입니다: Flask, Python, Javascript 및 ax를 나타내며 이 기법을 가능케 하는 비동기 통신을 의미합니다.\n\n미리 작성된 템플릿과 상당량의 보일러플레이트 코드를 사용하여 Python 코드의 로직에 대부분 집중하면서 유용한 대화형 웹 페이지를 만들 수 있다는 점을 보실 수 있기를 바랍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 앱에는 사용자가 새 옵션을 선택할 때 업데이트되는 단일 그래프만 포함되어 있지만 HTML 폼에서 수집할 수 있는 값의 수는 무한입니다. 이 값들은 Flask 앱에 의해 처리된 후 새로운 정보로 웹페이지가 업데이트됩니다. (아마 나중에 이에 대해 자세히 다룰 수도 있을 것입니다).\n\n여기에 설명된 모든 코드와 데이터는 제 GitHub 리포지토리에서 다운로드할 수 있습니다. (jinja-article 폴더를 참조해주세요).\n\n업데이트: GitHub 리포지토리의 reuse 폴더에 새 데이터 세트로 새 앱을 생성하는 새 앱을 작성했습니다. HTML 및 Javascript는 동일하며 Python 코드와 데이터만 변경되었습니다:\nFlapjax 템플릿 및 코드 재사용\n\n이 정보가 유용하게 느껴지길 바랍니다. 제 작업을 더 알아보고 싶으시면 웹사이트를 방문하시거나 무료 뉴스레터를 구독함으로써 발행 시 알림을 받을 수 있습니다. (여기를 참조해주세요)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 플라스크가 원하는 것이 아니라면, 내가 미디엄 기사를 기반으로 작성한 eBook Streamlit from Scratch을 읽어보세요.\n\n## 참고 자료\n\n이 기사와 앱에서 사용된 데이터는 아래 1번과 2번에서 설명된 것을 기반으로 합니다.\n\n- GISTEMP 팀, 2023: GISS 표면 온도 분석 (GISTEMP), 버전 4. NASA Goddard 우주 연구소. 데이터 세트는 2023년 9월 19일 data.giss.nasa.gov/gistemp/에서 액세스되었습니다. NASA의 데이터 세트에 대한 구체적인 라이선스가 없음에 유의하십시오. 이러한 데이터는 비상업적 목적으로 NASA에 의해 자유롭게 제공되지만 (위와 같이) 언급이 되어야 합니다.\n- Lenssen, N., G. Schmidt, J. Hansen, M. Menne, A. Persin, R. Ruedy, and D. Zyss, 2019: GISTEMP 불확실성 모델의 개선. 대기.지구물리학.연구.저널, 124권, 12호, 6307–6326, doi:10.1029/2018JD029522.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저자가 별도로 표기하지 않은 경우, 모든 이미지, 다이어그램, 스크린샷 및 코드는 저자가 제작했습니다.","ogImage":{"url":"/assets/img/2024-06-23-FlapjaxDataVisualizationontheWebwithPlotlyandFlask_0.png"},"coverImage":"/assets/img/2024-06-23-FlapjaxDataVisualizationontheWebwithPlotlyandFlask_0.png","tag":["Tech"],"readingTime":17},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e데이터 시각화 앱을 구축하는 가장 좋은 프레임워크는 무엇인가요? Streamlit이나 Dash일까요? 아니면 Jupyter Notebook을 Mercury나 Voilá로 변환하여 바로 웹 앱을 만드는 것일까요?\u003c/p\u003e\n\u003cp\u003e이 모든 것들은 애플리케이션을 만드는 좋은 방법이며 시작하기 쉽습니다. 하지만 시작하기 쉬운 것이 결국 더 모험적인 영역으로 발전할 수 있습니다. 그래서 저는 다시 기초로 돌아가 Python 서버 코드와 HTML 페이지를 함께 사용하는 것이 생각보다 어려운 일이 아니라고 설득하려고 합니다.\u003c/p\u003e\n\u003cp\u003e우리는 상당량의 보일러플레이트 코드와 템플릿을 활용하여 매력적인 대화형 애플리케이션을 만들 수 있습니다. 이는 여전히 Python 코드에 집중할 수 있게 해주며 HTML 및 JavaScript에 공부할 부담이 적다는 것을 의미합니다. 저는 이 접근 방식을 Flapjax라고 부릅니다 — 나중에 왜 이렇게 부르는지 설명하겠습니다.\u003c/p\u003e\n\u003cp\u003ePython으로 웹 애플리케이션을 만드는 가장 간단한 방법 중 하나는 Flask를 사용하는 것이므로, 이를 사용하여 아래 이미지와 같은 앱을 만들어보겠습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-FlapjaxDataVisualizationontheWebwithPlotlyandFlask_0.png\" alt=\"Flask Framework\"\u003e\u003c/p\u003e\n\u003ch2\u003e플라스크 프레임워크\u003c/h2\u003e\n\u003cp\u003eFlask는 웹 애플리케이션을 개발하기 위한 최소주의 프레임워크입니다. Flask 앱에서는 웹 페이지가 일반적으로 템플릿과 파이썬 코드에서 제공된 데이터로 구성됩니다. 이 데이터는 웹 페이지의 내용을 형성하는 텍스트나 그래픽일 수 있습니다. 결과물은 사용자에게 브라우저에서 표시되도록 전송됩니다.\u003c/p\u003e\n\u003cp\u003e아래 다이어그램은 인터랙티브 앱의 기본 구조를 보여줍니다. 앱이 실행 중일 때, Python 부분은 서버에서 실행되고 브라우저에서 실행되는 HTML로 데이터를 전송합니다. 웹 페이지에서 사용자 입력이 다시 Python 코드로 전달되며, 이후 Python 코드는 더 많은 데이터를 전송하여 사용자가 선택한 새로운 콘텐츠 - 사용자가 선택한 새로운 차트와 같은 - 로 HTML을 업데이트할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-FlapjaxDataVisualizationontheWebwithPlotlyandFlask_1.png\" alt=\"Flapjax Data Visualization on the Web with Plotly and Flask\"\u003e\u003c/p\u003e\n\u003cp\u003e웹 애플리케이션을 만드는 가장 쉬운 방법인가요?\u003c/p\u003e\n\u003cp\u003e내 생각에는 사용자 인터페이스 디자인과 프로그램 로직을 분리하는 것이 정말 쉽게 만드는 방법입니다. 그러나 Streamlit이나 Jupyter Notebooks에서 앱을 만드는 데 익숙하다면, 처음에는 학습 곡선이 존재할 수 있습니다. 그러나 기본 애플리케이션을 위한 패턴을 채택한 후에는 새로운 애플리케이션을 만드는 것이 훨씬 쉬워집니다.\u003c/p\u003e\n\u003cp\u003e그래서, 우리는 Flask를 사용하여 데이터 시각화 애플리케이션을 개발하고, HTML 페이지를 정의하는 Jinja 템플릿을 사용할 것입니다. 하지만 이 페이지에 나타나는 실제 데이터는 Python 코드에서 정의될 것입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e인터랙티브한 사용자 인터페이스를 만들기 위해서는 일부 UI 구성 요소와 작은 양의 JavaScript가 필요합니다. 그러나 보시다시피 이는 앞으로의 애플리케이션에서 재사용 가능한 코드로 거의 표준 코드라는 것을 확인할 것입니다.\u003c/p\u003e\n\u003cp\u003e또한 웹 페이지가 왼쪽과 같이 보이는 것으로 만족하는 대신 약간의 노력으로 오른쪽과 같이 만들 수 있기 때문에 Bootstrap 5 UI 구성 요소를 사용할 것입니다.\u003c/p\u003e\n\u003cp\u003e이 자습서는 두 부분으로 나뉘어 있습니다. 먼저 정적 웹페이지를 만들고 Flask와 HTML이 어떻게 함께 작동하는지 파악한 다음 콜백을 다루어 인터랙티브 페이지를 만들 것입니다.\u003c/p\u003e\n\u003cp\u003e이 문서의 모든 코드는 내 GitHub 저장소에 있을 것입니다. 발행 후 곧바로 이를 링크할 것입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e부트스트랩 UI\u003c/h2\u003e\n\u003cp\u003e부트스트랩을 사용하면 매력적인 웹페이지를 손쉽게 만들 수 있어요. Bootstrap 5 파일을 포함하고 HTML 요소에 몇 가지 속성을 추가하면 기본 HTML을 쉽게 개선할 수 있어요.\u003c/p\u003e\n\u003cp\u003e부트스트랩 튜토리얼은 아니지만 위 웹페이지의 헤더를 만드는 기본 HTML 코드의 차이를 빨리 보여드릴게요.\u003c/p\u003e\n\u003cp\u003e기본 HTML\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 제목\n\n부트스트랩 속성 추가\n\n\u0026#x3C;header \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"bg-primary text-white text-center py-2\"\u003c/span\u003e\u003e\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"display-4\"\u003c/span\u003e\u003e\u003c/span\u003e제목\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"lead\"\u003c/span\u003e\u003e\u003c/span\u003e부제목\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u0026#x3C;/header\u003e\n\n헤더는 \u003cspan class=\"hljs-string\"\u003e`h1`\u003c/span\u003e과 단락 요소 \u003cspan class=\"hljs-string\"\u003e`p`\u003c/span\u003e 두 가지 요소로 구성되어 있습니다. 부트스트랩 버전에서 이들 요소는 추가된 속성을 가지고 있습니다: 헤더 자체는 주요한 배경 색상으로 흰색 텍스트를 가지며, 텍스트는 가운데 정렬되고 위아래 패딩이 \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e픽셀로 설정됩니다; 제목 태그는 display-\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e 폰트를 사용하고 단락의 폰트는 lead로 설정되어 있습니다— display 폰트는 크고 굵고, lead는 강조해야 하는 일반 텍스트용으로 정의되어 있습니다.\n\n\u0026#x3C;div \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"content-ad\"\u003c/span\u003e\u003e\u0026#x3C;/div\u003e\n\n이러한 특성들은 \u003cspan class=\"hljs-variable constant_\"\u003eHTML\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e 속성에서 설정됩니다. 코드에서 더 많이 볼 수 있으며, 이해하기 쉽게 될 것입니다. 자세히 설명하지는 않겠지만 부트스트랩 문서에서 관련 정보를 찾을 수 있습니다. 그 웹사이트에서 필요한 모든 정보를 얻을 수 있을 거에요.\n\n## 플라스크 프로젝트\n\n플라스크 프레임워크는 웹 기반 어플리케이션을 만들기 쉽게 도와줍니다. 플라스크 어플리케이션은 일반적으로 적어도 두 개 파일로 구성됩니다: 파이썬 앱과 \u003cspan class=\"hljs-variable constant_\"\u003eHTML\u003c/span\u003e 템플릿입니다.\n\n파이썬 부분에는 어플리케이션 로직이 포함되어 있습니다. 예를 들어, 데이터 시각화 어플리케이션의 경우, 데이터를 \u003cspan class=\"hljs-title class_\"\u003ePandas\u003c/span\u003e 데이터프레임에로드하고, 분석을 수행하며 \u003cspan class=\"hljs-title class_\"\u003ePlotly\u003c/span\u003e에서 차트를 생성할 수도 있습니다. \u003cspan class=\"hljs-variable constant_\"\u003eHTML\u003c/span\u003e 템플릿은 웹페이지의 레이아웃을 정의하고, 파이썬 프로그램에 의해 표시할 데이터가 제공됩니다.\n\n\u0026#x3C;div \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"content-ad\"\u003c/span\u003e\u003e\u0026#x3C;/div\u003e\n\n/project_name\n    |--- app.\u003cspan class=\"hljs-property\"\u003epy\u003c/span\u003e\n    |\n    |--- /templates\n            |\n            |--- index.\u003cspan class=\"hljs-property\"\u003ehtml\u003c/span\u003e\n\n위의 다이어그램처럼 만들어야 할 간단한 앱의 디렉토리 구조입니다. 메인 \u003cspan class=\"hljs-title class_\"\u003ePython\u003c/span\u003e 앱은 프로젝트 폴더에 있고 템플릿은 templates라는 서브폴더에 위치해 있습니다.\n\n물론 \u003cspan class=\"hljs-title class_\"\u003eFlask\u003c/span\u003e를 설치해야 합니다:\n\npip install flask\n\n\u0026#x3C;div \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"content-ad\"\u003c/span\u003e\u003e\u0026#x3C;/div\u003e\n\n가상 환경을 먼저 만드시는 것이 좋습니다.\n\n\u003cspan class=\"hljs-title class_\"\u003eFlask\u003c/span\u003e 앱의 \u003cspan class=\"hljs-title class_\"\u003ePython\u003c/span\u003e 부분은 앱이 응답할 하나 이상의 라우트를 정의합니다. 일반적으로 그 라우트 중 하나는 프로젝트의 루트인 \u003cspan class=\"hljs-string\"\u003e'/'\u003c/span\u003e입니다.\n\n아래는 템플릿을 사용하는 최소한의 \u003cspan class=\"hljs-title class_\"\u003ePython\u003c/span\u003e 앱 예시입니다. 템플릿은 index.\u003cspan class=\"hljs-property\"\u003ehtml\u003c/span\u003e이라는 이름이어야 하며 templates 폴더에 있어야 하며 \u003cspan class=\"hljs-title function_\"\u003erender_template\u003c/span\u003e() 라이브러리 함수를 사용하여 \u003cspan class=\"hljs-title class_\"\u003eFlask\u003c/span\u003e에서 웹페이지로 렌더링됩니다. 웹페이지의 제목에 해당하는 값을 생성하고 이를 함수에 전달하는 것에 유의하세요.\n\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e flask \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFlask\u003c/span\u003e, render_template\n\napp = \u003cspan class=\"hljs-title class_\"\u003eFlask\u003c/span\u003e(__name__)\n\n@app.\u003cspan class=\"hljs-title function_\"\u003eroute\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/'\u003c/span\u003e)\ndef \u003cspan class=\"hljs-title function_\"\u003eindex\u003c/span\u003e():\n    title = \u003cspan class=\"hljs-string\"\u003e\"이것이 제목입니다\"\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erender_template\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'index.html'\u003c/span\u003e, title=title)\n\n\u0026#x3C;div \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"content-ad\"\u003c/span\u003e\u003e\u0026#x3C;/div\u003e\n\n아래는 \u003cspan class=\"hljs-string\"\u003e`title`\u003c/span\u003e 값이 인corporated되어야 하는 index.\u003cspan class=\"hljs-property\"\u003ehtml\u003c/span\u003e 템플릿입니다. \u003cspan class=\"hljs-string\"\u003e`h1`\u003c/span\u003e 태그 안에 \u003cspan class=\"hljs-string\"\u003e`title`\u003c/span\u003e 식별자가 이중 중괄호로 둘러싸여 있음을 볼 수 있습니다.\n\n\u0026#x3C;!\u003cspan class=\"hljs-variable constant_\"\u003eDOCTYPE\u003c/span\u003e html\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ehtml\u003c/span\u003e\u003e\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebody\u003c/span\u003e\u003e\u003c/span\u003e\n   \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e{title}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebody\u003c/span\u003e\u003e\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ehtml\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\n\u003cspan class=\"hljs-title class_\"\u003eFlask\u003c/span\u003e는 \u003cspan class=\"hljs-variable constant_\"\u003eHTML\u003c/span\u003e 템플릿의 플레이스홀더를 \u003cspan class=\"hljs-title function_\"\u003erender_template\u003c/span\u003e()에 전달된 값으로 대체하는 데 \u003cspan class=\"hljs-title class_\"\u003eJinja\u003c/span\u003e 템플릿 엔진을 사용합니다.\n\n터미널에서 flask run을 입력하여 애플리케이션을 실행하면 아래와 유사한 응답을 받게 됩니다. (만약 애플리케이션을 app.\u003cspan class=\"hljs-property\"\u003epy\u003c/span\u003e로 호출했다면, flask --app app_name run을 입력해야 합니다. 여기서 app_name에는 .\u003cspan class=\"hljs-property\"\u003epy\u003c/span\u003e 확장자를 제외한 앱의 이름을 입력해야 합니다.)\n\n\u0026#x3C;div \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"content-ad\"\u003c/span\u003e\u003e\u0026#x3C;/div\u003e\n\nflask run\n * \u003cspan class=\"hljs-title class_\"\u003eDebug\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003emode\u003c/span\u003e: off\n경고: 이는 개발 서버입니다. 제품 배포에는 사용하지 마십시오. 대신 제품 \u003cspan class=\"hljs-variable constant_\"\u003eWSGI\u003c/span\u003e 서버를 사용하십시오.\n * \u003cspan class=\"hljs-attr\"\u003ehttp\u003c/span\u003e:\u003cspan class=\"hljs-comment\"\u003e//127.0.0.1:5000에서 실행 중\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eCTRL\u003c/span\u003e+C를 눌러 종료\n\n브라우저에서 \u003cspan class=\"hljs-attr\"\u003ehttp\u003c/span\u003e:\u003cspan class=\"hljs-comment\"\u003e//127.0.0.1:5000 또는 localhost:5000을 입력하면, Python 코드에서 정의된 텍스트를 표시하는 간단한 웹 페이지가 표시됩니다.\u003c/span\u003e\n\n\u003cspan class=\"hljs-title class_\"\u003eFlask\u003c/span\u003e에 대해 더 알아보려면, \u003cspan class=\"hljs-title class_\"\u003eQuickstart\u003c/span\u003e 튜토리얼을 살펴보는 것에서 시작할 수 있지만, 여기에서 시작하는 데 필요한 모든 정보를 다룰 것을 희망합니다.\n\n# 정적 데이터 시각화 애플리케이션\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e저희 첫 번째 애플리케이션은 지금까지 본 내용을 기반으로 하여 Plotly 차트와 일부 보조 텍스트가 포함된 웹사이트를 생성합니다. 나중에는 상호 작용 기능을 추가할 예정입니다.\u003c/p\u003e\n\u003cp\u003e파이썬 쪽에 대해 알아보겠습니다. 목록은 아래에 있지만 일단 #### Simple template ####로 시작하는 섹션에 집중해봅시다. 여기서 /simple이라는 경로를 정의했음을 확인할 수 있습니다. 이는 브라우저를 localhost:5000/simple로 가리킴으로써 앱을 호출하게 됩니다. 그리고 데코레이터 아래에 있는 함수 simpleindex()가 실행됩니다.\u003c/p\u003e\n\u003cp\u003e이 함수에서 웹페이지에 표시할 일부 텍스트와 그래프를 설정합니다. 먼저 일부 변수를 설정하고, 그 변수들을 사용하여 HTML 템플릿이 사용할 매개변수 사전을 작성합니다. 변수들의 이름을 통해 어떻게 사용될지 명확히 알 수 있습니다.\u003c/p\u003e\n\u003cp\u003e그래프 매개변수는 get_graph() 함수를 사용하여 설정됩니다. 먼저 전역 온도 이상치 데이터를 로드하고, 1881년부터 2022년까지의 데이터가 기후 변화가 시간에 따라 온도에 미치는 영향을 추적합니다 (이에 대한 자세한 내용은 2023년이 역대 최고의 여름이었음을 나타내는 새로운 데이터를 참조하십시오). 데이터는 아래 표에 표시됩니다 (그래프에서 더 잘 나타납니다!).\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e정적 앱에는 6월, 7월 및 8월의 온도를 나타내는 단일 열 JJA를 사용할 것입니다. 대화형 앱은 나머지 몇 가지도 사용할 것이므로 현재 앱의 기간 매개변수에 대한 기본값을 설정하여 대화형 앱에서 나중에 변경할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e데이터는 Plotly 막대 차트를 생성하는 데 사용되며 생성된 도표는 JSON으로 변환됩니다. 그래서 이 JSON 데이터가 반환되어 사전의 매개변수에서 그래프 항목을 설정하는 데 사용됩니다.\u003c/p\u003e\n\u003cp\u003e이전 함수로 돌아가서 설정한 매개변수를 사용하여 render_template를 호출해야 합니다. 타이핑을 줄이기 위해 template라는 도우미 함수를 만들었습니다. 이 함수는 템플릿 매개변수를 추출하고 모든 데이터를 웹페이지로 전달합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e flask \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e Flask, request, jsonify, render_template\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e json\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e pandas \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e pd\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e plotly.express \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e px\n\napp = Flask(__name__)\n\n\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eget_graph\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eperiod=\u003cspan class=\"hljs-string\"\u003e'JJA'\u003c/span\u003e\u003c/span\u003e):\n    df = pd.read_csv(\u003cspan class=\"hljs-string\"\u003e'GlobalTemps1880-2022.csv'\u003c/span\u003e)\n    fig = px.bar(df, x=\u003cspan class=\"hljs-string\"\u003e'Year'\u003c/span\u003e, y=period, \n                 color=period, title=period, \n                 color_continuous_scale=\u003cspan class=\"hljs-string\"\u003e'reds'\u003c/span\u003e, \n                 template=\u003cspan class=\"hljs-string\"\u003e'plotly_white'\u003c/span\u003e, width=\u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e, height=\u003cspan class=\"hljs-number\"\u003e500\u003c/span\u003e)\n\n    graphJSON = fig.to_json()\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e json.dumps(graphJSON)\n\n\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003etemplate\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eparams\u003c/span\u003e):\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e render_template(params[\u003cspan class=\"hljs-string\"\u003e'template'\u003c/span\u003e], params=params)\n\n\u003cspan class=\"hljs-comment\"\u003e#### App ####\u003c/span\u003e\n\n\u003cspan class=\"hljs-meta\"\u003e@app.route(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-string\"\u003e'/'\u003c/span\u003e\u003c/span\u003e)\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eindex\u003c/span\u003e():\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e render_template(\u003cspan class=\"hljs-string\"\u003e'index.html'\u003c/span\u003e)\n\n\u003cspan class=\"hljs-comment\"\u003e#### Simple template ####\u003c/span\u003e\n\n\u003cspan class=\"hljs-meta\"\u003e@app.route(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-string\"\u003e'/simple'\u003c/span\u003e\u003c/span\u003e)\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esimpleindex\u003c/span\u003e():\n    header = \u003cspan class=\"hljs-string\"\u003e\"Global Temperature\"\u003c/span\u003e\n    subheader = \u003cspan class=\"hljs-string\"\u003e\"Global Temperature changes over the last few centuries\"\u003c/span\u003e\n    description = \u003cspan class=\"hljs-string\"\u003e\"\"\"The graph shows the increase in temperature year on year.\n    The data spans the years 1881 to 2022 and includes temperature anomalies \n    for the months June through August.\n    \"\"\"\u003c/span\u003e\n    params = {\n        \u003cspan class=\"hljs-string\"\u003e'template'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'simpleindex.html'\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e'title'\u003c/span\u003e: header,\n        \u003cspan class=\"hljs-string\"\u003e'subtitle'\u003c/span\u003e: subheader,\n        \u003cspan class=\"hljs-string\"\u003e'content'\u003c/span\u003e: description,\n        \u003cspan class=\"hljs-string\"\u003e'graph'\u003c/span\u003e: get_graph()\n    }\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e template(params)\n\n\u003cspan class=\"hljs-comment\"\u003e#### Main ####\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e __name__ == \u003cspan class=\"hljs-string\"\u003e'__main__'\u003c/span\u003e:\n    app.run(debug=\u003cspan class=\"hljs-literal\"\u003eTrue\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이젠 HTML 템플릿에 대해 이야기해볼게요. 아래 목록을 확인하고 좋은 소식은 \u003ccode\u003ebody\u003c/code\u003e...\u003ccode\u003e/body\u003c/code\u003e 태그 내의 코드를 제외한 모든 것을 무시할 수 있다는 겁니다. 나머지는 Bootstrap과 Plotly를 사용하는 웹페이지에 필요한 보일러플레이트 코드이며, 비슷한 웹페이지에 붙여넣을 수 있습니다. 마지막 \u003ccode\u003escript\u003c/code\u003e 태그도 Bootstrap Javascript 코드를 포함하고 있어서 안심하고 무시할 수 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e    \u0026#x3C;header\u003e\n        \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e{ params.title }\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n        \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e{ params.subtitle }\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n    \u0026#x3C;/header\u003e\n\n    \u003cspan class=\"xml\"\u003e\u0026#x3C;div\"\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e'chart'\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e{params.content}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e'text/javascript'\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"javascript\"\u003e\n      \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e figure = \u003cspan class=\"hljs-title class_\"\u003eJSON\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eparse\u003c/span\u003e({params.\u003cspan class=\"hljs-property\"\u003egraph\u003c/span\u003e | safe})\n      \u003cspan class=\"hljs-title class_\"\u003ePlotly\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enewPlot\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'chart'\u003c/span\u003e, figure, {});\n    \u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이전에도 Jinja 매개변수의 사용법을 보았었는데, 이번에는 몇 가지 매개변수를 params라는 딕셔너리로 묶었다는 점이 다릅니다. 따라서 이번에는 그들을 참조할 때 이름 앞에 딕셔너리의 이름을 붙여주어야 합니다. 따라서 \u003ccode\u003eh1\u003c/code\u003e'params.title'\u003ccode\u003e/h1\u003c/code\u003e은 간단히 제목 매개변수를 헤딩 태그 쌍에 넣는 것입니다. 텍스트 매개변수용의 나머지 세 태그도 비슷합니다.\u003c/p\u003e\n\u003cp\u003e그래프를 그리기 위해서는 그것을 넣을 요소가 필요하며 그 요소에는 id 속성이 있어야 합니다(\u003ccode\u003ediv id=\u003c/code\u003echart/div`). 이 요소는 제목 아래와 설명 위에 위치합니다.\u003c/p\u003e\n\u003cp\u003e이를 따르는 아래의 스크립트 요소는 다시 차트를 그리기 위해 Plotly Javascript를 호출하는 보일러플레이트 코드입니다. 여기서 주목해야 할 점은 그래프 매개변수를 포함할 때 safe 키워드를 사용한다는 것입니다. 이는 Jinja에게 그래프에 있는 특수 문자를 해석하지 말고, 그대로 사실 그대로 취급할 것을 지시합니다. 따라서 코드는 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e figure = \u003cspan class=\"hljs-title class_\"\u003eJSON\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eparse\u003c/span\u003e({params.\u003cspan class=\"hljs-property\"\u003egraph\u003c/span\u003e | safe})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이제, 템플릿은 프로젝트 디렉토리의 templates 폴더에 있어야 한다는 것을 기억해주세요. 그리고 이 코드가 작동하려면 데이터 파일이 프로젝트 디렉토리 자체에 있어야 합니다. (물론 이동할 수 있지만 Python 프로그램에서 열 때 경로를 변경해야 합니다).\u003c/p\u003e\n\u003cp\u003e앱을 실행하고 브라우저를 localhost:5000/simple로 이동하여 웹페이지를 보세요. 아마도 아래처럼 웹페이지가 나타날 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-FlapjaxDataVisualizationontheWebwithPlotlyandFlask_2.png\" alt=\"웹 앱의 정적 버전\"\u003e\u003c/p\u003e\n\u003cp\u003e그리고 이것이 웹 앱의 정적 버전입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e대화형 데이터 시각화 애플리케이션\u003c/h1\u003e\n\u003cp\u003e하지만 여름에만 제한되어 있는 것이 아쉽지 않나요? 우리가 JJA 이외의 기간을 선택할 수 있다면 얼마나 좋을까요? 데이터에는 전체 연간, J-D 및 세 달 기간 (DJF, MAM, JJA 및 SON)을 위한 열도 포함되어 있습니다. (알파벳은 영어로 된 월 이름을 나타냅니다: 12월, 1월, 2월; 3월, 4월, 5월; 그 이후로 계속됩니다.)\u003c/p\u003e\n\u003cp\u003e이를 위해 사용자가 적절한 기간을 선택할 수 있는 사용자 컨트롤을 통합해야 합니다. 저는 다양한 기간을 표시해 줄 드롭다운 메뉴를 선택했습니다. 이전 웹페이지와 꽤 유사하게 보일 것입니다(아래 이미지 참조).\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-FlapjaxDataVisualizationontheWebwithPlotlyandFlask_3.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 코드는 처음에는 꽤 유사합니다. 주요 차이점은 새로운 그래프를 선택할 때 발생합니다.\u003c/p\u003e\n\u003cp\u003e새 값을 선택하면 Javascript 함수가 호출되어 해당 값을 서버의 콜백 함수로 보내고 응답을 기다립니다. 이 콜백 함수는 새로운 차트를 반환하고, 호출하는 Javascript에 의해 표시됩니다.\u003c/p\u003e\n\u003cp\u003e먼저 익숙한 내용을 다뤄 봅시다. 아래에 새로운 엔드포인트 /ddsimple을 구현하는 함수가 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@app.\u003cspan class=\"hljs-title function_\"\u003eroute\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/ddsimple'\u003c/span\u003e)\ndef \u003cspan class=\"hljs-title function_\"\u003eddsimpleindex\u003c/span\u003e():\n    # \u003cspan class=\"hljs-title class_\"\u003eRoot\u003c/span\u003e 엔드포인트는 페이지를 만듭니다.\n    header = \u003cspan class=\"hljs-string\"\u003e\"지구 온도\"\u003c/span\u003e\n    subheader = \u003cspan class=\"hljs-string\"\u003e\"지난 몇 세기 동안의 지구 온도 변화\"\u003c/span\u003e\n    description = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"그래프는 연도별 온도 증가를 보여줍니다.\n    데이터는 1881년부터 2022년까지의 기간을 포함하며, 각 연도의 온도 이상치를 표시합니다.\n    \"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    menu_label = \u003cspan class=\"hljs-string\"\u003e\"기간을 선택하세요\"\u003c/span\u003e\n\n    params = {    \n        \u003cspan class=\"hljs-string\"\u003e'template'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'ddsimpleindex.html'\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e'title'\u003c/span\u003e: header,\n        \u003cspan class=\"hljs-string\"\u003e'subtitle'\u003c/span\u003e: subheader,\n        \u003cspan class=\"hljs-string\"\u003e'content'\u003c/span\u003e : description,\n        \u003cspan class=\"hljs-string\"\u003e'menu_label'\u003c/span\u003e: menu_label,\n        \u003cspan class=\"hljs-string\"\u003e'options'\u003c/span\u003e : [{\u003cspan class=\"hljs-string\"\u003e'code'\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e'J-D'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'desc'\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e'전체 연도'\u003c/span\u003e},\n                     {\u003cspan class=\"hljs-string\"\u003e'code'\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e'DJF'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'desc'\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e'겨울 (북반구)'\u003c/span\u003e},\n                     {\u003cspan class=\"hljs-string\"\u003e'code'\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e'MAM'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'desc'\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e'봄 (북반구)'\u003c/span\u003e},\n                     {\u003cspan class=\"hljs-string\"\u003e'code'\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e'JJA'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'desc'\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e'여름 (북반구)'\u003c/span\u003e},\n                     {\u003cspan class=\"hljs-string\"\u003e'code'\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e'SON'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'desc'\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e'가을 (북반구)'\u003c/span\u003e}],\n        \u003cspan class=\"hljs-string\"\u003e'graph'\u003c/span\u003e   : \u003cspan class=\"hljs-title function_\"\u003eget_graph\u003c/span\u003e()\n    }\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003etemplate\u003c/span\u003e(params)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e위의 코드를 Markdown 형식으로 변경하려면 아래와 같이 변경하실 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;form id=\u003cspan class=\"hljs-string\"\u003e\"userForm\"\u003c/span\u003e name=\u003cspan class=\"hljs-string\"\u003e\"form1\"\u003c/span\u003e onChange=\u003cspan class=\"hljs-string\"\u003e\"getFormValues('form1')\"\u003c/span\u003e\u003e\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"mb-3\"\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003elabel\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003efor\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"dropdown\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"form-label lead\"\u003c/span\u003e\u003e\u003c/span\u003e{{params.menu_label}}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003elabel\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eselect\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"form-select\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"dropdown\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"dropdown\"\u003c/span\u003e\u003e\u003c/span\u003e\n            {% for opt in params.options %}\n                \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eoption\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"{{opt.code}}\"\u003c/span\u003e\u003e\u003c/span\u003e{{opt.desc}}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eoption\u003c/span\u003e\u003e\u003c/span\u003e\n            {% endfor %}\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eselect\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u0026#x3C;/form\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e\u0026#x3C;!-- Main Content Area --\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"lead\"\u003c/span\u003e\u003e\u003c/span\u003e{{params.content}}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"graph\"\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게하면 드롭다운 메뉴가 포함된 양식을 만들 수 있습니다. 양식에는 이전에 본 두 개의 중괄호로 포함된 메뉴에 대한 레이블도 포함되어 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이전 예제와의 주요 차이점은 메뉴가 구성되는 방식입니다. \u003ccode\u003eselect\u003c/code\u003e 요소 내부에는 메뉴에서 제공된 옵션을 나타내는 \u003ccode\u003eoption\u003c/code\u003e 태그 목록을 넣어야 합니다. 옵션 태그에는 값과 설명이 있습니다. 이 값들과 설명들은 우리가 params.options 딕셔너리에 정의한 것입니다. 우리는 이 값을 포함하기 위해 ' for opt in param.options '와 같은 Jinja 반복문을 실행하여 딕셔너리를 반복하며 각 요소를 opt라는 지역 변수에 넣습니다. 그런 다음 opt.code와 opt.desc 값을 사용하여 이 값을 옵션 태그에 삽입합니다.\u003c/p\u003e\n\u003cp\u003eFlask 튜토리얼: Pythonbasics.org 웹사이트의 Templates에서 Jinja 템플릿의 간단한 예제와 설명을 찾을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e여기에는 우리 목적에 중요한 form 태그의 다른 부분이 있습니다. form 태그 내부에는 onChange라는 속성이 있는데, 이 속성은 어떤 동작의 값을 취합니다. 이 경우에는 폼의 값이 변경될 때 호출되는 자바스크립트 함수입니다. 이 경우에는 메뉴에서 옵션 중 하나를 선택했을 때입니다.\u003c/p\u003e\n\u003cp\u003e그리고 재미 있는 부분이 여기에서 시작됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e콜백\u003c/h2\u003e\n\u003cp\u003e웹 페이지를 새 차트로 업데이트하기 위해 콜백 메커니즘을 사용하며 아래 차트는 브라우저와 서버 간의 트랜잭션을 보여줍니다. 새 차트를 요청한 응답은 페이지를 다시로드하는 것이 아니라 업데이트하는 것임을 유의하세요. 이는 빠르며 잠깐의 빈 화면을 보여주지 않아 사용자 경험이 훨씬 더 좋아집니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-FlapjaxDataVisualizationontheWebwithPlotlyandFlask_4.png\" alt=\"차트 이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e콜백은 웹 페이지의 양식 변경에 의해 호출됩니다, 이전에 언급한대로. 이것을 위한 메커니즘은 양식의 onChange 속성에 식별된 자바스크립트 함수입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e자바스크립트 함수가 어떻게 작동하는지 자세히 설명하려고 합니다. 여기서 기본적으로, 이 함수는 폼에서 값을 가져와 Flask 앱의 콜백 엔드포인트로 보냅니다.\u003c/p\u003e\n\u003cp\u003e자바스크립트를 작성하는 것이 걱정되시는 분들은 걱정하지 마세요. 이것이 어떻게 작동하는지 알 필요는 없습니다. 그냥 복사해서 사용하면 여러분이 웹 페이지에 포함하고 싶은 어떤 폼이든 작동합니다.\u003c/p\u003e\n\u003cp\u003e더 자세한 설명을 읽고 싶으신 모험가들을 위해 아래에 설명을 제공하겠지만, 그렇지 않은 분들은 다음 섹션으로 건너뛰어도 괜찮습니다.\u003c/p\u003e\n\u003cp\u003e실제로 두 개의 함수가 있습니다. 폼에서 값을 가져오는 함수는 아래와 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e        \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetFormValues\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ef\u003c/span\u003e) {\n            \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e form = \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eforms\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enamedItem\u003c/span\u003e(f);\n            \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e formData = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFormData\u003c/span\u003e(form);\n            \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e value = \u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efromEntries\u003c/span\u003e(formData.\u003cspan class=\"hljs-title function_\"\u003eentries\u003c/span\u003e());\n            \u003cspan class=\"hljs-title function_\"\u003epostJSON\u003c/span\u003e(value);\n        }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e모든 코드는 내장된 JavaScript 함수를 사용합니다: 첫 번째 줄은 문서(즉, 웹 페이지)에서 폼을 가져오고, 두 번째 줄은 폼 데이터를 포함하는 데이터 구조체를 검색하며, 세 번째 줄은 해당 구조체에서 모든 값을 추출합니다.\u003c/p\u003e\n\u003cp\u003e마지막으로, 이러한 값들은 다른 함수 'postJson'에 전달됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e        \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003epostJSON\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e) {\n            \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n                \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e response = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"/callback\"\u003c/span\u003e, {\n                    \u003cspan class=\"hljs-attr\"\u003emethod\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"POST\"\u003c/span\u003e,\n                    \u003cspan class=\"hljs-attr\"\u003eheaders\u003c/span\u003e: {\n                        \u003cspan class=\"hljs-string\"\u003e\"Content-Type\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"application/json\"\u003c/span\u003e,\n                    },\n                    \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eJSON\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003estringify\u003c/span\u003e(data),\n                });\n\n                \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e result = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e response.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e();\n                \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Success:\"\u003c/span\u003e);\u003cspan class=\"hljs-comment\"\u003e//, result);\u003c/span\u003e\n\n                \u003cspan class=\"hljs-title function_\"\u003edrawGraph\u003c/span\u003e(result);\n            }\n            \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (error) {\n                \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eerror\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Error:\"\u003c/span\u003e, error);\n            }\n        }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 함수는 비동기 함수이므로 호출된 후 프로그램 실행이 즉시 호출한 코드로 돌아가고, 비동기 함수는 별도의 실행 스레드에서 계속 실행됩니다. 즉, 웹 페이지의 실행과 병렬로 수행해야 할 작업을 계속합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003epostJSON은 Python 콜백 코드로 전송해야 하는 데이터를 받아서 비동기 fetch 함수를 사용하여 전송합니다. fetch는 데이터가 전달되어야 하는 엔드포인트와 데이터 자체를 매개변수로 받습니다. 데이터를 전송하기 위해 HTTP POST 메커니즘을 사용합니다. postJSON은 fetch가 완료될 때까지 기다린 후, 즉 서버로부터 일부 데이터가 반환될 때까지 기다립니다. 그런 데이터는 그래프를 업데이트하는 drawGraph 함수로 전달됩니다.\u003c/p\u003e\n\u003cp\u003e코드는 try... catch... 블록에 포함되어 있음을 유의해주세요. 이는 Python 프로그램에서 발견할 수 있는 것과 거의 동일합니다. 즉, try 블록의 코드가 실패하면 — 응답이 없거나 다른 통신 오류가 발생하면 — 해당 실패는 콘솔에 로깅됩니다.\u003c/p\u003e\n\u003ch2\u003ePython 콜백\u003c/h2\u003e\n\u003cp\u003e이 모든 것이 작동하려면 Flask 코드에 데이터를 받고 처리한 후(예: 새로운 그래프 만들기) 결과를 다시 보내는 콜백 함수가 필요합니다. 여기에 있습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-comment\"\u003e# 콜백의 엔드포인트를 정의하는 것이 첫 번째 작업입니다. 엔드포인트가 POST 방식으로 데이터를 보내는 것을 명시해야 합니다.\u003c/span\u003e\n\n\u003cspan class=\"hljs-meta\"\u003e@app.route(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-string\"\u003e'/callback'\u003c/span\u003e, methods=[\u003cspan class=\"hljs-string\"\u003e'POST'\u003c/span\u003e]\u003c/span\u003e)\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecallback\u003c/span\u003e():\n    \u003cspan class=\"hljs-comment\"\u003e# 콜백은 페이지를 업데이트합니다.\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e request.is_json:\n        data = request.get_json() \n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e get_graph(period=data[\u003cspan class=\"hljs-string\"\u003e'dropdown'\u003c/span\u003e])\n    \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e jsonify({\u003cspan class=\"hljs-string\"\u003e\"error\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"잘못된 JSON 데이터입니다\"\u003c/span\u003e}), \u003cspan class=\"hljs-number\"\u003e400\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e콜백의 엔드포인트를 정의하는 것이 첫 번째 작업입니다. 엔드포인트가 POST 방식으로 데이터를 보내는 것을 명시해야 합니다.\u003c/p\u003e\n\u003cp\u003e또한 데이터가 JSON 형식으로 제공되기를 기대하는데, 그렇지 않은 경우 오류를 반환합니다.\u003c/p\u003e\n\u003cp\u003e데이터가 JSON이라면 드롭다운 메뉴에서 값을 추출하여 get_graph 함수에 전달하고, 이 함수는 그래프를 그리고 Plotly가 예상하는 JSON 형식으로 반환합니다. 이 그래프 데이터는 웹페이지의 JavaScript 함수에 의해 받아들여지고 페이지가 업데이트됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e위 코드를 사용하면 상단에 있는 대화형 웹 페이지를 제공합니다.\u003c/p\u003e\n\u003ch2\u003eFlapjax — 이름의 의미\u003c/h2\u003e\n\u003cp\u003e정말이지, 이것은 매우 인위적인 이름입니다: Flask, Python, Javascript 및 ax를 나타내며 이 기법을 가능케 하는 비동기 통신을 의미합니다.\u003c/p\u003e\n\u003cp\u003e미리 작성된 템플릿과 상당량의 보일러플레이트 코드를 사용하여 Python 코드의 로직에 대부분 집중하면서 유용한 대화형 웹 페이지를 만들 수 있다는 점을 보실 수 있기를 바랍니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 앱에는 사용자가 새 옵션을 선택할 때 업데이트되는 단일 그래프만 포함되어 있지만 HTML 폼에서 수집할 수 있는 값의 수는 무한입니다. 이 값들은 Flask 앱에 의해 처리된 후 새로운 정보로 웹페이지가 업데이트됩니다. (아마 나중에 이에 대해 자세히 다룰 수도 있을 것입니다).\u003c/p\u003e\n\u003cp\u003e여기에 설명된 모든 코드와 데이터는 제 GitHub 리포지토리에서 다운로드할 수 있습니다. (jinja-article 폴더를 참조해주세요).\u003c/p\u003e\n\u003cp\u003e업데이트: GitHub 리포지토리의 reuse 폴더에 새 데이터 세트로 새 앱을 생성하는 새 앱을 작성했습니다. HTML 및 Javascript는 동일하며 Python 코드와 데이터만 변경되었습니다:\nFlapjax 템플릿 및 코드 재사용\u003c/p\u003e\n\u003cp\u003e이 정보가 유용하게 느껴지길 바랍니다. 제 작업을 더 알아보고 싶으시면 웹사이트를 방문하시거나 무료 뉴스레터를 구독함으로써 발행 시 알림을 받을 수 있습니다. (여기를 참조해주세요)\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e만약 플라스크가 원하는 것이 아니라면, 내가 미디엄 기사를 기반으로 작성한 eBook Streamlit from Scratch을 읽어보세요.\u003c/p\u003e\n\u003ch2\u003e참고 자료\u003c/h2\u003e\n\u003cp\u003e이 기사와 앱에서 사용된 데이터는 아래 1번과 2번에서 설명된 것을 기반으로 합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eGISTEMP 팀, 2023: GISS 표면 온도 분석 (GISTEMP), 버전 4. NASA Goddard 우주 연구소. 데이터 세트는 2023년 9월 19일 data.giss.nasa.gov/gistemp/에서 액세스되었습니다. NASA의 데이터 세트에 대한 구체적인 라이선스가 없음에 유의하십시오. 이러한 데이터는 비상업적 목적으로 NASA에 의해 자유롭게 제공되지만 (위와 같이) 언급이 되어야 합니다.\u003c/li\u003e\n\u003cli\u003eLenssen, N., G. Schmidt, J. Hansen, M. Menne, A. Persin, R. Ruedy, and D. Zyss, 2019: GISTEMP 불확실성 모델의 개선. 대기.지구물리학.연구.저널, 124권, 12호, 6307–6326, doi:10.1029/2018JD029522.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e저자가 별도로 표기하지 않은 경우, 모든 이미지, 다이어그램, 스크린샷 및 코드는 저자가 제작했습니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-23-FlapjaxDataVisualizationontheWebwithPlotlyandFlask"},"buildId":"ckvP8zvWyPnScUqpsTElP","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>