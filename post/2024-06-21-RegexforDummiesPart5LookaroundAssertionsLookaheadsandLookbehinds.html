<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>정규 표현식 쉽게 배우기 5부 - 전방탐색과 후방탐색 기법 알아보기 | uidev-css</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://uidev-css.github.io///post/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="정규 표현식 쉽게 배우기 5부 - 전방탐색과 후방탐색 기법 알아보기 | uidev-css" data-gatsby-head="true"/><meta property="og:title" content="정규 표현식 쉽게 배우기 5부 - 전방탐색과 후방탐색 기법 알아보기 | uidev-css" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://uidev-css.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://uidev-css.github.io///post/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds" data-gatsby-head="true"/><meta name="twitter:title" content="정규 표현식 쉽게 배우기 5부 - 전방탐색과 후방탐색 기법 알아보기 | uidev-css" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | uidev-css" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-21 21:37" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b4eed7811784bdd3.js" defer=""></script><script src="/_next/static/5et5eMZxpKCgDAAyIS6Ju/_buildManifest.js" defer=""></script><script src="/_next/static/5et5eMZxpKCgDAAyIS6Ju/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UIDEV CSS</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">정규 표현식 쉽게 배우기 5부 - 전방탐색과 후방탐색 기법 알아보기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="정규 표현식 쉽게 배우기 5부 - 전방탐색과 후방탐색 기법 알아보기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UIDEV CSS</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 21, 2024</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<img src="/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_0.png">
<p>크레딧: Nguyễn Thành Minh (안드로이드 개발자)</p>
<p>Part 1은 여기에서 확인하세요: Quantifiers</p>
<p>Part 2은 여기에서 확인하세요: Flavors, Flags, and Assertions</p>
<div class="content-ad"></div>
<p>아래의 테이블 태그를 마크다운 형식으로 변경해주세요.</p>
<div class="content-ad"></div>
<p>룩어헤드 어설션은 특정 문자로 뒤따라오거나 선행하는 경우에만 일치하는 비캡처 그룹입니다.</p>
<p>룩어헤드 어설션은 입력 문자열이나 텍스트의 문자를 소비하지 않습니다. 다른 어설션 메타 문자인 입력 경계 어설션 (^와 $) 및 단어 경계 어설션 (\b와 \B)과 달리.</p>
<p>룩어헤드 어설션에는 두 가지 유형이 있습니다: 앞봐기(lookahead)와 뒷봐기(lookbehind). 두 유형은 양수와 음수 형태로 나뉘며, 양수 앞봐기, 음수 앞봐기, 양수 뒷봐기 및 음수 뒷봐기 어설션이 있습니다.</p>
<ul>
<li>양수 앞봐기(?=chars)</li>
</ul>
<div class="content-ad"></div>
<p>프렌들리한 톤으로 번역해드리겠습니다. 😀</p>
<p>긍정형 선행 단언은 문자열에서 현재 위치 이후에 특정 패턴이 일치하는지를 확인하며 해당 문자열에서 문자를 소비하지 않습니다. 간단히 말하면, 특정 표현식이 현재 위치 오른쪽에 위치하는지를 확인합니다. 이는 다음과 같은 구문을 사용하여 나타냅니다:</p>
<pre><code class="hljs language-js">(?=chars)
</code></pre>
<p>예를 들어, 패턴 x(?=y)는 y가 뒤따라오는 경우에만 x와 일치합니다.</p>
<p>[이미지:RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_1.png]</p>
<div class="content-ad"></div>
<p>다른 예시로, xyz(?=123)는 xyz와 일치하는 것이 123로 뒤 따르는 경우에만 일치합니다.</p>
<p><img src="/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_2.png" alt="image"></p>
<p>또 다른 예시로, apple (?=pie)</p>
<p><img src="/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_3.png" alt="image"></p>
<div class="content-ad"></div>
<p>위 예제에서, 'apple'과 일치하는 부분은 있지만 'apple pie' 전체까지는 일치하지 않습니다. 왜냐하면 lookaround 어서션은 입력 문자열의 문자들을 소비하지 않기 때문입니다.</p>
<p>만약 x(?=y)를 (?=y)x로 바꾼다면 어떻게 될까요? 패턴 (?=y)x를 이해하기 위해서는 먼저 패턴 (?=y)와 (?=y)y를 이해해야 합니다.</p>
<p>패턴 (?=y)는 'y'가 뒤따라오는 문자열과 일치하지만, 그 앞에는 다른 문자열이 없는 경우를 의미합니다. 따라서 아래 이미지에서 볼 수 있듯이 "빈 문자열"과 일치하게 됩니다. 이 경우 빈 문자열 중에서 'y'가 뒤따라오는 것에만 일치하며, 모든 빈 문자열과는 일치하지 않음에 유의해 주세요.</p>
<img src="/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_4.png">
<div class="content-ad"></div>
<p>The pattern (?=y)은 ‘y’ 바로 앞에 오는 빈 문자열과 일치합니다. 그래서, 패턴 (?=y)y는 ‘y’ 앞의 빈 문자열과 바로 ‘y’ 문자 뒤에 옵니다. 보다 쉬운 용어로 표현하자면, 이는 단순히 문자 ‘y’에 해당합니다.</p>
<p><img src="/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_5.png" alt=""></p>
<p>비슷하게, 패턴 (?=y)x는 ‘y’ 앞에 오는 빈 문자열과 바로 ‘x’ 문자 뒤에 오는 것을 나타냅니다. 다시 말해, 이는 'x' 문자 하나로만 구성되어야 하지만 'y'로 시작해야 하는 문자열과 일치합니다. 이러한 시나리오는 불가능하기 때문에, 이 패턴은 어떤 문자열과도 일치하지 않습니다.</p>
<p><img src="/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_6.png" alt=""></p>
<div class="content-ad"></div>
<p>만약 우리가 (?=y)x와 같은 패턴에 .*을 삽입한다면 어떻게 될까요? (?=.*y)x가 되는데, 이 경우 'x'가 'xy', 'x123y', 'x1y2z3'와 같이 'y'가 뒤에 오는 경우에 일치합니다.</p>
<p><img src="/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_7.png" alt="이미지"></p>
<p>먼저, 이 패턴이 단 한 문자 'x'만 일치한다는 점은 확실합니다. 왜냐하면 (?=.*y)는 단언이기 때문에 문자를 소비하지 않기 때문입니다.</p>
<p>그런 다음, 패턴 (?=.*y)가 어떻게 작동하는지 이해해야 합니다.</p>
<div class="content-ad"></div>
<ul>
<li>.*: 새 줄 제외한 모든 문자 시퀀스와 일치합니다.</li>
<li>y: 문자 <code>y</code>와 일치합니다.</li>
<li>따라서, .*y는 적어도 하나의 문자 <code>y</code>를 포함하는 모든 문자열과 일치합니다.</li>
</ul>
<p>그러므로, (?=.*y)는 'y'가 뒤따르는 빈 문자열과 일치합니다.</p>
<p><img src="/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_8.png" alt="이미지"></p>
<p>마지막으로, 패턴 (?=.*y)x는 'y'가 뒤따르는 문자열(예: <code>xy,</code>, <code>x123y,</code>, <code>x1y2</code> 등)에서 단일 문자 <code>x</code>와 일치합니다.</p>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_9.png" alt="image"></p>
<p>이 경우에는 .*가 ‘x’와 일치하기 때문에 .*y 전체가 ‘xy’와 일치하지만 ‘yx’와는 일치하지 않습니다. 그래서 (?=.<em>y)x는 ‘yx’와 일치하지 않습니다. 이를 그룹화하여 확인할 수 있습니다: (?=(.</em>)y)x</p>
<p><img src="/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_10.png" alt="image"></p>
<p>그룹 (.*)는 ‘x’, ‘xz’, ‘xbc’와 일치하는 것을 볼 수 있습니다.</p>
<div class="content-ad"></div>
<p>간단히 말해서, (?=.*y)는 문자열에 적어도 하나의 'y' 문자가 있는지 확인하는 데 일반적으로 사용됩니다. 비슷하게, 다음과 같은 유용한 패턴들이 있습니다:</p>
<ul>
<li>(?=.*[a-z]).+는 적어도 하나의 소문자가 있는 문자열과 일치합니다.</li>
<li>(?=.*[A-Z]).+는 적어도 하나의 대문자가 있는 문자열과 일치합니다.</li>
<li>(?=.*\d).+는 적어도 하나의 숫자가 있는 문자열과 일치합니다.</li>
<li>(?=.*[^A-Za-z0–9\s]).+는 공백을 제외한 특수 문자가 적어도 하나 있는 문자열과 일치합니다.</li>
</ul>
<p>긍정적인 선행 단언은 비밀번호 유효성을 확인하는 데 유용할 수 있습니다. 예를 들어, 적어도 하나의 대문자, 소문자, 숫자, 및 (공백을 제외한) 하나의 특수 문자를 포함하는 8자 이상의 비밀번호를 확인하려면 다음과 같이 할 수 있습니다:</p>
<pre><code class="hljs language-js">^(?=.*[A-Z])(?=.*[a-z])(?=.*\d)(?=.*[^A-<span class="hljs-title class_">Za</span>-z0-<span class="hljs-number">9</span>\s]).{<span class="hljs-number">8</span>,}$
</code></pre>
<div class="content-ad"></div>
<img src="/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_11.png">
<p>여기서:</p>
<ul>
<li>^: 패턴을 문자열의 시작으로 고정시킵니다.</li>
<li>(?=.*[A-Z]): 적어도 하나의 대문자가 존재하는 것을 보증합니다.</li>
<li>(?=.*[a-z]): 적어도 하나의 소문자가 존재하는 것을 보증합니다.</li>
<li>(?=.*\d): 적어도 하나의 숫자가 존재하는 것을 보증합니다.</li>
<li>(?=.*[^A-Za-z0-9\s]): 적어도 하나의 특수문자(공백 제외)가 존재하는 것을 보증합니다.</li>
<li>.'8,': 적어도 8자의 문자열과 일치합니다.</li>
<li>$: 패턴을 문자열의 끝으로 고정시킵니다.</li>
</ul>
<ol start="2">
<li>부정형 순방향탐색 (?!chars)</li>
</ol>
<div class="content-ad"></div>
<p>부정적 룩어헤드 구문에서는 등호를 느낌표로 바꿉니다:</p>
<pre><code class="hljs language-js">(?!chars)
</code></pre>
<p>예를 들어, x(?!y) 패턴은 'y'에 뒤이어 나오지 않는 경우에만 'x'와 일치합니다.</p>
<p>다른 예로는 x(?!123) 패턴으로, '123'에 뒤이어 나오지 않는 경우에만 'x'와 일치합니다.</p>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_12.png" alt="image"></p>
<p>부정적 전방탐색 어설션은 특정 단어로 시작하지 않는 문자열을 유효성 검사하는 데 유용할 수 있습니다. 예를 들어, 'http' 또는 'https'로 시작하지 않는 URL을 유효성 검사하는 것입니다.</p>
<pre><code class="hljs language-js">^(?!http|https).+$
</code></pre>
<p><img src="/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_13.png" alt="image"></p>
<div class="content-ad"></div>
<p>위의 패턴에서, ^는 현재 위치가 문자열의 시작임을 나타내며, 부정 후조형 (?!http|https)는 현재 위치 뒤의 문자열이 "http" 또는 "https"가 아님을 나타냅니다. 이는 "http" 또는 "https"로 시작하지 않는 문자열과 일치합니다.</p>
<ol start="3">
<li>긍정 후조형 (?`=chars)</li>
</ol>
<p>후조형 단언은 후조 단언과 유사합니다. 하지만 일치하려는 항목 뒤에 무엇이 따라오는지 확인하는 대신, 일치하려는 항목 앞에 어떤 문자(들)가 있는지 확인합니다.</p>
<p>후조 단언과 마찬가지로, 긍정과 부정 후조 단언도 있습니다. 긍정 후조는 패턴에서 지정한 다른 문자에 의해 선행된 문자만 일치시킵니다. 반면에 부정 후조는 일치시키려는 문자가 다른 문자에 의해 선행되지 않을 때만 일치시킵니다.</p>
<div class="content-ad"></div>
<p>이것은 긍정형 lookbehind의 구문입니다:</p>
<pre><code class="hljs language-js">(?&#x3C;=chars)
</code></pre>
<p>예를 들어, 패턴 (?`=x)y는 y를 일치시키려면 그 앞에 x가 있어야 한다는 것을 나타냅니다. 이 경우 xx 또는 yx는 일치하지 않지만 xy는 일치합니다.</p>
<p>긍정형 lookbehind 어설션은 특정 통화 기호로만 선행된 숫자와 일치하는 경우에 유용할 수 있습니다. 예를 들어, 달러 기호로 선행된 숫자와 일치하는 경우입니다.</p>
<div class="content-ad"></div>
<p>아래의 정규 표현식 패턴은 달러 기호가 앞에 오는 숫자만 일치시키는 양수형 룩비하인드를 갖고 있어요:</p>
<pre><code class="hljs language-js">(?&#x3C;=\$)\d+
</code></pre>
<img src="/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_14.png">
<p>위 패턴에서 양수형 룩비하인드인 (?`=$) 는 달러 기호인 '$' 가 \d+에 의해 표현되는 하나 이상의 숫자 앞에 있는지를 확인합니다.</p>
<div class="content-ad"></div>
<ol start="4">
<li>Negative lookbehind (?`!chars)</li>
</ol>
<p>부정적인 lookbehind에서는 등호 대신 느낌표를 사용합니다:</p>
<pre><code class="hljs language-js">(?&#x3C;!chars)
</code></pre>
<p>예를 들어, 패턴 (?`!x)y는 y 앞에 x가 있는 경우 y와 일치하지 않습니다. 이 경우 vy는 일치하고, ny는 일치하지만 xy는 결코 일치하지 않습니다.</p>
<div class="content-ad"></div>
<p>부정적인 전방탐색 단언은 특정 확장자로 끝나지 않는 파일을 유효성 검사할 때 유용할 수 있습니다. 예를 들어, "js", "css", 또는 "html"로 끝나지 않는 파일 경로를 유효성 검사하려면 아래와 같이 사용할 수 있습니다.</p>
<pre><code class="hljs language-js">^.+(?&#x3C;!js|css|html)$
</code></pre>
<p><img src="/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_15.png" alt="image"></p>
<p>위 패턴에서 $는 현재 위치가 문자열 끝을 나타내고, 부정적인 전방탐색 (?`!js|css|html)는 현재 위치(끝 위치) 앞에 있는 문자열이 "js", "css", 또는 "html"이 아님을 나타냅니다. 즉, "js", "css", "html"로 끝나지 않는 문자열과 일치합니다.</p>
<div class="content-ad"></div>
<p>결론</p>
<p>정규 표현식에서 이 개념이 제일 어려웠어요. 이번 레슨 이후에는 대부분의 문제를 해결하는 데 정규 표현식을 사용할 수 있을 것으로 믿어요. 다음 파트에서는 프로그래밍에 적용해볼 거에요.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"정규 표현식 쉽게 배우기 5부 - 전방탐색과 후방탐색 기법 알아보기","description":"","date":"2024-06-21 21:37","slug":"2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds","content":"\n\n\u003cimg src=\"/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_0.png\" /\u003e\n\n크레딧: Nguyễn Thành Minh (안드로이드 개발자)\n\nPart 1은 여기에서 확인하세요: Quantifiers\n\nPart 2은 여기에서 확인하세요: Flavors, Flags, and Assertions\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래의 테이블 태그를 마크다운 형식으로 변경해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n룩어헤드 어설션은 특정 문자로 뒤따라오거나 선행하는 경우에만 일치하는 비캡처 그룹입니다.\n\n룩어헤드 어설션은 입력 문자열이나 텍스트의 문자를 소비하지 않습니다. 다른 어설션 메타 문자인 입력 경계 어설션 (^와 $) 및 단어 경계 어설션 (\\b와 \\B)과 달리.\n\n룩어헤드 어설션에는 두 가지 유형이 있습니다: 앞봐기(lookahead)와 뒷봐기(lookbehind). 두 유형은 양수와 음수 형태로 나뉘며, 양수 앞봐기, 음수 앞봐기, 양수 뒷봐기 및 음수 뒷봐기 어설션이 있습니다.\n\n- 양수 앞봐기(?=chars)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프렌들리한 톤으로 번역해드리겠습니다. 😀\n\n긍정형 선행 단언은 문자열에서 현재 위치 이후에 특정 패턴이 일치하는지를 확인하며 해당 문자열에서 문자를 소비하지 않습니다. 간단히 말하면, 특정 표현식이 현재 위치 오른쪽에 위치하는지를 확인합니다. 이는 다음과 같은 구문을 사용하여 나타냅니다:\n\n```js\n(?=chars)\n```\n\n예를 들어, 패턴 x(?=y)는 y가 뒤따라오는 경우에만 x와 일치합니다.\n\n[이미지:RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_1.png]\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다른 예시로, xyz(?=123)는 xyz와 일치하는 것이 123로 뒤 따르는 경우에만 일치합니다.\n\n![image](/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_2.png)\n\n또 다른 예시로, apple (?=pie)\n\n![image](/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 예제에서, 'apple'과 일치하는 부분은 있지만 'apple pie' 전체까지는 일치하지 않습니다. 왜냐하면 lookaround 어서션은 입력 문자열의 문자들을 소비하지 않기 때문입니다.\n\n만약 x(?=y)를 (?=y)x로 바꾼다면 어떻게 될까요? 패턴 (?=y)x를 이해하기 위해서는 먼저 패턴 (?=y)와 (?=y)y를 이해해야 합니다.\n\n패턴 (?=y)는 'y'가 뒤따라오는 문자열과 일치하지만, 그 앞에는 다른 문자열이 없는 경우를 의미합니다. 따라서 아래 이미지에서 볼 수 있듯이 \"빈 문자열\"과 일치하게 됩니다. 이 경우 빈 문자열 중에서 'y'가 뒤따라오는 것에만 일치하며, 모든 빈 문자열과는 일치하지 않음에 유의해 주세요.\n\n\u003cimg src=\"/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_4.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nThe pattern (?=y)은 ‘y’ 바로 앞에 오는 빈 문자열과 일치합니다. 그래서, 패턴 (?=y)y는 ‘y’ 앞의 빈 문자열과 바로 ‘y’ 문자 뒤에 옵니다. 보다 쉬운 용어로 표현하자면, 이는 단순히 문자 ‘y’에 해당합니다.\n\n![](/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_5.png)\n\n비슷하게, 패턴 (?=y)x는 ‘y’ 앞에 오는 빈 문자열과 바로 ‘x’ 문자 뒤에 오는 것을 나타냅니다. 다시 말해, 이는 'x' 문자 하나로만 구성되어야 하지만 'y'로 시작해야 하는 문자열과 일치합니다. 이러한 시나리오는 불가능하기 때문에, 이 패턴은 어떤 문자열과도 일치하지 않습니다.\n\n![](/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_6.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 우리가 (?=y)x와 같은 패턴에 .*을 삽입한다면 어떻게 될까요? (?=.*y)x가 되는데, 이 경우 'x'가 'xy', 'x123y', 'x1y2z3'와 같이 'y'가 뒤에 오는 경우에 일치합니다.\n\n![이미지](/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_7.png)\n\n먼저, 이 패턴이 단 한 문자 'x'만 일치한다는 점은 확실합니다. 왜냐하면 (?=.*y)는 단언이기 때문에 문자를 소비하지 않기 때문입니다.\n\n그런 다음, 패턴 (?=.*y)가 어떻게 작동하는지 이해해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- .*: 새 줄 제외한 모든 문자 시퀀스와 일치합니다.\n- y: 문자 `y`와 일치합니다.\n- 따라서, .*y는 적어도 하나의 문자 `y`를 포함하는 모든 문자열과 일치합니다.\n\n그러므로, (?=.*y)는 'y'가 뒤따르는 빈 문자열과 일치합니다.\n\n![이미지](/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_8.png)\n\n마지막으로, 패턴 (?=.*y)x는 'y'가 뒤따르는 문자열(예: `xy,`, `x123y,`, `x1y2` 등)에서 단일 문자 `x`와 일치합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_9.png)\n\n이 경우에는 .*가 ‘x’와 일치하기 때문에 .*y 전체가 ‘xy’와 일치하지만 ‘yx’와는 일치하지 않습니다. 그래서 (?=.*y)x는 ‘yx’와 일치하지 않습니다. 이를 그룹화하여 확인할 수 있습니다: (?=(.*)y)x\n\n![image](/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_10.png)\n\n그룹 (.*)는 ‘x’, ‘xz’, ‘xbc’와 일치하는 것을 볼 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n간단히 말해서, (?=.*y)는 문자열에 적어도 하나의 'y' 문자가 있는지 확인하는 데 일반적으로 사용됩니다. 비슷하게, 다음과 같은 유용한 패턴들이 있습니다:\n\n- (?=.*[a-z]).+는 적어도 하나의 소문자가 있는 문자열과 일치합니다.\n- (?=.*[A-Z]).+는 적어도 하나의 대문자가 있는 문자열과 일치합니다.\n- (?=.*\\d).+는 적어도 하나의 숫자가 있는 문자열과 일치합니다.\n- (?=.*[^A-Za-z0–9\\s]).+는 공백을 제외한 특수 문자가 적어도 하나 있는 문자열과 일치합니다.\n\n긍정적인 선행 단언은 비밀번호 유효성을 확인하는 데 유용할 수 있습니다. 예를 들어, 적어도 하나의 대문자, 소문자, 숫자, 및 (공백을 제외한) 하나의 특수 문자를 포함하는 8자 이상의 비밀번호를 확인하려면 다음과 같이 할 수 있습니다:\n\n```js\n^(?=.*[A-Z])(?=.*[a-z])(?=.*\\d)(?=.*[^A-Za-z0-9\\s]).{8,}$\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_11.png\" /\u003e\n\n여기서:\n\n- ^: 패턴을 문자열의 시작으로 고정시킵니다.\n- (?=.*[A-Z]): 적어도 하나의 대문자가 존재하는 것을 보증합니다.\n- (?=.*[a-z]): 적어도 하나의 소문자가 존재하는 것을 보증합니다.\n- (?=.*\\d): 적어도 하나의 숫자가 존재하는 것을 보증합니다.\n- (?=.*[^A-Za-z0-9\\s]): 적어도 하나의 특수문자(공백 제외)가 존재하는 것을 보증합니다.\n- .'8,': 적어도 8자의 문자열과 일치합니다.\n- $: 패턴을 문자열의 끝으로 고정시킵니다.\n\n2. 부정형 순방향탐색 (?!chars)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n부정적 룩어헤드 구문에서는 등호를 느낌표로 바꿉니다:\n\n```js\n(?!chars)\n```\n\n예를 들어, x(?!y) 패턴은 'y'에 뒤이어 나오지 않는 경우에만 'x'와 일치합니다.\n\n다른 예로는 x(?!123) 패턴으로, '123'에 뒤이어 나오지 않는 경우에만 'x'와 일치합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_12.png)\n\n부정적 전방탐색 어설션은 특정 단어로 시작하지 않는 문자열을 유효성 검사하는 데 유용할 수 있습니다. 예를 들어, 'http' 또는 'https'로 시작하지 않는 URL을 유효성 검사하는 것입니다.\n\n```js\n^(?!http|https).+$\n```\n\n![image](/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_13.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 패턴에서, ^는 현재 위치가 문자열의 시작임을 나타내며, 부정 후조형 (?!http|https)는 현재 위치 뒤의 문자열이 \"http\" 또는 \"https\"가 아님을 나타냅니다. 이는 \"http\" 또는 \"https\"로 시작하지 않는 문자열과 일치합니다.\n\n3. 긍정 후조형 (?`=chars)\n\n후조형 단언은 후조 단언과 유사합니다. 하지만 일치하려는 항목 뒤에 무엇이 따라오는지 확인하는 대신, 일치하려는 항목 앞에 어떤 문자(들)가 있는지 확인합니다.\n\n후조 단언과 마찬가지로, 긍정과 부정 후조 단언도 있습니다. 긍정 후조는 패턴에서 지정한 다른 문자에 의해 선행된 문자만 일치시킵니다. 반면에 부정 후조는 일치시키려는 문자가 다른 문자에 의해 선행되지 않을 때만 일치시킵니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이것은 긍정형 lookbehind의 구문입니다:\n\n```js\n(?\u003c=chars)\n```\n\n예를 들어, 패턴 (?`=x)y는 y를 일치시키려면 그 앞에 x가 있어야 한다는 것을 나타냅니다. 이 경우 xx 또는 yx는 일치하지 않지만 xy는 일치합니다.\n\n긍정형 lookbehind 어설션은 특정 통화 기호로만 선행된 숫자와 일치하는 경우에 유용할 수 있습니다. 예를 들어, 달러 기호로 선행된 숫자와 일치하는 경우입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래의 정규 표현식 패턴은 달러 기호가 앞에 오는 숫자만 일치시키는 양수형 룩비하인드를 갖고 있어요:\n\n```js\n(?\u003c=\\$)\\d+\n```\n\n\u003cimg src=\"/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_14.png\" /\u003e\n\n위 패턴에서 양수형 룩비하인드인 (?`=\\$) 는 달러 기호인 '$' 가 \\d+에 의해 표현되는 하나 이상의 숫자 앞에 있는지를 확인합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n4. Negative lookbehind (?`!chars)\n\n부정적인 lookbehind에서는 등호 대신 느낌표를 사용합니다:\n\n```js\n(?\u003c!chars)\n```\n\n예를 들어, 패턴 (?`!x)y는 y 앞에 x가 있는 경우 y와 일치하지 않습니다. 이 경우 vy는 일치하고, ny는 일치하지만 xy는 결코 일치하지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n부정적인 전방탐색 단언은 특정 확장자로 끝나지 않는 파일을 유효성 검사할 때 유용할 수 있습니다. 예를 들어, \"js\", \"css\", 또는 \"html\"로 끝나지 않는 파일 경로를 유효성 검사하려면 아래와 같이 사용할 수 있습니다.\n\n```js\n^.+(?\u003c!js|css|html)$\n```\n\n![image](/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_15.png)\n\n위 패턴에서 $는 현재 위치가 문자열 끝을 나타내고, 부정적인 전방탐색 (?`!js|css|html)는 현재 위치(끝 위치) 앞에 있는 문자열이 \"js\", \"css\", 또는 \"html\"이 아님을 나타냅니다. 즉, \"js\", \"css\", \"html\"로 끝나지 않는 문자열과 일치합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n결론\n\n정규 표현식에서 이 개념이 제일 어려웠어요. 이번 레슨 이후에는 대부분의 문제를 해결하는 데 정규 표현식을 사용할 수 있을 것으로 믿어요. 다음 파트에서는 프로그래밍에 적용해볼 거에요.","ogImage":{"url":"/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_0.png"},"coverImage":"/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_0.png","tag":["Tech"],"readingTime":7},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cimg src=\"/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_0.png\"\u003e\n\u003cp\u003e크레딧: Nguyễn Thành Minh (안드로이드 개발자)\u003c/p\u003e\n\u003cp\u003ePart 1은 여기에서 확인하세요: Quantifiers\u003c/p\u003e\n\u003cp\u003ePart 2은 여기에서 확인하세요: Flavors, Flags, and Assertions\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e아래의 테이블 태그를 마크다운 형식으로 변경해주세요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e룩어헤드 어설션은 특정 문자로 뒤따라오거나 선행하는 경우에만 일치하는 비캡처 그룹입니다.\u003c/p\u003e\n\u003cp\u003e룩어헤드 어설션은 입력 문자열이나 텍스트의 문자를 소비하지 않습니다. 다른 어설션 메타 문자인 입력 경계 어설션 (^와 $) 및 단어 경계 어설션 (\\b와 \\B)과 달리.\u003c/p\u003e\n\u003cp\u003e룩어헤드 어설션에는 두 가지 유형이 있습니다: 앞봐기(lookahead)와 뒷봐기(lookbehind). 두 유형은 양수와 음수 형태로 나뉘며, 양수 앞봐기, 음수 앞봐기, 양수 뒷봐기 및 음수 뒷봐기 어설션이 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e양수 앞봐기(?=chars)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e프렌들리한 톤으로 번역해드리겠습니다. 😀\u003c/p\u003e\n\u003cp\u003e긍정형 선행 단언은 문자열에서 현재 위치 이후에 특정 패턴이 일치하는지를 확인하며 해당 문자열에서 문자를 소비하지 않습니다. 간단히 말하면, 특정 표현식이 현재 위치 오른쪽에 위치하는지를 확인합니다. 이는 다음과 같은 구문을 사용하여 나타냅니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e(?=chars)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e예를 들어, 패턴 x(?=y)는 y가 뒤따라오는 경우에만 x와 일치합니다.\u003c/p\u003e\n\u003cp\u003e[이미지:RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_1.png]\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e다른 예시로, xyz(?=123)는 xyz와 일치하는 것이 123로 뒤 따르는 경우에만 일치합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_2.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e또 다른 예시로, apple (?=pie)\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_3.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e위 예제에서, 'apple'과 일치하는 부분은 있지만 'apple pie' 전체까지는 일치하지 않습니다. 왜냐하면 lookaround 어서션은 입력 문자열의 문자들을 소비하지 않기 때문입니다.\u003c/p\u003e\n\u003cp\u003e만약 x(?=y)를 (?=y)x로 바꾼다면 어떻게 될까요? 패턴 (?=y)x를 이해하기 위해서는 먼저 패턴 (?=y)와 (?=y)y를 이해해야 합니다.\u003c/p\u003e\n\u003cp\u003e패턴 (?=y)는 'y'가 뒤따라오는 문자열과 일치하지만, 그 앞에는 다른 문자열이 없는 경우를 의미합니다. 따라서 아래 이미지에서 볼 수 있듯이 \"빈 문자열\"과 일치하게 됩니다. 이 경우 빈 문자열 중에서 'y'가 뒤따라오는 것에만 일치하며, 모든 빈 문자열과는 일치하지 않음에 유의해 주세요.\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_4.png\"\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eThe pattern (?=y)은 ‘y’ 바로 앞에 오는 빈 문자열과 일치합니다. 그래서, 패턴 (?=y)y는 ‘y’ 앞의 빈 문자열과 바로 ‘y’ 문자 뒤에 옵니다. 보다 쉬운 용어로 표현하자면, 이는 단순히 문자 ‘y’에 해당합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_5.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e비슷하게, 패턴 (?=y)x는 ‘y’ 앞에 오는 빈 문자열과 바로 ‘x’ 문자 뒤에 오는 것을 나타냅니다. 다시 말해, 이는 'x' 문자 하나로만 구성되어야 하지만 'y'로 시작해야 하는 문자열과 일치합니다. 이러한 시나리오는 불가능하기 때문에, 이 패턴은 어떤 문자열과도 일치하지 않습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_6.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e만약 우리가 (?=y)x와 같은 패턴에 .*을 삽입한다면 어떻게 될까요? (?=.*y)x가 되는데, 이 경우 'x'가 'xy', 'x123y', 'x1y2z3'와 같이 'y'가 뒤에 오는 경우에 일치합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_7.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e먼저, 이 패턴이 단 한 문자 'x'만 일치한다는 점은 확실합니다. 왜냐하면 (?=.*y)는 단언이기 때문에 문자를 소비하지 않기 때문입니다.\u003c/p\u003e\n\u003cp\u003e그런 다음, 패턴 (?=.*y)가 어떻게 작동하는지 이해해야 합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e.*: 새 줄 제외한 모든 문자 시퀀스와 일치합니다.\u003c/li\u003e\n\u003cli\u003ey: 문자 \u003ccode\u003ey\u003c/code\u003e와 일치합니다.\u003c/li\u003e\n\u003cli\u003e따라서, .*y는 적어도 하나의 문자 \u003ccode\u003ey\u003c/code\u003e를 포함하는 모든 문자열과 일치합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e그러므로, (?=.*y)는 'y'가 뒤따르는 빈 문자열과 일치합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_8.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e마지막으로, 패턴 (?=.*y)x는 'y'가 뒤따르는 문자열(예: \u003ccode\u003exy,\u003c/code\u003e, \u003ccode\u003ex123y,\u003c/code\u003e, \u003ccode\u003ex1y2\u003c/code\u003e 등)에서 단일 문자 \u003ccode\u003ex\u003c/code\u003e와 일치합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_9.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e이 경우에는 .*가 ‘x’와 일치하기 때문에 .*y 전체가 ‘xy’와 일치하지만 ‘yx’와는 일치하지 않습니다. 그래서 (?=.\u003cem\u003ey)x는 ‘yx’와 일치하지 않습니다. 이를 그룹화하여 확인할 수 있습니다: (?=(.\u003c/em\u003e)y)x\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_10.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e그룹 (.*)는 ‘x’, ‘xz’, ‘xbc’와 일치하는 것을 볼 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e간단히 말해서, (?=.*y)는 문자열에 적어도 하나의 'y' 문자가 있는지 확인하는 데 일반적으로 사용됩니다. 비슷하게, 다음과 같은 유용한 패턴들이 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e(?=.*[a-z]).+는 적어도 하나의 소문자가 있는 문자열과 일치합니다.\u003c/li\u003e\n\u003cli\u003e(?=.*[A-Z]).+는 적어도 하나의 대문자가 있는 문자열과 일치합니다.\u003c/li\u003e\n\u003cli\u003e(?=.*\\d).+는 적어도 하나의 숫자가 있는 문자열과 일치합니다.\u003c/li\u003e\n\u003cli\u003e(?=.*[^A-Za-z0–9\\s]).+는 공백을 제외한 특수 문자가 적어도 하나 있는 문자열과 일치합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e긍정적인 선행 단언은 비밀번호 유효성을 확인하는 데 유용할 수 있습니다. 예를 들어, 적어도 하나의 대문자, 소문자, 숫자, 및 (공백을 제외한) 하나의 특수 문자를 포함하는 8자 이상의 비밀번호를 확인하려면 다음과 같이 할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e^(?=.*[A-Z])(?=.*[a-z])(?=.*\\d)(?=.*[^A-\u003cspan class=\"hljs-title class_\"\u003eZa\u003c/span\u003e-z0-\u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e\\s]).{\u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e,}$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cimg src=\"/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_11.png\"\u003e\n\u003cp\u003e여기서:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e^: 패턴을 문자열의 시작으로 고정시킵니다.\u003c/li\u003e\n\u003cli\u003e(?=.*[A-Z]): 적어도 하나의 대문자가 존재하는 것을 보증합니다.\u003c/li\u003e\n\u003cli\u003e(?=.*[a-z]): 적어도 하나의 소문자가 존재하는 것을 보증합니다.\u003c/li\u003e\n\u003cli\u003e(?=.*\\d): 적어도 하나의 숫자가 존재하는 것을 보증합니다.\u003c/li\u003e\n\u003cli\u003e(?=.*[^A-Za-z0-9\\s]): 적어도 하나의 특수문자(공백 제외)가 존재하는 것을 보증합니다.\u003c/li\u003e\n\u003cli\u003e.'8,': 적어도 8자의 문자열과 일치합니다.\u003c/li\u003e\n\u003cli\u003e$: 패턴을 문자열의 끝으로 고정시킵니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e부정형 순방향탐색 (?!chars)\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e부정적 룩어헤드 구문에서는 등호를 느낌표로 바꿉니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e(?!chars)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e예를 들어, x(?!y) 패턴은 'y'에 뒤이어 나오지 않는 경우에만 'x'와 일치합니다.\u003c/p\u003e\n\u003cp\u003e다른 예로는 x(?!123) 패턴으로, '123'에 뒤이어 나오지 않는 경우에만 'x'와 일치합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_12.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e부정적 전방탐색 어설션은 특정 단어로 시작하지 않는 문자열을 유효성 검사하는 데 유용할 수 있습니다. 예를 들어, 'http' 또는 'https'로 시작하지 않는 URL을 유효성 검사하는 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e^(?!http|https).+$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_13.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e위의 패턴에서, ^는 현재 위치가 문자열의 시작임을 나타내며, 부정 후조형 (?!http|https)는 현재 위치 뒤의 문자열이 \"http\" 또는 \"https\"가 아님을 나타냅니다. 이는 \"http\" 또는 \"https\"로 시작하지 않는 문자열과 일치합니다.\u003c/p\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e긍정 후조형 (?`=chars)\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e후조형 단언은 후조 단언과 유사합니다. 하지만 일치하려는 항목 뒤에 무엇이 따라오는지 확인하는 대신, 일치하려는 항목 앞에 어떤 문자(들)가 있는지 확인합니다.\u003c/p\u003e\n\u003cp\u003e후조 단언과 마찬가지로, 긍정과 부정 후조 단언도 있습니다. 긍정 후조는 패턴에서 지정한 다른 문자에 의해 선행된 문자만 일치시킵니다. 반면에 부정 후조는 일치시키려는 문자가 다른 문자에 의해 선행되지 않을 때만 일치시킵니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이것은 긍정형 lookbehind의 구문입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e(?\u0026#x3C;=chars)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e예를 들어, 패턴 (?`=x)y는 y를 일치시키려면 그 앞에 x가 있어야 한다는 것을 나타냅니다. 이 경우 xx 또는 yx는 일치하지 않지만 xy는 일치합니다.\u003c/p\u003e\n\u003cp\u003e긍정형 lookbehind 어설션은 특정 통화 기호로만 선행된 숫자와 일치하는 경우에 유용할 수 있습니다. 예를 들어, 달러 기호로 선행된 숫자와 일치하는 경우입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e아래의 정규 표현식 패턴은 달러 기호가 앞에 오는 숫자만 일치시키는 양수형 룩비하인드를 갖고 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e(?\u0026#x3C;=\\$)\\d+\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_14.png\"\u003e\n\u003cp\u003e위 패턴에서 양수형 룩비하인드인 (?`=$) 는 달러 기호인 '$' 가 \\d+에 의해 표현되는 하나 이상의 숫자 앞에 있는지를 확인합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003eNegative lookbehind (?`!chars)\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e부정적인 lookbehind에서는 등호 대신 느낌표를 사용합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e(?\u0026#x3C;!chars)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e예를 들어, 패턴 (?`!x)y는 y 앞에 x가 있는 경우 y와 일치하지 않습니다. 이 경우 vy는 일치하고, ny는 일치하지만 xy는 결코 일치하지 않습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e부정적인 전방탐색 단언은 특정 확장자로 끝나지 않는 파일을 유효성 검사할 때 유용할 수 있습니다. 예를 들어, \"js\", \"css\", 또는 \"html\"로 끝나지 않는 파일 경로를 유효성 검사하려면 아래와 같이 사용할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e^.+(?\u0026#x3C;!js|css|html)$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_15.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e위 패턴에서 $는 현재 위치가 문자열 끝을 나타내고, 부정적인 전방탐색 (?`!js|css|html)는 현재 위치(끝 위치) 앞에 있는 문자열이 \"js\", \"css\", 또는 \"html\"이 아님을 나타냅니다. 즉, \"js\", \"css\", \"html\"로 끝나지 않는 문자열과 일치합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e결론\u003c/p\u003e\n\u003cp\u003e정규 표현식에서 이 개념이 제일 어려웠어요. 이번 레슨 이후에는 대부분의 문제를 해결하는 데 정규 표현식을 사용할 수 있을 것으로 믿어요. 다음 파트에서는 프로그래밍에 적용해볼 거에요.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds"},"buildId":"5et5eMZxpKCgDAAyIS6Ju","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>