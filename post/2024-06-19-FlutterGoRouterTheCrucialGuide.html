<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>플러터 Go 라우터 필수 가이드 | uidev-css</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://uidev-css.github.io///post/2024-06-19-FlutterGoRouterTheCrucialGuide" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="플러터 Go 라우터 필수 가이드 | uidev-css" data-gatsby-head="true"/><meta property="og:title" content="플러터 Go 라우터 필수 가이드 | uidev-css" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-19-FlutterGoRouterTheCrucialGuide_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://uidev-css.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://uidev-css.github.io///post/2024-06-19-FlutterGoRouterTheCrucialGuide" data-gatsby-head="true"/><meta name="twitter:title" content="플러터 Go 라우터 필수 가이드 | uidev-css" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-19-FlutterGoRouterTheCrucialGuide_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | uidev-css" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-19 08:13" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b75a4bf98ee956a8.js" defer=""></script><script src="/_next/static/-yEBofE4jMl3RL1kr5c4Y/_buildManifest.js" defer=""></script><script src="/_next/static/-yEBofE4jMl3RL1kr5c4Y/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UIDEV CSS</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">플러터 Go 라우터 필수 가이드</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="플러터 Go 라우터 필수 가이드" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UIDEV CSS</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 19, 2024</span><span class="posts_reading_time__f7YPP">10<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-19-FlutterGoRouterTheCrucialGuide&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-06-19-FlutterGoRouterTheCrucialGuide_0.png" alt="FlutterGoRouter"></p>
<p>Go_router은 Flutter에서 라우팅을 위한 서드 파티 패키지로, 기본 플러터 라우팅 옵션보다 더 유연하고 사용하기 쉬운 솔루션을 제공하기 위해 만들어졌습니다. 라우트가 어떻게 정의되고 관리되는지에 대해 더 많은 제어를 원하는 경우 유용할 수 있습니다. 또한 웹에 대한 좋은 지원을 제공하기 때문에 애플리케이션에 좋은 선택일 수 있습니다.</p>
<p>URL 패턴을 정의하고, URL을 사용하여 탐색하며, 딥 링크를 처리하고, 기타 여러 네비게이션 관련 시나리오를 다룰 수 있습니다.</p>
<h1>특징</h1>
<p>고 라우터(GoRouter)는 네비게이션을 간단하게 만들기 위한 다양한 기능을 제공합니다:</p>
<ul>
<li>Navigator API와의 하위 호환성</li>
<li>Material 및 Cupertino 앱을 지원</li>
<li>StatefulShellRoute를 사용하여 중첩된 탭 탐색 지원</li>
<li>목적지에 대한 여러 화면 표시 (하위 라우트)</li>
<li>템플릿 구문을 사용하여 경로 및 쿼리 매개변수 구문 분석</li>
<li>리디렉션 지원 — 사용자를 다른 URL로 리디렉션할 수 있으며,예를 들어 사용자가 인증되지 않은 경우에는 로그인 페이지로 이동할 수 있습니다.</li>
</ul>
<h1>시작하기</h1>
<p>시작하려면 pubspec.yaml에 go_router를 추가하세요. 이 문서에서는 ^13.2.0을 사용하겠습니다.</p>
<pre><code class="hljs language-yaml"><span class="hljs-attr">dependencies:</span>
  <span class="hljs-attr">go_router:</span> <span class="hljs-string">^13.2.0</span>
</code></pre>
<h1>라우트 구성</h1>
<p>이제 그렇게 한 다음에 GoRouter 구성을 앱에 추가해 봅시다:</p>
<pre><code class="hljs language-dart"><span class="hljs-keyword">import</span> <span class="hljs-string">'package:go_router/go_router.dart'</span>;

<span class="hljs-comment">// GoRouter 구성</span>
<span class="hljs-keyword">final</span> _router = GoRouter(
  initialLocation: <span class="hljs-string">'/'</span>,
  routes: [
    GoRoute(
      name: <span class="hljs-string">'home'</span>, <span class="hljs-comment">// 선택사항, 라우트에 이름 추가. 경로 대신 이름으로 이동 가능</span>
      path: <span class="hljs-string">'/'</span>,
      builder: (context, state) => HomeScreen(),
    ),
    GoRoute(
      name: <span class="hljs-string">'shope'</span>,
      path: <span class="hljs-string">'/shope'</span>,
      builder: (context, state) => ShopeScreen(),
    ),
  ],
);
</code></pre>
<p>그럼 MaterialApp.router 또는 CupertinoApp.router 생성자를 사용하고 routerConfig 매개변수를 GoRouter 구성 객체로 설정할 수 있어요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">StatelessWidget</span> {
  @override
  <span class="hljs-title class_">Widget</span> <span class="hljs-title function_">build</span>(<span class="hljs-params">BuildContext context</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">MaterialApp</span>.<span class="hljs-title function_">router</span>(
      <span class="hljs-attr">routerConfig</span>: _router,
    );
  }
}
</code></pre>
<p>이것으로 준비 끝이에요 🙂 go_router를 사용해보세요 !!!</p>
<h1>매개변수</h1>
<p>경로 매개변수를 지정하려면 경로 세그먼트 앞에 콜론(:) 문자를 붙이고 고유한 이름(:userId와 같은)을 따라야 합니다. 빌더 콜백에 제공된 GoRouterState 객체를 통해 매개변수 값을 액세스할 수 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">GoRoute</span>(
  <span class="hljs-attr">path</span>: <span class="hljs-string">'/fruits/:id'</span>,
  <span class="hljs-attr">builder</span>: (context, state) {
     final id = state.<span class="hljs-property">pathParameters</span>[<span class="hljs-string">"id"</span>]! <span class="hljs-comment">// URL에서 "id" 매개변수 가져오기</span>
     <span class="hljs-keyword">return</span> <span class="hljs-title class_">FruitsPage</span>(<span class="hljs-attr">id</span>: id);
  },
),
</code></pre>
<h1>하위 루트 추가</h1>
<p>일치하는 경로는 네비게이터에서 여러 화면이 표시되는 결과를 가져올 수 있습니다. 이는 push()를 호출한 것과 동일한 효과이며, 새 화면이 이전 화면 위에 표시되고 AppBar 위젯에 인앱 뒤로 가기 버튼이 제공됩니다.</p>
<p>다음과 같이 부모 라우트와 그 자식 라우트를 추가해 보세요:</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">GoRoute</span>(
  <span class="hljs-attr">path</span>: <span class="hljs-string">'/fruits'</span>,
  <span class="hljs-attr">builder</span>: (context, state) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">FruitsPage</span>();
  },
  <span class="hljs-attr">routes</span>: &#x3C;<span class="hljs-title class_">RouteBase</span>>[ <span class="hljs-comment">// 자식 라우트 추가</span>
    <span class="hljs-title class_">GoRoute</span>(
      <span class="hljs-attr">path</span>: <span class="hljs-string">'fruits-details'</span>, <span class="hljs-comment">// 참고: 라우터의 부모에 "/" 문자를 명시할 필요가 없습니다.</span>
      <span class="hljs-attr">builder</span>: (context, state) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">FruitDetailsPage</span>();
      },
    ),
  ],
)
</code></pre>
<h1>화면 간 이동</h1>
<p>go_router를 사용하여 목적지 간에 이동하는 다양한 방법이 있습니다.</p>
<p>새 화면으로 이동하려면 URL과 함께 context.go()를 호출하십시오:</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">build</span>(<span class="hljs-params">BuildContext context</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">TextButton</span>(
    <span class="hljs-attr">onPressed</span>: <span class="hljs-function">() =></span> context.<span class="hljs-title function_">go</span>(<span class="hljs-string">'/fruits/fruit-detail'</span>),
  );
}
</code></pre>
<p>URL 대신 이름을 사용하여 탐색할 수도 있습니다. context.goNamed()를 호출하면 됩니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">build</span>(<span class="hljs-params">BuildContext context</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">TextButton</span>(
    <span class="hljs-comment">// 라우트에 "name"을 추가하지 않으면 오류가 발생할 수 있습니다</span>
    <span class="hljs-attr">onPressed</span>: <span class="hljs-function">() =></span> context.<span class="hljs-title function_">goNamed</span>(<span class="hljs-string">'fruit-detail'</span>),
  );
}
</code></pre>
<p>URI에 경로 매개변수를 포함하여 만들려면 Uri 클래스를 사용할 수 있어요:</p>
<pre><code class="hljs language-js">context.<span class="hljs-title function_">go</span>(
  <span class="hljs-title class_">Uri</span>(
    <span class="hljs-attr">path</span>: <span class="hljs-string">'/fruit-detail'</span>,
    <span class="hljs-attr">pathParameters</span>: {<span class="hljs-string">'id'</span>: <span class="hljs-string">'10'</span>},
  ).<span class="hljs-title function_">toString</span>(),
);
</code></pre>
<p>context.pop()을 사용하면 현재 화면에서 뒤로 이동할 수 있어요.</p>
<h1>중첩된 탭 탐색</h1>
<p>일부 앱은 화면의 하위 섹션에 목적지를 표시합니다. 예를 들어, 화면 간을 이동할 때 항상 화면 상에 남아 있는 BottomNavigationBar와 같은 경우입니다.</p>
<p>StatefulShellRoute를 사용하여 중첩된 탐색을 설정했습니다.</p>
<p>이 StatefulShellRoute 클래스는 루트 네비게이터와 다른 네비게이터에 하위 루트를 배치합니다. 그러나 이 루트 클래스는 각 중첩 분기에 대해 별도의 네비게이터를 생성하므로 (즉, 병렬 탐색 트리), 상태가 있는 중첩된 네비게이션을 구축할 수 있습니다.</p>
<p>예를 들어 BottomNavigationBar를 구현하는 경우, 각 탭에 대한 지속적인 네비게이션 상태가 있는 UI를 구현하는 것이 편리합니다.</p>
<p>상태 유지 쉘 라우트는 상태 유지 브랜치를 나타내는 각각의 StatefulShellBranch 항목 목록을 지정하여 생성됩니다. StatefulShellBranch는 브랜치를 위한 루트 라우트와 네비게이터 키 (GlobalKey) 및 선택적 초기 위치를 제공합니다.</p>
<p>구현 방법을 살펴보겠습니다 🙂</p>
<p>먼저 라우터를 만들어 시작합니다. StatefulShellRoute.indexedStack()을 라우트에 추가할 것이며, 이 클래스는 중첩된 내비게이션을 생성하는 역할을 맡게 됩니다.</p>
<p>StatefulShellRoute.indexedStack()은 중첩된 네비게이터에 IndexedStack을 사용하는 StatefulShellRoute를 생성합니다.</p>
<p>이 생성자는 분기 네비게이터를 나타내는 위젯을 관리하는 컨테이너(navigatorContainerBuilder)에 대한 IndexedStack 기반 구현을 제공합니다.</p>
<pre><code class="hljs language-dart"><span class="hljs-comment">// `root` 및 `section` 네비게이터를 위한 키 생성하여 불필요한 재구성을 피합니다</span>
<span class="hljs-keyword">final</span> _rootNavigatorKey = GlobalKey&#x3C;NavigatorState>();
<span class="hljs-keyword">final</span> _sectionNavigatorKey = GlobalKey&#x3C;NavigatorState>();


<span class="hljs-keyword">final</span> router = GoRouter(
  navigatorKey: _rootNavigatorKey,
  initialLocation: <span class="hljs-string">'/home'</span>,
  routes: &#x3C;RouteBase>[
    StatefulShellRoute.indexedStack(
      builder: (context, state, navigationShell) {
        <span class="hljs-comment">// 커스텀 쉘(예: BottomNavigationBar)을 구현하는 위젯을 반환합니다.</span>
        <span class="hljs-comment">// 다른 분기로 상태를 유지하면서 이동할 수 있도록 [StatefulNavigationShell]이 전달됩니다.</span>
        <span class="hljs-keyword">return</span> ScaffoldWithNavbar(navigationShell);
      },
      branches: [
        <span class="hljs-comment">// 1번 탭을 위한 루트 분기</span>
        StatefulShellBranch(
          navigatorKey: _sectionNavigatorKey,
          <span class="hljs-comment">// 이 분기의 루트 추가</span>
          <span class="hljs-comment">// 가능한 경우 하위 루트가 있는 각 루트(예: feed/uuid/details)를 추가합니다</span>
          routes: &#x3C;RouteBase>[
            GoRoute(
              path: <span class="hljs-string">'/shope'</span>,
              builder: (context, state) => <span class="hljs-keyword">const</span> ShopePage(),
              routes: &#x3C;RouteBase>[
                GoRoute(
                  path: <span class="hljs-string">'detail'</span>,
                  builder: (context, state) => <span class="hljs-keyword">const</span> FeedDetailsPage(),
                )
              ],
            ),
          ],
        ),

        <span class="hljs-comment">// 2번 탭을 위한 루트 분기</span>
        StatefulShellBranch(routes: &#x3C;RouteBase>[
          <span class="hljs-comment">// 이 분기의 루트 추가</span>
          <span class="hljs-comment">// 가능한 경우 하위 루트가 있는 각 루트(예: shope/uuid/details)를 추가합니다</span>
          GoRoute(
            path: <span class="hljs-string">'/home'</span>,
            builder: (context, state) => <span class="hljs-keyword">const</span> HomePage(),
          ),
        ])
      ],
    ),
  ],
);
</code></pre>
<p>우리의 루트에 StatefulShellRoute.indexedStack()를 추가했습니다. 이것은 우리의 분기를 생성하고 사용자 정의 쉘(이 경우 BottomNavigationBar)을 반환합니다.</p>
<ul>
<li>빌더: (context, state, navigationShell)에서는 사용자 정의 쉘인 Scaffold with BottomNavigationBar를 반환하며, 이 페이지로 이동할 때 navigationShell을 전달해야 합니다(예: Shope == Home).</li>
<li>branches:[]에서는 StatefulShellBranch(분기) 목록을 제공합니다. 이전에 생성한 _sectionNavigatorKey를 첫 번째 분기에 navigatorKey 속성으로 전달하지만, 다른 분기에는 기본 키가 사용됩니다. 또한 해당 분기에 대한 지원 루트 목록인 RouteBase 목록을 제공합니다.</li>
</ul>
<p>우리의 빌더가 커스텀 쉘을 반환하는 것을 확인할 수 있습니다. 이 쉘에는 BottomNavigationBar가 포함되어 있어요. 그러니 이제 그것을 만들어 봅시다. 👇🏿</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter/material.dart'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'package:go_router/go_router.dart'</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ScaffoldWithNavbar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">StatelessWidget</span> {
  <span class="hljs-keyword">const</span> <span class="hljs-title class_">ScaffoldWithNavbar</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">navigationShell</span>, {<span class="hljs-variable language_">super</span>.<span class="hljs-property">key</span>});

  <span class="hljs-comment">/// 브랜치 네비게이터를 위한 네비게이션 쉘 및 컨테이너입니다.</span>
  final <span class="hljs-title class_">StatefulNavigationShell</span> navigationShell;

  @override
  <span class="hljs-title class_">Widget</span> <span class="hljs-title function_">build</span>(<span class="hljs-params">BuildContext context</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Scaffold</span>(
      <span class="hljs-attr">body</span>: navigationShell,
      <span class="hljs-attr">bottomNavigationBar</span>: <span class="hljs-title class_">BottomNavigationBar</span>(
        <span class="hljs-attr">currentIndex</span>: navigationShell.<span class="hljs-property">currentIndex</span>,
        <span class="hljs-attr">items</span>: <span class="hljs-keyword">const</span> [
          <span class="hljs-title class_">BottomNavigationBarItem</span>(<span class="hljs-attr">icon</span>: <span class="hljs-title class_">Icon</span>(<span class="hljs-title class_">Icons</span>.<span class="hljs-property">shop</span>), <span class="hljs-attr">label</span>: <span class="hljs-string">'Shope'</span>),
          <span class="hljs-title class_">BottomNavigationBarItem</span>(<span class="hljs-attr">icon</span>: <span class="hljs-title class_">Icon</span>(<span class="hljs-title class_">Icons</span>.<span class="hljs-property">home</span>), <span class="hljs-attr">label</span>: <span class="hljs-string">'Home'</span>),
        ],
        <span class="hljs-attr">onTap</span>: _onTap,
      ),
    );
  }

  <span class="hljs-keyword">void</span> <span class="hljs-title function_">_onTap</span>(<span class="hljs-params">index</span>) {
    navigationShell.<span class="hljs-title function_">goBranch</span>(
      index,
      <span class="hljs-comment">// 바텀 네비게이션 바를 사용할 때 일반적인 패턴은 현재 활성화된 아이템을 탭했을 때 초기 위치로 이동하는 것을 지원하는 것입니다. 이 예제에서는 goBranch의 initialLocation 매개변수를 사용하여 이 동작을 지원하는 방법을 보여줍니다.</span>
      <span class="hljs-attr">initialLocation</span>: index == navigationShell.<span class="hljs-property">currentIndex</span>,
    );
  }
}
</code></pre>
<p>기본적으로 BottomNavigationBar가 있는 Scaffold를 반환하며, 본문은 라우터에서 얻은 navigationShell이 될 것입니다.</p>
<p>또한 <code>_onTap(index)</code>가 있습니다. 여기서는 <code>navigationShell.goBranch(index)</code>를 사용하여 브랜치 간에 전환할 수 있습니다.</p>
<p>그럼 이제 여러분의 프로젝트에 이를 구현할 준비가 끝났어요 🥳🎉</p>
<p>자세한 예시는 아래의 저장소를 확인해주세요 👇🏿</p>
<h1>Guards</h1>
<p>특정 경로를 보호하기 위해, 예를 들어 인증되지 않은 사용자로부터, GoRouter를 통해 전역 리디렉션이 설정될 수 있습니다. 가장 일반적인 예는 /login이 아닌 모든 경로를 보호하는 리디렉트 설정이며, 사용자가 인증되지 않은 경우 /login으로 리디렉트됩니다.</p>
<p>리다이렉션은 GoRouterRedirect 유형의 콜백입니다. 일부 응용 프로그램 상태에 따라서 들어오는 위치를 변경하려면 GoRouter 또는 GoRoute 생성자에 콜백을 추가하세요:</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">GoRouter</span>(
  <span class="hljs-attr">redirect</span>: (<span class="hljs-title class_">BuildContext</span> context, <span class="hljs-title class_">GoRouterState</span> state) {
    final isAuthenticated = <span class="hljs-comment">// 사용자가 인증되었는지 확인하는 논리를 여기에 작성하세요</span>
    <span class="hljs-keyword">if</span> (!isAuthenticated) {
      <span class="hljs-keyword">return</span> <span class="hljs-string">'/login'</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 리디렉트 없이 의도한 경로를 표시하려면 "null"을 반환하세요</span>
    }
  },
  ...
</code></pre>
<ul>
<li>GoRouter 생성자에서 리다이렉트를 정의할 수 있습니다. 모든 탐색 이벤트보다 먼저 호출됩니다.</li>
<li>GoRoute 생성자에서 리다이렉트를 정의할 수 있습니다. 탐색 이벤트가 경로를 표시하기 직전에 호출됩니다.</li>
</ul>
<h1>전환 애니메이션</h1>
<p>GoRouter를 사용하면 각 GoRoute에 대한 전환 애니메이션을 사용자 정의할 수 있어요. 사용자 정의 전환 애니메이션을 구성하려면 GoRoute 생성자에 pageBuilder 매개변수를 제공하세요:</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">GoRoute</span>(
  <span class="hljs-attr">path</span>: <span class="hljs-string">'/fruit-details'</span>,
  <span class="hljs-attr">pageBuilder</span>: (context, state) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">CustomTransitionPage</span>(
      <span class="hljs-attr">key</span>: state.<span class="hljs-property">pageKey</span>,
      <span class="hljs-attr">child</span>: <span class="hljs-title class_">FruitDetailsScreen</span>(),
      <span class="hljs-attr">transitionsBuilder</span>: (context, animation, secondaryAnimation, child) {
        <span class="hljs-comment">// 애니메이션의 값에 따라 화면의 불투명도를 변경합니다. </span>
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">FadeTransition</span>(
          <span class="hljs-attr">opacity</span>: <span class="hljs-title class_">CurveTween</span>(<span class="hljs-attr">curve</span>: <span class="hljs-title class_">Curves</span>.<span class="hljs-property">easeInOutCirc</span>).<span class="hljs-title function_">animate</span>(animation),
          <span class="hljs-attr">child</span>: child,
        );
      },
    );
  },
),
</code></pre>
<p>전체 예제는 전환 애니메이션 샘플을 참조하세요.</p>
<h1>에러 처리 (404 페이지)</h1>
<p>기본적으로, go_router는 MaterialApp 및 CupertinoApp용 기본 오류 화면과 사용되지 않는 경우의 기본 오류 화면이 함께 제공됩니다. 또한 errorBuilder 매개변수를 사용하여 기본 오류 화면을 대체할 수도 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">GoRouter</span>(
  <span class="hljs-comment">/* ... */</span>
  <span class="hljs-attr">errorBuilder</span>: <span class="hljs-function">(<span class="hljs-params">context, state</span>) =></span> <span class="hljs-title class_">ErrorPage</span>(state.<span class="hljs-property">error</span>),
);
</code></pre>
<h1>이전에 이동하기 전에 !!</h1>
<p>go_router에는 아직도 좋은 기능이 있습니다. GoRouter에 NavigatorObserver를 추가하여 Navigator의 동작을 관찰하고 route가 푸시, 팝 또는 대체될 때마다 알림을 받습니다. 이를 위해 NavigatorObserver를 확장하는 클래스를 만들어 보겠습니다:</p>
<pre><code class="hljs language-dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyNavigatorObserver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">NavigatorObserver</span> </span>{
  <span class="hljs-meta">@override</span>
  <span class="hljs-keyword">void</span> didPush(Route&#x3C;<span class="hljs-built_in">dynamic</span>> route, Route&#x3C;<span class="hljs-built_in">dynamic</span>>? previousRoute) {
    log(<span class="hljs-string">'did push route'</span>);
  }

  <span class="hljs-meta">@override</span>
  <span class="hljs-keyword">void</span> didPop(Route&#x3C;<span class="hljs-built_in">dynamic</span>> route, Route&#x3C;<span class="hljs-built_in">dynamic</span>>? previousRoute) {
    log(<span class="hljs-string">'did pop route'</span>);
  }
</code></pre>
<p>이제 MyNavigatorObserver를 GoRouter에 추가해 봅시다.</p>
<pre><code class="hljs language-dart">GoRouter(
  ...
  observers: [ <span class="hljs-comment">// 내비게이터 옵저버 추가</span>
    MyNavigatorObserver(),
  ],
...
)
</code></pre>
<p>이벤트가 발생하면 내비게이터에 알림이 전달됩니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"플러터 Go 라우터 필수 가이드","description":"","date":"2024-06-19 08:13","slug":"2024-06-19-FlutterGoRouterTheCrucialGuide","content":"\n\n\n![FlutterGoRouter](/assets/img/2024-06-19-FlutterGoRouterTheCrucialGuide_0.png)\n\nGo_router은 Flutter에서 라우팅을 위한 서드 파티 패키지로, 기본 플러터 라우팅 옵션보다 더 유연하고 사용하기 쉬운 솔루션을 제공하기 위해 만들어졌습니다. 라우트가 어떻게 정의되고 관리되는지에 대해 더 많은 제어를 원하는 경우 유용할 수 있습니다. 또한 웹에 대한 좋은 지원을 제공하기 때문에 애플리케이션에 좋은 선택일 수 있습니다.\n\nURL 패턴을 정의하고, URL을 사용하여 탐색하며, 딥 링크를 처리하고, 기타 여러 네비게이션 관련 시나리오를 다룰 수 있습니다.\n\n# 특징\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n고 라우터(GoRouter)는 네비게이션을 간단하게 만들기 위한 다양한 기능을 제공합니다:\n\n- Navigator API와의 하위 호환성\n- Material 및 Cupertino 앱을 지원\n- StatefulShellRoute를 사용하여 중첩된 탭 탐색 지원\n- 목적지에 대한 여러 화면 표시 (하위 라우트)\n- 템플릿 구문을 사용하여 경로 및 쿼리 매개변수 구문 분석\n- 리디렉션 지원 — 사용자를 다른 URL로 리디렉션할 수 있으며,예를 들어 사용자가 인증되지 않은 경우에는 로그인 페이지로 이동할 수 있습니다.\n\n# 시작하기\n\n시작하려면 pubspec.yaml에 go_router를 추가하세요. 이 문서에서는 ^13.2.0을 사용하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```yaml\ndependencies:\n  go_router: ^13.2.0\n```\n\n# 라우트 구성\n\n이제 그렇게 한 다음에 GoRouter 구성을 앱에 추가해 봅시다:\n\n```dart\nimport 'package:go_router/go_router.dart';\n\n// GoRouter 구성\nfinal _router = GoRouter(\n  initialLocation: '/',\n  routes: [\n    GoRoute(\n      name: 'home', // 선택사항, 라우트에 이름 추가. 경로 대신 이름으로 이동 가능\n      path: '/',\n      builder: (context, state) =\u003e HomeScreen(),\n    ),\n    GoRoute(\n      name: 'shope',\n      path: '/shope',\n      builder: (context, state) =\u003e ShopeScreen(),\n    ),\n  ],\n);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그럼 MaterialApp.router 또는 CupertinoApp.router 생성자를 사용하고 routerConfig 매개변수를 GoRouter 구성 객체로 설정할 수 있어요:\n\n```js\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp.router(\n      routerConfig: _router,\n    );\n  }\n}\n```\n\n이것으로 준비 끝이에요 🙂 go_router를 사용해보세요 !!!\n\n# 매개변수\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n경로 매개변수를 지정하려면 경로 세그먼트 앞에 콜론(:) 문자를 붙이고 고유한 이름(:userId와 같은)을 따라야 합니다. 빌더 콜백에 제공된 GoRouterState 객체를 통해 매개변수 값을 액세스할 수 있습니다:\n\n```js\nGoRoute(\n  path: '/fruits/:id',\n  builder: (context, state) {\n     final id = state.pathParameters[\"id\"]! // URL에서 \"id\" 매개변수 가져오기\n     return FruitsPage(id: id);\n  },\n),\n```\n\n# 하위 루트 추가\n\n일치하는 경로는 네비게이터에서 여러 화면이 표시되는 결과를 가져올 수 있습니다. 이는 push()를 호출한 것과 동일한 효과이며, 새 화면이 이전 화면 위에 표시되고 AppBar 위젯에 인앱 뒤로 가기 버튼이 제공됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음과 같이 부모 라우트와 그 자식 라우트를 추가해 보세요:\n\n```js\nGoRoute(\n  path: '/fruits',\n  builder: (context, state) {\n    return FruitsPage();\n  },\n  routes: \u003cRouteBase\u003e[ // 자식 라우트 추가\n    GoRoute(\n      path: 'fruits-details', // 참고: 라우터의 부모에 \"/\" 문자를 명시할 필요가 없습니다.\n      builder: (context, state) {\n        return FruitDetailsPage();\n      },\n    ),\n  ],\n)\n```\n\n# 화면 간 이동\n\ngo_router를 사용하여 목적지 간에 이동하는 다양한 방법이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n새 화면으로 이동하려면 URL과 함께 context.go()를 호출하십시오:\n\n```js\nbuild(BuildContext context) {\n  return TextButton(\n    onPressed: () =\u003e context.go('/fruits/fruit-detail'),\n  );\n}\n```\n\nURL 대신 이름을 사용하여 탐색할 수도 있습니다. context.goNamed()를 호출하면 됩니다.\n\n```js\nbuild(BuildContext context) {\n  return TextButton(\n    // 라우트에 \"name\"을 추가하지 않으면 오류가 발생할 수 있습니다\n    onPressed: () =\u003e context.goNamed('fruit-detail'),\n  );\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nURI에 경로 매개변수를 포함하여 만들려면 Uri 클래스를 사용할 수 있어요:\n\n```js\ncontext.go(\n  Uri(\n    path: '/fruit-detail',\n    pathParameters: {'id': '10'},\n  ).toString(),\n);\n```\n\ncontext.pop()을 사용하면 현재 화면에서 뒤로 이동할 수 있어요.\n\n# 중첩된 탭 탐색\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일부 앱은 화면의 하위 섹션에 목적지를 표시합니다. 예를 들어, 화면 간을 이동할 때 항상 화면 상에 남아 있는 BottomNavigationBar와 같은 경우입니다.\n\nStatefulShellRoute를 사용하여 중첩된 탐색을 설정했습니다.\n\n이 StatefulShellRoute 클래스는 루트 네비게이터와 다른 네비게이터에 하위 루트를 배치합니다. 그러나 이 루트 클래스는 각 중첩 분기에 대해 별도의 네비게이터를 생성하므로 (즉, 병렬 탐색 트리), 상태가 있는 중첩된 네비게이션을 구축할 수 있습니다.\n\n예를 들어 BottomNavigationBar를 구현하는 경우, 각 탭에 대한 지속적인 네비게이션 상태가 있는 UI를 구현하는 것이 편리합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n상태 유지 쉘 라우트는 상태 유지 브랜치를 나타내는 각각의 StatefulShellBranch 항목 목록을 지정하여 생성됩니다. StatefulShellBranch는 브랜치를 위한 루트 라우트와 네비게이터 키 (GlobalKey) 및 선택적 초기 위치를 제공합니다.\n\n구현 방법을 살펴보겠습니다 🙂\n\n먼저 라우터를 만들어 시작합니다. StatefulShellRoute.indexedStack()을 라우트에 추가할 것이며, 이 클래스는 중첩된 내비게이션을 생성하는 역할을 맡게 됩니다.\n\nStatefulShellRoute.indexedStack()은 중첩된 네비게이터에 IndexedStack을 사용하는 StatefulShellRoute를 생성합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 생성자는 분기 네비게이터를 나타내는 위젯을 관리하는 컨테이너(navigatorContainerBuilder)에 대한 IndexedStack 기반 구현을 제공합니다.\n\n```dart\n// `root` 및 `section` 네비게이터를 위한 키 생성하여 불필요한 재구성을 피합니다\nfinal _rootNavigatorKey = GlobalKey\u003cNavigatorState\u003e();\nfinal _sectionNavigatorKey = GlobalKey\u003cNavigatorState\u003e();\n\n\nfinal router = GoRouter(\n  navigatorKey: _rootNavigatorKey,\n  initialLocation: '/home',\n  routes: \u003cRouteBase\u003e[\n    StatefulShellRoute.indexedStack(\n      builder: (context, state, navigationShell) {\n        // 커스텀 쉘(예: BottomNavigationBar)을 구현하는 위젯을 반환합니다.\n        // 다른 분기로 상태를 유지하면서 이동할 수 있도록 [StatefulNavigationShell]이 전달됩니다.\n        return ScaffoldWithNavbar(navigationShell);\n      },\n      branches: [\n        // 1번 탭을 위한 루트 분기\n        StatefulShellBranch(\n          navigatorKey: _sectionNavigatorKey,\n          // 이 분기의 루트 추가\n          // 가능한 경우 하위 루트가 있는 각 루트(예: feed/uuid/details)를 추가합니다\n          routes: \u003cRouteBase\u003e[\n            GoRoute(\n              path: '/shope',\n              builder: (context, state) =\u003e const ShopePage(),\n              routes: \u003cRouteBase\u003e[\n                GoRoute(\n                  path: 'detail',\n                  builder: (context, state) =\u003e const FeedDetailsPage(),\n                )\n              ],\n            ),\n          ],\n        ),\n\n        // 2번 탭을 위한 루트 분기\n        StatefulShellBranch(routes: \u003cRouteBase\u003e[\n          // 이 분기의 루트 추가\n          // 가능한 경우 하위 루트가 있는 각 루트(예: shope/uuid/details)를 추가합니다\n          GoRoute(\n            path: '/home',\n            builder: (context, state) =\u003e const HomePage(),\n          ),\n        ])\n      ],\n    ),\n  ],\n);\r\n```\n\n우리의 루트에 StatefulShellRoute.indexedStack()를 추가했습니다. 이것은 우리의 분기를 생성하고 사용자 정의 쉘(이 경우 BottomNavigationBar)을 반환합니다.\n\n- 빌더: (context, state, navigationShell)에서는 사용자 정의 쉘인 Scaffold with BottomNavigationBar를 반환하며, 이 페이지로 이동할 때 navigationShell을 전달해야 합니다(예: Shope == Home).\n- branches:[]에서는 StatefulShellBranch(분기) 목록을 제공합니다. 이전에 생성한 _sectionNavigatorKey를 첫 번째 분기에 navigatorKey 속성으로 전달하지만, 다른 분기에는 기본 키가 사용됩니다. 또한 해당 분기에 대한 지원 루트 목록인 RouteBase 목록을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리의 빌더가 커스텀 쉘을 반환하는 것을 확인할 수 있습니다. 이 쉘에는 BottomNavigationBar가 포함되어 있어요. 그러니 이제 그것을 만들어 봅시다. 👇🏿\n\n```js\nimport 'package:flutter/material.dart';\nimport 'package:go_router/go_router.dart';\n\nclass ScaffoldWithNavbar extends StatelessWidget {\n  const ScaffoldWithNavbar(this.navigationShell, {super.key});\n\n  /// 브랜치 네비게이터를 위한 네비게이션 쉘 및 컨테이너입니다.\n  final StatefulNavigationShell navigationShell;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: navigationShell,\n      bottomNavigationBar: BottomNavigationBar(\n        currentIndex: navigationShell.currentIndex,\n        items: const [\n          BottomNavigationBarItem(icon: Icon(Icons.shop), label: 'Shope'),\n          BottomNavigationBarItem(icon: Icon(Icons.home), label: 'Home'),\n        ],\n        onTap: _onTap,\n      ),\n    );\n  }\n\n  void _onTap(index) {\n    navigationShell.goBranch(\n      index,\n      // 바텀 네비게이션 바를 사용할 때 일반적인 패턴은 현재 활성화된 아이템을 탭했을 때 초기 위치로 이동하는 것을 지원하는 것입니다. 이 예제에서는 goBranch의 initialLocation 매개변수를 사용하여 이 동작을 지원하는 방법을 보여줍니다.\n      initialLocation: index == navigationShell.currentIndex,\n    );\n  }\n}\n```\n\n기본적으로 BottomNavigationBar가 있는 Scaffold를 반환하며, 본문은 라우터에서 얻은 navigationShell이 될 것입니다.\n\n또한 `_onTap(index)`가 있습니다. 여기서는 `navigationShell.goBranch(index)`를 사용하여 브랜치 간에 전환할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그럼 이제 여러분의 프로젝트에 이를 구현할 준비가 끝났어요 🥳🎉\n\n자세한 예시는 아래의 저장소를 확인해주세요 👇🏿\n\n# Guards\n\n특정 경로를 보호하기 위해, 예를 들어 인증되지 않은 사용자로부터, GoRouter를 통해 전역 리디렉션이 설정될 수 있습니다. 가장 일반적인 예는 /login이 아닌 모든 경로를 보호하는 리디렉트 설정이며, 사용자가 인증되지 않은 경우 /login으로 리디렉트됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리다이렉션은 GoRouterRedirect 유형의 콜백입니다. 일부 응용 프로그램 상태에 따라서 들어오는 위치를 변경하려면 GoRouter 또는 GoRoute 생성자에 콜백을 추가하세요:\n\n```js\nGoRouter(\n  redirect: (BuildContext context, GoRouterState state) {\n    final isAuthenticated = // 사용자가 인증되었는지 확인하는 논리를 여기에 작성하세요\n    if (!isAuthenticated) {\n      return '/login';\n    } else {\n      return null; // 리디렉트 없이 의도한 경로를 표시하려면 \"null\"을 반환하세요\n    }\n  },\n  ...\n```\n\n- GoRouter 생성자에서 리다이렉트를 정의할 수 있습니다. 모든 탐색 이벤트보다 먼저 호출됩니다.\n- GoRoute 생성자에서 리다이렉트를 정의할 수 있습니다. 탐색 이벤트가 경로를 표시하기 직전에 호출됩니다.\n\n# 전환 애니메이션\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGoRouter를 사용하면 각 GoRoute에 대한 전환 애니메이션을 사용자 정의할 수 있어요. 사용자 정의 전환 애니메이션을 구성하려면 GoRoute 생성자에 pageBuilder 매개변수를 제공하세요:\n\n```js\nGoRoute(\n  path: '/fruit-details',\n  pageBuilder: (context, state) {\n    return CustomTransitionPage(\n      key: state.pageKey,\n      child: FruitDetailsScreen(),\n      transitionsBuilder: (context, animation, secondaryAnimation, child) {\n        // 애니메이션의 값에 따라 화면의 불투명도를 변경합니다. \n        return FadeTransition(\n          opacity: CurveTween(curve: Curves.easeInOutCirc).animate(animation),\n          child: child,\n        );\n      },\n    );\n  },\n),\n```\n\n전체 예제는 전환 애니메이션 샘플을 참조하세요.\n\n# 에러 처리 (404 페이지)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기본적으로, go_router는 MaterialApp 및 CupertinoApp용 기본 오류 화면과 사용되지 않는 경우의 기본 오류 화면이 함께 제공됩니다. 또한 errorBuilder 매개변수를 사용하여 기본 오류 화면을 대체할 수도 있습니다:\n\n```js\nGoRouter(\n  /* ... */\n  errorBuilder: (context, state) =\u003e ErrorPage(state.error),\n);\n```\n\n# 이전에 이동하기 전에 !!\n\ngo_router에는 아직도 좋은 기능이 있습니다. GoRouter에 NavigatorObserver를 추가하여 Navigator의 동작을 관찰하고 route가 푸시, 팝 또는 대체될 때마다 알림을 받습니다. 이를 위해 NavigatorObserver를 확장하는 클래스를 만들어 보겠습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\nclass MyNavigatorObserver extends NavigatorObserver {\n  @override\n  void didPush(Route\u003cdynamic\u003e route, Route\u003cdynamic\u003e? previousRoute) {\n    log('did push route');\n  }\n\n  @override\n  void didPop(Route\u003cdynamic\u003e route, Route\u003cdynamic\u003e? previousRoute) {\n    log('did pop route');\n  }\n```\n\n이제 MyNavigatorObserver를 GoRouter에 추가해 봅시다.\n\n```dart\nGoRouter(\n  ...\n  observers: [ // 내비게이터 옵저버 추가\n    MyNavigatorObserver(),\n  ],\n...\n)\n```\n\n이벤트가 발생하면 내비게이터에 알림이 전달됩니다.\n","ogImage":{"url":"/assets/img/2024-06-19-FlutterGoRouterTheCrucialGuide_0.png"},"coverImage":"/assets/img/2024-06-19-FlutterGoRouterTheCrucialGuide_0.png","tag":["Tech"],"readingTime":10},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-FlutterGoRouterTheCrucialGuide_0.png\" alt=\"FlutterGoRouter\"\u003e\u003c/p\u003e\n\u003cp\u003eGo_router은 Flutter에서 라우팅을 위한 서드 파티 패키지로, 기본 플러터 라우팅 옵션보다 더 유연하고 사용하기 쉬운 솔루션을 제공하기 위해 만들어졌습니다. 라우트가 어떻게 정의되고 관리되는지에 대해 더 많은 제어를 원하는 경우 유용할 수 있습니다. 또한 웹에 대한 좋은 지원을 제공하기 때문에 애플리케이션에 좋은 선택일 수 있습니다.\u003c/p\u003e\n\u003cp\u003eURL 패턴을 정의하고, URL을 사용하여 탐색하며, 딥 링크를 처리하고, 기타 여러 네비게이션 관련 시나리오를 다룰 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e특징\u003c/h1\u003e\n\u003cp\u003e고 라우터(GoRouter)는 네비게이션을 간단하게 만들기 위한 다양한 기능을 제공합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eNavigator API와의 하위 호환성\u003c/li\u003e\n\u003cli\u003eMaterial 및 Cupertino 앱을 지원\u003c/li\u003e\n\u003cli\u003eStatefulShellRoute를 사용하여 중첩된 탭 탐색 지원\u003c/li\u003e\n\u003cli\u003e목적지에 대한 여러 화면 표시 (하위 라우트)\u003c/li\u003e\n\u003cli\u003e템플릿 구문을 사용하여 경로 및 쿼리 매개변수 구문 분석\u003c/li\u003e\n\u003cli\u003e리디렉션 지원 — 사용자를 다른 URL로 리디렉션할 수 있으며,예를 들어 사용자가 인증되지 않은 경우에는 로그인 페이지로 이동할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e시작하기\u003c/h1\u003e\n\u003cp\u003e시작하려면 pubspec.yaml에 go_router를 추가하세요. 이 문서에서는 ^13.2.0을 사용하겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-yaml\"\u003e\u003cspan class=\"hljs-attr\"\u003edependencies:\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003ego_router:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e^13.2.0\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e라우트 구성\u003c/h1\u003e\n\u003cp\u003e이제 그렇게 한 다음에 GoRouter 구성을 앱에 추가해 봅시다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-dart\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:go_router/go_router.dart'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e// GoRouter 구성\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efinal\u003c/span\u003e _router = GoRouter(\n  initialLocation: \u003cspan class=\"hljs-string\"\u003e'/'\u003c/span\u003e,\n  routes: [\n    GoRoute(\n      name: \u003cspan class=\"hljs-string\"\u003e'home'\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 선택사항, 라우트에 이름 추가. 경로 대신 이름으로 이동 가능\u003c/span\u003e\n      path: \u003cspan class=\"hljs-string\"\u003e'/'\u003c/span\u003e,\n      builder: (context, state) =\u003e HomeScreen(),\n    ),\n    GoRoute(\n      name: \u003cspan class=\"hljs-string\"\u003e'shope'\u003c/span\u003e,\n      path: \u003cspan class=\"hljs-string\"\u003e'/shope'\u003c/span\u003e,\n      builder: (context, state) =\u003e ShopeScreen(),\n    ),\n  ],\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그럼 MaterialApp.router 또는 CupertinoApp.router 생성자를 사용하고 routerConfig 매개변수를 GoRouter 구성 객체로 설정할 수 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyApp\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eStatelessWidget\u003c/span\u003e {\n  @override\n  \u003cspan class=\"hljs-title class_\"\u003eWidget\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebuild\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eBuildContext context\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMaterialApp\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erouter\u003c/span\u003e(\n      \u003cspan class=\"hljs-attr\"\u003erouterConfig\u003c/span\u003e: _router,\n    );\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이것으로 준비 끝이에요 🙂 go_router를 사용해보세요 !!!\u003c/p\u003e\n\u003ch1\u003e매개변수\u003c/h1\u003e\n\u003cp\u003e경로 매개변수를 지정하려면 경로 세그먼트 앞에 콜론(:) 문자를 붙이고 고유한 이름(:userId와 같은)을 따라야 합니다. 빌더 콜백에 제공된 GoRouterState 객체를 통해 매개변수 값을 액세스할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eGoRoute\u003c/span\u003e(\n  \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/fruits/:id'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003ebuilder\u003c/span\u003e: (context, state) {\n     final id = state.\u003cspan class=\"hljs-property\"\u003epathParameters\u003c/span\u003e[\u003cspan class=\"hljs-string\"\u003e\"id\"\u003c/span\u003e]! \u003cspan class=\"hljs-comment\"\u003e// URL에서 \"id\" 매개변수 가져오기\u003c/span\u003e\n     \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFruitsPage\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: id);\n  },\n),\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e하위 루트 추가\u003c/h1\u003e\n\u003cp\u003e일치하는 경로는 네비게이터에서 여러 화면이 표시되는 결과를 가져올 수 있습니다. 이는 push()를 호출한 것과 동일한 효과이며, 새 화면이 이전 화면 위에 표시되고 AppBar 위젯에 인앱 뒤로 가기 버튼이 제공됩니다.\u003c/p\u003e\n\u003cp\u003e다음과 같이 부모 라우트와 그 자식 라우트를 추가해 보세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eGoRoute\u003c/span\u003e(\n  \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/fruits'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003ebuilder\u003c/span\u003e: (context, state) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFruitsPage\u003c/span\u003e();\n  },\n  \u003cspan class=\"hljs-attr\"\u003eroutes\u003c/span\u003e: \u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eRouteBase\u003c/span\u003e\u003e[ \u003cspan class=\"hljs-comment\"\u003e// 자식 라우트 추가\u003c/span\u003e\n    \u003cspan class=\"hljs-title class_\"\u003eGoRoute\u003c/span\u003e(\n      \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'fruits-details'\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 참고: 라우터의 부모에 \"/\" 문자를 명시할 필요가 없습니다.\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003ebuilder\u003c/span\u003e: (context, state) {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFruitDetailsPage\u003c/span\u003e();\n      },\n    ),\n  ],\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e화면 간 이동\u003c/h1\u003e\n\u003cp\u003ego_router를 사용하여 목적지 간에 이동하는 다양한 방법이 있습니다.\u003c/p\u003e\n\u003cp\u003e새 화면으로 이동하려면 URL과 함께 context.go()를 호출하십시오:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title function_\"\u003ebuild\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eBuildContext context\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTextButton\u003c/span\u003e(\n    \u003cspan class=\"hljs-attr\"\u003eonPressed\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e context.\u003cspan class=\"hljs-title function_\"\u003ego\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/fruits/fruit-detail'\u003c/span\u003e),\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eURL 대신 이름을 사용하여 탐색할 수도 있습니다. context.goNamed()를 호출하면 됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title function_\"\u003ebuild\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eBuildContext context\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTextButton\u003c/span\u003e(\n    \u003cspan class=\"hljs-comment\"\u003e// 라우트에 \"name\"을 추가하지 않으면 오류가 발생할 수 있습니다\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eonPressed\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e context.\u003cspan class=\"hljs-title function_\"\u003egoNamed\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'fruit-detail'\u003c/span\u003e),\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eURI에 경로 매개변수를 포함하여 만들려면 Uri 클래스를 사용할 수 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003econtext.\u003cspan class=\"hljs-title function_\"\u003ego\u003c/span\u003e(\n  \u003cspan class=\"hljs-title class_\"\u003eUri\u003c/span\u003e(\n    \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/fruit-detail'\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003epathParameters\u003c/span\u003e: {\u003cspan class=\"hljs-string\"\u003e'id'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'10'\u003c/span\u003e},\n  ).\u003cspan class=\"hljs-title function_\"\u003etoString\u003c/span\u003e(),\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003econtext.pop()을 사용하면 현재 화면에서 뒤로 이동할 수 있어요.\u003c/p\u003e\n\u003ch1\u003e중첩된 탭 탐색\u003c/h1\u003e\n\u003cp\u003e일부 앱은 화면의 하위 섹션에 목적지를 표시합니다. 예를 들어, 화면 간을 이동할 때 항상 화면 상에 남아 있는 BottomNavigationBar와 같은 경우입니다.\u003c/p\u003e\n\u003cp\u003eStatefulShellRoute를 사용하여 중첩된 탐색을 설정했습니다.\u003c/p\u003e\n\u003cp\u003e이 StatefulShellRoute 클래스는 루트 네비게이터와 다른 네비게이터에 하위 루트를 배치합니다. 그러나 이 루트 클래스는 각 중첩 분기에 대해 별도의 네비게이터를 생성하므로 (즉, 병렬 탐색 트리), 상태가 있는 중첩된 네비게이션을 구축할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e예를 들어 BottomNavigationBar를 구현하는 경우, 각 탭에 대한 지속적인 네비게이션 상태가 있는 UI를 구현하는 것이 편리합니다.\u003c/p\u003e\n\u003cp\u003e상태 유지 쉘 라우트는 상태 유지 브랜치를 나타내는 각각의 StatefulShellBranch 항목 목록을 지정하여 생성됩니다. StatefulShellBranch는 브랜치를 위한 루트 라우트와 네비게이터 키 (GlobalKey) 및 선택적 초기 위치를 제공합니다.\u003c/p\u003e\n\u003cp\u003e구현 방법을 살펴보겠습니다 🙂\u003c/p\u003e\n\u003cp\u003e먼저 라우터를 만들어 시작합니다. StatefulShellRoute.indexedStack()을 라우트에 추가할 것이며, 이 클래스는 중첩된 내비게이션을 생성하는 역할을 맡게 됩니다.\u003c/p\u003e\n\u003cp\u003eStatefulShellRoute.indexedStack()은 중첩된 네비게이터에 IndexedStack을 사용하는 StatefulShellRoute를 생성합니다.\u003c/p\u003e\n\u003cp\u003e이 생성자는 분기 네비게이터를 나타내는 위젯을 관리하는 컨테이너(navigatorContainerBuilder)에 대한 IndexedStack 기반 구현을 제공합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-dart\"\u003e\u003cspan class=\"hljs-comment\"\u003e// `root` 및 `section` 네비게이터를 위한 키 생성하여 불필요한 재구성을 피합니다\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efinal\u003c/span\u003e _rootNavigatorKey = GlobalKey\u0026#x3C;NavigatorState\u003e();\n\u003cspan class=\"hljs-keyword\"\u003efinal\u003c/span\u003e _sectionNavigatorKey = GlobalKey\u0026#x3C;NavigatorState\u003e();\n\n\n\u003cspan class=\"hljs-keyword\"\u003efinal\u003c/span\u003e router = GoRouter(\n  navigatorKey: _rootNavigatorKey,\n  initialLocation: \u003cspan class=\"hljs-string\"\u003e'/home'\u003c/span\u003e,\n  routes: \u0026#x3C;RouteBase\u003e[\n    StatefulShellRoute.indexedStack(\n      builder: (context, state, navigationShell) {\n        \u003cspan class=\"hljs-comment\"\u003e// 커스텀 쉘(예: BottomNavigationBar)을 구현하는 위젯을 반환합니다.\u003c/span\u003e\n        \u003cspan class=\"hljs-comment\"\u003e// 다른 분기로 상태를 유지하면서 이동할 수 있도록 [StatefulNavigationShell]이 전달됩니다.\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e ScaffoldWithNavbar(navigationShell);\n      },\n      branches: [\n        \u003cspan class=\"hljs-comment\"\u003e// 1번 탭을 위한 루트 분기\u003c/span\u003e\n        StatefulShellBranch(\n          navigatorKey: _sectionNavigatorKey,\n          \u003cspan class=\"hljs-comment\"\u003e// 이 분기의 루트 추가\u003c/span\u003e\n          \u003cspan class=\"hljs-comment\"\u003e// 가능한 경우 하위 루트가 있는 각 루트(예: feed/uuid/details)를 추가합니다\u003c/span\u003e\n          routes: \u0026#x3C;RouteBase\u003e[\n            GoRoute(\n              path: \u003cspan class=\"hljs-string\"\u003e'/shope'\u003c/span\u003e,\n              builder: (context, state) =\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e ShopePage(),\n              routes: \u0026#x3C;RouteBase\u003e[\n                GoRoute(\n                  path: \u003cspan class=\"hljs-string\"\u003e'detail'\u003c/span\u003e,\n                  builder: (context, state) =\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e FeedDetailsPage(),\n                )\n              ],\n            ),\n          ],\n        ),\n\n        \u003cspan class=\"hljs-comment\"\u003e// 2번 탭을 위한 루트 분기\u003c/span\u003e\n        StatefulShellBranch(routes: \u0026#x3C;RouteBase\u003e[\n          \u003cspan class=\"hljs-comment\"\u003e// 이 분기의 루트 추가\u003c/span\u003e\n          \u003cspan class=\"hljs-comment\"\u003e// 가능한 경우 하위 루트가 있는 각 루트(예: shope/uuid/details)를 추가합니다\u003c/span\u003e\n          GoRoute(\n            path: \u003cspan class=\"hljs-string\"\u003e'/home'\u003c/span\u003e,\n            builder: (context, state) =\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e HomePage(),\n          ),\n        ])\n      ],\n    ),\n  ],\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e우리의 루트에 StatefulShellRoute.indexedStack()를 추가했습니다. 이것은 우리의 분기를 생성하고 사용자 정의 쉘(이 경우 BottomNavigationBar)을 반환합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e빌더: (context, state, navigationShell)에서는 사용자 정의 쉘인 Scaffold with BottomNavigationBar를 반환하며, 이 페이지로 이동할 때 navigationShell을 전달해야 합니다(예: Shope == Home).\u003c/li\u003e\n\u003cli\u003ebranches:[]에서는 StatefulShellBranch(분기) 목록을 제공합니다. 이전에 생성한 _sectionNavigatorKey를 첫 번째 분기에 navigatorKey 속성으로 전달하지만, 다른 분기에는 기본 키가 사용됩니다. 또한 해당 분기에 대한 지원 루트 목록인 RouteBase 목록을 제공합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e우리의 빌더가 커스텀 쉘을 반환하는 것을 확인할 수 있습니다. 이 쉘에는 BottomNavigationBar가 포함되어 있어요. 그러니 이제 그것을 만들어 봅시다. 👇🏿\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:flutter/material.dart'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'package:go_router/go_router.dart'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eScaffoldWithNavbar\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eStatelessWidget\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eScaffoldWithNavbar\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003enavigationShell\u003c/span\u003e, {\u003cspan class=\"hljs-variable language_\"\u003esuper\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ekey\u003c/span\u003e});\n\n  \u003cspan class=\"hljs-comment\"\u003e/// 브랜치 네비게이터를 위한 네비게이션 쉘 및 컨테이너입니다.\u003c/span\u003e\n  final \u003cspan class=\"hljs-title class_\"\u003eStatefulNavigationShell\u003c/span\u003e navigationShell;\n\n  @override\n  \u003cspan class=\"hljs-title class_\"\u003eWidget\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebuild\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eBuildContext context\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eScaffold\u003c/span\u003e(\n      \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: navigationShell,\n      \u003cspan class=\"hljs-attr\"\u003ebottomNavigationBar\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eBottomNavigationBar\u003c/span\u003e(\n        \u003cspan class=\"hljs-attr\"\u003ecurrentIndex\u003c/span\u003e: navigationShell.\u003cspan class=\"hljs-property\"\u003ecurrentIndex\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003eitems\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [\n          \u003cspan class=\"hljs-title class_\"\u003eBottomNavigationBarItem\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eicon\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eIcon\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eIcons\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eshop\u003c/span\u003e), \u003cspan class=\"hljs-attr\"\u003elabel\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'Shope'\u003c/span\u003e),\n          \u003cspan class=\"hljs-title class_\"\u003eBottomNavigationBarItem\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eicon\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eIcon\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eIcons\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ehome\u003c/span\u003e), \u003cspan class=\"hljs-attr\"\u003elabel\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'Home'\u003c/span\u003e),\n        ],\n        \u003cspan class=\"hljs-attr\"\u003eonTap\u003c/span\u003e: _onTap,\n      ),\n    );\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e_onTap\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eindex\u003c/span\u003e) {\n    navigationShell.\u003cspan class=\"hljs-title function_\"\u003egoBranch\u003c/span\u003e(\n      index,\n      \u003cspan class=\"hljs-comment\"\u003e// 바텀 네비게이션 바를 사용할 때 일반적인 패턴은 현재 활성화된 아이템을 탭했을 때 초기 위치로 이동하는 것을 지원하는 것입니다. 이 예제에서는 goBranch의 initialLocation 매개변수를 사용하여 이 동작을 지원하는 방법을 보여줍니다.\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003einitialLocation\u003c/span\u003e: index == navigationShell.\u003cspan class=\"hljs-property\"\u003ecurrentIndex\u003c/span\u003e,\n    );\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e기본적으로 BottomNavigationBar가 있는 Scaffold를 반환하며, 본문은 라우터에서 얻은 navigationShell이 될 것입니다.\u003c/p\u003e\n\u003cp\u003e또한 \u003ccode\u003e_onTap(index)\u003c/code\u003e가 있습니다. 여기서는 \u003ccode\u003enavigationShell.goBranch(index)\u003c/code\u003e를 사용하여 브랜치 간에 전환할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e그럼 이제 여러분의 프로젝트에 이를 구현할 준비가 끝났어요 🥳🎉\u003c/p\u003e\n\u003cp\u003e자세한 예시는 아래의 저장소를 확인해주세요 👇🏿\u003c/p\u003e\n\u003ch1\u003eGuards\u003c/h1\u003e\n\u003cp\u003e특정 경로를 보호하기 위해, 예를 들어 인증되지 않은 사용자로부터, GoRouter를 통해 전역 리디렉션이 설정될 수 있습니다. 가장 일반적인 예는 /login이 아닌 모든 경로를 보호하는 리디렉트 설정이며, 사용자가 인증되지 않은 경우 /login으로 리디렉트됩니다.\u003c/p\u003e\n\u003cp\u003e리다이렉션은 GoRouterRedirect 유형의 콜백입니다. 일부 응용 프로그램 상태에 따라서 들어오는 위치를 변경하려면 GoRouter 또는 GoRoute 생성자에 콜백을 추가하세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eGoRouter\u003c/span\u003e(\n  \u003cspan class=\"hljs-attr\"\u003eredirect\u003c/span\u003e: (\u003cspan class=\"hljs-title class_\"\u003eBuildContext\u003c/span\u003e context, \u003cspan class=\"hljs-title class_\"\u003eGoRouterState\u003c/span\u003e state) {\n    final isAuthenticated = \u003cspan class=\"hljs-comment\"\u003e// 사용자가 인증되었는지 확인하는 논리를 여기에 작성하세요\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!isAuthenticated) {\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'/login'\u003c/span\u003e;\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 리디렉트 없이 의도한 경로를 표시하려면 \"null\"을 반환하세요\u003c/span\u003e\n    }\n  },\n  ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eGoRouter 생성자에서 리다이렉트를 정의할 수 있습니다. 모든 탐색 이벤트보다 먼저 호출됩니다.\u003c/li\u003e\n\u003cli\u003eGoRoute 생성자에서 리다이렉트를 정의할 수 있습니다. 탐색 이벤트가 경로를 표시하기 직전에 호출됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e전환 애니메이션\u003c/h1\u003e\n\u003cp\u003eGoRouter를 사용하면 각 GoRoute에 대한 전환 애니메이션을 사용자 정의할 수 있어요. 사용자 정의 전환 애니메이션을 구성하려면 GoRoute 생성자에 pageBuilder 매개변수를 제공하세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eGoRoute\u003c/span\u003e(\n  \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/fruit-details'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003epageBuilder\u003c/span\u003e: (context, state) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCustomTransitionPage\u003c/span\u003e(\n      \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e: state.\u003cspan class=\"hljs-property\"\u003epageKey\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eFruitDetailsScreen\u003c/span\u003e(),\n      \u003cspan class=\"hljs-attr\"\u003etransitionsBuilder\u003c/span\u003e: (context, animation, secondaryAnimation, child) {\n        \u003cspan class=\"hljs-comment\"\u003e// 애니메이션의 값에 따라 화면의 불투명도를 변경합니다. \u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFadeTransition\u003c/span\u003e(\n          \u003cspan class=\"hljs-attr\"\u003eopacity\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCurveTween\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ecurve\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCurves\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eeaseInOutCirc\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003eanimate\u003c/span\u003e(animation),\n          \u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: child,\n        );\n      },\n    );\n  },\n),\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e전체 예제는 전환 애니메이션 샘플을 참조하세요.\u003c/p\u003e\n\u003ch1\u003e에러 처리 (404 페이지)\u003c/h1\u003e\n\u003cp\u003e기본적으로, go_router는 MaterialApp 및 CupertinoApp용 기본 오류 화면과 사용되지 않는 경우의 기본 오류 화면이 함께 제공됩니다. 또한 errorBuilder 매개변수를 사용하여 기본 오류 화면을 대체할 수도 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eGoRouter\u003c/span\u003e(\n  \u003cspan class=\"hljs-comment\"\u003e/* ... */\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003eerrorBuilder\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003econtext, state\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eErrorPage\u003c/span\u003e(state.\u003cspan class=\"hljs-property\"\u003eerror\u003c/span\u003e),\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e이전에 이동하기 전에 !!\u003c/h1\u003e\n\u003cp\u003ego_router에는 아직도 좋은 기능이 있습니다. GoRouter에 NavigatorObserver를 추가하여 Navigator의 동작을 관찰하고 route가 푸시, 팝 또는 대체될 때마다 알림을 받습니다. 이를 위해 NavigatorObserver를 확장하는 클래스를 만들어 보겠습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-dart\"\u003e\u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eMyNavigatorObserver\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eNavigatorObserver\u003c/span\u003e \u003c/span\u003e{\n  \u003cspan class=\"hljs-meta\"\u003e@override\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e didPush(Route\u0026#x3C;\u003cspan class=\"hljs-built_in\"\u003edynamic\u003c/span\u003e\u003e route, Route\u0026#x3C;\u003cspan class=\"hljs-built_in\"\u003edynamic\u003c/span\u003e\u003e? previousRoute) {\n    log(\u003cspan class=\"hljs-string\"\u003e'did push route'\u003c/span\u003e);\n  }\n\n  \u003cspan class=\"hljs-meta\"\u003e@override\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e didPop(Route\u0026#x3C;\u003cspan class=\"hljs-built_in\"\u003edynamic\u003c/span\u003e\u003e route, Route\u0026#x3C;\u003cspan class=\"hljs-built_in\"\u003edynamic\u003c/span\u003e\u003e? previousRoute) {\n    log(\u003cspan class=\"hljs-string\"\u003e'did pop route'\u003c/span\u003e);\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 MyNavigatorObserver를 GoRouter에 추가해 봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-dart\"\u003eGoRouter(\n  ...\n  observers: [ \u003cspan class=\"hljs-comment\"\u003e// 내비게이터 옵저버 추가\u003c/span\u003e\n    MyNavigatorObserver(),\n  ],\n...\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이벤트가 발생하면 내비게이터에 알림이 전달됩니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-19-FlutterGoRouterTheCrucialGuide"},"buildId":"-yEBofE4jMl3RL1kr5c4Y","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>