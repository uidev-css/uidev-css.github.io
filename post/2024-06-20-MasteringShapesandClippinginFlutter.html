<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>플러터에서 모양과 클리핑 마스터하기 | uidev-css</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://uidev-css.github.io///post/2024-06-20-MasteringShapesandClippinginFlutter" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="플러터에서 모양과 클리핑 마스터하기 | uidev-css" data-gatsby-head="true"/><meta property="og:title" content="플러터에서 모양과 클리핑 마스터하기 | uidev-css" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://uidev-css.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://uidev-css.github.io///post/2024-06-20-MasteringShapesandClippinginFlutter" data-gatsby-head="true"/><meta name="twitter:title" content="플러터에서 모양과 클리핑 마스터하기 | uidev-css" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | uidev-css" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-20 13:42" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b4eed7811784bdd3.js" defer=""></script><script src="/_next/static/5et5eMZxpKCgDAAyIS6Ju/_buildManifest.js" defer=""></script><script src="/_next/static/5et5eMZxpKCgDAAyIS6Ju/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UIDEV CSS</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">플러터에서 모양과 클리핑 마스터하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="플러터에서 모양과 클리핑 마스터하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UIDEV CSS</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 20, 2024</span><span class="posts_reading_time__f7YPP">9<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-20-MasteringShapesandClippinginFlutter&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>도형과 상자를 다루는 것은 설계된 UI를 구현하는 방법을 알지 못하면 압도될 수 있습니다. 이 기사에서는 매우 기초부터 시작하여 일부 고급 예제로 이동할 것입니다.</p>
<h2>1. 도형과 상자란 무엇인가요?</h2>
<p>도형은 해당 경로에 의해 정의된 어떤 형태를 나타낼 수 있습니다.</p>
<p>상자는 4개의 점으로 구성된 직사각형 모양을 나타냅니다. 테두리 반경과 같은 추가 속성을 가질 수 있습니다.</p>
<div class="content-ad"></div>
<p>위젯 Flutter의 다양한 컨텍스트에서 상자가 나타날 수 있어요.</p>
<p>예를 들어:</p>
<ul>
<li>RenderBox: 비 슬리버 컨텍스트의 위젯의 RenderObject</li>
<li>BoxDecoration</li>
<li>BoxBorder</li>
</ul>
<p>또한 ShapeDecoration, ShapeBorder와 같은 클래스들도 있어요.</p>
<p>우리는 Container, DecoratedSlivers 또는 DecoratedBoxes를 스타일링하기 위해 자주 BoxDecoration을 사용해요:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-title class_">DecoratedBox</span>(
  <span class="hljs-attr">decoration</span>: <span class="hljs-title class_">BoxDecoration</span>( <span class="hljs-comment">// &#x3C;- this</span>
    <span class="hljs-attr">borderRadius</span>: <span class="hljs-title class_">BorderRadius</span>.<span class="hljs-title function_">circular</span>(<span class="hljs-number">10</span>),
    <span class="hljs-attr">color</span>: <span class="hljs-title class_">Colors</span>.<span class="hljs-property">amber</span>,
  ),
  <span class="hljs-attr">child</span>: <span class="hljs-keyword">const</span> <span class="hljs-title class_">SizedBox</span>(<span class="hljs-attr">height</span>: <span class="hljs-number">200</span>, <span class="hljs-attr">width</span>: <span class="hljs-number">200</span>),
)
</code></pre>
<p>그냥 이렇게 해서, 결과를 얻습니다:</p>
<img src="/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_0.png">
<p>대안으로 ShapeDecoration을 사용할 수도 있는데, 이것은 색상, 그림자, 그라디언트의 비슷한 사용자 정의를 제공하지만 주요 차이점은 그 모양 매개변수가 BoxShape 대신 ShapeBorder를 사용한다는 것입니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-title class_">DecoratedBox</span>(
  <span class="hljs-attr">decoration</span>: <span class="hljs-title class_">ShapeDecoration</span>( <span class="hljs-comment">// &#x3C;- 이 부분</span>
    <span class="hljs-attr">color</span>: <span class="hljs-title class_">Colors</span>.<span class="hljs-property">amber</span>,
    <span class="hljs-attr">shape</span>: <span class="hljs-title class_">BeveledRectangleBorder</span>(<span class="hljs-attr">borderRadius</span>: <span class="hljs-title class_">BorderRadius</span>.<span class="hljs-title function_">circular</span>(<span class="hljs-number">20</span>)),
  ),
  <span class="hljs-attr">child</span>: <span class="hljs-keyword">const</span> <span class="hljs-title class_">SizedBox</span>(<span class="hljs-attr">height</span>: <span class="hljs-number">200</span>, <span class="hljs-attr">width</span>: <span class="hljs-number">200</span>),
)
</code></pre>
<img src="/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_1.png">
<p>그럼 ShapeBorder는 정확히 무엇인가요?</p>
<p>구현을 확인하면 좀 더 명확해집니다. OutlinedBorder, StarBorder, BeveledRectangleBorder와 같은 슈퍼클래스들이 있습니다. 이것들은 위젯을 꾸미기 위한 다양한 모양들입니다. 그리고 WidgetStateOutlinedBorder도 있습니다. WidgetStates에 익숙하지 않다면 해당 기사를 읽어보세요.</p>
<div class="content-ad"></div>
<p>경계의 본질은 내부 경로와 외부 경로 2개가 있어야 한다는 것을 의미합니다:</p>
<p><img src="/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_2.png" alt="MasteringShapesandClippinginFlutter"></p>
<p>베지에 곡선에 익숙하지 않다면, 이 대화식 가이드를 확인하는 것을 추천합니다. 플러터의 Path는 선형, 이차, 삼차 및 콘회의 절을 지원합니다.</p>
<p>용어는 여기까지, 이제 재미있는 일을 시작해 봅시다: 사용자 정의 모양을 만들어 보세요!</p>
<div class="content-ad"></div>
<h1>2. 사용자 정의 ShapeBorder 구현</h1>
<p>위 작업을 수행하려면 ShapeBorder의 슈퍼 클래스 또는 OutlinedBorder를 만들고 다음 메서드를 구현해야 합니다:</p>
<ul>
<li>getInnerPath 및 getOuterPath: 해당 경로를 반환하는 메서드</li>
<li>paint: 모양을 그리는 메서드</li>
<li>scale, copyWith</li>
</ul>
<p>원하는 메시지 버블 모양을 만들어보겠습니다. 원구획을 사용하고 두께(w) 매개변수를 변수로 사용하세요.</p>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_3.png" alt="이미지"></p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageShapeBorder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">OutlinedBorder</span> {
  final double borderRadius;
  final double weight;

  <span class="hljs-keyword">const</span> <span class="hljs-title class_">MessageShapeBorder</span>({
    <span class="hljs-variable language_">super</span>.<span class="hljs-property">side</span>, 
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">borderRadius</span> = <span class="hljs-number">50</span>,
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">weight</span> = <span class="hljs-number">2.5</span>,
  });

  ...

}
</code></pre>
<p>그 다음으로, getOuterPath 메서드를 구현합니다. 여기서 경로는 아래 왼쪽 모서리에서 시계 방향으로 이동하는 선 및 물결 모양 세그먼트로 구성됩니다.</p>
<pre><code class="hljs language-js">  @override
  <span class="hljs-title class_">Path</span> <span class="hljs-title function_">getOuterPath</span>(<span class="hljs-params">Rect rect, {TextDirection? textDirection}</span>) {
    final double left = rect.<span class="hljs-property">left</span>;
    final double right = rect.<span class="hljs-property">right</span>;
    final double top = rect.<span class="hljs-property">top</span>;
    final double bottom = rect.<span class="hljs-property">bottom</span>;

    final radius = borderRadius;
    final offset = <span class="hljs-number">10</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Path</span>()
      ..<span class="hljs-title function_">moveTo</span>(left, bottom)
      ..<span class="hljs-title function_">conicTo</span>(left + offset, bottom - offset, left + offset,
          bottom - <span class="hljs-number">2</span> * radius, weight)
      ..<span class="hljs-title function_">lineTo</span>(left + offset, top + radius)
      ..<span class="hljs-title function_">conicTo</span>(left + offset, top, left + offset + radius, top, weight)
      ..<span class="hljs-title function_">lineTo</span>(right - radius, top)
      ..<span class="hljs-title function_">conicTo</span>(right, top, right, top + radius, weight)
      ..<span class="hljs-title function_">lineTo</span>(right, bottom - radius)
      ..<span class="hljs-title function_">conicTo</span>(right, bottom, right - radius, bottom, weight)
      ..<span class="hljs-title function_">close</span>();
  }
</code></pre>
<div class="content-ad"></div>
<p>더 명확하게 하기 위해, 아래는 각 행이 하는 작업을 시각적으로 보여줍니다:</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*KKbxvf4nJa9IXIUcPdPUxg.gif" alt="이미지"></p>
<p>이제 약간 다른 내부 경로를 만들어 봅시다:</p>
<pre><code class="hljs language-js">  @override
  <span class="hljs-title class_">Path</span> <span class="hljs-title function_">getInnerPath</span>(<span class="hljs-params">Rect rect, {TextDirection? textDirection}</span>) {
    final strokeWidth = side.<span class="hljs-property">width</span>;

    final double left = rect.<span class="hljs-property">left</span> + strokeWidth;
    final double right = rect.<span class="hljs-property">right</span> - strokeWidth;
    final double top = rect.<span class="hljs-property">top</span> + strokeWidth;
    final double bottom = rect.<span class="hljs-property">bottom</span> - strokeWidth;

    final radius = math.<span class="hljs-title function_">max</span>(<span class="hljs-number">0</span>, borderRadius - <span class="hljs-number">10</span>);
    final offset = <span class="hljs-number">10</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Path</span>()
      ..<span class="hljs-title function_">moveTo</span>(left + offset + radius, bottom)
      ..<span class="hljs-title function_">conicTo</span>(
          left + offset, bottom, left + offset, bottom - <span class="hljs-number">2</span> * radius, weight)
      ..<span class="hljs-title function_">lineTo</span>(left + offset, top + radius)
      ..<span class="hljs-title function_">conicTo</span>(left + offset, top, left + offset + radius, top, weight)
      ..<span class="hljs-title function_">lineTo</span>(right - radius, top)
      ..<span class="hljs-title function_">conicTo</span>(right, top, right, top + radius, weight)
      ..<span class="hljs-title function_">lineTo</span>(right, bottom - radius)
      ..<span class="hljs-title function_">conicTo</span>(right, bottom, right - radius, bottom, weight)
      ..<span class="hljs-title function_">close</span>();
  }
</code></pre>
<div class="content-ad"></div>
<pre><code class="hljs language-js">  @override
  <span class="hljs-keyword">void</span> <span class="hljs-title function_">paint</span>(<span class="hljs-params">Canvas canvas, Rect rect, {TextDirection? textDirection}</span>) {
    canvas.<span class="hljs-title function_">drawPath</span>(<span class="hljs-title function_">getInnerPath</span>(rect), <span class="hljs-title class_">Paint</span>()..<span class="hljs-property">color</span> = side.<span class="hljs-property">color</span>);
  }
</code></pre>
<img src="/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_4.png">
<p>이제 이 모양을 다음과 같이 DecoratedBox에서 사용할 수 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">DecoratedBox</span>(
  <span class="hljs-attr">decoration</span>: <span class="hljs-title class_">ShapeDecoration</span>(
    <span class="hljs-attr">shape</span>: <span class="hljs-title class_">MessageShapeBorder</span>(
      <span class="hljs-attr">borderRadius</span>: <span class="hljs-number">30</span>,
      <span class="hljs-attr">fillColor</span>: <span class="hljs-title class_">Color</span>(<span class="hljs-number">0xFF7ADEFF</span>)
    ),
    <span class="hljs-attr">color</span>: <span class="hljs-title class_">Color</span>(<span class="hljs-number">0xFFd6f5ff</span>),
  ),
  <span class="hljs-attr">child</span>: <span class="hljs-title class_">Padding</span>(
    <span class="hljs-attr">padding</span>: <span class="hljs-title class_">EdgeInsets</span>.<span class="hljs-title function_">all</span>(<span class="hljs-number">20</span>).<span class="hljs-title function_">copyWith</span>(<span class="hljs-attr">left</span>: <span class="hljs-number">30</span>),
    <span class="hljs-attr">child</span>: <span class="hljs-title class_">Text</span>(<span class="hljs-string">"샘플 메시지 텍스트"</span>),
  ),
)
</code></pre>
<div class="content-ad"></div>
<img src="/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_5.png">
<p>안녕하세요! 코닉 섹션의 무게를 AnimatedBuilder를 사용하여 애니메이션할 수 있습니다. 만약 플러터의 애니메이션에 익숙하지 않다면, 꼭 공식 안내서를 읽어보시기를 강력히 추천합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">MessageShapeBorder</span>(
  <span class="hljs-attr">side</span>: <span class="hljs-title class_">BorderSide</span>(<span class="hljs-attr">color</span>: <span class="hljs-title class_">Color</span>(<span class="hljs-number">0xFF7ADEFF</span>), <span class="hljs-attr">width</span>: animation.<span class="hljs-property">value</span> + <span class="hljs-number">2</span>),
  <span class="hljs-attr">weight</span>: animation.<span class="hljs-property">value</span>,
  <span class="hljs-attr">borderRadius</span>: <span class="hljs-number">30</span>
)
</code></pre>
<img src="https://miro.medium.com/v2/resize:fit:1088/1*AqcXygpWbTcwMHVyDkAf6A.gif">
<div class="content-ad"></div>
<h1>3. 사용 중인 클리퍼</h1>
<p>Flutter에서는 여러 내장 클리퍼가 있습니다. 예를 들면:</p>
<ul>
<li>직사각형에 사용하는 ClipRect</li>
<li>둥근 직사각형에 사용하는 ClipRRect</li>
<li>원과 타원에 사용하는 ClipOval</li>
<li>사용자 정의 경로에 사용하는 ClipPath</li>
</ul>
<p>첫 세 개는 사용하기 매우 간단합니다. 클리핑을 원하는 위젯을 해당 클리퍼로 감싸기만 하면 클리핑 효과를 얻을 수 있습니다. 그러나 이러한 클래스들에 대해 더 알고 싶다면 여기 공식 문서 링크를 참조해주세요.</p>
<div class="content-ad"></div>
<p>ClipPath은 CustomClipper를 인수로 사용합니다. 대부분의 경우에는 ShapeBorder를 ShapeBorderClipper에 전달하면 됩니다. 이는 ShapeBorder의 외부 경로로 자식을 클리핑하는 CustomClipper의 구현입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">ClipPath</span>(
  <span class="hljs-attr">clipper</span>: <span class="hljs-keyword">const</span> <span class="hljs-title class_">ShapeBorderClipper</span>( <span class="hljs-comment">// &#x3C;- 이 부분</span>
    <span class="hljs-attr">shape</span>: <span class="hljs-title class_">MessageShapeBorder</span>(),
  ),
  <span class="hljs-attr">child</span>: <span class="hljs-title class_">Image</span>.<span class="hljs-title function_">asset</span>(
    <span class="hljs-string">"assets/6392956.jpg"</span>,
    <span class="hljs-attr">height</span>: <span class="hljs-number">300</span>,
    <span class="hljs-attr">width</span>: <span class="hljs-number">300</span>,
    <span class="hljs-attr">fit</span>: <span class="hljs-title class_">BoxFit</span>.<span class="hljs-property">cover</span>,
    <span class="hljs-attr">cacheHeight</span>: (<span class="hljs-number">300</span> * <span class="hljs-title class_">MediaQuery</span>.<span class="hljs-title function_">of</span>(context).<span class="hljs-property">devicePixelRatio</span>).<span class="hljs-title function_">toInt</span>(),
  ),
);
</code></pre>
<img src="/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_6.png">
<p>클리핑이 레이아웃에서 사용될 때마다 새 레이어가 생성되는 점을 주의해야 합니다. 이는 비교적 비용이 많이 드는 작업이므로 가능한 경우 클리핑 대신 데코레이션을 사용하세요.</p>
<div class="content-ad"></div>
<h1>4. 사용자 지정 클리퍼</h1>
<p>일부 경우에는 클리핑에 대해 더 많은 제어가 필요합니다. 예를 들어, 클리핑이 콘텐츠나 일부 형제 위젯에 따라 달라져야 할 때입니다. 콘텐츠에 따라 달라지는 노치가 있는 티켓 모양 위젯을 만들어 봅시다:</p>
<p><img src="/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_7.png" alt="이미지"></p>
<p>여기서 어려운 점은 상하 자식 위젯의 크기가 다를 수 있고, 노치가 이에 종속되어야 한다는 것입니다. Flutter에서 위젯의 크기 정보는 RenderObject의 하위 클래스인 RenderBox를 사용하여 얻을 수 있습니다. RenderObjects에 익숙하지 않다면, 공식 문서로 이동하여 확인해보세요.</p>
<div class="content-ad"></div>
<p>먼저 레이아웃을 만들고 상단과 하단 자식을 나누는 SizedBox에 GlobalKey를 추가해보겠습니다.</p>
<pre><code class="hljs language-js">final notchKey = <span class="hljs-title class_">GlobalKey</span>(); <span class="hljs-comment">// &#x3C;- 이 부분</span>

...

<span class="hljs-title class_">Column</span>(
  <span class="hljs-attr">children</span>: [
    widget.<span class="hljs-property">topChild</span>,
    <span class="hljs-title class_">SizedBox</span>(<span class="hljs-attr">key</span>: notchKey, <span class="hljs-attr">height</span>: <span class="hljs-number">20</span>), <span class="hljs-comment">// &#x3C;- 이 부분</span>
    widget.<span class="hljs-property">bottomChild</span>,
  ],
)
</code></pre>
<p>GlobalKey를 사용하면 위젯의 BuildContext를 얻을 수 있어요. RenderObject를 얻기 위해 context가 필요한데요. SizedBox의 좌표를 티켓 위젯의 context에서 가져와야 해서 해당 RenderBoxes가 필요해요. 여기에서는 Slivers을 사용하지 않기 때문에 RenderObject를 안전하게 RenderBox로 형변환할 수 있어요.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">ClipPath</span>(
  <span class="hljs-attr">clipper</span>: <span class="hljs-title function_">_TicketClipper</span>( <span class="hljs-comment">// &#x3C;- 우리의 클리퍼</span>
    <span class="hljs-attr">notchBox</span>: notchKey.<span class="hljs-property">currentContext</span>?.<span class="hljs-title function_">findRenderObject</span>() <span class="hljs-keyword">as</span> <span class="hljs-title class_">RenderBox</span>, <span class="hljs-comment">// &#x3C;- 이 부분</span>
    <span class="hljs-attr">ancestorBox</span>: context.<span class="hljs-title function_">findRenderObject</span>() <span class="hljs-keyword">as</span> <span class="hljs-title class_">RenderBox</span>, <span class="hljs-comment">// &#x3C;- 이 부분</span>
  ),
  <span class="hljs-attr">child</span>: <span class="hljs-title class_">ColoredBox</span>(
    <span class="hljs-attr">color</span>: <span class="hljs-title class_">Color</span>(<span class="hljs-number">0xFFd6f5ff</span>),
    <span class="hljs-attr">child</span>: <span class="hljs-title class_">Column</span>(
      <span class="hljs-attr">children</span>: ...
    ),
  ),
)
</code></pre>
<div class="content-ad"></div>
<p>그리고 클리퍼 자체는 다음과 같이 보일 것입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">_TicketClipper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">CustomClipper</span>&#x3C;<span class="hljs-title class_">Path</span>> {
  final <span class="hljs-title class_">RenderBox</span> notchBox;
  final <span class="hljs-title class_">RenderBox</span> ancestorBox;

  <span class="hljs-title function_">_TicketClipper</span>({required <span class="hljs-variable language_">this</span>.<span class="hljs-property">notchBox</span>, required <span class="hljs-variable language_">this</span>.<span class="hljs-property">ancestorBox</span>});

  @override
  <span class="hljs-title class_">Path</span> <span class="hljs-title function_">getClip</span>(<span class="hljs-params">Size size</span>) {
    final widgetRect = <span class="hljs-title class_">RRect</span>.<span class="hljs-title function_">fromRectAndRadius</span>(
      <span class="hljs-title class_">Rect</span>.<span class="hljs-title function_">fromPoints</span>(<span class="hljs-title class_">Offset</span>.<span class="hljs-property">zero</span>, <span class="hljs-title class_">Offset</span>(size.<span class="hljs-property">width</span>, size.<span class="hljs-property">height</span>)),
      <span class="hljs-keyword">const</span> <span class="hljs-title class_">Radius</span>.<span class="hljs-title function_">circular</span>(<span class="hljs-number">10</span>),
    );

    final notch = notchBox.<span class="hljs-title function_">localToGlobal</span>(<span class="hljs-title class_">Offset</span>.<span class="hljs-property">zero</span>, <span class="hljs-attr">ancestor</span>: ancestorBox);

    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Path</span>.<span class="hljs-title function_">combine</span>(
      <span class="hljs-title class_">PathOperation</span>.<span class="hljs-property">difference</span>,
      <span class="hljs-title class_">Path</span>()..<span class="hljs-title function_">addRRect</span>(widgetRect),
      <span class="hljs-title class_">Path</span>()
        ..<span class="hljs-title function_">addOval</span>(<span class="hljs-title class_">Rect</span>.<span class="hljs-title function_">fromCenter</span>(
            <span class="hljs-attr">center</span>: <span class="hljs-title class_">Offset</span>(<span class="hljs-number">0</span>, notch.<span class="hljs-property">dy</span> + <span class="hljs-number">10</span>), <span class="hljs-attr">width</span>: <span class="hljs-number">20</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">20</span>))
        ..<span class="hljs-title function_">addOval</span>(<span class="hljs-title class_">Rect</span>.<span class="hljs-title function_">fromCenter</span>(
            <span class="hljs-attr">center</span>: <span class="hljs-title class_">Offset</span>(size.<span class="hljs-property">width</span>, notch.<span class="hljs-property">dy</span> + <span class="hljs-number">10</span>), <span class="hljs-attr">width</span>: <span class="hljs-number">20</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">20</span>)),
    );
  }

  @override
  bool <span class="hljs-title function_">shouldReclip</span>(<span class="hljs-params">covariant CustomClipper&#x3C;Path> oldClipper</span>) {
    ...
  }
}
</code></pre>
<p>Flutter는 차이, 교차 등의 경로 작업을 지원합니다. 여기서는 둥근 사각형에서 2개의 원을 빼내어 원하는 모양을 얻어낸 것입니다.</p>
<img src="/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_8.png">
<div class="content-ad"></div>
<p>이 글이 도움이 되셨기를 바랍니다. 새로운 기술을 발견할 때마다 업데이트하겠습니다. 최신 업데이트를 받으시려면 Twitter에서 제 소식을 팔로우해주세요. 전체 코드를 읽고 싶다면 저장소를 확인해주세요.</p>
<p><img src="/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_9.png" alt="마스터링 플러터의 형태와 클리핑"></p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"플러터에서 모양과 클리핑 마스터하기","description":"","date":"2024-06-20 13:42","slug":"2024-06-20-MasteringShapesandClippinginFlutter","content":"\n\n도형과 상자를 다루는 것은 설계된 UI를 구현하는 방법을 알지 못하면 압도될 수 있습니다. 이 기사에서는 매우 기초부터 시작하여 일부 고급 예제로 이동할 것입니다.\n\n## 1. 도형과 상자란 무엇인가요?\n\n도형은 해당 경로에 의해 정의된 어떤 형태를 나타낼 수 있습니다.\n\n상자는 4개의 점으로 구성된 직사각형 모양을 나타냅니다. 테두리 반경과 같은 추가 속성을 가질 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위젯 Flutter의 다양한 컨텍스트에서 상자가 나타날 수 있어요. \n\n예를 들어:\n\n- RenderBox: 비 슬리버 컨텍스트의 위젯의 RenderObject\n- BoxDecoration\n- BoxBorder\n\n또한 ShapeDecoration, ShapeBorder와 같은 클래스들도 있어요.\n\n우리는 Container, DecoratedSlivers 또는 DecoratedBoxes를 스타일링하기 위해 자주 BoxDecoration을 사용해요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```js\nDecoratedBox(\n  decoration: BoxDecoration( // \u003c- this\n    borderRadius: BorderRadius.circular(10),\n    color: Colors.amber,\n  ),\n  child: const SizedBox(height: 200, width: 200),\n)\n```\n\n그냥 이렇게 해서, 결과를 얻습니다:\n\n\u003cimg src=\"/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_0.png\" /\u003e\n\n대안으로 ShapeDecoration을 사용할 수도 있는데, 이것은 색상, 그림자, 그라디언트의 비슷한 사용자 정의를 제공하지만 주요 차이점은 그 모양 매개변수가 BoxShape 대신 ShapeBorder를 사용한다는 것입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nDecoratedBox(\n  decoration: ShapeDecoration( // \u003c- 이 부분\n    color: Colors.amber,\n    shape: BeveledRectangleBorder(borderRadius: BorderRadius.circular(20)),\n  ),\n  child: const SizedBox(height: 200, width: 200),\n)\n```\n\n\u003cimg src=\"/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_1.png\" /\u003e\n\n그럼 ShapeBorder는 정확히 무엇인가요?\n\n구현을 확인하면 좀 더 명확해집니다. OutlinedBorder, StarBorder, BeveledRectangleBorder와 같은 슈퍼클래스들이 있습니다. 이것들은 위젯을 꾸미기 위한 다양한 모양들입니다. 그리고 WidgetStateOutlinedBorder도 있습니다. WidgetStates에 익숙하지 않다면 해당 기사를 읽어보세요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n경계의 본질은 내부 경로와 외부 경로 2개가 있어야 한다는 것을 의미합니다:\n\n![MasteringShapesandClippinginFlutter](/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_2.png)\n\n베지에 곡선에 익숙하지 않다면, 이 대화식 가이드를 확인하는 것을 추천합니다. 플러터의 Path는 선형, 이차, 삼차 및 콘회의 절을 지원합니다.\n\n용어는 여기까지, 이제 재미있는 일을 시작해 봅시다: 사용자 정의 모양을 만들어 보세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 2. 사용자 정의 ShapeBorder 구현\n\n위 작업을 수행하려면 ShapeBorder의 슈퍼 클래스 또는 OutlinedBorder를 만들고 다음 메서드를 구현해야 합니다:\n\n- getInnerPath 및 getOuterPath: 해당 경로를 반환하는 메서드\n- paint: 모양을 그리는 메서드\n- scale, copyWith\n\n원하는 메시지 버블 모양을 만들어보겠습니다. 원구획을 사용하고 두께(w) 매개변수를 변수로 사용하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_3.png)\n\n```js\nclass MessageShapeBorder extends OutlinedBorder {\n  final double borderRadius;\n  final double weight;\n\n  const MessageShapeBorder({\n    super.side, \n    this.borderRadius = 50,\n    this.weight = 2.5,\n  });\n\n  ...\n\n}\n```\n\n그 다음으로, getOuterPath 메서드를 구현합니다. 여기서 경로는 아래 왼쪽 모서리에서 시계 방향으로 이동하는 선 및 물결 모양 세그먼트로 구성됩니다.\n\n```js\n  @override\n  Path getOuterPath(Rect rect, {TextDirection? textDirection}) {\n    final double left = rect.left;\n    final double right = rect.right;\n    final double top = rect.top;\n    final double bottom = rect.bottom;\n\n    final radius = borderRadius;\n    final offset = 10;\n\n    return Path()\n      ..moveTo(left, bottom)\n      ..conicTo(left + offset, bottom - offset, left + offset,\n          bottom - 2 * radius, weight)\n      ..lineTo(left + offset, top + radius)\n      ..conicTo(left + offset, top, left + offset + radius, top, weight)\n      ..lineTo(right - radius, top)\n      ..conicTo(right, top, right, top + radius, weight)\n      ..lineTo(right, bottom - radius)\n      ..conicTo(right, bottom, right - radius, bottom, weight)\n      ..close();\n  }\n```\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더 명확하게 하기 위해, 아래는 각 행이 하는 작업을 시각적으로 보여줍니다:\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*KKbxvf4nJa9IXIUcPdPUxg.gif)\n\n이제 약간 다른 내부 경로를 만들어 봅시다:\n\n```js\n  @override\n  Path getInnerPath(Rect rect, {TextDirection? textDirection}) {\n    final strokeWidth = side.width;\n\n    final double left = rect.left + strokeWidth;\n    final double right = rect.right - strokeWidth;\n    final double top = rect.top + strokeWidth;\n    final double bottom = rect.bottom - strokeWidth;\n\n    final radius = math.max(0, borderRadius - 10);\n    final offset = 10;\n\n    return Path()\n      ..moveTo(left + offset + radius, bottom)\n      ..conicTo(\n          left + offset, bottom, left + offset, bottom - 2 * radius, weight)\n      ..lineTo(left + offset, top + radius)\n      ..conicTo(left + offset, top, left + offset + radius, top, weight)\n      ..lineTo(right - radius, top)\n      ..conicTo(right, top, right, top + radius, weight)\n      ..lineTo(right, bottom - radius)\n      ..conicTo(right, bottom, right - radius, bottom, weight)\n      ..close();\n  }\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n  @override\n  void paint(Canvas canvas, Rect rect, {TextDirection? textDirection}) {\n    canvas.drawPath(getInnerPath(rect), Paint()..color = side.color);\n  }\n```\n\n\u003cimg src=\"/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_4.png\" /\u003e\n\n이제 이 모양을 다음과 같이 DecoratedBox에서 사용할 수 있습니다:\n\n```js\nDecoratedBox(\n  decoration: ShapeDecoration(\n    shape: MessageShapeBorder(\n      borderRadius: 30,\n      fillColor: Color(0xFF7ADEFF)\n    ),\n    color: Color(0xFFd6f5ff),\n  ),\n  child: Padding(\n    padding: EdgeInsets.all(20).copyWith(left: 30),\n    child: Text(\"샘플 메시지 텍스트\"),\n  ),\n)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\u003cimg src=\"/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_5.png\" /\u003e\n\n안녕하세요! 코닉 섹션의 무게를 AnimatedBuilder를 사용하여 애니메이션할 수 있습니다. 만약 플러터의 애니메이션에 익숙하지 않다면, 꼭 공식 안내서를 읽어보시기를 강력히 추천합니다.\n\n```js\nMessageShapeBorder(\n  side: BorderSide(color: Color(0xFF7ADEFF), width: animation.value + 2),\n  weight: animation.value,\n  borderRadius: 30\n)\n```\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1088/1*AqcXygpWbTcwMHVyDkAf6A.gif\" /\u003e\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 3. 사용 중인 클리퍼\n\nFlutter에서는 여러 내장 클리퍼가 있습니다. 예를 들면:\n\n- 직사각형에 사용하는 ClipRect\n- 둥근 직사각형에 사용하는 ClipRRect\n- 원과 타원에 사용하는 ClipOval\n- 사용자 정의 경로에 사용하는 ClipPath\n\n첫 세 개는 사용하기 매우 간단합니다. 클리핑을 원하는 위젯을 해당 클리퍼로 감싸기만 하면 클리핑 효과를 얻을 수 있습니다. 그러나 이러한 클래스들에 대해 더 알고 싶다면 여기 공식 문서 링크를 참조해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nClipPath은 CustomClipper를 인수로 사용합니다. 대부분의 경우에는 ShapeBorder를 ShapeBorderClipper에 전달하면 됩니다. 이는 ShapeBorder의 외부 경로로 자식을 클리핑하는 CustomClipper의 구현입니다:\n\n```js\nClipPath(\n  clipper: const ShapeBorderClipper( // \u003c- 이 부분\n    shape: MessageShapeBorder(),\n  ),\n  child: Image.asset(\n    \"assets/6392956.jpg\",\n    height: 300,\n    width: 300,\n    fit: BoxFit.cover,\n    cacheHeight: (300 * MediaQuery.of(context).devicePixelRatio).toInt(),\n  ),\n);\n```\n\n\u003cimg src=\"/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_6.png\" /\u003e\n\n클리핑이 레이아웃에서 사용될 때마다 새 레이어가 생성되는 점을 주의해야 합니다. 이는 비교적 비용이 많이 드는 작업이므로 가능한 경우 클리핑 대신 데코레이션을 사용하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 4. 사용자 지정 클리퍼\n\n일부 경우에는 클리핑에 대해 더 많은 제어가 필요합니다. 예를 들어, 클리핑이 콘텐츠나 일부 형제 위젯에 따라 달라져야 할 때입니다. 콘텐츠에 따라 달라지는 노치가 있는 티켓 모양 위젯을 만들어 봅시다:\n\n![이미지](/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_7.png)\n\n여기서 어려운 점은 상하 자식 위젯의 크기가 다를 수 있고, 노치가 이에 종속되어야 한다는 것입니다. Flutter에서 위젯의 크기 정보는 RenderObject의 하위 클래스인 RenderBox를 사용하여 얻을 수 있습니다. RenderObjects에 익숙하지 않다면, 공식 문서로 이동하여 확인해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저 레이아웃을 만들고 상단과 하단 자식을 나누는 SizedBox에 GlobalKey를 추가해보겠습니다.\n\n```js\nfinal notchKey = GlobalKey(); // \u003c- 이 부분\n\n...\n\nColumn(\n  children: [\n    widget.topChild,\n    SizedBox(key: notchKey, height: 20), // \u003c- 이 부분\n    widget.bottomChild,\n  ],\n)\n```\n\nGlobalKey를 사용하면 위젯의 BuildContext를 얻을 수 있어요. RenderObject를 얻기 위해 context가 필요한데요. SizedBox의 좌표를 티켓 위젯의 context에서 가져와야 해서 해당 RenderBoxes가 필요해요. 여기에서는 Slivers을 사용하지 않기 때문에 RenderObject를 안전하게 RenderBox로 형변환할 수 있어요.\n\n```js\nClipPath(\n  clipper: _TicketClipper( // \u003c- 우리의 클리퍼\n    notchBox: notchKey.currentContext?.findRenderObject() as RenderBox, // \u003c- 이 부분\n    ancestorBox: context.findRenderObject() as RenderBox, // \u003c- 이 부분\n  ),\n  child: ColoredBox(\n    color: Color(0xFFd6f5ff),\n    child: Column(\n      children: ...\n    ),\n  ),\n)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n그리고 클리퍼 자체는 다음과 같이 보일 것입니다:\n\n```js\nclass _TicketClipper extends CustomClipper\u003cPath\u003e {\n  final RenderBox notchBox;\n  final RenderBox ancestorBox;\n\n  _TicketClipper({required this.notchBox, required this.ancestorBox});\n\n  @override\n  Path getClip(Size size) {\n    final widgetRect = RRect.fromRectAndRadius(\n      Rect.fromPoints(Offset.zero, Offset(size.width, size.height)),\n      const Radius.circular(10),\n    );\n\n    final notch = notchBox.localToGlobal(Offset.zero, ancestor: ancestorBox);\n\n    return Path.combine(\n      PathOperation.difference,\n      Path()..addRRect(widgetRect),\n      Path()\n        ..addOval(Rect.fromCenter(\n            center: Offset(0, notch.dy + 10), width: 20, height: 20))\n        ..addOval(Rect.fromCenter(\n            center: Offset(size.width, notch.dy + 10), width: 20, height: 20)),\n    );\n  }\n\n  @override\n  bool shouldReclip(covariant CustomClipper\u003cPath\u003e oldClipper) {\n    ...\n  }\n}\n```\n\nFlutter는 차이, 교차 등의 경로 작업을 지원합니다. 여기서는 둥근 사각형에서 2개의 원을 빼내어 원하는 모양을 얻어낸 것입니다.\n\n\u003cimg src=\"/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_8.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 글이 도움이 되셨기를 바랍니다. 새로운 기술을 발견할 때마다 업데이트하겠습니다. 최신 업데이트를 받으시려면 Twitter에서 제 소식을 팔로우해주세요. 전체 코드를 읽고 싶다면 저장소를 확인해주세요.\n\n![마스터링 플러터의 형태와 클리핑](/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_9.png)","ogImage":{"url":"/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_0.png"},"coverImage":"/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_0.png","tag":["Tech"],"readingTime":9},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e도형과 상자를 다루는 것은 설계된 UI를 구현하는 방법을 알지 못하면 압도될 수 있습니다. 이 기사에서는 매우 기초부터 시작하여 일부 고급 예제로 이동할 것입니다.\u003c/p\u003e\n\u003ch2\u003e1. 도형과 상자란 무엇인가요?\u003c/h2\u003e\n\u003cp\u003e도형은 해당 경로에 의해 정의된 어떤 형태를 나타낼 수 있습니다.\u003c/p\u003e\n\u003cp\u003e상자는 4개의 점으로 구성된 직사각형 모양을 나타냅니다. 테두리 반경과 같은 추가 속성을 가질 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e위젯 Flutter의 다양한 컨텍스트에서 상자가 나타날 수 있어요.\u003c/p\u003e\n\u003cp\u003e예를 들어:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eRenderBox: 비 슬리버 컨텍스트의 위젯의 RenderObject\u003c/li\u003e\n\u003cli\u003eBoxDecoration\u003c/li\u003e\n\u003cli\u003eBoxBorder\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e또한 ShapeDecoration, ShapeBorder와 같은 클래스들도 있어요.\u003c/p\u003e\n\u003cp\u003e우리는 Container, DecoratedSlivers 또는 DecoratedBoxes를 스타일링하기 위해 자주 BoxDecoration을 사용해요:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eDecoratedBox\u003c/span\u003e(\n  \u003cspan class=\"hljs-attr\"\u003edecoration\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eBoxDecoration\u003c/span\u003e( \u003cspan class=\"hljs-comment\"\u003e// \u0026#x3C;- this\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eborderRadius\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eBorderRadius\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecircular\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e),\n    \u003cspan class=\"hljs-attr\"\u003ecolor\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eColors\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eamber\u003c/span\u003e,\n  ),\n  \u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSizedBox\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eheight\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e),\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그냥 이렇게 해서, 결과를 얻습니다:\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_0.png\"\u003e\n\u003cp\u003e대안으로 ShapeDecoration을 사용할 수도 있는데, 이것은 색상, 그림자, 그라디언트의 비슷한 사용자 정의를 제공하지만 주요 차이점은 그 모양 매개변수가 BoxShape 대신 ShapeBorder를 사용한다는 것입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eDecoratedBox\u003c/span\u003e(\n  \u003cspan class=\"hljs-attr\"\u003edecoration\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eShapeDecoration\u003c/span\u003e( \u003cspan class=\"hljs-comment\"\u003e// \u0026#x3C;- 이 부분\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003ecolor\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eColors\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eamber\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eshape\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eBeveledRectangleBorder\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eborderRadius\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eBorderRadius\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecircular\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e)),\n  ),\n  \u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSizedBox\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eheight\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e),\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_1.png\"\u003e\n\u003cp\u003e그럼 ShapeBorder는 정확히 무엇인가요?\u003c/p\u003e\n\u003cp\u003e구현을 확인하면 좀 더 명확해집니다. OutlinedBorder, StarBorder, BeveledRectangleBorder와 같은 슈퍼클래스들이 있습니다. 이것들은 위젯을 꾸미기 위한 다양한 모양들입니다. 그리고 WidgetStateOutlinedBorder도 있습니다. WidgetStates에 익숙하지 않다면 해당 기사를 읽어보세요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e경계의 본질은 내부 경로와 외부 경로 2개가 있어야 한다는 것을 의미합니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_2.png\" alt=\"MasteringShapesandClippinginFlutter\"\u003e\u003c/p\u003e\n\u003cp\u003e베지에 곡선에 익숙하지 않다면, 이 대화식 가이드를 확인하는 것을 추천합니다. 플러터의 Path는 선형, 이차, 삼차 및 콘회의 절을 지원합니다.\u003c/p\u003e\n\u003cp\u003e용어는 여기까지, 이제 재미있는 일을 시작해 봅시다: 사용자 정의 모양을 만들어 보세요!\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e2. 사용자 정의 ShapeBorder 구현\u003c/h1\u003e\n\u003cp\u003e위 작업을 수행하려면 ShapeBorder의 슈퍼 클래스 또는 OutlinedBorder를 만들고 다음 메서드를 구현해야 합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003egetInnerPath 및 getOuterPath: 해당 경로를 반환하는 메서드\u003c/li\u003e\n\u003cli\u003epaint: 모양을 그리는 메서드\u003c/li\u003e\n\u003cli\u003escale, copyWith\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e원하는 메시지 버블 모양을 만들어보겠습니다. 원구획을 사용하고 두께(w) 매개변수를 변수로 사용하세요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_3.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMessageShapeBorder\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eOutlinedBorder\u003c/span\u003e {\n  final double borderRadius;\n  final double weight;\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMessageShapeBorder\u003c/span\u003e({\n    \u003cspan class=\"hljs-variable language_\"\u003esuper\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eside\u003c/span\u003e, \n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eborderRadius\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e,\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eweight\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e2.5\u003c/span\u003e,\n  });\n\n  ...\n\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그 다음으로, getOuterPath 메서드를 구현합니다. 여기서 경로는 아래 왼쪽 모서리에서 시계 방향으로 이동하는 선 및 물결 모양 세그먼트로 구성됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e  @override\n  \u003cspan class=\"hljs-title class_\"\u003ePath\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetOuterPath\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eRect rect, {TextDirection? textDirection}\u003c/span\u003e) {\n    final double left = rect.\u003cspan class=\"hljs-property\"\u003eleft\u003c/span\u003e;\n    final double right = rect.\u003cspan class=\"hljs-property\"\u003eright\u003c/span\u003e;\n    final double top = rect.\u003cspan class=\"hljs-property\"\u003etop\u003c/span\u003e;\n    final double bottom = rect.\u003cspan class=\"hljs-property\"\u003ebottom\u003c/span\u003e;\n\n    final radius = borderRadius;\n    final offset = \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePath\u003c/span\u003e()\n      ..\u003cspan class=\"hljs-title function_\"\u003emoveTo\u003c/span\u003e(left, bottom)\n      ..\u003cspan class=\"hljs-title function_\"\u003econicTo\u003c/span\u003e(left + offset, bottom - offset, left + offset,\n          bottom - \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e * radius, weight)\n      ..\u003cspan class=\"hljs-title function_\"\u003elineTo\u003c/span\u003e(left + offset, top + radius)\n      ..\u003cspan class=\"hljs-title function_\"\u003econicTo\u003c/span\u003e(left + offset, top, left + offset + radius, top, weight)\n      ..\u003cspan class=\"hljs-title function_\"\u003elineTo\u003c/span\u003e(right - radius, top)\n      ..\u003cspan class=\"hljs-title function_\"\u003econicTo\u003c/span\u003e(right, top, right, top + radius, weight)\n      ..\u003cspan class=\"hljs-title function_\"\u003elineTo\u003c/span\u003e(right, bottom - radius)\n      ..\u003cspan class=\"hljs-title function_\"\u003econicTo\u003c/span\u003e(right, bottom, right - radius, bottom, weight)\n      ..\u003cspan class=\"hljs-title function_\"\u003eclose\u003c/span\u003e();\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e더 명확하게 하기 위해, 아래는 각 행이 하는 작업을 시각적으로 보여줍니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*KKbxvf4nJa9IXIUcPdPUxg.gif\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e이제 약간 다른 내부 경로를 만들어 봅시다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e  @override\n  \u003cspan class=\"hljs-title class_\"\u003ePath\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetInnerPath\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eRect rect, {TextDirection? textDirection}\u003c/span\u003e) {\n    final strokeWidth = side.\u003cspan class=\"hljs-property\"\u003ewidth\u003c/span\u003e;\n\n    final double left = rect.\u003cspan class=\"hljs-property\"\u003eleft\u003c/span\u003e + strokeWidth;\n    final double right = rect.\u003cspan class=\"hljs-property\"\u003eright\u003c/span\u003e - strokeWidth;\n    final double top = rect.\u003cspan class=\"hljs-property\"\u003etop\u003c/span\u003e + strokeWidth;\n    final double bottom = rect.\u003cspan class=\"hljs-property\"\u003ebottom\u003c/span\u003e - strokeWidth;\n\n    final radius = math.\u003cspan class=\"hljs-title function_\"\u003emax\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, borderRadius - \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e);\n    final offset = \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePath\u003c/span\u003e()\n      ..\u003cspan class=\"hljs-title function_\"\u003emoveTo\u003c/span\u003e(left + offset + radius, bottom)\n      ..\u003cspan class=\"hljs-title function_\"\u003econicTo\u003c/span\u003e(\n          left + offset, bottom, left + offset, bottom - \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e * radius, weight)\n      ..\u003cspan class=\"hljs-title function_\"\u003elineTo\u003c/span\u003e(left + offset, top + radius)\n      ..\u003cspan class=\"hljs-title function_\"\u003econicTo\u003c/span\u003e(left + offset, top, left + offset + radius, top, weight)\n      ..\u003cspan class=\"hljs-title function_\"\u003elineTo\u003c/span\u003e(right - radius, top)\n      ..\u003cspan class=\"hljs-title function_\"\u003econicTo\u003c/span\u003e(right, top, right, top + radius, weight)\n      ..\u003cspan class=\"hljs-title function_\"\u003elineTo\u003c/span\u003e(right, bottom - radius)\n      ..\u003cspan class=\"hljs-title function_\"\u003econicTo\u003c/span\u003e(right, bottom, right - radius, bottom, weight)\n      ..\u003cspan class=\"hljs-title function_\"\u003eclose\u003c/span\u003e();\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e  @override\n  \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003epaint\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eCanvas canvas, Rect rect, {TextDirection? textDirection}\u003c/span\u003e) {\n    canvas.\u003cspan class=\"hljs-title function_\"\u003edrawPath\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003egetInnerPath\u003c/span\u003e(rect), \u003cspan class=\"hljs-title class_\"\u003ePaint\u003c/span\u003e()..\u003cspan class=\"hljs-property\"\u003ecolor\u003c/span\u003e = side.\u003cspan class=\"hljs-property\"\u003ecolor\u003c/span\u003e);\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_4.png\"\u003e\n\u003cp\u003e이제 이 모양을 다음과 같이 DecoratedBox에서 사용할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eDecoratedBox\u003c/span\u003e(\n  \u003cspan class=\"hljs-attr\"\u003edecoration\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eShapeDecoration\u003c/span\u003e(\n    \u003cspan class=\"hljs-attr\"\u003eshape\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eMessageShapeBorder\u003c/span\u003e(\n      \u003cspan class=\"hljs-attr\"\u003eborderRadius\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e30\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003efillColor\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eColor\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0xFF7ADEFF\u003c/span\u003e)\n    ),\n    \u003cspan class=\"hljs-attr\"\u003ecolor\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eColor\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0xFFd6f5ff\u003c/span\u003e),\n  ),\n  \u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003ePadding\u003c/span\u003e(\n    \u003cspan class=\"hljs-attr\"\u003epadding\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eEdgeInsets\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eall\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003ecopyWith\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eleft\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e30\u003c/span\u003e),\n    \u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"샘플 메시지 텍스트\"\u003c/span\u003e),\n  ),\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cimg src=\"/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_5.png\"\u003e\n\u003cp\u003e안녕하세요! 코닉 섹션의 무게를 AnimatedBuilder를 사용하여 애니메이션할 수 있습니다. 만약 플러터의 애니메이션에 익숙하지 않다면, 꼭 공식 안내서를 읽어보시기를 강력히 추천합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eMessageShapeBorder\u003c/span\u003e(\n  \u003cspan class=\"hljs-attr\"\u003eside\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eBorderSide\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ecolor\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eColor\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0xFF7ADEFF\u003c/span\u003e), \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e: animation.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e + \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e),\n  \u003cspan class=\"hljs-attr\"\u003eweight\u003c/span\u003e: animation.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eborderRadius\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e30\u003c/span\u003e\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1088/1*AqcXygpWbTcwMHVyDkAf6A.gif\"\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e3. 사용 중인 클리퍼\u003c/h1\u003e\n\u003cp\u003eFlutter에서는 여러 내장 클리퍼가 있습니다. 예를 들면:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e직사각형에 사용하는 ClipRect\u003c/li\u003e\n\u003cli\u003e둥근 직사각형에 사용하는 ClipRRect\u003c/li\u003e\n\u003cli\u003e원과 타원에 사용하는 ClipOval\u003c/li\u003e\n\u003cli\u003e사용자 정의 경로에 사용하는 ClipPath\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e첫 세 개는 사용하기 매우 간단합니다. 클리핑을 원하는 위젯을 해당 클리퍼로 감싸기만 하면 클리핑 효과를 얻을 수 있습니다. 그러나 이러한 클래스들에 대해 더 알고 싶다면 여기 공식 문서 링크를 참조해주세요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eClipPath은 CustomClipper를 인수로 사용합니다. 대부분의 경우에는 ShapeBorder를 ShapeBorderClipper에 전달하면 됩니다. 이는 ShapeBorder의 외부 경로로 자식을 클리핑하는 CustomClipper의 구현입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eClipPath\u003c/span\u003e(\n  \u003cspan class=\"hljs-attr\"\u003eclipper\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eShapeBorderClipper\u003c/span\u003e( \u003cspan class=\"hljs-comment\"\u003e// \u0026#x3C;- 이 부분\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eshape\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eMessageShapeBorder\u003c/span\u003e(),\n  ),\n  \u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003easset\u003c/span\u003e(\n    \u003cspan class=\"hljs-string\"\u003e\"assets/6392956.jpg\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eheight\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e300\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e300\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003efit\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eBoxFit\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecover\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003ecacheHeight\u003c/span\u003e: (\u003cspan class=\"hljs-number\"\u003e300\u003c/span\u003e * \u003cspan class=\"hljs-title class_\"\u003eMediaQuery\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eof\u003c/span\u003e(context).\u003cspan class=\"hljs-property\"\u003edevicePixelRatio\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003etoInt\u003c/span\u003e(),\n  ),\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_6.png\"\u003e\n\u003cp\u003e클리핑이 레이아웃에서 사용될 때마다 새 레이어가 생성되는 점을 주의해야 합니다. 이는 비교적 비용이 많이 드는 작업이므로 가능한 경우 클리핑 대신 데코레이션을 사용하세요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e4. 사용자 지정 클리퍼\u003c/h1\u003e\n\u003cp\u003e일부 경우에는 클리핑에 대해 더 많은 제어가 필요합니다. 예를 들어, 클리핑이 콘텐츠나 일부 형제 위젯에 따라 달라져야 할 때입니다. 콘텐츠에 따라 달라지는 노치가 있는 티켓 모양 위젯을 만들어 봅시다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_7.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e여기서 어려운 점은 상하 자식 위젯의 크기가 다를 수 있고, 노치가 이에 종속되어야 한다는 것입니다. Flutter에서 위젯의 크기 정보는 RenderObject의 하위 클래스인 RenderBox를 사용하여 얻을 수 있습니다. RenderObjects에 익숙하지 않다면, 공식 문서로 이동하여 확인해보세요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e먼저 레이아웃을 만들고 상단과 하단 자식을 나누는 SizedBox에 GlobalKey를 추가해보겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efinal notchKey = \u003cspan class=\"hljs-title class_\"\u003eGlobalKey\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// \u0026#x3C;- 이 부분\u003c/span\u003e\n\n...\n\n\u003cspan class=\"hljs-title class_\"\u003eColumn\u003c/span\u003e(\n  \u003cspan class=\"hljs-attr\"\u003echildren\u003c/span\u003e: [\n    widget.\u003cspan class=\"hljs-property\"\u003etopChild\u003c/span\u003e,\n    \u003cspan class=\"hljs-title class_\"\u003eSizedBox\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e: notchKey, \u003cspan class=\"hljs-attr\"\u003eheight\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e), \u003cspan class=\"hljs-comment\"\u003e// \u0026#x3C;- 이 부분\u003c/span\u003e\n    widget.\u003cspan class=\"hljs-property\"\u003ebottomChild\u003c/span\u003e,\n  ],\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eGlobalKey를 사용하면 위젯의 BuildContext를 얻을 수 있어요. RenderObject를 얻기 위해 context가 필요한데요. SizedBox의 좌표를 티켓 위젯의 context에서 가져와야 해서 해당 RenderBoxes가 필요해요. 여기에서는 Slivers을 사용하지 않기 때문에 RenderObject를 안전하게 RenderBox로 형변환할 수 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eClipPath\u003c/span\u003e(\n  \u003cspan class=\"hljs-attr\"\u003eclipper\u003c/span\u003e: \u003cspan class=\"hljs-title function_\"\u003e_TicketClipper\u003c/span\u003e( \u003cspan class=\"hljs-comment\"\u003e// \u0026#x3C;- 우리의 클리퍼\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003enotchBox\u003c/span\u003e: notchKey.\u003cspan class=\"hljs-property\"\u003ecurrentContext\u003c/span\u003e?.\u003cspan class=\"hljs-title function_\"\u003efindRenderObject\u003c/span\u003e() \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eRenderBox\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// \u0026#x3C;- 이 부분\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eancestorBox\u003c/span\u003e: context.\u003cspan class=\"hljs-title function_\"\u003efindRenderObject\u003c/span\u003e() \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eRenderBox\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// \u0026#x3C;- 이 부분\u003c/span\u003e\n  ),\n  \u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eColoredBox\u003c/span\u003e(\n    \u003cspan class=\"hljs-attr\"\u003ecolor\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eColor\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0xFFd6f5ff\u003c/span\u003e),\n    \u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eColumn\u003c/span\u003e(\n      \u003cspan class=\"hljs-attr\"\u003echildren\u003c/span\u003e: ...\n    ),\n  ),\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e그리고 클리퍼 자체는 다음과 같이 보일 것입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003e_TicketClipper\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eCustomClipper\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003ePath\u003c/span\u003e\u003e {\n  final \u003cspan class=\"hljs-title class_\"\u003eRenderBox\u003c/span\u003e notchBox;\n  final \u003cspan class=\"hljs-title class_\"\u003eRenderBox\u003c/span\u003e ancestorBox;\n\n  \u003cspan class=\"hljs-title function_\"\u003e_TicketClipper\u003c/span\u003e({required \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003enotchBox\u003c/span\u003e, required \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eancestorBox\u003c/span\u003e});\n\n  @override\n  \u003cspan class=\"hljs-title class_\"\u003ePath\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetClip\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eSize size\u003c/span\u003e) {\n    final widgetRect = \u003cspan class=\"hljs-title class_\"\u003eRRect\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efromRectAndRadius\u003c/span\u003e(\n      \u003cspan class=\"hljs-title class_\"\u003eRect\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efromPoints\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eOffset\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ezero\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eOffset\u003c/span\u003e(size.\u003cspan class=\"hljs-property\"\u003ewidth\u003c/span\u003e, size.\u003cspan class=\"hljs-property\"\u003eheight\u003c/span\u003e)),\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eRadius\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecircular\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e),\n    );\n\n    final notch = notchBox.\u003cspan class=\"hljs-title function_\"\u003elocalToGlobal\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eOffset\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ezero\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eancestor\u003c/span\u003e: ancestorBox);\n\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecombine\u003c/span\u003e(\n      \u003cspan class=\"hljs-title class_\"\u003ePathOperation\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edifference\u003c/span\u003e,\n      \u003cspan class=\"hljs-title class_\"\u003ePath\u003c/span\u003e()..\u003cspan class=\"hljs-title function_\"\u003eaddRRect\u003c/span\u003e(widgetRect),\n      \u003cspan class=\"hljs-title class_\"\u003ePath\u003c/span\u003e()\n        ..\u003cspan class=\"hljs-title function_\"\u003eaddOval\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eRect\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efromCenter\u003c/span\u003e(\n            \u003cspan class=\"hljs-attr\"\u003ecenter\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eOffset\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, notch.\u003cspan class=\"hljs-property\"\u003edy\u003c/span\u003e + \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e), \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eheight\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e))\n        ..\u003cspan class=\"hljs-title function_\"\u003eaddOval\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eRect\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efromCenter\u003c/span\u003e(\n            \u003cspan class=\"hljs-attr\"\u003ecenter\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eOffset\u003c/span\u003e(size.\u003cspan class=\"hljs-property\"\u003ewidth\u003c/span\u003e, notch.\u003cspan class=\"hljs-property\"\u003edy\u003c/span\u003e + \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e), \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eheight\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e)),\n    );\n  }\n\n  @override\n  bool \u003cspan class=\"hljs-title function_\"\u003eshouldReclip\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecovariant CustomClipper\u0026#x3C;Path\u003e oldClipper\u003c/span\u003e) {\n    ...\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFlutter는 차이, 교차 등의 경로 작업을 지원합니다. 여기서는 둥근 사각형에서 2개의 원을 빼내어 원하는 모양을 얻어낸 것입니다.\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_8.png\"\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 글이 도움이 되셨기를 바랍니다. 새로운 기술을 발견할 때마다 업데이트하겠습니다. 최신 업데이트를 받으시려면 Twitter에서 제 소식을 팔로우해주세요. 전체 코드를 읽고 싶다면 저장소를 확인해주세요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_9.png\" alt=\"마스터링 플러터의 형태와 클리핑\"\u003e\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-20-MasteringShapesandClippinginFlutter"},"buildId":"5et5eMZxpKCgDAAyIS6Ju","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>