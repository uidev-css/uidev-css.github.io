<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>탭 간 통신 구현하는 방법 | uidev-css</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://uidev-css.github.io///post/2024-06-22-Howtoimplementcross-tabcommunication" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="탭 간 통신 구현하는 방법 | uidev-css" data-gatsby-head="true"/><meta property="og:title" content="탭 간 통신 구현하는 방법 | uidev-css" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-22-Howtoimplementcross-tabcommunication_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://uidev-css.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://uidev-css.github.io///post/2024-06-22-Howtoimplementcross-tabcommunication" data-gatsby-head="true"/><meta name="twitter:title" content="탭 간 통신 구현하는 방법 | uidev-css" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-22-Howtoimplementcross-tabcommunication_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | uidev-css" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-22 05:52" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b75a4bf98ee956a8.js" defer=""></script><script src="/_next/static/ANQ7dDegvQhf-pl2SqBlQ/_buildManifest.js" defer=""></script><script src="/_next/static/ANQ7dDegvQhf-pl2SqBlQ/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UIDEV CSS</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">탭 간 통신 구현하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="탭 간 통신 구현하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">UIDEV CSS</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 22, 2024</span><span class="posts_reading_time__f7YPP">4<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-22-Howtoimplementcross-tabcommunication&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>🌐 제 블로그에서 이 게시물을 읽어보세요</h2>
<p>웹 개발 여정 중 어느 순간, 웹 애플리케이션이 탭 간에 통신해야 하는 경우가 있을 수 있습니다. 아직 그런 적이 없다면, 왜 그럴 필요가 있는지 궁금할 수도 있겠죠.</p>
<h1>🗣️ 그럴 필요가 있는 이유는 무엇일까요?</h1>
<p>좋아요~ 첫 번째 단락을 마무리하게 해 주셔서 감사합니다. 이제 상호 테이블 통신이 유용한 많은 상황들이 있습니다. 몇 가지 살펴보겠습니다.</p>
<ul>
<li>세션 관리 — 웹사이트의 여러 탭을 여는 상황을 상상해봅시다. 한 창에서 로그인하면, 다른 모든 창도 로그인해 있는 것을 기대합니다. 로그아웃도 동일하게 적용됩니다.</li>
<li>공유 상태 — 테마, 로케일화, 또는 실시간 데이터와 같이 애플리케이션에서 탭 간에 상태를 공유해야 할 수 있습니다.</li>
<li>메시지 브로드캐스트 — 한 탭에서 다른 탭으로 메시지를 브로드캐스트하고 싶을 때, 예를 들어 양식을 제출하거나 다른 사용자 작업 등</li>
</ul>
<p>여기까지 보셔서 정말 편리하다는 걸 느끼지 않으셨나요? 이제...어떻게 구현할 수 있는지 궁금하시죠?</p>
<h1>🗣️ 어떻게 구현할 수 있을까요?</h1>
<p>헉, 두 번째로 방해하네요. 괜찮아요... 간단한 예제를 통해 어떻게 구현하는지 몇 가지 일반적인 방법을 선택해볼게요</p>
<ul>
<li>로컬 스토리지</li>
<li>브로드캐스트 채널</li>
<li>공유 워커</li>
</ul>
<p>위 세 가지 방법 모두 동일 출처 정책을 따르며, 즉 우리 애플리케이션이 동일한 출처를 가졌을 때만 작동하는 것을 의미해요</p>
<h2>로컬 스토리지</h2>
<p>가장 간단하고 인기 있는 방법일 수 있어요.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 발신자</span>
sender.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">'channel'</span>, <span class="hljs-string">'some message'</span>);

<span class="hljs-comment">// 수신자</span>
<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'storage'</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =></span> {
  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">key</span> === <span class="hljs-string">'channel'</span>) {
    <span class="hljs-comment">// 메시지는 event.newValue에 들어 있어요</span>
  }
});
</code></pre>
<p>정말 간단하죠! 수신 창에만 저장 이벤트 리스너를 추가하면 돼요. 그럼 로컬스토리지의 데이터가 변경되면 핸들러가 호출돼요.</p>
<h2>브로드캐스트 채널</h2>
<p>Broadcast Channel을 사용한 방법은 매우 간단합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> broadcastChannel = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BroadcastChannel</span>(<span class="hljs-string">'channel'</span>);

<span class="hljs-comment">// 발신자</span>
broadcastChannel.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">'일부 메시지'</span>);

<span class="hljs-comment">// 수신자</span>
broadcastChannel.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =></span> {
  <span class="hljs-comment">// 메시지는 event.data에 있습니다.</span>
};
</code></pre>
<p>먼저, BroadcastChannel의 새 인스턴스를 생성하고 채널 이름을 인수로 전달해야 합니다.</p>
<p>이후에는 저가 언급한 대로 간단합니다. 제가 설명을 하지 않아도 예시 코드가 자체적으로 설명할 수 있습니다. 😆 장난이죠! 우리는 단순히 postMessage를 사용하여 메시지를 보내고, 수신자는 onmessage 이벤트 리스너를 생성하면 됩니다.</p>
<h2>공유 워커</h2>
<p>마지막으로, 세 가지 방법 중에서 가장 복잡한 것이에요. 제가 가능한 한 간단하게 설명해 드릴게요.</p>
<p>아마 이미 알고 있겠지만, 웹 애플리케이션은 하나의 스레드에서 실행된다는 것을 의미합니다. 이는 일부 실행이 UI를 렌더링하는 데 차단할 수 있다는 것을 의미합니다. 웹 워커는 이러한 문제를 해결하는 데 도움이 됩니다!</p>
<p>우리는 공유 워커가 웹 애플리케이션 간의 중계 역할을 한다고 말할 수 있으며, 탭 간의 메시지 전달에 적합하다고 할 수 있어요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> sharedWorker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SharedWorker</span>(<span class="hljs-string">'./worker.js'</span>);

<span class="hljs-comment">// sender</span>
sharedWorker.<span class="hljs-property">port</span>.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">'메시지 전송'</span>);

<span class="hljs-comment">// receiver</span>
sharedWorker.<span class="hljs-property">port</span>.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =></span> {
  <span class="hljs-comment">// 수신된 메시지는 event.data에 있습니다</span>
};
</code></pre>
<p>위의 코드 예제를 보면 Broadcast Channel의 구현과 매우 유사하다는 것을 알 수 있어요. 그러나 worker.js라는 파일 뒤에 비밀스러운 마법이 숨어있어요.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// worker.js</span>
<span class="hljs-keyword">let</span> ports = [];

onconnect = <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) {
  <span class="hljs-keyword">const</span> currentPort = e.<span class="hljs-property">ports</span>[<span class="hljs-number">0</span>];

  ports.<span class="hljs-title function_">push</span>(currentPort);

  currentPort.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) {
    <span class="hljs-keyword">const</span> message = event.<span class="hljs-property">data</span>;

    ports.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">port</span> =></span> {
      <span class="hljs-keyword">if</span> (currentPort !== port) {
        port.<span class="hljs-title function_">postMessage</span>(message);
      }
    });
  };
};
</code></pre>
<p>여기서 마법처럼 동작하는 로직이 수행되어요. onconnect 핸들러는 동일한 출처의 스크립트 중 어떤 것이든 worker.js를 Shared Worker로 로드할 때마다 호출될 거에요.</p>
<p>우리는 각 탭에서 전달된 MessagePort가 담긴 MessagePort 배열을 정의했어. 발신자가 postMessage를 호출할 때마다 Shared Worker가 다른 탭의 다른 MessagePort로 메시지를 브로드캐스트할 거야.</p>
<p>그리고 이렇게 우리가 탭 간 통신을 하는 세 가지 방법을 설명했지. 그런데 어떤 걸 사용해야 할까...</p>
<h1>🗣️ 그럼 어떤 걸 선택해야 할까?</h1>
<p>😑 ← 이게 지금 내 표정... 그건 우리가 구현하는 기능에 따라 다르다는 걸로...</p>
<ul>
<li>상태를 공유하고 싶다면 → Local Storage</li>
<li>메시지를 브로드캐스트하려면 → Broadcast Channel</li>
<li>응용 프로그램이 많은 처리를 필요로 한다면 → Shared Worker</li>
</ul>
<p>그러나 올바른 선택을 결정하기 전에 다른 조건들을 고려해야 합니다.</p>
<h1>데모</h1>
<p>간단한 데모를 만들어서 사용해 볼 수 있습니다.</p>
<p>데모 사이트
소스 코드</p>
<p>여기까지 입니다! 더 많은 블로그를 punn.dev에서 확인해보세요!</p>
<p>다음 포스트에서 만나요! 👋🏼</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"탭 간 통신 구현하는 방법","description":"","date":"2024-06-22 05:52","slug":"2024-06-22-Howtoimplementcross-tabcommunication","content":"\n\n\u003cimg src=\"/assets/img/2024-06-22-Howtoimplementcross-tabcommunication_0.png\" /\u003e\n\n## 🌐 제 블로그에서 이 게시물을 읽어보세요\n\n웹 개발 여정 중 어느 순간, 웹 애플리케이션이 탭 간에 통신해야 하는 경우가 있을 수 있습니다. 아직 그런 적이 없다면, 왜 그럴 필요가 있는지 궁금할 수도 있겠죠.\n\n# 🗣️ 그럴 필요가 있는 이유는 무엇일까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n좋아요~ 첫 번째 단락을 마무리하게 해 주셔서 감사합니다. 이제 상호 테이블 통신이 유용한 많은 상황들이 있습니다. 몇 가지 살펴보겠습니다.\n\n- 세션 관리 — 웹사이트의 여러 탭을 여는 상황을 상상해봅시다. 한 창에서 로그인하면, 다른 모든 창도 로그인해 있는 것을 기대합니다. 로그아웃도 동일하게 적용됩니다.\n- 공유 상태 — 테마, 로케일화, 또는 실시간 데이터와 같이 애플리케이션에서 탭 간에 상태를 공유해야 할 수 있습니다.\n- 메시지 브로드캐스트 — 한 탭에서 다른 탭으로 메시지를 브로드캐스트하고 싶을 때, 예를 들어 양식을 제출하거나 다른 사용자 작업 등\n\n여기까지 보셔서 정말 편리하다는 걸 느끼지 않으셨나요? 이제...어떻게 구현할 수 있는지 궁금하시죠? \n\n# 🗣️ 어떻게 구현할 수 있을까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n헉, 두 번째로 방해하네요. 괜찮아요... 간단한 예제를 통해 어떻게 구현하는지 몇 가지 일반적인 방법을 선택해볼게요\n\n- 로컬 스토리지\n- 브로드캐스트 채널\n- 공유 워커\n\n위 세 가지 방법 모두 동일 출처 정책을 따르며, 즉 우리 애플리케이션이 동일한 출처를 가졌을 때만 작동하는 것을 의미해요\n\n## 로컬 스토리지\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가장 간단하고 인기 있는 방법일 수 있어요.\n\n```js\n// 발신자\nsender.setItem('channel', 'some message');\n\n// 수신자\nwindow.addEventListener('storage', (event) =\u003e {\n  if (event.key === 'channel') {\n    // 메시지는 event.newValue에 들어 있어요\n  }\n});\n```\n\n정말 간단하죠! 수신 창에만 저장 이벤트 리스너를 추가하면 돼요. 그럼 로컬스토리지의 데이터가 변경되면 핸들러가 호출돼요.\n\n## 브로드캐스트 채널\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nBroadcast Channel을 사용한 방법은 매우 간단합니다.\n\n```js\nconst broadcastChannel = new BroadcastChannel('channel');\n\n// 발신자\nbroadcastChannel.postMessage('일부 메시지');\n\n// 수신자\nbroadcastChannel.onmessage = (event) =\u003e {\n  // 메시지는 event.data에 있습니다.\n};\n```\n\n먼저, BroadcastChannel의 새 인스턴스를 생성하고 채널 이름을 인수로 전달해야 합니다.\n\n이후에는 저가 언급한 대로 간단합니다. 제가 설명을 하지 않아도 예시 코드가 자체적으로 설명할 수 있습니다. 😆 장난이죠! 우리는 단순히 postMessage를 사용하여 메시지를 보내고, 수신자는 onmessage 이벤트 리스너를 생성하면 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 공유 워커\n\n마지막으로, 세 가지 방법 중에서 가장 복잡한 것이에요. 제가 가능한 한 간단하게 설명해 드릴게요.\n\n아마 이미 알고 있겠지만, 웹 애플리케이션은 하나의 스레드에서 실행된다는 것을 의미합니다. 이는 일부 실행이 UI를 렌더링하는 데 차단할 수 있다는 것을 의미합니다. 웹 워커는 이러한 문제를 해결하는 데 도움이 됩니다!\n\n우리는 공유 워커가 웹 애플리케이션 간의 중계 역할을 한다고 말할 수 있으며, 탭 간의 메시지 전달에 적합하다고 할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst sharedWorker = new SharedWorker('./worker.js');\n\n// sender\nsharedWorker.port.postMessage('메시지 전송');\n\n// receiver\nsharedWorker.port.onmessage = (event) =\u003e {\n  // 수신된 메시지는 event.data에 있습니다\n};\n```\n\n위의 코드 예제를 보면 Broadcast Channel의 구현과 매우 유사하다는 것을 알 수 있어요. 그러나 worker.js라는 파일 뒤에 비밀스러운 마법이 숨어있어요.\n\n```js\n// worker.js\nlet ports = [];\n\nonconnect = function(e) {\n  const currentPort = e.ports[0];\n\n  ports.push(currentPort);\n\n  currentPort.onmessage = function(event) {\n    const message = event.data;\n\n    ports.forEach(port =\u003e {\n      if (currentPort !== port) {\n        port.postMessage(message);\n      }\n    });\n  };\n};\n```\n\n여기서 마법처럼 동작하는 로직이 수행되어요. onconnect 핸들러는 동일한 출처의 스크립트 중 어떤 것이든 worker.js를 Shared Worker로 로드할 때마다 호출될 거에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 각 탭에서 전달된 MessagePort가 담긴 MessagePort 배열을 정의했어. 발신자가 postMessage를 호출할 때마다 Shared Worker가 다른 탭의 다른 MessagePort로 메시지를 브로드캐스트할 거야.\n\n그리고 이렇게 우리가 탭 간 통신을 하는 세 가지 방법을 설명했지. 그런데 어떤 걸 사용해야 할까...\n\n# 🗣️ 그럼 어떤 걸 선택해야 할까?\n\n😑 ← 이게 지금 내 표정... 그건 우리가 구현하는 기능에 따라 다르다는 걸로...\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 상태를 공유하고 싶다면 → Local Storage\n- 메시지를 브로드캐스트하려면 → Broadcast Channel\n- 응용 프로그램이 많은 처리를 필요로 한다면 → Shared Worker\n\n그러나 올바른 선택을 결정하기 전에 다른 조건들을 고려해야 합니다.\n\n# 데모\n\n간단한 데모를 만들어서 사용해 볼 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n데모 사이트\n소스 코드\n\n여기까지 입니다! 더 많은 블로그를 punn.dev에서 확인해보세요!\n\n다음 포스트에서 만나요! 👋🏼","ogImage":{"url":"/assets/img/2024-06-22-Howtoimplementcross-tabcommunication_0.png"},"coverImage":"/assets/img/2024-06-22-Howtoimplementcross-tabcommunication_0.png","tag":["Tech"],"readingTime":4},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003e🌐 제 블로그에서 이 게시물을 읽어보세요\u003c/h2\u003e\n\u003cp\u003e웹 개발 여정 중 어느 순간, 웹 애플리케이션이 탭 간에 통신해야 하는 경우가 있을 수 있습니다. 아직 그런 적이 없다면, 왜 그럴 필요가 있는지 궁금할 수도 있겠죠.\u003c/p\u003e\n\u003ch1\u003e🗣️ 그럴 필요가 있는 이유는 무엇일까요?\u003c/h1\u003e\n\u003cp\u003e좋아요~ 첫 번째 단락을 마무리하게 해 주셔서 감사합니다. 이제 상호 테이블 통신이 유용한 많은 상황들이 있습니다. 몇 가지 살펴보겠습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e세션 관리 — 웹사이트의 여러 탭을 여는 상황을 상상해봅시다. 한 창에서 로그인하면, 다른 모든 창도 로그인해 있는 것을 기대합니다. 로그아웃도 동일하게 적용됩니다.\u003c/li\u003e\n\u003cli\u003e공유 상태 — 테마, 로케일화, 또는 실시간 데이터와 같이 애플리케이션에서 탭 간에 상태를 공유해야 할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e메시지 브로드캐스트 — 한 탭에서 다른 탭으로 메시지를 브로드캐스트하고 싶을 때, 예를 들어 양식을 제출하거나 다른 사용자 작업 등\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e여기까지 보셔서 정말 편리하다는 걸 느끼지 않으셨나요? 이제...어떻게 구현할 수 있는지 궁금하시죠?\u003c/p\u003e\n\u003ch1\u003e🗣️ 어떻게 구현할 수 있을까요?\u003c/h1\u003e\n\u003cp\u003e헉, 두 번째로 방해하네요. 괜찮아요... 간단한 예제를 통해 어떻게 구현하는지 몇 가지 일반적인 방법을 선택해볼게요\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e로컬 스토리지\u003c/li\u003e\n\u003cli\u003e브로드캐스트 채널\u003c/li\u003e\n\u003cli\u003e공유 워커\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e위 세 가지 방법 모두 동일 출처 정책을 따르며, 즉 우리 애플리케이션이 동일한 출처를 가졌을 때만 작동하는 것을 의미해요\u003c/p\u003e\n\u003ch2\u003e로컬 스토리지\u003c/h2\u003e\n\u003cp\u003e가장 간단하고 인기 있는 방법일 수 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 발신자\u003c/span\u003e\nsender.\u003cspan class=\"hljs-title function_\"\u003esetItem\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'channel'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'some message'\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// 수신자\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eaddEventListener\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'storage'\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eevent\u003c/span\u003e) =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (event.\u003cspan class=\"hljs-property\"\u003ekey\u003c/span\u003e === \u003cspan class=\"hljs-string\"\u003e'channel'\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// 메시지는 event.newValue에 들어 있어요\u003c/span\u003e\n  }\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e정말 간단하죠! 수신 창에만 저장 이벤트 리스너를 추가하면 돼요. 그럼 로컬스토리지의 데이터가 변경되면 핸들러가 호출돼요.\u003c/p\u003e\n\u003ch2\u003e브로드캐스트 채널\u003c/h2\u003e\n\u003cp\u003eBroadcast Channel을 사용한 방법은 매우 간단합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e broadcastChannel = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBroadcastChannel\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'channel'\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// 발신자\u003c/span\u003e\nbroadcastChannel.\u003cspan class=\"hljs-title function_\"\u003epostMessage\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'일부 메시지'\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// 수신자\u003c/span\u003e\nbroadcastChannel.\u003cspan class=\"hljs-property\"\u003eonmessage\u003c/span\u003e = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eevent\u003c/span\u003e) =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e// 메시지는 event.data에 있습니다.\u003c/span\u003e\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e먼저, BroadcastChannel의 새 인스턴스를 생성하고 채널 이름을 인수로 전달해야 합니다.\u003c/p\u003e\n\u003cp\u003e이후에는 저가 언급한 대로 간단합니다. 제가 설명을 하지 않아도 예시 코드가 자체적으로 설명할 수 있습니다. 😆 장난이죠! 우리는 단순히 postMessage를 사용하여 메시지를 보내고, 수신자는 onmessage 이벤트 리스너를 생성하면 됩니다.\u003c/p\u003e\n\u003ch2\u003e공유 워커\u003c/h2\u003e\n\u003cp\u003e마지막으로, 세 가지 방법 중에서 가장 복잡한 것이에요. 제가 가능한 한 간단하게 설명해 드릴게요.\u003c/p\u003e\n\u003cp\u003e아마 이미 알고 있겠지만, 웹 애플리케이션은 하나의 스레드에서 실행된다는 것을 의미합니다. 이는 일부 실행이 UI를 렌더링하는 데 차단할 수 있다는 것을 의미합니다. 웹 워커는 이러한 문제를 해결하는 데 도움이 됩니다!\u003c/p\u003e\n\u003cp\u003e우리는 공유 워커가 웹 애플리케이션 간의 중계 역할을 한다고 말할 수 있으며, 탭 간의 메시지 전달에 적합하다고 할 수 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e sharedWorker = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSharedWorker\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'./worker.js'\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// sender\u003c/span\u003e\nsharedWorker.\u003cspan class=\"hljs-property\"\u003eport\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003epostMessage\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'메시지 전송'\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// receiver\u003c/span\u003e\nsharedWorker.\u003cspan class=\"hljs-property\"\u003eport\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eonmessage\u003c/span\u003e = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eevent\u003c/span\u003e) =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e// 수신된 메시지는 event.data에 있습니다\u003c/span\u003e\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위의 코드 예제를 보면 Broadcast Channel의 구현과 매우 유사하다는 것을 알 수 있어요. 그러나 worker.js라는 파일 뒤에 비밀스러운 마법이 숨어있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// worker.js\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e ports = [];\n\nonconnect = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ee\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e currentPort = e.\u003cspan class=\"hljs-property\"\u003eports\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e];\n\n  ports.\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e(currentPort);\n\n  currentPort.\u003cspan class=\"hljs-property\"\u003eonmessage\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eevent\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e message = event.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e;\n\n    ports.\u003cspan class=\"hljs-title function_\"\u003eforEach\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eport\u003c/span\u003e =\u003e\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (currentPort !== port) {\n        port.\u003cspan class=\"hljs-title function_\"\u003epostMessage\u003c/span\u003e(message);\n      }\n    });\n  };\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 마법처럼 동작하는 로직이 수행되어요. onconnect 핸들러는 동일한 출처의 스크립트 중 어떤 것이든 worker.js를 Shared Worker로 로드할 때마다 호출될 거에요.\u003c/p\u003e\n\u003cp\u003e우리는 각 탭에서 전달된 MessagePort가 담긴 MessagePort 배열을 정의했어. 발신자가 postMessage를 호출할 때마다 Shared Worker가 다른 탭의 다른 MessagePort로 메시지를 브로드캐스트할 거야.\u003c/p\u003e\n\u003cp\u003e그리고 이렇게 우리가 탭 간 통신을 하는 세 가지 방법을 설명했지. 그런데 어떤 걸 사용해야 할까...\u003c/p\u003e\n\u003ch1\u003e🗣️ 그럼 어떤 걸 선택해야 할까?\u003c/h1\u003e\n\u003cp\u003e😑 ← 이게 지금 내 표정... 그건 우리가 구현하는 기능에 따라 다르다는 걸로...\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e상태를 공유하고 싶다면 → Local Storage\u003c/li\u003e\n\u003cli\u003e메시지를 브로드캐스트하려면 → Broadcast Channel\u003c/li\u003e\n\u003cli\u003e응용 프로그램이 많은 처리를 필요로 한다면 → Shared Worker\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e그러나 올바른 선택을 결정하기 전에 다른 조건들을 고려해야 합니다.\u003c/p\u003e\n\u003ch1\u003e데모\u003c/h1\u003e\n\u003cp\u003e간단한 데모를 만들어서 사용해 볼 수 있습니다.\u003c/p\u003e\n\u003cp\u003e데모 사이트\n소스 코드\u003c/p\u003e\n\u003cp\u003e여기까지 입니다! 더 많은 블로그를 punn.dev에서 확인해보세요!\u003c/p\u003e\n\u003cp\u003e다음 포스트에서 만나요! 👋🏼\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-22-Howtoimplementcross-tabcommunication"},"buildId":"ANQ7dDegvQhf-pl2SqBlQ","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>