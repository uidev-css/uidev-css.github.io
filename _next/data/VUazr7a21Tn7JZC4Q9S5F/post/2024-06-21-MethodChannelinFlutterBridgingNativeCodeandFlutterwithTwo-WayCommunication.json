{"pageProps":{"post":{"title":"플러터에서 네이티브 코드와의 양방향 통신을 위한 메소드 채널 사용 방법","description":"","date":"2024-06-21 22:37","slug":"2024-06-21-MethodChannelinFlutterBridgingNativeCodeandFlutterwithTwo-WayCommunication","content":"\n\n플러터의 메소드 채널은 플러터와 플랫폼별 코드 간에 원활한 통신을 제공하는 강력한 메커니즘을 제공합니다. 이 블로그 포스트에서는 플러터에서 메소드 채널을 설정하고 네이티브 MainActivity.kt(Android) 및 AppDelegate.swift(iOS) 코드에서 데이터를 플러터 애플리케이션으로 반환하는 과정을 살펴보겠습니다. 함께 알아보겠습니다!\n\n플러터에서 메소드 채널 설정하기: 먼저, 플러터 프로젝트에 메소드 채널을 설정해 봅시다.\n\n- 의존성 추가: 플러터 프로젝트의 pubspec.yaml 파일에 flutter/services 패키지를 의존성으로 추가하세요:\n\n```js\ndependencies:\n  flutter:\n    sdk: flutter\n  flutter/services:\n    ^2.0.0\n```\n\n<div class=\"content-ad\"></div>\n\n- Method Channel 정의하기: 플러터 Dart 코드에서 Method Channel을 정의하세요:\n\n```js\nimport 'package:flutter/services.dart';\n\n// MethodChannel의 인스턴스 생성\nfinal MethodChannel platformChannel = MethodChannel('your_channel_name');\n```\n\nAndroid에서 Method Channel 통신 구현하기: 이제 Android 플랫폼에서 Method Channel 통신을 구현해 봅시다.\n\n- MainActivity.kt에서 메소드 호출 수신하기: MainActivity.kt 파일에서 onMethodCall 메소드를 오버라이드하여 Flutter로부터의 메소드 호출을 처리하고 데이터를 반환하세요:\n\n<div class=\"content-ad\"></div>\n\n```kotlin\nimport io.flutter.embedding.android.FlutterActivity\nimport io.flutter.embedding.engine.FlutterEngine\nimport io.flutter.plugin.common.MethodChannel\n\nclass MainActivity : FlutterActivity() {\n    private val CHANNEL = \"your_channel_name\"\n\n    override fun configureFlutterEngine(flutterEngine: FlutterEngine) {\n        super.configureFlutterEngine(flutterEngine)\n\n        // Set up the MethodChannel with the same name as defined in Dart\n        MethodChannel(flutterEngine.dartExecutor.binaryMessenger, CHANNEL).setMethodCallHandler { call, result ->\n            if (call.method == \"getDataFromNative\") {\n                // Perform platform-specific operations and obtain the result\n                val data = getDataFromNative()\n\n                // Send the result back to Flutter\n                result.success(data)\n            } else {\n                result.notImplemented()\n            }\n        }\n    }\n\n    private fun getDataFromNative(): String {\n        // Perform platform-specific operations to fetch the data\n        return \"Data from Native\"\n    }\n}\n```\n\niOS에서 Method Channel 통신 구현하기: 이제 iOS 플랫폼에서 메서드 채널 통신을 구현해봅시다.\n\n- AppDelegate.swift에서 메서드 호출 받기: AppDelegate.swift 파일에 아래 코드를 추가하여 Flutter에서의 메서드 호출을 처리하고 데이터를 반환합니다:\n\n```swift\nimport UIKit\nimport Flutter\n\n@UIApplicationMain\n@objc class AppDelegate: FlutterAppDelegate {\n    private let CHANNEL = \"your_channel_name\"\n\n    override func application(\n        _ application: UIApplication,\n        didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?\n    ) -> Bool {\n        // Set up the MethodChannel with the same name as defined in Dart\n        if let flutterViewController = window?.rootViewController as? FlutterViewController {\n            let methodChannel = FlutterMethodChannel(name: CHANNEL, binaryMessenger: flutterViewController.binaryMessenger)\n            methodChannel.setMethodCallHandler { [weak self] (call: FlutterMethodCall, result: FlutterResult) in\n                if call.method == \"getDataFromNative\" {\n                    // Perform platform-specific operations and obtain the result\n                    let data = self?.getDataFromNative()\n\n                    // Send the result back to Flutter\n                    result(data)\n                } else {\n                    result(FlutterMethodNotImplemented)\n                }\n            }\n        }\n\n        return super.application(application, didFinishLaunchingWithOptions: launchOptions)\n    }\n\n    private func getDataFromNative() -> String {\n        // Perform platform-specific operations to fetch the data\n        return \"Data from Native\"\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n플러터에서 네이티브로 데이터 전달 및 결과 반환하기: 이제 플러터에서 네이티브에 데이터를 전달하고 결과를 다시 플러터에서 받는 방법을 살펴봅시다.\n\n- 플러터에서 메소드 호출: 플러터 Dart 코드에서 플랫폼별 코드에서 메소드를 호출하고 결과를 처리하세요.\n\n```js\nvoid fetchDataFromNative() async {\n  try {\n    final String result = await platformChannel.invokeMethod('getDataFromNative');\n    print('Result from Native: $result');\n  } on PlatformException catch (e) {\n    print('Error: ${e.message}');\n  }\n}\n```\n\n결론: 축하합니다! 이제 플러터에서 메서드 채널을 성공적으로 설정했습니다. 이를 통해 플러터와 플랫폼별 코드 간의 양방향 통신이 가능해졌습니다. 이 블로그 포스트에서 안내된 단계와 코드 예제를 따라 하시면, 네이티브 기능을 쉽게 통합하고 네이티브 측에서 플러터 응용 프로그램으로 데이터를 반환할 수 있습니다. 실험하고 탐색하며, 메서드 채널의 강력한 기능을 활용하여 플러터 프로젝트의 무한한 가능성을 발견하세요. 즐거운 코딩되세요!","ogImage":{"url":"/assets/img/2024-06-21-MethodChannelinFlutterBridgingNativeCodeandFlutterwithTwo-WayCommunication_0.png"},"coverImage":"/assets/img/2024-06-21-MethodChannelinFlutterBridgingNativeCodeandFlutterwithTwo-WayCommunication_0.png","tag":["Tech"],"readingTime":5},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>플러터의 메소드 채널은 플러터와 플랫폼별 코드 간에 원활한 통신을 제공하는 강력한 메커니즘을 제공합니다. 이 블로그 포스트에서는 플러터에서 메소드 채널을 설정하고 네이티브 MainActivity.kt(Android) 및 AppDelegate.swift(iOS) 코드에서 데이터를 플러터 애플리케이션으로 반환하는 과정을 살펴보겠습니다. 함께 알아보겠습니다!</p>\n<p>플러터에서 메소드 채널 설정하기: 먼저, 플러터 프로젝트에 메소드 채널을 설정해 봅시다.</p>\n<ul>\n<li>의존성 추가: 플러터 프로젝트의 pubspec.yaml 파일에 flutter/services 패키지를 의존성으로 추가하세요:</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-attr\">dependencies</span>:\n  <span class=\"hljs-attr\">flutter</span>:\n    <span class=\"hljs-attr\">sdk</span>: flutter\n  flutter/<span class=\"hljs-attr\">services</span>:\n    ^<span class=\"hljs-number\">2.0</span><span class=\"hljs-number\">.0</span>\n</code></pre>\n<ul>\n<li>Method Channel 정의하기: 플러터 Dart 코드에서 Method Channel을 정의하세요:</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'package:flutter/services.dart'</span>;\n\n<span class=\"hljs-comment\">// MethodChannel의 인스턴스 생성</span>\nfinal <span class=\"hljs-title class_\">MethodChannel</span> platformChannel = <span class=\"hljs-title class_\">MethodChannel</span>(<span class=\"hljs-string\">'your_channel_name'</span>);\n</code></pre>\n<p>Android에서 Method Channel 통신 구현하기: 이제 Android 플랫폼에서 Method Channel 통신을 구현해 봅시다.</p>\n<ul>\n<li>MainActivity.kt에서 메소드 호출 수신하기: MainActivity.kt 파일에서 onMethodCall 메소드를 오버라이드하여 Flutter로부터의 메소드 호출을 처리하고 데이터를 반환하세요:</li>\n</ul>\n<pre><code class=\"hljs language-kotlin\"><span class=\"hljs-keyword\">import</span> io.flutter.embedding.android.FlutterActivity\n<span class=\"hljs-keyword\">import</span> io.flutter.embedding.engine.FlutterEngine\n<span class=\"hljs-keyword\">import</span> io.flutter.plugin.common.MethodChannel\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MainActivity</span> : <span class=\"hljs-type\">FlutterActivity</span>() {\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">val</span> CHANNEL = <span class=\"hljs-string\">\"your_channel_name\"</span>\n\n    <span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">configureFlutterEngine</span><span class=\"hljs-params\">(flutterEngine: <span class=\"hljs-type\">FlutterEngine</span>)</span></span> {\n        <span class=\"hljs-keyword\">super</span>.configureFlutterEngine(flutterEngine)\n\n        <span class=\"hljs-comment\">// Set up the MethodChannel with the same name as defined in Dart</span>\n        MethodChannel(flutterEngine.dartExecutor.binaryMessenger, CHANNEL).setMethodCallHandler { call, result ->\n            <span class=\"hljs-keyword\">if</span> (call.method == <span class=\"hljs-string\">\"getDataFromNative\"</span>) {\n                <span class=\"hljs-comment\">// Perform platform-specific operations and obtain the result</span>\n                <span class=\"hljs-keyword\">val</span> <span class=\"hljs-keyword\">data</span> = getDataFromNative()\n\n                <span class=\"hljs-comment\">// Send the result back to Flutter</span>\n                result.success(<span class=\"hljs-keyword\">data</span>)\n            } <span class=\"hljs-keyword\">else</span> {\n                result.notImplemented()\n            }\n        }\n    }\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">getDataFromNative</span><span class=\"hljs-params\">()</span></span>: String {\n        <span class=\"hljs-comment\">// Perform platform-specific operations to fetch the data</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"Data from Native\"</span>\n    }\n}\n</code></pre>\n<p>iOS에서 Method Channel 통신 구현하기: 이제 iOS 플랫폼에서 메서드 채널 통신을 구현해봅시다.</p>\n<ul>\n<li>AppDelegate.swift에서 메서드 호출 받기: AppDelegate.swift 파일에 아래 코드를 추가하여 Flutter에서의 메서드 호출을 처리하고 데이터를 반환합니다:</li>\n</ul>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-keyword\">import</span> UIKit\n<span class=\"hljs-keyword\">import</span> Flutter\n\n<span class=\"hljs-keyword\">@UIApplicationMain</span>\n<span class=\"hljs-keyword\">@objc</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AppDelegate</span>: <span class=\"hljs-title class_\">FlutterAppDelegate</span> {\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">let</span> <span class=\"hljs-type\">CHANNEL</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">\"your_channel_name\"</span>\n\n    <span class=\"hljs-keyword\">override</span> <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">application</span>(\n        <span class=\"hljs-keyword\">_</span> <span class=\"hljs-params\">application</span>: <span class=\"hljs-type\">UIApplication</span>,\n        <span class=\"hljs-params\">didFinishLaunchingWithOptions</span> <span class=\"hljs-params\">launchOptions</span>: [<span class=\"hljs-type\">UIApplication</span>.<span class=\"hljs-params\">LaunchOptionsKey</span>: <span class=\"hljs-keyword\">Any</span>]<span class=\"hljs-operator\">?</span>\n    ) -> <span class=\"hljs-type\">Bool</span> {\n        <span class=\"hljs-comment\">// Set up the MethodChannel with the same name as defined in Dart</span>\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> flutterViewController <span class=\"hljs-operator\">=</span> window<span class=\"hljs-operator\">?</span>.rootViewController <span class=\"hljs-keyword\">as?</span> <span class=\"hljs-type\">FlutterViewController</span> {\n            <span class=\"hljs-keyword\">let</span> methodChannel <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">FlutterMethodChannel</span>(name: <span class=\"hljs-type\">CHANNEL</span>, binaryMessenger: flutterViewController.binaryMessenger)\n            methodChannel.setMethodCallHandler { [<span class=\"hljs-keyword\">weak</span> <span class=\"hljs-keyword\">self</span>] (call: <span class=\"hljs-type\">FlutterMethodCall</span>, result: <span class=\"hljs-type\">FlutterResult</span>) <span class=\"hljs-keyword\">in</span>\n                <span class=\"hljs-keyword\">if</span> call.method <span class=\"hljs-operator\">==</span> <span class=\"hljs-string\">\"getDataFromNative\"</span> {\n                    <span class=\"hljs-comment\">// Perform platform-specific operations and obtain the result</span>\n                    <span class=\"hljs-keyword\">let</span> data <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">self</span><span class=\"hljs-operator\">?</span>.getDataFromNative()\n\n                    <span class=\"hljs-comment\">// Send the result back to Flutter</span>\n                    result(data)\n                } <span class=\"hljs-keyword\">else</span> {\n                    result(<span class=\"hljs-type\">FlutterMethodNotImplemented</span>)\n                }\n            }\n        }\n\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">super</span>.application(application, didFinishLaunchingWithOptions: launchOptions)\n    }\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">getDataFromNative</span>() -> <span class=\"hljs-type\">String</span> {\n        <span class=\"hljs-comment\">// Perform platform-specific operations to fetch the data</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"Data from Native\"</span>\n    }\n}\n</code></pre>\n<p>플러터에서 네이티브로 데이터 전달 및 결과 반환하기: 이제 플러터에서 네이티브에 데이터를 전달하고 결과를 다시 플러터에서 받는 방법을 살펴봅시다.</p>\n<ul>\n<li>플러터에서 메소드 호출: 플러터 Dart 코드에서 플랫폼별 코드에서 메소드를 호출하고 결과를 처리하세요.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">fetchDataFromNative</span>() <span class=\"hljs-keyword\">async</span> {\n  <span class=\"hljs-keyword\">try</span> {\n    final <span class=\"hljs-title class_\">String</span> result = <span class=\"hljs-keyword\">await</span> platformChannel.<span class=\"hljs-title function_\">invokeMethod</span>(<span class=\"hljs-string\">'getDataFromNative'</span>);\n    <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">'Result from Native: $result'</span>);\n  } on <span class=\"hljs-title class_\">PlatformException</span> <span class=\"hljs-keyword\">catch</span> (e) {\n    <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">'Error: ${e.message}'</span>);\n  }\n}\n</code></pre>\n<p>결론: 축하합니다! 이제 플러터에서 메서드 채널을 성공적으로 설정했습니다. 이를 통해 플러터와 플랫폼별 코드 간의 양방향 통신이 가능해졌습니다. 이 블로그 포스트에서 안내된 단계와 코드 예제를 따라 하시면, 네이티브 기능을 쉽게 통합하고 네이티브 측에서 플러터 응용 프로그램으로 데이터를 반환할 수 있습니다. 실험하고 탐색하며, 메서드 채널의 강력한 기능을 활용하여 플러터 프로젝트의 무한한 가능성을 발견하세요. 즐거운 코딩되세요!</p>\n</body>\n</html>\n"},"__N_SSG":true}