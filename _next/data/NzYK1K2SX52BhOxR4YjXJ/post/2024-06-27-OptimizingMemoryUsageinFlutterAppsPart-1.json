{"pageProps":{"post":{"title":"Flutter 앱에서 메모리 사용 최적화 방법 파트 1","description":"","date":"2024-06-27 18:29","slug":"2024-06-27-OptimizingMemoryUsageinFlutterAppsPart-1","content":"\n<img src=\"/assets/img/2024-06-27-OptimizingMemoryUsageinFlutterAppsPart-1_0.png\" />\n\n안녕하세요 Medium 독자 여러분, 오늘은 플러터 애플리케이션의 메모리 최적화에 대해 이야기하려고 합니다. 메모리 사용을 최적화하면 부드럽고 반응성 있는 앱을 보장하여 사용자 경험을 향상시킵니다.\n\n# 프로파일링 기술 (Flutter DevTools)\n\nFlutter DevTools의 메모리 탭을 사용하여 플러터 앱이 메모리를 실시간으로 어떻게 사용하는지 분석하세요. 이를 통해 메모리 사용에 대한 자세한 정보를 얻을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n메모리 그래프를 확인하여 메모리 사용 방식을 파악하고 문제가 발생하는 영역을 찾아보세요. 너무 많은 메모리 사용이나 누수를 나타내는 패턴을 찾아보세요. 또한 메모리 사용량이 급증하는 부분을 확인하여 어플리케이션의 어떤 부분이 이러한 현상을 유발하는지 파악해보세요. 빈번한 메모리 사용량 변동이 있다면 메모리가 효율적으로 사용되고 있지 않을 수 있습니다.\n\n# 메모리 최적화 기술\n\n기본적으로 메모리 최적화 기술에는 2가지 방법이 있습니다.\n\n## 풀링 및 객체 재사용으로 할당량 줄이기\n\n<div class=\"content-ad\"></div>\n\n객체 풀링(Object Pooling): 반복적으로 새로운 객체를 만드는 대신에 객체를 재사용합니다. 이는 메모리 사용량을 크게 줄이고 가비지 수집 작업을 줄일 수 있습니다.\n\n기본적인 객체 풀링의 예시를 살펴봅시다.\n\n```js\n// 예시: Worker 객체를 사용한 객체 풀링\n\nclass Worker {\n  int id;\n  Worker(this.id);\n\n  void doWork() {\n    print('Worker $id is doing work');\n  }\n}\n\nclass ObjectPool<T> {\n  final List<T> _available = [];\n  final List<T> _inUse = [];\n  int _counter = 0;\n\n  T getObject() {\n    if (_available.isEmpty) {\n      _available.add(_createObject());\n    }\n    final obj = _available.removeLast();\n    _inUse.add(obj);\n    return obj;\n  }\n\n  void releaseObject(T obj) {\n    _inUse.remove(obj);\n    _available.add(obj);\n  }\n\n  T _createObject() {\n    // 고유 ID를 가진 Worker 객체 생성\n    _counter++;\n    return Worker(_counter) as T;\n  }\n}\n\nvoid main() {\n  final workerPool = ObjectPool<Worker>();\n\n  // 풀에서 Worker를 가져와서 작업을 수행합니다\n  Worker worker1 = workerPool.getObject();\n  worker1.doWork();\n\n  // 다른 Worker를 풀에서 가져와서 작업을 수행합니다\n  Worker worker2 = workerPool.getObject();\n  worker2.doWork();\n\n  // 첫 번째 Worker를 풀에 반환합니다\n  workerPool.releaseObject(worker1);\n\n  // 풀에서 다른 Worker를 가져옵니다 (이전에 반환된 Worker를 재사용해야 합니다)\n  Worker worker3 = workerPool.getObject();\n  worker3.doWork();\n\n  // 나머지 Worker들을 풀에 반환합니다\n  workerPool.releaseObject(worker2);\n  workerPool.releaseObject(worker3);\n}\n```\n\nWorker 클래스에는 Worker가 일을 하는 상황을 알리는 메시지를 간단히 출력하는 doWork 메소드가 있습니다. Object Pool 클래스에서는 Worker 객체의 재사용을 관리하여 메모리 할당과 가비지 수집을 최소화합니다.\n\n<div class=\"content-ad\"></div>\n\n- Object Pool 클래스에는 두 개의 리스트인 \\_available(재사용 가능한 객체)와 \\_inUse(현재 사용 중인 객체)가 포함되어 있습니다.\n- \\_counter는 새로 생성된 Worker 객체에 고유 ID를 할당하는 데 도움을 줍니다.\n- getObject() 메서드는 풀에서 객체를 가져옵니다. 리스트가 비어 있다면 새로운 객체를 생성하고 \\_available에서 가져온 객체를 \\_inUse로 이동합니다.\n\nRelease object는 객체를 \\_inUse에서 가져와 \\_available로 다시 반환합니다.\n\n\\_createObject 메서드는 고유 ID가 있는 새 Worker 객체를 생성하고, 각 Worker가 고유 ID를 받을 수 있도록 \\_counter를 증가시킵니다.\n\n이제 main 함수인 void main()으로 넘어가 봅시다.\n\n<div class=\"content-ad\"></div>\n\n우선 Worker 객체를 위한 ObjectPool을 생성합니다.\n\n```js\nvoid main() {\n  final workerPool = ObjectPool<Worker>();\n```\n\n풀에서 Worker를 가져와 작업을 수행합니다.\n\n```js\n// 풀에서 Worker를 가져와 작업을 수행합니다\nWorker worker1 = workerPool.getObject();\nworker1.doWork();\n```\n\n<div class=\"content-ad\"></div>\n\n위 코드에서 getObject 메서드는 기존 Worker를 재사용하거나 새로운 Worker를 생성한 후에 Worker의 doWork 메서드를 호출합니다.\n\n다음으로 풀에서 또 다른 Worker를 가져와 작업을 수행합니다.\n\n```js\n  // 풀에서 또 다른 Worker를 가져와 작업 수행\n  Worker worker2 = workerPool.getObject();\n  worker2.doWork();\n```\n\n첫 번째 Worker를 풀로 반납하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\n// 첫 번째 워커를 풀에 반환합니다\nworkerPool.releaseObject(worker1);\n```\n\n이제 풀에서 다른 워커를 가져옵니다. 여기서 워커는 다시 사용되어야 합니다 (이 경우 worker1).\n\n```js\n  // 풀에서 다른 워커를 가져옵니다 (반환된 워커를 재사용해야 함)\n  Worker worker3 = workerPool.getObject();\n  worker3.doWork();\n```\n\n나머지 워커들을 풀에 반납합니다\n\n<div class=\"content-ad\"></div>\n\n워커 객체가 모두 풀로 반환되도록 보장합니다.\n\n```js\n// 나머지 워커를 풀로 반환합니다\nworkerPool.releaseObject(worker2);\nworkerPool.releaseObject(worker3);\n}\n```\n\n# 요약 :\n\n- 객체 풀링은 객체를 반복적으로 생성하고 파괴하는 대신 재사용하는 디자인 패턴입니다.\n- 이점: 메모리 할당 오버헤드를 줄이고 가비지 컬렉션을 최소화합니다.\n\n<div class=\"content-ad\"></div>\n\n# 결론:\n\n이번에는 Dart에서 객체 풀링에 대해 논의했습니다. 이는 빈번한 생성과 소멸 대신 객체를 재사용하는 데 도움이 됩니다. 이 기사의 다음 부분에서 메모리를 더 최적화하는 방법을 더 알아볼 수 있습니다. Dart 패드에서 코드를 자유롭게 테스트해보세요.\n\n이 기사를 즐겁게 읽으셨길 바랍니다!\n\n만약 이 기사가 도움이 되었다면 👏를 눌러주세요.\n\n<div class=\"content-ad\"></div>\n\n안녕히 가세요!\n","ogImage":{"url":"/assets/img/2024-06-27-OptimizingMemoryUsageinFlutterAppsPart-1_0.png"},"coverImage":"/assets/img/2024-06-27-OptimizingMemoryUsageinFlutterAppsPart-1_0.png","tag":["Tech"],"readingTime":4},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<img src=\"/assets/img/2024-06-27-OptimizingMemoryUsageinFlutterAppsPart-1_0.png\">\n<p>안녕하세요 Medium 독자 여러분, 오늘은 플러터 애플리케이션의 메모리 최적화에 대해 이야기하려고 합니다. 메모리 사용을 최적화하면 부드럽고 반응성 있는 앱을 보장하여 사용자 경험을 향상시킵니다.</p>\n<h1>프로파일링 기술 (Flutter DevTools)</h1>\n<p>Flutter DevTools의 메모리 탭을 사용하여 플러터 앱이 메모리를 실시간으로 어떻게 사용하는지 분석하세요. 이를 통해 메모리 사용에 대한 자세한 정보를 얻을 수 있습니다.</p>\n<div class=\"content-ad\"></div>\n<p>메모리 그래프를 확인하여 메모리 사용 방식을 파악하고 문제가 발생하는 영역을 찾아보세요. 너무 많은 메모리 사용이나 누수를 나타내는 패턴을 찾아보세요. 또한 메모리 사용량이 급증하는 부분을 확인하여 어플리케이션의 어떤 부분이 이러한 현상을 유발하는지 파악해보세요. 빈번한 메모리 사용량 변동이 있다면 메모리가 효율적으로 사용되고 있지 않을 수 있습니다.</p>\n<h1>메모리 최적화 기술</h1>\n<p>기본적으로 메모리 최적화 기술에는 2가지 방법이 있습니다.</p>\n<h2>풀링 및 객체 재사용으로 할당량 줄이기</h2>\n<div class=\"content-ad\"></div>\n<p>객체 풀링(Object Pooling): 반복적으로 새로운 객체를 만드는 대신에 객체를 재사용합니다. 이는 메모리 사용량을 크게 줄이고 가비지 수집 작업을 줄일 수 있습니다.</p>\n<p>기본적인 객체 풀링의 예시를 살펴봅시다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 예시: Worker 객체를 사용한 객체 풀링</span>\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Worker</span> {\n  int id;\n  <span class=\"hljs-title class_\">Worker</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">id</span>);\n\n  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">doWork</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">'Worker $id is doing work'</span>);\n  }\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ObjectPool</span>&#x3C;T> {\n  final <span class=\"hljs-title class_\">List</span>&#x3C;T> _available = [];\n  final <span class=\"hljs-title class_\">List</span>&#x3C;T> _inUse = [];\n  int _counter = <span class=\"hljs-number\">0</span>;\n\n  T <span class=\"hljs-title function_\">getObject</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">if</span> (_available.<span class=\"hljs-property\">isEmpty</span>) {\n      _available.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-title function_\">_createObject</span>());\n    }\n    final obj = _available.<span class=\"hljs-title function_\">removeLast</span>();\n    _inUse.<span class=\"hljs-title function_\">add</span>(obj);\n    <span class=\"hljs-keyword\">return</span> obj;\n  }\n\n  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">releaseObject</span>(<span class=\"hljs-params\">T obj</span>) {\n    _inUse.<span class=\"hljs-title function_\">remove</span>(obj);\n    _available.<span class=\"hljs-title function_\">add</span>(obj);\n  }\n\n  T <span class=\"hljs-title function_\">_createObject</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-comment\">// 고유 ID를 가진 Worker 객체 생성</span>\n    _counter++;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Worker</span>(_counter) <span class=\"hljs-keyword\">as</span> T;\n  }\n}\n\n<span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"></span>) {\n  final workerPool = <span class=\"hljs-title class_\">ObjectPool</span>&#x3C;<span class=\"hljs-title class_\">Worker</span>>();\n\n  <span class=\"hljs-comment\">// 풀에서 Worker를 가져와서 작업을 수행합니다</span>\n  <span class=\"hljs-title class_\">Worker</span> worker1 = workerPool.<span class=\"hljs-title function_\">getObject</span>();\n  worker1.<span class=\"hljs-title function_\">doWork</span>();\n\n  <span class=\"hljs-comment\">// 다른 Worker를 풀에서 가져와서 작업을 수행합니다</span>\n  <span class=\"hljs-title class_\">Worker</span> worker2 = workerPool.<span class=\"hljs-title function_\">getObject</span>();\n  worker2.<span class=\"hljs-title function_\">doWork</span>();\n\n  <span class=\"hljs-comment\">// 첫 번째 Worker를 풀에 반환합니다</span>\n  workerPool.<span class=\"hljs-title function_\">releaseObject</span>(worker1);\n\n  <span class=\"hljs-comment\">// 풀에서 다른 Worker를 가져옵니다 (이전에 반환된 Worker를 재사용해야 합니다)</span>\n  <span class=\"hljs-title class_\">Worker</span> worker3 = workerPool.<span class=\"hljs-title function_\">getObject</span>();\n  worker3.<span class=\"hljs-title function_\">doWork</span>();\n\n  <span class=\"hljs-comment\">// 나머지 Worker들을 풀에 반환합니다</span>\n  workerPool.<span class=\"hljs-title function_\">releaseObject</span>(worker2);\n  workerPool.<span class=\"hljs-title function_\">releaseObject</span>(worker3);\n}\n</code></pre>\n<p>Worker 클래스에는 Worker가 일을 하는 상황을 알리는 메시지를 간단히 출력하는 doWork 메소드가 있습니다. Object Pool 클래스에서는 Worker 객체의 재사용을 관리하여 메모리 할당과 가비지 수집을 최소화합니다.</p>\n<div class=\"content-ad\"></div>\n<ul>\n<li>Object Pool 클래스에는 두 개의 리스트인 _available(재사용 가능한 객체)와 _inUse(현재 사용 중인 객체)가 포함되어 있습니다.</li>\n<li>_counter는 새로 생성된 Worker 객체에 고유 ID를 할당하는 데 도움을 줍니다.</li>\n<li>getObject() 메서드는 풀에서 객체를 가져옵니다. 리스트가 비어 있다면 새로운 객체를 생성하고 _available에서 가져온 객체를 _inUse로 이동합니다.</li>\n</ul>\n<p>Release object는 객체를 _inUse에서 가져와 _available로 다시 반환합니다.</p>\n<p>_createObject 메서드는 고유 ID가 있는 새 Worker 객체를 생성하고, 각 Worker가 고유 ID를 받을 수 있도록 _counter를 증가시킵니다.</p>\n<p>이제 main 함수인 void main()으로 넘어가 봅시다.</p>\n<div class=\"content-ad\"></div>\n<p>우선 Worker 객체를 위한 ObjectPool을 생성합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"></span>) {\n  final workerPool = <span class=\"hljs-title class_\">ObjectPool</span>&#x3C;<span class=\"hljs-title class_\">Worker</span>>();\n</code></pre>\n<p>풀에서 Worker를 가져와 작업을 수행합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 풀에서 Worker를 가져와 작업을 수행합니다</span>\n<span class=\"hljs-title class_\">Worker</span> worker1 = workerPool.<span class=\"hljs-title function_\">getObject</span>();\nworker1.<span class=\"hljs-title function_\">doWork</span>();\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>위 코드에서 getObject 메서드는 기존 Worker를 재사용하거나 새로운 Worker를 생성한 후에 Worker의 doWork 메서드를 호출합니다.</p>\n<p>다음으로 풀에서 또 다른 Worker를 가져와 작업을 수행합니다.</p>\n<pre><code class=\"hljs language-js\">  <span class=\"hljs-comment\">// 풀에서 또 다른 Worker를 가져와 작업 수행</span>\n  <span class=\"hljs-title class_\">Worker</span> worker2 = workerPool.<span class=\"hljs-title function_\">getObject</span>();\n  worker2.<span class=\"hljs-title function_\">doWork</span>();\n</code></pre>\n<p>첫 번째 Worker를 풀로 반납하세요.</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 첫 번째 워커를 풀에 반환합니다</span>\nworkerPool.<span class=\"hljs-title function_\">releaseObject</span>(worker1);\n</code></pre>\n<p>이제 풀에서 다른 워커를 가져옵니다. 여기서 워커는 다시 사용되어야 합니다 (이 경우 worker1).</p>\n<pre><code class=\"hljs language-js\">  <span class=\"hljs-comment\">// 풀에서 다른 워커를 가져옵니다 (반환된 워커를 재사용해야 함)</span>\n  <span class=\"hljs-title class_\">Worker</span> worker3 = workerPool.<span class=\"hljs-title function_\">getObject</span>();\n  worker3.<span class=\"hljs-title function_\">doWork</span>();\n</code></pre>\n<p>나머지 워커들을 풀에 반납합니다</p>\n<div class=\"content-ad\"></div>\n<p>워커 객체가 모두 풀로 반환되도록 보장합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 나머지 워커를 풀로 반환합니다</span>\nworkerPool.<span class=\"hljs-title function_\">releaseObject</span>(worker2);\nworkerPool.<span class=\"hljs-title function_\">releaseObject</span>(worker3);\n}\n</code></pre>\n<h1>요약 :</h1>\n<ul>\n<li>객체 풀링은 객체를 반복적으로 생성하고 파괴하는 대신 재사용하는 디자인 패턴입니다.</li>\n<li>이점: 메모리 할당 오버헤드를 줄이고 가비지 컬렉션을 최소화합니다.</li>\n</ul>\n<div class=\"content-ad\"></div>\n<h1>결론:</h1>\n<p>이번에는 Dart에서 객체 풀링에 대해 논의했습니다. 이는 빈번한 생성과 소멸 대신 객체를 재사용하는 데 도움이 됩니다. 이 기사의 다음 부분에서 메모리를 더 최적화하는 방법을 더 알아볼 수 있습니다. Dart 패드에서 코드를 자유롭게 테스트해보세요.</p>\n<p>이 기사를 즐겁게 읽으셨길 바랍니다!</p>\n<p>만약 이 기사가 도움이 되었다면 👏를 눌러주세요.</p>\n<div class=\"content-ad\"></div>\n<p>안녕히 가세요!</p>\n</body>\n</html>\n"},"__N_SSG":true}