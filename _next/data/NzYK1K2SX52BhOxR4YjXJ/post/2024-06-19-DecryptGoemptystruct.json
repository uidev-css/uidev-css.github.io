{"pageProps":{"post":{"title":"복호화 Go 빈 구조체","description":"","date":"2024-06-19 08:25","slug":"2024-06-19-DecryptGoemptystruct","content":"\n\n<img src=\"/assets/img/2024-06-19-DecryptGoemptystruct_0.png\" />\n\n# 고(Go)에서 빈 구조체의 수수께끼: 사용법과 최적화를 이해해보세요\n\n일반적으로 구조체는 메모리 블록을 차지합니다. 그러나 특별한 경우가 있습니다: 만약 빈 구조체라면, 크기는 제로입니다. 이것이 어떻게 가능한 것이고, 빈 구조체의 사용은 무엇일까요?\n\n```js\ntype Test struct {\n     A int\n     B string\n }\n \n func main() {\n     fmt.Println(unsafe.Sizeof(Test{}))\n     fmt.Println(unsafe.Sizeof(struct{}{}))\n }\n \n /*\n 24\n 0\n */\n```\n\n<div class=\"content-ad\"></div>\n\n# 빈 구조체의 비밀\n\n## 특별한 변수: zerobase\n\n빈 구조체는 메모리 크기가 없는 구조체입니다. 이 문장은 맞지만, 더 정확하게 말하면 특별한 시작점이 있습니다: zerobase 변수입니다. 이는 8바이트를 차지하는 uintptr 전역 변수입니다. 무수히 많은 구조체 '' 변수가 정의될 때, 컴파일러는 이 zerobase 변수의 주소를 할당합니다. 다시 말해, Go에서 크기가 0인 모든 메모리 할당은 동일한 주소 &zerobase 를 사용합니다.\n\n예제\n\n<div class=\"content-ad\"></div>\n\n```go\npackage main\n\nimport \"fmt\"\n\ntype emptyStruct struct{}\n\nfunc main() {\n    a := struct{}{}\n    b := struct{}{}\n    c := emptyStruct{}\n\n    fmt.Printf(\"%p\\n\", &a)\n    fmt.Printf(\"%p\\n\", &b)\n    fmt.Printf(\"%p\\n\", &c)\n}\n\n// 0x58e360\n// 0x58e360\n// 0x58e360\n```\n\n빈 구조체 변수의 메모리 주소는 모두 동일합니다. 이는 컴파일 시에 특수한 형식의 메모리 할당을 만나면 컴파일러가 &zerobase를 할당하기 때문입니다. 이 로직은 mallocgc 함수에 있습니다.\n\n```go\n//go:linkname mallocgc\nfunc mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n    ...\n    if size == 0 {\n        return unsafe.Pointer(&zerobase)\n    }\n    ...\n```\n\n이것이 빈 구조체의 비밀입니다. 이 특수한 변수로 많은 기능을 수행할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 빈 구조체와 메모리 정렬\n\n일반적으로 빈 구조체가 더 큰 구조체의 일부인 경우 메모리를 차지하지 않습니다. 그러나 빈 구조체가 마지막 필드인 경우에는 메모리 정렬이 트리거됩니다.\n\n예시\n\n```js\ntype A struct {\n    x int\n    y string\n    z struct{}\n}\ntype B struct {\n    x int\n    z struct{}\n    y string\n}\n\nfunc main() {\n    println(unsafe.Alignof(A{}))\n    println(unsafe.Alignof(B{}))\n    println(unsafe.Sizeof(A{}))\n    println(unsafe.Sizeof(B{}))\n}\n```\n\n결과:\n\n```plaintext\n8\n8\n32\n24\n```\n\n<div class=\"content-ad\"></div>\n\n포인터가 필드를 가리키는 경우, 반환된 주소는 구조체 외부에 있을 수 있으며, 구조체가 해제될 때 해당 메모리가 해제되지 않으면 메모리 누수로 이어질 수 있습니다. 따라서 다른 구조체의 마지막 필드로 빈 구조체가 사용될 때는 안전을 위해 추가적인 메모리가 할당됩니다. 빈 구조체가 시작이나 중간에 위치할 경우, 그 주소는 다음 변수와 동일합니다.\n\n```js\ntype A struct {  \n    x int  \n    y string  \n    z struct{}  \n}  \ntype B struct {  \n    x int  \n    z struct{}  \n    y string  \n}  \n\nfunc main() {  \n    a := A{}  \n    b := B{}  \n    fmt.Printf(\"%p\\n\", &a.y)  \n    fmt.Printf(\"%p\\n\", &a.z)  \n    fmt.Printf(\"%p\\n\", &b.y)  \n    fmt.Printf(\"%p\\n\", &b.z)  \n}\n\n/**\n0x1400012c008\n0x1400012c018\n0x1400012e008\n0x1400012e008\n**/\n```\n\n# 빈 구조체의 사용 사례\n\n빈 구조체(struct{})의 존재 이유는 메모리를 절약하는 데 있습니다. 내용에 관심이 없지만 구조체가 필요할 때 빈 구조체를 사용하는 것을 고려해보세요. Go의 핵심 복합 구조체인 map, chan 및 slice 모두 빈 구조체를 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 맵과 구조체\n\n```go\n// 맵 생성\nm := make(map[int]struct{})\n// 값 할당\nm[1] = struct{}{}\n// 키 존재 여부 확인\n_, ok := m[1]\n```\n\n## 채널과 구조체\n\n채널과 구조체를 결합하는 클래식한 시나리오에서는 구조체를 신호로 사용하고 내용에 대해 신경 쓰지 않습니다. 이전 글에서 분석한 대로 채널의 필수 데이터 구조는 관리 구조체와 링 버퍼가 함께합니다. 구조체를 요소로 사용하는 경우 링 버퍼는 제로 할당됩니다.\n\n<div class=\"content-ad\"></div>\n\nchan과 struct를 함께 사용하는 유일한 목적은 빈 구조체 자체가 어떤 값을 전달할 수 없기 때문에 신호 전달에 사용된다는 것입니다. 일반적으로 버퍼가 없는 채널과 함께 사용됩니다.\n\n```js\n// 신호 채널 생성\nwaitc := make(chan struct{})\n \n// ...\ngoroutine 1:\n    // 신호 전송: 요소 추가\n    waitc <- struct{}{}\n    // 신호 전송: 종료\n    close(waitc)\n \ngoroutine 2:\n    select {\n    // 신호 수신 및 해당 작업 수행\n    case <-waitc:\n    }\n```\n\n이 시나리오에서 struct가 꼭 필요할까요? 정말 필요하지는 않으며, 절약되는 메모리는 미미합니다. 핵심은 chan의 요소 값이 중요하지 않다는 것이며, 따라서 struct가 사용됩니다.\n\n# 요약\n\n<div class=\"content-ad\"></div>\n\n- 빈 구조체는 여전히 크기가 0인 구조체입니다.\n- 모든 빈 구조체는 동일한 주소를 공유합니다: zerobase 주소입니다.\n- 빈 구조체의 메모리를 차지하지 않는 기능을 활용하여 맵을 사용하여 집합 및 채널을 구현하는 등 코드를 최적화할 수 있습니다.\n\n# 참고 자료\n\n- 빈 구조체, Dave Cheney\n- Go 최종 릴리스 - struct'' 빈 구조체가 정확히 무엇인가요?","ogImage":{"url":"/assets/img/2024-06-19-DecryptGoemptystruct_0.png"},"coverImage":"/assets/img/2024-06-19-DecryptGoemptystruct_0.png","tag":["Tech"],"readingTime":4},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<img src=\"/assets/img/2024-06-19-DecryptGoemptystruct_0.png\">\n<h1>고(Go)에서 빈 구조체의 수수께끼: 사용법과 최적화를 이해해보세요</h1>\n<p>일반적으로 구조체는 메모리 블록을 차지합니다. 그러나 특별한 경우가 있습니다: 만약 빈 구조체라면, 크기는 제로입니다. 이것이 어떻게 가능한 것이고, 빈 구조체의 사용은 무엇일까요?</p>\n<pre><code class=\"hljs language-js\">type <span class=\"hljs-title class_\">Test</span> struct {\n     A int\n     B string\n }\n \n func <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"></span>) {\n     fmt.<span class=\"hljs-title class_\">Println</span>(unsafe.<span class=\"hljs-title class_\">Sizeof</span>(<span class=\"hljs-title class_\">Test</span>{}))\n     fmt.<span class=\"hljs-title class_\">Println</span>(unsafe.<span class=\"hljs-title class_\">Sizeof</span>(struct{}{}))\n }\n \n <span class=\"hljs-comment\">/*\n 24\n 0\n */</span>\n</code></pre>\n<div class=\"content-ad\"></div>\n<h1>빈 구조체의 비밀</h1>\n<h2>특별한 변수: zerobase</h2>\n<p>빈 구조체는 메모리 크기가 없는 구조체입니다. 이 문장은 맞지만, 더 정확하게 말하면 특별한 시작점이 있습니다: zerobase 변수입니다. 이는 8바이트를 차지하는 uintptr 전역 변수입니다. 무수히 많은 구조체 '' 변수가 정의될 때, 컴파일러는 이 zerobase 변수의 주소를 할당합니다. 다시 말해, Go에서 크기가 0인 모든 메모리 할당은 동일한 주소 &#x26;zerobase 를 사용합니다.</p>\n<p>예제</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">package</span> main\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">\"fmt\"</span>\n\n<span class=\"hljs-keyword\">type</span> emptyStruct <span class=\"hljs-keyword\">struct</span>{}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n    a := <span class=\"hljs-keyword\">struct</span>{}{}\n    b := <span class=\"hljs-keyword\">struct</span>{}{}\n    c := emptyStruct{}\n\n    fmt.Printf(<span class=\"hljs-string\">\"%p\\n\"</span>, &#x26;a)\n    fmt.Printf(<span class=\"hljs-string\">\"%p\\n\"</span>, &#x26;b)\n    fmt.Printf(<span class=\"hljs-string\">\"%p\\n\"</span>, &#x26;c)\n}\n\n<span class=\"hljs-comment\">// 0x58e360</span>\n<span class=\"hljs-comment\">// 0x58e360</span>\n<span class=\"hljs-comment\">// 0x58e360</span>\n</code></pre>\n<p>빈 구조체 변수의 메모리 주소는 모두 동일합니다. 이는 컴파일 시에 특수한 형식의 메모리 할당을 만나면 컴파일러가 &#x26;zerobase를 할당하기 때문입니다. 이 로직은 mallocgc 함수에 있습니다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-comment\">//go:linkname mallocgc</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">mallocgc</span><span class=\"hljs-params\">(size <span class=\"hljs-type\">uintptr</span>, typ *_type, needzero <span class=\"hljs-type\">bool</span>)</span></span> unsafe.Pointer {\n    ...\n    <span class=\"hljs-keyword\">if</span> size == <span class=\"hljs-number\">0</span> {\n        <span class=\"hljs-keyword\">return</span> unsafe.Pointer(&#x26;zerobase)\n    }\n    ...\n</code></pre>\n<p>이것이 빈 구조체의 비밀입니다. 이 특수한 변수로 많은 기능을 수행할 수 있습니다.</p>\n<div class=\"content-ad\"></div>\n<h1>빈 구조체와 메모리 정렬</h1>\n<p>일반적으로 빈 구조체가 더 큰 구조체의 일부인 경우 메모리를 차지하지 않습니다. 그러나 빈 구조체가 마지막 필드인 경우에는 메모리 정렬이 트리거됩니다.</p>\n<p>예시</p>\n<pre><code class=\"hljs language-js\">type A struct {\n    x int\n    y string\n    z struct{}\n}\ntype B struct {\n    x int\n    z struct{}\n    y string\n}\n\nfunc <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-title function_\">println</span>(unsafe.<span class=\"hljs-title class_\">Alignof</span>(A{}))\n    <span class=\"hljs-title function_\">println</span>(unsafe.<span class=\"hljs-title class_\">Alignof</span>(B{}))\n    <span class=\"hljs-title function_\">println</span>(unsafe.<span class=\"hljs-title class_\">Sizeof</span>(A{}))\n    <span class=\"hljs-title function_\">println</span>(unsafe.<span class=\"hljs-title class_\">Sizeof</span>(B{}))\n}\n</code></pre>\n<p>결과:</p>\n<pre><code class=\"hljs language-plaintext\">8\n8\n32\n24\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>포인터가 필드를 가리키는 경우, 반환된 주소는 구조체 외부에 있을 수 있으며, 구조체가 해제될 때 해당 메모리가 해제되지 않으면 메모리 누수로 이어질 수 있습니다. 따라서 다른 구조체의 마지막 필드로 빈 구조체가 사용될 때는 안전을 위해 추가적인 메모리가 할당됩니다. 빈 구조체가 시작이나 중간에 위치할 경우, 그 주소는 다음 변수와 동일합니다.</p>\n<pre><code class=\"hljs language-js\">type A struct {  \n    x int  \n    y string  \n    z struct{}  \n}  \ntype B struct {  \n    x int  \n    z struct{}  \n    y string  \n}  \n\nfunc <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"></span>) {  \n    a := A{}  \n    b := B{}  \n    fmt.<span class=\"hljs-title class_\">Printf</span>(<span class=\"hljs-string\">\"%p\\n\"</span>, &#x26;a.<span class=\"hljs-property\">y</span>)  \n    fmt.<span class=\"hljs-title class_\">Printf</span>(<span class=\"hljs-string\">\"%p\\n\"</span>, &#x26;a.<span class=\"hljs-property\">z</span>)  \n    fmt.<span class=\"hljs-title class_\">Printf</span>(<span class=\"hljs-string\">\"%p\\n\"</span>, &#x26;b.<span class=\"hljs-property\">y</span>)  \n    fmt.<span class=\"hljs-title class_\">Printf</span>(<span class=\"hljs-string\">\"%p\\n\"</span>, &#x26;b.<span class=\"hljs-property\">z</span>)  \n}\n\n<span class=\"hljs-comment\">/**\n0x1400012c008\n0x1400012c018\n0x1400012e008\n0x1400012e008\n**/</span>\n</code></pre>\n<h1>빈 구조체의 사용 사례</h1>\n<p>빈 구조체(struct{})의 존재 이유는 메모리를 절약하는 데 있습니다. 내용에 관심이 없지만 구조체가 필요할 때 빈 구조체를 사용하는 것을 고려해보세요. Go의 핵심 복합 구조체인 map, chan 및 slice 모두 빈 구조체를 사용할 수 있습니다.</p>\n<div class=\"content-ad\"></div>\n<h2>맵과 구조체</h2>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-comment\">// 맵 생성</span>\nm := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>]<span class=\"hljs-keyword\">struct</span>{})\n<span class=\"hljs-comment\">// 값 할당</span>\nm[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-keyword\">struct</span>{}{}\n<span class=\"hljs-comment\">// 키 존재 여부 확인</span>\n_, ok := m[<span class=\"hljs-number\">1</span>]\n</code></pre>\n<h2>채널과 구조체</h2>\n<p>채널과 구조체를 결합하는 클래식한 시나리오에서는 구조체를 신호로 사용하고 내용에 대해 신경 쓰지 않습니다. 이전 글에서 분석한 대로 채널의 필수 데이터 구조는 관리 구조체와 링 버퍼가 함께합니다. 구조체를 요소로 사용하는 경우 링 버퍼는 제로 할당됩니다.</p>\n<div class=\"content-ad\"></div>\n<p>chan과 struct를 함께 사용하는 유일한 목적은 빈 구조체 자체가 어떤 값을 전달할 수 없기 때문에 신호 전달에 사용된다는 것입니다. 일반적으로 버퍼가 없는 채널과 함께 사용됩니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 신호 채널 생성</span>\nwaitc := <span class=\"hljs-title function_\">make</span>(chan struct{})\n \n<span class=\"hljs-comment\">// ...</span>\ngoroutine <span class=\"hljs-number\">1</span>:\n    <span class=\"hljs-comment\">// 신호 전송: 요소 추가</span>\n    waitc &#x3C;- struct{}{}\n    <span class=\"hljs-comment\">// 신호 전송: 종료</span>\n    <span class=\"hljs-title function_\">close</span>(waitc)\n \ngoroutine <span class=\"hljs-number\">2</span>:\n    select {\n    <span class=\"hljs-comment\">// 신호 수신 및 해당 작업 수행</span>\n    <span class=\"hljs-keyword\">case</span> <span class=\"xml\">&#x3C;-waitc:\n    }\n</span></code></pre>\n<p>이 시나리오에서 struct가 꼭 필요할까요? 정말 필요하지는 않으며, 절약되는 메모리는 미미합니다. 핵심은 chan의 요소 값이 중요하지 않다는 것이며, 따라서 struct가 사용됩니다.</p>\n<h1>요약</h1>\n<div class=\"content-ad\"></div>\n<ul>\n<li>빈 구조체는 여전히 크기가 0인 구조체입니다.</li>\n<li>모든 빈 구조체는 동일한 주소를 공유합니다: zerobase 주소입니다.</li>\n<li>빈 구조체의 메모리를 차지하지 않는 기능을 활용하여 맵을 사용하여 집합 및 채널을 구현하는 등 코드를 최적화할 수 있습니다.</li>\n</ul>\n<h1>참고 자료</h1>\n<ul>\n<li>빈 구조체, Dave Cheney</li>\n<li>Go 최종 릴리스 - struct'' 빈 구조체가 정확히 무엇인가요?</li>\n</ul>\n</body>\n</html>\n"},"__N_SSG":true}