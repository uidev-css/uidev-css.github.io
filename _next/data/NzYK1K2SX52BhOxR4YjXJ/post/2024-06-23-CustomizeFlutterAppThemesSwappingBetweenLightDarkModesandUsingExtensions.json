{"pageProps":{"post":{"title":"Flutter 앱 테마 커스터마이즈 라이트와 다크 모드 전환 및 익스텐션 사용 방법","description":"","date":"2024-06-23 14:53","slug":"2024-06-23-CustomizeFlutterAppThemesSwappingBetweenLightDarkModesandUsingExtensions","content":"\n플러터는 테마 지원을 통해 개발자들이 다양한 테마 기능으로 애플리케이션을 사용자 정의할 수 있도록 훌륭한 지원을 제공합니다. 이 글에서는 두 가지 핵심 테마 기능에 중점을 두겠습니다:\n\nA) 다크 테마와 라이트 테마 간 전환하기.\n\nB) 테마 확장을 사용하여 추가 테마 데이터 클래스를 생성하여 더 많은 사용자 정의를 할 수 있습니다.\n\n完전한 작동하는 샘플 코드에 대한 접근은 동봉된 GitHub 저장소를 참조해주세요.\n\n<div class=\"content-ad\"></div>\n\n![image](/assets/img/2024-06-23-CustomizeFlutterAppThemesSwappingBetweenLightDarkModesandUsingExtensions_0.png)\n\n# 다크 테마와 라이트 테마 사이를 전환하세요\n\n다크 테마와 라이트 테마 사이를 전환하는 것은 다음 예시에서 알 수 있듯이 매우 간단합니다:\n\n```js\nreturn MaterialApp(\n  ...\n  themeMode: themeMode,\n  darkTheme: ThemeData.dark(),\n  theme: ThemeData.light(),\n  ...\n);\n```\n\n<div class=\"content-ad\"></div>\n\n이 세 가지 필드는 앱이 적용해야 하는 테마의 유형을 지정할 수 있습니다. 기본적으로 themeMode는 darkTheme 또는 theme을 사용할지를 결정합니다.\n\nThemeMode에는 세 가지 값이 있습니다:\n\n- ThemeMode.light: 앱에 밝은 테마를 사용하도록 지시합니다.\n- ThemeMode.dark: 앱에 어두운 테마를 사용하도록 지시합니다.\n- ThemeMode.system: 앱이 시스템의 테마와 일치하도록 지시합니다.\n\n애플리케이션의 테마를 동적으로 변경하려면 코드가 반응해야 합니다. 실제적이고 효율적인 방법은 변경 사항에 응답할 수 있는 상태를 App 위젯 위에 배치하는 것입니다. 이 상태는 원하는 방식으로 관리할 수 있습니다. 현재, 저는 애플리케이션의 상태 관리에 플러터 프로바이더를 사용하고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nreturn Solid(\n  providers: [\n    Provider<Signal<ThemeMode>>(create: () => Signal(ThemeMode.system)),\n  ],\n  builder: (context) {\n    final themeMode = context.observe<ThemeMode>();\n    return MaterialApp(\n      ...\n      themeMode: themeMode,\n      darkTheme: ThemeData.dark(),\n      theme: ThemeData.light(),\n      ...\n    );\n  },\n);\n```\n\n그 후, 애플리케이션 어디서든 메서드를 호출하여 프로바이더에게 값을 변경하도록 지시할 수 있습니다. 이는 애플리케이션을 그에 맞게 다시 빌드합니다:\n\n```js\ncontext.get<Signal<ThemeMode>>().value = newThemeMode;\n```\n\n앱이 시작할 때마다 ThemeMode를 저장하고 가져와서 사용자의 테마 선호도를 유지해야 합니다. 이렇게 하면 사용자의 선택사항이 기억되고 일관되게 적용됩니다.\n\n<div class=\"content-ad\"></div>\n\n# 테마 확장 사용하기\n\n다크 테마와 라이트 테마를 전환하는 것만으로도 좋지만, Flutter를 사용하면 테마 확장을 통해 더 많은 사용자 정의가 가능합니다. 테마 확장은 표준 ThemeData를 넘어 사용자 정의 속성과 스타일을 정의할 수 있게 해줍니다.\n\n다음은 ThemeExtension을 확장한 클래스의 일부 코드입니다:\n\n```js\nclass MyCustomThemeExtension extends ThemeExtension<MyCustomThemeExtension> {\n  const MyCustomThemeExtension({\n    required this.customColor,\n  });\n\n  MyCustomThemeExtension.light() : customColor = Colors.yellow.shade900;\n\n  MyCustomThemeExtension.dark() : customColor = Colors.green.shade900;\n\n  final Color customColor;\n\n  @override\n  ThemeExtension<MyCustomThemeExtension> copyWith({\n    Color? customColor,\n  }) {\n    return MyCustomThemeExtension(customColor: customColor ?? this.customColor);\n  }\n\n  @override\n  ThemeExtension<MyCustomThemeExtension> lerp(\n    covariant ThemeExtension<MyCustomThemeExtension>? other,\n    double t,\n  ) {\n    if (other is! MyCustomThemeExtension) return this;\n    return MyCustomThemeExtension(\n      customColor: Color.lerp(customColor, other.customColor, t)!,\n    );\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n저는 이 클래스를 매우 간단하게 유지하여 효과적으로 사용하는 방법을 보여주기 위해 노력했습니다.\n\n먼저, 이 클래스를 ThemeData에 추가하여 확장하고 해당 확장을 서브트리 내에서 접근할 수 있도록 해야 합니다:\n\n```js\nreturn ThemeData(\n  ...\n  extensions: [MyCustomThemeExtension.light()],\n  ...\n);\n```\n\n우리가 이전에 선언한 customColor를 활용하기 위해서는 해당 확장에 접근하면 됩니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n마지막 색상 = Theme.of(context)\n                        .extension<MyCustomThemeExtension>()!\n                        .customColor;\n```\n\nThemeExtension의 사용은 특히 Material 사양과 긴밀히 연결되지 않은 디자인 시스템을 코딩할 때 특히 유용하다고 생각합니다. 이러한 경우에는 ThemeData의 기본 필드가 충분하지 않거나 디자인 시스템의 요구 사항과 의미적으로 일치하지 않을 수 있습니다.\n\n# 결론\n\n테마 전환을 통해 개발자는 더 동적이고 현대적인 애플리케이션을 만들 수 있을 뿐만 아니라 사용자의 요구를 존중할 수 있다고 생각합니다. 저는 개인적으로 다크 모드를 많이 사용하고 애플리케이션이 그것을 지원하지 않을 때 약간 긴장을 느낍니다.\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 Markdown 형식으로 변경해 드렸어요.\n\n좋은 하루 보내세요!\n\n## 참고문헌\n","ogImage":{"url":"/assets/img/2024-06-23-CustomizeFlutterAppThemesSwappingBetweenLightDarkModesandUsingExtensions_0.png"},"coverImage":"/assets/img/2024-06-23-CustomizeFlutterAppThemesSwappingBetweenLightDarkModesandUsingExtensions_0.png","tag":["Tech"],"readingTime":4},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>플러터는 테마 지원을 통해 개발자들이 다양한 테마 기능으로 애플리케이션을 사용자 정의할 수 있도록 훌륭한 지원을 제공합니다. 이 글에서는 두 가지 핵심 테마 기능에 중점을 두겠습니다:</p>\n<p>A) 다크 테마와 라이트 테마 간 전환하기.</p>\n<p>B) 테마 확장을 사용하여 추가 테마 데이터 클래스를 생성하여 더 많은 사용자 정의를 할 수 있습니다.</p>\n<p>完전한 작동하는 샘플 코드에 대한 접근은 동봉된 GitHub 저장소를 참조해주세요.</p>\n<div class=\"content-ad\"></div>\n<p><img src=\"/assets/img/2024-06-23-CustomizeFlutterAppThemesSwappingBetweenLightDarkModesandUsingExtensions_0.png\" alt=\"image\"></p>\n<h1>다크 테마와 라이트 테마 사이를 전환하세요</h1>\n<p>다크 테마와 라이트 테마 사이를 전환하는 것은 다음 예시에서 알 수 있듯이 매우 간단합니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">MaterialApp</span>(\n  ...\n  <span class=\"hljs-attr\">themeMode</span>: themeMode,\n  <span class=\"hljs-attr\">darkTheme</span>: <span class=\"hljs-title class_\">ThemeData</span>.<span class=\"hljs-title function_\">dark</span>(),\n  <span class=\"hljs-attr\">theme</span>: <span class=\"hljs-title class_\">ThemeData</span>.<span class=\"hljs-title function_\">light</span>(),\n  ...\n);\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>이 세 가지 필드는 앱이 적용해야 하는 테마의 유형을 지정할 수 있습니다. 기본적으로 themeMode는 darkTheme 또는 theme을 사용할지를 결정합니다.</p>\n<p>ThemeMode에는 세 가지 값이 있습니다:</p>\n<ul>\n<li>ThemeMode.light: 앱에 밝은 테마를 사용하도록 지시합니다.</li>\n<li>ThemeMode.dark: 앱에 어두운 테마를 사용하도록 지시합니다.</li>\n<li>ThemeMode.system: 앱이 시스템의 테마와 일치하도록 지시합니다.</li>\n</ul>\n<p>애플리케이션의 테마를 동적으로 변경하려면 코드가 반응해야 합니다. 실제적이고 효율적인 방법은 변경 사항에 응답할 수 있는 상태를 App 위젯 위에 배치하는 것입니다. 이 상태는 원하는 방식으로 관리할 수 있습니다. 현재, 저는 애플리케이션의 상태 관리에 플러터 프로바이더를 사용하고 있습니다.</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Solid</span>(\n  <span class=\"hljs-attr\">providers</span>: [\n    <span class=\"hljs-title class_\">Provider</span>&#x3C;<span class=\"hljs-title class_\">Signal</span>&#x3C;<span class=\"hljs-title class_\">ThemeMode</span>>>(<span class=\"hljs-attr\">create</span>: <span class=\"hljs-function\">() =></span> <span class=\"hljs-title class_\">Signal</span>(<span class=\"hljs-title class_\">ThemeMode</span>.<span class=\"hljs-property\">system</span>)),\n  ],\n  <span class=\"hljs-attr\">builder</span>: (context) {\n    final themeMode = context.<span class=\"hljs-property\">observe</span>&#x3C;<span class=\"hljs-title class_\">ThemeMode</span>>();\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">MaterialApp</span>(\n      ...\n      <span class=\"hljs-attr\">themeMode</span>: themeMode,\n      <span class=\"hljs-attr\">darkTheme</span>: <span class=\"hljs-title class_\">ThemeData</span>.<span class=\"hljs-title function_\">dark</span>(),\n      <span class=\"hljs-attr\">theme</span>: <span class=\"hljs-title class_\">ThemeData</span>.<span class=\"hljs-title function_\">light</span>(),\n      ...\n    );\n  },\n);\n</code></pre>\n<p>그 후, 애플리케이션 어디서든 메서드를 호출하여 프로바이더에게 값을 변경하도록 지시할 수 있습니다. 이는 애플리케이션을 그에 맞게 다시 빌드합니다:</p>\n<pre><code class=\"hljs language-js\">context.<span class=\"hljs-property\">get</span>&#x3C;<span class=\"hljs-title class_\">Signal</span>&#x3C;<span class=\"hljs-title class_\">ThemeMode</span>>>().<span class=\"hljs-property\">value</span> = newThemeMode;\n</code></pre>\n<p>앱이 시작할 때마다 ThemeMode를 저장하고 가져와서 사용자의 테마 선호도를 유지해야 합니다. 이렇게 하면 사용자의 선택사항이 기억되고 일관되게 적용됩니다.</p>\n<div class=\"content-ad\"></div>\n<h1>테마 확장 사용하기</h1>\n<p>다크 테마와 라이트 테마를 전환하는 것만으로도 좋지만, Flutter를 사용하면 테마 확장을 통해 더 많은 사용자 정의가 가능합니다. 테마 확장은 표준 ThemeData를 넘어 사용자 정의 속성과 스타일을 정의할 수 있게 해줍니다.</p>\n<p>다음은 ThemeExtension을 확장한 클래스의 일부 코드입니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyCustomThemeExtension</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">ThemeExtension</span>&#x3C;<span class=\"hljs-title class_\">MyCustomThemeExtension</span>> {\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">MyCustomThemeExtension</span>({\n    required <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">customColor</span>,\n  });\n\n  <span class=\"hljs-title class_\">MyCustomThemeExtension</span>.<span class=\"hljs-title function_\">light</span>() : customColor = <span class=\"hljs-title class_\">Colors</span>.<span class=\"hljs-property\">yellow</span>.<span class=\"hljs-property\">shade900</span>;\n\n  <span class=\"hljs-title class_\">MyCustomThemeExtension</span>.<span class=\"hljs-title function_\">dark</span>() : customColor = <span class=\"hljs-title class_\">Colors</span>.<span class=\"hljs-property\">green</span>.<span class=\"hljs-property\">shade900</span>;\n\n  final <span class=\"hljs-title class_\">Color</span> customColor;\n\n  @override\n  <span class=\"hljs-title class_\">ThemeExtension</span>&#x3C;<span class=\"hljs-title class_\">MyCustomThemeExtension</span>> <span class=\"hljs-title function_\">copyWith</span>(<span class=\"hljs-params\">{\n    Color? customColor,\n  }</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">MyCustomThemeExtension</span>(<span class=\"hljs-attr\">customColor</span>: customColor ?? <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">customColor</span>);\n  }\n\n  @override\n  <span class=\"hljs-title class_\">ThemeExtension</span>&#x3C;<span class=\"hljs-title class_\">MyCustomThemeExtension</span>> <span class=\"hljs-title function_\">lerp</span>(<span class=\"hljs-params\">\n    covariant ThemeExtension&#x3C;MyCustomThemeExtension>? other,\n    double t,\n  </span>) {\n    <span class=\"hljs-keyword\">if</span> (other is! <span class=\"hljs-title class_\">MyCustomThemeExtension</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">MyCustomThemeExtension</span>(\n      <span class=\"hljs-attr\">customColor</span>: <span class=\"hljs-title class_\">Color</span>.<span class=\"hljs-title function_\">lerp</span>(customColor, other.<span class=\"hljs-property\">customColor</span>, t)!,\n    );\n  }\n}\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>저는 이 클래스를 매우 간단하게 유지하여 효과적으로 사용하는 방법을 보여주기 위해 노력했습니다.</p>\n<p>먼저, 이 클래스를 ThemeData에 추가하여 확장하고 해당 확장을 서브트리 내에서 접근할 수 있도록 해야 합니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">ThemeData</span>(\n  ...\n  <span class=\"hljs-attr\">extensions</span>: [<span class=\"hljs-title class_\">MyCustomThemeExtension</span>.<span class=\"hljs-title function_\">light</span>()],\n  ...\n);\n</code></pre>\n<p>우리가 이전에 선언한 customColor를 활용하기 위해서는 해당 확장에 접근하면 됩니다:</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\">마지막 색상 = <span class=\"hljs-title class_\">Theme</span>.<span class=\"hljs-title function_\">of</span>(context)\n                        .<span class=\"hljs-property\">extension</span>&#x3C;<span class=\"hljs-title class_\">MyCustomThemeExtension</span>>()!\n                        .<span class=\"hljs-property\">customColor</span>;\n</code></pre>\n<p>ThemeExtension의 사용은 특히 Material 사양과 긴밀히 연결되지 않은 디자인 시스템을 코딩할 때 특히 유용하다고 생각합니다. 이러한 경우에는 ThemeData의 기본 필드가 충분하지 않거나 디자인 시스템의 요구 사항과 의미적으로 일치하지 않을 수 있습니다.</p>\n<h1>결론</h1>\n<p>테마 전환을 통해 개발자는 더 동적이고 현대적인 애플리케이션을 만들 수 있을 뿐만 아니라 사용자의 요구를 존중할 수 있다고 생각합니다. 저는 개인적으로 다크 모드를 많이 사용하고 애플리케이션이 그것을 지원하지 않을 때 약간 긴장을 느낍니다.</p>\n<div class=\"content-ad\"></div>\n<p>테이블 태그를 Markdown 형식으로 변경해 드렸어요.</p>\n<p>좋은 하루 보내세요!</p>\n<h2>참고문헌</h2>\n</body>\n</html>\n"},"__N_SSG":true}