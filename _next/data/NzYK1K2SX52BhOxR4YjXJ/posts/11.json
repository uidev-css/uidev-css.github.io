{"pageProps":{"posts":[{"title":"Flutter FCM - 푸시 알림 탭 후 특정 화면으로 이동하는 방법","description":"","date":"2024-06-21 23:04","slug":"2024-06-21-FlutterFCMHowtoNavigatetoaParticularScreenAfterTappingonPushNotification","content":"\n이 게시물에서는 FCM 푸시 알림을 수신하고 사용자가 푸시 알림을 탭했을 때 특정 페이지로 이동하는 방법에 대해 Flutter에서 설명하겠습니다 (서버 측 코드 없음).\n\n![Flutter FCM How to Navigate to a Particular Screen After Tapping on Push Notification](/assets/img/2024-06-21-FlutterFCMHowtoNavigatetoaParticularScreenAfterTappingonPushNotification_0.png)\n\n## iOS 설정\n\nApple의 플랫폼에서 개발하는 것은 때로 어려울 수 있습니다. 예를 들어 Android와는 달리, 푸시 알림을 테스트하려면 실제 기기가 필요하며 Apple 개발자 프로그램에 관리자 또는 계정 보유자로 등록해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n- Xcode에서 Targets `Runner` Signing & Capabilities로 이동하여 푸시 알림을 추가하려면 +를 눌러주세요. 그리고 Background Modes에 Background fetch와 Remote notification도 추가해주세요.\n\n2. Apple Developer Member Center에서 Certificates, Identifiers & Profile로 이동하여 `Keys`에서 Apple Push Notification service (APN) 키를 추가해주세요. 그런 다음, 해당 키를 Firebase Console `Project Settings` Cloud Messaging `Apple app configuration`에 추가해주세요.\n\n3. 나머지는 매우 간단합니다 — 공식 문서를 참조해주세요.\n\n## Android 설정\n\n<div class=\"content-ad\"></div>\n\nForeground Notification(푸시 알림이 일시적으로 화면 상단에 팝업되는 경우)을 사용하려면 AndroidManifest.xml에 아래의 메타데이터가 필요합니다. 'high_importance_channel'에 대한 고급 중요도 채널은 Firebase 공식 문서에서 제공된 이름을 사용했으며 platformChannelSpecifics에서 (아래에서 자세히 설명함) 채널 이름을 지정할 수 있습니다.\n\n```js\n<meta-data\n  android:name=\"com.google.firebase.messaging.default_notification_channel_id\"\n  android:value=\"high_importance_channel\"\n/>\n```\n\n## Firebase 초기화\n\n먼저 필요한 모든 패키지를 추가해주세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nflutter pub add firebase_messaging\nflutter pub add firebase_core\nflutter pub add flutter_local_notifications\n```\n\n파일들을 프로바이더와 서비스 파일로 분리하는 것에 익숙하지만, 그렇게 하는 것이 필요하지는 않습니다. Firebase 초기화에 대해 말씀드리면 main 함수에서 해야 합니다.\n\n```js\nvoid main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n  await FirebaseService.initializeFirebase();\n  runApp(const MyApp());\n}\n```\n\n```js\nimport 'dart:async';\n\nimport 'package:firebase_core/firebase_core.dart';\nimport 'package:firebase_messaging/firebase_messaging.dart';\nimport 'package:flutter_local_notifications/flutter_local_notifications.dart';\n\nclass FirebaseService {\n  static FirebaseMessaging? _firebaseMessaging;\n  static FirebaseMessaging get firebaseMessaging => FirebaseService._firebaseMessaging ?? FirebaseMessaging.instance;\n\n  static Future<void> initializeFirebase() async {\n    await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);\n    FirebaseService._firebaseMessaging = FirebaseMessaging.instance;\n    await FirebaseService.initializeLocalNotifications();\n    await FCMProvider.onMessage();\n    await FirebaseService.onBackgroundMsg();\n  }\n\n  Future<String?> getDeviceToken() async => await FirebaseMessaging.instance.getToken();\n\n  static FlutterLocalNotificationsPlugin _localNotificationsPlugin = FlutterLocalNotificationsPlugin();\n\n  static Future<void> initializeLocalNotifications() async {\n    final InitializationSettings _initSettings = InitializationSettings(\n      android: AndroidInitializationSettings(\"icon_name\"),\n      iOS: DarwinInitializationSettings()\n    );\n    /// on did receive notification response = for when app is opened via notification while in foreground on android\n    await FirebaseService.localNotificationsPlugin.initialize(_initSettings, onDidReceiveNotificationResponse: FCMProvider.onTapNotification);\n    /// need this for ios foregournd notification\n    await FirebaseService.firebaseMessaging.setForegroundNotificationPresentationOptions(\n      alert: true, // Required to display a heads up notification\n      badge: true,\n      sound: true,\n    );\n  }\n\n  static NotificationDetails platformChannelSpecifics = NotificationDetails(\n    android: AndroidNotificationDetails(\n      \"high_importance_channel\", \"High Importance Notifications\", priority: Priority.max, importance: Importance.max,\n    ),\n  );\n\n  // for receiving message when app is in background or foreground\n  static Future<void> onMessage() async {\n    FirebaseMessaging.onMessage.listen((RemoteMessage message) async {\n      if (Platform.isAndroid) {\n        // if this is available when Platform.isIOS, you'll receive the notification twice\n        await FirebaseService._localNotificationsPlugin.show(\n          0, message.notification!.title, message.notification!.body, FirebaseService.platformChannelSpecifics,\n          payload: message.data.toString(),\n        );\n      }\n    });\n  }\n\n  static Future<void> onBackgroundMsg() async {\n    FirebaseMessaging.onBackgroundMessage(FCMProvider.backgroundHandler);\n  }\n\n}\n```\n\n<div class=\"content-ad\"></div>\n\nFirebaseService.initializeFirebase 메서드 내의 모든 메서드를 살펴보겠습니다.\n\n\\_firebaseMessaging: 이전 FCM 포스트를 작성하던 중 한국 어딘가에서 FirebaseMessaging.instance를 한 번만 호출하는 것이 좋다는 글을 읽은 적이 있어요. 그래서 이를 initialize 메서드에서 초기화하고, \\_firebaseMessaging이 null인 경우 적절한 값을 제공해주는 getter를 만들었어요.\n\ninitializeLocalNotifications: Foreground Notification을 활용하려면 이 메서드가 필요해요. Android에서는 반드시 전달해야 하는 인자 중 하나가 android/app/src/main/res/drawable에 있어야 하는 아이콘 로고 파일 이름이에요.\n\n전달된 두 번째 인자는 onSelectNotification으로, 사용자가 푸시 알림을 탭했을 때 (앱이 포그라운드에 있을 때) 실행되는 콜백입니다. 이런 처리가 없으면 앱이 열리고 더 이상의 작업이 발생하지 않아요. 이 메서드는 onMessage의 FirebaseMessaging.onMessage.listen(안드로이드용)로부터 페이로드를 받습니다.\n\n<div class=\"content-ad\"></div>\n\n`onMessage`: 앱이 활성 상태인 경우에 알림을 받을 때 호출됩니다.\n\n`onBackgroundMsg`: 앱이 백그라운드에 있거나 종료된 상태일 때 알림을 받을 때 호출됩니다.\n\n## 디바이스 토큰 받기/확인\n\n```js\nFuture<String?> getDeviceToken() async => await FirebaseService.firebaseMessaging.getToken();\n```\n\n<div class=\"content-ad\"></div>\n\n기기 토큰을 관리하는 올바른 방법은 없지만 Firebase가 권장하는 방법이 있습니다. 제가 선택한 방법은 sqflite를 사용하여 사용자 기기에 타임스탬프와 함께 기기 토큰을 저장하고 서버로 보내는 것입니다. 앱이 열릴 때마다 기기에 저장된 토큰이 있다면 서버로 전송됩니다. 타임스탬프가 한 달 이상 경과했다는 것을 나타내는 경우, 토큰이 새로 고침되고 새 토큰이 서버로 전송됩니다. (아래 코드는 sqflite를 사용하는 제 sql 파일을 기반으로 합니다.)\n\n```js\nFuture<String?> checkDeviceToken() async {\n    String? _deviceToken;\n    final bool _exists = await this._sqlService.tableExists(this._tableName);\n    if (_exists) {\n        final List<Json> _data = await this._sqlService.readData(this._tableName);\n        final DateTime _timeStamp = DateTime.parse(_data[0][\"timeStamp\"]);\n        if (_timeStamp.difference(DateTime.now()).inDays > 30) {\n            _deviceToken = await this._getDeviceToken();\n            if (_deviceToken == null) return null; // todo error handling\n            await this._updateDeviceToken(_deviceToken);\n        } else {\n            _deviceToken = _data[0][\"deviceToken\"];\n        }\n    } else {\n        _deviceToken = await this._getDeviceToken();\n        if (_deviceToken == null) return null; // todo error handling\n        await this._saveDeviceToken(_deviceToken);\n    }\n    return _deviceToken;\n}\n\nFuture<String?> _getDeviceToken() async => await FirebaseService.firebaseMessaging.getToken();\n\nFuture<void> _saveDeviceToken(String deviceToken) async {\n    final String _createSql = \"CREATE TABLE ${this._tableName}(deviceToken TEXT PRIMARY KEY NOT NULL, timeStamp TEXT NOT NULL)\";\n    final List<Object> _values = [deviceToken, DateTime.now().toIso8601String()];\n    final String _insertSql = \"INSERT INTO ${this._tableName}(deviceToken, timeStamp) VALUES(?, ?)\";\n    await this._sqlService.saveData(tableName: this._tableName, createSql: _createSql, insertSql: _insertSql, values: _values);\n}\n\nFuture<void> _updateDeviceToken(String deviceToken) async {\n    final String _updateSql = \"UPDATE ${this._tableName} SET deviceToken = ?, timeStamp = ?\";\n    final List<Object> _values = [deviceToken, DateTime.now().toIso8601String()];\n    await this._sqlService.updateData(tableName: this._tableName, updateSql: _updateSql, values: _values);\n}\n```\n\n## 알림 수신\n\n불행히도 저는 서버 측 코드를 만들지 않아 message.data가 어떻게 작동하는지를 보여줄 수 없습니다. 왜냐하면 Firebase의 테스트 알림은 message.notification.body와 message.notification.title만 허용하기 때문입니다. 더 구체적인 알림을 테스트하려면 백엔드 개발자와 협력해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n푸시 알림을 받고 앱을 열 수 있는 세 가지 방법이 있습니다:\n\n- 앱이 화면에 표시될 때\n- 앱이 백그라운드에 있을 때\n- 앱이 종료되었을 때\n\n## 앱이 화면에 표시될 때 (Android)\n\n사용자가 알림을 탭하면 기본적으로 앱이 열리게 됩니다. 그러나 때로는 사용자가 특정 페이지를 볼 수 있기를 원할 수도 있습니다. 백엔드 개발자는 이러한 정보를 메시지.data에 제공할 수 있습니다. 해당 정보를 가져오기 위해 제공자를 만들었고, Navigator.of(context).push를 사용하기 위해 첫 화면에서 제공자의 BuildContext 변수를 초기화했습니다.\n\n<div class=\"content-ad\"></div>\n\n@override\nvoid init() {\nsuper.initState();\nWidgetsBinding.instance.addPostFrameCallback((\\_) {\nFCMProvider.setContext(context);\n});\n}\n\nimport 'package:firebase_messaging/firebase_messaging.dart' show FirebaseMessaging, RemoteMessage;\nimport 'package:flutter/widgets.dart';\nimport 'package:pops/helpers/custom_types.dart';\n\nimport '../views/store_detail/store_detail_page.dart';\n\nclass FCMProvider with ChangeNotifier {\nstatic BuildContext? \\_context;\n\nstatic void setContext(BuildContext context) => FCMProvider.\\_context = context;\n\n/// when app is in the foreground\nstatic Future<void> onTapNotification(NotificationResponse? response) async {\nif (FCMProvider.\\_context == null || response?.payload == null) return;\nfinal Json \\_data = FCMProvider.convertPayload(response!.payload!);\nif (\\_data.containsKey(...)){\nawait Navigator.of(FCMProvider.\\_context!).push(...);\n}\n}\n\nstatic Json convertPayload(String payload){\nfinal String \\_payload = payload.substring(1, payload.length - 1);\nList<String> \\_split = [];\n\\_payload.split(\",\")..forEach((String s) => \\_split.addAll(s.split(\":\")));\nJson \\_mapped = {};\nfor (int i = 0; i < \\_split.length + 1; i++) {\nif (i % 2 == 1) \\_mapped.addAll({\\_split[i-1].trim().toString(): \\_split[i].trim()});\n}\nreturn \\_mapped;\n}\n\nstatic Future<void> onMessage() async {\nFirebaseMessaging.onMessage.listen((RemoteMessage message) async {\nif (FCMProvider.\\_refreshNotifications != null) await FCMProvider.\\_refreshNotifications!(true);\n// if this is available when Platform.isIOS, you'll receive the notification twice\nif (Platform.isAndroid) {\nawait FirebaseService.localNotificationsPlugin.show(\n0, message.notification!.title,\nmessage.notification!.body,\nFirebaseService.platformChannelSpecifics,\npayload: message.data.toString(),\n);\n}\n});\n}\n\nstatic Future<void> backgroundHandler(RemoteMessage message) async {\n\n}\n}\n\n앱이 화면에 보일 때 onTapNotification 메서드가 실행되며, localNotificationsPlugin.initialize의 onSelectNotification에 콜백 메서드로 설정됩니다. onTapNotification은 message.data.toString()을 페이로드로 받고(페이로드는 문자열로만 넣을 수 있기 때문에) 페이로드를 다시 맵으로 변환합니다.\n\n## 앱이 백그라운드에 있을 때 (Android) 및 앱이 포그라운드 / 백그라운드에 있을 때(iOS)\n\n<div class=\"content-ad\"></div>\n\n첫 번째 페이지에서 initState에 다음 코드를 넣었는데, 안드로이드에서 앱이 백그라운드에 있을 때 작동하는 것으로 보이며, iOS에서는 앱이 포그라운드/백그라운드에 있을 때 작동합니다.\n\n```js\nStream<RemoteMessage> _stream = FirebaseMessaging.onMessageOpenedApp;\n_stream.listen((RemoteMessage event) async {\n  if (event.data != null) {\n    await Navigator.of(context).push(...);\n  }\n});\n```\n\n## 앱이 종료된 경우\n\n앱이 종료된 경우 main.dart의 main 메소드에서 메시지를 받아와야 하며, 다른 곳에서 시도하면 실패할 것입니다. 저는 이 메시지를 첫 번째 페이지로 전달하고, initState에서 적절한 조치를 취했습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// main.dart\nvoid main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n  await FirebaseService.initializeFirebase();\n  final RemoteMessage? _message = await FirebaseService.firebaseMessaging.getInitialMessage();\n  runApp(const MyApp(message: _message));\n}\n\n// 앱이 켜졌을 때 열리는 첫 번째 페이지\n@override\nvoid initState() {\n  super.initState();\n  WidgetsBinding.instance.addPostFrameCallback((_) async {\n    if (this.widget.message != null) {\n      Future.delayed(const Duration(milliseconds: 1000), () async {\n        await Navigator.of(context).pushNamed(...);\n      });\n    }\n  });\n}\n```\n\n## Backend\n\niOS에서 소리가 포함된 알림을 받으려면 Cloud 콘솔에 다음이 필요합니다: (깃헙 참조)\n\n```js\n\"apns: {\n  \"payload\": {\n    \"aps\": {\n      \"sound\": default\n    }\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n도움이 되길 바라요! 즐거운 코딩하세요.\n","ogImage":{"url":"/assets/img/2024-06-21-FlutterFCMHowtoNavigatetoaParticularScreenAfterTappingonPushNotification_0.png"},"coverImage":"/assets/img/2024-06-21-FlutterFCMHowtoNavigatetoaParticularScreenAfterTappingonPushNotification_0.png","tag":["Tech"],"readingTime":12},{"title":"플러터에서 Cubit 상태 관리 사용하는 방법","description":"","date":"2024-06-21 23:02","slug":"2024-06-21-CubitStateManagementinFlutter","content":"\n![Cubit State Management in Flutter](/assets/img/2024-06-21-CubitStateManagementinFlutter_0.png)\n\n상태 관리는 모바일 앱 개발에서 중요한 요소이며, 특히 UI가 반응적인 Flutter와 같은 프레임워크에서는 더욱 중요합니다. Flutter에서 다양한 상태 관리 기술 중 하나인 BLoC (Business Logic Component) 패턴이 상당한 인기를 얻었습니다. BLoC의 영역 내에서 두 가지 주요 접근 방식이 있습니다: Bloc State Management과 Cubit State Management.\n\n# Cubit이란?\n\nCubit은 BLoC 패턴의 일부인 간단하고 직관적인 상태 관리 솔루션입니다. \"Business Logic Component\"의 약자입니다. 전통적인 BLoC와는 달리, Cubit은 더 가벼우며 더 간단한 API를 가지고 있어 더 작은 프로젝트나 간단한 상태 관리 필요에 쉽게 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n플러터에서 Cubit 상태 관리를 시작하려면 flutter_bloc 패키지를 설치해야 합니다:\n\n```js\ndependencies:\n   flutter_bloc: ^8.1.3\n```\n\n# Cubit을 사용한 카운터 앱\n\n더 나은 이해를 위해 Cubit을 사용하여 간단한 카운터 앱을 구현해 봅시다. 단계별로 진행하겠습니다. 함께 따라와 주세요.\n\n<div class=\"content-ad\"></div>\n\n친구야, Cubit 폴더를 만들어 그 안에 counter_cubit.dart 파일을 생성해보세요.\n\n![이미지](/assets/img/2024-06-21-CubitStateManagementinFlutter_1.png)\n\n파일 안에 Cubit을 확장한 클래스를 만들어주세요.\n\n```js\nclass CounterCubit extends Cubit {}\n```\n\n<div class=\"content-ad\"></div>\n\n문제: 하지만 이렇게 하면 오류가 발생합니다. 수퍼 클래스 'Cubit`dynamic`'에는 인수가 없는 생성자가 없습니다.\n\n그래서 생성자를 만들어 초기 상태를 전달해야 합니다.\n\n```js\nclass CounterCubit extends Cubit {\n  CounterCubit():super(0);\n}\n```\n\n여기서 '0'은 초기 상태이지만 문자열, 클래스 등이 될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 이제 초기 상태를 화면에 표시해야 합니다\n\n카운터 큐빗 클래스의 인스턴스를 만듭니다.\n\n이제 이 객체를 사용하여 다양한 것에 액세스할 수 있습니다:\n\n![Cubit State Management in Flutter](/assets/img/2024-06-21-CubitStateManagementinFlutter_2.png)\n\n<div class=\"content-ad\"></div>\n\n지금은 .state를 필요로 합니다.\n\n```js\nfinal counter = CounterCubit().state;\n```\n\n필요한 곳에서 사용할 수 있습니다.\n\n```js\nText(\"$counter\");\n```\n\n<div class=\"content-ad\"></div>\n\n문제: 작은 문제가 있습니다. 이 카운터는 동적 타입이므로 코드를 망가뜨리지는 않지만, 동적 타입을 피해야 합니다.\n\n![이미지](/assets/img/2024-06-21-CubitStateManagementinFlutter_3.png)\n\n그래서 카운터 cubic 클래스에 타입을 지정해 주세요.\n\n```js\nclass CounterCubit extends Cubit<int> {\n  CounterCubit() : super(0);\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이제 초기 상태를 성공적으로 표시했어요.\n\n## 값 증가, 상태 변경\n\n이를 위해 카운터 커빗 클래스에 값을 증가시키는 함수를 만들고 모든 청취자에게 알립니다. 상태를 변경하기 위해 emit 함수를 사용합니다.\n\nemit(state) // 제공된 [state]로 상태를 업데이트합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nclass CounterCubit extends Cubit<int> {\n  CounterCubit() : super(0);\n\n  void increment() {\n    emit(state + 1);\n  }\n}\n```\n\n이제 이 함수를 버튼 클릭에 사용하세요\n\n```js\nonPressed: () => CounterCubit().increment(),\n```\n\n문제: 그러나 버튼을 클릭해도 상태가 변경되지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n이는 우리가 cubit의 두 개체를 생성하고 있기 때문입니다. 두 번째 cubit의 값을 업데이트하고 있습니다. 이것을 제거하려면 하나의 cubit만 사용해야 합니다.\n\n단일 객체 생성\n\n```js\nfinal counterCubit = CounterCubit();\n```\n\n그리고 이것을 모두에서 사용하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nfinal counter = counterCubit.state; // 빌드 내부\n\n```\n\n버튼을 누르면\n\n```js\nonPressed: () => counterCubit.increment(),\n```\n\n문제점: 그러나 한 가지 더 빠진 것이 있습니다.\n\n<div class=\"content-ad\"></div>\n\n한 번만 값을 받아서 상태를 업데이트하고 emit이 청취자에게 통지하지만 우리는 상태를 청취하고 있지 않습니다.\n\n이제 BlocBuilder를 사용해야 합니다. 이는 flutter_bloc에서 제공하는 위젯이며 bloc과 builder라는 두 인수가 필요합니다.\n\n```js\nBlocBuilder<CounterCubit, int>(\n      bloc: counterCubit, // 선택 사항\n      builder: (context, counter) {\n         return Text(\n           '$counter',\n         );\n}),\n```\n\n# 완료 단계\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 Markdown 형식으로 변경해주세요.\n\nCreate a separate class extend with cubit, give the initial state and a function to change the state.\n\n```js\nimport 'package:flutter_bloc/flutter_bloc.dart';\n\nclass CounterCubit extends Cubit<int> {\n  CounterCubit() : super(0);\n\n  void increment() {\n    emit(state + 1);\n  }\n}\n```\n\nUse the state by making a single object of the cubit class and use BlocBuilder where you need the changing state\n\n```js\nclass _MyHomePageState extends State<MyHomePage> {\n  final counterCubit = CounterCubit(); // (1: object)\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: Column(\n          children: <Widget>[\n            const Text(\n              'You have pushed the button this many times:',\n            ),\n            // (2: state value)\n            BlocBuilder<CounterCubit, int>(\n              bloc: counterCubit, // optional\n              builder: (context, counter) {\n                return Text(\n                  '$counter',\n                );\n              }\n            ),\n          ],\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () => counterCubit.increment(), // (3: increment)\n        tooltip: 'Increment',\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## 감소 기능 추가\n\n```js\n void decrement() {\n    if (state == 0) {\n      return;\n    }\n    emit(state - 1);\n  }\n```\n\n```js\nonPressed: () => counterCubit.decrement(),\n```\n\n참고: emit() 함수는 Cubit 외부에서 사용할 수 없습니다.\n\n<div class=\"content-ad\"></div>\n\n# 질문: 두 개의 별도 페이지가 있는 경우\n\n두 개의 별도 페이지가 있는 경우에는 상태를 표시하는 페이지와 그 상태를 변경하는 버튼이 있는 페이지가 따로 있는 것을 의미합니다.\n\n그런데 앞서 언급한 대로 cubit 클래스의 두 개의 다른 객체를 사용할 수 없습니다.\n\n![이미지](/assets/img/2024-06-21-CubitStateManagementinFlutter_4.png)\n\n<div class=\"content-ad\"></div>\n\n이제 icc_dec_page에 버튼이 있고 home_page.dart에서 카운터를 표시하고 있습니다.\n\n카운터 Cubit의 두 인스턴스를 만들 수 없기 때문에 작동하지 않습니다. 하나의 인스턴스만 사용해야 합니다. 이 문제를 해결하기 위해 BlocProvider를 사용합니다. BlocProvider는 블록의 인스턴스를 전달하는 데 사용됩니다.\n\n따라서 main.dart에서 Material app을 BlocProvider로 래핑하고 cubit/bloc을 함수의 인수로 전달합니다.\n\nMarkdown 형식의 표로 변경:\n\nWidget build(BuildContext context) {\nreturn BlocProvider( // <-- 이 부분\ncreate: (\\_) => CounterCubit(),\nchild: MaterialApp(\ntitle: 'Flutter Demo',\ntheme: ThemeData(\ncolorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple),\nuseMaterial3: true,\n),\nhome: const MyHomePage(title: 'Flutter Demo Home Page'),\n),\n);\n}\n}\n\n<div class=\"content-ad\"></div>\n\n이제 앱 어디에서든 이 카운터 cubit 인스턴스에 액세스할 수 있습니다. 이전에 생성한 cubit 인스턴스를 제거하고 다음을 사용할 수 있습니다.\n\n```js\nfinal counterCubit = BlocProvider.of<CounterCubit>(context);\n```\n\nhome_page.dart에서\n\n```js\n  Widget build(BuildContext context) {\n    final counterCubit = BlocProvider.of<CounterCubit>(context);\n    return Scaffold(\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n\n            BlocBuilder<CounterCubit, int>(\n                bloc: counterCubit, // optional\n                builder: (context, counter) {\n                  return Text(\n                    '$counter',\n                  );\n                }),\n          ],\n        ),\n      ),\n```\n\n<div class=\"content-ad\"></div>\n\ninc_dec_page.dart 파일에서\n\n```js\n @override\n  Widget build(BuildContext context) {\n    final counterCubit = BlocProvider.of<CounterCubit>(context);\n    return Scaffold(\n      floatingActionButton: Column(\n        mainAxisAlignment: MainAxisAlignment.end,\n        children: [\n          IconButton(\n            onPressed: () => counterCubit.increment(),\n            tooltip: '증가',\n            icon: const Icon(Icons.add),\n          ),\n          const SizedBox(\n            height: 10,\n          ),\n          IconButton(\n            onPressed: () => counterCubit.decrement(),\n            tooltip: '감소',\n            icon: const Icon(Icons.minimize),\n          ),\n        ],\n```\n\n이 예시의 전체 코드는 제 GitHub 저장소에서 확인할 수 있습니다:\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\n요약하자면, Cubit은 bloc 및 provider 패키지의 장점을 결합하여 상태를 관리하는 간단한 방법을 제공하며 이벤트의 복잡성 없이 상태를 관리할 수 있습니다. Cubit은 메서드 중심의 접근 방식과 최소한의 보일러플레이트 코드로 상태 관리를 간소화하므로 Flutter 개발자들에게 효율성과 구현 용이성을 위한 탁월한 선택지가 됩니다.\n\n- 👔 LinkedIn: muhammadnaqeeb\n- 💻 GitHub: muhammadnaqeeb\n","ogImage":{"url":"/assets/img/2024-06-21-CubitStateManagementinFlutter_0.png"},"coverImage":"/assets/img/2024-06-21-CubitStateManagementinFlutter_0.png","tag":["Tech"],"readingTime":8},{"title":"플러터 다트에서 extends, implements, mixin의 차이점 완벽 이해하기","description":"","date":"2024-06-21 23:00","slug":"2024-06-21-UnderstandingtheDifferencesBetweenextendsimplementsandmixininFluttersDart","content":"\n![image](/assets/img/2024-06-21-UnderstandingtheDifferencesBetweenextendsimplementsandmixininFluttersDart_0.png)\n\n안녕하세요!\n\nFlutter는 크로스 플랫폼 모바일 애플리케이션을 만들기 위한 강력한 프레임워크입니다. 기본적으로 Flutter는 Dart 프로그래밍 언어를 사용하며, 개발자가 깨끗하고 유지보수가 쉬운 코드를 작성하는 데 도움을 주는 여러 기능을 제공합니다. Dart의 한 가지 측면 중 초보자들에게 혼란스러울 수 있는 부분은 \"extends\", \"implements\" 및 \"mixin\"의 차이점입니다. 이 블로그 포스트에서는 이러한 개념을 쉽게 이해할 수 있도록 탐구할 것입니다. 이 글을 끝까지 읽으시면 Flutter 프로젝트에서 각 키워드를 언제 어떻게 사용해야 하는지 명확히 이해하게 될 것입니다.\n\n- \"extends\" 이해하기.\n\n<div class=\"content-ad\"></div>\n\n닷(Dart)에서는 \"extends\" 키워드를 사용하여 다른 클래스, 즉 수퍼클래스로부터 속성 및 동작을 상속하는 클래스를 만듭니다. 클래스가 다른 클래스를 확장하면 수퍼클래스에서 정의된 모든 변수, 메서드 및 생성자에 액세스할 수 있습니다. 이 개념을 상속이라고 합니다.\n\n- 상속 계층 구조: 상속을 통해 클래스를 계층 구조로 구성할 수 있으며 맨 위에는 베이스 또는 부모 클래스가 있고 그 아래에 파생 또는 자식 클래스가 있습니다. 이 계층 구조를 통해 공통 속성과 동작을 공유할 수 있습니다.\n- 구문 및 예제: Dart에서 \"extends\"를 사용하는 구문은 다음과 같습니다:\n\n```js\nclass 자식클래스 extends 부모클래스 {\n  // 자식클래스 멤버\n}\n```\n\n- 다음은 \"extends\"의 사용법을 보여주는 예제입니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n// 슈퍼클래스 생성\nclass Animal {\n  String name;\n\n  Animal(this.name);\n\n  void makeSound() {\n    print(\"동물이 소리를 냅니다\");\n  }\n}\n\n// 'extends'를 사용하여 서브클래스 생성\nclass Dog extends Animal {\n  String breed;\n\n  Dog(String name, this.breed) : super(name);\n\n  @override\n  void makeSound() {\n    print(\"개가 짖습니다\");\n  }\n}\n\nvoid main() {\n  // 서브클래스의 인스턴스 생성\n  var myDog = Dog(\"버디\", \"골든 리트리버\");\n  print(myDog.name); // 출력: Buddy\n  print(myDog.breed); // 출력: Golden Retriever\n  myDog.makeSound(); // 출력: The dog barks\n}\n```\n\n2. \"implements\" 탐색.\n\n\"extends\"는 클래스 상속에 사용되는 반면, \"implements\" 키워드는 Dart에서 인터페이스를 구현하는 데 사용됩니다. 인터페이스는 클래스가 해당 인터페이스의 메소드를 구현함으로써 준수해야 하는 계약을 정의합니다. 클래스가 인터페이스를 구현하면 인터페이스에서 지정된 필수 기능을 제공하기로 동의합니다.\n\n- 인터페이스란 무엇인가? 인터페이스는 클래스가 준수해야 하는 메소드 세트를 정의하는 방법으로 생각할 수 있습니다. 인터페이스를 준수하는 클래스에서 예상되는 동작을 지정합니다.\n- 인터페이스 구현: 인터페이스를 구현하려면 클래스가 인터페이스에서 선언된 모든 메소드를 정의해야 합니다. 이를 통해 클래스가 필요한 기능을 제공하도록 합니다.\n- 아래 예제는 \"implements\" 사용법을 보여줍니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// 인터페이스 생성하기\nabstract class Flyable {\n  void fly();\n}\n\n// 인터페이스 구현하기\nclass Bird implements Flyable {\n  String name;\n\n  Bird(this.name);\n\n  @override\n  void fly() {\n    print(\"$name가 날고 있습니다\");\n  }\n}\n\nvoid main() {\n  // 인터페이스를 구현하는 클래스의 인스턴스 생성\n  var myBird = Bird(\"참새\");\n  myBird.fly(); // 출력: 참새가 날고 있습니다\n}\n```\n\n- 이 예제에서 \"Bird\" 클래스는 \"Flyable\" 인터페이스를 구현하여 \"fly\" 메서드에 대한 구현을 제공합니다.\n- 다중 인터페이스: Dart는 클래스가 여러 인터페이스를 구현할 수 있도록 허용하여 여러 계약을 준수할 수 있습니다. 이 유연성은 코드 재사용과 다양한 시나리오에서의 적응성을 가능하게 합니다.\n\n3. \"mixin\"의 힘을 이해하기.\n\nDart는 상속 없이 여러 클래스 간에 코드를 재사용할 수 있게 하는 \"mixin\"이라는 개념을 소개합니다. Mixin은 다른 클래스에 적용할 수 있는 행동을 구성하여 코드 모듈성과 재사용성을 향상시킵니다.\n\n<div class=\"content-ad\"></div>\n\n- 믹신이 뭡니까? 믹신은 클래스 계층 구조를 만들지 않고 여러 클래스 사이에서 코드를 재사용하는 방법을 제공합니다. 믹신은 관련이 없는 클래스 사이에서 공유할 수 있는 행동을 구성하는 것을 가능하게 합니다.\n\n- 구성 vs. 상속: 상속은 클래스 간에 계층적인 관계를 만드는 데 유용하지만, 믹신은 코드 재사용에 더 유연하고 모듈식 접근 방식을 제공합니다. 믹신을 사용하면 클래스가 엄격한 클래스 계층 구조의 제약으로 인해 제한받지 않고 특정 행동을 채택할 수 있습니다.\n\n- 믹신 선언: Dart에서 믹신을 선언하려면 믹신 이름 뒤에 \"mixin\" 키워드를 사용하면 됩니다. 다음은 예시입니다:\n\n```js\nmixin Swimmer {\n  void swim() {\n    print(\"The object is swimming\");\n  }\n}\n```\n\n- 믹신 적용: 클래스에서 믹신을 사용하려면 믹신 이름 뒤에 \"with\" 키워드를 사용하면 됩니다. 다음은 예시입니다:\n\n```js\nclass Dolphin with Swimmer {\n  String name;\n\n  Dolphin(this.name);\n}\n```\n\n<div class=\"content-ad\"></div>\n\n- 이 예시에서는 \"Dolphin\" 클래스가 \"Swimmer\" 믹스인을 적용하여 \"swim\" 메서드를 얻습니다.\n- 코드 예시: 실용적인 예시로 \"Person\" 클래스와 \"Walker\" 믹스인이 있는 경우를 고려해 봅시다:\n\n```js\nmixin Walker {\n  void walk() {\n    print(\"The person is walking\");\n  }\n}\n\nclass Person with Walker {\n  String name;\n\n  Person(this.name);\n}\n\nvoid main() {\n  var person = Person(\"John\");\n  person.walk(); // 출력: The person is walking\n}\n```\n\n- 이 예시에서 \"Person\" 클래스는 \"Walker\" 믹스인을 적용하여 \"walk\" 메서드를 사용할 수 있게 됩니다.\n\n결론\n\n<div class=\"content-ad\"></div>\n\nDart에서 'extends', 'implements', 그리고 'mixin'의 차이를 이해하는 것은 효율적이고 유지보수 가능한 Flutter 애플리케이션을 작성하는 데 중요합니다. 'extends'는 클래스 상속을 가능하게 하며, 'implements'는 인터페이스 계약을 준수하는 데 도움을 줍니다. 'mixin'은 복잡한 클래스 계층 구조를 만들지 않고도 코드 재사용을 촉진합니다. 이러한 개념을 이해함으로써 탄탄한 기반을 갖추어 견고한 Flutter 애플리케이션을 설계하고 Dart의 능력을 활용할 수 있을 것입니다.\n\n계속해서 Flutter와 Dart의 세계를 탐험하는 동안, 이러한 개념을 마스터하는 데 있어서 연습이 중요하다는 것을 기억해 주세요. 직접 프로젝트에 적용해 보고 다양한 시나리오를 실험하여 깊은 이해를 얻어보세요.\n\n더 많은 정보는 아래 링크에서 확인할 수 있습니다:\n\n- Flutter Documentation: https://flutter.dev/docs\n- Dart Language Tour: https://dart.dev/guides/language/language-tour\n","ogImage":{"url":"/assets/img/2024-06-21-UnderstandingtheDifferencesBetweenextendsimplementsandmixininFluttersDart_0.png"},"coverImage":"/assets/img/2024-06-21-UnderstandingtheDifferencesBetweenextendsimplementsandmixininFluttersDart_0.png","tag":["Tech"],"readingTime":5},{"title":"2024년 소프트웨어 개발을 위한 최고의 10대 기술 스택","description":"","date":"2024-06-21 22:58","slug":"2024-06-21-Top10TechnologyStackinSoftwareDevelopmentFor2024","content":"\n\n# Tech-Stacks에 대해\n\n테크 스택(Tech-Stacks)은 이름에서 알 수 있듯이 어떤 프로젝트에서 사용되는 기술 스택의 끝부분을 의미합니다. 클라이언트 측 즉, UI부터 서버 측까지 사용되는 모든 기술이 포함됩니다. 테크 스택을 구축하기 위해서는 프로젝트의 모든 세그먼트에서 적절한 기술을 선택해야 합니다. 이러한 기술은 소프트웨어 프로젝트의 요구사항에 따라 선택됩니다. 프로젝트 요구사항과 기술이 시간과 함께 발전함에 따라 더 나은 새로운 기술이 나오므로, 이전의 기술 스택을 새로운 기술 스택으로 이동하는 것이 중요합니다.\n\n기술 스택은 주로 두 가지 주요 구성 요소로 구성됩니다: 프런트엔드 스택과 백엔드 스택.\n\n## 프런트엔드 스택\n\n<div class=\"content-ad\"></div>\n\n프론트엔드 스택은 소프트웨어 응용 프로그램의 사용자 인터페이스를 개발하는 데 사용되는 도구와 기술로 구성됩니다. 이에는 HTML, CSS, JavaScript 및 Angular, React, Vue.js와 같은 프론트엔드 프레임워크가 포함됩니다.\n\n## 백엔드 스택\n\n백엔드 스택은 소프트웨어 응용 프로그램의 서버 측을 개발하는 데 사용되는 도구와 기술로 구성됩니다. 이에는 PHP, Python, Ruby, C++ 및 Java와 같은 프로그래밍 언어, Django, Laravel, Ruby on Rails와 같은 백엔드 프레임워크, MySQL, Oracle DB, NoSQL DB와 같은 데이터베이스, Nginx, Apache, Internet Information Server (IIS)와 같은 웹 서버가 포함됩니다.\n\n# 2024년 소프트웨어 개발의 상위 10개 기술 스택\n\n<div class=\"content-ad\"></div>\n\n아래는 소프트웨어 개발에 널리 사용되었으며 강력한 선택지로 간주되는 몇 가지 기술 스택입니다.\n\n# 1. LAMP 스택\n\n- Linux : LINUX의 전체 명칭은 Lovable Intellect Not Using XP입니다. Linus Torvalds가 만들었습니다. 서버, 컴퓨터, 메인프레임, 모바일 시스템 및 임베디드 시스템을 위한 오픈 소스 운영 체제입니다.\n- Apache : Apache HTTP Server는 무료이자 오픈 소스의 크로스 플랫폼 웹 서버 소프트웨어입니다. 이는 HTTP 요청을 받아들이고 클라이언트(UI)로부터 요청된 정보를 웹 페이지 형식으로 보내기 위해 사용됩니다.\n- MySQL : MySQL은 오픈 소스 관계형 데이터베이스 관리 시스템입니다.\n- PHP : Hypertext Preprocessor의 약자입니다. 웹 개발을 위해 특별히 설계된 서버 측 스크립팅 언어입니다. 오픈 소스로 무료로 다운로드 및 사용할 수 있습니다. 배우기 쉽고 사용하기 매우 간단합니다.\n\n주요 구성 요소로는 Linux(운영 체제), Apache(웹 서버), MySQL(데이터베이스) 및 PHP(프로그래밍 언어)가 포함됩니다. LAMP 스택은 매우 간단하고 적응력이 있으며 저렴한 기술 스택입니다. LAMP는 개발자가 유지 및 확장하기 쉽고 동적이며 인터랙티브한 웹 애플리케이션을 생성할 수 있도록 합니다. 크기가 크지 않은 프로젝트를 시작하거나 작업하고 있는 웹 개발자에게 LAMP는 훌륭한 선택지입니다.\n\n<div class=\"content-ad\"></div>\n\nSlack의 개발에는 다음 기술 스택이 사용됩니다.\n\n![2024-06-21-Top10TechnologyStackinSoftwareDevelopmentFor2024](/assets/img/2024-06-21-Top10TechnologyStackinSoftwareDevelopmentFor2024_0.png)\n\n## 2. Python/Django 스택\n\n- Python: Python은 고수준의 범용 프로그래밍 언어입니다. 구조화된, 객체지향 및 함수형 프로그래밍을 지원합니다.\n- Django: Django는 무료이면서 오픈소스인 Python 기반의 웹 프레임워크로, 웹 서버에서 실행됩니다. Model-Template-Views 아키텍처 패턴을 따릅니다.\n- React/Angular/Vue: 이들은 무료이면서 오픈소스인 프런트엔드 JavaScript 라이브러리로, 구성 요소를 기반으로 하는 사용자 인터페이스를 구축하는 데 사용됩니다. 이들은 개별 개발자 및 회사들의 커뮤니티에 의해 유지보수되고 있습니다.\n- MySQL\n\n<div class=\"content-ad\"></div>\n\n이 기술 스택에서는 프로그래밍 언어로 Python을 사용하고 백엔드 프레임워크로 Django를 사용하며 프론트엔드 기술(예: React, Angular, Vue)을 사용하며 데이터베이스로 MySQL을 사용합니다. 이는 매우 유명한 가벼운 구축이 쉬운 스택입니다.\n\nPixar 개발에는 이 기술 스택이 사용됩니다.\n\n![image](/assets/img/2024-06-21-Top10TechnologyStackinSoftwareDevelopmentFor2024_1.png)\n\n### 3. Ruby on Rails 스택\n\n<div class=\"content-ad\"></div>\n\n- 루비: 프로그래밍 언어\n- 루비 온 레일즈: Model-View-Controller (MVC) 패턴에 따라 데이터베이스를 백엔드 웹 애플리케이션을 만드는 데 필요한 모든 것을 포함한 웹 앱 프레임워크입니다.\n- 자바스크립트: 자바스크립트는 세계적인 웹 기술인 HTML 및 CSS와 함께 사용되는 프로그래밍 언어입니다.\n\n이 기술 스택에서 루비는 프로그래밍 언어로 사용되고, 루비 온 레일즈는 백엔드 프레임워크로 사용되며, 자바스크립트는 프론트 엔드에 사용됩니다. 이는 오픈 소스이며 객체 지향적이며, 모델-뷰-컨트롤러 (MVC) 패턴을 따르므로 코드를 보다 구조화되고 유지보수하기 쉽게 만듭니다. 루비에는 방대한 문서화 및 리소스가 있는 강력한 커뮤니티가 있어 개발자들이 협력하고 코드를 이해하기 쉬워집니다. ROR은 데이터베이스 설정을 간편하게 하고 빠른 소프트웨어 개발을 위한 스캐폴딩을 제공합니다. ROR은 또한 Active Record라는 ORM(객체-관계 매핑) 도구를 함께 제공하여 데이터베이스 테이블을 루비 객체에 매핑하여 데이터베이스 상호작용을 간단하게 합니다. 이외에도 ROR은 사용자 인터페이스를 위해 HTML, CSS 및 자바스크립트를 사용하며, 데이터는 JSON 또는 XML을 사용합니다.\n\n에어비앤비의 개발에는 이 기술 스택이 사용됩니다.\n\n![이미지](/assets/img/2024-06-21-Top10TechnologyStackinSoftwareDevelopmentFor2024_2.png)\n\n<div class=\"content-ad\"></div>\n\n# Ruby on Rails\n\n## 4. Java Spring Stack\n\n- Java : 웹 서비스의 백엔드 개발에 사용되는 오픈 소스 언어입니다.\n- Spring Framework : Spring Framework는 Java 플랫폼을 위한 응용 프레임워크 및 제어 반전 컨테이너입니다.\n- JavaScript 프레임워크\n- MySQL/PostgreSQL/Oracle\n\n이 기술 스택에서는 프로그래밍 언어로 Java를 사용하고 백엔드 프레임워크로 Spring Framework를 사용합니다. 프론트엔드에는 JavaScript 프레임워크(e.g., React, Angular)를 사용하며 데이터베이스로는 MySQL, PostgreSQL, Oracle과 같은 다양한 데이터베이스 시스템을 Java 개발자가 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n테슬라 개발에 사용된 기술 스택입니다.\n\n![Tech Stack](/assets/img/2024-06-21-Top10TechnologyStackinSoftwareDevelopmentFor2024_3.png)\n\n### 5. ASP.NET 스택\n\n- C# : 여러 패러다임을 지원하는 범용 고수준 프로그래밍 언어입니다. C#은 정적 타입, 강한 타입, 렉시컬 스코핑, 명령형, 선언적, 함수형, 제네릭, 객체지향(클래스 기반), 컴포넌트 지향 프로그래밍을 포함합니다.\n- ASP.NET : 마이크로소프트에서 디자인 및 개발한 웹 애플리케이션 프레임워크입니다.\n- React/Angular\n\n<div class=\"content-ad\"></div>\n\n이 기술 스택에서는 C#을 프로그래밍 언어로 사용하고 백엔드 프레임워크로 ASP.NET을, 그리고 프런트엔드에는 JavaScript 프레임워크(예: React, Angular)를 사용합니다. 이 기술 스택은 동적이고 견고한 웹 애플리케이션을 구축하는 데 널리 사용됩니다. ASP.NET의 주요 기능은 확장성, 성능, 보안 등이 있습니다. ASP.NET은 다른 기술에 비해 더 발전된 기술입니다. 예를 들어, PHP나 LAMP와 같은 전통적인 웹 기술보다 더 우수한 성능을 제공합니다. 그리고 성능을 훼손하지 않고 높은 트래픽 양을 처리할 수 있으며 확장성도 뛰어납니다. 게다가 강력한 보안 기능을 제공하여 보안 수준이 높은 애플리케이션에 선호되는 선택지입니다.\n\n마이크로소프트의 개발에서는 이 기술 스택을 사용합니다.\n\n![그림](/assets/img/2024-06-21-Top10TechnologyStackinSoftwareDevelopmentFor2024_4.png)\n\n# 6. 서버리스 스택\n\n<div class=\"content-ad\"></div>\n\n- AWS Lambda/Azure Functions/ Google Cloud Functions: 이들은 서버를 프로비저닝하거나 관리하지 않고 코드를 실행할 수 있는 서버리스 컴퓨팅 서비스입니다. 소비한 컴퓨팅 시간만큼 비용을 지불합니다.\n- API Gateway: 클라이언트와 서비스 사이에 위치하여 API 통신을 중앙에서 처리하고 보안 및 정책 강제 기능을 제공하는 애플리케이션 전달 인프라의 구성 요소입니다.\n- NoSQL: NoSQL은 오픈 소스 비관계형 데이터베이스 관리 시스템입니다.\n- React/Vue/Angular\n\n이 기술 스택에서 AWS Lambda, Azure Functions, Google Cloud Functions은 서버리스 컴퓨팅으로 사용되고, API Gateway는 백엔드 관리를 위해 사용되며, NoSQL이나 관리형 데이터베이스 서비스와 React, Vue, Angular 같은 프론트엔드가 사용될 수 있습니다. 현재 가장 트렌디하고 고급 기술 스택으로, 개발자가 인프라와 서버 관리에 대해 걱정할 필요가 없어집니다.\n\nFigma 개발에는 이 기술 스택이 사용됩니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-21-Top10TechnologyStackinSoftwareDevelopmentFor2024_5.png\" />\n\n# 7. MEVN Stack\n\n- MongoDB: 가장 인기있는 NoSQL 데이터베이스 중 하나입니다. 오픈 소스 문서 지향 데이터베이스입니다. MongoDB는 데이터를 테이블과 같은 관계형 데이터베이스 구조에 저장하지 않고 데이터의 저장 및 검색을 위한 전혀 다른 메커니즘을 제공합니다. MongoDB에 대해 알아볼 수 있습니다.\n- Express.js: Node.js로 RESTful API를 작성하기 위한 백엔드 웹 애플리케이션 프레임워크입니다. 웹 애플리케이션 및 API를 구축하기 위해 설계되었습니다.\n- Vue.js: 또한 오픈 소스 JavaScript 라이브러리입니다.\n- Node.js: Windows, Linux, Unix, macOS 등에서 실행할 수 있는 오픈 소스 크로스 플랫폼 JavaScript 런타임 환경입니다. Node.js는 V8 JavaScript 엔진에서 실행되며 JavaScript 코드를 웹 브라우저 외부에서 실행합니다. Node.js를 사용하면 개발자가 JavaScript로 명령 줄 도구 작성 및 서버 측 스크립팅에 사용할 수 있습니다.\n\n이 기술 스택에서 MongoDB는 데이터 저장에 사용되고, Express.js는 백엔드 프레임워크에 사용되며, Vue.js는 프런트엔드 라이브러리에 사용되고, Node.js는 런타임 환경에 사용됩니다. 이를 통해 실시간 데이터 스트리밍 및 동적 사용자 인터페이스가 필요한 시스템과 같은 견고하고 확장 가능한 웹 애플리케이션을 구축할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n조마토의 개발에는 이 기술 스택이 사용됩니다.\n\n![기술 스택](/assets/img/2024-06-21-Top10TechnologyStackinSoftwareDevelopmentFor2024_6.png)\n\n## 8. MEAN 스택\n\n- MongoDB\n- Express.js\n- Angular: 단일 페이지 애플리케이션을 개발하기 위한 JavaScript 기반 프레임워크로, 구글과 여러 기업 및 개인 커뮤니티에 의해 주로 유지보수되었던 무료 오픈 소스 프레임워크입니다.\n- Node.js\n\n<div class=\"content-ad\"></div>\n\n이 기술 스택에서는 데이터베이스로 MongoDB가, 백엔드 프레임워크로 Express.js가, 프론트엔드 프레임워크로 Angular가, 그리고 런타임 환경으로 Node.js가 사용됩니다.\n\n유튜브 개발에는 이 기술 스택이 사용됩니다.\n\n![이미지](/assets/img/2024-06-21-Top10TechnologyStackinSoftwareDevelopmentFor2024_7.png)\n\n## 9. MERN 스택\n\n<div class=\"content-ad\"></div>\n\n- MongoDB\n- Express.js\n- React.js: 이것은 구성요소를 기반으로한 사용자 인터페이스를 구축하기 위한 무료 오픈 소스 프론트엔드 JavaScript 라이브러리입니다. 개인 개발자와 기업 커뮤니티에 의해 유지보수됩니다.\n- Node.js\n\n이 기술 스택에서 MongoDB는 데이터베이스로 사용되며, Express.js는 백엔드 프레임워크로, React.js는 프런트엔드 프레임워크로, Node.js는 실행 환경으로 사용됩니다. 이는 채팅 앱, 게임 앱 및 협업 도구와 같은 실시간 웹 응용 프로그램을 개발하기 위한 탁월한 선택입니다. 또한, 싱글 페이지 및 모바일 애플리케이션을 구축하는 데도 훌륭한 기술 스택입니다.\n\nNetflix의 개발에도 이 기술 스택이 사용되었습니다.\n\n![이미지](/assets/img/2024-06-21-Top10TechnologyStackinSoftwareDevelopmentFor2024_8.png)\n\n<div class=\"content-ad\"></div>\n\n10. 플러터 스택\n\n플러터 스택은 오픈 소스 모바일 애플리케이션 개발 프레임워크이며 크로스 플랫폼 응용 프로그램을 구축하는 데 사용되는 UI 툴킷을 포함하고 있습니다.\n\nGoogle Pay의 개발에 이 기술 스택이 사용됩니다.\n\n![이미지](/assets/img/2024-06-21-Top10TechnologyStackinSoftwareDevelopmentFor2024_9.png)\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n이것들은 가장 유명하고 유용한 기술 스택들 중 일부입니다. 이를 사용하여 훌륭한 프로젝트를 만들 수 있습니다. 예를 들어, LAMP 스택은 간단한 프로젝트에 가장 적합하며, Python 스택은 빠른 개발 및 웹 애플리케이션 구축을 위한 강력한 생태계에 적합합니다. Ruby on Rails 스택은 개발자의 행복과 유지보수 우선 프로젝트에 가장 적합합니다. 반면에 Java Spring 스택은 기업 수준 응용 프로그램에 가장 적합합니다. 한편, ASP.NET 스택은 Windows 중심 환경에서 효율적입니다. 서버리스 스택 또한 개발자들 사이에서 좋은 선택지입니다. MEVN, MEAN 및 MERN 스택 또한 훌륭한 선택지입니다. 따라서 프로젝트를 위해 특정 기술 스택을 선택할 때, 프로젝트의 복잡성, 확장성 요구, 목표, 팀의 전문성, 그리고 각 기술이 제공하는 특정 기능은 고려해야 할 중요한 요소입니다.","ogImage":{"url":"/assets/img/2024-06-21-Top10TechnologyStackinSoftwareDevelopmentFor2024_0.png"},"coverImage":"/assets/img/2024-06-21-Top10TechnologyStackinSoftwareDevelopmentFor2024_0.png","tag":["Tech"],"readingTime":8},{"title":"플러터에서 비밀번호 저장 및 자동 완성하는 방법","description":"","date":"2024-06-21 22:56","slug":"2024-06-21-SavePasswordAutofillPasswordinFlutter","content":"\n\n## 로그인할 때마다 로그인 자격 증명을 입력하는 것보다 더 쉬운 게 있을까요? 자동 입력 자격 증명이 여러분이 찾던 프로세스입니다!\n\n이 기사를 읽고 나서 기대할 수 있는 것들은 다음과 같습니다:\n\n![이미지](/assets/img/2024-06-21-SavePasswordAutofillPasswordinFlutter_0.png)\n\n![이미지](/assets/img/2024-06-21-SavePasswordAutofillPasswordinFlutter_1.png) \n\n<div class=\"content-ad\"></div>\n\n# 안드로이드\n\n안드로이드 파트는 매우 간단합니다. Android 모듈에서 구성을 설정할 필요가 없습니다.\n\n# iOS\n\niOS 모듈의 경우, 작업을 완료하기 위해 약간의 노력이 필요합니다.\n\n<div class=\"content-ad\"></div>\n\n그럼 시작해 봅시다!\n\n이미 플러터 프로젝트를 생성했다고 가정합니다.\n\n### 단계 1\n\n먼저 XCode에서 iOS 모듈을 엽니다. 그런 다음 \"Signing & Capabilities(서명 및 기능)\" 섹션으로 이동합니다. \"AutoFill Credential Provider(자동 완성 자격 증명 제공자)\" 및 \"Keychain Sharing(키체인 공유)\" 기능을 추가하세요.\n\n<div class=\"content-ad\"></div>\n\n단계 2\n\n\"Keychain Sharing\" 기능을 위해 프로젝트에 키 체인 그룹을 추가하세요. 그룹은 번들 식별자가 될 수 있습니다. 아래 그림 1을 참조하세요.\n\n![그림 1](/assets/img/2024-06-21-SavePasswordAutofillPasswordinFlutter_2.png)\n\n단계 3\n\n<div class=\"content-ad\"></div>\n\n다음으로, 기기의 키체인에 사용자 자격 증명을 저장하기 위해 사용될 \"연결된 도메인\" 기능을 추가해주세요.\n\n**단계 4**\n\n\"연결된 도메인\" 기능을 위해 webcredentials 및 applinks에 대한 도메인을 추가해야 합니다. 도면 2에 나와있는 도메인을 프로젝트의 실제 도메인으로 대체해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n혹시 iOS 기기의 키체인에서 사용자의 자격 증명을 앱과 관련시키기 위해 이 도메인을 사용하려고 합니다.\n\n**단계 5**\n\n이제 Apple 앱 사이트 연결을 위해 관련 도메인을 호스팅해야 합니다. 이를 위해 JSON 형식의 앱 데이터가 포함된 파일을 생성해야 합니다.\n\n```js\n{\n  \"applinks\": {\n      \"details\": [\n           {\n             \"appIDs\": [ \"{teamID}.{bundleID}\", \"{teamID}.{bundleID}\"],\n             \"components\": [\n               {\n                  \"#\": \"no_universal_links\",\n                  \"exclude\": true,\n                  \"comment\": \"fragment 값이 no_universal_links인 URL을 모두 일반 링크로 열지 않도록 시스템에 지시합니다.\"\n               },\n               {\n                  \"/\": \"/buy/*\",\n                  \"comment\": \"경로가 /buy/로 시작하는 모든 URL과 일치합니다.\"\n               },\n               {\n                  \"/\": \"/help/website/*\",\n                  \"exclude\": true,\n                  \"comment\": \"/help/website/로 시작하는 경로를 가진 URL을 모두 일반 링크로 열지 않도록 시스템에 지시합니다.\"\n               },\n               {\n                  \"/\": \"/help/*\",\n                  \"?\": { \"articleNumber\": \"????\" },\n                  \"comment\": \"경로가 /help/로 시작하고 'articleNumber'라는 쿼리 항목이 있으며 값이 정확히 네 자리인 URL을 모두 일치시킵니다.\"\n               }\n             ]\n           }\n       ]\n   },\n   \"webcredentials\": {\n      \"apps\": [ \"{teamID}.{bundleID}\" ]\n   },\n\n\n    \"appclips\": {\n        \"apps\": [\"{teamID}.{bundleID}\"]\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\nNOTE: 프로젝트의 팀 ID로 'teamID' 및 앱의 번들 ID로 'bundleID'를 교체해야 합니다.\n\n**단계 6**\n\n파일을 호스팅한 후에 아래 제공된 링크를 사용하여 파일이 성공적으로 호스팅되었는지 확인할 수 있습니다. 페이지가 성공적으로 로드되면 정상적으로 진행됩니다.\n\n[https://'your domain'/.well-known/assetlinks.json](https://'your domain'/.well-known/assetlinks.json)\n\n<div class=\"content-ad\"></div>\n\n현재 앱 구성이 완료되었습니다.\n\n# FLUTTER\n\n단계 1\n\n<div class=\"content-ad\"></div>\n\n거의 다 왔어요. 이제 로그인 화면을 열고 텍스트 필드를 Column 위젯으로 감싸세요. 그리고 해당 \"Column\" 위젯을 \"AutofillGroup\" 위젯으로 감싸세요.\n\n단계 2\n\n사용자 이름을 입력하는 텍스트 필드와 비밀번호를 입력하는 또 다른 텍스트 필드 두 개가 있다고 가정합니다. 사용자 이름 텍스트 필드에 AutofillHints.username을 설정한 후, 비밀번호 텍스트 필드에 AutofillHints.password을 설정하세요. 아래 그림과 같이 말이죠. \n\n![image](/assets/img/2024-06-21-SavePasswordAutofillPasswordinFlutter_4.png)\n\n<div class=\"content-ad\"></div>\n\n알림: iOS와 Android에 따라 저장된 비밀번호 프로세스가 다르게 작동됩니다.\n\n이제 빌드를 정리하고 실행하세요. 사용자가 사용자 이름과 비밀번호를 입력하고 텍스트 필드를 제출하면, 비밀번호 저장 프롬프트가 나타납니다. 그리고 다음에 다시 로그인을 시도하면, 이전에 추가된 자격증명을 자동으로 채울 것을 제안받게 됩니다.\n\n즐거운 코딩되세요...","ogImage":{"url":"/assets/img/2024-06-21-SavePasswordAutofillPasswordinFlutter_0.png"},"coverImage":"/assets/img/2024-06-21-SavePasswordAutofillPasswordinFlutter_0.png","tag":["Tech"],"readingTime":4},{"title":"Ionic vs React Native vs Flutter 2023년 최고의 선택은","description":"","date":"2024-06-21 22:53","slug":"2024-06-21-IonicvsReactNativevsFlutterWhatsBestfor2023","content":"\n\n\n![이미지](/assets/img/2024-06-21-IonicvsReactNativevsFlutterWhatsBestfor2023_0.png)\n\n# 소개:\n\n모바일 앱을 개발하고 싶지만 어떤 프레임워크를 선택해야 할지 확신이 서지 않나요? 이해합니다 - 다양한 옵션이 있고, 풍경이 끊임없이 변화하기 때문에 결정하기 어렵습니다. 저도 개발자로서 다양한 크로스 플랫폼 모바일 프레임워크를 실험해보았고, 세 가지 주요 플레이어인 Ionic, React Native 및 Flutter에 대한 통찰을 공유하고 싶습니다.\n\n각 프레임워크에는 장단점이 있어 모든 앱이나 팀에 대한 단일 정답은 없습니다. 그러나 2023년을 맞아 고려할 가치가 있는 몇 가지 트렌드가 등장하고 있습니다. 성능 및 개발자 경험이 점점 중요해지고 있습니다. 네이티브 기능 및 플랫폼별 최적화가 앱의 성공을 좌우할 수 있습니다. 새로운 기기 및 형태 요소에 적응할 수 있는 유연성이 핵심이 됩니다.\n\n\n<div class=\"content-ad\"></div>\n\n이 기사에서는 Ionic, React Native 및 Flutter의 개요를 제공하고, 이러한 영역 전체에서 어떻게 비교되는지 탐색하며, 다가오는 해에 귀하의 요구에 가장 적합한 선택이 무엇일지에 대해 공유할 것입니다. 최종 선택은 궁극적으로 여러분에게 달려 있지만, 올바른 정보를 갖고 있으면 자신감을 갖고 결정할 수 있습니다. 함께 알아보겠습니다!\n\n# Ionic, React Native 및 Flutter 프레임워크 개요\n\n![이미지](/assets/img/2024-06-21-IonicvsReactNativevsFlutterWhatsBestfor2023_1.png)\n\n그래서, 2023년에 프로젝트용 모바일 개발 프레임워크를 선택하려고 하는데 Ionic, React Native 및 Flutter 사이에서 고민 중이십니다. 이러한 프레임워크들이 각각 장단점을 갖고 있다는 것을 알지만, 전반적으로 어떤 것이 가장 좋은 옵션일까요?\n\n<div class=\"content-ad\"></div>\n\n이 세 가지 프레임워크의 개요부터 시작해보겠습니다. Ionic은 하이브리드 앱을 만드는 데 좋은 선택지입니다. 이를 사용하면 HTML, CSS, JavaScript을 활용하여 iOS/Android 앱을 만들 수 있습니다. React Native는 페이스북이 만든 오픈소스 플랫폼으로 iOS/Android 양쪽 플랫폼에 대한 크로스 플랫폼 개발을 가능케 합니다. 마지막으로, Flutter는 구글의 제품으로 안드로이드/iOS 플랫폼 모두를 위한 하나의 코드베이스로 고품질 앱을 개발할 수 있는 기능을 제공합니다.\n\n2023년에 프로젝트에 적합한 프레임워크를 결정하기 전에 이러한 플랫폼들을 신중히 고려하는 것이 중요합니다!\n\n# Ionic Framework: Build Native-Like Apps With Web Technologies\n\n![Ionic vs React Native vs Flutter - What's Best for 2023?](/assets/img/2024-06-21-IonicvsReactNativevsFlutterWhatsBestfor2023_2.png)\n\n<div class=\"content-ad\"></div>\n\n웹 기술을 사용하여 모바일 앱을 만들고 싶다면, Ionic을 사용하는 것이 좋습니다. Ionic을 사용하면 HTML, CSS 및 JavaScript를 활용하여 네이티브 앱과 유사한 앱을 만들 수 있습니다. 미리 디자인된 UI 구성 요소를 제공하여 개발자가 기능적이고 아름다운 앱을 만드는 것이 쉽습니다. Ionic은 iOS, Android 및 웹용 앱을 개발하는 데 사용할 수 있으므로 크로스 플랫폼 프레임워크로서도 좋은 선택입니다.\n\nIonic의 가장 큰 장점 중 하나는 Angular 위에 구축되어 있다는 것입니다. 이미 Angular에 익숙한 개발자들은 Ionic을 시작하는 것이 쉽을 것입니다. 또한 Angular 위에 구축되어 있음과 동시에 Ionic은 프레임워크를 위한 지원을 제공하고 플러그인 및 확장 프로그램을 만드는 커뮤니티가 큽니다.\n\nIonic은 \"Ionic Capacitor\"라는 기능도 제공합니다. 이는 개발자들이 Windows 또는 macOS와 같은 데스크톱 플랫폼에서 네이티브로 실행되는 앱을 개발할 수 있도록 합니다. 이는 기존의 웹 개발 기술을 활용하여 성능이나 디자인 품질을 희생하지 않고 여러 플랫폼 애플리케이션을 만들 수 있는 장점을 제공합니다.\n\n요약하자면, 웹 기술을 사용하여 네이티브 앱을 만드는 크로스 플랫폼 프레임워크를 찾고 있고 Angular에 대한 경험이 있는 경우, 2023년에는 Ionic을 고려해야 할 목록에 꼭 넣어두어야 합니다.\n\n<div class=\"content-ad\"></div>\n\n# React Native: React를 사용하여 네이티브 모바일 애플리케이션 개발하기\n\n![이미지](/assets/img/2024-06-21-IonicvsReactNativevsFlutterWhatsBestfor2023_3.png)\n\nReact Native은 모바일 앱 개발에서 개발자들 사이에서 인기 있는 선택지입니다. 그 인기의 이유는 명확합니다 — React를 사용하여 iOS와 Android 플랫폼 양쪽에 모두 적합한 네이티브 모바일 앱을 개발할 수 있기 때문입니다.\n\n## 크로스 플랫폼 개발:\n\n<div class=\"content-ad\"></div>\n\nReact Native으로 iOS 및 Android 플랫폼 모두에 코드를 한 번 작성하고 배포할 수 있어요. 이렇게 하면 시간과 자원을 절약할 수 있어요. 또한 사용자 경험이나 앱 성능을 양쪽 플랫폼 중 하나를 위해 희생할 필요가 없다는 것을 의미해요.\n\n## 개발 속도 향상:\n\nReact Native은 핫 리로딩을 가능하게 하여 코드에 가한 변경 사항이 전체 재빌드 없이 즉시 반영되는 기능을 제공해요. 이로 인해 더 빠른 개발 주기와 신속한 버그 수정이 가능해질 수 있어요.\n\n## 대규모 커뮤니티 지원:\n\n<div class=\"content-ad\"></div>\n\nReact Native은 상당히 오랜 시간동안 존재해왔으며 이로 인해 많은 개발자 커뮤니티가 형성되었습니다. 이는 온라인에서 문서부터 라이브러리까지 다양한 자원이 제공되어 개발자가 더 빠르게 더 나은 앱을 개발할 수 있도록 도와줍니다.\n\nReact Native를 사용하는 또 다른 장점은 React의 선언적 프로그래밍 패러다임을 활용하여 사용자 인터페이스를 구축한다는 점입니다. 이는 UI 컴포넌트를 작성하는 것을 다른 명령형 프로그래밍과 비교하여 직관적이고 유지 보수가 쉽게 만듭니다.\n\n모두를 종합해보면, JavaScript 및 React에 대한 기존 지식을 활용하여 네이티브 모바일 앱을 효율적으로 개발하려면 2023년에는 React Native가 여러분에게 가장 좋은 선택일 수 있습니다.\n\n# Flutter: Google의 네이티브 모바일 앱용 UI 툴킷\n\n<div class=\"content-ad\"></div>\n\n\n![Screenshot](/assets/img/2024-06-21-IonicvsReactNativevsFlutterWhatsBestfor2023_4.png)\n\n2023년을 위한 또 다른 프레임워크로 고려할만한 것은 플러터(Flutter)입니다. 플러터는 Google의 오픈 소스 UI 툴킷으로, 단일 코드베이스로 네이티브 모바일 앱을 구축하는 데 사용됩니다. 다음은 플러터가 다음 모바일 앱 프로젝트에 가장 적합한 선택일 수 있는 주요 이유입니다:\n\n## 네이티브 성능:\n\n플러터는 모든 것을 렌더링하는 데 Skia 그래픽 라이브러리를 사용하므로 플러터 앱은 iOS와 Android 모두에서 네이티브한 외관과 느낌을 제공합니다. 또한 플러터는 반응형 프레임워크와 상태 보존 핫 리로드를 갖고 있어, 빠른 렌더링과 부드러운 개발 경험을 얻을 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n## 거대한 생태계:\n\nFlutter는 Google에서 지원하고 있는 풍부한 도구 및 문서와 함께 개발자들에 의해 기여된 다양한 패키지의 거대한 생태계를 갖고 있습니다. Firebase 통합, 결제, 지도, 기계 학습 등 거의 모든 사용 사례에 대한 패키지를 찾을 수 있습니다.\n\n## 단일 코드베이스:\n\nFlutter를 사용하면 iOS 및 Android 앱을 빌드하기 위한 단일 코드베이스를 사용할 수 있으며 웹 및 데스크톱 앱을 개발할 수도 있습니다. 이는 개발 주기가 빨라지고 크로스 플랫폼 지원이 더욱 쉬워집니다. 각 플랫폼에 대한 별도의 코드베이스나 팀을 유지할 필요가 없습니다.\n\n<div class=\"content-ad\"></div>\n\n## Google 지원:\n\nGoogle이 만든 오픈 소스 프로젝트인 Flutter는 시간이 지남에 따라 프레임워크를 개선하기 위해 Google의 강력한 지원과 투자를 받습니다. Google은 또한 Flutter 엔진, Flutter의 핵심 계층을 유지보수합니다. Google의 뒤에 서있는 Flutter로 인해, Flutter가 계속해서 더 나아지리라 기대할 수 있습니다.\n\n전반적으로, 2023년 이후에도 Flutter는 크로스 플랫폼 모바일 개발을 위한 훌륭한 선택지입니다. 네이티브 성능, 거대한 생태계, 단일 코드베이스 및 Google 지원과 같은 기능들로, Flutter를 사용하면 iOS 및 Android 앱을 보다 신속하고 적은 비용으로 빌드하는 데 도움을 받을 수 있습니다.\n\n# Ionic vs React Native vs Flutter 비교\n\n<div class=\"content-ad\"></div>\n\n\n![Image](/assets/img/2024-06-21-IonicvsReactNativevsFlutterWhatsBestfor2023_5.png)\n\n2023년을 고려할 때 또 다른 고려해야 할 요소는 프레임워크가 능력과 기능 면에서 어떻게 비교되는지입니다. 간단히 살펴보겠습니다:\n\n## Ionic:\n\nIonic은 HTML, CSS 및 JavaScript와 같은 웹 기술을 사용하여 모바일 앱을 구축합니다. 따라서 기존의 웹 기술을 활용하고 플랫폼 간에 코드를 재사용할 수 있습니다. Ionic은 또한 네이티브 같은 앱을 만들기 위한 강력한 UI 구성 요소, 제스처 및 도구 라이브러리를 갖추고 있습니다. 그러나 앱 성능과 경험은 실제 네이티브 앱과 일치하지 않을 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n## React Native:\n\n리액트 네이티브는 웹 기술을 사용하지만 코드를 네이티브 컴포넌트로 컴파일하기 때문에 성능과 경험이 매우 네이티브에 가깝습니다. 다양한 타사 라이브러리와 통합이 많이 있습니다. 그러나 이온릭(Ionic)과 플러터(Flutter)에 비해 배우기 어려울 수 있습니다. 리액트 네이티브는 페이스북(Facebook)에서 지원하므로 강력한 커뮤니티와 생태계를 갖고 있습니다.\n\n## Flutter:\n\n플러터는 구글의 Dart 프로그래밍 언어와 독점 위젯을 사용하며 Skia라는 2D 렌더링 엔진을 사용해 모든 것을 렌더링합니다. 이로써 플러터 앱은 고성능으로 네이티브한 외관과 느낌을 구현할 수 있습니다. 플러터는 비교적 새로운 프레임워크지만 강력한 커뮤니티와 다양한 라이브러리 및 플러그인이 사용 가능합니다. 그러나 웹 언어에서 오는 학습 곡선이 가파를 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n2023년에는 Ionic, React Native 및 Flutter로 모바일 앱을 구축하는 데 좋은 옵션이 있습니다. 선택은 기술 스킬, 성능 요구 사항, 커뮤니티 지원 및 MVP를 빌드해야 하는 속도와 같은 요소에 따라 다릅니다. 많은 간단한 앱의 경우, 익숙한 웹 기술을 사용하여 가장 빠른 경로를 제공하는 Ionic이 좋습니다. 더 복잡한 고성능 앱의 경우, React Native 및 Flutter는 그들 뒤에 강력한 커뮤니티가 있는 좋은 선택지입니다.\n\n# 결론: 2023년 이후에 어떤 프레임워크가 가장 좋을까요?\n\n![이미지](/assets/img/2024-06-21-IonicvsReactNativevsFlutterWhatsBestfor2023_6.png)\n\n그렇다면 2023년과 이후에 가장 잘 준비된 프레임워크는 무엇일까요? 사실, 한 가지 결정적인 답변이 있지 않을 수도 있습니다. 각 프레임워크에는 강점이 있으며, 프로젝트에 대한 올바른 선택은 귀하의 우선 순위와 요구 사항에 따라 다릅니다.\n\n<div class=\"content-ad\"></div>\n\n## Ionic은 최적인 경우…\n\n웹 개발 기술을 활용하여 모바일 앱을 만들고 싶거나, 강력한 기본 UI 구성 요소가 필요하거나, 가장 넓은 기기 지원을 원할 때 좋습니다. Ionic은 HTML, CSS, JavaScript과 같은 웹 기술을 사용하여 모바일 앱을 개발합니다. 따라서 팀 내에 웹 개발자가 있다면 학습 곡선이 최소화됩니다. Ionic은 강력한 UI 요소 라이브러리를 보유하고 있으며, 가장 다양한 모바일 기기를 지원합니다.\n\n## React Native은 최적인 경우…\n\niOS, Android 및 웹 앱 간에 코드를 재사용하거나, 고성능이 필요하거나, 네이티브 기기 기능을 활용하고 싶을 때 좋습니다. React Native은 웹 앱을 개발하는 데 사용되는 React 프레임워크와 동일하게 사용합니다. 따라서 여러 플랫폼 간에 많은 코드를 공유할 수 있습니다. 또한 React Native은 실제 네이티브 앱으로 컴파일되므로 성능이 매우 좋습니다. React Native은 카메라, 가속도계 등과 같은 기기 기능에 액세스할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## Flutter은 가장 적합합니다…\n\n고품질 UI, 빠른 개발 시간 또는 모바일 및 데스크톱용 솔루션이 필요한 경우입니다. Flutter는 Dart 프로그래밍 언어와 미리 제공된 UI 요소 라이브러리를 사용하여 아름다운 앱을 신속하게 개발할 수 있도록 지원합니다. 또한 Flutter는 모바일 및 데스크톱용 원시 코드를 컴파일하므로 코드를 플랫폼 간에 재사용할 수 있습니다.\n\n최종적으로, 이러한 프레임워크 중 어느 것을 선택해도 잘못된 선택은 없습니다. 그러나 여러분의 우선순위와 기술적 요구 사항을 고려하여 다음 앱 개발 프로젝트에 가장 적합한 프레임워크를 결정할 수 있습니다.\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\n2023년의 문턱에 서 있을 때, Ionic, React Native 및 Flutter 간의 선택은 여전히 복잡합니다. 각 프레임워크는 독특한 장점을 제공하여 다양한 개발 요구 사항에 부합하는 자리를 확보했습니다. 크로스 플랫폼 모바일 프레임워크의 변화하는 풍경을 탐색하는 개발자로서, 최종 결정은 각 옵션의 강점과 우선순위를 조율하는 데 달려 있습니다.\n\n## 하이브리드 앱의 역량에 도전할 준비가 되셨나요?\n\n더 이상 찾지 마세요! 선두 Flutter 개발 회사와 함께하십시오. 저희 팀은 개념을 화려한 크로스 플랫폼 현실로 변신시키는데 특화되어 있습니다. 경험이 풍부한 Flutter 앱 개발자들로 구성된 저희 팀은 여러분의 비전을 현실로 구현하는 데 필요한 기술과 지식을 보유하고 있습니다.","ogImage":{"url":"/assets/img/2024-06-21-IonicvsReactNativevsFlutterWhatsBestfor2023_0.png"},"coverImage":"/assets/img/2024-06-21-IonicvsReactNativevsFlutterWhatsBestfor2023_0.png","tag":["Tech"],"readingTime":8},{"title":"Flutter에서 폼과 유효성 검사 실용 가이드","description":"","date":"2024-06-21 22:50","slug":"2024-06-21-FormsandValidationinFlutterAPracticalGuide","content":"\n\n모바일 폼은 스마트폰, 태블릿 등의 모바일 장치로 접근할 수 있는 전자 버전의 종이 양식입니다.\n\n현재의 대부분의 모바일 및 웹 애플리케이션은 양식을 어떤 형태로든 사용합니다. 주로 사용자가 앱과 소통하고 정보를 제공할 수 있는 방법으로 기능합니다. 비즈니스 요구 사항 및 논리의 성격에 따라 다양한 기능을 수행할 수 있습니다. 일반적으로 다음과 같은 일반적인 기능이 포함됩니다:\n\n1. 사용자 인증\n\n2. 사용자 추가\n\n<div class=\"content-ad\"></div>\n\n3. 검색\n\n4. 필터링\n\n5. 정렬\n\n6. 예약\n\n<div class=\"content-ad\"></div>\n\n양식에 포함될 수 있는 요소로는 다음과 같은 것들이 있을 수 있습니다:\n\n1. 텍스트 필드\n\n2. 버튼\n\n3. 체크박스\n\n<div class=\"content-ad\"></div>\n\n4. 라디오 버튼\n\n디지턈 양식의 장점은 다음과 같이 언급됩니다:\n\n1. 정보의 이동성이 크다.\n\n2. 기민성이 향상된다.\n\n<div class=\"content-ad\"></div>\n\n3. 높은 정밀도\n\n4. 더 뛰어난 응답 능력\n\n5. 더 빠른 콘텐츠 수정\n\n# 폼 관리의 중요성\n\n<div class=\"content-ad\"></div>\n\n양식 관리는 데이터 수집과 결정을 위해 양식을 생성, 보급, 완료, 평가하고 자동화하는 프로세스를 의미합니다.\n\n양식은 옛날에는 물리적인 물건이었지만, 많은 기업들이 종이 양식 대신 전자 문서를 사용하도록 전환했습니다. 자동화는 기존에 인간이 처리하던 작업을 기술을 사용하여 처리하는 것을 의미하며, 양식 관리도 그 예외가 아닙니다.\n\n# 양식\n\n종이 양식의 온라인 버전인 디지털 양식은 조직 내에서 빠르게 흘러가는 데이터를 캡처하는 데 사용됩니다. 기업이 데이터를 정확하게 기록하고 작업을 시작하는 주요 방법으로 종이 양식을 빠르게 대체하고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n디지턈 폼으로 전환함으로써 놀라운 많은 이점이 있습니다. 실시간 위치 공유, 이미지 촬영 및 추가, 신속한 계산 수행, 시간 추적 및 바코드 스캔 등 다양한 기능을 제공합니다.\n\n디지턈 폼을 사용하면 데이터의 구성이 간단합니다. 위치, 신원, 주소 또는 기타 중요 정보와 같은 데이터를 수집하고 구성할 수 있습니다. 모든 데이터가 한 곳에서 처리 및 저장되기 때문에 사용자는 언제든지 어디서든 데이터에 액세스할 수 있습니다.\n\n폼을 디지턈화함으로써 수집된 모든 정보를 신속하고 효과적으로 체계적으로 보관할 수 있습니다. 이러한 조정은 비즈니스가 시간과 비용을 절약하며 일상적인 작업 생산성과 효율성을 향상시킬 수 있도록 도와줄 것입니다.\n\n# Flutter forms\n\n<div class=\"content-ad\"></div>\n\n요즘에는 모바일 애플리케이션이나 웹 애플리케이션에서 양식이 필수적인 구성 요소입니다. 사용자 정보는 양식을 사용하여 수집됩니다. 플러터는 양식 위젯을 제공하여 양식을 개발할 수 있습니다. 이 양식 위젯의 컨테이너 기능을 사용하여 여러 양식 필드를 그룹화할 수 있습니다. 양식을 생성할 때 고유하게 식별할 수 있도록 GlobalKey가 필요하며 양식 필드를 유효성 검사할 수 있습니다.\n\n사용자가 텍스트를 입력할 수 있도록 하려면 양식 위젯이 자식 위젯인 TextFormField를 사용합니다. 이 위젯은 머티리얼 디자인의 텍스트 필드를 제공하며 발생하는 유효성 검사 문제를 보여줄 수 있습니다.\n\n사용자는 앱에서 자주 텍스트 필드에 데이터를 입력해야 합니다. 예를 들어, 이메일 주소와 비밀번호를 사용하여 사용자가 로그인해야 할 수도 있습니다. 애플리케이션을 안전하고 사용하기 쉽도록 만들기 위해 제공된 정보의 유효성을 확인하십시오. 사용자가 양식을 올바르게 작성했을 경우 데이터를 처리하십시오. 잘못된 정보를 제출할 경우 사용자에게 문제를 알리는 유용한 오류 메시지를 표시하십시오.\n\n# 양식 유효성 검사\n\n<div class=\"content-ad\"></div>\n\n특정 기준을 수정하거나 확인할 수 있는 기술을 검증이라고 합니다. 데이터 입력의 신뢰성을 보장합니다. 양식 유효성 검사는 모든 디지털 거래에서의 표준 절차입니다. Flutter에서 양식을 유효성 검사하는 데 필요한 세 가지 단계를 구현해야 합니다.\n\n1. Form 위젯과 함께 전역 키를 사용합니다.\n   \n2. TextFormField를 사용하여 입력 필드에 validator 속성을 제공합니다.\n   \n3. 양식 필드를 확인하고 오류를 표시할 버튼을 만듭니다.\n\n<div class=\"content-ad\"></div>\n\n# 양식 생성\n\n다음 단계를 따라 양식을 만들어보세요:\n\n## GlobalKey가 포함된 양식 만들기\n\n먼저 Form을 만들어보세요. Form 위젯을 사용하여 여러 양식 필드를 모아 유효성을 검사할 수 있습니다. 양식을 만들 때 GlobalKey를 지정해 주세요. 이를 통해 양식 유효성을 확인하고 양식을 고유하게 식별할 수 있게 됩니다.\n\n<div class=\"content-ad\"></div>\n\n# 유효성 검사 로직이 추가된 TextFormField를 추가해야 합니다\n\n양식은 있지만 사용자가 사용할 수 있는 텍스트 입력 필드가 없습니다. TextFormField의 역할은 이를 수행하는 것입니다. TextFormField 위젯은 텍스트 필드를 재료 디자인으로 표시하고 유효성 검사 문제를 표시할 수 있습니다. TextFormField에 입력을 확인하는 validator() 함수를 제공하세요. validator 메서드는 사용자의 입력이 잘못된 경우 오류 메시지가 포함된 문자열을 반환합니다. 오류가 없는 경우 validator는 null을 반환해야 합니다.\n\n# 양식을 유효성 검사하고 제출하기 위해 버튼 만들기\n\n양식에 텍스트 필드가 있는지 확인한 후 사용자가 정보를 제출할 수 있는 버튼을 제공하세요. 사용자가 제출하려고 할 때 양식의 유효성을 검사하세요. 유효한 경우 성공 메시지를 표시하세요. 텍스트 필드가 비어 있다면 오류 메시지를 표시하세요.\n\n<div class=\"content-ad\"></div>\n\n# 단일 필드 폼을 위한 코드\n\n단일 필드 플러터 폼을 만들려면 Flutter를 열고 새 프로젝트를 만든 다음 다음 코드를 사용하십시오 [2]:\n\n```js\nimport 'package:flutter/material.dart';\n\nvoid main() => runApp(const MyApp());\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    const appTitle = '테스트 폼';\n\n    return MaterialApp(\n      title: appTitle,\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text(appTitle),\n        ),\n        body: const MyCustomForm(),\n      ),\n    );\n  }\n}\n\n// 폼 위젯을 만듭니다.\nclass MyCustomForm extends StatefulWidget {\n  const MyCustomForm({super.key});\n\n  @override\n  MyCustomFormState createState() {\n    return MyCustomFormState();\n  }\n}\n\n// 해당 State 클래스를 만듭니다.\n// 이 클래스는 폼과 관련된 데이터를 보유합니다.\nclass MyCustomFormState extends State<MyCustomForm> {\n  // 폼 위젯을 고유하게 식별하는 전역 키를 만들어 폼의 유효성을 검사할 수 있게 합니다.\n  //\n  // 참고: 이것은 GlobalKey<FormState>이며\n  // GlobalKey<MyCustomFormState>가 아닙니다.\n  final _formKey = GlobalKey<FormState>();\n\n  @override\n  Widget build(BuildContext context) {\n    // 위에서 만든 _formKey를 사용하여 폼 위젯을 빌드합니다.\n    return Form(\n      key: _formKey,\n      child: Column(\n        crossAxisAlignment: CrossAxisAlignment.start,\n        children: [\n          TextFormField(\n            // validator는 사용자가 입력한 텍스트를 받습니다.\n            validator: (value) {\n              if (value == null || value.isEmpty) {\n                return '텍스트를 입력해주세요';\n              }\n              return null;\n            },\n          ),\n          Padding(\n            padding: const EdgeInsets.symmetric(vertical: 16),\n            child: ElevatedButton(\n              onPressed: () {\n                // 폼이 유효하면 true를 반환하고 그렇지 않으면 false를 반환합니다.\n                if (_formKey.currentState!.validate()) {\n                  // 폼이 유효하면 스낵바를 표시합니다. 실제로는\n                  // 서버를 호출하거나 정보를 데이터베이스에 저장하는 경우가 많습니다.\n                  ScaffoldMessenger.of(context).showSnackBar(\n                    const SnackBar(content: Text('데이터 처리 중')),\n                  );\n                }\n              },\n              child: const Text('제출'),\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n결과:\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-21-FormsandValidationinFlutterAPracticalGuide_0.png)\n\n# 설명\n\n스텝 1에서 생성된 _formKey를 활용하여 폼을 검증하세요. Form을 생성할 때 자동으로 생성되는 FormState에 접근하려면 _formKey.currentState() 메서드를 사용하세요. validate() 메서드는 FormState 클래스의 일부입니다. 폼의 각 텍스트 필드는 validate() 메서드가 호출될 때 validator() 함수를 가지며, 모두 정상인 경우 true를 반환합니다. validate() 함수는 어떠한 오류 경고도 표시하고, 텍스트 필드 중에 오류가 있는 경우 false를 반환합니다.\n\n[인터랙티브 예시2](링크)에서 코드를 작성하고 온라인에서 테스트할 수 있으며, 결과를 즉시 확인할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n# 비동기 유효성 검사\n\n폼에서 필드를 유효성 검사하려면 백엔드 서비스를 활용해 정보를 찾는 것이 종종 도움이 됩니다. 로그인 및 비밀번호를 데이터베이스에서 유효성을 검사하는 것이 전형적인 예입니다. 플러터의 비동기 폼 유효성 검사 기능은 사용자 인터페이스가 제대로 나오지 않을 수 있기 때문에 개발자가 동기식과 비동기식 유효성 검사기를 부적절하게 조합하거나 문제를 식별하기 어려울 수 있습니다. 따라서 플러터 팀은 비동기 유효성 검사 지원을 제공하지 않습니다. 그러나 이 문제에 대한 해결책이 있습니다[3]. 이 문제를 다음과 같은 세 가지 부분으로 나눌 수 있습니다:\n\n1. 먼저 비동기 호출 결과의 성공 또는 실패를 추적하는 로컬 부울을 생성하세요. 그런 다음, 이를 동기식 유효성 검사에 포함하여 실패 상태를 설명하는 비동기 유효성 검사 메시지(예: \"잘못된 사용자 이름\")를 생성합니다.\n\n2. 폼을 제출하고 동기식 유효성 검사를 통과한 후 백엔드로 비동기 호출을 하는 등의 비동기 호출을 수행하세요. 비동기 호출의 결과가 완료되면 로컬 부울을 해당 호출의 성공 또는 실패로 설정한 후 SetState()를 호출합니다. 그런 다음, 폼이 다시 그려집니다. 그러나 비동기 유효성 검사는 다시 시작되지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n3. build() 메서드를 호출하여 명시적으로 async validator를 다시 실행합니다. Form이 재생성되기 전에 async validator가 다시 실행됩니다. Async validator 결과 (있는 경우)는 Form이 재구성을 마치면 예상대로 Form에 표시됩니다.\n\n# 참고 자료:\n\n[1] https://www.javatpoint.com/flutter-forms\n\n[2] https://docs.flutter.dev/cookbook/forms/validation\n\n<div class=\"content-ad\"></div>\n\n[3]https://medium.com/@nocnoc/the-secret-to-async-validation-on-flutter-forms-4b273c667c03#:~:text=Once%20the%20sync%20validator%20passes,the%20correct%20user%2Fpass%20combination.","ogImage":{"url":"/assets/img/2024-06-21-FormsandValidationinFlutterAPracticalGuide_0.png"},"coverImage":"/assets/img/2024-06-21-FormsandValidationinFlutterAPracticalGuide_0.png","tag":["Tech"],"readingTime":7},{"title":"Flutter에서 간단한 BottomAppBar 만들기","description":"","date":"2024-06-21 22:49","slug":"2024-06-21-ASimpleBottomAppBarinFlutter","content":"\n현재 작업 중인 프로젝트에서 — 곧 공유할 예정이에요, BottomNavigationBar를 포함해야 했어요. 하지만 단순한 하단 네비게이션 바가 아니라, 약간은 멋지고 세련된 모습으로 구현하고 싶었어요.\n\n![BottomNavigationBar](/assets/img/2024-06-21-ASimpleBottomAppBarinFlutter_0.png)\n\nBottomNavigationBar는 하단에 작은 위젯들(아이콘 또는 레이블)을 나란히 표시할 수 있는 위젯이에요. 이를 통해 한 번에 하나의 항목을 선택하고 해당 페이지/UI로 빠르게 이동할 수 있어요. 하단 네비게이션 바에는 2~5개의 항목을 넣는 것이 권장되고요. 그 이상의 경우에는 네비게이션 드로어나 탭을 사용하는 것이 더 좋아요.\n\n구현\nFlutter에서 하단 네비게이션 바를 사용하려면 build 메서드가 Scaffold 위젯을 반환해야 해요.\n\n<div class=\"content-ad\"></div>\n\n```js\nclass _MyHomePageState extends State<MyHomePage> {\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Bottom Navigation Bar'),\n        centerTitle: true,\n      ),\n      body: const Center(),\n    );\n  }\n}\n```\n\nScaffold 위젯에는 bottomNavigationBar 속성이 있으며, 이를 통해 BottomAppBar 위젯을 추가할 수 있습니다. 나는 내 탐색 바에 '노치'를 추가하고 싶었기 때문에 BottomAppBar를 사용하고 있습니다 — 그래서 \"조금 멋지고 멋있어 보이게\"하고 있는 것이죠.\n\nBottomAppBar에는 다음과 같은 속성들을 사용하고 싶었어요:\n\n- shape — 탐색 바에 노치를 추가하여 겹치는 FAB(Floating Action Button)에 공간을 만듦\n- notchMargin — 탐색 바 노치와 FAB 사이의 여백\n- clipBehavior — 설정 옵션에 따라 내용이 클리핑되는지 여부를 지정합니다\n\n<div class=\"content-ad\"></div>\n\n```js\nbottomNavigationBar: BottomAppBar(\n  shape: const CircularNotchedRectangle(),\n  notchMargin: 5.0,\n  clipBehavior: Clip.antiAlias,\n  child: SizedBox(\n    height: kBottomNavigationBarHeight,\n    child: Row(\n      mainAxisSize: MainAxisSize.max,\n      mainAxisAlignment: MainAxisAlignment.spaceAround,\n      children: <Widget>[\n        IconButton(\n          icon: const Icon(Icons.home),\n          onPressed: () {\n            setState(() {\n            });\n          },\n        ),\n        IconButton(\n          icon: const Icon(Icons.search),\n          onPressed: () {\n            setState(() {\n            });\n          },\n        ),\n        IconButton(\n          icon: const Icon(Icons.favorite_border_outlined),\n          onPressed: () {\n            setState(() {\n            });\n          },\n        ),\n        IconButton(\n          icon: const Icon(Icons.account_circle_outlined),\n          onPressed: () {\n            setState(() {\n            });\n          },\n        )\n      ],\n    ),\n  ),\n),\n```\n\n![스크린샷](/assets/img/2024-06-21-ASimpleBottomAppBarinFlutter_1.png)\n\n이제 BottomAppBar 속성을 사용하기 위해 FAB를 추가할 때 centerDocked 속성을 사용해야 합니다.\n\n```js\nfloatingActionButtonLocation: FloatingActionButtonLocation.centerDocked,\nfloatingActionButton: FloatingActionButton(\n  onPressed: () {},\n  child: const Icon(Icons.add),\n),\n```\n\n<div class=\"content-ad\"></div>\n\n![BottomAppBar](/assets/img/2024-06-21-ASimpleBottomAppBarinFlutter_2.png)\n\n그래서 우리는 이제 '다른' ​​디자인의 하단 네비게이션 바를 얻을 수 있게 되었습니다.\n\n그러나 구현이 간단해 보이더라도, 실제로 작동하게 만드는 데 꽤 고생했습니다. 먼저 BottomAppBar에는 currentIndex 속성이 없어서 어떤 아이콘이 선택되었는지 알아야 페이지를 이동할 수 없습니다. 또한 selectedItemColor와 unselectedItemColor 속성도 없어서 해당 화면으로 이동될 때 아이콘 색상을 전환할 수 없습니다.\n\n그래서 BottomAppBar의 자식으로 BottomNavigationBar를 사용해야 합니다. 또한 페이지 간 전환을 허용하기 위해 pageController를 사용할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nbottomNavigationBar: BottomAppBar(\n  shape: const CircularNotchedRectangle(),\n  notchMargin: 5.0,\n  clipBehavior: Clip.antiAlias,\n  child: SizedBox(\n    height: kBottomNavigationBarHeight,\n    child: BottomNavigationBar(\n      type: BottomNavigationBarType.fixed,\n      backgroundColor: Colors.green,\n      currentIndex: _selectedIndex,\n      selectedItemColor: Colors.white,\n      unselectedItemColor: Colors.black,\n      onTap: (index) {\n        setState(() {\n          _selectedIndex = index;\n          pageController.jumpToPage(index);\n        });\n      },\n      items: const [\n        BottomNavigationBarItem(\n          icon: Icon(Icons.home_outlined),\n          label: '',\n        ),\n        BottomNavigationBarItem(\n          icon: Icon(Icons.search),\n          label: '',\n        ),\n        BottomNavigationBarItem(\n          icon: Icon(Icons.favorite_border_outlined),\n          label: '',\n        ),\n        BottomNavigationBarItem(\n          icon: Icon(Icons.account_circle_outlined),\n          label: '',\n        ),\n      ],\n    ),\n  ),\n),\nbody: PageView(\n  controller: pageController,\n  children: const <Widget>[\n    Center(\n      child: Home(),\n    ),\n    Center(\n      child: Search(),\n    ),\n    Center(\n      child: Favourite(),\n    ),\n    Center(\n      child: Profile(),\n    ),\n  ],\n),\n```\n\n![Here is the full code:](https://miro.medium.com/v2/resize:fit:1200/1*1LiVHOIR0xdH2Kzg3FdygQ.gif)\n\nLet me know how I can improve on this implementation (e.g., the spacing of the icons next to the notch could be better when there are four navigation items. It looks okay when it’s just two items.)\n\n<div class=\"content-ad\"></div>\n\n읽어 주셔서 감사합니다 ❤\n","ogImage":{"url":"/assets/img/2024-06-21-ASimpleBottomAppBarinFlutter_0.png"},"coverImage":"/assets/img/2024-06-21-ASimpleBottomAppBarinFlutter_0.png","tag":["Tech"],"readingTime":5},{"title":"Flutter 알림 마스터하기 awesome_notification 패키지 가이드 Part-I 단계별 가이드","description":"","date":"2024-06-21 22:46","slug":"2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide","content":"\n\n- Flutter 앱에서 원활하고 강력하며 사용자 친화적인 알림 경험을 위해 awesome_notification의 모든 기능을 활용해보세요.\n\n![이미지](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_0.png)\n\nFlutter에서 push 알림의 힘을 활용하는 것은 사용자 참여도와 유지율 향상에 중요합니다. 이러한 동적 알림은 사용자에게 실시간 업데이트 및 맞춤화된 상호작용을 제공하여 더 입체적이고 빠른 앱 경험을 조성합니다. 시각적으로 매력적이고 기능이 풍부한 알림을 만들 수 있는 awesome_notifications은 Flutter 개발자들이 사용자를 매혹시키고 앱이 계속해서 주목받을 수 있도록 돕습니다. 오늘날의 경쟁적인 모바일 환경에서 성공을 위한 키패드인 push 알림으로 앱의 커뮤니케이션 전략을 높여보세요.\n\n이 튜토리얼을 위한 프로젝트 구조를 시작해봅시다. 이 이미지에서 기본 구조를 확인할 수 있습니다: -\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_1.png)\n\n홈 페이지와 제품 상세 페이지 두 개의 페이지를 만들었습니다.\n\nFlutter에서 멋진 푸시 알림의 세계로 여정을 시작하기 위해, 우리의 Flutter 앱이 사용자에게 멋진과 동적인 알림을 만드는 데 필요한 도구를 갖추도록 보장하는 필수 종속성을 pubspec.yaml 파일에 추가하는 것으로 시작해봅시다.\n\npubspec.yaml 파일을 열고 다음 라인을 추가해주세요:\n\n<div class=\"content-ad\"></div>\n\n아래 이미지는 Flutter에 최신 버전의 awesome_notifications 및 http 패키지를 가져와 통합하라고 알려줍니다.\n\nawesome_notifications 패키지는 매력적이고 기능이 풍부한 알림을 만들기 위한 해결책으로 사용되고, http 패키지는 알림 워크플로에 필요한 모든 HTTP 요청을 용이하게 처리할 것입니다.\n\n터미널에서 flutter pub get을 실행하여 이러한 종속성을 가져오고 설치하는 것을 기억하세요.\n\n기본 작업이 완료되었으므로, 이제 awesome_notifications 패키지가 제공하는 끝없는 가능성을 탐험할 준비가 되었습니다. 즉각적인 알림, 예약된 경고 및 더 많은 기능을 만들어보자!\n\n<div class=\"content-ad\"></div>\n\n우리의 플러터 프로젝트의 핵심은 main.dart 파일에 있습니다. 이 파일은 우리 멋진 알림 시스템의 초기화를 조정하는 진입점입니다. 즐거운 알림 경험을 위한 무척 중요한 코드 조각을 살펴보겠습니다.\n\nmain.dart에는 클래스 구성 메서드를 호출하고 라우트 생성기 클래스를 생성하여 material 앱 섹션에 할당하는 내용이 담겨 있습니다.\n\nmain.dart\n\n![이미지](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_3.png)\n\n<div class=\"content-ad\"></div>\n\nRouteGenerator.dart\n\n이 클래스에 뷰 파일을 추가하고 네비게이션에 연결하세요.\n\n<img src=\"/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_4.png\" />\n\n애플리케이션 알림 유틸리티 클래스의 중요한 부분은 이 클래스에 있습니다. 사용자에게 멋진 알림을 제공하기 위해 몇 가지 속성과 메서드를 만들었으니 알림 유틸리티를 시작해보겠습니다.\n\n<div class=\"content-ad\"></div>\n\nnotification configuration 코드를 시작하기 전에, 이미지를 통해 멋진 notification 패키지에 의해 제공되는 매개변수를 확인할 수 있고, 이러한 매개변수를 사용하여 push notification을 탐색해보세요. 첫 번째 이미지에서는 단순한 notification만 볼 수 있고, 다른 이미지에서는 사용자 지정 버튼이 있는 notification을 볼 수 있습니다.\n\n\n![First Image](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_5.png)\n\n![Second Image](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_6.png)\n\n\nNotification_utils.dart\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_7.png)\n\n이제 사용자에게 알림 권한을 확인합니다. 이미 권한이 허용되어 있으면 네 개의 상자를 보여주는 홈 화면 UI가 표시됩니다. 권한이 허용되었는지 아닌지 확인하는 코드를 추가했습니다. 매우 간단한 내용이니 이 코드를 따라해보세요:-\n\n![이미지](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_8.png)\n\n코드와 주요 기능을 사용한 멋진 알림 패키지를 확인해봅시다.\n\n\n<div class=\"content-ad\"></div>\n\n🚨 주요 기능:\n\n1️⃣ 즉시 알림: 몇 줄의 코드로 손쉽게 즉시 알림을 생성하고 표시할 수 있어요! ⚡️\n\n2️⃣ 예약 알림: 특정 시간에 전달될 알림을 예약해서 미리 계획하세요. 📅⏰\n\n3️⃣ JSON 데이터 알림: JSON 데이터를 활용하여 동적으로 알림을 사용자 정의해보세요. 🧩📤\n\n<div class=\"content-ad\"></div>\n\n4️⃣ 사용자 정의 버튼 알림: 사용자 상호작용을 더욱 향상시키기 위해 알림 내에 사용자 정의 버튼을 통합하세요. 🎛️📲\n\n- . 즉시 알림: 몇 줄의 코드로 쉽게 즉시 알림을 생성하고 표시할 수 있습니다! ⚡️\n\n![Screenshot](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_9.png)\n\n2). 예약 알림: 알림을 특정 시간에 전달할 수 있도록 예약함으로써 미리 계획하세요. 📅⏰, 이 코드에서는 이 메소드를 호출한 후 1분 후에 알림이 도착하도록 예약 설정을 합니다. 이 기능을 이용하여 사용자에게 정기적으로 업데이트를 알리는 리마인더 또는 전자상거래 프로젝트나 피트니스 앱에서 일정 시간에 사용자에게 알리기 위해 사용할 수 있습니다. 예약된 알림을 다룰 때에는 안드로이드 manifest 파일에서 권한을 몇 가지 추가할 수 있습니다. 아래 이미지에서 해당 권한을 확인할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지 1](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_10.png)\n\n![이미지 2](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_11.png)\n\n3). JSON 데이터 통지: JSON 데이터를 활용하여 알림을 동적으로 사용자 정의하세요. 🧩📤 메서드 호출 시 jsonData를 전달할 수 있습니다. 자세한 내용은 홈페이지에서 확인해주세요. 그러면 메서드가 어떻게 작동하는지 쉽게 이해하고 확인할 수 있습니다.\n\n![이미지 3](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_12.png)\n\n\n<div class=\"content-ad\"></div>\n\n4). 사용자 상호작용을 더욱 향상시키기 위해 맞춤 버튼을 알림에 포함하여 사용하세요. 🎛️📲\n\n지금부터 제가 최고로 선호하는 주요 기능은 더 나은 사용자 경험을 위한 것입니다. 이 멋진 알림이 도착했을 때 맞춤 버튼을 추가하여 필요에 따라 더 많은 사용자 경험을 제공할 수 있습니다. 사용자의 이동 부분에 대해 알아보시죠. 한 예를 통해 이해해보겠습니다. 전자 상거래 프로젝트를 작업 중이라고 가정해보세요. 두 개의 버튼 중 하나는 \"지금 구매\"이고 다른 하나는 \"장바구니에 추가\"입니다. 이 경우 사용자가 \"지금 구매\" 버튼을 클릭하면 사용자가 체크 아웃 화면 또는 페이지로 이동할 것이고, \"장바구니에 추가\"를 클릭하면 제품이 장바구니에 추가되고 사용자는 장바구니 화면으로 이동하게 됩니다. 이것이 기본 설명입니다. 이제 코드로 돌아가 봅시다. 여기 createCustomNotificationWithActionButtons() 메서드명이 있습니다.\n\n![이미지](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_13.png)\n\n이제 거의 모든 코드 작업을 마쳤습니다. 성공적으로 알림이 생성되거나 화면에 도착한 후 알림을 탭하면 사용자로 이동하게 만들어야 합니다. 그래서 이 코드를 추가했습니다. 위 코드를 따라해 주세요.\n\n<div class=\"content-ad\"></div>\n\nonActionRecivedMethod은 사용자를 새 페이지로 리디렉션하거나 유효한 컨텍스트를 사용해야 할 때에만 필요합니다. 병렬 격리본은 유효한 컨텍스트를 갖고 있지 않기 때문에, 실행을 주 격리본으로 리디렉션해야 합니다.\n\n\n![Image](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_14.png)\n\n\nonActionRecivdeImplementationMethod은 사용자를 탐색할 때 실행될 것이므로, 이 방법을 사용하면 사용자에게 특정 페이지의 뷰나 화면을 정의할 수 있습니다. 또한, 사용자가 커스텀 버튼을 클릭하는 동안 사용자를 탐색할 수도 있으므로, 커스텀 버튼과 함께 알림을 생성할 때 키와 레이블을 전달하면 됩니다. 키를 사용하여 버튼을 클릭했을 때 페이지를 리디렉션할 조건이나 구성을 설정할 수 있으므로, 이 코드를 추가합니다. 아래 코드를 확인할 수 있습니다.\n\n\n![Image](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_15.png)\n\n\n<div class=\"content-ad\"></div>\n\n이제 우리는 onActionRecivedMethod, onNotificationCreatedMethod, onNotificationDisplayedMethod, onDismissActionReceivedMethod과 같은 멋진 알림 패키지에서 제공하는 이벤트를 수신하는 리스너를 설정했습니다. 이 메서드들을 사용하여 알림의 생성, 표시 및 해제를 감지할 수 있습니다. initState()에서 Homeview에서 startListeningNotificationEvents 메서드를 호출합니다.\n\n![image](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_16.png)\n\n이제 알림에 대한 논리 부분을 생성하고 추가했습니다. 이제 UI 부분으로 이동하여 사용자 인터페이스에서 화면을 만들겠습니다. 홈 화면과 제품 세부 정보 화면을 추가했습니다. 홈 페이지에는 아래와 같이 4개의 상자가 있는 GridView를 만듭니다.\n\n![image](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_17.png)\n\n<div class=\"content-ad\"></div>\n\nHome_view.dart에 대한 설명입니다.\n\nBuild 메소드 내에서 제목을 구현하고, notificationType에 알림 유형 서브 위젯을 추가합니다. GridView.extent를 사용하여 4가지 상자를 만들고 각각의 탭 기능에는 Gesture Detector 위젯을 사용하며, 탭할 때 해당하는 알림 클래스 메소드를 호출합니다.\n\n![이미지](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_18.png)\n\n첫 번째 상자에서 사용자가 즉시 통지를 탭하면 즉시 로컬 통지가 전송되며, 기기에 통지가 표시되고, 동시에 리디렉션도 수행됩니다.\n\n<div class=\"content-ad\"></div>\n\n첫 번째 상자는 인스턴트 알림 생성을 통해 사용자가 상자를 탭할 때 utils 클래스의 createInstantNotification 메서드가 호출되고 알림이 전송됩니다.\n\n두 번째 상자는 일정된 알림을 가지고 있습니다. 이는 스케줄 알림 기능을 사용하여 트리거된 알림을 설정하는 것을 의미합니다. 이러한 기능은 전자 상거래 앱, 피트니스 앱, 리마인더 앱 등 다양한 애플리케이션에서 주로 볼 수 있습니다.\n\n따라서 상자 안에서 사용자가 탭하면 notification_utils 클래스의 createScheduleNotification 메서드를 호출합니다. 이 코드에서는 탭한 후 1분 동안의 시간이 경과한 후에 알림이 표시되며, 필요에 맞게 사용자 정의할 수 있습니다.\n\n![이미지](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_19.png)\n\n<div class=\"content-ad\"></div>\n\n세 번째 상자에는 JSON 객체로 알림을 생성하고 API나 JSON 응답에 따라 사용자 정의하거나 동적으로 만들 수 있습니다. 이를 위해 호출 jsonDataNotification 메소드가 호출될 때 매개변수를 JSON 객체 형식으로 전달할 수 있습니다.\n\n![이미지](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_20.png)\n\n마지막으로 가장 좋아하는 기능 중 하나는 사용자 정의 버튼 알림입니다.\n\n네 번째 상자에서 상자를 탭하면 알림 클래스에서 createCustomNotificationWithActionButtons가 호출되고 이 메서드에서 actionButtons를 추가하여 사용자에게 표시합니다. actionButton에서 위젯 목록을 제공하고 버튼에 대한 키와 레이블을 잊지 마세요. 키를 사용하여 버튼KeyInput을 식별하고 동작을 수행하고 레이블은 단순 표시 용도입니다.\n\n<div class=\"content-ad\"></div>\n\n\n![2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_21](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_21.png)\n\n이 화면의 제품 상세 페이지 UI는 단지 제품 데이터와 수량, 제품 크기, 그리고 제품 가격을 보여줍니다.\n\n![2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_22](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_22.png)\n\n어서요, 기다리던 것이 끝났습니다. 리다이렉션을 통해 멋진 알림 패키지를 성공적으로 구현했습니다.\n\n\n<div class=\"content-ad\"></div>\n\n![image](https://miro.medium.com/v2/resize:fit:600/1*KBn0C6MmIzCdSEM_1xZrfQ.gif)\n\n플러터 개발의 복잡한 태피스트리 속에서 우리의 awesome_notifications 탐험은 혁신과 무한한 잠재력으로 가득한 여정이었습니다. 즉시 알림부터 예약된 통지 및 JSON 데이터의 동적 매력까지, 우리는 플러터 앱을 참여의 전도사로 변화시킬 수 있는 도구들을 발견했습니다.\n\n이 기사가 가이드 역할을 해 준 것으로서 부디 당신이 푸시 알림을 통해 몰입형 사용자 경험을 만들어가는 길을 밝혀 주었기를 바랍니다. 이 놀라운 논의를 마무리하면서 새롭게 얻은 지식이 얼마나 매료시키고 당신의 플러터 프로젝트가 디지털 환경에서 빛날 수 있는지 곰곰히 생각해 보시기 바랍니다.\n\nawesome_notifications 패키지 내부 동작을 더 깊이 파고들고 싶은 분들을 위해 GitHub의 포괄적인 코드베이스를 살펴보시기를 초대합니다:\n\n<div class=\"content-ad\"></div>\n\nGitHub 저장소\n\n저와 함께하시면 플러터 개발 세계에서 계속되는 토론, 통찰, 그리고 미래 탐구를 경험할 수 있습니다:\n\nLinkedIn 프로필\n\n이 여정에 투자해 주신 여러분께 감사드립니다. 여러분의 플러터 노력이 혁신적이고 원활한 기능성을 갖추며, 사용자들로부터 진정으로 중요한 알림을 받을 수 있기를 바라겠습니다.\n\n<div class=\"content-ad\"></div>\n\n플러터 우수성을 위한 이 여정에 참여해 주셔서 감사합니다. 다음 탐험 때까지 즐거운 코딩하세요! 알림이 항상 멋지고 효과적하기를 바라요! 🚀📲","ogImage":{"url":"/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_0.png"},"coverImage":"/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_0.png","tag":["Tech"],"readingTime":10},{"title":"Dio 패키지를 사용하여 Flutter에서 REST API에 이미지 업로드하는 방법","description":"","date":"2024-06-21 22:44","slug":"2024-06-21-UploadimagestoRESTAPIwithFlutterusingDioPackage","content":"\n플러터 개발자들로부터 받은 엄청난 반응 뒤에 http 패키지를 사용하여 REST API에 이미지를 업로드하는 방법에 대한 이야기를 공유한 후, 많은 사람들이 dio 패키지를 사용하여 그렇게 하는 데 어려움을 겪는 것을 보았습니다. 초보자들은 일반적으로 사용할 수 있는 코드 스니펫을 찾을 수 있는 자세하고 쉽게 배울 수 있는 자료를 원합니다.  \n이 이야기에서는 flutter에서 이미지를 업로드하는 방법에 대해 dio 패키지를 사용하여 작성하겠습니다. 가능한 모든 측면에 대해 설명하기 위해 최선을 다하겠지만, 빠진 부분이 있다고 생각하거나 의겢가 있으면 의겢를 남겨주시고 학습 과정에서 도와주십시오.\n\n우선 dio 패키지를 앱에 추가하는 방법부터 시작해봅시다.\n\nDio는 다트를위한 강력한 HTTP 클라이언트로서 내 flutter 앱에서 서버에 연결하는 동안 응답의 직렬화 및 역직렬화와 같은 여러 측면에서 도움이 됩니다.\n\n프로젝트 디렉토리 터미널에서 다음 명령을 실행합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n $ dart pub add dio\n```\n\n기기 갤러리나 카메라에서 이미지를 가져 오기 위해 Image Picker 패키지를 사용했어요.\n\n프로젝트 디렉토리 터미널에서 다음 명령어를 실행해주세요:\n\n```js\n$ flutter pub add image_picker\n```\n\n<div class=\"content-ad\"></div>\n\n여기 갤러리에서 이미지를 가져 오는 코드입니다.\n\n```js\nFuture<File> getImage() async {\n  final ImagePicker _picker = ImagePicker();\n  // 이미지 선택\n  final XFile? image = await _picker.pickImage(source: ImageSource.gallery);\n  // XFile을 파일로 변환\n  File file = File(image!.path);\n  // print(‘이미지 선택됨');\n  return file;\n}\n```\n\n이제 갤러리에서 이미지를 선택했습니다. 다음은 MultipartRequest를 수행 할 dart 파일에서 dio 패키지를 가져 오는 방법입니다.\n\n```js\nimport \"package:dio/dio.dart\";\n```\n\n<div class=\"content-ad\"></div>\n\n그럼 REST API에 전송할 이미지를 포함하는 fromMap이라는 이름의 이름이 지정된 생성자를 사용하여 FormData 객체를 만들어보겠습니다.\n\n```js\nvar formData = FormData.fromMap({\n        'file': await MultipartFile.fromFile(empFace.path, filename: empCode),\n      });\n```\n\n여기서 'file' 키를 사용하여 파일을 Map에 포함했습니다. 이는 서버로 보낼 FormData 객체를 반환하며, 우리는 이 객체를 사용하여 서버로 전송할 것입니다. 카메라 이미지의 파일을 사용하여 MultipartFile을 생성하고, 이를 인터넷을 통해 전송할 수 있습니다.\n\n마지막으로 dio를 사용하여 REST API에 요청을 보내보세요:\n\n<div class=\"content-ad\"></div>\n\n```js\n최종 응답 = await Dio().post(\n        '당신의 API URL',\n        data: formData,\n      );\n```\n\n우리는 formData를 post 메소드에 전달했고, 자동으로 contentType을 처리해줄 것입니다. 일반적으로 서버로 이미지를 보낼 때 form-data 헤더를 사용합니다.:\n\n```js\nheaders: {\n    'Content-Type': 'multipart/form-data'\n  },\n```\n\ndio를 사용하면 헤더에서 content-type을 명시적으로 지정할 필요가 없습니다.\n\n<div class=\"content-ad\"></div>\n\n여기에서 시나리오와 사용 사례를 더 잘 이해하기 위한 완전한 코드입니다:\n\n```js\nFuture<bool> registerEmployeeFace(\n      {required File empFace, required String empCode}) async {\n    final url =\n        '내 API URL';\n    try {\n      var formData = FormData.fromMap({\n        'file': await MultipartFile.fromFile(empFace.path, filename: empCode),\n      });\n      final response = await Dio().post(\n        url,\n        data: formData,\n      );\n      if (response.statusCode == 200) {\n        var map = response.data as Map;\n        print('success');\n        if (map['status'] == 'Successfully registered') {\n          return true;\n        } else {\n          return false;\n        }\n      } else {\n        // BotToast는 pub.dev에서 사용 가능한 토스트 패키지입니다.\n        BotToast.showText(text: '에러');\n        return false;\n      }\n    } on DioError catch (error) {\n      log(error.message);\n      throw YourException(error);\n    } catch (_) {\n      log(_.toString());\n      throw '문제가 발생했습니다';\n    }\n  }\n```\n\n초보자들도 이 요청을 쉽게 수행하고 복잡한 API를 빠르게 통합할 수 있기를 바랍니다. 더 많은 Github를 위해\n\n<div class=\"content-ad\"></div>\n\n만약 도움이 되었다면 좋아요 버튼을 눌러주시고 친구들과 공유해주세요.\n","ogImage":{"url":"/assets/img/2024-06-21-UploadimagestoRESTAPIwithFlutterusingDioPackage_0.png"},"coverImage":"/assets/img/2024-06-21-UploadimagestoRESTAPIwithFlutterusingDioPackage_0.png","tag":["Tech"],"readingTime":4}],"page":"11","totalPageCount":28,"totalPageGroupCount":2,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}