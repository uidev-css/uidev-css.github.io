{"pageProps":{"posts":[{"title":"Flutter 프로젝트 05 광학 문자 인식OCR 앱 만들기","description":"","date":"2024-06-21 21:19","slug":"2024-06-21-FlutterProjects05BuildinganOpticalCharacterRecognitionOCRApp","content":"\n\n<img src=\"/assets/img/2024-06-21-FlutterProjects05BuildinganOpticalCharacterRecognitionOCRApp_0.png\" />\n\n이 튜토리얼에서는 Flutter를 사용하여 광학 문자 인식 (OCR) 애플리케이션을 만드는 단계를 안내합니다. google_mlkit_text_recognition 패키지를 사용하여 이미지에서 텍스트를 추출할 것입니다. 이 안내서는 초보자에게 이상적이며 코드의 각 부분을 자세히 설명할 것입니다.\n\n이 글은 플러터로 첫 번째 애플리케이션을 만드는 초보 개발자들을 돕기 위해 다양한 프로젝트를 만드는 일련의 기사 중 일부입니다. 따라서 UI 조립, 프로그래밍 로직, 그리고 좋은 프로그래밍 관행을 연습할 수 있습니다. 이전 기사를 놓친 경우 이를 확인할 수 있습니다.\n\n- 초보자를 위한 플러터 프로젝트 #01: BMI 계산기 구축\n- 초보자를 위한 플러터 프로젝트 #02: 할 일 목록 구축\n- 초보자를 위한 플러터 프로젝트 #03: 다크 모드 및 라이트 모드 전환\n- 초보자를 위한 플러터 프로젝트 #04: 채팅 GPT 앱 구축\n\n<div class=\"content-ad\"></div>\n\n![image](https://miro.medium.com/v2/resize:fit:960/1*MHgy2Jl-x4X3NG0UYAL9qQ.gif)\n\n# 플러터 프로젝트 시작하기\n\n먼저 할 일은 플러터 프로젝트를 설정하는 것입니다. 이미 플러터가 설치되어 있는지 확인하세요. 그렇지 않다면, https://flutter.dev/docs/get-started/install 에서 설치 지침을 따를 수 있습니다.\n\n다음으로, 터미널에서 다음 명령을 사용하여 새 플러터 프로젝트를 생성하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nflutter create flutter_ocr\n```\n\n프로젝트 디렉토리로 이동하고 다음 명령어로 VSCode에서 프로젝트를 엽니다:\n\n```js\ncd flutter_ocr && code .\n```\n\n# 초기 설정\n\n\n<div class=\"content-ad\"></div>\n\n자, 이제 실제 코드 작성을 시작해봅시다. 먼저 main.dart 파일에서 몇 가지 작은 변경사항을 시작해보겠습니다.\n\n자동으로 생성된 주석을 삭제하고 MyHomePage 클래스도 제거해주세요(우리만의 사용자 정의 위젯을 만들 예정이에요). 그리고 MyApp 위젯의 내용을 잘라서 my_app.dart 라는 파일에 추가해주세요. 그런 다음, 이 새 파일을 main.dart에서 내보내세요.\n\n당신의 main.dart 파일은 다음과 같은 모습이어야 합니다:\n\n```js\nimport 'package:flutter/material.dart';\nimport 'package:flutter_ocr/src/my_app.dart';\n\nvoid main() => runApp(const MyApp());\n```\n\n<div class=\"content-ad\"></div>\n\n그리고 당신의 my_app.dart 파일은 다음과 같이 보여야 합니다:\n\n```js\nimport 'package:flutter/material.dart';\nimport 'package:flutter_ocr/src/pages/home_page.dart';\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Flutter OCR',\n      debugShowCheckedModeBanner: false,\n      theme: ThemeData(\n        colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple),\n        useMaterial3: true,\n      ),\n      home: const HomePage(),\n    );\n  }\n}\n```\n\n# HomePage Widget 생성하기\n\n프로젝트를 더 잘 구성하기 위해, 'lib' 폴더 안에 'pages'라는 폴더를 생성한 다음 그 안에 'home_page.dart'라는 새 파일을 만드세요.\n\n<div class=\"content-ad\"></div>\n\n이 새 파일 안에 build 메서드에서 Scaffold를 가지는 새 StatefulWidget을 생성해 보세요. 예시 코드는 다음과 같을 것입니다:\n\n```js\nimport 'package:flutter/material.dart';\n\nclass HomePage extends StatefulWidget {\n  const HomePage({super.key});\n\n  @override\n  State<HomePage> createState() => _HomePageState();\n}\n\nclass _HomePageState extends State<HomePage> {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Flutter OCR')),\n      body: const Column(\n        children: [],\n      ),\n    );\n  }\n}\n```\n\n# 패키지의 설치 및 구성\n\nOCR 앱을 시작하기 위해 Flutter 프로젝트에 필요한 종속 항목을 추가하는 단계를 따라보세요.\n\n<div class=\"content-ad\"></div>\n\n이 프로젝트에서는 세 가지 패키지를 사용할 거에요:\n\n- image_picker: 갤러리나 카메라에서 이미지를 선택하는 데 사용돼요.\n- image_cropper: 선택한 이미지를 자르는 데 사용돼요.\n- google_mlkit_text_recognition: 이미지에서 텍스트 인식을 수행하는 데 사용돼요.\n\n## 종속성 추가하기\n\npubspec.yaml 파일을 열고 다음 종속성을 추가해주세요:\n\n<div class=\"content-ad\"></div>\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n\n  cupertino_icons: ^1.0.6 \n  image_picker: ^1.1.2\n  image_cropper: ^7.0.5\n  google_mlkit_text_recognition: ^0.13.0\n```\n\n의존성을 추가한 후 아래 명령을 실행하여 설치하십시오:\n\n```bash\nflutter pub get\n```\n\nAndroid에서 image_cropper 패키지가 올바르게 작동하려면 추가 구성이 필요합니다. AndroidManifest.xml 파일을 열어 `manifest` 태그 안에 다음 코드를 추가하십시오:\n\n\n<div class=\"content-ad\"></div>\n\n```js\n<activity\n    android:name=\"com.yalantis.ucrop.UCropActivity\"\n    android:screenOrientation=\"portrait\"\n    android:theme=\"@style/Theme.AppCompat.Light.NoActionBar\"/>\n```\n\n이제 여러분의 프로젝트에서 필요한 모든 패키지를 사용할 수 있는 준비가 되었습니다.\n\n# 홈페이지 UI 만들기\n\n먼저, widgets라는 새 폴더를 만들고 이 폴더 안에 picker_option_widget.dart라는 파일을 생성하십시오. 이러면 다음과 같이 보일 것입니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport 'package:flutter/material.dart';\n\nclass PickerOptionWidget extends StatelessWidget {\n  const PickerOptionWidget({\n    super.key,\n    required this.color,\n    required this.label,\n    required this.icon,\n    this.onTap,\n  });\n\n  final Color color;\n\n  final String label;\n\n  final IconData icon;\n\n  final void Function()? onTap;\n\n  @override\n  Widget build(BuildContext context) {\n    return Expanded(\n      child: InkWell(\n        onTap: onTap,\n        child: Container(\n          padding: const EdgeInsets.all(20.0),\n          decoration: BoxDecoration(\n            color: color.withOpacity(0.3),\n            borderRadius: BorderRadius.circular(10),\n          ),\n          child: Column(\n            crossAxisAlignment: CrossAxisAlignment.center,\n            children: [\n              Icon(\n                icon,\n                size: 38.0,\n                color: color,\n              ),\n              const SizedBox(height: 10.0),\n              Text(\n                label,\n                style: const TextStyle(\n                  fontSize: 20.0,\n                ),\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n```\n\n이 위젯을 사용하여 코드를 더 정리하고 반복을 피할 거예요. 이 버튼은 기기 갤러리나 카메라를 열기 위해 사용될 거에요.\n\n## 그러면 이제 HomePage의 구조를 설정할 수 있어요.\n\nHomePage에서 String 타입의 _extractedText라는 변수를 만들어주세요. 이 변수는 이미지로부터 추출된 텍스트를 저장할 거에요.\n\n<div class=\"content-ad\"></div>\n\n```js\n/// 이미지에서 추출된 텍스트를 저장할 변수\nString _extractedText = '';\n```\n\n이제 이전에 만든 위젯을 사용하여 Scaffold를 구성할 수 있습니다. 다음과 같이 보여야 합니다:\n\n```js\n@override\nWidget build(BuildContext context) {\n  return Scaffold(\n    appBar: AppBar(title: const Text('Flutter OCR')),\n    body: Column(\n      children: [\n        const Text(\n          '옵션을 선택하세요',\n          style: TextStyle(fontSize: 22.0),\n        ),\n        const SizedBox(height: 10.0),\n        Padding(\n          padding: const EdgeInsets.symmetric(\n            vertical: 10.0,\n            horizontal: 20.0,\n          ),\n          child: Row(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: [\n              PickerOptionWidget(\n                label: '갤러리에서',\n                color: Colors.blueAccent,\n                icon: Icons.image_outlined,\n                onTap: () {\n                  /// 갤러리에서 이미지 가져오는 코드\n                },\n              ),\n              const SizedBox(width: 10.0),\n              PickerOptionWidget(\n                label: '카메라에서',\n                color: Colors.redAccent,\n                icon: Icons.camera_alt_outlined,\n                onTap: () {\n                  /// 카메라에서 이미지 가져오는 코드\n                },\n              ),\n            ],\n          ),\n        ),\n        if (_extractedText.isNotEmpty) ...{\n          Padding(\n            padding: const EdgeInsets.symmetric(\n              vertical: 15.0,\n              horizontal: 10.0,\n            ),\n            child: Row(\n              mainAxisAlignment: MainAxisAlignment.spaceBetween,\n              children: [\n                const Text(\n                  '이전에 읽은 내용',\n                  style: TextStyle(fontSize: 22.0),\n                ),\n                IconButton(\n                  onPressed: () {\n                    /// 텍스트를 클립 보드에 복사하는 코드\n                  },\n                  icon: const Icon(Icons.copy),\n                )\n              ],\n            ),\n          ),\n          Expanded(\n            child: Container(\n              padding: const EdgeInsets.symmetric(horizontal: 15.0),\n              width: double.infinity,\n              decoration: BoxDecoration(\n                color: Colors.grey.shade100,\n              ),\n              child: SingleChildScrollView(\n                child: Padding(\n                  padding: const EdgeInsets.only(\n                    top: 10.0,\n                    bottom: 20.0,\n                  ),\n                  child: Text(_extractedText),\n                ),\n              ),\n            ),\n          )\n        },\n      ],\n    ),\n  );\n}\n```\n\n## 이 코드에 대한 몇 가지 설명:\n\n\n<div class=\"content-ad\"></div>\n\n- 사용자 정의 위젯 PickerOptionWidget은 두 번 사용되며 각각 버튼과 같은 UI 요소를 나타냅니다. 갤러리에서 이미지를 선택하는 경우(갤러리에서)와 카메라로 이미지를 촬영하는 경우(카메라에서).\r\n- 두 위젯은 서로 다른 스타일(색상 및 아이콘)을 가지며 사용자 상호 작용을 처리하는 onTap 콜백이 정의되어 있습니다(구현 예정).\r\n- _extractedText가 비어 있지 않은지 확인합니다(_extractedText.isNotEmpty). 만약 true이면 다음과 같이 렌더링됩니다:\r\n- \"이전에 읽은 내용\"이라는 텍스트와 복사 아이콘(Icons.copy)을 가진 IconButton이 있는 행(Row). 클립보드로 텍스트를 복사하는 onPressed 콜백이 정의되어 있습니다(구현 예정).\r\n- 스타일이 적용된 Container를 포함하는 Expanded 위젯.\r\n- 컨테이너 안에는 _extractedText를 표시하는 Text 위젯이 포함된 SingleChildScrollView가 있습니다.\n\n이제 우리는 기본 구조를 만들었고 다음에 생성할 메소드를 받아들일 준비가 되었습니다.\n\n# 필요한 메소드 생성\n\n이제 이미지 선택, 선택한 이미지 자르기 및 텍스트 추출을 담당할 함수를 만들어 봅시다.\n\n<div class=\"content-ad\"></div>\n\n각 부분을 각각의 메소드로 분리하여 조직화하고 이해하기 쉽도록 유지할 것입니다.\n\n먼저 사용할 패키지를 가져오겠습니다:\n\n```js\nimport 'dart:io';\n...\nimport 'package:image_picker/image_picker.dart';\nimport 'package:image_cropper/image_cropper.dart';\nimport 'package:google_mlkit_text_recognition/google_mlkit_text_recognition.dart';\n```\n\n## 이미지 선택기\n\n<div class=\"content-ad\"></div>\n\n먼저, 장치에서 이미지를 선택할 수 있도록 하는 메소드를 만들어봅시다.\n\n```js\nFuture<File?> _pickerImage({required ImageSource source}) async {\n  final ImagePicker picker = ImagePicker();\n  final XFile? image = await picker.pickImage(source: source);\n  if (image != null) {\n    return File(image.path);\n  }\n  return null;\n}\n```\n\n설명:\n\n- final ImagePicker picker = ImagePicker();: ImagePicker 클래스의 인스턴스를 생성하여 장치의 이미지 선택기 기능에 액세스합니다.\n- final XFile? image = await picker.pickImage(source: source);: 이 줄은 ImagePicker 인스턴스의 pickImage 메소드를 사용하여 장치의 이미지 선택기 인터페이스를 엽니다. 사용자가 이미지를 선택할 때까지 기다립니다. source 매개변수는 갤러리 또는 카메라를 여는지를 지정합니다. 결과는 XFile? 유형의 변수 image에 저장됩니다.\n- if (image != null) ': 사용자가 실제로 이미지를 선택했는지 확인합니다. 이미지가 null이 아닌 경우 이미지가 선택된 것을 의미합니다.\n- return File(image.path);: 이미지가 선택된 경우, 이 줄은 이미지의 파일 경로를 사용하여 XFile을 File로 변환하고 반환합니다.\n\n<div class=\"content-ad\"></div>\n\n## 이미지 크롭\n\n이제 선택한 이미지를 자르는 기능을 만들어 보겠습니다. 특정 영역에서 텍스트만을 추출하고 싶은 큰 이미지가 있는 경우 매우 유용합니다.\n\n```js\nFuture<CroppedFile?> _cropImage({required File imageFile}) async {\n  CroppedFile? croppedfile = await ImageCropper().cropImage(\n    sourcePath: imageFile.path,\n    uiSettings: [\n      AndroidUiSettings(\n        aspectRatioPresets: [\n          CropAspectRatioPreset.square,\n          CropAspectRatioPreset.ratio3x2,\n          CropAspectRatioPreset.original,\n          CropAspectRatioPreset.ratio4x3,\n          CropAspectRatioPreset.ratio16x9\n        ],\n      ),\n      IOSUiSettings(\n        minimumAspectRatio: 1.0,\n      ),\n    ],\n  );\n\n  if (croppedfile != null) {\n    return croppedfile;\n  }\n\n  return null;\n}\n```\n\n- ImageCropper().cropImage(: ImageCropper의 인스턴스를 생성하고 즉시 cropImage 메서드를 호출합니다.\n- sourcePath: imageFile.path,: 자르려는 imageFile의 경로를 sourcePath 매개변수로 지정합니다.\n- AndroidUiSettings 및 IOSUiSettings: 각각 Android 및 iOS 플랫폼에서 자르기에 대한 UI 설정을 정의합니다.\n- aspectRatioPresets: Android에서 사용 가능한 자르기용 가로세로 비율을 지정합니다. 예시로는 square, 3:2, original, 4:3, 16:9 등이 있습니다.\n- minimumAspectRatio: iOS에서 자르기에 허용되는 최소 가로세로 비율을 정의합니다. 여기서는 1.0으로 설정했습니다.\n- await ImageCropper().cropImage(...): 제공된 설정을 기반으로 자르기 작업을 비동기적으로 시작하고 사용자가 자르기 작업을 수행할 때까지 대기합니다.\n- croppedfile이 null이 아닌 경우(즉, 사용자가 이미지를 성공적으로 자르는 경우), 해당 croppedfile을 반환합니다.\n\n<div class=\"content-ad\"></div>\n\n## Google의 ML Kit 텍스트 인식\n\n이제 이미지에서 텍스트 인식을 수행하는 책임을 가지는 메소드를 작성해봅시다.\n\n```js\nFuture<String> _recognizeTextFromImage({required String imgPath}) async {\n  final textRecognizer = TextRecognizer(script: TextRecognitionScript.latin);\n\n  final image = InputImage.fromFile(File(imgPath));\n  final recognized = await textRecognizer.processImage(image);\n\n  return recognized.text;\n}\n```\n\n- final textRecognizer = TextRecognizer(script: TextRecognitionScript.latin);: TextRecognitionScript.latin 스크립트를 사용하여 TextRecognizer 인스턴스를 생성합니다. TextRecognitionScript는 텍스트 인식에 사용할 언어 스크립트를 지정합니다.\n- final image = InputImage.fromFile(File(imgPath));: imgPath에서 지정된 파일에서 InputImage 객체를 생성합니다. File 클래스는 장치에서 파일에 액세스하고 조작하는 데 사용됩니다.\n- final recognized = await textRecognizer.processImage(image);: textRecognizer의 processImage 메소드를 호출하여 이미지에서 텍스트 인식 작업을 수행합니다. 이 작업은 비동기적으로 실행되므로 (await을 사용함) 텍스트 인식이 완료될 때까지 메소드가 기다릴 수 있습니다.\n- return recognized.text;: 이미지에서 추출된 인식된 텍스트를 반환합니다. recognized 객체에는 텍스트 인식 프로세스의 결과인 추출된 텍스트가 포함되어 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 클립 보드에 복사\n\n프로세스 결과를 클립 보드에 복사할 수 있는 메소드를 만들어 보겠습니다.\n\n```js\nvoid _copyToClipBoard() {\n  Clipboard.setData(ClipboardData(text: _extractedText));\n\n  ScaffoldMessenger.of(context).showSnackBar(\n    const SnackBar(\n      content: Text('클립 보드에 복사되었습니다'),\n    ),\n  );\n}\n```\n\n## 이미지 처리\n\n<div class=\"content-ad\"></div>\n\n모든 과정을 한 메서드로 결합하는 함수를 만들어 봅시다.\n\n```js\nFuture<void> _processImageExtractText({\n  required ImageSource imageSource,\n}) async {\n  final imageFile = await _pickerImage(source: imageSource);\n\n  if (imageFile == null) return;\n\n  final croppedImage = await _cropImage(\n    imageFile: imageFile,\n  );\n\n  if (croppedImage == null) return;\n\n  final recognizedText = await _recognizeTextFromImage(\n    imgPath: croppedImage.path,\n  );\n\n  setState(() => _extractedText = recognizedText);\n}\n```\n\n- `final imageFile = await _pickerImage(source: imageSource);`: `_pickerImage` 메서드를 호출하여 지정된 `imageSource`에서 이미지를 선택합니다. 선택 과정이 완료될 때까지 기다렸다가 결과를 `imageFile`에 할당합니다.\n- `final croppedImage = await _cropImage(imageFile: imageFile);`: 선택된 `imageFile`을 자르기 위해 `_cropImage` 메서드를 호출합니다. 자르기 과정이 완료될 때까지 기다렸다가 잘린 이미지(`CroppedFile`)를 `croppedImage`에 할당합니다.\n- `final recognizedText = await _recognizeTextFromImage(imgPath: croppedImage.path);`: 자른 이미지의 경로(`croppedImage.path`)에 대해 텍스트 인식을 수행하기 위해 `_recognizeTextFromImage` 메서드를 호출합니다. 인식 과정이 완료될 때까지 기다렸다가 인식된 텍스트(`String`)를 `recognizedText`에 할당합니다.\n- `setState(() => _extractedText = recognizedText);`: `_extractedText` 상태 변수를 `recognizedText`로 업데이트합니다. 이는 UI를 다시 빌드하여 추출된 텍스트를 표시하는 역할을 합니다.\n\n# 모든 것을 자리에 놓기\n\n<div class=\"content-ad\"></div>\n\n우리가 메소드를 생성하고 인터페이스를 설정해 놨으니, 이제 각 구현을 올바른 위치에 추가하기만 하면 됩니다.\n\n먼저, 사용자가 이미지를 선택할 옵션을 고르는 위젯에서 이미지를 처리하는 함수를 호출할 것입니다. 이미 필요한 모든 것이 구현된 함수이므로 onTap 이벤트에 이를 추가하고 소스를 지정해주기만 하면 됩니다.\n\n```js\n...\nchild: Row(\n  mainAxisAlignment: MainAxisAlignment.center,\n  children: [\n    PickerOptionWidget(\n      label: '갤러리에서 선택',\n      color: Colors.blueAccent,\n      icon: Icons.image_outlined,\n      onTap: () => _processImageExtractText(\n        imageSource: ImageSource.gallery,\n      ),\n    ),\n    const SizedBox(width: 10.0),\n    PickerOptionWidget(\n      label: '카메라로 촬영',\n      color: Colors.redAccent,\n      icon: Icons.camera_alt_outlined,\n      onTap: () => _processImageExtractText(\n        imageSource: ImageSource.camera,\n      ),\n    ),\n  ],\n),\n...\n```\n\n마지막으로, 결과를 클립보드 영역에 복사하는 함수를 추가하면 됩니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n...\nchild: Row(\n  mainAxisAlignment: MainAxisAlignment.spaceBetween,\n  children: [\n    const Text(\n      '이전에 읽은 항목',\n      style: TextStyle(fontSize: 22.0),\n    ),\n    IconButton(\n      onPressed: _copyToClipBoard,\n      icon: const Icon(Icons.copy),\n    )\n  ],\n),\n...\n```\n\n이제 모든 준비가 완료되었어요.\n\n# 최종 결과물\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1200/1*FY0xUZ88uI-MJlc-dkbdCw.gif\" />\n\n<div class=\"content-ad\"></div>\n\n이 튜토리얼에서는 이미지에서 광학 문자 인식(OCR)을 수행하는 Flutter 애플리케이션을 생성했습니다. Flutter 환경을 설정하고, 갤러리 또는 카메라에서 이미지를 선택할 수 있는 옵션을 포함한 사용자 인터페이스를 디자인했습니다. Google ML Kit을 사용하여 이미지 자르기와 텍스트 추출을 포함한 이미지 처리 방법을 구현했으며 추출된 텍스트를 클립보드에 복사하는 기능을 통합했습니다. 이 과정에서 중요한 Flutter 패키지를 통합하는 방법, 이미지 처리를 위한 비동기 작업 관리, 동적 UI 업데이트를 통해 사용자 상호작용을 향상하는 방법 등을 배웠습니다. 이 튜토리얼은 이미지 처리 및 OCR을 위해 Flutter의 기능을 최대한 활용하는 실용적인 통찰을 제공하여 개발자들이 자신의 애플리케이션에 비슷한 기능을 효과적으로 구현할 수 있는 기술을 갖추도록 도와줍니다.\n\n![Animation](https://miro.medium.com/v2/resize:fit:536/1*mVI3BmDdc3duwtvixvNU9A.gif)\n\n프로젝트의 완전한 소스 코드는 이 글의 맨 끝에서 찾을 수 있습니다.\n\n이 내용이 마음에 드셨다면, 박수를 보내주시고 제 포스트를 업데이트 받고 싶다면 팔로우해주세요! 👏👏👏\n\n<div class=\"content-ad\"></div>\n\n힘이 함께하기를 바랍니다. 🤓","ogImage":{"url":"/assets/img/2024-06-21-FlutterProjects05BuildinganOpticalCharacterRecognitionOCRApp_0.png"},"coverImage":"/assets/img/2024-06-21-FlutterProjects05BuildinganOpticalCharacterRecognitionOCRApp_0.png","tag":["Tech"],"readingTime":16},{"title":"Flutter에서 Bloc과 get_it 패키지를 사용하여 클린 아키텍처 구현하는 방법","description":"","date":"2024-06-21 21:16","slug":"2024-06-21-HowtoimplementcleanarchitecturewithBlocandget_itpackageinFlutter","content":"\n\n이 기사에서는 get_it 패키지를 서비스 로케이터로, Bloc를 상태 관리로 사용하여 클린 아키텍처를 구현하는 방법을 가르쳐 드리겠습니다. 이를 통해 책임을 분리하고, 앱이 점점 커지고 복잡해짐에 따라 새로운 기능을 더 잘 유지하고 코드를 이해하기 쉽게 유지할 수 있습니다.\n\n다음 이미지에서 보듯이, 우리는 클린 아키텍처 레이어를 기반으로 기본 파일 시스템을 생성하는 방법에 대해 알아볼 것입니다.\n\n![이미지](/assets/img/2024-06-21-HowtoimplementcleanarchitecturewithBlocandget_itpackageinFlutter_0.png)\n\n프로젝트의 요구 사항에 따라이 파일 시스템이 변경될 수 있다는 점을 고려해야 합니다. 일부 개발자는 작은 앱에서 작업할 때 도메인 레이어를 사용하지 않는 경우가 있습니다. 이 경우에는 사용 사례와 리포지토리를 통해 비즈니스 로직을 추상화하는 데 도움이 될 것이므로 사용하겠습니다.\n\n<div class=\"content-ad\"></div>\n\n# 브레이킹 배드 앱\n\nBloc 및 get_it 패키지를 사용하여 청결한 아키텍처를 배우기 위해, 우리는 Breaking Bad Quotes API(https://api.breakingbadquotes.xyz/v1/quotes)를 사용하는 간단한 앱을 만들 것입니다. 이 API를 통해 Breaking Bad에서 랜덤 명언을 얻을 수 있습니다. 사용하기 매우 쉽고 응답은 명언과 저자가 포함된 객체가 있는 간단한 목록입니다.\n\n좋아요, 시작해 봅시다! API를 사용하면 다음과 같이 간단한 응답을 받게 됩니다.\n\n```js\n[\n  {\n    \"quote\": \"Congratulations, you’ve just left your family a second-hand Subaru.\",\n    \"author\": \"Saul Goodman\"\n  }\n]\n```\n\n<div class=\"content-ad\"></div>\n\n클린 아키텍처를 구현하려면 도메인 레이어부터 시작하는 것이 좋습니다. 이 레이어는 추상 리포지토리를 주입한 유스케이스를 통해 데이터와 프레젠테이션 레이어 사이의 다리 역할을 합니다.\n\n# 응답 엔티티\n\n우선 엔티티를 만들 것인데, 이는 앱에서 가장 간단한 객체를 나타냅니다. 모든 엔티티와 모델을 Equatable에서 확장하여 객체를 문제없이 비교하고, 앱의 테스트를 개선하며, 상태에서 원치 않는 동작을 피할 수 있도록 해야 합니다.\n\n```dart\nimport 'package:equatable/equatable.dart';\n\nclass QuoteEntitie extends Equatable {\n\n  final String? quote;\n  final String? author;\n\n  const QuoteEntitie({\n    this.quote,\n    this.author,\n  });\n\n  @override\n  List<Object?> get props => [\n    quote,\n    author,\n  ];\n}\n```\n\n<div class=\"content-ad\"></div>\n\n# 추상 저장소\n\n이제 우리는 리포지토리를 구현하는 모든 클래스에 대해 getQuote() 함수를 강제시키는 계약으로 작용하는 추상 클래스를 통해 엔티티를 반환해야 합니다. 이 구현은 나중에 확인하겠습니다. API 서비스가 비동기 데이터를 반환하기 때문에 Future를 사용합니다.\n\n```js\nabstract class QuoteRepository{\n  Future<QuoteEntitie> getQuote();\n}\n```\n\n# 사용 사례\n\n<div class=\"content-ad\"></div>\n\n다음으로, 우리는 리포지토리를 생성자를 통해 주입하는 유스 케이스를 만들 것입니다. 이 유스 케이스는 데이터 레이어와 프레젠테이션 레이어 사이의 다리 역할을 하며 새로운 상태를 발신하는 상태 관리에 중요한 역할을 합니다.\n\n```dart\nclass QuoteUsecase {\n\n  final QuoteRepository _quoteRepository;\n\n  QuoteUsecase(this._quoteRepository);\n\n  Future<QuoteEntity> getQuote() {\n    return _quoteRepository.getQuote();\n  }\n}\n```\n\n이 시점에서, 도메인 레이어를 구현합니다. 파일 시스템은 다음과 같이 보여야 합니다:\n\n![image](/assets/img/2024-06-21-HowtoimplementcleanarchitecturewithBlocandget_itpackageinFlutter_1.png)\n\n<div class=\"content-ad\"></div>\n\n이제 데이터 레이어를 구현할 차례입니다. 이름에서 알 수 있듯이 데이터 레이어는 다른 소스(우리 경우 API)에서 데이터를 관리하고 도메인 레이어와 상호 작용하여 프리젠테이션 레이어가 필요로 하는 모든 데이터를 제공합니다.\n\n# 모델 응답\n\n모델 폴더를 앱의 요구에 따라 나눌 수 있습니다. 이 경우 API 응답 모델을 위한 폴더와 API 요청 모델을 위한 폴더 두 개로 나누겠습니다. 우리 앱에서는 API 응답을 위한 모델 하나만 필요하겠지만요. 또한, 객체를 비교할 수 있도록 Equatable에서 모델을 확장하고 엔티티를 구현하는 것을 기억해주세요.\n\n```js\nclass QuoteResponseModel extends Equatable implements QuoteEntitie {\n  @override\n  final String? quote;\n  @override\n  final String? author;\n\n  const QuoteResponseModel({\n    this.quote,\n    this.author,\n  });\n\n  QuoteResponseModel copyWith({\n    String? quote,\n    String? author,\n  }) =>\n      QuoteResponseModel(\n        quote: quote ?? this.quote,\n        author: author ?? this.author,\n      );\n\n  factory QuoteResponseModel.fromRawJson(String str) =>\n      QuoteResponseModel.fromJson(json.decode(str)[0]);\n\n\n  factory QuoteResponseModel.fromJson(Map<String, dynamic> json) =>\n      QuoteResponseModel(\n        quote: json[\"quote\"],\n        author: json[\"author\"],\n      );\n\n  @override\n  List<Object?> get props => [\n        quote,\n        author,\n      ];\n}\n```\n\n<div class=\"content-ad\"></div>\n\n# 데이터 소스\n\n데이터 소스를 만들어 봅시다. 이는 필요에 따라 데이터를 가져오는 프로세스를 처리합니다. 이 예시에서는 API에서 데이터를 가져와 모든 것이 문제없이 진행되면 응답 객체를 생성하거나 오류가 발생하면 예외를 throw합니다. 보시다시피, 우리는 먼저 추상 클래스를 작성하여 추상 로직을 만듭니다. 이후 이 클래스의 구현은 선택한 클라이언트를 사용하여 데이터를 가져오는 책임을 갖게 됩니다. 이 경우 HTTP 클라이언트는 나중에 get_it 패키지를 사용하여 주입될 것입니다.\n\n```js\nimport 'package:http/http.dart' as http;\n\nabstract class QuoteDataSource {\n  Future<QuoteResponseModel> getQuote();\n}\n\nclass QuoteDataSourceImpl implements QuoteDataSource {\n  final http.Client _client;\n\n  QuoteDataSourceImpl(this._client);\n\n  @override\n  Future<QuoteResponseModel> getQuote() async {\n    final Uri url = Uri.https('api.breakingbadquotes.xyz', '/v1/quotes');\n    final http.Response response = await _client.get(url);\n    if (response.statusCode == 200) {\n      final QuoteResponseModel quoteResponseModel =\n          QuoteResponseModel.fromRawJson(response.body);\n      return quoteResponseModel;\n    } else {\n      throw Exception();\n    }\n  }\n}\n```\n\n# 저장소 구현\n\n<div class=\"content-ad\"></div>\n\n데이터 소스를 생성한 후, 이전에 만든 추상 리포지토리를 구현해야 합니다. 이는 구현 클래스의 생성자에 데이터 소스를 주입하고 추상 리포지토리 함수를 오버라이딩하여 달성할 수 있습니다.\n\n```js\nclass QuoteRepositoryImpl implements QuoteRepository{\n\n  final QuoteDataSource _dataSource;\n\n  QuoteRepositoryImpl(this._dataSource);\n\n  @override\n  Future<QuoteEntitie> getQuote() async{\n    return await _dataSource.getQuote();\n  }\n\n}\n```\n\n이 시점에서 애플리케이션에서 모든 것이 정상적으로 작동하는지 간단하게 테스트할 수 있습니다. FutureBuilder 위젯을 사용하여 API 정보를 검색하고 직접 의존성 주입을 통해 use case 객체를 만들어 확인할 수 있습니다.\n\n```js\nvoid main() => runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  MyApp({super.key});\n\n  final useCase = QuoteUsecase(QuoteRepositoryImpl(QuoteDataSourceImpl()));\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      debugShowCheckedModeBanner: false,\n      title: 'Quote App',\n      home: Scaffold(\n        appBar: AppBar(),\n        body: Center(\n          child: FutureBuilder(\n            future: useCase.getQuote(),\n            builder:\n                (BuildContext context, AsyncSnapshot<QuoteEntitie> snapshot) {\n              return Column(\n                children: [\n                  Text(\"${snapshot.data?.quote}\"),\n                  Text(\"${snapshot.data?.quote}\"),\n                ],\n              );\n            },\n          ),\n        ),\n      ),\n    );\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n하지만 이 방식에는 유지 및 확장이 어려워지고, 앱이 추가 기능과 함께 복잡해질수록 문제가 발생할 수 있습니다. 이를 해결하기 위해 홈 화면을 다른 파일로 분리하고, 서비스 로케이터 메서드를 생성하여 Bloc을 사용하여 상태를 관리할 것입니다.\n\n# Bloc 생성\n\n알다시피 Flutter 애플리케이션에서 Bloc을 구현하려면 상태 파일, 이벤트 파일, 그리고 이벤트를 기반으로 상태를 발행하는 Bloc 파일을 생성해야 합니다. 이 경우 API가 데이터를 가져오기 시작할 때와 완료될 때 피드백을 제공하는 간단한 로직 상태가 있습니다. 따라서 로딩 중인지와 견적이 이용 가능한지를 나타내는 상태가 있을 것입니다.\n\n```js\nclass QuoteBlocState extends Equatable {\n\n  final bool? isLoadingQuote;\n  final QuoteEntitie? quote;\n\n  const QuoteBlocState({this.isLoadingQuote, this.quote});\n\n  QuoteBlocState copyWith({\n    bool? isLoadingQuote,\n    QuoteEntitie? quote\n    }) {\n    return QuoteBlocState(\n      isLoadingQuote: isLoadingQuote ?? this.isLoadingQuote,\n      quote: quote ?? this.quote,\n    );\n  }\n\n  @override\n  List<Object?> get props => [\n    isLoadingQuote,\n    quote\n    ];\n}\n```\n\n<div class=\"content-ad\"></div>\n\n```js\nsealed class QuoteBlocEvent extends Equatable {\n  const QuoteBlocEvent();\n\n  @override\n  List<Object> get props => [];\n}\n\nfinal class GetQuouteEvent extends QuoteBlocEvent{\n  const GetQuouteEvent();\n}\n```\n\n```js\nclass QuoteBloc extends Bloc<QuoteBlocEvent, QuoteBlocState> {\n\n  final QuoteUsecase _quoteUsecase;\n\n  QuoteBloc(this._quoteUsecase) : super(const QuoteBlocState()) {\n    on<GetQuouteEvent>(_getQuote);\n  }\n\n  FutureOr<void> _getQuote(\n      GetQuouteEvent event, Emitter<QuoteBlocState> emit) async {\n    emit(state.copyWith(isLoadingQuote: true));\n    final QuoteEntitie response = await _quoteUsecase.getQuote();\n    emit(state.copyWith(quote: response, isLoadingQuote: false));\n  }\n}\n```\n\n여기서는 use case가 생성자로 주입되어 getQuote() 함수를 사용할 수 있도록 되어 있다는 점을 강조하는 것이 매우 중요합니다.\n\n우리의 기본 아키텍처를 완성하기 위해 필요한 유일한 것은 서비스를 위한 초기화(init) 함수를 만드는 것입니다. 이 함수를 통해 앱 전체에서 필요한 경우 서비스를 사용할 수 있습니다. get_it 패키지를 사용하면 이를 매우 간단하게 만들 수 있습니다. 아래와 같은 함수를 만드는 것만 필요합니다:\n\n<div class=\"content-ad\"></div>\n\n```dart\n최종 getIt = GetIt.instance;\n\nvoid initServices() {\n\n  이제 http.Client client = getIt.registerSingleton(http.Client());\n\n  이제 QuoteDataSourceImpl quoteDataSourceImpl =\n      getIt.registerSingleton(QuoteDataSourceImpl(client));\n\n  이제 QuoteRepositoryImpl quoteRepositoryImpl =\n      getIt.registerSingleton(QuoteRepositoryImpl(quoteDataSourceImpl));\n\n  이제 QuoteUsecase quoteUsecase =\n      getIt.registerSingleton(QuoteUsecase(quoteRepositoryImpl));\n\n  getIt.registerFactory(() => QuoteBloc(quoteUsecase));\n}\n```\n\nmain 함수에서 runApp() 이전에 initServices() 함수를 호출하여 애플리케이션의 모든 부분이 인스턴스에 액세스할 수 있도록 합니다.\n\n```dart\nvoid main() {\n  intServices();\n  runApp(const MyApp());\n}\n```\n\n이 시점에서 Bloc을 사용한 상태 관리 및 이미 설정된 서비스 로케이터를 사용하여 표현 레이어가 이렇게 보여야 합니다. 화면을 독립적인 파일로 분리하는 것을 잊지 마세요.\n\n\n<div class=\"content-ad\"></div>\n\n\n![How to Implement Clean Architecture with Bloc and get_it Package in Flutter 2](/assets/img/2024-06-21-HowtoimplementcleanarchitecturewithBlocandget_itpackageinFlutter_2.png)\n\n마지막으로, 관심 분리를 위해 홈 화면은 작은 위젯으로, 랜덤 인용구와 그 저자를 표시하는 컬럼이 있습니다. 또한, API에서 새 데이터를 가져와 다른 인용구를 검색하는 버튼이 있습니다. 데이터를 가져오는 동안에는 CircularProgressIndicator 위젯을 표시합니다.\n\n```dart\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({Key? key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(),\n      body: const Center(child: _QuoteWidget()),\n    );\n  }\n}\n\nclass _QuoteWidget extends StatelessWidget {\n  const _QuoteWidget();\n\n  @override\n  Widget build(BuildContext context) {\n    return Builder(builder: (context) {\n      final QuoteBlocState state = context.select((QuoteBloc bloc) => bloc.state);\n      final bool? isLoading = state.isLoadingQuote;\n      final QuoteEntity? quote = state.quote;\n\n      if (isLoading == true) {\n        return const Center(\n          child: CircularProgressIndicator(),\n        );\n      }\n\n      return Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          Text(\"${quote?.quote}\"),\n          Text(\"${quote?.author}\"),\n          ElevatedButton(\n              onPressed: () {\n                context.read<QuoteBloc>().add(const GetQuoteEvent());\n              },\n              child: const Text(\"Get another quote\"))\n        ],\n      );\n    });\n  }\n}\n```\n\n마지막 단계는 Bloc을 get_it을 사용하여 필요한 위치에 주입하는 것입니다. QuouteBloc의 인스턴스가 서비스 로케이터를 사용하여 위젯 트리에 주입되는 점에 유의하십시오. 마지막으로, Bloc 인스턴스가 생성된 후 인용구를 가져오고 새 상태를 발생시키는 이벤트를 호출하기 위해 연속 연산자를 사용하세요.\n\n\n<div class=\"content-ad\"></div>\n\n```dart\nclass MyApp extends StatelessWidget {\n  const MyApp({Key key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n        debugShowCheckedModeBanner: false,\n        title: 'Quote App',\n        home: BlocProvider(\n          create: (context) => getIt<QuoteBloc>()..add(const GetQuouteEvent()),\n          child: Builder(builder: (context) {\n            return const HomeScreen();\n          }),\n        ));\n  }\n}\n```\n\n그러니까 이제 앱을 실행시켜서 코딩의 매력을 만끽해보세요.\n\n![image](/assets/img/2024-06-21-HowtoimplementcleanarchitecturewithBlocandget_itpackageinFlutter_3.png)\n","ogImage":{"url":"/assets/img/2024-06-21-HowtoimplementcleanarchitecturewithBlocandget_itpackageinFlutter_0.png"},"coverImage":"/assets/img/2024-06-21-HowtoimplementcleanarchitecturewithBlocandget_itpackageinFlutter_0.png","tag":["Tech"],"readingTime":11},{"title":"Flutter 웹 애플리케이션에서 화살표 키 스크롤링 구현 방법","description":"","date":"2024-06-21 21:15","slug":"2024-06-21-ArrowKeyScrollinginFlutterWeb","content":"\n\n![화살표 키 스크롤링](/assets/img/2024-06-21-ArrowKeyScrollinginFlutterWeb_0.png)\n\n환영합니다, 플러터 열정자 여러분! 오늘은 플러터 웹에서 화살표 키 스크롤링을 구현하는 방법을 알아볼 거에요. 웹 애플리케이션이 더 상호작용적으로 변화함에 따라 사용자가 콘텐츠를 탐색하는 직관적인 방법을 제공하는 것이 중요해지고 있어요. 이 글에서는 화살표 키 입력을 감지하고 스크롤링을 처리하는 단계를 안내할 거에요.\n\n플러터 웹은 고유의 도전 과제를 가지고 있는데, 그 중 하나는 화살표 키 스크롤링에 대한 기본 지원의 부재입니다. 이것은 보통 사소한 제한처럼 보이지만 사용자의 탐색에 상당한 영향을 미칠 수 있어요.\n\n그래서 플러터에서 화살표 키를 통해 스크롤링하는 몇 가지 솔루션이 있어요. 함께 솔루션을 알아보러 가볼까요? 🤓🤓\n\n<div class=\"content-ad\"></div>\n\n# 첫 번째 솔루션:\n\nListView에서 \"primary\" 속성이 있는 것을 알고 있습니다. ListView 위젯 내에서 \"primary\" 속성을 true로 설정하면 사용자가 키보드 화살표 키를 사용하여 내용을 원활하게 탐색할 수 있습니다.\n\n이 기능을 테스트하기 위해 이 코드를 복제해 보세요:\n\n# 두 번째 솔루션:\n\n<div class=\"content-ad\"></div>\n\n우리는 GestureDetector와 FocusScope를 통해 화살표 키도 활성화할 수 있어요.\n\nGestureDetector =` 'ListView'를 'GestureDetector' 위젯으로 감쌉니다. 이렇게 하면 사용자가 탭과 같은 사용자 입력 제스처를 감지할 수 있어요. 이를 활용하여 ListView 내에서 포커스를 관리할 수 있습니다.\n\n- FocusScope: 'FocusScope' 위젯을 사용하여 ListView의 포커스 상태를 동적으로 관리할 거예요. 'FocusScopeNode' 인스턴스를 만들고 유지함으로써 포커스 동작을 제어할 수 있어요. 이를 통해 ListView가 사용자 상호작용에 적절하게 응답하도록 보장합니다.\n- 기본 속성 설정: ListView 내에서 'primary' 속성을 포커스 상태에 따라 동적으로 설정합니다. ListView가 포커스를 얻을 때는 'primary'를 true로 설정하여 부모 위젯 계층 내에서 기본 스크롤 뷰가 되어야 함을 나타냅니다. 이를 통해 키보드 화살표 키를 사용하여 부드럽고 직관적인 스크롤이 가능해지며, 접근성과 사용성을 향상시킵니다.\n\n이 기능을 테스트하기 위해 이 코드를 클론하세요:\n\n<div class=\"content-ad\"></div>\n\n# 세 번째 해결책:\n\nKeyboardListener와 ScrollController를 사용합니다.\n\nKeyboardListener와 ScrollController 두 가지 위젯을 통해 플러터 웹 애플리케이션의 ListView에서 키보드 입력을 모니터하고 스크롤 동작을 동적으로 조정할 수 있습니다. 화살표 키 이벤트를 감지하고 스크롤 위치를 그에 맞게 애니메이팅함으로써 사용자에게 직관적이고 반응성 있는 스크롤 경험을 제공합니다.\n\n- KeyboardListener: ListView를 KeyboardListener 위젯으로 감싸줍니다. 이 위젯은 키보드 이벤트를 수신하고 사용자 입력에 효과적으로 응답할 수 있도록 합니다. 자동 초점 노드를 지정함으로써 ListView가 기본적으로 키보드 입력 초점을 받도록 하여 원활한 상호작용이 가능하도록 보장합니다.\n- ScrollController: ScrollController를 초기화하여 ListView의 스크롤 위치를 프로그래밍 방식으로 관리합니다. 이 컨트롤러를 통해 화살표 키 이벤트에 반응하여 스크롤 위치를 애니메이션화할 수 있어 부드럽고 유동적인 스크롤 동작을 가능하게 합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nonKeyEvent: (value) {\n  if (_controller.position.outOfRange) {\n    return;\n  }\n  final offset = _controller.offset;\n  if (value.physicalKey.debugName == \"Arrow Down\") {\n    _controller.animateTo(offset + 50,\n        duration: const Duration(milliseconds: 500),\n        curve: Curves.linear);\n  }\n  if (value.physicalKey.debugName == \"Arrow Up\") {\n    _controller.animateTo(offset - 50,\n        duration: const Duration(milliseconds: 500),\n        curve: Curves.linear);\n  }\n},\n```\n\n이 코드를 복제하여 이 기능을 테스트해보세요:\n\n# 네 번째 솔루션 :\n\n키보드 화살표 키 스크롤링을 위해 FocusableActionDetector 사용하기.\n\n<div class=\"content-ad\"></div>\n\n- FocusableActionDetector : ListView을 GestureDetector와 FocusableActionDetector의 조합으로 감쌀 것입니다. 이 설정을 통해 키보드 이벤트를 감지하고 화살표 키 입력에 대응하여 해당 작업을 트리거할 수 있습니다.\n- 단축키 및 작업 정의: FocusableActionDetector 내에서 화살표 키 이벤트 (예: arrowUp 및 arrowDown)에 대한 단축키를 정의하고 해당 단축키를 특정 콜백 작업에 연결합니다. 이러한 작업은 ListView의 스크롤 위치를 동적으로 조정하는 사용자 지정 함수를 트리거하여 부드럽고 직관적인 스크롤 경험을 제공합니다.\n- ScrollController : ListView의 스크롤 위치를 프로그래밍 방식으로 관리하기 위해 ScrollController를 초기화할 것입니다.\n\n이 기능을 테스트하려면 이 코드를 복제해 보세요:\n\n# 결론:\n\nFlutter 웹 앱에서 화살표 키 스크롤링에 대한 다양한 방법에 대해 논의했습니다. Flutter 웹에서 직면한 공통적인 도전 과제입니다.\n\n<div class=\"content-ad\"></div>\n\n이 기사가 마음에 들었기를 바라요!\n\n만약 이 기사가 도움이 되었다면 👏 손뼉을 치세요.\n\n다음에 또 만나요!","ogImage":{"url":"/assets/img/2024-06-21-ArrowKeyScrollinginFlutterWeb_0.png"},"coverImage":"/assets/img/2024-06-21-ArrowKeyScrollinginFlutterWeb_0.png","tag":["Tech"],"readingTime":4},{"title":"플러터에서 히어로 애니메이션 마스터하기 종합 가이드","description":"","date":"2024-06-21 21:13","slug":"2024-06-21-MasteringHeroAnimationsinFlutterAComprehensiveGuide","content":"\n\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*hfZq5kMkFSZtlSRsReQYdQ.gif)\n\n모바일 앱 개발 세계에서 부드럽고 시각적으로 매력적인 전환을 만드는 것은 매혹적인 사용자 경험을 위해 중요합니다. Flutter에서 이를 달성하는 가장 효과적인 방법 중 하나는 히어로 애니메이션을 통해입니다. 히어로 애니메이션은 위젯을 한 페이지에서 다른 페이지로 애니메이션화하여 서로 연결되고 동적인 느낌을 만들어 다른 화면 간에 매끄러운 전환을 제공합니다. 이 안내서에서는 Flutter에서 히어로 애니메이션의 기본 사항, 중요성 및 코드 예제로 구현하는 방법을 안내합니다.\n\n## 히어로 애니메이션의 중요성과 사용 사례\n\n히어로 애니메이션은 시각적으로 매력적일 뿐만 아니라 사용자 경험에서도 중요한 역할을 합니다. 그들은 다음에서 도움이 됩니다:\n\n\n<div class=\"content-ad\"></div>\n\n- 컨텍스트 유지: 사용자들이 쉽게 전환을 따라갈 수 있고 서로 다른 UI 요소 간의 관계를 이해할 수 있습니다.\n- 시각적 연속성 제공: 부드럽고 연속적인 사용자 경험을 제공하여 네비게이션이 자연스럽고 순조롭게 느껴지도록 합니다.\n- 사용자 참여 증진: 정교하게 디자인된 애니메이션은 앱을 사용하는 데 더 즐겁고 매력적으로 만들 수 있습니다.\n\n## 주요 히어로 애니메이션 사용 사례:\n\n- 이미지 갤러리 전환: 섬네일 그리드 뷰에서 전체 화면 이미지 뷰로 이동하는 것.\n- 프로필 페이지 애니메이션: 서로 다른 화면 간에 사용자 아바타나 프로필 사진을 전환하는 것.\n- 전자 상거래 앱: 제품 이미지를 목록에서 상세보기로 애니메이션하는 것.\n\n# 파트 1: 히어로 애니메이션의 기본 구조\n\n<div class=\"content-ad\"></div>\n\n## 히어로 애니메이션이란 무엇인가요?\n\nFlutter에서의 히어로 애니메이션은 위젯 간 전환 애니메이션으로, 화면 전환 시 위젯이 한 화면에서 다른 화면으로 \"비행\"하는 것을 의미합니다. 이로 인해 위젯은 출발지와 도착지 화면 사이를 부드럽게 전환하는 것처럼 보여 시각적으로 매력적인 효과를 제공합니다.\n\n## 기본 히어로 애니메이션 예제\n\n기본 히어로 애니메이션을 만들려면 다음 단계를 따라주세요:\n\n<div class=\"content-ad\"></div>\n\n1. 위젯을 히어로 위젯으로 감싸기:\n\n- 애니메이션을 적용하려는 위젯을 감싸는 데 히어로 위젯을 사용하세요.\n- 원본과 대상 히어로 위젯이 동일한 태그를 가지고 있는지 확인하세요.\n\n2. 화면 간 이동하기:\n\n- 화면 간 이동에는 Navigator.push 메서드를 사용하세요.\n\n<div class=\"content-ad\"></div>\n\n여기에 기본 hero 애니메이션을 보여주는 간단한 예제가 있어요:\n\n![영상](https://miro.medium.com/v2/resize:fit:1400/1*Tnp6mCmVil2aRqNtcxrfDg.gif)\n\n```dart\nimport 'package:flutter/material.dart';\n\nvoid main() => runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: FirstPage(),\n    );\n  }\n}\n\nclass FirstPage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('First Page')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            Navigator.push(\n              context,\n              MaterialPageRoute(builder: (context) => SecondPage()),\n            );\n          },\n          child: Text('Go to Second Page'),\n        ),\n      ),\n    );\n  }\n}\n\nclass SecondPage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Second Page')),\n      body: Center(\n        child: Text('Welcome to the second page!'),\n      ),\n    );\n  }\n}\n```\n\n## 플러터에서 사용자 정의 전환\n\n<div class=\"content-ad\"></div>\n\n기본 전환 방식은 편리하지만, 사용자 정의 전환은 애니메이션에 대한 더 큰 유연성과 제어를 제공하여 더 독특한 사용자 경험을 만들 수 있습니다. 페이지 라우트 빌더를 사용하여 사용자 정의 전환을 구현할 수 있으며 전환 애니메이션을 정의할 수 있습니다.\n\n사용자 정의 슬라이드 전환 예시\n\n![사용자 정의 슬라이드 전환 예시](https://miro.medium.com/v2/resize:fit:1400/1*c5cZecOnWL5IL6g75JmoNw.gif)\n\nPageRouteBuilder를 사용하여 사용자 정의 슬라이드 전환의 예시를 확인해보세요:\n\n<div class=\"content-ad\"></div>\n\n```dart\nimport 'package:flutter/material.dart';\n\nvoid main() => runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: FirstScreen(),\n    );\n  }\n}\n\nclass FirstScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('First Screen')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            Navigator.push(context, PageRouteBuilder(\n              pageBuilder: (context, animation, secondaryAnimation) => SecondScreen(),\n              transitionsBuilder: (context, animation, secondaryAnimation, child) {\n                const begin = Offset(1.0, 0.0);\n                const end = Offset.zero;\n                const curve = Curves.ease;\n\n                var tween = Tween(begin: begin, end: end).chain(CurveTween(curve: curve));\n\n                return SlideTransition(\n                  position: animation.drive(tween),\n                  child: child,\n                );\n              },\n            ));\n          },\n          child: Text('Go to Second Screen'),\n        ),\n      ),\n    );\n  }\n}\n\nclass SecondScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Second Screen')),\n      body: Center(\n        child: Text('This is the second screen'),\n      ),\n    );\n  }\n}\n```\n\n# 사용자 정의 슬라이드 트랜지션 설명\n\n- PageRouteBuilder: 사용자 정의 페이지 라우트 전환을 생성하는 데 사용됩니다.\n- pageBuilder: 대상 화면을 정의합니다.\n- transitionsBuilder: 전환 애니메이션을 정의합니다. 여기서 SlideTransition을 사용하여 새 화면이 오른쪽에서 슬라이드되는 애니메이션을 구현합니다.\n\n## 코드 설명\n\n<div class=\"content-ad\"></div>\n\n- FirstScreen Class: 초기 화면으로 이미지의 작은 버전을 표시하는 곳입니다. `hero-tag` 태그로 된 Hero 위젯으로 감싸져 있습니다. GestureDetector를 사용하여 탭하면 SecondScreen으로 이동합니다.\n- SecondScreen Class: 이 화면은 동일한 이미지의 큰 버전을 표시하며, 같은 태그로 된 Hero 위젯으로도 감싸져 있습니다. Hero 애니메이션은 이 태그를 기반으로 두 위젯을 연결하고 매끄러운 전환 효과를 만듭니다.\n\n## 고급 사용자 정의\n\nFlutter를 사용하면 여러 가지 사용자 정의가 가능합니다. 예를 들어 사용자 정의 비행 경로 및 애니메이션을 정의하거나, FlightShuttleBuilder를 사용하여 전환 중에 hero의 모양을 사용자 정의할 수 있습니다.\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\n플러터의 히어로 애니메이션은 화면 간에 시각적으로 매력적이고 맥락적으로 의미 있는 전환을 만드는 강력한 도구입니다. 기본 구조를 이해하고 간단한 코드 조각으로 히어로 애니메이션을 구현하면 앱의 사용자 경험을 크게 향상시킬 수 있습니다. 사진 갤러리, 전자상거래 플랫폼 또는 부드러운 전환을 통해 혜택을 얻는 어떤 앱이든 구축 중이라면 히어로 애니메이션은 게임 체인저가 될 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-21-MasteringHeroAnimationsinFlutterAComprehensiveGuide_0.png"},"coverImage":"/assets/img/2024-06-21-MasteringHeroAnimationsinFlutterAComprehensiveGuide_0.png","tag":["Tech"],"readingTime":6},{"title":"2024년 예비 개발자에게 Flutter를 꼭 배워야 하는 이유","description":"","date":"2024-06-21 21:09","slug":"2024-06-21-WhyLearningFlutterin2024isEssentialforAspiringDevelopers","content":"\n\n<img src=\"/assets/img/2024-06-21-WhyLearningFlutterin2024isEssentialforAspiringDevelopers_0.png\" />\n\n급변하는 기술 환경에서 앞서 나가는 것은 지망 개발자에게 필수적입니다. 현재 큰 인기를 끌고 있는 기술 중 하나는 Flutter입니다. Google에서 출시된 Flutter는 개발자가 단일 코드베이스에서 모바일, 웹 및 데스크톱용 네이티브 컴파일된 애플리케이션을 빌드할 수 있는 오픈 소스 UI 소프트웨어 개발 키트(SDK)입니다. 2024년을 맞아 Flutter 학습의 중요성은 전에 없던 만큼 뚜렷해졌습니다. 이 블로그에서는 Flutter가 지망 개발자의 학습 여정에서 중심에 있어야 하는 주요 이유에 대해 탐구합니다.\n\n## 현재 앱 개발 환경 개요\n\n앱 개발 산업은 크로스 플랫폼 솔루션으로의 패러다임 변화를 겪었습니다. 과거 iOS 및 Android를 위해 별도의 코드베이스를 작성해야 했던 시대는 지나갔습니다. 오늘날 기업은 빠른 전환 시간, 줄어든 비용, 다중 플랫폼에서의 원활한 성능을 요구합니다. 이러한 변화로 Flutter와 같은 크로스 플랫폼 프레임워크가 주목받게 되었습니다.\n\n<div class=\"content-ad\"></div>\n\n## 플러터 팩트\n\n플러터가 처음 출시된 이후 구글, 알리바바, 이베이를 포함한 많은 유명 회사들이 채택했습니다. 강력한 프레임워크와 열정적이고 지원적인 커뮤니티를 갖춘 플러터는 개발자들 사이에서 인기가 많습니다. 스택 오버플로의 개발자 설문 조사에 따르면, 플러터는 지속적으로 가장 선호되고 원하는 프레임워크 중 하나로 꼽히며, 인기와 광범위한 사용을 반영하고 있습니다.\n\n## 사람들이 묻는 질문: 플러터의 미래는 어떨까요?\n\n플러터의 미래는 매우 밝아 보입니다. 지속적인 업데이트와 구글의 강력한 지원으로 플러터는 앱 개발 분야에서 주요 역할을 계속할 것으로 예상됩니다. 최신 기술 트렌드를 따라갈 수 있는 능력이 플러터를 개발자들에게 계속해서 필요하고 가치 있는 도구로 만들 것임을 보장합니다.\n\n<div class=\"content-ad\"></div>\n\n🚀 플러터 스킬 수요가 늘어나는 이유, 크로스 플랫폼 개발의 혜택💻, 탁월한 성능, 강력한 커뮤니티 지원, 그리고 구글로부터 지속적인 향상🔄을 탐구해보세요.\n\n# 이유 1: 플러터 개발자에 대한 수요 상승\n\n플러터 개발자를 위한 취업 시장이 번창하고 있습니다. 플러터를 사용하는 혜택을 더 많은 기업들이 인지함에 따라, 이 프레임워크에 능숙한 개발자들에 대한 수요가 증가하고 있습니다.\n\n## 취업 시장 동향\n\n<div class=\"content-ad\"></div>\n\n\n![Job Board](/assets/img/2024-06-21-WhyLearningFlutterin2024isEssentialforAspiringDevelopers_1.png)\n\nFlutter 개발자를 찾는 기업이 늘어나고 있습니다. 각종 산업 분야의 기업들이 Flutter의 능력을 활용하여 고품질의 크로스 플랫폼 애플리케이션을 개발할 수 있는 개발자를 찾고 있습니다.\n\n## Flutter를 채택한 기업들\n\n![Companies Adopting Flutter](/assets/img/2024-06-21-WhyLearningFlutterin2024isEssentialforAspiringDevelopers_2.png)\n\n\n<div class=\"content-ad\"></div>\n\n대형 기술 기업부터 스타트업까지가 앱 개발에 Flutter를 채택하고 있어요. Google, Tencent, Philips와 같은 기업들은 Flutter를 활용하여 원할하고 효과적인 애플리케이션을 개발하고 있어요. 이 추세는 기업들이 Flutter에 대한 신뢰와 신빙성을 나타내며, 이 프레임워크에 능숙한 개발자에 대한 수요를 더욱 촉진하고 있어요.\n\n# 이유 2: 크로스 플랫폼 개발\n\nFlutter의 가장 큰 장점 중 하나는 크로스 플랫폼 개발을 용이하게 한다는 점이에요.\n\n![이미지](/assets/img/2024-06-21-WhyLearningFlutterin2024isEssentialforAspiringDevelopers_3.png)\n\n<div class=\"content-ad\"></div>\n\n## iOS와 안드로이드를 위한 단일 코드베이스\n\nFlutter를 사용하면 개발자들은 iOS와 안드로이드 모두에서 작동하는 단일 코드베이스를 작성할 수 있습니다. 이는 시간을 절약하는 뿐만 아니라 플랫폼 간 일관성을 보장합니다. 이제 더 이상 개발자들은 다른 운영 체제를 위한 별도의 코드베이스를 유지할 필요가 없으며, 이는 개발 프로세스를 보다 간소화하고 효율적으로 만듭니다.\n\n## 시간 및 비용 효율성\n\niOS와 안드로이드를 위한 별도의 애플리케이션을 개발하는 것은 시간이 많이 걸리고 비용이 많이 발생할 수 있습니다. Flutter의 크로스 플랫폼 기능을 통해 비즈니스는 개발 비용을 줄이고 시장 진입 시간을 단축할 수 있습니다. 이러한 효율성은 리소스를 최적화하려는 스타트업 및 기업에게 큰 변화를 가져다줍니다.\n\n<div class=\"content-ad\"></div>\n\n# 이유 3: 견고한 성능\n\n플러터의 아키텍처는 원본 애플리케이션과 견주어질 정도로 견고한 성능을 제공하도록 설계되었습니다.\n\n## 네이티브와 유사한 성능\n\n플러터 애플리케이션은 네이티브 ARM 코드로 직접 컴파일되어 iOS와 Android에서 높은 성능을 제공합니다. 이를 통해 플러터로 구축된 앱이 원활하고 효율적으로 실행되어 사용자에게 네이티브와 유사한 경험을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n## 빠른 렌더링 및 실행\n\nFlutter의 렌더링 엔진 Skia는 빠르고 반응적인 UI 렌더링을 가능하게 합니다. 또한 핫 리로딩과 같은 기능을 통해 실시간으로 변경 사항의 효과를 확인할 수 있어 개발자들이 더 효율적인 개발 프로세스와 빠른 반복 주기를 가질 수 있습니다.\n\n# 이유 4: 강력한 커뮤니티와 생태계\n\n강력하고 지원적인 커뮤니티는 어떠한 기술의 성장과 지속 가능성에 중요한 요소이며, Flutter도 예외가 아닙니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-21-WhyLearningFlutterin2024isEssentialforAspiringDevelopers_4.png\" />\n\n## 활기찬 개발자 커뮤니티\n\nFlutter는 활기찬 활발한 개발자 커뮤니티를 자랑합니다. 이 커뮤니티는 입문 개발자에게 귀중한 자원으로, 지원을 제공하고 지식을 공유하며 프레임워크의 지속적인 개선에 기여합니다. GitHub, Stack Overflow 및 다양한 Flutter 중심 포럼과 같은 플랫폼들은 서로 돕고 성공하기를 바라는 개발자들로 북적입니다.\n\n## 풍부한 라이브러리와 플러그인\n\n<div class=\"content-ad\"></div>\n\n플러터의 생태계는 라이브러리와 플러그인으로 풍부하며, 개발 프로세스를 크게 가속화시킬 수 있습니다. 복잡한 애니메이션을 구현하거나, 제3자 서비스를 통합하거나, 앱 기능을 향상시킬 필요가 있다면, 플러터 플러그인을 활용하여 빠르고 효율적으로 목표를 달성할 수 있습니다.\n\n# 이유 5: 지속적인 개선 및 지원\n\n플러터의 강점 중 하나는 Google의 지속적인 개선과 견고한 지원 기능입니다.\n\n## Google로부터의 정기적인 업데이트\n\n<div class=\"content-ad\"></div>\n\nGoogle이 Flutter에 대한 헌신은 정기적인 업데이트와 개선 사항을 통해 명확하게 드러납니다. 이러한 업데이트는 Flutter가 최신 기술 발전을 따라잡고 개발자들에게 최신 기능을 제공하는 것을 보장합니다.\n\n## 장기적인 지원과 성장 잠재력\n\nGoogle로부터 받는 Flutter의 장기적인 지원은 개발자들이 이 프레임워크를 자신 있게 배우고 리소스를 투자할 수 있음을 의미합니다. Flutter가 계속 성장하고 발전함에 따라, 오늘 기술을 습득한 개발자들은 미래 기회를 활용할 준비가 잘 된 상태에 있을 것입니다.\n\n# 자주 묻는 질문 (FAQs):\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-21-WhyLearningFlutterin2024isEssentialforAspiringDevelopers_5.png\" />\n\n## 1. Flutter이란 무엇인가요?\n\n답변: Flutter는 Google이 만든 오픈 소스 UI 소프트웨어 개발 키트(SDK)입니다. 이를 사용하면 모바일(iOS 및 Android), 웹 및 데스크톱용 네이티브 컴파일된 응용 프로그램을 단일 코드베이스에서 만들 수 있습니다.\n\n## 2. 2024년에 Flutter를 배워야 하는 이유?\n\n<div class=\"content-ad\"></div>\n\n답변: 2024년에 Flutter를 배우는 것은 그것의 인기 증가, 숙련된 Flutter 개발자에 대한 수요 증가, 크로스 플랫폼 기능, 강력한 성능, 강력한 커뮤니티 지원 및 Google의 지속적인 개선으로 인해 필수적입니다.\n\n## 3. Flutter가 크로스 플랫폼 개발을 어떻게 지원하나요?\n\n답변: Flutter를 사용하면 개발자들이 iOS, Android, 웹 및 데스크톱을 포함한 여러 플랫폼에 애플리케이션을 배포하기 위해 사용할 수있는 단일 코드베이스를 작성할 수 있습니다. 이 접근 방식은 일관된 성능 및 UI/UX를 보장하면서 시간과 자원을 절약합니다.\n\n## 4. Flutter는 초보자에게 적합한가요?\n\n<div class=\"content-ad\"></div>\n\n네, 플러터는 초보자 친화적입니다. 명확한 문서, 풍부한 라이브러리 및 지원하는 커뮤니티로 인해, 플러터는 모바일 및 웹 앱 개발에 처음으로 도전하는 개발자들에게 쉽게 접근할 수 있습니다.\n\n## 5. 플러터와 함께 사용되는 프로그래밍 언어는 무엇인가요?\n\n답변: 플러터는 구글에서 개발한 Dart 프로그래밍 언어를 사용합니다. Dart는 배우기 쉽고 JavaScript나 Java와 같은 인기 있는 프로그래밍 언어와 유사한 구문을 가지고 있습니다.\n\n## 6. 플러터 개발자의 경력 전망은 어떻게 되나요?\n\n<div class=\"content-ad\"></div>\n\n답변: 플러터 개발자의 경력 전망은 밝습니다. 더 많은 기업이 앱 개발을 위해 플러터를 채택함에 따라 숙련된 개발자에 대한 수요는 계속해서 증가하고 있습니다. 많은 기술 거장 및 스타트업 기업이 고품질의 크로스 플랫폼 애플리케이션을 구축하기 위해 플러터 개발자를 찾고 있습니다.\n\n## 7. 플러터는 웹 및 데스크톱 애플리케이션에 사용될 수 있나요?\n\n답변: 네, 플러터는 모바일 앱뿐만 아니라 웹 및 데스크톱 애플리케이션 개발에도 사용할 수 있습니다. 이러한 다양성은 각종 플랫폼에서 실행되는 애플리케이션을 만들고 싶은 개발자들에게 가치 있는 도구로 작용합니다.\n\n## 8. 플러터의 성능은 네이티브 앱과 비교했을 때 어떻게 됩니까?\n\n<div class=\"content-ad\"></div>\n\nFlutter 애플리케이션은 기본 ARM 코드로 직접 컴파일되기 때문에 네이티브와 유사한 성능을 제공합니다. 이로 인해 원활하고 효율적인 실행이 가능하며, 완전한 네이티브 앱과 견줄만한 성능을 제공합니다.\n\n## 9. Flutter는 어떤 지원과 커뮤니티를 가지고 있나요?\n\nFlutter는 계속해서 개선되는 데 기여하는 개발자들의 활기찬 활동적인 커뮤니티를 보유하고 있습니다. 문서, 포럼, GitHub 저장소 및 써드파티 라이브러리 및 플러그인과 같은 다양한 리소스들이 제공되어 개발 경험을 향상시킵니다.\n\n## 10. Google은 Flutter를 얼마나 자주 업데이트하나요?\n\n<div class=\"content-ad\"></div>\n\n답변: Flutter는 구글로부터 정기적인 업데이트를 받아 최신 기술 발전에 따라 업데이트되며 개발자들에게 최신 특징을 제공하도록 합니다. 이러한 업데이트는 구글의 Flutter의 장기적인 성장과 지원에 대한 약속을 반영하고 있습니다.\n\n# 결론\n\n## Flutter 학습의 이유 요약\n\n2024년에 Flutter를 학습하는 것은 많은 이점을 제공합니다. Flutter 개발자에 대한 수요의 증가, 프레임워크의 크로스 플랫폼 기능, 강력한 성능, 뛰어난 커뮤니티, 지속적인 개선 등이 결합되어 필수 기술로 인식되고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 학습 시작\n\n앱 개발의 경쟁력 있는 세계에서 앞서나가고 싶다면, 지금이 플러터 학습을 시작할 때가 없습니다. 당신이 경험 많은 개발자이든 초보자이든, 플러터를 마스터하면 고품질의 크로스 플랫폼 애플리케이션을 효율적으로 만들 수 있는 기술을 습득할 수 있습니다. 앱 개발의 미래를 받아들이고, 지금 바로 플러터 여정을 시작하세요!","ogImage":{"url":"/assets/img/2024-06-21-WhyLearningFlutterin2024isEssentialforAspiringDevelopers_0.png"},"coverImage":"/assets/img/2024-06-21-WhyLearningFlutterin2024isEssentialforAspiringDevelopers_0.png","tag":["Tech"],"readingTime":7},{"title":"Flutter에서 더 나은 오류 처리 방법  Error Stack 알아보기","description":"","date":"2024-06-21 21:07","slug":"2024-06-21-BetterErrorHandlingforFlutterErrorStack","content":"\n\n## 플러터용 모던 오류 처리 UI가 있습니다. 이로 인해 버그를 더 빨리 해결할 수 있습니다\n\n![이미지](/assets/img/2024-06-21-BetterErrorHandlingforFlutterErrorStack_0.png)\n\n이 중간 이야기에서, 단 한 줄의 코드로 오류 화면을 멋지고 현대적인 오류 처리 UI로 변환하는 새 패키지를 공유하겠습니다. 이 패키지는 Android, iOS, Linux, macOS, Windows 및 웹에서 작동합니다.\n\n# 플러터를 위한 에러 스택 소개 🎉\n\n<div class=\"content-ad\"></div>\n\npub.dev을 통해 이 패키지를 설치할 수 있어요. 공개 저장소는 GitHub에 호스팅돼요.\n\n## 에러 스택 설치하기\n\n아래 내용을 당신의 pubspec.yaml 파일에 추가하세요:\n\n```yaml\ndependencies:\n  error_stack: ^1.7.3\n```\n\n<div class=\"content-ad\"></div>\n\n혹시 Flutter를 사용하시나요?\n\nflutter pub add error_stack\n\n프로젝트에 의존성으로 추가되었는지 확인하려면 flutter pub get을 실행해보세요.\n\n# 에러 스택 초기화하기 🛠️\n\n<div class=\"content-ad\"></div>\n\n에러 스택을 사용하려면 아래 예제처럼 main.dart 파일에 ErrorStack.init();을 추가하십시오.\n\n```js\n// main.dart 파일에 에러 스택 추가\n...\nimport 'package:error_stack/error_stack.dart';\n\nvoid main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n  await ErrorStack.init(); // 에러 스택 초기화\n  runApp(MyApp());\n}\n```\n\n이제 에러 스택이 활성화되어 UI에서 발생하는 모든 오류를 캐치할 준비가 되었습니다. 테스트를 위해 에러를 시뮬레이션해 보겠습니다!\n\n```js\nimport 'package:flutter/material.dart';\n\nclass ErrorExampleWidget extends StatefulWidget {\n  \n  ErrorExampleWidget({super.key});\n\n  @override\n  createState() => _ErrorExampleWidgetState();\n}\n\nclass _ErrorExampleWidgetState extends State<ErrorExampleWidget> {\n\n  dynamic title = [];\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(\"에러 예제\")\n      ),\n      body: SafeArea(\n         child: Container(\n           child: Text(title), // 타이틀에 대한 Subtype이 String이 아닙니다 💣\n         ),\n      ),\n    );\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n에러 발생 예제 페이지(ErrorExamplePage)는 Text 위젯이 첫 번째 인수로 문자열만 허용하기 때문에 오류가 발생할 것입니다.\n\n앱에서 이 위젯을 사용하려고 하면 에러 스택(Error Stack)이 나타납니다.\n\n<img src=\"/assets/img/2024-06-21-BetterErrorHandlingforFlutterErrorStack_1.png\" />\n\n# 주요 기능 🚀\n\n<div class=\"content-ad\"></div>\n\n- 웹 UI에서의 빠른 구글 검색을 통해 오류 해결\n- 오류 메시지를 클립보드에 복사\n- 라이트 모드 및 다크 모드 지원\n- 디버그 및 릴리스 모드 오류 화면\n- 릴리스 모드를 위한 사용자 정의 오류 페이지\n\n![이미지](/assets/img/2024-06-21-BetterErrorHandlingforFlutterErrorStack_2.png)\n\n## 빠른 구글 검색\n\n내가 좋아하는 기능은 오류를 즉시 구글에서 검색할 수 있는 기능입니다. \"이 오류로 구글에서 검색\"을 탭하면 바로 검색 페이지로 이동하여 오류를 해결하는 방법을 배울 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 앱 재시작\n\n다른 유용한 기능은 디버그 모드에서 앱을 다시 시작할 수 있는 기능입니다. 이는 앱을 수동으로 종료하고 다시 빌드할 필요가 없다는 뜻입니다.\n\n## 릴리스 모드 UI\n\n릴리스 모드에서 앱이 충돌하는 경우, 오류 스택은 사용자에게 다른 UI를 표시할 것입니다. 그러나 사용자 정의 UI를 사용하고 싶다면, 아래 예시처럼 init 메서드에 errorWidget을 추가하십시오.\n\n<div class=\"content-ad\"></div>\n\n```js\nawait ErrorStack.init(\n  errorWidget: (errorDetails) => MaterialApp(\n    home: Scaffold(\n      body: Center(\n        child: Text(\"An error occurred\"),\n      ),\n    ),\n  )\n);\n```\n\n# 마무리하며\n\n이번 미디엄 스토리가 유익했기를 바랍니다! Error Stack을 개발하는 것이 정말 재미있었는데, 더 나은 기능을 추가할 아이디어를 이미 몇 가지 생각해 두었습니다.\n\n만약 궁금하시다면 GitHub의 공개 저장소에서 내부 동작을 확인해볼 수 있습니다. 여러분의 프로젝트에서 시도해보고 피드백을 보내주세요.\n\n<div class=\"content-ad\"></div>\n\n위 문서를 읽어 주셔서 감사합니다.\n\n안토니 고든\n\nhttps://linktr.ee/agordn","ogImage":{"url":"/assets/img/2024-06-21-BetterErrorHandlingforFlutterErrorStack_0.png"},"coverImage":"/assets/img/2024-06-21-BetterErrorHandlingforFlutterErrorStack_0.png","tag":["Tech"],"readingTime":3},{"title":"Flutter로 크로스 플랫폼 앱을 만드는 방법","description":"","date":"2024-06-21 21:06","slug":"2024-06-21-HowToUseFlutterforBuildingCross-PlatformApps","content":"\n\n구글은 기술 산업에서 많은 혁신을 이끌어 온 주요한 역할을 해왔어요. 그중 하나가 플러터(Flutter)라는 강력한 프레임워크인데, 개발자들 사이에서 폭넓게 인기를 얻고 있어요. 플러터는 크로스 플랫폼 앱 개발을 용이하게 해주는 능력으로 특히 유명해요. 그리고 더욱 흥미로운 점은 플러터가 이제 웹 개발까지 지원하며, 개발자들이 단일 코드베이스를 사용해 크로스 플랫폼 웹 앱을 만들 수 있다는 것이에요. 이 글에서는 플러터의 크로스 플랫폼 앱 개발에 사용되는 장점을 탐색하고, 웹 개발을 위해 플러터로 시작하는 단계별 안내를 제공할 거에요.\n\n# 플러터를 사용한 크로스 플랫폼 앱의 장점\n\n단일 코드베이스: 플러터의 가장 큰 장점 중 하나는 코드를 한 번 작성하면 iOS, Android 및 웹에서 원활하게 배포할 수 있는 크로스 플랫폼 앱 개발을 가능하게 한다는 것이에요. 이는 코드를 한 번만 작성하고 iOS, Android 및 웹에 쉽게 배포할 수 있어 소중한 시간과 노력을 아낄 수 있게 해줘요.\n빠른 개발: Flutter는 Hot Reload라는 기능을 제공하는데, 이를 통해 개발자들은 편집을 할 때 즉시 실시간 변경 사항을 볼 수 있어요. 이는 개발 과정을 크게 가속화하여 생산성을 향상시킵니다. 개발자들은 손쉽게 앱을 세밀하게 조정할 수 있어요.\n아름다운 반응형 UI: Flutter는 사용자 인터페이스를 구축하기 위한 선언적인 방법을 제공하며 다양한 사용자 지정 위젯과 UI 요소를 제공해요. 이를 통해 다양한 플랫폼에서 네이티브 같은 경험을 제공하는 멋진 반응형 디자인을 쉽게 만들 수 있어요.\n네이티브 성능: Flutter 앱은 네이티브 코드로 컴파일되어 고성능을 보장해요. Skia 그래픽 라이브러리를 활용하여 Flutter는 부드러운 애니메이션과 빠른 렌더링을 가능하게 하며, 시각적으로 매력적인 것 뿐만 아니라 고성능의 앱을 제공해줘요.\n네이티브 기능 및 API에 액세스: Flutter는 개발자들에게 네이티브 기능과 API에 직접 액세스 권한을 부여해요. 디바이스 센서, 카메라, 위치 서비스 또는 플랫폼별 API에 액세스해야 할 때, Flutter는 프레임워크와 네이티브 기능 간의 간극을 메우는 플러그인을 제공해요.\n\n# 웹 개발을 위해 플러터로 시작하기:\n\n<div class=\"content-ad\"></div>\n\n이제 Flutter의 크로스 플랫폼 앱을 위한 장점을 탐색했으니, Flutter 웹 개발을 시작하는 방법에 대해 알아봅시다.\nFlutter 설치: 먼저 시스템에 Flutter SDK를 설치하여 시작하세요. 여러 운영 체제에 대한 자세한 설치 지침은 Flutter 공식 웹사이트에서 확인할 수 있습니다. 터미널에서 Flutter의 명령줄 도구에 어디서든 접근할 수 있도록 필요한 환경 변수를 설정해 주세요.\nIDE 설정: Flutter 개발을 지원하는 통합 개발 환경(IDE)을 선택해주세요. 인기 있는 옵션은 Flutter 익스텐션을 지원하는 Visual Studio Code, Android Studio 또는 Flutter 플러그인을 가진 IntelliJ IDEA 등이 있습니다. 원하는 IDE를 설치하고 Flutter 개발을 위해 구성하세요.\n새로운 Flutter 프로젝트 생성: 터미널이나 명령 프롬프트를 열고 Flutter의 명령줄 도구를 사용하여 새로운 Flutter 프로젝트를 생성하세요. 다음 명령을 실행하세요: flutter create my_web_app, my_web_app은 원하는 프로젝트 이름으로 대체해주세요. 이 명령은 기본 프로젝트 구조와 필요한 파일을 생성합니다.\n프로젝트 실행: 터미널이나 명령 프롬프트를 사용하여 프로젝트 디렉토리로 이동하고 다음 명령을 사용하여 프로젝트를 실행하세요: cd my_web_app 다음으로 flutter run -d chrome. 이 명령은 Flutter 웹 앱을 구글 크롬에서 실행합니다. 원하는 브라우저로 \"크롬\"을 대체할 수 있습니다.\n개발 시작: 앱이 실행 중이면 lib/main.dart 파일을 수정하여 Flutter 웹 앱을 개발을 시작하세요. 이 파일은 앱의 주 진입점으로 기능합니다. Flutter의 위젯 기반 아키텍처를 활용하여 사용자 인터페이스를 작성하고 상호 작용을 처리하며 상태를 관리하세요.\n\n## Flutter 웹 개발의 미래:\n\nFlutter의 웹 개발로의 확장은 크로스 플랫폼 앱 개발에 흥미로운 가능성을 열었습니다. Flutter를 사용하면 개발자들은 동일한 코드베이스로 네이티브 경험과 유사한 고품질 웹 앱을 만들 수 있습니다.\nFlutter 웹 개발의 미래는 더 많은 모험을 약속합니다. Flutter 팀과 활기찬 개발자 커뮤니티는 계속해서 Flutter의 웹 기능을 개선하고 최적화하여 새로운 기능, 향상된 성능 및 더 나은 툴 지원을 제공합니다. Flutter 생태계는 번창하며 웹 개발에 맞춘 ​​새로운 패키지와 리소스의 수가 증가하고 있습니다.\n\nFlutter가 웹에 대해 성숙해질수록 더 많은 기업과 개발자들이 이 프레임워크를 교차 플랫폼 웹 앱 구축의 기본 선택지로 채택할 것으로 예상됩니다. Flutter의 아름다운 UI 제공, 우수한 성능 및 다중 플랫폼에서 코드 재사용의 능력은 현재와 미래를 고려한 웹 개발에 매력적인 선택지로 만들어줍니다. 결론적으로, Flutter는 교차 플랫폼 앱 개발의 새로운 시대를 열었으며 웹 개발에 완벽하게 통합되어 앱 제작의 미래를 형성할 준비가 되어 있습니다. 숙련된 개발자이든 초심자이든 Flutter는 여러 플랫폼에서 쉽게 앱 아이디어를 현실로 만들기 위한 도구와 능력을 제공합니다.","ogImage":{"url":"/assets/img/2024-06-21-HowToUseFlutterforBuildingCross-PlatformApps_0.png"},"coverImage":"/assets/img/2024-06-21-HowToUseFlutterforBuildingCross-PlatformApps_0.png","tag":["Tech"],"readingTime":3},{"title":"Flutter 웹의 혁신적인 새로운 기능 게임 체인저 ","description":"","date":"2024-06-21 21:05","slug":"2024-06-21-FlutterWebNewFeatureGameChanger","content":"\n\nFlutter WebAssembly: 빠른 웹 앱 만들기\n\n모바일 네이티브 앱처럼 부드럽고 반응성 있는 웹 앱을 원한 적이 있나요? 플러터(WebAssembly와 함께 여러분의 꿈을 현실로 만듭니다!\n\nWebAssembly란?\n\n웹 브라우저가 복잡한 작업을 빠르게 처리할 수 있도록 하는 특별한 코드 형식을 상상해보세요. 그것이 바로 WebAssembly입니다. 이것은 C++과 같은 언어를 웹에서 컴파일하고 실행하여 네이티브 앱과 유사한 성능을 달성할 수 있게 합니다.\n\n<div class=\"content-ad\"></div>\n\n플러터와 웹어셈블리를 함께 사용하는 이유는 무엇일까요?\n\n플러터는 이미 모바일과 데스크탑에서 빠르고 아름다운 UI로 유명합니다. 이제 웹어셈블리를 사용하여 웹 프로젝트에 동일한 속도를 제공할 수 있습니다! 이는 다음을 의미합니다:\n\n- 빠른 성능: 웹어셈블리를 통해 그래픽이 많거나 복잡한 계산이 필요한 웹 앱도 원활하게 실행됩니다.\n- 한 번 작성하고 모든 곳에서 실행: 모바일, 웹, 데스크톱용 단일 코드베이스로 앱을 개발할 수 있습니다.\n- 빠른 개발: 플러터의 핫 리로드를 통해 변경 사항을 즉시 확인할 수 있습니다.\n- 미래를 대비: 웹어셈블리가 지원되어 계속 사용됨으로써 앞으로 뭐가 될지에 대비할 수 있습니다.\n\n시작하기\n\n<div class=\"content-ad\"></div>\n\n시작해볼 준비가 되셨나요? 아래에 간단한 개요가 있어요:\n\n- Flutter 설치: 컴퓨터에 최신 버전이 설치되어 있는지 확인해보세요.\n- 프로젝트 생성: Flutter 명령줄 도구를 사용하여 새 프로젝트를 시작하세요.\n- WebAssembly 구성: 구성 파일에서 WebAssembly을 타겟팅하도록 프로젝트를 설정하세요.\n- 빌드 및 배포: 웹용으로 프로젝트를 빌드하고 웹 서버에 배포하세요.\n\n함께 무언가를 만들어 봐요!\n\n버튼을 누른 횟수를 계속 추적하는 간단한 카운터 앱을 상상해보세요. 이것이 Flutter와 WebAssembly로 만들어진 앱이 보일 것입니다:\n\n<div class=\"content-ad\"></div>\n\n- 새 프로젝트 만들기: Flutter CLI를 사용하여 새 프로젝트를 만듭니다.\n- 코드 작성: 코드는 카운터 변수를 만들고 탭할 때 카운터가 증가하는 버튼을 만드는 과정을 포함할 것입니다.\n- 빌드 및 배포: 위 단계를 따라 앱을 웹에 빌드하고 배포합니다.\n\n미래는 빠릅니다\n\n플러터와 WebAssembly는 웹 개발을 변화시키는 혁신적인 기술입니다. 이러한 기술이 발전함에 따라 더 빠르고 강력한 웹 앱을 기대할 수 있습니다. 그래서 무엇을 기다리고 있나요? 지금 플러터와 WebAssembly로 빠른 웹 앱을 만들기 시작해 보세요!\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/0*DoLvv_b5xizTNwA2.gif\" />","ogImage":{"url":"/assets/img/2024-06-21-FlutterWebNewFeatureGameChanger_0.png"},"coverImage":"/assets/img/2024-06-21-FlutterWebNewFeatureGameChanger_0.png","tag":["Tech"],"readingTime":2},{"title":"Flutter에서 InheritedWidget 사용하기 간단한 카운터 예제","description":"","date":"2024-06-21 21:03","slug":"2024-06-21-UsingInheritedWidgetinFlutterASimpleCounterExample","content":"\n\n\n![사진](/assets/img/2024-06-21-UsingInheritedWidgetinFlutterASimpleCounterExample_0.png)\n\n플러터에서 상태를 관리하는 것은 어렵지만, 특히 여러 위젯 간에 데이터를 공유해야 할 때 더 어려울 수 있습니다. InheritedWidget은 이 문제를 해결하는 데 도움이 되는 플러터의 강력한 기능으로, 위젯이 공유된 데이터에 효율적으로 액세스할 수 있도록 합니다. 이 글에서는 간단한 카운터 예제와 함께 InheritedWidget을 어떻게 사용하는지 살펴보겠습니다.\n\n단계 1: Inherited Widget 생성\n\n먼저, AppState라는 InheritedWidget을 만들겠습니다. 이 위젯은 공유 상태(이 경우 카운터)를 보유하고 이를 하위 항목에 제공할 것입니다.\n\n\n<div class=\"content-ad\"></div>\n\n\n```js\nimport 'package:flutter/material.dart';\n\nclass AppState extends InheritedWidget {\n  final int counter;\n  final Widget child;\n\n  AppState({\n    required this.counter,\n    required this.child,\n  }) : super(child: child);\n\n  static AppState? of(BuildContext context) {\n    return context.dependOnInheritedWidgetOfExactType<AppState>();\n  }\n\n  @override\n  bool updateShouldNotify(AppState oldWidget) {\n    return oldWidget.counter != counter;\n  }\n}\n```\n\nAppState 클래스에서:\n\n- counter와 child를 초기화하는 생성자를 정의합니다.\n- of 메서드는 하위 위젯이 AppState에 액세스할 수 있도록 합니다.\n- updateShouldNotify 메서드는 하위 항목에 변경 사항을 알리는 시점을 결정합니다.\n\n단계 2: State를 관리하는 StatefulWidget 생성\n\n\n<div class=\"content-ad\"></div>\n\n다음으로 상태를 관리하는 StatefulWidget 인 MyApp을 만들겠습니다. 이 위젯은 상태를 업데이트하고 필요할 때 다시 빌드를 트리거할 것입니다.\n\n```js\nclass MyApp extends StatefulWidget {\n  @override\n  _MyAppState createState() => _MyAppState();\n}\n\nclass _MyAppState extends State<MyApp> {\n  int _counter = 0;\n\n  void _incrementCounter() {\n    setState(() {\n      _counter++;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return AppState(\n      counter: _counter,\n      child: MaterialApp(\n        home: Scaffold(\n          appBar: AppBar(\n            title: Text('Inherited Widget demo'),\n          ),\n          body: CounterDisplay(),\n          floatingActionButton: FloatingActionButton(\n            onPressed: _incrementCounter,\n            child: Icon(Icons.add),\n          ),\n        ),\n      ),\n    );\n  }\n}\n```\n\n단계 3: Inherited Widget을 사용하는 위젯 생성\n\n마지막으로, 우리는 InheritedWidget을 사용하여 카운터 값을 액세스하고 표시하는 CounterDisplay라는 StatelessWidget을 만들 것입니다.\n\n<div class=\"content-ad\"></div>\n\n```dart\nclass CounterDisplay extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    final appState = AppState.of(context);\n\n    return Center(\n      child: Text(\n        'Counter: ${appState?.counter}',\n        style: TextStyle(fontSize: 22),\n      ),\n    );\n  }\n}\n```\n\nCounterDisplay 클래스에서:\n\n- AppState를 액세스하고 카운터 값을 검색하려면 of 메서드를 사용합니다.\n- Text 위젯에 카운터 값을 표시합니다.\n\n이 코드를 실행해 봅시다.\n\n\n<div class=\"content-ad\"></div>\n\n앱을 실행하려면 MyApp을 인수로 사용하여 runApp 함수를 호출하겠습니다.\n\n```js\nvoid main() => runApp(MyApp());\n```","ogImage":{"url":"/assets/img/2024-06-21-UsingInheritedWidgetinFlutterASimpleCounterExample_0.png"},"coverImage":"/assets/img/2024-06-21-UsingInheritedWidgetinFlutterASimpleCounterExample_0.png","tag":["Tech"],"readingTime":3},{"title":"Flutter  Firebase로 푸시 알림 구현하는 완벽 가이드","description":"","date":"2024-06-21 21:01","slug":"2024-06-21-FlutterFirebasePushNotificationsCompleteGuide","content":"\n\n<img src=\"/assets/img/2024-06-21-FlutterFirebasePushNotificationsCompleteGuide_0.png\" />\n\n# 푸시 알림이란 무엇인가요?\n\n푸시 알림은 모바일 앱이나 웹사이트에서 기기로 보내는 메시지로, 기기가 활발하게 사용되지 않는 경우에도 전송됩니다. 일반적으로 사용자에게 새로운 콘텐츠나 기능을 알리거나 관심이 있을 수 있는 내용을 상기시키기 위해 사용됩니다.\n\n# 모바일 앱 개발에서 푸시 알림의 장점은 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n- 사용자 참여 향상: 푸시 알림을 통해 사용자가 앱에 계속해서 참여하도록 유도할 수 있습니다. 사용자가 앱을 활발하게 사용하지 않을 때에도 이를 통해 전반적인 앱 사용량과 인기를 증가시킬 수 있습니다.\n- 유지율 증가: 푸시 알림을 통해 사용자에게 앱을 상기시킬 수 있어, 유지율을 높이고 앱을 제거하는 사용자 수를 줄일 수 있습니다.\n- 타겟팅 메시징: 푸시 알림은 사용자의 관심사나 행동을 기반으로 특정 사용자나 그룹을 대상으로 할 수 있습니다. 이를 통해 앱 개발자는 사용자에게 개인화되고 관련성 높은 메시지를 보낼 수 있어 알림의 효과를 높일 수 있습니다.\n- 수익 증대: 푸시 알림을 통해 인앱 구매나 기타 수익화 기회를 홍보할 수 있어, 앱 개발자의 수익을 향상시킬 수 있습니다.\n- 고객 서비스 향상: 푸시 알림을 통해 업데이트나 경고와 같은 시기적절하고 관련성 있는 정보를 제공할 수 있습니다. 이를 통해 전반적인 고객 경험과 앱에 대한 만족도를 향상시킬 수 있습니다.\n\n# Firebase Cloud Messaging (FCM)이란?\n\n![이미지](/assets/img/2024-06-21-FlutterFirebasePushNotificationsCompleteGuide_1.png)\n\nFirebase에 따르면, FCM은 무료로 메시지를 신뢰할 수 있게 전송할 수 있는 크로스 플랫폼 메시징 솔루션이라고 합니다.\n\n<div class=\"content-ad\"></div>\n\nFCM은 Android, iOS 및 웹 사용자에게 메시지와 알림을 보낼 수 있는 크로스 플랫폼 메시징 솔루션입니다. 구글은 FCM을 Firebase 스위트의 일부로 제공하여 모바일 앱 개발을 위한 도구 및 서비스를 제공합니다.\n\nFCM을 사용하면 사용자 관심사, 앱 사용 방식 및 위치에 따라 특정 기기 또는 기기 그룹에 메시지를 보낼 수 있습니다. 알림, 푸시 알림 및 데이터 페이로드를 포함한 다양한 유형의 메시지를 보낼 수 있습니다. FCM은 또한 메시지 예약, 기기 그룹 관리 및 분석과 같은 기능을 제공합니다.\n\nFCM은 기존 앱 인프라와 쉽게 통합되고 사용하기 쉽게 설계되었습니다. 간단한 API를 사용하며 Firebase Analytics와 같은 다른 Firebase 서비스와 통합하여 모바일 앱 개발을 위한 포괄적인 도구 세트를 제공합니다.\n\n# 플러터 앱에서 Firebase FCM을 통해 푸시 알림을 수신하는 방법 — 구현\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-21-FlutterFirebasePushNotificationsCompleteGuide_2.png)\n\n플러터와 FCM에서 3가지 디바이스 상태\n\n- Foreground(전경): 어플리케이션이 열려 있고 보여지며 사용 중일 때입니다.\n- Background(최소화): 사용자가 장치에서 \"홈\" 버튼을 누르거나 앱 전환기를 통해 다른 앱으로 전환하거나 다른 탭(웹)에서 앱을 열었을 때 보통 발생합니다.\n- Terminated(종료됨): 장치가 잠겨 있거나 어플리케이션이 실행되지 않을 때입니다. 사용자는 장치의 앱 전환기 UI를 통해 앱을 닫거나 탭(웹)을 닫아 어플리케이션을 종료할 수 있습니다.\n\n이 프로세스가 어떻게 작동하는지 보려면 이 동영상을 시청해보세요.\n\n\n<div class=\"content-ad\"></div>\n\n구현 단계\n\n- CMD에서\n\n- Node.js를 다운로드 및 설치하십시오. https://nodejs.org/en/\n- firebase 도구 설치: npm install -g firebase-tools (CMD)\n- \"firebase login\"을 실행하고 Google 계정을 선택하십시오 (CMD)\n\n2. 플러터 프로젝트 터미널에서\n\n<div class=\"content-ad\"></div>\n\n- 그런 다음 플러터 프로젝트를 열고 터미널에서 다음 명령을 실행하세요\n- dart pub global activate flutterfire_cli\n- flutterfire configure (만약 이 명령이 \"flutterfire가 인식되지 않습니다.\"와 같은 오류를 발생시킨다면, 시스템 환경 변수에 \"C:\\Users\\*사용자명*\\AppData\\Local\\Pub\\Cache\\bin\"을 새 항목으로 추가해야 합니다. 이제 오류 없이 명령을 실행할 수 있어야 합니다.) \n\n3. Firebase 콘솔에서\n\n- 새 Firebase 프로젝트를 생성하고 Firebase FCM(메시징/클라우드 메시징으로도 알려짐)를 활성화하세요.\n\n4. 그런 다음 플러터 프로젝트의 main.dart에 다음 종속성을 추가하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\n// 의존성\nimport 'package:firebase_core/firebase_core.dart';\nimport '/firebase_options.dart'; // 이 파일은 \"flutterfire config\" 명령어로 생성됩니다.\nimport 'package:firebase_messaging/firebase_messaging.dart';\n```\n\n5. 이제 main.dart에 다음 라인을 추가하여 Firebase Messaging을 초기화합니다.\n\n```js\n// 초기화\nWidgetsFlutterBinding.ensureInitialized();\n\nawait Firebase.initializeApp(\n  options: DefaultFirebaseOptions.currentPlatform,\n);\n\nFirebaseMessaging messaging = FirebaseMessaging.instance;\n\nNotificationSettings settings = await messaging.requestPermission(\n  alert: true,\n  announcement: false,\n  badge: true,\n  carPlay: false,\n  criticalAlert: false,\n  provisional: false,\n  sound: true,\n);\n\nprint('사용자가 허용한 권한: ${settings.authorizationStatus}');\n```\n\n6. 이제 main.dart에 다음 라인을 추가하여 \"백그라운드 메시지\"를 받습니다.\n\n\n<div class=\"content-ad\"></div>\n\n```dart\n// 백그라운드 메시지 수신\nFuture<void> _firebaseMessagingBackgroundHandler(RemoteMessage message) async {\n  await Firebase.initializeApp();\n  print(\"백그라운드 메시지 처리 중: ${message.messageId}\");\n}\n```\n\n```dart\n// 백그라운드 메시지 수신 대기\nWidgetsFlutterBinding.ensureInitialized();\nFirebaseMessaging.onBackgroundMessage(_firebaseMessagingBackgroundHandler);\n```\n\n7. 그런 다음 main.dart에 다음 줄을 추가하여 \"전경 메시지\"를 받습니다.\n\n```dart\n// 전경 메시지 수신\nFirebaseMessaging.onMessage.listen((RemoteMessage message) {\n  print('전경에서 메시지를 받았어요!');\n  print('메시지 데이터: ${message.data}');\n\n  if (message.notification != null) {\n    print('메시지에 알림도 포함되어 있어요: ${message.notification}');\n  }\n});\n```\n\n<div class=\"content-ad\"></div>\n\n# 중요\n\n- (공통):\n- 클라우드 메시징 패키지는 애플리케이션을 Firebase Cloud Messaging (FCM) 서비스에 연결합니다.\n- 메시지 페이로드를 무료로 디바이스로 직접 보낼 수 있습니다.\n- 각 메시지 페이로드는 최대 4KB까지 가능합니다.\n- (iOS 전용):\n- iOS 플랫폼에서 Firebase 메시징을 테스트하려면 실제 디바이스가 필요합니다.\n\n# 받을 수 있는 3가지 메시지 유형\n\n메시지 페이로드를 세 가지 유형 중 하나로 볼 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n- 알림 전용 메시지: 페이로드에는 사용자에게 표시되는 알림 속성이 포함되어 있습니다.\n- 데이터 전용 메시지: \"silent message\"로도 알려진 이 페이로드에는 데이터 속성 내에 사용자가 필요에 따라 사용할 수 있는 사용자 정의 키/값 쌍이 포함되어 있습니다. 이러한 메시지는 \"우선 순위가 낮음\"으로 간주됩니다(나중에 더 자세히 설명합니다).\n- 알림 및 데이터 메시지: 알림 및 데이터 속성을 모두 포함하는 페이로드입니다.\n\n# 상호 작용 처리\n\n알림은 사용자에게 보이는 신호이므로 사용자가 해당 신호에 상호 작용하는 것이 일반적입니다(눌러서). Android 및 iOS 모두의 기본 동작은 애플리케이션을 열도록 하는 것입니다. 애플리케이션이 종료된 경우 시작되고, 백그라운드 상태인 경우 화면으로 가져옵니다.\n\n알림의 내용에 따라 애플리케이션이 열릴 때 사용자 상호 작용을 처리하고 싶을 수 있습니다. 예를 들어, 알림을 통해 새로운 채팅 메시지가 전송되고 사용자가 그것을 누른 경우, 애플리케이션이 열릴 때 특정 대화를 열도록 하고 싶을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nfirebase-messaging 패키지는 이 상호작용을 다루는 두 가지 방법을 제공합니다:\n\n- getInitialMessage(): 애플리케이션이 종료된 상태에서 열리면 RemoteMessage가 포함된 Future가 반환됩니다. RemoteMessage를 사용하면 해당 메시지는 제거됩니다.\n- onMessageOpenedApp: 백그라운드 상태에서 애플리케이션이 열릴 때 RemoteMessage를 게시하는 Stream입니다.\n\n사용자에 대한 원활한 사용자 경험을 위해 두 시나리오를 모두 처리하는 것이 좋습니다. 아래의 코드 예시는 이를 어떻게 달성할 수 있는지 보여줍니다:\n\n```js\nclass Application extends StatefulWidget {\n  @override\n  State<StatefulWidget> createState() => _Application();\n}\n\nclass _Application extends State<Application> {\n  // 모든 메시지에 'type' 키를 포함하는 데이터 필드가 있다고 가정합니다.\n  Future<void> setupInteractedMessage() async {\n    // 애플리케이션이 종료된 상태에서 열린 이유가 된 메시지를 가져옵니다.\n    RemoteMessage? initialMessage =\n        await FirebaseMessaging.instance.getInitialMessage();\n\n    // 메시지가 'type'이 'chat'인 데이터 속성도 포함하고 있다면\n    // 채팅 화면으로 이동합니다.\n    if (initialMessage != null) {\n      _handleMessage(initialMessage);\n    }\n\n    // 애플리케이션이 백그라운드에 있을 때 상호작용을 다루기 위해 \n    // Stream 리스너를 통해 처리합니다.\n    FirebaseMessaging.onMessageOpenedApp.listen(_handleMessage);\n  }\n  \n  void _handleMessage(RemoteMessage message) {\n    if (message.data['type'] == 'chat') {\n      Navigator.pushNamed(context, '/chat', \n        arguments: ChatArguments(message),\n      );\n    }\n  }\n\n  @override\n  void initState() {\n    super.initState();\n\n    // initState()이 비동기일 수 없기 때문에 상호작용하는 메시지를 다루는 \n    // 코드를 비동기 함수에서 실행합니다.\n    setupInteractedMessage();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Text(\"...\");\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n# 특정 화면으로 이동하는 방법\n\n```js\nvoid _handleMessage(RemoteMessage message) {\n    // 메시지 객체 내용 확인\n    RemoteNotification? notification = message.notification;\n    //AndroidNotification? android = message.notification?.android;\n\n    print(\"notification: $notification\");\n    print(\"message data: ${message.data}\");\n\n    Get.toNamed(Routes.getNotificationDetailScreen(), arguments: [\n      {\"message\": message}\n    ]);\n}\n\n// 상호 작용 처리\nFirebaseMessaging.onMessageOpenedApp.listen(_handleMessage);\n```\n\n![이미지 1](/assets/img/2024-06-21-FlutterFirebasePushNotificationsCompleteGuide_3.png)\n\n![이미지 2](/assets/img/2024-06-21-FlutterFirebasePushNotificationsCompleteGuide_4.png)\n\n<div class=\"content-ad\"></div>\n\n## 참고 자료:\n\n- https://www.youtube.com/watch?v=3lsP1jZNqjE\n- https://stackoverflow.com/questions/70320263/the-term-flutterfire-is-not-recognized-as-the-name-of-a-cmdlet-function-scri\n- https://firebase.flutter.dev/docs/cli/\n- https://firebase.google.com/docs/cli#install-cli-windows\n- https://firebase.flutter.dev/docs/overview/\n- https://medium.com/@rysesoft/flutter-push-notification-with-fcm-6e7a95f5abb6\n- https://firebase.flutter.dev/docs/messaging/apple-integration/\n- https://www.youtube.com/watch?v=54vgoPgB8xE\n- https://pub.dev/packages/flutterfire_cli/install\n- https://pub.dev/packages/firebase_core/install\n- https://www.youtube.com/watch?v=2tjuUwNx6qk\n- https://firebase.flutter.dev/docs/messaging/usage/\n- https://medium.com/firebase-developers/flutter-fcm-how-to-navigate-to-a-particular-screen-after-tapping-on-push-notification-8cb5d5111ee6\n- https://pub.dev/packages/flutter_local_notifications\n- https://firebase.flutter.dev/docs/messaging/usage/\n- https://pub.dev/documentation/firebase_messaging_platform_interface/latest/firebase_messaging_platform_interface/RemoteMessage-class.html\n- https://firebase.google.com/docs/cloud-messaging/flutter/receive","ogImage":{"url":"/assets/img/2024-06-21-FlutterFirebasePushNotificationsCompleteGuide_0.png"},"coverImage":"/assets/img/2024-06-21-FlutterFirebasePushNotificationsCompleteGuide_0.png","tag":["Tech"],"readingTime":9}],"page":"8","totalPageCount":20,"totalPageGroupCount":1,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}