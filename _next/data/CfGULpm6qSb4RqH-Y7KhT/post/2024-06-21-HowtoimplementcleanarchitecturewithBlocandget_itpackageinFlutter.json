{"pageProps":{"post":{"title":"Flutter에서 Bloc과 get_it 패키지를 사용하여 클린 아키텍처 구현하는 방법","description":"","date":"2024-06-21 21:16","slug":"2024-06-21-HowtoimplementcleanarchitecturewithBlocandget_itpackageinFlutter","content":"\n\n이 기사에서는 get_it 패키지를 서비스 로케이터로, Bloc를 상태 관리로 사용하여 클린 아키텍처를 구현하는 방법을 가르쳐 드리겠습니다. 이를 통해 책임을 분리하고, 앱이 점점 커지고 복잡해짐에 따라 새로운 기능을 더 잘 유지하고 코드를 이해하기 쉽게 유지할 수 있습니다.\n\n다음 이미지에서 보듯이, 우리는 클린 아키텍처 레이어를 기반으로 기본 파일 시스템을 생성하는 방법에 대해 알아볼 것입니다.\n\n![이미지](/assets/img/2024-06-21-HowtoimplementcleanarchitecturewithBlocandget_itpackageinFlutter_0.png)\n\n프로젝트의 요구 사항에 따라이 파일 시스템이 변경될 수 있다는 점을 고려해야 합니다. 일부 개발자는 작은 앱에서 작업할 때 도메인 레이어를 사용하지 않는 경우가 있습니다. 이 경우에는 사용 사례와 리포지토리를 통해 비즈니스 로직을 추상화하는 데 도움이 될 것이므로 사용하겠습니다.\n\n<div class=\"content-ad\"></div>\n\n# 브레이킹 배드 앱\n\nBloc 및 get_it 패키지를 사용하여 청결한 아키텍처를 배우기 위해, 우리는 Breaking Bad Quotes API(https://api.breakingbadquotes.xyz/v1/quotes)를 사용하는 간단한 앱을 만들 것입니다. 이 API를 통해 Breaking Bad에서 랜덤 명언을 얻을 수 있습니다. 사용하기 매우 쉽고 응답은 명언과 저자가 포함된 객체가 있는 간단한 목록입니다.\n\n좋아요, 시작해 봅시다! API를 사용하면 다음과 같이 간단한 응답을 받게 됩니다.\n\n```js\n[\n  {\n    \"quote\": \"Congratulations, you’ve just left your family a second-hand Subaru.\",\n    \"author\": \"Saul Goodman\"\n  }\n]\n```\n\n<div class=\"content-ad\"></div>\n\n클린 아키텍처를 구현하려면 도메인 레이어부터 시작하는 것이 좋습니다. 이 레이어는 추상 리포지토리를 주입한 유스케이스를 통해 데이터와 프레젠테이션 레이어 사이의 다리 역할을 합니다.\n\n# 응답 엔티티\n\n우선 엔티티를 만들 것인데, 이는 앱에서 가장 간단한 객체를 나타냅니다. 모든 엔티티와 모델을 Equatable에서 확장하여 객체를 문제없이 비교하고, 앱의 테스트를 개선하며, 상태에서 원치 않는 동작을 피할 수 있도록 해야 합니다.\n\n```dart\nimport 'package:equatable/equatable.dart';\n\nclass QuoteEntitie extends Equatable {\n\n  final String? quote;\n  final String? author;\n\n  const QuoteEntitie({\n    this.quote,\n    this.author,\n  });\n\n  @override\n  List<Object?> get props => [\n    quote,\n    author,\n  ];\n}\n```\n\n<div class=\"content-ad\"></div>\n\n# 추상 저장소\n\n이제 우리는 리포지토리를 구현하는 모든 클래스에 대해 getQuote() 함수를 강제시키는 계약으로 작용하는 추상 클래스를 통해 엔티티를 반환해야 합니다. 이 구현은 나중에 확인하겠습니다. API 서비스가 비동기 데이터를 반환하기 때문에 Future를 사용합니다.\n\n```js\nabstract class QuoteRepository{\n  Future<QuoteEntitie> getQuote();\n}\n```\n\n# 사용 사례\n\n<div class=\"content-ad\"></div>\n\n다음으로, 우리는 리포지토리를 생성자를 통해 주입하는 유스 케이스를 만들 것입니다. 이 유스 케이스는 데이터 레이어와 프레젠테이션 레이어 사이의 다리 역할을 하며 새로운 상태를 발신하는 상태 관리에 중요한 역할을 합니다.\n\n```dart\nclass QuoteUsecase {\n\n  final QuoteRepository _quoteRepository;\n\n  QuoteUsecase(this._quoteRepository);\n\n  Future<QuoteEntity> getQuote() {\n    return _quoteRepository.getQuote();\n  }\n}\n```\n\n이 시점에서, 도메인 레이어를 구현합니다. 파일 시스템은 다음과 같이 보여야 합니다:\n\n![image](/assets/img/2024-06-21-HowtoimplementcleanarchitecturewithBlocandget_itpackageinFlutter_1.png)\n\n<div class=\"content-ad\"></div>\n\n이제 데이터 레이어를 구현할 차례입니다. 이름에서 알 수 있듯이 데이터 레이어는 다른 소스(우리 경우 API)에서 데이터를 관리하고 도메인 레이어와 상호 작용하여 프리젠테이션 레이어가 필요로 하는 모든 데이터를 제공합니다.\n\n# 모델 응답\n\n모델 폴더를 앱의 요구에 따라 나눌 수 있습니다. 이 경우 API 응답 모델을 위한 폴더와 API 요청 모델을 위한 폴더 두 개로 나누겠습니다. 우리 앱에서는 API 응답을 위한 모델 하나만 필요하겠지만요. 또한, 객체를 비교할 수 있도록 Equatable에서 모델을 확장하고 엔티티를 구현하는 것을 기억해주세요.\n\n```js\nclass QuoteResponseModel extends Equatable implements QuoteEntitie {\n  @override\n  final String? quote;\n  @override\n  final String? author;\n\n  const QuoteResponseModel({\n    this.quote,\n    this.author,\n  });\n\n  QuoteResponseModel copyWith({\n    String? quote,\n    String? author,\n  }) =>\n      QuoteResponseModel(\n        quote: quote ?? this.quote,\n        author: author ?? this.author,\n      );\n\n  factory QuoteResponseModel.fromRawJson(String str) =>\n      QuoteResponseModel.fromJson(json.decode(str)[0]);\n\n\n  factory QuoteResponseModel.fromJson(Map<String, dynamic> json) =>\n      QuoteResponseModel(\n        quote: json[\"quote\"],\n        author: json[\"author\"],\n      );\n\n  @override\n  List<Object?> get props => [\n        quote,\n        author,\n      ];\n}\n```\n\n<div class=\"content-ad\"></div>\n\n# 데이터 소스\n\n데이터 소스를 만들어 봅시다. 이는 필요에 따라 데이터를 가져오는 프로세스를 처리합니다. 이 예시에서는 API에서 데이터를 가져와 모든 것이 문제없이 진행되면 응답 객체를 생성하거나 오류가 발생하면 예외를 throw합니다. 보시다시피, 우리는 먼저 추상 클래스를 작성하여 추상 로직을 만듭니다. 이후 이 클래스의 구현은 선택한 클라이언트를 사용하여 데이터를 가져오는 책임을 갖게 됩니다. 이 경우 HTTP 클라이언트는 나중에 get_it 패키지를 사용하여 주입될 것입니다.\n\n```js\nimport 'package:http/http.dart' as http;\n\nabstract class QuoteDataSource {\n  Future<QuoteResponseModel> getQuote();\n}\n\nclass QuoteDataSourceImpl implements QuoteDataSource {\n  final http.Client _client;\n\n  QuoteDataSourceImpl(this._client);\n\n  @override\n  Future<QuoteResponseModel> getQuote() async {\n    final Uri url = Uri.https('api.breakingbadquotes.xyz', '/v1/quotes');\n    final http.Response response = await _client.get(url);\n    if (response.statusCode == 200) {\n      final QuoteResponseModel quoteResponseModel =\n          QuoteResponseModel.fromRawJson(response.body);\n      return quoteResponseModel;\n    } else {\n      throw Exception();\n    }\n  }\n}\n```\n\n# 저장소 구현\n\n<div class=\"content-ad\"></div>\n\n데이터 소스를 생성한 후, 이전에 만든 추상 리포지토리를 구현해야 합니다. 이는 구현 클래스의 생성자에 데이터 소스를 주입하고 추상 리포지토리 함수를 오버라이딩하여 달성할 수 있습니다.\n\n```js\nclass QuoteRepositoryImpl implements QuoteRepository{\n\n  final QuoteDataSource _dataSource;\n\n  QuoteRepositoryImpl(this._dataSource);\n\n  @override\n  Future<QuoteEntitie> getQuote() async{\n    return await _dataSource.getQuote();\n  }\n\n}\n```\n\n이 시점에서 애플리케이션에서 모든 것이 정상적으로 작동하는지 간단하게 테스트할 수 있습니다. FutureBuilder 위젯을 사용하여 API 정보를 검색하고 직접 의존성 주입을 통해 use case 객체를 만들어 확인할 수 있습니다.\n\n```js\nvoid main() => runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  MyApp({super.key});\n\n  final useCase = QuoteUsecase(QuoteRepositoryImpl(QuoteDataSourceImpl()));\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      debugShowCheckedModeBanner: false,\n      title: 'Quote App',\n      home: Scaffold(\n        appBar: AppBar(),\n        body: Center(\n          child: FutureBuilder(\n            future: useCase.getQuote(),\n            builder:\n                (BuildContext context, AsyncSnapshot<QuoteEntitie> snapshot) {\n              return Column(\n                children: [\n                  Text(\"${snapshot.data?.quote}\"),\n                  Text(\"${snapshot.data?.quote}\"),\n                ],\n              );\n            },\n          ),\n        ),\n      ),\n    );\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n하지만 이 방식에는 유지 및 확장이 어려워지고, 앱이 추가 기능과 함께 복잡해질수록 문제가 발생할 수 있습니다. 이를 해결하기 위해 홈 화면을 다른 파일로 분리하고, 서비스 로케이터 메서드를 생성하여 Bloc을 사용하여 상태를 관리할 것입니다.\n\n# Bloc 생성\n\n알다시피 Flutter 애플리케이션에서 Bloc을 구현하려면 상태 파일, 이벤트 파일, 그리고 이벤트를 기반으로 상태를 발행하는 Bloc 파일을 생성해야 합니다. 이 경우 API가 데이터를 가져오기 시작할 때와 완료될 때 피드백을 제공하는 간단한 로직 상태가 있습니다. 따라서 로딩 중인지와 견적이 이용 가능한지를 나타내는 상태가 있을 것입니다.\n\n```js\nclass QuoteBlocState extends Equatable {\n\n  final bool? isLoadingQuote;\n  final QuoteEntitie? quote;\n\n  const QuoteBlocState({this.isLoadingQuote, this.quote});\n\n  QuoteBlocState copyWith({\n    bool? isLoadingQuote,\n    QuoteEntitie? quote\n    }) {\n    return QuoteBlocState(\n      isLoadingQuote: isLoadingQuote ?? this.isLoadingQuote,\n      quote: quote ?? this.quote,\n    );\n  }\n\n  @override\n  List<Object?> get props => [\n    isLoadingQuote,\n    quote\n    ];\n}\n```\n\n<div class=\"content-ad\"></div>\n\n```js\nsealed class QuoteBlocEvent extends Equatable {\n  const QuoteBlocEvent();\n\n  @override\n  List<Object> get props => [];\n}\n\nfinal class GetQuouteEvent extends QuoteBlocEvent{\n  const GetQuouteEvent();\n}\n```\n\n```js\nclass QuoteBloc extends Bloc<QuoteBlocEvent, QuoteBlocState> {\n\n  final QuoteUsecase _quoteUsecase;\n\n  QuoteBloc(this._quoteUsecase) : super(const QuoteBlocState()) {\n    on<GetQuouteEvent>(_getQuote);\n  }\n\n  FutureOr<void> _getQuote(\n      GetQuouteEvent event, Emitter<QuoteBlocState> emit) async {\n    emit(state.copyWith(isLoadingQuote: true));\n    final QuoteEntitie response = await _quoteUsecase.getQuote();\n    emit(state.copyWith(quote: response, isLoadingQuote: false));\n  }\n}\n```\n\n여기서는 use case가 생성자로 주입되어 getQuote() 함수를 사용할 수 있도록 되어 있다는 점을 강조하는 것이 매우 중요합니다.\n\n우리의 기본 아키텍처를 완성하기 위해 필요한 유일한 것은 서비스를 위한 초기화(init) 함수를 만드는 것입니다. 이 함수를 통해 앱 전체에서 필요한 경우 서비스를 사용할 수 있습니다. get_it 패키지를 사용하면 이를 매우 간단하게 만들 수 있습니다. 아래와 같은 함수를 만드는 것만 필요합니다:\n\n<div class=\"content-ad\"></div>\n\n```dart\n최종 getIt = GetIt.instance;\n\nvoid initServices() {\n\n  이제 http.Client client = getIt.registerSingleton(http.Client());\n\n  이제 QuoteDataSourceImpl quoteDataSourceImpl =\n      getIt.registerSingleton(QuoteDataSourceImpl(client));\n\n  이제 QuoteRepositoryImpl quoteRepositoryImpl =\n      getIt.registerSingleton(QuoteRepositoryImpl(quoteDataSourceImpl));\n\n  이제 QuoteUsecase quoteUsecase =\n      getIt.registerSingleton(QuoteUsecase(quoteRepositoryImpl));\n\n  getIt.registerFactory(() => QuoteBloc(quoteUsecase));\n}\n```\n\nmain 함수에서 runApp() 이전에 initServices() 함수를 호출하여 애플리케이션의 모든 부분이 인스턴스에 액세스할 수 있도록 합니다.\n\n```dart\nvoid main() {\n  intServices();\n  runApp(const MyApp());\n}\n```\n\n이 시점에서 Bloc을 사용한 상태 관리 및 이미 설정된 서비스 로케이터를 사용하여 표현 레이어가 이렇게 보여야 합니다. 화면을 독립적인 파일로 분리하는 것을 잊지 마세요.\n\n\n<div class=\"content-ad\"></div>\n\n\n![How to Implement Clean Architecture with Bloc and get_it Package in Flutter 2](/assets/img/2024-06-21-HowtoimplementcleanarchitecturewithBlocandget_itpackageinFlutter_2.png)\n\n마지막으로, 관심 분리를 위해 홈 화면은 작은 위젯으로, 랜덤 인용구와 그 저자를 표시하는 컬럼이 있습니다. 또한, API에서 새 데이터를 가져와 다른 인용구를 검색하는 버튼이 있습니다. 데이터를 가져오는 동안에는 CircularProgressIndicator 위젯을 표시합니다.\n\n```dart\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({Key? key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(),\n      body: const Center(child: _QuoteWidget()),\n    );\n  }\n}\n\nclass _QuoteWidget extends StatelessWidget {\n  const _QuoteWidget();\n\n  @override\n  Widget build(BuildContext context) {\n    return Builder(builder: (context) {\n      final QuoteBlocState state = context.select((QuoteBloc bloc) => bloc.state);\n      final bool? isLoading = state.isLoadingQuote;\n      final QuoteEntity? quote = state.quote;\n\n      if (isLoading == true) {\n        return const Center(\n          child: CircularProgressIndicator(),\n        );\n      }\n\n      return Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          Text(\"${quote?.quote}\"),\n          Text(\"${quote?.author}\"),\n          ElevatedButton(\n              onPressed: () {\n                context.read<QuoteBloc>().add(const GetQuoteEvent());\n              },\n              child: const Text(\"Get another quote\"))\n        ],\n      );\n    });\n  }\n}\n```\n\n마지막 단계는 Bloc을 get_it을 사용하여 필요한 위치에 주입하는 것입니다. QuouteBloc의 인스턴스가 서비스 로케이터를 사용하여 위젯 트리에 주입되는 점에 유의하십시오. 마지막으로, Bloc 인스턴스가 생성된 후 인용구를 가져오고 새 상태를 발생시키는 이벤트를 호출하기 위해 연속 연산자를 사용하세요.\n\n\n<div class=\"content-ad\"></div>\n\n```dart\nclass MyApp extends StatelessWidget {\n  const MyApp({Key key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n        debugShowCheckedModeBanner: false,\n        title: 'Quote App',\n        home: BlocProvider(\n          create: (context) => getIt<QuoteBloc>()..add(const GetQuouteEvent()),\n          child: Builder(builder: (context) {\n            return const HomeScreen();\n          }),\n        ));\n  }\n}\n```\n\n그러니까 이제 앱을 실행시켜서 코딩의 매력을 만끽해보세요.\n\n![image](/assets/img/2024-06-21-HowtoimplementcleanarchitecturewithBlocandget_itpackageinFlutter_3.png)\n","ogImage":{"url":"/assets/img/2024-06-21-HowtoimplementcleanarchitecturewithBlocandget_itpackageinFlutter_0.png"},"coverImage":"/assets/img/2024-06-21-HowtoimplementcleanarchitecturewithBlocandget_itpackageinFlutter_0.png","tag":["Tech"],"readingTime":11},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>이 기사에서는 get_it 패키지를 서비스 로케이터로, Bloc를 상태 관리로 사용하여 클린 아키텍처를 구현하는 방법을 가르쳐 드리겠습니다. 이를 통해 책임을 분리하고, 앱이 점점 커지고 복잡해짐에 따라 새로운 기능을 더 잘 유지하고 코드를 이해하기 쉽게 유지할 수 있습니다.</p>\n<p>다음 이미지에서 보듯이, 우리는 클린 아키텍처 레이어를 기반으로 기본 파일 시스템을 생성하는 방법에 대해 알아볼 것입니다.</p>\n<p><img src=\"/assets/img/2024-06-21-HowtoimplementcleanarchitecturewithBlocandget_itpackageinFlutter_0.png\" alt=\"이미지\"></p>\n<p>프로젝트의 요구 사항에 따라이 파일 시스템이 변경될 수 있다는 점을 고려해야 합니다. 일부 개발자는 작은 앱에서 작업할 때 도메인 레이어를 사용하지 않는 경우가 있습니다. 이 경우에는 사용 사례와 리포지토리를 통해 비즈니스 로직을 추상화하는 데 도움이 될 것이므로 사용하겠습니다.</p>\n<h1>브레이킹 배드 앱</h1>\n<p>Bloc 및 get_it 패키지를 사용하여 청결한 아키텍처를 배우기 위해, 우리는 Breaking Bad Quotes API(<a href=\"https://api.breakingbadquotes.xyz/v1/quotes)%EB%A5%BC\" rel=\"nofollow\" target=\"_blank\">https://api.breakingbadquotes.xyz/v1/quotes)를</a> 사용하는 간단한 앱을 만들 것입니다. 이 API를 통해 Breaking Bad에서 랜덤 명언을 얻을 수 있습니다. 사용하기 매우 쉽고 응답은 명언과 저자가 포함된 객체가 있는 간단한 목록입니다.</p>\n<p>좋아요, 시작해 봅시다! API를 사용하면 다음과 같이 간단한 응답을 받게 됩니다.</p>\n<pre><code class=\"hljs language-js\">[\n  {\n    <span class=\"hljs-string\">\"quote\"</span>: <span class=\"hljs-string\">\"Congratulations, you’ve just left your family a second-hand Subaru.\"</span>,\n    <span class=\"hljs-string\">\"author\"</span>: <span class=\"hljs-string\">\"Saul Goodman\"</span>\n  }\n]\n</code></pre>\n<p>클린 아키텍처를 구현하려면 도메인 레이어부터 시작하는 것이 좋습니다. 이 레이어는 추상 리포지토리를 주입한 유스케이스를 통해 데이터와 프레젠테이션 레이어 사이의 다리 역할을 합니다.</p>\n<h1>응답 엔티티</h1>\n<p>우선 엔티티를 만들 것인데, 이는 앱에서 가장 간단한 객체를 나타냅니다. 모든 엔티티와 모델을 Equatable에서 확장하여 객체를 문제없이 비교하고, 앱의 테스트를 개선하며, 상태에서 원치 않는 동작을 피할 수 있도록 해야 합니다.</p>\n<pre><code class=\"hljs language-dart\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'package:equatable/equatable.dart'</span>;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">QuoteEntitie</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Equatable</span> </span>{\n\n  <span class=\"hljs-keyword\">final</span> <span class=\"hljs-built_in\">String?</span> quote;\n  <span class=\"hljs-keyword\">final</span> <span class=\"hljs-built_in\">String?</span> author;\n\n  <span class=\"hljs-keyword\">const</span> QuoteEntitie({\n    <span class=\"hljs-keyword\">this</span>.quote,\n    <span class=\"hljs-keyword\">this</span>.author,\n  });\n\n  <span class=\"hljs-meta\">@override</span>\n  <span class=\"hljs-built_in\">List</span>&#x3C;<span class=\"hljs-built_in\">Object?</span>> <span class=\"hljs-keyword\">get</span> props => [\n    quote,\n    author,\n  ];\n}\n</code></pre>\n<h1>추상 저장소</h1>\n<p>이제 우리는 리포지토리를 구현하는 모든 클래스에 대해 getQuote() 함수를 강제시키는 계약으로 작용하는 추상 클래스를 통해 엔티티를 반환해야 합니다. 이 구현은 나중에 확인하겠습니다. API 서비스가 비동기 데이터를 반환하기 때문에 Future를 사용합니다.</p>\n<pre><code class=\"hljs language-js\">abstract <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">QuoteRepository</span>{\n  <span class=\"hljs-title class_\">Future</span>&#x3C;<span class=\"hljs-title class_\">QuoteEntitie</span>> <span class=\"hljs-title function_\">getQuote</span>();\n}\n</code></pre>\n<h1>사용 사례</h1>\n<p>다음으로, 우리는 리포지토리를 생성자를 통해 주입하는 유스 케이스를 만들 것입니다. 이 유스 케이스는 데이터 레이어와 프레젠테이션 레이어 사이의 다리 역할을 하며 새로운 상태를 발신하는 상태 관리에 중요한 역할을 합니다.</p>\n<pre><code class=\"hljs language-dart\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">QuoteUsecase</span> </span>{\n\n  <span class=\"hljs-keyword\">final</span> QuoteRepository _quoteRepository;\n\n  QuoteUsecase(<span class=\"hljs-keyword\">this</span>._quoteRepository);\n\n  Future&#x3C;QuoteEntity> getQuote() {\n    <span class=\"hljs-keyword\">return</span> _quoteRepository.getQuote();\n  }\n}\n</code></pre>\n<p>이 시점에서, 도메인 레이어를 구현합니다. 파일 시스템은 다음과 같이 보여야 합니다:</p>\n<p><img src=\"/assets/img/2024-06-21-HowtoimplementcleanarchitecturewithBlocandget_itpackageinFlutter_1.png\" alt=\"image\"></p>\n<p>이제 데이터 레이어를 구현할 차례입니다. 이름에서 알 수 있듯이 데이터 레이어는 다른 소스(우리 경우 API)에서 데이터를 관리하고 도메인 레이어와 상호 작용하여 프리젠테이션 레이어가 필요로 하는 모든 데이터를 제공합니다.</p>\n<h1>모델 응답</h1>\n<p>모델 폴더를 앱의 요구에 따라 나눌 수 있습니다. 이 경우 API 응답 모델을 위한 폴더와 API 요청 모델을 위한 폴더 두 개로 나누겠습니다. 우리 앱에서는 API 응답을 위한 모델 하나만 필요하겠지만요. 또한, 객체를 비교할 수 있도록 Equatable에서 모델을 확장하고 엔티티를 구현하는 것을 기억해주세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">QuoteResponseModel</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Equatable</span> implements <span class=\"hljs-title class_\">QuoteEntitie</span> {\n  @override\n  final <span class=\"hljs-title class_\">String</span>? quote;\n  @override\n  final <span class=\"hljs-title class_\">String</span>? author;\n\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">QuoteResponseModel</span>({\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">quote</span>,\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">author</span>,\n  });\n\n  <span class=\"hljs-title class_\">QuoteResponseModel</span> <span class=\"hljs-title function_\">copyWith</span>({\n    <span class=\"hljs-title class_\">String</span>? quote,\n    <span class=\"hljs-title class_\">String</span>? author,\n  }) =>\n      <span class=\"hljs-title class_\">QuoteResponseModel</span>(\n        <span class=\"hljs-attr\">quote</span>: quote ?? <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">quote</span>,\n        <span class=\"hljs-attr\">author</span>: author ?? <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">author</span>,\n      );\n\n  factory <span class=\"hljs-title class_\">QuoteResponseModel</span>.<span class=\"hljs-title function_\">fromRawJson</span>(<span class=\"hljs-title class_\">String</span> str) =>\n      <span class=\"hljs-title class_\">QuoteResponseModel</span>.<span class=\"hljs-title function_\">fromJson</span>(json.<span class=\"hljs-title function_\">decode</span>(str)[<span class=\"hljs-number\">0</span>]);\n\n\n  factory <span class=\"hljs-title class_\">QuoteResponseModel</span>.<span class=\"hljs-title function_\">fromJson</span>(<span class=\"hljs-title class_\">Map</span>&#x3C;<span class=\"hljs-title class_\">String</span>, dynamic> json) =>\n      <span class=\"hljs-title class_\">QuoteResponseModel</span>(\n        <span class=\"hljs-attr\">quote</span>: json[<span class=\"hljs-string\">\"quote\"</span>],\n        <span class=\"hljs-attr\">author</span>: json[<span class=\"hljs-string\">\"author\"</span>],\n      );\n\n  @override\n  <span class=\"hljs-title class_\">List</span>&#x3C;<span class=\"hljs-title class_\">Object</span>?> get props => [\n        quote,\n        author,\n      ];\n}\n</code></pre>\n<h1>데이터 소스</h1>\n<p>데이터 소스를 만들어 봅시다. 이는 필요에 따라 데이터를 가져오는 프로세스를 처리합니다. 이 예시에서는 API에서 데이터를 가져와 모든 것이 문제없이 진행되면 응답 객체를 생성하거나 오류가 발생하면 예외를 throw합니다. 보시다시피, 우리는 먼저 추상 클래스를 작성하여 추상 로직을 만듭니다. 이후 이 클래스의 구현은 선택한 클라이언트를 사용하여 데이터를 가져오는 책임을 갖게 됩니다. 이 경우 HTTP 클라이언트는 나중에 get_it 패키지를 사용하여 주입될 것입니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'package:http/http.dart'</span> <span class=\"hljs-keyword\">as</span> http;\n\nabstract <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">QuoteDataSource</span> {\n  <span class=\"hljs-title class_\">Future</span>&#x3C;<span class=\"hljs-title class_\">QuoteResponseModel</span>> <span class=\"hljs-title function_\">getQuote</span>();\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">QuoteDataSourceImpl</span> implements <span class=\"hljs-title class_\">QuoteDataSource</span> {\n  final http.<span class=\"hljs-property\">Client</span> _client;\n\n  <span class=\"hljs-title class_\">QuoteDataSourceImpl</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_client</span>);\n\n  @override\n  <span class=\"hljs-title class_\">Future</span>&#x3C;<span class=\"hljs-title class_\">QuoteResponseModel</span>> <span class=\"hljs-title function_\">getQuote</span>() <span class=\"hljs-keyword\">async</span> {\n    final <span class=\"hljs-title class_\">Uri</span> url = <span class=\"hljs-title class_\">Uri</span>.<span class=\"hljs-title function_\">https</span>(<span class=\"hljs-string\">'api.breakingbadquotes.xyz'</span>, <span class=\"hljs-string\">'/v1/quotes'</span>);\n    final http.<span class=\"hljs-property\">Response</span> response = <span class=\"hljs-keyword\">await</span> _client.<span class=\"hljs-title function_\">get</span>(url);\n    <span class=\"hljs-keyword\">if</span> (response.<span class=\"hljs-property\">statusCode</span> == <span class=\"hljs-number\">200</span>) {\n      final <span class=\"hljs-title class_\">QuoteResponseModel</span> quoteResponseModel =\n          <span class=\"hljs-title class_\">QuoteResponseModel</span>.<span class=\"hljs-title function_\">fromRawJson</span>(response.<span class=\"hljs-property\">body</span>);\n      <span class=\"hljs-keyword\">return</span> quoteResponseModel;\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-title class_\">Exception</span>();\n    }\n  }\n}\n</code></pre>\n<h1>저장소 구현</h1>\n<p>데이터 소스를 생성한 후, 이전에 만든 추상 리포지토리를 구현해야 합니다. 이는 구현 클래스의 생성자에 데이터 소스를 주입하고 추상 리포지토리 함수를 오버라이딩하여 달성할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">QuoteRepositoryImpl</span> implements <span class=\"hljs-title class_\">QuoteRepository</span>{\n\n  final <span class=\"hljs-title class_\">QuoteDataSource</span> _dataSource;\n\n  <span class=\"hljs-title class_\">QuoteRepositoryImpl</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_dataSource</span>);\n\n  @override\n  <span class=\"hljs-title class_\">Future</span>&#x3C;<span class=\"hljs-title class_\">QuoteEntitie</span>> <span class=\"hljs-title function_\">getQuote</span>() <span class=\"hljs-keyword\">async</span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">await</span> _dataSource.<span class=\"hljs-title function_\">getQuote</span>();\n  }\n\n}\n</code></pre>\n<p>이 시점에서 애플리케이션에서 모든 것이 정상적으로 작동하는지 간단하게 테스트할 수 있습니다. FutureBuilder 위젯을 사용하여 API 정보를 검색하고 직접 의존성 주입을 통해 use case 객체를 만들어 확인할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span>() => <span class=\"hljs-title function_\">runApp</span>(<span class=\"hljs-title class_\">MyApp</span>());\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyApp</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">StatelessWidget</span> {\n  <span class=\"hljs-title class_\">MyApp</span>({<span class=\"hljs-variable language_\">super</span>.<span class=\"hljs-property\">key</span>});\n\n  final useCase = <span class=\"hljs-title class_\">QuoteUsecase</span>(<span class=\"hljs-title class_\">QuoteRepositoryImpl</span>(<span class=\"hljs-title class_\">QuoteDataSourceImpl</span>()));\n\n  @override\n  <span class=\"hljs-title class_\">Widget</span> <span class=\"hljs-title function_\">build</span>(<span class=\"hljs-params\">BuildContext context</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">MaterialApp</span>(\n      <span class=\"hljs-attr\">debugShowCheckedModeBanner</span>: <span class=\"hljs-literal\">false</span>,\n      <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">'Quote App'</span>,\n      <span class=\"hljs-attr\">home</span>: <span class=\"hljs-title class_\">Scaffold</span>(\n        <span class=\"hljs-attr\">appBar</span>: <span class=\"hljs-title class_\">AppBar</span>(),\n        <span class=\"hljs-attr\">body</span>: <span class=\"hljs-title class_\">Center</span>(\n          <span class=\"hljs-attr\">child</span>: <span class=\"hljs-title class_\">FutureBuilder</span>(\n            <span class=\"hljs-attr\">future</span>: useCase.<span class=\"hljs-title function_\">getQuote</span>(),\n            <span class=\"hljs-attr\">builder</span>:\n                (<span class=\"hljs-title class_\">BuildContext</span> context, <span class=\"hljs-title class_\">AsyncSnapshot</span>&#x3C;<span class=\"hljs-title class_\">QuoteEntitie</span>> snapshot) {\n              <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Column</span>(\n                <span class=\"hljs-attr\">children</span>: [\n                  <span class=\"hljs-title class_\">Text</span>(<span class=\"hljs-string\">\"${snapshot.data?.quote}\"</span>),\n                  <span class=\"hljs-title class_\">Text</span>(<span class=\"hljs-string\">\"${snapshot.data?.quote}\"</span>),\n                ],\n              );\n            },\n          ),\n        ),\n      ),\n    );\n  }\n}\n</code></pre>\n<p>하지만 이 방식에는 유지 및 확장이 어려워지고, 앱이 추가 기능과 함께 복잡해질수록 문제가 발생할 수 있습니다. 이를 해결하기 위해 홈 화면을 다른 파일로 분리하고, 서비스 로케이터 메서드를 생성하여 Bloc을 사용하여 상태를 관리할 것입니다.</p>\n<h1>Bloc 생성</h1>\n<p>알다시피 Flutter 애플리케이션에서 Bloc을 구현하려면 상태 파일, 이벤트 파일, 그리고 이벤트를 기반으로 상태를 발행하는 Bloc 파일을 생성해야 합니다. 이 경우 API가 데이터를 가져오기 시작할 때와 완료될 때 피드백을 제공하는 간단한 로직 상태가 있습니다. 따라서 로딩 중인지와 견적이 이용 가능한지를 나타내는 상태가 있을 것입니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">QuoteBlocState</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Equatable</span> {\n\n  final bool? isLoadingQuote;\n  final <span class=\"hljs-title class_\">QuoteEntitie</span>? quote;\n\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">QuoteBlocState</span>({<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">isLoadingQuote</span>, <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">quote</span>});\n\n  <span class=\"hljs-title class_\">QuoteBlocState</span> <span class=\"hljs-title function_\">copyWith</span>(<span class=\"hljs-params\">{\n    bool? isLoadingQuote,\n    QuoteEntitie? quote\n    }</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">QuoteBlocState</span>(\n      <span class=\"hljs-attr\">isLoadingQuote</span>: isLoadingQuote ?? <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">isLoadingQuote</span>,\n      <span class=\"hljs-attr\">quote</span>: quote ?? <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">quote</span>,\n    );\n  }\n\n  @override\n  <span class=\"hljs-title class_\">List</span>&#x3C;<span class=\"hljs-title class_\">Object</span>?> get props => [\n    isLoadingQuote,\n    quote\n    ];\n}\n</code></pre>\n<pre><code class=\"hljs language-js\">sealed <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">QuoteBlocEvent</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Equatable</span> {\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">QuoteBlocEvent</span>();\n\n  @override\n  <span class=\"hljs-title class_\">List</span>&#x3C;<span class=\"hljs-title class_\">Object</span>> get props => [];\n}\n\nfinal <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">GetQuouteEvent</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">QuoteBlocEvent</span>{\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">GetQuouteEvent</span>();\n}\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">QuoteBloc</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Bloc</span>&#x3C;<span class=\"hljs-title class_\">QuoteBlocEvent</span>, <span class=\"hljs-title class_\">QuoteBlocState</span>> {\n\n  final <span class=\"hljs-title class_\">QuoteUsecase</span> _quoteUsecase;\n\n  <span class=\"hljs-title class_\">QuoteBloc</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_quoteUsecase</span>) : <span class=\"hljs-title function_\">super</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">const</span> QuoteBlocState()</span>) {\n    on&#x3C;<span class=\"hljs-title class_\">GetQuouteEvent</span>>(_getQuote);\n  }\n\n  <span class=\"hljs-title class_\">FutureOr</span>&#x3C;<span class=\"hljs-keyword\">void</span>> <span class=\"hljs-title function_\">_getQuote</span>(\n      <span class=\"hljs-title class_\">GetQuouteEvent</span> event, <span class=\"hljs-title class_\">Emitter</span>&#x3C;<span class=\"hljs-title class_\">QuoteBlocState</span>> emit) <span class=\"hljs-keyword\">async</span> {\n    <span class=\"hljs-title function_\">emit</span>(state.<span class=\"hljs-title function_\">copyWith</span>(<span class=\"hljs-attr\">isLoadingQuote</span>: <span class=\"hljs-literal\">true</span>));\n    final <span class=\"hljs-title class_\">QuoteEntitie</span> response = <span class=\"hljs-keyword\">await</span> _quoteUsecase.<span class=\"hljs-title function_\">getQuote</span>();\n    <span class=\"hljs-title function_\">emit</span>(state.<span class=\"hljs-title function_\">copyWith</span>(<span class=\"hljs-attr\">quote</span>: response, <span class=\"hljs-attr\">isLoadingQuote</span>: <span class=\"hljs-literal\">false</span>));\n  }\n}\n</code></pre>\n<p>여기서는 use case가 생성자로 주입되어 getQuote() 함수를 사용할 수 있도록 되어 있다는 점을 강조하는 것이 매우 중요합니다.</p>\n<p>우리의 기본 아키텍처를 완성하기 위해 필요한 유일한 것은 서비스를 위한 초기화(init) 함수를 만드는 것입니다. 이 함수를 통해 앱 전체에서 필요한 경우 서비스를 사용할 수 있습니다. get_it 패키지를 사용하면 이를 매우 간단하게 만들 수 있습니다. 아래와 같은 함수를 만드는 것만 필요합니다:</p>\n<pre><code class=\"hljs language-dart\">최종 getIt = GetIt.instance;\n\n<span class=\"hljs-keyword\">void</span> initServices() {\n\n  이제 http.Client client = getIt.registerSingleton(http.Client());\n\n  이제 QuoteDataSourceImpl quoteDataSourceImpl =\n      getIt.registerSingleton(QuoteDataSourceImpl(client));\n\n  이제 QuoteRepositoryImpl quoteRepositoryImpl =\n      getIt.registerSingleton(QuoteRepositoryImpl(quoteDataSourceImpl));\n\n  이제 QuoteUsecase quoteUsecase =\n      getIt.registerSingleton(QuoteUsecase(quoteRepositoryImpl));\n\n  getIt.registerFactory(() => QuoteBloc(quoteUsecase));\n}\n</code></pre>\n<p>main 함수에서 runApp() 이전에 initServices() 함수를 호출하여 애플리케이션의 모든 부분이 인스턴스에 액세스할 수 있도록 합니다.</p>\n<pre><code class=\"hljs language-dart\"><span class=\"hljs-keyword\">void</span> main() {\n  intServices();\n  runApp(<span class=\"hljs-keyword\">const</span> MyApp());\n}\n</code></pre>\n<p>이 시점에서 Bloc을 사용한 상태 관리 및 이미 설정된 서비스 로케이터를 사용하여 표현 레이어가 이렇게 보여야 합니다. 화면을 독립적인 파일로 분리하는 것을 잊지 마세요.</p>\n<p><img src=\"/assets/img/2024-06-21-HowtoimplementcleanarchitecturewithBlocandget_itpackageinFlutter_2.png\" alt=\"How to Implement Clean Architecture with Bloc and get_it Package in Flutter 2\"></p>\n<p>마지막으로, 관심 분리를 위해 홈 화면은 작은 위젯으로, 랜덤 인용구와 그 저자를 표시하는 컬럼이 있습니다. 또한, API에서 새 데이터를 가져와 다른 인용구를 검색하는 버튼이 있습니다. 데이터를 가져오는 동안에는 CircularProgressIndicator 위젯을 표시합니다.</p>\n<pre><code class=\"hljs language-dart\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HomeScreen</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">StatelessWidget</span> </span>{\n  <span class=\"hljs-keyword\">const</span> HomeScreen({Key? key});\n\n  <span class=\"hljs-meta\">@override</span>\n  Widget build(BuildContext context) {\n    <span class=\"hljs-keyword\">return</span> Scaffold(\n      appBar: AppBar(),\n      body: <span class=\"hljs-keyword\">const</span> Center(child: _QuoteWidget()),\n    );\n  }\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">_QuoteWidget</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">StatelessWidget</span> </span>{\n  <span class=\"hljs-keyword\">const</span> _QuoteWidget();\n\n  <span class=\"hljs-meta\">@override</span>\n  Widget build(BuildContext context) {\n    <span class=\"hljs-keyword\">return</span> Builder(builder: (context) {\n      <span class=\"hljs-keyword\">final</span> QuoteBlocState state = context.select((QuoteBloc bloc) => bloc.state);\n      <span class=\"hljs-keyword\">final</span> <span class=\"hljs-built_in\">bool?</span> isLoading = state.isLoadingQuote;\n      <span class=\"hljs-keyword\">final</span> QuoteEntity? quote = state.quote;\n\n      <span class=\"hljs-keyword\">if</span> (isLoading == <span class=\"hljs-keyword\">true</span>) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">const</span> Center(\n          child: CircularProgressIndicator(),\n        );\n      }\n\n      <span class=\"hljs-keyword\">return</span> Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          Text(<span class=\"hljs-string\">\"<span class=\"hljs-subst\">${quote?.quote}</span>\"</span>),\n          Text(<span class=\"hljs-string\">\"<span class=\"hljs-subst\">${quote?.author}</span>\"</span>),\n          ElevatedButton(\n              onPressed: () {\n                context.read&#x3C;QuoteBloc>().add(<span class=\"hljs-keyword\">const</span> GetQuoteEvent());\n              },\n              child: <span class=\"hljs-keyword\">const</span> Text(<span class=\"hljs-string\">\"Get another quote\"</span>))\n        ],\n      );\n    });\n  }\n}\n</code></pre>\n<p>마지막 단계는 Bloc을 get_it을 사용하여 필요한 위치에 주입하는 것입니다. QuouteBloc의 인스턴스가 서비스 로케이터를 사용하여 위젯 트리에 주입되는 점에 유의하십시오. 마지막으로, Bloc 인스턴스가 생성된 후 인용구를 가져오고 새 상태를 발생시키는 이벤트를 호출하기 위해 연속 연산자를 사용하세요.</p>\n<pre><code class=\"hljs language-dart\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyApp</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">StatelessWidget</span> </span>{\n  <span class=\"hljs-keyword\">const</span> MyApp({Key key}) : <span class=\"hljs-keyword\">super</span>(key: key);\n\n  <span class=\"hljs-meta\">@override</span>\n  Widget build(BuildContext context) {\n    <span class=\"hljs-keyword\">return</span> MaterialApp(\n        debugShowCheckedModeBanner: <span class=\"hljs-keyword\">false</span>,\n        title: <span class=\"hljs-string\">'Quote App'</span>,\n        home: BlocProvider(\n          create: (context) => getIt&#x3C;QuoteBloc>()..add(<span class=\"hljs-keyword\">const</span> GetQuouteEvent()),\n          child: Builder(builder: (context) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">const</span> HomeScreen();\n          }),\n        ));\n  }\n}\n</code></pre>\n<p>그러니까 이제 앱을 실행시켜서 코딩의 매력을 만끽해보세요.</p>\n<p><img src=\"/assets/img/2024-06-21-HowtoimplementcleanarchitecturewithBlocandget_itpackageinFlutter_3.png\" alt=\"image\"></p>\n</body>\n</html>\n"},"__N_SSG":true}