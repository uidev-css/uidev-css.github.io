{"pageProps":{"posts":[{"title":"Flutter 확장 프로그램 생산성을 높이는 7가지 꿀팁 ","description":"","date":"2024-06-21 21:39","slug":"2024-06-21-FlutterExtensionsTrickstoBoostYourProductivity","content":"\n\n![이미지](/assets/img/2024-06-21-FlutterExtensionsTrickstoBoostYourProductivity_0.png)\n\n플러터 코드가 정체되어 있는 기분이 들죠? 반복적인 보일러플레이트를 작성하거나 기존 클래스에 슈퍼파워를 추가하고 싶은가요? 그렇다면, 플러터 개발자 여러분, 확실하게 할 일을 해야 합니다! 약간의 마법 같은 힘을 담아줄 확장 함수로 여러분의 작업 흐름에 활력을 불어넣어 보세요! 이 안내서에서는 이러한 다재다능한 코드 챔피언들의 비밀을 밝혀내어 기존 유형을 확장하고 코드를 간소화하며 플러터 게임의 수준을 높이도록 도와줄 것입니다. 이 강력한 확장 기능을 통해 반복적인 수고를 벗어던지고 더 깔끔하고 표현력이 풍부한 코드의 세계를 받아들이세요!\n\n# A. BuildContext에 대한 Extension\n\n먼저, 확장 기능을 만들고 이 확장 기능이 BuildContext를 확장한다는 것을 확실히하고 메서드를 확장 기능에 넣으세요:\n\n<div class=\"content-ad\"></div>\n\n\n# 테이블 태그를 Markdown 형식으로 변경\n\n```js\nextension ContextExt on BuildContext {\n\n    // 여기에 EXT 함수를 넣으세요\n\n}\n```\n\n1. 테마에 쉽게 접근하기\n\n```js\n  Color get primaryColor => Theme.of(this).primaryColor;\n  Color get canvasColor => Theme.of(this).canvasColor;\n  Color get cardColor => Theme.of(this).cardColor;\n  Color get focusColor => Theme.of(this).focusColor;\n  Color get dialogBackgroundColor => Theme.of(this).dialogBackgroundColor;\n  Color get disabledColor => Theme.of(this).disabledColor;\n  Color get dividerColor => Theme.of(this).dividerColor;\n  Color get highlightColor => Theme.of(this).highlightColor;\n  Color get hintColor => Theme.of(this).hintColor;\n  Color get hoverColor => Theme.of(this).hoverColor;\n  Color get indicatorColor => Theme.of(this).indicatorColor;\n  Color get primaryDark => Theme.of(this).primaryColorDark;\n  Color get primaryLight => Theme.of(this).primaryColorLight;\n  Color get shadowColor => Theme.of(this).shadowColor;\n```\n\n2. MediaQuery에 쉽게 접근하기\n\n\n<div class=\"content-ad\"></div>\n\n```dart\n  double get width => MediaQuery.of(this).size.width;\n  double get height => MediaQuery.of(this).size.height;\n  double get aspectRatio => MediaQuery.of(this).size.aspectRatio;\n  double get longestSide => MediaQuery.of(this).size.longestSide;\n  double get shortestSide => MediaQuery.of(this).size.shortestSide;\n  Orientation get orientation => MediaQuery.of(this).orientation;\n  EdgeInsets get padding => MediaQuery.of(this).padding;\n```\n\n3. SnackBar 표시하기\n\n```dart\n  void showSnackBar(String message) {\n    if (!mounted) return;\n    final snackBar = SnackBar(\n      content: Text(message),\n      duration: const Duration(seconds: 3),\n    );\n    ScaffoldMessenger.of(this).showSnackBar(snackBar);\n  }\n```\n\n4. AlertDialog 표시하기\n\n\n<div class=\"content-ad\"></div>\n\n```js\r\n  void displayAlertDialog({\r\n    required String title,\r\n    required String content,\r\n    VoidCallback? onPositivePressed,\r\n    String positiveButtonText = 'OK',\r\n    VoidCallback? onNegativePressed,\r\n    String negativeButtonText = 'Cancel',\r\n  }) {\r\n    if (!mounted) return;\r\n    showDialog(\r\n      context: this,\r\n      builder: (BuildContext context) {\r\n        return AlertDialog(\r\n          title: Text(title),\r\n          content: Text(content),\r\n          actions: <Widget>[\r\n            TextButton(\r\n              onPressed: onNegativePressed ??\r\n                  () {\r\n                    Navigator.of(this).pop();\r\n                  },\r\n              child: Text(negativeButtonText),\r\n            ),\r\n            TextButton(\r\n              onPressed: onPositivePressed ??\r\n                  () {\r\n                    Navigator.of(this).pop();\r\n                  },\r\n              child: Text(positiveButtonText),\r\n            ),\r\n          ],\r\n        );\r\n      },\r\n    );\r\n  }\r\n```\r\n\r\n5. 방향 기반으로 위젯 작성하기\r\n\r\n```js\r\n  T orientationAction<T>({\r\n    required T Function() onPortrait,\r\n    required T Function() onLandscape,\r\n  }) {\r\n    if (MediaQuery.of(this).orientation == Orientation.landscape) {\r\n      return onLandscape();\r\n    }\r\n    return onPortrait();\r\n  }\r\n```\r\n\r\n<br>\r\n\r\n<img src=\"https://miro.medium.com/v2/resize:fit:1200/1*aFEZr6_WdUFq3-DRjnYm9g.gif\" />\r\n\n\n<div class=\"content-ad\"></div>\n\n# 위젯 확장\n\n위젯을 확장하려면 먼저 확장 프로젝트를 만들고 위젯에 적용하세요.\n\n```js\nextension WidgetExt on Widget {\n\n    // 여기에 확장 함수를 넣으세요\n\n}\n```\n\n- 위젯 확장하기\n\n<div class=\"content-ad\"></div>\n\n```dart\n확장된확장({int flex = 1}) => Expanded(\n        flex: flex,\n        child: this,\n      );\n```\n\n2. 투명도 설정\n\n```dart\n투명도설정(double val) => Opacity(\n        opacity: val,\n        child: this,\n      );\n```\n\n3. Padding 추가하기\n\n\n<div class=\"content-ad\"></div>\n\n```js\nPadding withPadding(EdgeInsets padding) => Padding(\n        padding: padding,\n        child: this,\n      );\n```\n\n4. Wrap with SizedBox\n\n```js\nSizedBox box({double? width, double? height}) =>\n      SizedBox(width: width, height: height, child: this);\n```\n\n5. Centerize It!\n\n<div class=\"content-ad\"></div>\n\n```js\n  Center center() => Center(\n    child: this,\n  );\n```\n\n6. 클릭 가능하게 만들기\n\n```js\nWidget onClick(Function() onClick) => InkWell(\n        onTap: onClick,\n        child: this,\n      );\n```\n\n7. 회전하기!\n\n<div class=\"content-ad\"></div>\n\n```dart\nRotatedBox rotate(int quarterTurns) => RotatedBox(\n  quarterTurns: quarterTurns,\n  child: this,\n);\n```\n\n![image](https://miro.medium.com/v2/resize:fit:1200/1*4Wh8PWVfCj2Jf3wlfSELYA.gif)\n\n# C. Extension on String\n\n먼저 확장 기능을 만들고 문자열을 확장하세요.\n\n<div class=\"content-ad\"></div>\n\n```dart\nextension StringExt on String {\n\n  // 여기에 EXT 함수 추가하세요\n\n}\n```\n\n- 텍스트 위젯으로 변환\n\n```dart\nText get text => Text(this);\n```\n\n2. 매치해 보세요!\n\n<div class=\"content-ad\"></div>\n\n```dart\n// 8자리 문자, 소문자, 대문자, 숫자를 포함해야 함\nbool isValidPassword() {\n  return RegExp(r'^(?=.*[A-Z])(?=.*[a-z])(?=.*\\d).{8,}$').hasMatch(this);\n}\n\nbool isValidEmail() {\n  return RegExp(r'^[\\w-]+(\\.[\\w-]+)*@([\\w-]+\\.)+[a-zA-Z]{2,7}$').hasMatch(this);\n}\n\nbool isURL() {\n  // 간단한 URL 패턴에 대한 정규 표현식\n  RegExp urlRegExp = RegExp(\n    r'^(https?|ftp):\\/\\/[^\\s/$.?#].[^\\s]*$',\n    caseSensitive: false,\n    multiLine: false,\n  );\n\n  return urlRegExp.hasMatch(this);\n}\n```\n\n3. 기타 내용\n\n```dart\nString append(String other) => '$this$other';\n\nString get capitalizeFirstLetter =>\n    this.isNotEmpty ? this[0].toUpperCase() + this.substring(1) : this;\n\nString get removeWhitespace => this.replaceAll(RegExp(r'\\s+'), '');\n\n// 형식: yyyy-MM-dd HH:mm:ss\nDateTime toDateTime() {\n  return DateTime.parse(this);\n}\n```\n\n# D. Num 확장  \n\n<div class=\"content-ad\"></div>\n\n먼저 Extension을 만들고 num을 확장하세요.\n\n```dart\nextension NumExt on num {\n\n    // 여기에 EXT 함수를 넣어주세요\n\n}\n```\n\n- 수직 및 수평 간격을 간단하게 만듭니다.\n\n```dart\nSizedBox get heightBox => SizedBox(\n        height: toDouble(),\n      );\n\nSizedBox get widthBox => SizedBox(\n        width: toDouble(),\n      );\n```\n\n<div class=\"content-ad\"></div>\n\n2. 패딩으로 변환\n\n```js\nEdgeInsets get allPadding => EdgeInsets.all(toDouble());\n\nEdgeInsets get verticalPadding => EdgeInsets.symmetric(vertical: toDouble());\n\nEdgeInsets get horizontalPadding => EdgeInsets.symmetric(horizontal: toDouble());\n\nEdgeInsets get leftPadding => EdgeInsets.only(left: toDouble());\n\nEdgeInsets get rightPadding => EdgeInsets.only(right: toDouble());\n\nEdgeInsets get topPadding => EdgeInsets.only(top: toDouble());\n\nEdgeInsets get bottomPadding => EdgeInsets.only(bottom: toDouble());\n```\n\n3. 기간으로 변환\n\n```js\nDuration get microseconds => Duration(microseconds: toInt());\n\nDuration get milliseconds => Duration(milliseconds: toInt());\n\nDuration get seconds => Duration(seconds: toInt());\n\nDuration get minutes => Duration(minutes: toInt());\n\nDuration get hours => Duration(hours: toInt());\n\nDuration get days => Duration(days: toInt());\n```\n\n<div class=\"content-ad\"></div>\n\n# 기타\n\n- DateTime 확장\n\n```dart\nextension DateTimeExt on DateTime {\n  bool isToday() {\n    final now = DateTime.now();\n    return day == now.day && month == now.month && year == now.year;\n  }\n\n  bool isYesterday() {\n    final now = DateTime.now();\n    final yesterday = DateTime(now.year, now.month, now.day - 1);\n    return day == yesterday.day &&\n        month == yesterday.month &&\n        year == yesterday.year;\n  }\n\n  // yyyy-mm-dd\n  String get stringFormat => toIso8601String().substring(0, 10);\n}\n```\n\n2. 파일 확장\n\n<div class=\"content-ad\"></div>\n\n```dart\nextension FileExt on File {\n  Future<Uint8List?> toUint8List() async {\n    try {\n      List<int> bytes = await readAsBytes();\n      Uint8List uint8List = Uint8List.fromList(bytes);\n      return uint8List;\n    } catch (e) {\n      return null;\n    }\n  }\n\n  bool isImageFile() {\n    final String extension = path.split('.').last.toLowerCase();\n    return ['jpg', 'jpeg', 'png', 'gif', 'bmp'].contains(extension);\n  }\n\n  bool isVideoFile() {\n    final String extension = path.split('.').last.toLowerCase();\n    return ['mp4', 'avi', 'mkv', 'mov', 'wmv', 'flv', 'webm'].contains(extension);\n  }\n\n  bool isAudioFile() {\n    final String extension = path.split('.').last.toLowerCase();\n    return ['mp3', 'wav', 'ogg', 'aac', 'flac', 'm4a', 'wma'].contains(extension);\n  }\n}\n```\n\n3. Scope Function Extension\n\n```dart\nextension ScopeFunctionExt<T> on T {\n\n  // Do Something on The Object and returns Something\n  R map<R>(R Function(T) block) {\n    return block(this);\n  }\n\n  // Do Something on The Object and returns The Object\n  T apply(Function(T) block) {\n    block(this);\n    return this;\n  }\n}\n```\n\n플러터에서 확장 메서드에 대한 코드 팁을 보여드렸습니다. 생산성을 높이는 데 도움이 되는 내용일지 모릅니다. 만약 이 기사가 유익했다면 👏 박수를 보내주시고, 휴대폰 개발에 관한 다양한 기사를 확인하시려면 팔로우해주세요. 감사합니다. 계속해서 생산적이세요 🔥\n\n\n<div class=\"content-ad\"></div>\n\n아래는 제 GitHub에서 제 쿨한 프로젝트들을 확인해보세요:\n\n# 나와 소통하기:\n\n- Medium\n- GitHub\n- LinkedIn\n\n<div class=\"content-ad\"></div>\n\n# Stackademic\n\n끝까지 읽어 주셔서 감사합니다. 떠나기 전에:\n\n- 작가를 칭찬하고 팔로우해 주시면 감사하겠습니다! 👏\n- Twitter(X), LinkedIn, YouTube에서 팔로우해 주세요.\n- 세계적으로 프로그래밍 교육을 무료로 더 democra타이징하는 Stackademic.com 방문하기.","ogImage":{"url":"/assets/img/2024-06-21-FlutterExtensionsTrickstoBoostYourProductivity_0.png"},"coverImage":"/assets/img/2024-06-21-FlutterExtensionsTrickstoBoostYourProductivity_0.png","tag":["Tech"],"readingTime":10},{"title":"정규 표현식 쉽게 배우기 5부 - 전방탐색과 후방탐색 기법 알아보기","description":"","date":"2024-06-21 21:37","slug":"2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds","content":"\n\n<img src=\"/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_0.png\" />\n\n크레딧: Nguyễn Thành Minh (안드로이드 개발자)\n\nPart 1은 여기에서 확인하세요: Quantifiers\n\nPart 2은 여기에서 확인하세요: Flavors, Flags, and Assertions\n\n<div class=\"content-ad\"></div>\n\n아래의 테이블 태그를 마크다운 형식으로 변경해주세요.\n\n<div class=\"content-ad\"></div>\n\n룩어헤드 어설션은 특정 문자로 뒤따라오거나 선행하는 경우에만 일치하는 비캡처 그룹입니다.\n\n룩어헤드 어설션은 입력 문자열이나 텍스트의 문자를 소비하지 않습니다. 다른 어설션 메타 문자인 입력 경계 어설션 (^와 $) 및 단어 경계 어설션 (\\b와 \\B)과 달리.\n\n룩어헤드 어설션에는 두 가지 유형이 있습니다: 앞봐기(lookahead)와 뒷봐기(lookbehind). 두 유형은 양수와 음수 형태로 나뉘며, 양수 앞봐기, 음수 앞봐기, 양수 뒷봐기 및 음수 뒷봐기 어설션이 있습니다.\n\n- 양수 앞봐기(?=chars)\n\n<div class=\"content-ad\"></div>\n\n프렌들리한 톤으로 번역해드리겠습니다. 😀\n\n긍정형 선행 단언은 문자열에서 현재 위치 이후에 특정 패턴이 일치하는지를 확인하며 해당 문자열에서 문자를 소비하지 않습니다. 간단히 말하면, 특정 표현식이 현재 위치 오른쪽에 위치하는지를 확인합니다. 이는 다음과 같은 구문을 사용하여 나타냅니다:\n\n```js\n(?=chars)\n```\n\n예를 들어, 패턴 x(?=y)는 y가 뒤따라오는 경우에만 x와 일치합니다.\n\n[이미지:RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_1.png]\n\n<div class=\"content-ad\"></div>\n\n다른 예시로, xyz(?=123)는 xyz와 일치하는 것이 123로 뒤 따르는 경우에만 일치합니다.\n\n![image](/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_2.png)\n\n또 다른 예시로, apple (?=pie)\n\n![image](/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_3.png)\n\n<div class=\"content-ad\"></div>\n\n위 예제에서, 'apple'과 일치하는 부분은 있지만 'apple pie' 전체까지는 일치하지 않습니다. 왜냐하면 lookaround 어서션은 입력 문자열의 문자들을 소비하지 않기 때문입니다.\n\n만약 x(?=y)를 (?=y)x로 바꾼다면 어떻게 될까요? 패턴 (?=y)x를 이해하기 위해서는 먼저 패턴 (?=y)와 (?=y)y를 이해해야 합니다.\n\n패턴 (?=y)는 'y'가 뒤따라오는 문자열과 일치하지만, 그 앞에는 다른 문자열이 없는 경우를 의미합니다. 따라서 아래 이미지에서 볼 수 있듯이 \"빈 문자열\"과 일치하게 됩니다. 이 경우 빈 문자열 중에서 'y'가 뒤따라오는 것에만 일치하며, 모든 빈 문자열과는 일치하지 않음에 유의해 주세요.\n\n<img src=\"/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_4.png\" />\n\n<div class=\"content-ad\"></div>\n\nThe pattern (?=y)은 ‘y’ 바로 앞에 오는 빈 문자열과 일치합니다. 그래서, 패턴 (?=y)y는 ‘y’ 앞의 빈 문자열과 바로 ‘y’ 문자 뒤에 옵니다. 보다 쉬운 용어로 표현하자면, 이는 단순히 문자 ‘y’에 해당합니다.\n\n![](/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_5.png)\n\n비슷하게, 패턴 (?=y)x는 ‘y’ 앞에 오는 빈 문자열과 바로 ‘x’ 문자 뒤에 오는 것을 나타냅니다. 다시 말해, 이는 'x' 문자 하나로만 구성되어야 하지만 'y'로 시작해야 하는 문자열과 일치합니다. 이러한 시나리오는 불가능하기 때문에, 이 패턴은 어떤 문자열과도 일치하지 않습니다.\n\n![](/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_6.png)\n\n<div class=\"content-ad\"></div>\n\n만약 우리가 (?=y)x와 같은 패턴에 .*을 삽입한다면 어떻게 될까요? (?=.*y)x가 되는데, 이 경우 'x'가 'xy', 'x123y', 'x1y2z3'와 같이 'y'가 뒤에 오는 경우에 일치합니다.\n\n![이미지](/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_7.png)\n\n먼저, 이 패턴이 단 한 문자 'x'만 일치한다는 점은 확실합니다. 왜냐하면 (?=.*y)는 단언이기 때문에 문자를 소비하지 않기 때문입니다.\n\n그런 다음, 패턴 (?=.*y)가 어떻게 작동하는지 이해해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n- .*: 새 줄 제외한 모든 문자 시퀀스와 일치합니다.\n- y: 문자 `y`와 일치합니다.\n- 따라서, .*y는 적어도 하나의 문자 `y`를 포함하는 모든 문자열과 일치합니다.\n\n그러므로, (?=.*y)는 'y'가 뒤따르는 빈 문자열과 일치합니다.\n\n![이미지](/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_8.png)\n\n마지막으로, 패턴 (?=.*y)x는 'y'가 뒤따르는 문자열(예: `xy,`, `x123y,`, `x1y2` 등)에서 단일 문자 `x`와 일치합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_9.png)\n\n이 경우에는 .*가 ‘x’와 일치하기 때문에 .*y 전체가 ‘xy’와 일치하지만 ‘yx’와는 일치하지 않습니다. 그래서 (?=.*y)x는 ‘yx’와 일치하지 않습니다. 이를 그룹화하여 확인할 수 있습니다: (?=(.*)y)x\n\n![image](/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_10.png)\n\n그룹 (.*)는 ‘x’, ‘xz’, ‘xbc’와 일치하는 것을 볼 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n간단히 말해서, (?=.*y)는 문자열에 적어도 하나의 'y' 문자가 있는지 확인하는 데 일반적으로 사용됩니다. 비슷하게, 다음과 같은 유용한 패턴들이 있습니다:\n\n- (?=.*[a-z]).+는 적어도 하나의 소문자가 있는 문자열과 일치합니다.\n- (?=.*[A-Z]).+는 적어도 하나의 대문자가 있는 문자열과 일치합니다.\n- (?=.*\\d).+는 적어도 하나의 숫자가 있는 문자열과 일치합니다.\n- (?=.*[^A-Za-z0–9\\s]).+는 공백을 제외한 특수 문자가 적어도 하나 있는 문자열과 일치합니다.\n\n긍정적인 선행 단언은 비밀번호 유효성을 확인하는 데 유용할 수 있습니다. 예를 들어, 적어도 하나의 대문자, 소문자, 숫자, 및 (공백을 제외한) 하나의 특수 문자를 포함하는 8자 이상의 비밀번호를 확인하려면 다음과 같이 할 수 있습니다:\n\n```js\n^(?=.*[A-Z])(?=.*[a-z])(?=.*\\d)(?=.*[^A-Za-z0-9\\s]).{8,}$\n```\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_11.png\" />\n\n여기서:\n\n- ^: 패턴을 문자열의 시작으로 고정시킵니다.\n- (?=.*[A-Z]): 적어도 하나의 대문자가 존재하는 것을 보증합니다.\n- (?=.*[a-z]): 적어도 하나의 소문자가 존재하는 것을 보증합니다.\n- (?=.*\\d): 적어도 하나의 숫자가 존재하는 것을 보증합니다.\n- (?=.*[^A-Za-z0-9\\s]): 적어도 하나의 특수문자(공백 제외)가 존재하는 것을 보증합니다.\n- .'8,': 적어도 8자의 문자열과 일치합니다.\n- $: 패턴을 문자열의 끝으로 고정시킵니다.\n\n2. 부정형 순방향탐색 (?!chars)\n\n<div class=\"content-ad\"></div>\n\n부정적 룩어헤드 구문에서는 등호를 느낌표로 바꿉니다:\n\n```js\n(?!chars)\n```\n\n예를 들어, x(?!y) 패턴은 'y'에 뒤이어 나오지 않는 경우에만 'x'와 일치합니다.\n\n다른 예로는 x(?!123) 패턴으로, '123'에 뒤이어 나오지 않는 경우에만 'x'와 일치합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_12.png)\n\n부정적 전방탐색 어설션은 특정 단어로 시작하지 않는 문자열을 유효성 검사하는 데 유용할 수 있습니다. 예를 들어, 'http' 또는 'https'로 시작하지 않는 URL을 유효성 검사하는 것입니다.\n\n```js\n^(?!http|https).+$\n```\n\n![image](/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_13.png)\n\n\n<div class=\"content-ad\"></div>\n\n위의 패턴에서, ^는 현재 위치가 문자열의 시작임을 나타내며, 부정 후조형 (?!http|https)는 현재 위치 뒤의 문자열이 \"http\" 또는 \"https\"가 아님을 나타냅니다. 이는 \"http\" 또는 \"https\"로 시작하지 않는 문자열과 일치합니다.\n\n3. 긍정 후조형 (?`=chars)\n\n후조형 단언은 후조 단언과 유사합니다. 하지만 일치하려는 항목 뒤에 무엇이 따라오는지 확인하는 대신, 일치하려는 항목 앞에 어떤 문자(들)가 있는지 확인합니다.\n\n후조 단언과 마찬가지로, 긍정과 부정 후조 단언도 있습니다. 긍정 후조는 패턴에서 지정한 다른 문자에 의해 선행된 문자만 일치시킵니다. 반면에 부정 후조는 일치시키려는 문자가 다른 문자에 의해 선행되지 않을 때만 일치시킵니다.\n\n<div class=\"content-ad\"></div>\n\n이것은 긍정형 lookbehind의 구문입니다:\n\n```js\n(?<=chars)\n```\n\n예를 들어, 패턴 (?`=x)y는 y를 일치시키려면 그 앞에 x가 있어야 한다는 것을 나타냅니다. 이 경우 xx 또는 yx는 일치하지 않지만 xy는 일치합니다.\n\n긍정형 lookbehind 어설션은 특정 통화 기호로만 선행된 숫자와 일치하는 경우에 유용할 수 있습니다. 예를 들어, 달러 기호로 선행된 숫자와 일치하는 경우입니다.\n\n<div class=\"content-ad\"></div>\n\n아래의 정규 표현식 패턴은 달러 기호가 앞에 오는 숫자만 일치시키는 양수형 룩비하인드를 갖고 있어요:\n\n```js\n(?<=\\$)\\d+\n```\n\n<img src=\"/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_14.png\" />\n\n위 패턴에서 양수형 룩비하인드인 (?`=\\$) 는 달러 기호인 '$' 가 \\d+에 의해 표현되는 하나 이상의 숫자 앞에 있는지를 확인합니다.\n\n<div class=\"content-ad\"></div>\n\n4. Negative lookbehind (?`!chars)\n\n부정적인 lookbehind에서는 등호 대신 느낌표를 사용합니다:\n\n```js\n(?<!chars)\n```\n\n예를 들어, 패턴 (?`!x)y는 y 앞에 x가 있는 경우 y와 일치하지 않습니다. 이 경우 vy는 일치하고, ny는 일치하지만 xy는 결코 일치하지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n부정적인 전방탐색 단언은 특정 확장자로 끝나지 않는 파일을 유효성 검사할 때 유용할 수 있습니다. 예를 들어, \"js\", \"css\", 또는 \"html\"로 끝나지 않는 파일 경로를 유효성 검사하려면 아래와 같이 사용할 수 있습니다.\n\n```js\n^.+(?<!js|css|html)$\n```\n\n![image](/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_15.png)\n\n위 패턴에서 $는 현재 위치가 문자열 끝을 나타내고, 부정적인 전방탐색 (?`!js|css|html)는 현재 위치(끝 위치) 앞에 있는 문자열이 \"js\", \"css\", 또는 \"html\"이 아님을 나타냅니다. 즉, \"js\", \"css\", \"html\"로 끝나지 않는 문자열과 일치합니다.\n\n<div class=\"content-ad\"></div>\n\n결론\n\n정규 표현식에서 이 개념이 제일 어려웠어요. 이번 레슨 이후에는 대부분의 문제를 해결하는 데 정규 표현식을 사용할 수 있을 것으로 믿어요. 다음 파트에서는 프로그래밍에 적용해볼 거에요.","ogImage":{"url":"/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_0.png"},"coverImage":"/assets/img/2024-06-21-RegexforDummiesPart5LookaroundAssertionsLookaheadsandLookbehinds_0.png","tag":["Tech"],"readingTime":7},{"title":"Execution failed for task appcheckDebugDuplicateClasses 에러 해결하는 방법","description":"","date":"2024-06-21 21:35","slug":"2024-06-21-HowtofixExecutionfailedfortaskappcheckDebugDuplicateClasses","content":"\n\n```js\r\n실패: 예외로 빌드가 실패했습니다.\n\n* 무엇이 잘못되었나요:\n:app:checkDebugDuplicateClasses 작업을 실행하는 동안 실행이 실패했습니다.\n> com.android.build.gradle.internal.tasks.CheckDuplicatesRunnable을 실행하는 동안 오류가 발생했습니다.\n   > 모듈 jetified-kotlin-stdlib-1.8.10 (org.jetbrains.kotlin:kotlin-stdlib:1.8.10)와 jetified-kotlin-stdlib-jdk8-1.6.21 (org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.6.21)에서 발견된 중복 클래스 kotlin.collections.jdk8.CollectionsJDK8Kt\n     모듈 jetified-kotlin-stdlib-1.8.10 (org.jetbrains.kotlin:kotlin-stdlib:1.8.10)와 jetified-kotlin-stdlib-jdk8-1.6.21 (org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.6.21)에서 발견된 중복 클래스 kotlin.internal.jdk8.JDK8PlatformImplementations\n     모듈 jetified-kotlin-stdlib-1.8.10 (org.jetbrains.kotlin:kotlin-stdlib:1.8.10)와 jetified-kotlin-stdlib-jdk8-1.6.21 (org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.6.21)에서 발견된 중복 클래스 kotlin.internal.jdk8.JDK8PlatformImplementations$ReflectSdkVersion\n     모듈 jetified-kotlin-stdlib-1.8.10 (org.jetbrains.kotlin:kotlin-stdlib:1.8.10)와 jetified-kotlin-stdlib-jdk8-1.6.21 (org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.6.21)에서 발견된 중복 클래스 kotlin.jvm.jdk8.JvmRepeatableKt\n     모듈 jetified-kotlin-stdlib-1.8.10 (org.jetbrains.kotlin:kotlin-stdlib:1.8.10)와 jetified-kotlin-stdlib-jdk8-1.6.21 (org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.6.21)에서 발견된 중복 클래스 kotlin.random.jdk8.PlatformThreadLocalRandom\n     모듈 jetified-kotlin-stdlib-1.8.10 (org.jetbrains.kotlin:kotlin-stdlib:1.8.10)와 jetified-kotlin-stdlib-jdk8-1.6.21 (org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.6.21)에서 발견된 중복 클래스 kotlin.streams.jdk8.StreamsKt\n     ...\n  \n* 해결 방법:\n> 스택 트레이스를 가져오려면 --stacktrace 옵션을 사용하십시오.\n> 더 많은 로그 출력을 얻으려면 --info 또는 --debug 옵션으로 실행하십시오.\n> 전체 통찰을 얻으려면 --scan으로 실행하십시오.\n\n* https://help.gradle.org에서 더 많은 도움을 받을 수 있습니다.\n\n빌드 완료: 1 분 9 초 \nGradle 작업 'assembleDebug' 실행 중...                             72.5초\n예외: Gradle 작업 assembleDebug의 종료 코드가 1로 실패했습니다\r\n```\n\n저는 zegocloud SDK를 활용한 앱을 생성하면서 이 오류를 만났어요.\n\n이 오류를 해결하는 방법은 간단합니다. 아래 코드 라인을 추가하는 것뿐이에요.\n\n```js\next.kotlin_version = '1.8.0-Beta'\n```\n\n<div class=\"content-ad\"></div>\n\nAndroid build.gradle 파일에서 작업하고 있군요.\n\n다음과 같이 수정하면 됩니다.\n\n```js\nbuildscript {\n    ext.kotlin_version = '1.7.10'\n    repositories {\n        google()\n        mavenCentral()\n    }\n\n    dependencies {\n        classpath 'com.android.tools.build:gradle:7.2.0'\n        classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\"\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n```kotlin\nbuildscript {\n    ext.kotlin_version = '1.8.0-Beta'\n    repositories {\n        google()\n        mavenCentral()\n    }\n\n    dependencies {\n        classpath 'com.android.tools.build:gradle:7.2.0'\n        classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\"\n    }\n}\n```\n\n그 다음 앱을 다시 실행하면 문제가 해결될 것입니다.","ogImage":{"url":"/assets/img/2024-06-21-HowtofixExecutionfailedfortaskappcheckDebugDuplicateClasses_0.png"},"coverImage":"/assets/img/2024-06-21-HowtofixExecutionfailedfortaskappcheckDebugDuplicateClasses_0.png","tag":["Tech"],"readingTime":3},{"title":"Flutter에서 네트워크 이미지 최적화로 메모리 사용량 줄이는 방법","description":"","date":"2024-06-21 21:32","slug":"2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter","content":"\n\n\n![이미지](/assets/img/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter_0.png)\n\n플러터에서 네트워크 이미지를 가져와 표시할 때 기억해야 할 중요한 요소는 무엇인가요?\n\n이미지 위젯을 사용할 때 더 나은 사용자 경험(UX)을 제공하기 위해 네트워크에서 이미지를로드하기 전에 페이드-인 애니메이션을 적용하거나 로딩 표시기를 표시하는 것을 고려할 수 있습니다.\n\n이러한 UX 고려사항이 중요하지만 네트워크 이미지를 렌더링할 때 메모리 사용량을 줄이는 것도 중요합니다. 이는 더 큰 이미지가 렌더링 프로세스 중에 상당한 양의 메모리를 요구하기 때문입니다.\n\n\n<div class=\"content-ad\"></div>\n\n이를 설명하기 위해 개인 프로젝트 예시를 공유하고 싶습니다. 내 앱에서 화면이 버벅거리고 비정상적으로 종료되는 문제가 발생했습니다. 앞서 언급했듯이, 문제의 원인은 화면에 고해상도 네트워크 이미지를 표시할 때 과도한 메모리 사용이었습니다.\n\n![이미지](/assets/img/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter_1.png)\n\n동일한 실수를 피하려면, 화면에 이미지를 로드할 때 렌더링을 최적화하는 방법을 이해해야 합니다. 이 게시물에서는 메모리 사용량을 줄이면서 효과적으로 네트워크 이미지를 렌더링하는 방법을 소개하겠습니다. 유용한 팁을 모아두세요!\n\n# 과도하게 큰 이미지 진단하기\n\n<div class=\"content-ad\"></div>\n\n먼저, 네트워크 이미지를 렌더링할 때 메모리 사용량이 과도한지 진단하는 것이 중요합니다. 간단한 예를 통해 이를 확인해 보겠습니다.\n\n<img src=\"/assets/img/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter_2.png\" />\n\n```js\nImage.network(\n    imageUrl,\n    width: 250,\n),\n```\n\n위의 이미지 위젯이 효율적으로 렌더링되었습니까? 알아내는 간단한 방법이 있습니다.\n\n<div class=\"content-ad\"></div>\n\n아래는 Markdown 형식으로 변경한 표입니다.\n\n![이미지1](/assets/img/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter_3.png)\n\nFlutter Inspector에서 \"Highlight oversized images\" 버튼을 활성화하세요.\n\n![이미지2](/assets/img/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter_4.png)\n\n그러면 화면에 표시된 이미지가 색상이 반전되고 수직으로 뒤집힌 것을 알 수 있습니다. 이는 이미지 디코딩 과정에서 필요한 것보다 더 많은 메모리가 사용되었다는 것을 나타냅니다.\n\n<div class=\"content-ad\"></div>\n\n# 화면 크기 및 디코딩 크기\n\n에러 로그를 확인하면 더 구체적인 정보를 얻을 수 있습니다.\n\n```js\nImage [...]의 화면 크기는 750×421이지만 디코딩 크기는 3840×2160으로,\n기기 픽셀 비율이 3.0을 가정했을 때 추가적인 41552KB를 사용합니다.\n```\n\n화면에 표시된 이미지의 크기는 750x421이지만, 디코딩된 크기는 3840×2160으로, 추가로 41552KB의 메모리를 사용하고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n디스플레이 크기는 이미지를 디코딩하는 크기를 나타냅니다. 다시 말해, 화면에 실제로 표시될 때, 필요한 디스플레이 크기는 750×421에 불과합니다. 따라서 이미지의 전체 원본 크기, 3840×2160(디코드 크기),를 디코딩하는 것은 불필요합니다.\n\n더 쉽게 이해하기 위해 비유를 들어보겠습니다.\n\n![이미지](/assets/img/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter_5.png)\n\n친구와 찍은 사진을 기반으로 화가에게 그림을 그리도록 부탁했다고 상상해보세요. 화가에게 사진을 제공할 때, 그림을 만드는 데 필요한 것보다 훨씬 큰 대형 게시판 크기의 사진을 제공할 필요는 없습니다. 사실, 그러한 큰 사진은 화가의 작업을 방해할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter_6.png)\n\n정확하고 빠른 그림을 그리려면 예당 크기의 사진만 있으면 됩니다. 이 개념은 Flutter에서 네트워크 이미지를 로드할 때도 적용됩니다. 이미지의 크기가 화면에 표시될 크기(표시 크기)보다 훨씬 크면 Flutter 엔진이 디코딩 프로세스 중에 메모리를 낭비합니다.\n\n# 이미지 크기 조정\n\n그렇다면 이미지의 크기를 어떻게 조정해야 할까요? 다음 오류 로그는 이미지 크기를 조정하는 방법에 대한 안내를 제공합니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\n이제 코드 수정을 통해 기록에 기반한 변경을 가해보겠습니다.\n\nImage.network(\n  imageUrl,\n  width: 250,\n  cacheWidth: 750,\n),\nconst Divider(),\nImage.network(\n  imageUrl,\n  width: 250,\n),\n\n<div class=\"content-ad\"></div>\n\n비교를 위해 cacheWidth 속성이 설정되지 않은 위젯을 추가했습니다. (한 가지 캐시 속성을 설정하면 다른 이미지도 비율을 유지하면서 크기를 조정할 수 있습니다)\n\n![image](/assets/img/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter_7.png)\n\ncacheWidth를 설정한 이미지는 과도한 오류 없이 표시되지만, 다른 이미지는 색상과 방향이 반전되고 수직으로 뒤집힙니다. cacheWidth를 올바르게 설정함으로써 이미지의 크기를 조정하여 디코딩 프로세스에서 메모리 사용량을 최적화했습니다.\n\n# 장치별 화소 비율\n\n<div class=\"content-ad\"></div>\n\n그러나 여전히 문제가 발생할 수 있습니다.\n\n![image](/assets/img/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter_8.png)\n\ncacheWidth가 설정된 동일한 코드에서 iPhone 12 mini에서 이미지가 올바르게 표시되지만, 화면 크기가 작은 iPhone SE에서는 여전히 크기가 너무 크다는 표시가 있습니다.\n\n이 문제가 발생하는 이유는 무엇일까요? 오류 로그를 다시 확인해 보죠.\n\n<div class=\"content-ad\"></div>\n\n## iPhone 12 미니\n\nImage [...]의 디스플레이 크기는 750×421이지만 디코딩 크기는 3840×2160으로, 기기 픽셀 비율을 3.0으로 가정할 때 추가 41552KB가 사용됩니다.\n\n미리 자산의 크기를 조정하거나 cacheWidth 매개변수를 750, cacheHeight 매개변수를 421로 제공하거나 ResizeImage를 사용하는 것을 고려해보세요.\n\niPhone 12 미니의 경우, 이미지의 디스플레이 폭은 750이며, 기기 픽셀 비율은 3.0입니다.\n\n## iPhone SE\n\n<div class=\"content-ad\"></div>\n\n이미지 [...]는 표시 크기가 500×281이지만 디코딩 크기는 3840×2160 이며, 장치 픽셀 비율이 2.0일 때 추가로 42467KB를 사용합니다.\n\n미리 에셋 크기를 조정하고, cacheWidth 매개변수를 500, cacheHeight 매개변수를 281로 제공하거나 ResizeImage를 사용하는 것을 고려해보세요.\n\n반면에 iPhone SE의 경우, 이미지의 표시 크기는 500이며, 장치 픽셀 비율은 2.0입니다.\n\n이 차이는 각 장치의 다른 디바이스 픽셀 비율 때문에 발생합니다.\n\n디바이스 픽셀 비율은 디바이스 화면에 표시되는 픽셀 밀도를 나타내며, 특정 장치의 화면 크기 당 픽셀 수를 나타냅니다.\n```\n\n<div class=\"content-ad\"></div>\n\n![image](/assets/img/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter_9.png)\n\n화소 밀도는 일반적으로 특정 디바이스의 화면 크기에 따라 다양한 값을 갖는 ppi(인치당 픽셀)로 측정됩니다. 예를 들어 고해상도 장치는 화면 크기 당 픽셀이 더 많아 더 높은 화소 밀도를 가지게 됩니다.\n\n요약하자면, iPhone SE는 디바이스 픽셀 비율이 2.0이며, 이는 물리적 픽셀 당 2개의 픽셀을 표시한다는 것을 의미하며, iPhone 12 mini는 디바이스 픽셀 비율이 3.0이며, 즉 물리적 픽셀 당 3개의 픽셀을 표시합니다. 따라서 iPhone 12 mini를 기준으로 cacheWidth를 설정할 때, iPhone SE의 낮은 픽셀 비율로 인해 여전히 불필요한 디코딩 크기가 남아 있습니다.\n\n# 이미지 캐시 크기 동적으로 결정하기\n\n<div class=\"content-ad\"></div>\n\n이제 모든 단서가 모였으니, 기기의 픽셀 비율을 기반으로 cacheWidth 값을 계산할 수 있어요.\n\n```js\n250 (위젯 크기) X 2 (iPhone SE 기기 픽셀 비율) = 500 (캐시 크기)\n```\n\n250의 목표 위젯 크기와 iPhone SE의 1인치 당 2픽셀의 표시 방법을 고려하여, 위젯 크기에 기기 픽셀 비율을 곱하면 적절한 디스플레이 크기인 500이 나옵니다.\n\n다음은 코드 표현입니다.\n\n<div class=\"content-ad\"></div>\n\n\n이미지 네트워크 (\n  imageUrl,\n  width: 250,\n  cacheWidth: (250 * MediaQuery.of(context).devicePixelRatio).round(),\n)\n\n\nMediaQuery를 사용하여 장치의 픽셀 비율을 결정하고 이미지 위젯의 너비와 곱하여 cacheWidth 값을 설정합니다. cacheWidth 속성은 정수 값을 필요로 하므로 round 메소드를 사용하여 가장 가까운 정수로 반올림합니다. 이 코드를 사용하면 장치의 픽셀 비율에 따라 이미지 크기를 조정할 수 있습니다.\n\n더불어 코드를 더 간결하게 만들기 위해 이미지 크기 계산을 확장(extension)으로 구현할 수 있습니다. 확장을 사용한 코드 예시는 다음과 같습니다.\n\n\n확장 ImageExtension on num {\n  int cacheSize(BuildContext context) {\n    return (this * MediaQuery.of(context).devicePixelRatio).round();\n  }\n}\n\n\n<div class=\"content-ad\"></div>\n\n그럼, 이미지 위젯의 확장 기능을 사용하여 필요한 캐시 값을 간결하게 설정할 수 있어요.\n\n```js\nImage.network(  \n  imageUrl,  \n  width: 250,  \n  cacheWidth: 250.cacheSize(context),  \n)\n```\n\n# 캐시 크기 지정 고려 사항\n\n원본 이미지의 종횡비가 대상 위젯의 종횡비와 다를 때, 그리고 이미지 위젯에 fit: BoxFit.cover를 사용할 때 캐시 크기를 설정할 때 특정 측면을 고려해야 해요. 일반적으로 fit: BoxFit.cover를 사용하면 이미지가 위젯에 맞게 잘립니다. 이러한 경우에는 이미지의 표시 크기를 결정할 때 종횡비를 고려해야 해요.\n\n<div class=\"content-ad\"></div>\n\n만약 원본 이미지와 위젯의 종횡비가 다르다면, 이미지를 최적화하는 동안 원본 이미지의 종횡비를 유지하기 위해 작은 차원(너비 또는 높이)을 기준으로 캐시 크기를 설정해야 합니다.\n\n그 반대로 설정하면 해상도가 낮은 이미지가 표시될 수 있습니다.\n\n예를 살펴보겠습니다.\n\n```js\nImage.network(  \n  imageUrl,  \n  width: 250,  \n  height: 250,  \n  cacheWidth: 250.cacheSize(context),  \n  fit: BoxFit.cover,\n)\n```\n\n<div class=\"content-ad\"></div>\n\n\n![Network Images in Flutter](/assets/img/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter_10.png)\n\n- 이미지 크기: 3000 x 1688\n- 이미지 가로 세로 비율: 1.7\n- 디코딩된 이미지의 표시 크기: 500 x 282\n- 이미지 위젯 크기: 250 x 250\n- 이미지 위젯 가로 세로 비율: 1\n\n이미지 위젯은 250 x 250 크기이며 디바이스의 픽셀 비율을 곱한 값인 500을 cacheWidth로 설정하면 이미지의 표시 높이를 자동으로 결정하고 이미지의 가로 세로 비율을 유지합니다. 그러나 원본 이미지의 가로가 세로보다 큰 비율을 가지고 있고, 이는 위젯의 표시에 필요한 가로 세로 비율과 다르기 때문에, 디코딩된 이미지의 표시 높이(281)가 목표 표시 높이(500)보다 낮아져 이미지가 흐릿하게 보일 수 있습니다. 예시 사진에 나와 있습니다.\n\n반면, cacheHeight를 설정하면…\n\n\n<div class=\"content-ad\"></div>\n\n```js\nImage.network(\n  imageUrl,\n  width: 250,\n  height: 250,\n  cacheHeight: 250.cacheSize(context),\n  fit: BoxFit.cover,\n)\n```\n\n<img src=\"/assets/img/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter_11.png\" />\n\n캐시 높이를 설정하면 이미지의 종횡비를 유지하면서 최소 표시 크기로 크기를 조정하여 이미지의 해상도를 유지합니다.\n\n기존의 오버사이즈된 오류 로그는 여전히 발생하지만, 이미지의 크기를 크게 줄이고 종횡비를 유지하여 선명한 이미지를 제공하도록 최적화되었습니다.\n\n<div class=\"content-ad\"></div>\n\n# 이미지 종횡비를 고려한 캐시 크기 동적 설정\n\n대부분의 경우에는 프런트엔드 개발자가 네트워크 이미지의 종횡비를 사전에 알지 못합니다. 이러한 상황에서는 원본 이미지의 종횡비가 0보다 큰지 여부를 기반으로 캐시 크기를 동적으로 결정할 수 있습니다.\n\n```js\nBuilder(  \n  builder: (context) {  \n    int? cacheWidth, cacheHeight;  \n    Size targetSize = const Size(250, 250);  \n    const double originImgAspectRatio = 1.7;  \n   \n    // 원본 이미지의 종횡비가 0보다 큰 경우, 이미지가 세로보다 넓은 것을 의미합니다.\n    if (originImgAspectRatio > 0) {  \n      cacheHeight = targetSize.height.cacheSize(context);  \n    } else {  \n      cacheWidth = targetSize.width.cacheSize(context);  \n    }  \n  \n    return Image.network(  \n      imageUrl,  \n      width: targetSize.width,  \n      height: targetSize.height,  \n      cacheWidth: cacheWidth,  \n      cacheHeight: cacheHeight,  \n      fit: BoxFit.cover,  \n    );  \n  },  \n)\n```\n\n위 코드에서는 원본 이미지의 종횡비(originImgAspectRatio)를 사용하여 조건부로 cacheWidth 또는 cacheHeight를 캐시 크기로 설정합니다. 앞서 언급한 대로 캐시 크기 속성 중 하나만 설정하면 이미지가 종횡비에 맞게 크기가 조정되므로 다른 속성을 null로 설정해도 괜찮습니다.\n\n<div class=\"content-ad\"></div>\n\n# CacheNetworkImage 패키지\n\nFlutter는 네트워크에서 이미지를로드하기 위한 Image.network 위젯을 제공하지만 이미지 캐싱에는 cached_network_image 패키지를 사용하는 것이 좋습니다. 이 패키지는 세밀한 캐싱 제어를 제공하여 성능을 향상시킬 수 있습니다. 아래는 cached_network_image 패키지를 사용하는 예시입니다.\n\n```js\nCachedNetworkImage(  \n  imageUrl: imageUrl,  \n  memCacheHeight: 320.cacheSize(context),  \n  memCacheWidth: 250.cacheSize(context),  \n)\n```\n\nCachedNetworkImage 위젯을 사용하면 Image.network 위젯과 유사하게 캐시 크기를 지정하기 위해 memCacheHeight 및 memCacheWidth 속성을 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n이 글에서는 Flutter에서 네트워크 이미지를 효율적으로 로드하고 메모리 사용량을 최적화하는 방법을 살펴보았습니다. 앱 개발 중 가장 중요한 측면 중 하나이지만 쉽게 간과될 수 있는 문제로, 특히 애플리케이션에서 고해상도 이미지를 다룰 때 부드러운 사용자 경험을 위해 중요합니다.\n\nFlutter에서 이미지 처리에 대한 더 많은 팁과 모범 사례에 관심이 있다면, 잘 문서화된 \"Flutter를 사용한 최상의 UX 성능을 위한 12가지 이미지 팁과 모범 사례\" 문서를 참고하실 수 있습니다.\n\n본 글에서 논의된 예제 코드에 대해 궁금하시다면, 제 GitHub 저장소에서 확인하실 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n위 내용을 읽어 주셔서 감사합니다!\n\n# 참고 자료\n\n- https://www.themoviedb.org/tv/1396-breaking-bad/images/backdrops?language=ko\n- https://api.flutter.dev/flutter/painting/debugInvertOversizedImages.html\n- https://github.com/flutter/flutter/issues/56239","ogImage":{"url":"/assets/img/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter_0.png"},"coverImage":"/assets/img/2024-06-21-SaveYourMemoryUsageByOptimizingNetworkImagesinFlutter_0.png","tag":["Tech"],"readingTime":10},{"title":"VS Code에서 Flutter 프로젝트 만드는 방법  단계별 완벽 가이드","description":"","date":"2024-06-21 21:30","slug":"2024-06-21-HowtocreateFlutterprojectinVSCodeStep-by-stepcompleteguide","content":"\n\n![image](/assets/img/2024-06-21-HowtocreateFlutterprojectinVSCodeStep-by-stepcompleteguide_0.png)\n\n새로운 Flutter 프로젝트를 Visual Studio Code 내에서 생성하는 단계별 가이드를 제공합니다:\n\n시작하기 전에, 머신에 Flutter 및 Dart SDK가 설치되어 있는지 확인하세요. 공식 Flutter 웹사이트에서 다운로드하고 운영 체제에 맞는 설치 지침을 따를 수 있습니다.\n\n![image](/assets/img/2024-06-21-HowtocreateFlutterprojectinVSCodeStep-by-stepcompleteguide_1.png)\n\n<div class=\"content-ad\"></div>\n\n만약 Visual Studio Code가 설치되어 있지 않다면, 공식 웹사이트에서 다운로드하여 설치해주세요: go\n\nVisual Studio Code를 실행한 다음, 창 옆의 활동 표시줄에서 확장 아이콘을 클릭하여 확장 보기로 이동합니다. \"Flutter\"와 \"Dart\" 확장 프로그램을 검색하여 설치하세요. 이러한 확장 프로그램은 Flutter 개발을 위한 언어 지원 및 추가 도구를 제공합니다.\n\n<img src=\"/assets/img/2024-06-21-HowtocreateFlutterprojectinVSCodeStep-by-stepcompleteguide_2.png\" />\n\n이제 모든 준비가 끝났으므로 새로운 Flutter 프로젝트를 생성할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n- Visual Studio Code를 열어주세요.\n- 상단 메뉴에서 \"View\"를 클릭한 후 \"Command Palette...\"를 선택해주세요(또는 Windows/Linux에서는 Ctrl+Shift+P, macOS에서는 Cmd+Shift+P 단축키를 사용할 수 있습니다).\n\n![이미지](/assets/img/2024-06-21-HowtocreateFlutterprojectinVSCodeStep-by-stepcompleteguide_3.png)\n\n- Command Palette에 \"Flutter: New Project\"를 입력하고 해당 옵션이 나타나면 선택해주세요.\n\n![이미지](/assets/img/2024-06-21-HowtocreateFlutterprojectinVSCodeStep-by-stepcompleteguide_4.png)\n\n<div class=\"content-ad\"></div>\n\n- \"Flutter: New Project\"을 선택한 후 프로젝트 유형을 선택하라는 메시지가 표시됩니다. 표준 Flutter 프로젝트를 위해 \"Flutter Application\"을 선택할 수 있습니다.\n\n![image](/assets/img/2024-06-21-HowtocreateFlutterprojectinVSCodeStep-by-stepcompleteguide_5.png)\n\n- 이후 새 프로젝트를 생성할 위치를 선택하고 이름을 제공하세요. 프로젝트 파일에 쓰기 권한이 있는 위치를 선택하고 쉽게 프로젝트 파일에 액세스할 수 있는 곳을 선택하세요.\n\nVS Code가 대신 새 Flutter 프로젝트를 생성할 것입니다. 이 작업에는 필요한 종속성을 다운로드하고 초기 프로젝트 구조를 설정하는 데 시간이 걸릴 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n프로젝트가 생성되면 VS Code가 자동으로 프로젝트 폴더를 엽니다. 여기에 프로젝트 파일과 폴더가 나타납니다.\n\nFlutter 앱을 실행하려면 에뮬레이터/시뮬레이터 또는 실제 기기가 필요합니다.\n\n에뮬레이터/시뮬레이터:\n\n- Android 에뮬레이터: Android를 타겟팅하는 경우, Android Studio가 설치되어 있는지 확인하고 AVD Manager에서 Android 에뮬레이터를 설정할 수 있습니다.\n- iOS 시뮬레이터: iOS를 타겟팅하는 경우, Xcode를 사용하여 iOS 시뮬레이터를 설정할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n피지컬 디바이스:\n\n- 안드로이드와 iOS 모두 USB를 이용해 컴퓨터에 피지컬 디바이스를 연결할 수 있어요. Android 디바이스의 경우 USB 디버깅이 활성화되어 있는지 확인해 주세요.\n\nFlutter 앱을 실행하는 두 가지 방법이 있어요,\n\n첫 번째 방법:\n\n<div class=\"content-ad\"></div>\n\n아래는 마크다운 형식으로 지정되었습니다.\n\n\n![이미지](/assets/img/2024-06-21-HowtocreateFlutterprojectinVSCodeStep-by-stepcompleteguide_6.png)\n\n노트: main.dart 파일에서 작업 중인지 확인하세요.\n\n두 번째 방법:\n\n터미널을 열고 flutter run 명령을 실행한 후 Enter 키를 누릅니다.\n\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-21-HowtocreateFlutterprojectinVSCodeStep-by-stepcompleteguide_7.png\" />\n\n이제 선택한 기기(에뮬레이터 또는 실제 장치)에서 플러터 앱이 실행 중입니다. 앱을 실제 애플리케이션처럼 상호 작용할 수 있으며 코드를 변경하면 자동으로 핫 리로드되어 변경 사항을 즉시 확인할 수 있습니다.\n\n새 플러터 프로젝트를 설정하고 실행한 후에 앱 개발을 시작할 수 있습니다! Visual Studio Code의 코드 자동 완성, 디버깅 및 통합 터미널과 같은 강력한 기능을 활용하여 개발 프로세스를 원할하고 효율적으로 만들어 보세요.\n\n그게 다예요! 이제 Visual Studio Code 내에서 새 플러터 프로젝트를 성공적으로 만들고 앱 개발을 시작했습니다. 멋진 플러터 애플리케이션을 개발하는 재미를 느껴보세요! 추가 질문이 있거나 도움이 필요하면 언제든지 물어보세요. 즐거운 코딩하세요!","ogImage":{"url":"/assets/img/2024-06-21-HowtocreateFlutterprojectinVSCodeStep-by-stepcompleteguide_0.png"},"coverImage":"/assets/img/2024-06-21-HowtocreateFlutterprojectinVSCodeStep-by-stepcompleteguide_0.png","tag":["Tech"],"readingTime":3},{"title":"플러터 위젯 생명주기 모든 것을 알아보세요","description":"","date":"2024-06-21 21:28","slug":"2024-06-21-FlutterWidgetLifecycleEverythingYouNeedtoKnow","content":"\n\n![이미지](/assets/img/2024-06-21-FlutterWidgetLifecycleEverythingYouNeedtoKnow.png)\n\n플러터(Flutter)는 구글의 UI 툴킷으로, 모바일, 웹 및 데스크톱용으로 아름답고 네이티브로 결합된 애플리케이션을 단일 코드베이스에서 빠르게 개발할 수 있도록 도와줍니다. 이는 상태를 가지는(stateful) 및 상태를 가지지 않는(stateless) 위젯의 조합입니다. 위젯 라이프사이클을 이해하는 것은 고품질의 플러터 애플리케이션을 개발하기 위해 꼭 필요합니다.\n\n이 블로그 포스트에서는 실제 예제와 함께 플러터에서의 위젯 라이프사이클에 대해 학습하여 작동 방식을 이해하는 데 도움이 되도록 하겠습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:960/1*i4BhVQPDcv8mspZ1TOP4_g.gif)\n\n<div class=\"content-ad\"></div>\n\n위젯 생명주기에 들어가기 전에, 이 위젯이 무엇을 의미하며 Flutter에서 어떤 유형의 위젯이 있는지 먼저 이해해 보겠습니다.\n\n# 위젯이란 무엇인가요?\n\n위젯은 Flutter 애플리케이션의 구성 요소입니다. 버튼에서 복잡한 UI 구성 요소까지 모든 것이 될 수 있습니다. 위젯은 애플리케이션의 사용자 인터페이스를 구성하는 데 사용됩니다. Flutter 애플리케이션은 위젯 트리로 구성됩니다. 각 위젯은 고유한 속성을 가지며 다른 위젯 내에 중첩될 수 있습니다.\n\n여기서 위젯을 자세히 설명했습니다.\n\n<div class=\"content-ad\"></div>\n\n- 상태가 없는 위젯.\n- 상태를 가지는 위젯.\n\n상태가 없는 위젯은 상태를 포함하지 않기 때문에 부모가 변경될 때만 업데이트될 수 있습니다. 생성된 후에 상태가 없는 위젯은 업데이트할 수 없으므로 변하지 않고 불변성을 가집니다. 변경 사항을 보려면 새 데이터를 제공하여 다시 만들어야 합니다.\n\n```dart\nimport 'package:flutter/material.dart';\n\nvoid main() => runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Container();\n  }\n}\n```\n\n상태를 가지는 위젯은 내부적으로 상태를 가지므로 상태가 변경될 때나 부모가 변경될 때 업데이트될 수 있습니다. 가변적인 위젯이므로 수명 동안 여러 번 그려질 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```dart\nimport 'package:flutter/material.dart';\n\nvoid main() => runApp(MyApp());\n\nclass MyApp extends StatefulWidget {\n  @override\n  _MyAppState createState() => _MyAppState();\n}\n\nclass _MyAppState extends State<MyApp> {\n  @override\n  Widget build(BuildContext context) {\n    return Container();\n  }\n}\n```\n\n![Flutter Widget Lifecycle - Everything You Need to Know](/assets/img/2024-06-21-FlutterWidgetLifecycleEverythingYouNeedtoKnow_1.png)\n\n# 위젯 라이프사이클 메서드란:\n\n위젯 라이프사이클은 위젯이 생성, 업데이트 또는 파괴될 때 발생하는 일련의 이벤트입니다. 위젯 라이프사이클을 이해하는 것은 효율적인 Flutter 애플리케이션을 작성하는 데 중요합니다.\n\n\n<div class=\"content-ad\"></div>\n\n- createState(): 위 메서드는 위젯의 상태 객체를 생성합니다. 상태를 가진 위젯을 만들 때, 프레임워크는 createState() 메서드를 호출하며 이를 재정의해야 합니다.\n\n```dart\nclass MyPage extends StatefulWidget {\n  @override\n  _MyPageState createState() => _MyPageState();\n}\n```\n\n- initState(): 위 메서드는 상태 객체 생성 후에 호출됩니다. 위젯의 상태를 초기화하는 데 사용됩니다.\n\n```dart\nlate int _counter;\n@override\nvoid initState() {\n  print(\"initState\");\n  _counter = 0;\n  super.initState();\n}\n```\n\n<div class=\"content-ad\"></div>\n\n- build() 메서드: 이 메서드는 상태 객체가 초기화된 후에 호출됩니다. 위젯 트리를 구축하는 데 사용됩니다. initState, didChangeDependencies, didUpdateWidget 또는 setState를 통해 상태가 변경된 후에 위젯이 다시 빌드될 때마다 호출됩니다.\n\n```dart\n  @override\n  Widget build(BuildContext context) {\n    print(\"build\");\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text(\"Lifecycle Demo\"),\n      ),\n      body: Container(\n          child: Column(\n        children: [\n          Text(_counter.toString()),\n          ElevatedButton(onPressed: _increment, child: const Text(\"Increment\"))\n        ],\n      )),\n    );\n  }\n```\n\n- didChangeDependencies() 메서드: 이 메서드는 initState 후에 즉시 호출되며, 상태 객체의 종속성이 InheritedWidget을 통해 변경된 경우에 호출됩니다.\n\n```dart\n  @override\n  void didChangeDependencies() {\n    print(\"didChangeDependencies\");\n    super.didChangeDependencies();\n  }\n```\n\n<div class=\"content-ad\"></div>\n\n- didUpdateWidget(): 위젯이 새로운 속성으로 업데이트될 때 호출되는 메서드입니다. 일반적인 경우는 부모가 생성자를 통해 자식 위젯에 변수를 전달할 때입니다.\n\n```js\n  @override\n  void didUpdateWidget(covariant MyPage oldWidget) {\n    print(\"didUpdateWidget\");\n    super.didUpdateWidget(oldWidget);\n  }\n```\n\n- deactivate(): 이 메서드는 State가 subtree A에서 제거되고 GlobalKey를 사용하여 subtree B로 다시 삽입될 때 호출됩니다.\n\n```js\n  @override\n  void deactivate() {\n    print(\"deactivate\");\n    super.deactivate();\n  }\n```\n\n<div class=\"content-ad\"></div>\n\n- dispose(): 위젯이 영구적으로 파괴되기 전에 호출되는 메서드입니다. 네트워크 연결을 닫거나 애니메이션을 중지하는 등 위젯이 사용한 모든 리소스를 해제하는 데 사용됩니다.\n\n```js\n  @override\n  void dispose() {\n    print(\"dispose\");\n    super.dispose();\n  }\n```\n\n코드 파일\n\n```js\nclass MyPage extends StatefulWidget {\n  const MyPage({super.key});\n\n  @override\n  State<MyPage> createState() {\n    print(\"createState\");\n    return _MyPageState();\n  }\n}\n\nclass _MyPageState extends State<MyPage> {\n  void _increment() {\n    setState(() {\n      _counter = _counter + 1;\n    });\n  }\n\n  late int _counter;\n  @override\n  void initState() {\n    print(\"initState\");\n    _counter = 0;\n    super.initState();\n  }\n\n  @override\n  void didChangeDependencies() {\n    print(\"didChangeDependencies\");\n    super.didChangeDependencies();\n  }\n\n  @override\n  void didUpdateWidget(covariant MyPage oldWidget) {\n    print(\"didUpdateWidget\");\n    super.didUpdateWidget(oldWidget);\n  }\n\n  @override\n  void dispose() {\n    print(\"dispose\");\n    super.dispose();\n  }\n\n  @override\n  void deactivate() {\n    print(\"deactivate\");\n    super.deactivate();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    print(\"build\");\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text(\"Lifecycle Demo\"),\n      ),\n      body: Container(\n          child: Column(\n        children: [\n          Text(_counter.toString()),\n          ElevatedButton(onPressed: _increment, child: const Text(\"Increment\"))\n        ],\n      )),\n    );\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n라이프사이클 메서드의 순서:\n\n![라이프사이클](/assets/img/2024-06-21-FlutterWidgetLifecycleEverythingYouNeedtoKnow_2.png)\n\n# 결론\n\n요약하면, 위젯 라이프사이클을 이해하는 것은 고품질의 플러터 애플리케이션을 개발하는 데 필수적입니다. 위젯은 플러터 애플리케이션의 구성 요소이며, 각 위젯은 고유의 라이프사이클을 갖습니다. 위젯 라이프사이클을 숙지함으로써 더 효율적이고 효과적인 플러터 애플리케이션을 개발할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n❤ ❤ 이 글 읽어 주셔서 감사합니다 ❤ ❤\n\n만약 이 블로그가 유익하다고 느끼신다면 아래에 👏 클랩(clap)을 부탁드립니다.\n\nLinkedIn에서 연결해요.\n\n저는 플러터 앱 라이프사이클에 관한 모든 것을 설명한 이 블로그를 썼어요 (위젯 라이프사이클과는 다릅니다)","ogImage":{"url":"/assets/img/2024-06-21-FlutterWidgetLifecycleEverythingYouNeedtoKnow_0.png"},"coverImage":"/assets/img/2024-06-21-FlutterWidgetLifecycleEverythingYouNeedtoKnow_0.png","tag":["Tech"],"readingTime":6},{"title":"예제와 함께 배우는 Flutter에서의 MVC 아키텍처 완벽 가이드","description":"","date":"2024-06-21 21:27","slug":"2024-06-21-UnderstandingMVCArchitectureinFlutterAComprehensiveGuidewithExamples","content":"\n\n<img src=\"/assets/img/2024-06-21-UnderstandingMVCArchitectureinFlutterAComprehensiveGuidewithExamples_0.png\" />\n\n소개: 소프트웨어 개발 세계에서 아키텍처 패턴은 확장 가능하고 유지보수 가능하며 견고한 애플리케이션을 구축하는 데 중요한 역할을 합니다. Model-View-Controller (MVC)는 이러한 아키텍처 패턴 중 하나로, 애플리케이션의 관심사를 Model, View 및 Controller라는 세 가지 구성 요소로 분리합니다. 이 기사에서는 인기 있는 크로스 플랫폼 프레임워크인 Flutter의 맥락에서 MVC 아키텍처를 탐구하고 구현 방법을 이해하는 데 도움이 되는 실용적인 예제를 제공할 것입니다.\n\n- MVC 아키텍처란 무엇인가요? Model-View-Controller (MVC) 아키텍처는 애플리케이션을 세 가지 구성 요소로 분리하여 코드의 조직화와 모듈화를 더 잘할 수 있게 해주는 디자인 패턴입니다. 각 구성 요소를 간단히 이해해 봅시다:\n\n- Model: 애플리케이션의 데이터와 비즈니스 로직을 나타냅니다. 데이터를 캡슐화하고 상호 작용하고 조작할 수 있는 메서드를 제공합니다.\n- View: 애플리케이션의 사용자 인터페이스(UI)를 나타냅니다. Model의 데이터를 표시하고 사용자와 상호 작용합니다.\n- Controller: Model과 View 사이의 중개자 역할을 합니다. 사용자 입력을 처리하고 입력에 따라 모델을 조작하고 View를 그에 맞게 업데이트합니다.\n\n<div class=\"content-ad\"></div>\n\n- Flutter에서 MVC 구현: Flutter에서 MVC 패턴을 구현하려면 다음 가이드라인을 따를 수 있습니다:\n\n- Model: 데이터 및 비즈니스 로직을 표현하는 별도의 클래스를 만듭니다. 예를 들어, 작업 목록을 관리하는 간단한 앱을 고려해 보겠습니다. 다음과 같은 Task 클래스를 정의할 수 있습니다:\n\n```js\nclass Task {\n  String title;\n  bool completed;\n\n  Task(this.title, this.completed);\n}\n```\n\n- View: Flutter에서 위젯은 UI 구성 요소를 나타냅니다. 데이터를 표시하고 사용자 입력을 캡처하는 위젯을 생성합니다. 작업 관리 앱의 경우 TaskListView 위젯을 만들어 작업 목록을 표시할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```dart\nclass TaskListView extends StatefulWidget {\n  final TaskListController controller;\n\n  const TaskListView({\n    super.key,\n    required this.controller\n  });\n\n  @override\n  State<TaskListView> createState() => _TaskListViewState();\n}\n\nclass _TaskListViewState extends State<TaskListView> {\n  @override\n  Widget build(BuildContext context) {\n    return ListView.builder(\n      itemCount: widget.controller.tasks.length,\n      itemBuilder: (context, index) {\n        final task = widget.controller.tasks[index];\n        return ListTile(\n          title: Text(task.title),\n          leading: Checkbox(\n            value: task.completed,\n            onChanged: (value) {\n              setState(() =>\n                widget.controller.toggleTaskCompletion(index)\n              );\n            },\n          ),\n        );\n      },\n    );\n  }\n}\n```\n\n- 컨트롤러: 사용자 입력을 처리하고 모델 및 뷰를 업데이트하는 별도의 클래스를 만듭니다. 이 예에서는 TaskListController 클래스를 만들 수 있습니다:\n\n```dart\nclass TaskListController {\n  List<Task> tasks = [\n    Task('Task 1', false),\n    Task('Task 2', true),\n    Task('Task 3', false),\n  ];\n\n  void toggleTaskCompletion(int index) {\n    tasks[index].completed = !tasks[index].completed;\n  }\n}\n```\n\n- 전부 합치기: 이제 모델, 뷰 및 컨트롤러를 연결하여 작동하는 앱을 만들어 봅시다.\n\n\n<div class=\"content-ad\"></div>\n\n```dart\nvoid main() {\n  runApp(TaskListApp());\n}\n\nclass TaskListApp extends StatelessWidget {\n  final TaskListController controller = TaskListController();\n\n  TaskListApp({Key key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('Task List'),\n        ),\n        body: TaskListView(controller: controller),\n      ),\n    );\n  }\n}\n```\n\n- 플러터에서 MVC 사용의 장점: MVC 아키텍처는 플러터 애플리케이션 개발 시 여러 가지 이점을 제공합니다.\n\n- 관심사 분리: MVC는 데이터, UI 및 로직 간 명확한 분리를 촉진하여 코드베이스를 이해하고 테스트하고 유지 보수하는 것을 더 쉽게 만듭니다.\n- 재사용성: MVC의 모듈식 구조는 애플리케이션의 다른 부분에서 구성 요소를 재사용할 수 있도록 합니다.\n- 확장성: Model, View 및 Controller를 분리함으로써 새로운 기능을 추가하거나 기존 기능을 수정할 때 다른 구성 요소에 영향을 주지 않게 됩니다.\n\n결론: Model-View-Controller(MVC)는 플러터 애플리케이션 구축에 구조화된 접근 방식을 제공하는 강력한 아키텍처 패턴입니다. 관심사를 분리하고 코드를 구별 구성 요소로 구성함으로써, 개발자는 더 나은 코드 유지 보수성, 확장성 및 재사용성을 달성할 수 있습니다. 플러터에서 MVC를 이해하고 구현함으로써 개발 프로세스를 크게 개선하고 더 나은 소프트웨어 품질을 달성할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n# 소스 코드\n\nhttps://github.com/Faiz-rhm/TaskList-MVC","ogImage":{"url":"/assets/img/2024-06-21-UnderstandingMVCArchitectureinFlutterAComprehensiveGuidewithExamples_0.png"},"coverImage":"/assets/img/2024-06-21-UnderstandingMVCArchitectureinFlutterAComprehensiveGuidewithExamples_0.png","tag":["Tech"],"readingTime":4},{"title":"플러터 고급 인터뷰 질문  코드 예제로 풀어보는 세부 가이드","description":"","date":"2024-06-21 21:23","slug":"2024-06-21-FlutterAdvancedInterviewQuestionsADetailedGuidewithCodingExamples","content":"\n\n![image](/assets/img/2024-06-21-FlutterAdvancedInterviewQuestionsADetailedGuidewithCodingExamples_0.png)\n\n# 소개:\n\nFlutter는 Google의 UI 툴킷으로, 모바일, 웹 및 데스크톱용 네이티브 컴파일된 애플리케이션을 단일 코드베이스에서 구축하는 데 사용됩니다. 이식성, 성능 및 사용 편의성으로 개발자들 사이에서 엄청난 인기를 얻고 있습니다. 이 기사에서는 고급 Flutter 개념과 모범 사례에 대해 살펴보고, 여러분의 Flutter 스킬을 향상시키고 견고한 애플리케이션을 구축하는 데 도움이 될 것입니다.\n\n# 1. 사용자 정의 페인터의 개념을 설명하고 사용자 정의 UI 요소를 생성하는 방법에 대해 설명해주세요.\n\n<div class=\"content-ad\"></div>\n\n플러터에서의 사용자 정의 페인터(Custom painters)는 캔버스에 직접 그리는 것으로 복잡하고 사용자 정의된 UI 요소를 생성할 수 있게 해줍니다. 이를 통해 UI 구성 요소의 모양과 동작에 대해 세밀한 제어가 가능해집니다.\n\n예를 들어, 사용자 정의 페인터를 사용하여 서명 패드와 같은 사용자 정의 UI 요소를 만들 수 있습니다:\n\n```js\nimport 'package:flutter/material.dart';\n\nclass SignaturePad extends StatefulWidget {\n  @override\n  _SignaturePadState createState() => _SignaturePadState();\n}\n\nclass _SignaturePadState extends State<SignaturePad> {\n  List<Offset> _points = <Offset>[];\n\n  @override\n  Widget build(BuildContext context) {\n    return GestureDetector(\n      onPanUpdate: (DragUpdateDetails details) {\n        setState(() {\n          RenderBox renderBox = context.findRenderObject() as RenderBox;\n          _points.add(renderBox.globalToLocal(details.globalPosition));\n        });\n      },\n      onPanEnd: (DragEndDetails details) => _points.add(null),\n      child: CustomPaint(\n        painter: SignaturePainter(_points),\n        size: Size.infinite,\n      ),\n    );\n  }\n}\n\nclass SignaturePainter extends CustomPainter {\n  SignaturePainter(this.points);\n\n  final List<Offset> points;\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    Paint paint = Paint()\n      ..color = Colors.black\n      ..strokeCap = StrokeCap.round\n      ..strokeWidth = 5.0;\n\n    for (int i = 0; i < points.length - 1; i++) {\n      if (points[i] != null && points[i + 1] != null) {\n        canvas.drawLine(points[i], points[i + 1], paint);\n      }\n    }\n  }\n\n  @override\n  bool shouldRepaint(SignaturePainter other) => other.points != points;\n}\n```\n\n이 예제에서 SignaturePad는 캔버스에 선을 그리기 위해 터치 이벤트를 캡처하는 사용자 정의 위젯입니다. CustomPaint 위젯은 SignaturePainter 클래스를 사용하여 캔버스에 그림을 그리며, 이 클래스는 선이 어떻게 그려지는지를 정의합니다.\n\n<div class=\"content-ad\"></div>\n\n---\n\n# 2. Flutter에서 플랫폼별 기능에 액세스하기 위한 네이티브 모듈을 생성하는 방법을 설명합니다.\n\nFlutter에서 플랫폼별 기능에 액세스하기 위해 네이티브 모듈을 생성하려면 플랫폼 채널을 사용할 수 있습니다. 플랫폼 채널을 통해 Dart 코드와 네이티브 코드 (Android의 경우 Java/Kotlin, iOS의 경우 Objective-C/Swift) 간의 통신이 가능합니다.\n\n다음은 네이티브 토스트 메시지를 표시하는 네이티브 모듈을 생성하는 기본 예시입니다:\n\n<div class=\"content-ad\"></div>\n\n먼저 메서드 채널을 정의하겠습니다:\n\n```js\nimport 'package:flutter/services.dart';\n\nconst platform = MethodChannel('example.com/toast');\n\nFuture<void> showToast(String message) async {\n  try {\n    await platform.invokeMethod('showToast', {'message': message});\n  } on PlatformException catch (e) {\n    print(\"토스트 메시지 표시에 실패했습니다: '${e.message}'.\");\n  }\n}\n```\n\n다음으로, 각 플랫폼별로 네이티브 코드를 구현하겠습니다:\n\n## 안드로이드 (Java/Kotlin):\n\n<div class=\"content-ad\"></div>\n\n```js\r\nimport android.content.Context;\nimport android.widget.Toast;\nimport io.flutter.plugin.common.MethodCall;\nimport io.flutter.plugin.common.MethodChannel;\nimport io.flutter.plugin.common.MethodChannel.MethodCallHandler;\nimport io.flutter.plugin.common.MethodChannel.Result;\nimport io.flutter.plugin.common.PluginRegistry.Registrar;\n\npublic class ToastPlugin implements MethodCallHandler {\n  private final Context context;\n\n  private ToastPlugin(Context context) {\n    this.context = context;\n  }\n\n  public static void registerWith(Registrar registrar) {\n    final MethodChannel channel = new MethodChannel(registrar.messenger(), \"example.com/toast\");\n    channel.setMethodCallHandler(new ToastPlugin(registrar.context()));\n  }\n\n  @Override\n  public void onMethodCall(MethodCall call, Result result) {\n    if (call.method.equals(\"showToast\")) {\n      String message = call.argument(\"message\");\n      showToast(message);\n    } else {\n      result.notImplemented();\n    }\n  }\n\n  private void showToast(String message) {\n    Toast.makeText(context, message, Toast.LENGTH_SHORT).show();\n  }\n}\n```\n\n## iOS (Objective-C/Swift):\n\n```js\r\nimport Flutter\nimport UIKit\n\npublic class SwiftToastPlugin: NSObject, FlutterPlugin {\n  public static func register(with registrar: FlutterPluginRegistrar) {\n    let channel = FlutterMethodChannel(name: \"example.com/toast\", binaryMessenger: registrar.messenger())\n    let instance = SwiftToastPlugin()\n    registrar.addMethodCallDelegate(instance, channel: channel)\n  }\n\n  public func handle(_ call: FlutterMethodCall, result: @escaping FlutterResult) {\n    if call.method == \"showToast\" {\n      if let args = call.arguments as? Dictionary<String, Any>,\n         let message = args[\"message\"] as? String {\n        showToast(message)\n      }\n    } else {\n      result(FlutterMethodNotImplemented)\n    }\n  }\n\n  private func showToast(_ message: String) {\n    if let viewController = UIApplication.shared.keyWindow?.rootViewController {\n      let toast = UIAlertController(title: nil, message: message, preferredStyle: .alert)\n      viewController.present(toast, animated: true)\n      DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 2) {\n        toast.dismiss(animated: true)\n      }\n    }\n  }\n}\n```\n\nAppDelegate(iOS)와 MainActivity(Android)에서 플러그인을 등록해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n지금은 showToast 메서드를 호출하여 Dart 코드로 네이티브 토스트 메시지를 표시할 수 있어요.\n\n```js\nshowToast(\"Hello, Native Toast!\");\n```\n\n이것은 매우 기본적인 예제에 불과하지만, 이 패턴을 확장하여 다양한 플랫폼별 기능에 접근하는 더 복잡한 네이티브 모듈을 만들 수 있어요.\n\n— — —\n\n<div class=\"content-ad\"></div>\n\n# 3. 플러터 앱을 테스트하는 방법을 설명해주세요 (예: 유닛 테스팅, 위젯 테스팅, 통합 테스팅).\n\n플러터 앱을 테스트할 때, 나는 유닛 테스팅, 위젯 테스팅 및 통합 테스팅을 포함한 종합적인 접근 방식을 따릅니다.\n\n## * 유닛 테스팅:\n\n각 함수와 클래스에 대한 유닛 테스트를 작성하여 독립적으로 예상대로 작동하는지 확인합니다. 유당 떄 내장된 flutter_test 패키지와 test 패키지를 활용합니다. mockito와 같은 모킹 프레임워크를 사용하여 종속성을 모킹하는 데 도움이 됩니다.\n\n<div class=\"content-ad\"></div>\n\n예시:\n\n```js\nvoid main() {\n  test('String.trim() removes surrounding whitespace', () {\n    expect('  hello  '.trim(), 'hello');\n  });\n}\n```\n\n## 위젯 테스트:\n\n위젯 테스트는 UI 구성 요소를 격리하여 테스트하는 데 사용됩니다. flutter_test 패키지를 사용하고 WidgetTester를 활용하여 위젯과 그 동작을 검증합니다.\n\n<div class=\"content-ad\"></div>\n\n예시:\n\n```js\nvoid main() {\n  testWidgets('Counter increments smoke test', (WidgetTester tester) async {\n    await tester.pumpWidget(MyApp());\n    expect(find.text('0'), findsOneWidget);\n    await tester.tap(find.byIcon(Icons.add));\n    await tester.pump();\n    expect(find.text('1'), findsOneWidget);\n  });\n}\n```\n\n## * 통합 테스트:\n\n통합 테스트는 앱의 다양한 부분 간 상호 작용을 테스트하는 데 사용됩니다. 저는 플러터 드라이버 패키지와 플러터 테스트 패키지를 이용하여 통합 테스트를 작성합니다. 이러한 테스트는 실제 디바이스나 에뮬레이터에서 실행되며 사용자 상호작용을 시뮬레이트합니다.\n\n<div class=\"content-ad\"></div>\n\n예시:\n\n```js\nvoid main() {\n  group('카운터 앱', () {\n    FlutterDriver driver;\n\n    setUpAll(() async {\n      driver = await FlutterDriver.connect();\n    });\n\n    tearDownAll(() async {\n      if (driver != null) {\n        driver.close();\n      }\n    });\n\n    test('카운터를 증가시킵니다', () async {\n      await driver.tap(find.byType(FloatingActionButton));\n      expect(await driver.getText(find.text('1')), '1');\n    });\n  });\n}\n```\n\n이러한 테스트 전략을 개발 프로세스에 통합하여, 내 Flutter 앱을 견고하고 신뢰할 수 있게 만들고 있어요.\n\n---\n\n<div class=\"content-ad\"></div>\n\n# 4. 고급 Dart 개념인 제네릭, 스트림, 아이솔레이트 및 비동기 프로그래밍에 대해 이야기해보세요.\n\n## 제네릭:\n\n제네릭은 모든 데이터 유형과 작동할 수 있는 재사용 가능한 코드를 작성할 수 있게 합니다. 컴파일 시간에 타입 안전성을 제공하며 유연한 데이터 구조 및 알고리즘을 생성할 수 있도록 합니다.\n\n예시:\n\n<div class=\"content-ad\"></div>\n\n```dart\nclass Box<T> {\n  T value;\n\n  Box(this.value);\n}\n\nvoid main() {\n  var box = Box<int>(10);\n  print(box.value); // Output: 10\n}\n```\n\n## 스트림:\n\n스트림은 비동기 데이터 이벤트의 시퀀스를 나타냅니다. 이를 통해 비동기 데이터를 반응적인 방식으로 처리할 수 있습니다. 스트림은 주로 사용자 입력, 네트워크 요청 및 데이터 동기화를 처리하는 데에 사용됩니다.\n\n예시:\n\n<div class=\"content-ad\"></div>\n\n```dart\nimport 'dart:async';\n\nvoid main() {\n  Stream<int> stream = countStream(5);\n  stream.listen((int value) {\n    print(value); // 출력: 0, 1, 2, 3, 4\n  });\n}\n\nStream<int> countStream(int max) async* {\n  for (int i = 0; i < max; i++) {\n    yield i;\n  }\n}\n```\n\n## Isolates:\n\n아이솔레이트(Isolates)는 Dart의 동시성 모델로, 코드를 병렬로 실행할 수 있게 합니다. 이들은 서로 독립적이며 메시지 전달을 통해 통신합니다. 아이솔레이트는 비용이 많이 드는 계산, I/O에 바운드된 작업 및 백그라운드 처리에 유용합니다.\n\n예시:\n\n<div class=\"content-ad\"></div>\n\n```dart\nimport 'dart:isolate';\n\nvoid main() async {\n  ReceivePort receivePort = ReceivePort();\n  await Isolate.spawn(echo, receivePort.sendPort);\n\n  sendReceive(receivePort);\n}\n\nvoid echo(SendPort sendPort) {\n  ReceivePort receivePort = ReceivePort();\n  sendPort.send(receivePort.sendPort);\n\n  receivePort.listen((message) {\n    print('Received: $message');\n  });\n}\n\nvoid sendReceive(ReceivePort receivePort) {\n  SendPort sendPort = await receivePort.first;\n  sendPort.send('Hello from main!');\n}\n```\n\n## 비동기 프로그래밍:\n\nDart는 future와 async/await 구문을 통해 비동기 프로그래밍을 지원합니다. Future는 미래의 어느 시점에 사용 가능한 잠재적인 값 또는 오류를 나타냅니다. Async/await는 비동기 코드를 순차적이고 동기적인 스타일로 작성할 수 있는 구문을 제공합니다.\n\n예시:\n\n<div class=\"content-ad\"></div>\n\n```dart\nimport 'dart:async';\n\nvoid main() async {\n  try {\n    String result = await fetchUser();\n    print(result); // Output: User data\n  } catch (e) {\n    print('Error: $e');\n  }\n}\n\nFuture<String> fetchUser() async {\n  await Future.delayed(Duration(seconds: 2));\n  return 'User data';\n}\n```\n\n이러한 고급 Dart 개념을 숙지하면 개발자들은 더 효율적이고 확장 가능한 Flutter 애플리케이션을 구축할 수 있습니다.\n\n— — —\n\n# 5. 당신이 개발한 실제 Flutter 앱이나 구현한 복잡한 기능을 소개해주세요.\n\n\n<div class=\"content-ad\"></div>\n\n한 번 제가 구축한 실제 Flutter 앱은 \"TaskMaster\"라는 생산성 도구입니다. TaskMaster는 사용자가 업무를 조직화하고 알림을 설정하며 진행 상황을 추적하는 데 도움이 되는 업무 관리 앱입니다.\n\nTaskMaster에 구현한 복잡한 기능 중 하나는 사용자 정의 캘린더 뷰입니다. 캘린더 뷰를 통해 사용자는 월별, 주간 또는 일별 레이아웃에서 업무와 이벤트를 시각화할 수 있습니다. 이 기능은 캘린더에서 직접 업무를 추가/편집하거나 중요도에 따라 색상을 지정하는 기능을 지원하며 Google 캘린더와 같은 외부 캘린더와 동기화할 수 있습니다.\n\n구현에는 각기 다른 캘린더 뷰(월, 주, 일)를 위한 사용자 정의 위젯 생성, 사용자 상호작용(스와이프, 탭) 처리, 플랫폼별 캘린더 API와의 통합이 포함되었습니다.\n\n다음은 사용자 정의 캘린더 뷰의 간소화된 구현 방법입니다:\n\n<div class=\"content-ad\"></div>\n\n```dart\n// 사용자 정의 캘린더 위젯\nclass CalendarView extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      // 캘린더 구현 부분\n    );\n  }\n}\n\n// 주 앱 위젯\nclass TaskMasterApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text('TaskMaster'),\n        ),\n        body: CalendarView(), // 캘린더 뷰 표시\n      ),\n    );\n  }\n}\n\nvoid main() {\n  runApp(TaskMasterApp());\n}\n```\n\n이 예는 단순화된 예시일 뿐이며, 실제 구현에는 더 복잡한 논리가 필요할 것입니다. 작업/이벤트 렌더링, 날짜/시간 계산 처리, 백엔드 서비스 통합 등이 포함될 것입니다.\n\n--- ---\n\n# 6. Google Material Design 원칙에 대한 지식 및 Flutter 프로젝트에서 적용하는 방법에 대해 이야기해보세요.\n\n\n<div class=\"content-ad\"></div>\n\n구글 마테리얼 디자인은 구글이 개발한 디자인 언어로, 물성 현실주의, 대담한 그래픽, 의미 있는 모션 등을 강조합니다. 플러터 프로젝트에서는 마테리얼 디자인 원칙을 적용하여 직관적이고 시각적으로 매력적인 사용자 인터페이스를 만들어냅니다.\n\n마테리얼 디자인의 주요 측면과 해당하는 내용은 다음과 같습니다:\n\n### 마테리얼 구성 요소:\n\nAppBar, BottomNavigationBar, Card, FloatingActionButton 등과 같은 내장 플러터 위젯을 활용하여 마테리얼 디자인 가이드라인에 따라 디자인됩니다.\n\n<div class=\"content-ad\"></div>\n\n## 타이포그래피:\n\n저는 텍스트 요소에 적절한 글꼴 스타일, 크기 및 두께를 사용하여 타이포그래피에 주의를 기울입니다. 더 나은 가독성을 위해 적절한 간격과 정렬을 보장합니다.\n\n## 색상:\n\n저는 다양한 UI 요소에 색상을 선택하기 위해 Material 색상 팔레트를 사용하여 일관성과 접근성을 보장합니다. 또한 UI에서 깊이와 계층 구조를 만들기 위해 총돌과 그림자를 적용합니다.\n\n<div class=\"content-ad\"></div>\n\n## 동작:\n\n안녕하세요! Flutter의 애니메이션과 트랜지션을 활용하여 섬세한 동작 효과를 추가해 사용자 경험을 향상시키고 피드백을 제공합니다. 페이지 전환, 버튼 클릭 및 입력 유효성 검사를 위한 애니메이션을 포함합니다.\n\n## 레이아웃:\n\n안녕하세요! 저는 Material Design의 레이아웃 원칙을 따라 그리드, 카드 및 반응형 디자인을 활용하여 시각적으로 조화롭고 일관된 레이아웃을 다양한 화면 크기와 방향에 걸쳐 구축합니다.\n\n<div class=\"content-ad\"></div>\n\nMaterial Design 원칙을 준수하여, Flutter 앱이 통일된 느낌과 사용자들이 익숙하고 쉽게 탐색할 수 있는 완성도 높은 외관을 갖도록 합니다.\n\n--- \n\n# 7. 디버깅 도구와 기술을 사용하여 Flutter 앱에서 복잡한 문제를 효과적으로 해결하는 방법을 설명하세요.\n\nFlutter 앱에서 복잡한 문제를 해결하기 위해서는 디버깅 도구와 기술의 조합이 필요합니다. 다음은 저의 디버깅 접근 방식입니다:\n\n<div class=\"content-ad\"></div>\n\n## 로깅:\n\n코드 전반에 print 문을 전략적으로 사용하여 중요한 변수, 상태 및 메서드 호출을 로깅합니다. 이를 통해 실행 흐름을 이해하고 잠재적인 문제를 식별하는 데 도움이 됩니다.\n\n## 디버깅 도구:\n\nFlutter는 강력한 디버깅 도구인 Flutter DevTools를 제공합니다. 이 도구를 사용하면 위젯 트리를 검사하고 로그를 보고 성능을 프로파일링하며 네트워크 요청을 디버깅할 수 있습니다. 또한 Android Studio/VS Code의 Flutter Inspector를 사용하여 UI 요소와 속성을 분석합니다.\n\n<div class=\"content-ad\"></div>\n\n## 중단점:\n\n문제가 발생할 수 있는 중요한 지점에 중단점을 설정합니다. 이를 통해 앱의 실행을 일시 중지하고 변수 값, 스택 추적, 코드를 한 줄씩 실행해볼 수 있습니다.\n\n## 핫 리로드/리스타트:\n\n플러터의 핫 리로드/리스타트 기능을 활용하여 변경 사항을 빠르게 반복하고 실시간으로 그 효과를 확인합니다. 이를 통해 다양한 시나리오를 테스트하고 문제의 원인을 좁혀낼 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 문제 고립하기:\n\n문제를 체계적으로 분리하기 위해 의심되는 코드를 일시적으로 제거하거나 주석 처리합니다. 이렇게 하면 문제의 범위를 좁히고 원인을 식별하는 데 도움이 됩니다.\n\n## 문서 읽기:\n\n오류나 예기치 않은 동작을 만나면 공식 Flutter 문서, API 참조, 커뮤니티 포럼을 참고하여 통찰과 해결책을 찾습니다. 다양한 위젯과 API가 어떻게 작동하는지 이해하면 문제 해결에 도움이 될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 디버깅 도구와 기술을 체계적으로 활용하여, Flutter 앱에서 복잡한 문제를 효과적으로 식별하고 해결할 수 있어요.\n\n---\n\n## 8. 플랫폼별 기능(예: 카메라 액세스, 알림)을 Flutter 앱에서 어떻게 처리하시겠습니까?\n\nFlutter 앱에서 플랫폼별 기능을 처리하려면, 플랫폼 채널을 사용하여 네이티브 코드(안드로이드의 Java/Kotlin, iOS의 Objective-C/Swift)와 통신할 거예요. 이렇게 카메라 액세스와 알림을 구현할 거예요:\n\n<div class=\"content-ad\"></div>\n\n## 카메라 액세스:\n\n카메라 액세스를 위한 메소드 채널을 정의하세요:\n\n```js\nimport 'package:flutter/services.dart';\n\nconst platform = MethodChannel('example.com/camera');\n\nFuture<void> takePicture() async {\n  try {\n    await platform.invokeMethod('takePicture');\n  } on PlatformException catch (e) {\n    print(\"사진 찍기에 실패했습니다: '${e.message}'.\");\n  }\n}\n```\n\n각 플랫폼에 대한 네이티브 코드를 구현하여 카메라 액세스를 처리하세요.\n\n<div class=\"content-ad\"></div>\n\n## Android (Java/Kotlin):\n\n```js\nimport android.content.Context;\nimport android.content.Intent;\nimport android.provider.MediaStore;\nimport io.flutter.plugin.common.MethodCall;\nimport io.flutter.plugin.common.MethodChannel;\nimport io.flutter.plugin.common.MethodChannel.MethodCallHandler;\nimport io.flutter.plugin.common.MethodChannel.Result;\nimport io.flutter.plugin.common.PluginRegistry.Registrar;\n\npublic class CameraPlugin implements MethodCallHandler {\n  private final Context context;\n\n  private CameraPlugin(Context context) {\n    this.context = context;\n  }\n\n  public static void registerWith(Registrar registrar) {\n    final MethodChannel channel = new MethodChannel(registrar.messenger(), \"example.com/camera\");\n    channel.setMethodCallHandler(new CameraPlugin(registrar.context()));\n  }\n\n  @Override\n  public void onMethodCall(MethodCall call, Result result) {\n    if (call.method.equals(\"takePicture\")) {\n      takePicture();\n    } else {\n      result.notImplemented();\n    }\n  }\n\n  private void takePicture() {\n    Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);\n    context.startActivity(intent);\n  }\n}\n```\n\n## iOS (Objective-C/Swift):\n\n```js\nimport Flutter\nimport UIKit\n\npublic class SwiftCameraPlugin: NSObject, FlutterPlugin {\n  public static func register(with registrar: FlutterPluginRegistrar) {\n    let channel = FlutterMethodChannel(name: \"example.com/camera\", binaryMessenger: registrar.messenger())\n    let instance = SwiftCameraPlugin()\n    registrar.addMethodCallDelegate(instance, channel: channel)\n  }\n\n  public func handle(_ call: FlutterMethodCall, result: @escaping FlutterResult) {\n    if call.method == \"takePicture\" {\n      takePicture()\n    } else {\n      result(FlutterMethodNotImplemented)\n    }\n  }\n\n  private func takePicture() {\n    // Implement camera access for iOS\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## 알림:\n\n알림을 위한 메서드 채널을 정의하세요:\n\n```js\nimport 'package:flutter/services.dart';\n\nconst platform = MethodChannel('example.com/notifications');\n\nFuture<void> showNotification(String message) async {\n  try {\n    await platform.invokeMethod('showNotification', {'message': message});\n  } on PlatformException catch (e) {\n    print(\"Failed to show notification: '${e.message}'.\");\n  }\n}\n```\n\n각 플랫폼에 대한 기본 코드를 구현하세요.\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 마크다운 형식으로 변경해 보세요.\n\n<div class=\"content-ad\"></div>\n\nFlutter 앱의 성능 최적화는 부드럽고 반응성 있는 사용자 경험을 제공하는 데 필수적입니다. 성능 최적화를 위해 사용하는 여러 기술은 다음과 같습니다:\n\n## 캐싱:\n\n자주 액세스되는 데이터를 로컬에 저장하기 위해 캐싱을 사용하여 반복되는 네트워크 요청을 줄입니다. shared_preferences, hive 또는 sqflite와 같은 라이브러리를 사용하여 이미지, API 응답, 데이터베이스 쿼리 등을 캐싱할 수 있습니다.\n\n## 지연 로딩:\n\n<div class=\"content-ad\"></div>\n\n저는 모든 것을 한꺼번에 로드하는 대신 필요할 때만 데이터를 가져오는 레이지 로딩을 구현했습니다. 이를 통해 초기 앱 로드 시간이 개선되고 메모리 사용량이 줄어듭니다. 페이지별 목록, 무한 스크롤, 자산의 온 디맨드 로딩과 같은 기술들이 레이지 로딩에 대해 흔히 사용됩니다.\n\n## 효율적인 상태 관리:\n\nProvider, Riverpod 또는 GetX와 같은 효율적인 상태 관리 기술을 사용하여 불필요한 위젯 재구성을 최소화하고 성능을 최적화합니다. UI 상태와 비즈니스 로직을 분리하고 불변 데이터 구조를 사용하여 상태가 변경될 때 UI의 필요한 부분만 업데이트되도록 보장합니다.\n\n## 최적화된 UI 렌더링:\n\n<div class=\"content-ad\"></div>\n\nUI 렌더링을 최적화하기 위해 위젯 수를 최소화하고 위젯 중첩을 줄이며 가능한 경우 const 생성자를 사용하여 위젯 서브트리를 사전에 계산합니다. 이렇게 하면 위젯 빌드 단계에서 소요 시간을 줄이고 UI 반응성을 향상시킬 수 있습니다.\n\n### 네트워크 최적화:\n\nHTTP 캐싱, 압축, 프리패칭 기술 등을 사용하여 네트워크 요청을 최적화합니다. 이는 특히 네트워크 상황이 좋지 않은 시나리오에서 지연 시간과 대역폭 사용량을 최소화하는 데 도움이 됩니다.\n\n### 백그라운드 처리:\n\n<div class=\"content-ad\"></div>\n\n저는 CPU 집약적인 작업과 오랜 시간이 걸리는 작업을 백그라운드 아이솔레이트로 오프로드하여 주요 UI 스레드를 차단하지 않도록 합니다. 이를 통해 앱이 무거운 계산 또는 I/O 작업 중에도 반응성을 유지할 수 있습니다.\n\n이러한 최적화 기술을 개발 프로세스에 통합함으로써, Flutter 앱이 다양한 기기와 사용 시나리오에서 탁월한 성능을 제공하도록 보장합니다.\n\n--- --- ---\n\n# 10. 선택한 접근 방식(예: BLoC)을 사용하여 복잡한 앱 상태 관리를 어떻게 구현할 것인가요?\n\n<div class=\"content-ad\"></div>\n\n제가 플러터에서 복잡한 앱 상태 관리에 자주 사용하는 한 가지 방법은 BLoC (Business Logic Component) 패턴입니다. BLoC는 프레젠테이션 레이어를 비즈니스 로직 및 상태 관리로부터 분리하여 유지 및 테스트를 쉽게 만드는 장점이 있습니다.\n\n아래는 BLoC 패턴을 사용한 복잡한 앱 상태 관리를 구현하는 방법입니다:\n\n## BLoC 정의:\n\n```js\nimport 'dart:async';\nimport 'package:flutter/material.dart';\n\nenum CounterEvent { increment, decrement }\n\nclass CounterBloc {\n  int _counter = 0;\n  final _controller = StreamController<int>();\n\n  Stream<int> get counterStream => _controller.stream;\n\n  void mapEventToState(CounterEvent event) {\n    if (event == CounterEvent.increment) {\n      _counter++;\n    } else {\n      _counter--;\n    }\n    _controller.sink.add(_counter);\n  }\n\n  void dispose() {\n    _controller.close();\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## BLoC 제공하기:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'counter_bloc.dart';\n\nclass BlocProvider extends InheritedWidget {\n  final CounterBloc bloc;\n\n  BlocProvider({Key key, @required Widget child})\n      : bloc = CounterBloc(),\n        super(key: key, child: child);\n\n  @override\n  bool updateShouldNotify(_) => true;\n\n  static CounterBloc of(BuildContext context) {\n    return (context.dependOnInheritedWidgetOfExactType<BlocProvider>()).bloc;\n  }\n}\n```\n\n## 위젯에서 BLoC 사용하기:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'bloc_provider.dart';\nimport 'counter_bloc.dart';\n\nclass CounterWidget extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    final CounterBloc bloc = BlocProvider.of(context);\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('BLoC Pattern Example'),\n      ),\n      body: StreamBuilder<int>(\n        stream: bloc.counterStream,\n        initialData: 0,\n        builder: (BuildContext context, AsyncSnapshot<int> snapshot) {\n          return Center(\n            child: Text('Counter: ${snapshot.data}'),\n          );\n        },\n      ),\n      floatingActionButton: Column(\n        mainAxisAlignment: MainAxisAlignment.end,\n        children: <Widget>[\n          FloatingActionButton(\n            onPressed: () => bloc.mapEventToState(CounterEvent.increment),\n            child: Icon(Icons.add),\n          ),\n          SizedBox(height: 10),\n          FloatingActionButton(\n            onPressed: () => bloc.mapEventToState(CounterEvent.decrement),\n            child: Icon(Icons.remove),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## BLoC 해제하기:\n\n```js\nimport 'package:flutter/material.dart';\nimport 'bloc_provider.dart';\nimport 'counter_widget.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return BlocProvider(\n      child: MaterialApp(\n        home: CounterWidget(),\n      ),\n    );\n  }\n}\n\nclass BlocProvider extends InheritedWidget {\n  final CounterBloc bloc;\n\n  BlocProvider({Key key, @required Widget child})\n      : bloc = CounterBloc(),\n        super(key: key, child: child);\n\n  @override\n  bool updateShouldNotify(_) => true;\n\n  static CounterBloc of(BuildContext context) {\n    return (context.dependOnInheritedWidgetOfExactType<BlocProvider>()).bloc;\n  }\n\n  @override\n  void dispose() {\n    bloc.dispose();\n    super.dispose();\n  }\n}\n```\n\n이 예시에서 CounterBloc은 카운터의 상태를 관리하고 카운터 값의 스트림을 노출합니다. BlocProvider 위젯은 InheritedWidget 메커니즘을 사용하여 CounterBloc을 해당 하위 위젯에 제공합니다. 그러면 위젯은 BlocProvider.of(context) 메서드를 사용하여 CounterBloc에 액세스할 수 있습니다.\n\nBLoC 패턴을 따르면 복잡한 앱 상태를 효과적으로 관리할 수 있고 UI 레이어를 깔끔하고 유지보수 가능하게 유지할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n--- --- ---\n\n더 많은 내용을 보려면 Ahsi Dev를 팔로우하세요...\n\nLinkedIn: [https://www.linkedin.com/in/ahsan-saeed-11a787183/](https://www.linkedin.com/in/ahsan-saeed-11a787183/)\n\n![이미지](/assets/img/2024-06-21-FlutterAdvancedInterviewQuestionsADetailedGuidewithCodingExamples_1.png)","ogImage":{"url":"/assets/img/2024-06-21-FlutterAdvancedInterviewQuestionsADetailedGuidewithCodingExamples_0.png"},"coverImage":"/assets/img/2024-06-21-FlutterAdvancedInterviewQuestionsADetailedGuidewithCodingExamples_0.png","tag":["Tech"],"readingTime":21},{"title":"CameraX를 사용하여 완벽한 카메라 경험을 구현하는 방법 Flutter","description":"","date":"2024-06-21 21:21","slug":"2024-06-21-Picture-PerfectCameraExperiencesinFlutterwithCameraX","content":"\n\n\n![Perfect Camera Experiences in Flutter with CameraX](/assets/img/2024-06-21-Picture-PerfectCameraExperiencesinFlutterwithCameraX_0.png)\n\nFlutter가 최신 업데이트에서 멋진 기능 추가를 내놓았는데, 이 CameraX 플러그인은 정말 멋진 것 중 하나여야 합니다. Dart와 Flutter를 사용한 모바일 앱 개발 환경은 개발자들이 다목적, 효율적, 견고한 프레임워크를 찾는 데 있어 밝은 등대의 역할을 계속하고 있습니다. Google I/O 2024에서 공개된 최신 업데이트인 Flutter 3.22와 Dart 3.4는 성능 향상, 통합 기능 개선, 개발자를 위한 새로운 도구 등을 포함한 흥미로운 기능 향상을 제공했습니다. 그 중 하나로 사용자에게 카메라 기능을 간단하게 하고 향상시키기 위해 설계된 Jetpack 라이브러리인 CameraX의 통합이 돋보입니다. 이 기사에서는 Flutter와 함께 CameraX를 활용하여 애플리케이션에서 원활하고 신뢰할 수 있는 카메라 경험을 만드는 방법을 살펴보겠습니다.\n\n# CameraX 이해하기\n\nCameraX는 Camera2를 기반으로 구축되어 안드로이드에서 카메라 개발과 관련된 복잡성 중 많은 부분을 추상화하는 더 높은 수준의 API를 제공합니다. CameraX는 다양한 디바이스에서 일관된 신뢰할 수 있는 카메라 동작을 제공하도록 목표로 하며, 디바이스별 특이점을 처리하고 자동 해상도 선택 기능을 제공하여 카메라 기능 개발에 필요한 노력을 크게 줄입니다.\n\n\n<div class=\"content-ad\"></div>\n\n# CameraX를 선택하는 이유\n\nCameraX는 다음과 같은 이유로 카메라 개발을 간단하게 만들어줍니다:\n\n- 자동 장치 문제 처리: 장치별 특이 사항을 자동으로 처리하여 서로 다른 장치에서 일관된 성능을 보장합니다.\n- 해상도 선택: 장치의 기능에 따라 최적의 해상도를 선택하여 최상의 화질을 유지합니다.\n- 사용 편의성: 카메라 개발 과정을 간단하게 만들어주어 개발자가 낮은 수준의 카메라 제어에 대해 걱정하지 않고 핵심 기능에 집중할 수 있도록 합니다.\n\n# Flutter에서 CameraX 시작하기\n\n<div class=\"content-ad\"></div>\n\n친구야, Flutter 애플리케이션에서 CameraX를 활용하는 방법을 알아보려면 카메라 플러그인을 업그레이드하거나 추가해야 해. 최신 버전의 카메라 플러그인은 기본적으로 CameraX를 사용해.\n\n## 1: 카메라 플러그인 추가하기\n\nFlutter 프로젝트에 아직 카메라 플러그인을 추가하지 않았다면 다음 명령어를 통해 추가할 수 있어:\n\n```js\nflutter pub add camera\n```\n\n<div class=\"content-ad\"></div>\n\n업그레이드하는 경우, 다음을 실행하세요:\n\n```js\nflutter pub upgrade major versions camera\n```\n\n## 2: 기본 카메라 설정\n\n카메라X 플러그인을 사용하여 사진 촬영을 시작하는 기본 예제입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport 'package:flutter/material.dart';\nimport 'package:camera/camera';\n\n\nvoid main() => runApp(MyApp());\n\nclass MyApp extends StatefulWidget {\n  @override\n  _MyAppState createState() => _MyAppState();\n}\nclass _MyAppState extends State<MyApp> {\n  CameraController? controller;\n  List<CameraDescription>? cameras;\n  @override\n  void initState() {\n    super.initState();\n    availableCameras().then((availableCameras) {\n      cameras = availableCameras;\n      if (cameras != null && cameras!.isNotEmpty) {\n        controller = CameraController(cameras![0], ResolutionPreset.high);\n        controller?.initialize().then((_) {\n          if (!mounted) {\n            return;\n          }\n          setState(() {});\n        });\n      }\n    });\n  }\n  @override\n  void dispose() {\n    controller?.dispose();\n    super.dispose();\n  }\n  @override\n  Widget build(BuildContext context) {\n    if (controller == null || !controller!.value.isInitialized) {\n      return Container();\n    }\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: Text('CameraX Example')),\n        body: CameraPreview(controller!),\n        floatingActionButton: FloatingActionButton(\n          onPressed: () async {\n            try {\n              await controller?.takePicture();\n            } catch (e) {\n              print(e);\n            }\n          },\n          child: Icon(Icons.camera),\n        ),\n      ),\n    );\n  }\n}\n```\n\n## 고급 기능 및 사용자 정의\n\n### 자동 해상도 선택\n\nCameraX의 자동 해상도 선택 기능을 통해 기기의 성능을 기반으로 가장 적합한 해상도가 선택됩니다. 특히 스캔이나 이미지 분석과 같은 작업에 고해상도 이미지가 필요한 애플리케이션에 유용합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\r\ncontroller = CameraController(\n  cameras![0],\n  ResolutionPreset.ultraHigh,\n  imageFormatGroup: ImageFormatGroup.jpeg,\n);\r\n```\n\n카메라X를 사용하면 원하는 해상도를 사용할 수 없는 경우를 처리하기 위한 해상도 전략을 정의할 수 있습니다:\n\n```js\r\nimport 'package:camera/camera.dart';\n\nvoid configureResolution(CameraController controller) {\n  final ResolutionSelector resolutionSelector = ResolutionSelector(\n    boundSize: Size(3840, 2160),\n    fallbackRule: FallbackRule(\n      closer: true,\n      lowerThenHigher: true,\n    ),\n  );\n  controller.setResolutionSelector(resolutionSelector);\n}\r\n```\n\n## 디바이스 특이사항 처리하기\n\n<div class=\"content-ad\"></div>\n\nCameraX는 Android 기기 간에 부드럽고 일관된 경험을 제공하기 위해 장치별 특이사항을 관리합니다. 이는 잘못된 플래시 동작이나 부적절한 캡처 세션 종료와 같은 문제를 처리하는 것을 포함합니다.\n\n```js\ncontroller.addListener(() {\n  if (controller.value.hasError) {\n    print('카메라 오류: ${controller.value.errorDescription}');\n  }\n});\n```\n\nFlutter 어플리케이션에서 CameraX를 활용하여 더 스마트하고 믿을 수 있는 카메라 경험을 만들 수 있습니다. 고품질 사진 촬영, 문서 스캔 또는 이미지 분석을 위해 CameraX는 일관되고 고품질의 사용자 경험을 제공하는 데 필요한 도구를 제공합니다.\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\nCameraX 통합으로 인해 Flutter 개발자들은 이제 더 효율적으로 완벽한 카메라 경험을 만들 수 있습니다. CameraX가 제공하는 자동 해상도 선택 및 장치 특이성 처리로 개발 프로세스가 간소화되어, 개발자들은 혁신적인 기능을 구축하는 데 집중할 수 있습니다. 나는 확실히 내가 작업할 응용 프로그램에 이 플러그인을 추가할 것입니다. 그래서 더 기다릴 이유가 뭐 있나요? 오늘 카메라 플러그인을 업그레이드하고 Flutter와 CameraX로 다음 세대의 카메라 앱을 만들기 시작하세요.\n\n더 자세한 정보 및 Flutter의 최신 개발 내용을 확인하려면, Google I/O 2024의 내 Flutter 3.22 및 Dart 3.4 기사를 참조하세요.","ogImage":{"url":"/assets/img/2024-06-21-Picture-PerfectCameraExperiencesinFlutterwithCameraX_0.png"},"coverImage":"/assets/img/2024-06-21-Picture-PerfectCameraExperiencesinFlutterwithCameraX_0.png","tag":["Tech"],"readingTime":5},{"title":"Flutter 프로젝트 05 광학 문자 인식OCR 앱 만들기","description":"","date":"2024-06-21 21:19","slug":"2024-06-21-FlutterProjects05BuildinganOpticalCharacterRecognitionOCRApp","content":"\n\n<img src=\"/assets/img/2024-06-21-FlutterProjects05BuildinganOpticalCharacterRecognitionOCRApp_0.png\" />\n\n이 튜토리얼에서는 Flutter를 사용하여 광학 문자 인식 (OCR) 애플리케이션을 만드는 단계를 안내합니다. google_mlkit_text_recognition 패키지를 사용하여 이미지에서 텍스트를 추출할 것입니다. 이 안내서는 초보자에게 이상적이며 코드의 각 부분을 자세히 설명할 것입니다.\n\n이 글은 플러터로 첫 번째 애플리케이션을 만드는 초보 개발자들을 돕기 위해 다양한 프로젝트를 만드는 일련의 기사 중 일부입니다. 따라서 UI 조립, 프로그래밍 로직, 그리고 좋은 프로그래밍 관행을 연습할 수 있습니다. 이전 기사를 놓친 경우 이를 확인할 수 있습니다.\n\n- 초보자를 위한 플러터 프로젝트 #01: BMI 계산기 구축\n- 초보자를 위한 플러터 프로젝트 #02: 할 일 목록 구축\n- 초보자를 위한 플러터 프로젝트 #03: 다크 모드 및 라이트 모드 전환\n- 초보자를 위한 플러터 프로젝트 #04: 채팅 GPT 앱 구축\n\n<div class=\"content-ad\"></div>\n\n![image](https://miro.medium.com/v2/resize:fit:960/1*MHgy2Jl-x4X3NG0UYAL9qQ.gif)\n\n# 플러터 프로젝트 시작하기\n\n먼저 할 일은 플러터 프로젝트를 설정하는 것입니다. 이미 플러터가 설치되어 있는지 확인하세요. 그렇지 않다면, https://flutter.dev/docs/get-started/install 에서 설치 지침을 따를 수 있습니다.\n\n다음으로, 터미널에서 다음 명령을 사용하여 새 플러터 프로젝트를 생성하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nflutter create flutter_ocr\n```\n\n프로젝트 디렉토리로 이동하고 다음 명령어로 VSCode에서 프로젝트를 엽니다:\n\n```js\ncd flutter_ocr && code .\n```\n\n# 초기 설정\n\n\n<div class=\"content-ad\"></div>\n\n자, 이제 실제 코드 작성을 시작해봅시다. 먼저 main.dart 파일에서 몇 가지 작은 변경사항을 시작해보겠습니다.\n\n자동으로 생성된 주석을 삭제하고 MyHomePage 클래스도 제거해주세요(우리만의 사용자 정의 위젯을 만들 예정이에요). 그리고 MyApp 위젯의 내용을 잘라서 my_app.dart 라는 파일에 추가해주세요. 그런 다음, 이 새 파일을 main.dart에서 내보내세요.\n\n당신의 main.dart 파일은 다음과 같은 모습이어야 합니다:\n\n```js\nimport 'package:flutter/material.dart';\nimport 'package:flutter_ocr/src/my_app.dart';\n\nvoid main() => runApp(const MyApp());\n```\n\n<div class=\"content-ad\"></div>\n\n그리고 당신의 my_app.dart 파일은 다음과 같이 보여야 합니다:\n\n```js\nimport 'package:flutter/material.dart';\nimport 'package:flutter_ocr/src/pages/home_page.dart';\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Flutter OCR',\n      debugShowCheckedModeBanner: false,\n      theme: ThemeData(\n        colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple),\n        useMaterial3: true,\n      ),\n      home: const HomePage(),\n    );\n  }\n}\n```\n\n# HomePage Widget 생성하기\n\n프로젝트를 더 잘 구성하기 위해, 'lib' 폴더 안에 'pages'라는 폴더를 생성한 다음 그 안에 'home_page.dart'라는 새 파일을 만드세요.\n\n<div class=\"content-ad\"></div>\n\n이 새 파일 안에 build 메서드에서 Scaffold를 가지는 새 StatefulWidget을 생성해 보세요. 예시 코드는 다음과 같을 것입니다:\n\n```js\nimport 'package:flutter/material.dart';\n\nclass HomePage extends StatefulWidget {\n  const HomePage({super.key});\n\n  @override\n  State<HomePage> createState() => _HomePageState();\n}\n\nclass _HomePageState extends State<HomePage> {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Flutter OCR')),\n      body: const Column(\n        children: [],\n      ),\n    );\n  }\n}\n```\n\n# 패키지의 설치 및 구성\n\nOCR 앱을 시작하기 위해 Flutter 프로젝트에 필요한 종속 항목을 추가하는 단계를 따라보세요.\n\n<div class=\"content-ad\"></div>\n\n이 프로젝트에서는 세 가지 패키지를 사용할 거에요:\n\n- image_picker: 갤러리나 카메라에서 이미지를 선택하는 데 사용돼요.\n- image_cropper: 선택한 이미지를 자르는 데 사용돼요.\n- google_mlkit_text_recognition: 이미지에서 텍스트 인식을 수행하는 데 사용돼요.\n\n## 종속성 추가하기\n\npubspec.yaml 파일을 열고 다음 종속성을 추가해주세요:\n\n<div class=\"content-ad\"></div>\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n\n  cupertino_icons: ^1.0.6 \n  image_picker: ^1.1.2\n  image_cropper: ^7.0.5\n  google_mlkit_text_recognition: ^0.13.0\n```\n\n의존성을 추가한 후 아래 명령을 실행하여 설치하십시오:\n\n```bash\nflutter pub get\n```\n\nAndroid에서 image_cropper 패키지가 올바르게 작동하려면 추가 구성이 필요합니다. AndroidManifest.xml 파일을 열어 `manifest` 태그 안에 다음 코드를 추가하십시오:\n\n\n<div class=\"content-ad\"></div>\n\n```js\n<activity\n    android:name=\"com.yalantis.ucrop.UCropActivity\"\n    android:screenOrientation=\"portrait\"\n    android:theme=\"@style/Theme.AppCompat.Light.NoActionBar\"/>\n```\n\n이제 여러분의 프로젝트에서 필요한 모든 패키지를 사용할 수 있는 준비가 되었습니다.\n\n# 홈페이지 UI 만들기\n\n먼저, widgets라는 새 폴더를 만들고 이 폴더 안에 picker_option_widget.dart라는 파일을 생성하십시오. 이러면 다음과 같이 보일 것입니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport 'package:flutter/material.dart';\n\nclass PickerOptionWidget extends StatelessWidget {\n  const PickerOptionWidget({\n    super.key,\n    required this.color,\n    required this.label,\n    required this.icon,\n    this.onTap,\n  });\n\n  final Color color;\n\n  final String label;\n\n  final IconData icon;\n\n  final void Function()? onTap;\n\n  @override\n  Widget build(BuildContext context) {\n    return Expanded(\n      child: InkWell(\n        onTap: onTap,\n        child: Container(\n          padding: const EdgeInsets.all(20.0),\n          decoration: BoxDecoration(\n            color: color.withOpacity(0.3),\n            borderRadius: BorderRadius.circular(10),\n          ),\n          child: Column(\n            crossAxisAlignment: CrossAxisAlignment.center,\n            children: [\n              Icon(\n                icon,\n                size: 38.0,\n                color: color,\n              ),\n              const SizedBox(height: 10.0),\n              Text(\n                label,\n                style: const TextStyle(\n                  fontSize: 20.0,\n                ),\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n```\n\n이 위젯을 사용하여 코드를 더 정리하고 반복을 피할 거예요. 이 버튼은 기기 갤러리나 카메라를 열기 위해 사용될 거에요.\n\n## 그러면 이제 HomePage의 구조를 설정할 수 있어요.\n\nHomePage에서 String 타입의 _extractedText라는 변수를 만들어주세요. 이 변수는 이미지로부터 추출된 텍스트를 저장할 거에요.\n\n<div class=\"content-ad\"></div>\n\n```js\n/// 이미지에서 추출된 텍스트를 저장할 변수\nString _extractedText = '';\n```\n\n이제 이전에 만든 위젯을 사용하여 Scaffold를 구성할 수 있습니다. 다음과 같이 보여야 합니다:\n\n```js\n@override\nWidget build(BuildContext context) {\n  return Scaffold(\n    appBar: AppBar(title: const Text('Flutter OCR')),\n    body: Column(\n      children: [\n        const Text(\n          '옵션을 선택하세요',\n          style: TextStyle(fontSize: 22.0),\n        ),\n        const SizedBox(height: 10.0),\n        Padding(\n          padding: const EdgeInsets.symmetric(\n            vertical: 10.0,\n            horizontal: 20.0,\n          ),\n          child: Row(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: [\n              PickerOptionWidget(\n                label: '갤러리에서',\n                color: Colors.blueAccent,\n                icon: Icons.image_outlined,\n                onTap: () {\n                  /// 갤러리에서 이미지 가져오는 코드\n                },\n              ),\n              const SizedBox(width: 10.0),\n              PickerOptionWidget(\n                label: '카메라에서',\n                color: Colors.redAccent,\n                icon: Icons.camera_alt_outlined,\n                onTap: () {\n                  /// 카메라에서 이미지 가져오는 코드\n                },\n              ),\n            ],\n          ),\n        ),\n        if (_extractedText.isNotEmpty) ...{\n          Padding(\n            padding: const EdgeInsets.symmetric(\n              vertical: 15.0,\n              horizontal: 10.0,\n            ),\n            child: Row(\n              mainAxisAlignment: MainAxisAlignment.spaceBetween,\n              children: [\n                const Text(\n                  '이전에 읽은 내용',\n                  style: TextStyle(fontSize: 22.0),\n                ),\n                IconButton(\n                  onPressed: () {\n                    /// 텍스트를 클립 보드에 복사하는 코드\n                  },\n                  icon: const Icon(Icons.copy),\n                )\n              ],\n            ),\n          ),\n          Expanded(\n            child: Container(\n              padding: const EdgeInsets.symmetric(horizontal: 15.0),\n              width: double.infinity,\n              decoration: BoxDecoration(\n                color: Colors.grey.shade100,\n              ),\n              child: SingleChildScrollView(\n                child: Padding(\n                  padding: const EdgeInsets.only(\n                    top: 10.0,\n                    bottom: 20.0,\n                  ),\n                  child: Text(_extractedText),\n                ),\n              ),\n            ),\n          )\n        },\n      ],\n    ),\n  );\n}\n```\n\n## 이 코드에 대한 몇 가지 설명:\n\n\n<div class=\"content-ad\"></div>\n\n- 사용자 정의 위젯 PickerOptionWidget은 두 번 사용되며 각각 버튼과 같은 UI 요소를 나타냅니다. 갤러리에서 이미지를 선택하는 경우(갤러리에서)와 카메라로 이미지를 촬영하는 경우(카메라에서).\r\n- 두 위젯은 서로 다른 스타일(색상 및 아이콘)을 가지며 사용자 상호 작용을 처리하는 onTap 콜백이 정의되어 있습니다(구현 예정).\r\n- _extractedText가 비어 있지 않은지 확인합니다(_extractedText.isNotEmpty). 만약 true이면 다음과 같이 렌더링됩니다:\r\n- \"이전에 읽은 내용\"이라는 텍스트와 복사 아이콘(Icons.copy)을 가진 IconButton이 있는 행(Row). 클립보드로 텍스트를 복사하는 onPressed 콜백이 정의되어 있습니다(구현 예정).\r\n- 스타일이 적용된 Container를 포함하는 Expanded 위젯.\r\n- 컨테이너 안에는 _extractedText를 표시하는 Text 위젯이 포함된 SingleChildScrollView가 있습니다.\n\n이제 우리는 기본 구조를 만들었고 다음에 생성할 메소드를 받아들일 준비가 되었습니다.\n\n# 필요한 메소드 생성\n\n이제 이미지 선택, 선택한 이미지 자르기 및 텍스트 추출을 담당할 함수를 만들어 봅시다.\n\n<div class=\"content-ad\"></div>\n\n각 부분을 각각의 메소드로 분리하여 조직화하고 이해하기 쉽도록 유지할 것입니다.\n\n먼저 사용할 패키지를 가져오겠습니다:\n\n```js\nimport 'dart:io';\n...\nimport 'package:image_picker/image_picker.dart';\nimport 'package:image_cropper/image_cropper.dart';\nimport 'package:google_mlkit_text_recognition/google_mlkit_text_recognition.dart';\n```\n\n## 이미지 선택기\n\n<div class=\"content-ad\"></div>\n\n먼저, 장치에서 이미지를 선택할 수 있도록 하는 메소드를 만들어봅시다.\n\n```js\nFuture<File?> _pickerImage({required ImageSource source}) async {\n  final ImagePicker picker = ImagePicker();\n  final XFile? image = await picker.pickImage(source: source);\n  if (image != null) {\n    return File(image.path);\n  }\n  return null;\n}\n```\n\n설명:\n\n- final ImagePicker picker = ImagePicker();: ImagePicker 클래스의 인스턴스를 생성하여 장치의 이미지 선택기 기능에 액세스합니다.\n- final XFile? image = await picker.pickImage(source: source);: 이 줄은 ImagePicker 인스턴스의 pickImage 메소드를 사용하여 장치의 이미지 선택기 인터페이스를 엽니다. 사용자가 이미지를 선택할 때까지 기다립니다. source 매개변수는 갤러리 또는 카메라를 여는지를 지정합니다. 결과는 XFile? 유형의 변수 image에 저장됩니다.\n- if (image != null) ': 사용자가 실제로 이미지를 선택했는지 확인합니다. 이미지가 null이 아닌 경우 이미지가 선택된 것을 의미합니다.\n- return File(image.path);: 이미지가 선택된 경우, 이 줄은 이미지의 파일 경로를 사용하여 XFile을 File로 변환하고 반환합니다.\n\n<div class=\"content-ad\"></div>\n\n## 이미지 크롭\n\n이제 선택한 이미지를 자르는 기능을 만들어 보겠습니다. 특정 영역에서 텍스트만을 추출하고 싶은 큰 이미지가 있는 경우 매우 유용합니다.\n\n```js\nFuture<CroppedFile?> _cropImage({required File imageFile}) async {\n  CroppedFile? croppedfile = await ImageCropper().cropImage(\n    sourcePath: imageFile.path,\n    uiSettings: [\n      AndroidUiSettings(\n        aspectRatioPresets: [\n          CropAspectRatioPreset.square,\n          CropAspectRatioPreset.ratio3x2,\n          CropAspectRatioPreset.original,\n          CropAspectRatioPreset.ratio4x3,\n          CropAspectRatioPreset.ratio16x9\n        ],\n      ),\n      IOSUiSettings(\n        minimumAspectRatio: 1.0,\n      ),\n    ],\n  );\n\n  if (croppedfile != null) {\n    return croppedfile;\n  }\n\n  return null;\n}\n```\n\n- ImageCropper().cropImage(: ImageCropper의 인스턴스를 생성하고 즉시 cropImage 메서드를 호출합니다.\n- sourcePath: imageFile.path,: 자르려는 imageFile의 경로를 sourcePath 매개변수로 지정합니다.\n- AndroidUiSettings 및 IOSUiSettings: 각각 Android 및 iOS 플랫폼에서 자르기에 대한 UI 설정을 정의합니다.\n- aspectRatioPresets: Android에서 사용 가능한 자르기용 가로세로 비율을 지정합니다. 예시로는 square, 3:2, original, 4:3, 16:9 등이 있습니다.\n- minimumAspectRatio: iOS에서 자르기에 허용되는 최소 가로세로 비율을 정의합니다. 여기서는 1.0으로 설정했습니다.\n- await ImageCropper().cropImage(...): 제공된 설정을 기반으로 자르기 작업을 비동기적으로 시작하고 사용자가 자르기 작업을 수행할 때까지 대기합니다.\n- croppedfile이 null이 아닌 경우(즉, 사용자가 이미지를 성공적으로 자르는 경우), 해당 croppedfile을 반환합니다.\n\n<div class=\"content-ad\"></div>\n\n## Google의 ML Kit 텍스트 인식\n\n이제 이미지에서 텍스트 인식을 수행하는 책임을 가지는 메소드를 작성해봅시다.\n\n```js\nFuture<String> _recognizeTextFromImage({required String imgPath}) async {\n  final textRecognizer = TextRecognizer(script: TextRecognitionScript.latin);\n\n  final image = InputImage.fromFile(File(imgPath));\n  final recognized = await textRecognizer.processImage(image);\n\n  return recognized.text;\n}\n```\n\n- final textRecognizer = TextRecognizer(script: TextRecognitionScript.latin);: TextRecognitionScript.latin 스크립트를 사용하여 TextRecognizer 인스턴스를 생성합니다. TextRecognitionScript는 텍스트 인식에 사용할 언어 스크립트를 지정합니다.\n- final image = InputImage.fromFile(File(imgPath));: imgPath에서 지정된 파일에서 InputImage 객체를 생성합니다. File 클래스는 장치에서 파일에 액세스하고 조작하는 데 사용됩니다.\n- final recognized = await textRecognizer.processImage(image);: textRecognizer의 processImage 메소드를 호출하여 이미지에서 텍스트 인식 작업을 수행합니다. 이 작업은 비동기적으로 실행되므로 (await을 사용함) 텍스트 인식이 완료될 때까지 메소드가 기다릴 수 있습니다.\n- return recognized.text;: 이미지에서 추출된 인식된 텍스트를 반환합니다. recognized 객체에는 텍스트 인식 프로세스의 결과인 추출된 텍스트가 포함되어 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 클립 보드에 복사\n\n프로세스 결과를 클립 보드에 복사할 수 있는 메소드를 만들어 보겠습니다.\n\n```js\nvoid _copyToClipBoard() {\n  Clipboard.setData(ClipboardData(text: _extractedText));\n\n  ScaffoldMessenger.of(context).showSnackBar(\n    const SnackBar(\n      content: Text('클립 보드에 복사되었습니다'),\n    ),\n  );\n}\n```\n\n## 이미지 처리\n\n<div class=\"content-ad\"></div>\n\n모든 과정을 한 메서드로 결합하는 함수를 만들어 봅시다.\n\n```js\nFuture<void> _processImageExtractText({\n  required ImageSource imageSource,\n}) async {\n  final imageFile = await _pickerImage(source: imageSource);\n\n  if (imageFile == null) return;\n\n  final croppedImage = await _cropImage(\n    imageFile: imageFile,\n  );\n\n  if (croppedImage == null) return;\n\n  final recognizedText = await _recognizeTextFromImage(\n    imgPath: croppedImage.path,\n  );\n\n  setState(() => _extractedText = recognizedText);\n}\n```\n\n- `final imageFile = await _pickerImage(source: imageSource);`: `_pickerImage` 메서드를 호출하여 지정된 `imageSource`에서 이미지를 선택합니다. 선택 과정이 완료될 때까지 기다렸다가 결과를 `imageFile`에 할당합니다.\n- `final croppedImage = await _cropImage(imageFile: imageFile);`: 선택된 `imageFile`을 자르기 위해 `_cropImage` 메서드를 호출합니다. 자르기 과정이 완료될 때까지 기다렸다가 잘린 이미지(`CroppedFile`)를 `croppedImage`에 할당합니다.\n- `final recognizedText = await _recognizeTextFromImage(imgPath: croppedImage.path);`: 자른 이미지의 경로(`croppedImage.path`)에 대해 텍스트 인식을 수행하기 위해 `_recognizeTextFromImage` 메서드를 호출합니다. 인식 과정이 완료될 때까지 기다렸다가 인식된 텍스트(`String`)를 `recognizedText`에 할당합니다.\n- `setState(() => _extractedText = recognizedText);`: `_extractedText` 상태 변수를 `recognizedText`로 업데이트합니다. 이는 UI를 다시 빌드하여 추출된 텍스트를 표시하는 역할을 합니다.\n\n# 모든 것을 자리에 놓기\n\n<div class=\"content-ad\"></div>\n\n우리가 메소드를 생성하고 인터페이스를 설정해 놨으니, 이제 각 구현을 올바른 위치에 추가하기만 하면 됩니다.\n\n먼저, 사용자가 이미지를 선택할 옵션을 고르는 위젯에서 이미지를 처리하는 함수를 호출할 것입니다. 이미 필요한 모든 것이 구현된 함수이므로 onTap 이벤트에 이를 추가하고 소스를 지정해주기만 하면 됩니다.\n\n```js\n...\nchild: Row(\n  mainAxisAlignment: MainAxisAlignment.center,\n  children: [\n    PickerOptionWidget(\n      label: '갤러리에서 선택',\n      color: Colors.blueAccent,\n      icon: Icons.image_outlined,\n      onTap: () => _processImageExtractText(\n        imageSource: ImageSource.gallery,\n      ),\n    ),\n    const SizedBox(width: 10.0),\n    PickerOptionWidget(\n      label: '카메라로 촬영',\n      color: Colors.redAccent,\n      icon: Icons.camera_alt_outlined,\n      onTap: () => _processImageExtractText(\n        imageSource: ImageSource.camera,\n      ),\n    ),\n  ],\n),\n...\n```\n\n마지막으로, 결과를 클립보드 영역에 복사하는 함수를 추가하면 됩니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n...\nchild: Row(\n  mainAxisAlignment: MainAxisAlignment.spaceBetween,\n  children: [\n    const Text(\n      '이전에 읽은 항목',\n      style: TextStyle(fontSize: 22.0),\n    ),\n    IconButton(\n      onPressed: _copyToClipBoard,\n      icon: const Icon(Icons.copy),\n    )\n  ],\n),\n...\n```\n\n이제 모든 준비가 완료되었어요.\n\n# 최종 결과물\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1200/1*FY0xUZ88uI-MJlc-dkbdCw.gif\" />\n\n<div class=\"content-ad\"></div>\n\n이 튜토리얼에서는 이미지에서 광학 문자 인식(OCR)을 수행하는 Flutter 애플리케이션을 생성했습니다. Flutter 환경을 설정하고, 갤러리 또는 카메라에서 이미지를 선택할 수 있는 옵션을 포함한 사용자 인터페이스를 디자인했습니다. Google ML Kit을 사용하여 이미지 자르기와 텍스트 추출을 포함한 이미지 처리 방법을 구현했으며 추출된 텍스트를 클립보드에 복사하는 기능을 통합했습니다. 이 과정에서 중요한 Flutter 패키지를 통합하는 방법, 이미지 처리를 위한 비동기 작업 관리, 동적 UI 업데이트를 통해 사용자 상호작용을 향상하는 방법 등을 배웠습니다. 이 튜토리얼은 이미지 처리 및 OCR을 위해 Flutter의 기능을 최대한 활용하는 실용적인 통찰을 제공하여 개발자들이 자신의 애플리케이션에 비슷한 기능을 효과적으로 구현할 수 있는 기술을 갖추도록 도와줍니다.\n\n![Animation](https://miro.medium.com/v2/resize:fit:536/1*mVI3BmDdc3duwtvixvNU9A.gif)\n\n프로젝트의 완전한 소스 코드는 이 글의 맨 끝에서 찾을 수 있습니다.\n\n이 내용이 마음에 드셨다면, 박수를 보내주시고 제 포스트를 업데이트 받고 싶다면 팔로우해주세요! 👏👏👏\n\n<div class=\"content-ad\"></div>\n\n힘이 함께하기를 바랍니다. 🤓","ogImage":{"url":"/assets/img/2024-06-21-FlutterProjects05BuildinganOpticalCharacterRecognitionOCRApp_0.png"},"coverImage":"/assets/img/2024-06-21-FlutterProjects05BuildinganOpticalCharacterRecognitionOCRApp_0.png","tag":["Tech"],"readingTime":16}],"page":"7","totalPageCount":20,"totalPageGroupCount":1,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}