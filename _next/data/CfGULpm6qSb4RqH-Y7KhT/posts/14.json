{"pageProps":{"posts":[{"title":"Flutter의 Clean Architecture 파트1 - 소개","description":"","date":"2024-06-20 13:46","slug":"2024-06-20-FlutterCleanArchitecturePart1Introduction","content":"\n\n\n![image](/assets/img/2024-06-20-FlutterCleanArchitecturePart1Introduction_0.png)\n\n소프트웨어 개발에서는 체계적이고 유지보수 가능한 코드베이스를 유지하는 것이 매우 중요합니다. 이때 Clean Architecture가 등장하여 코드베이스를 모듈식, 독립적이고 테스트 가능한 방식으로 구성하는 데 도움을 줍니다. 이 글에서는 Clean Architecture가 무엇인지, Flutter에서 어떻게 구현하는지, 그리고 프로젝트에 어떤 이점을 가져다 줄 수 있는지 살펴보겠습니다.\n\n커피를 마시고 준비하세요! 오랜 여정이 시작됩니다.\n\n## Flutter에서 Clean Architecture를 사용해야 하는 이유\n\n\n<div class=\"content-ad\"></div>\n\n클린 아키텍처는 모듈화, 유지보수 가능성, 테스트 가능성을 향상시켜 주는 소프트웨어 설계 철학입니다. 각 층으로 코드를 분리하여 애플리케이션을 구조화하며, 크고 복잡한 앱에 특히 유용합니다.\n\n## 장점\n\n- 모듈성과 독립성: 애플리케이션을 독립적인 부분으로 분할하고 각각을 별도로 관리 및 개발합니다.\n- 쉬운 테스트 가능성: 비즈니스 로직을 독립적으로 테스트하여 오류를 감지하기 쉽습니다.\n- 테스트 주도 개발 (TDD): TDD 원칙과 잘 부합합니다. 먼저 비즈니스 로직에 대한 테스트를 작성한 후 그 테스트를 통과할 코드를 구현할 수 있습니다.\n- 미래 확장성: 새로운 기능을 추가하거나 기존 기능을 수정하는 데 더 적은 노력이 필요합니다.\n- 재사용성: 비즈니스 로직을 다른 프로젝트나 플랫폼에서 재사용할 수 있습니다.\n- 관심사 분리: 비즈니스 로직과 사용자 인터페이스 (UI) 사이의 명확한 경계를 유지함으로써 팀 구성을 더 잘 조직화할 수 있습니다.\n- 유지보수 용이성: 층 간 의존성을 줄여 코드 유지보수를 단순화합니다.\n- 변경에 대한 유연성: 데이터 소스나 서비스를 변경하기 쉽게 합니다.\n- 좋은 문서화: 프로젝트 이해와 유지보수를 위해 구조와 작동원리를 명확히 정의합니다.\n\n클린 아키텍처는 데이터층, 도메인층, 프레젠테이션 층으로 구성되어 있습니다. 각 층은 구별된 책임과 제한된 의존성을 가지고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-20-FlutterCleanArchitecturePart1Introduction_1.png)\n\n코딩을 시작하기 전에 짧게 예제에 대해 설명하겠습니다:\n\nTMDB 플랫폼의 API를 사용하여 기본 영화 애플리케이션을 구축할 예정입니다. 이 응용 프로그램은 API에서 인기 있는 및 최상위 영화 목록을 검색하고 표시할 것입니다. 사용자는 배우 세부 정보를 포함한 영화 정보에 액세스할 수 있습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:600/1*opIWWgVq6ZlP_x5sdV0LDA.gif)\n\n\n<div class=\"content-ad\"></div>\n\n사용할 패키지 목록\n\n```js\ndependencies:\n  # 라우팅을 위해 => https://pub.dev/packages/auto_route\n  auto_route: ^7.8.3\n\n  # 이미지 캐싱을 위해 => https://pub.dev/packages/cached_network_image\n  cached_network_image: ^3.3.0\n\n  # 네트워크 요청을 위해 => https://pub.dev/packages/dio\n  dio: ^5.3.3\n\n  # 동등성을 위해 => https://pub.dev/packages/equatable\n  equatable: ^2.0.5\n\n  # 테마를 위해 => https://pub.dev/packages/flex_color_scheme\n  flex_color_scheme: ^7.3.1\n\n  flutter:\n    sdk: flutter\n\n  # 상태 관리를 위해 => https://pub.dev/packages/flutter_bloc\n  flutter_bloc: ^8.1.3\n\n  # 환경 변수를 위해 => https://pub.dev/packages/flutter_dotenv\n  flutter_dotenv: ^5.1.0\n\n  # 자산 코드 생성을 위해 => https://pub.dev/packages/flutter_gen\n  flutter_gen: ^5.4.0\n\n  # 유용한 훅을 위해 => https://pub.dev/packages/flutter_hooks\n  flutter_hooks: ^0.20.3\n\n  # 책임성을 위해 => https://pub.dev/packages/flutter_screenutil\n  flutter_screenutil: ^5.9.0\n\n  # SVG를 위해 => https://pub.dev/packages/flutter_svg\n  flutter_svg: ^2.0.9\n\n  # 함수형 프로그래밍을 위해 => https://pub.dev/packages/fpdart\n  fpdart: ^1.1.0\n\n  # 의존성 주입을 위해 => https://pub.dev/packages/get_it\n  get_it: ^7.6.4\n\n  # 테마 또는 로캘 관리를 위해 => https://pub.dev/packages/hydrated_bloc\n  hydrated_bloc: ^9.1.2\n\n  intl: ^0.19.0\n\n  # 로컬 데이터 소스를 위해\n  isar: ^3.1.0+1\n  isar_flutter_libs: ^3.1.0+1\n\n  # API 모델 생성을 위해 => https://pub.dev/packages/json_annotation\n  json_annotation: ^4.8.1\n\n  # 앱 데이터 디렉토리\n  path_provider: ^2.1.1\n\n  # 개발자를 위한 dio 인터셉터 => https://pub.dev/packages/pretty_dio_logger\n  pretty_dio_logger: ^1.3.1\n\n  # 반짝거림 효과를 위해 => https://pub.dev/packages/shimmer\n  shimmer: ^3.0.0\n\n  # URL 런처를 위해 => https://pub.dev/packages/url_launcher\n  url_launcher: ^6.2.2\n\ndev_dependencies:\n  # auto_route 생성기 => https://pub.dev/packages/auto_route_generator\n  auto_route_generator: ^7.3.1\n\n  # bloc 테스트를 위해 => https://pub.dev/packages/bloc_test\n  bloc_test: ^9.1.4\n\n  build_runner: ^2.4.6\n  flutter_gen_runner: ^5.4.0\n  flutter_lints: ^3.0.1\n  flutter_test:\n    sdk: flutter\n\n  # 로컬 데이터 소스\n  isar_generator: ^3.1.0+1\n\n  # API 모델 생성을 위해 => https://pub.dev/packages/json_serializable\n  json_serializable: ^6.7.1\n\n  # 테스트를 위해 => https://pub.dev/packages/mockito\n  mockito: ^5.4.4\n```\n\n## HTTP 요청\n\nflutter_dotenv 패키지를 사용하여 간단한 애플리케이션 상수 클래스를 만들어 봅시다.\n\n<div class=\"content-ad\"></div>\n\n```js\nclass AppConstants {\n  final baseUrl = '${dotenv.env['BASE_URL']}'; //* https://api.themoviedb.org/3\n  final apiToken = '${dotenv.env['API_TOKEN']}'; //* your TMDB token. (sign up here https://developer.themoviedb.org/docs)\n}\n```\n\nHTTP 요청을 위한 클래스를 만들어 봅시다. DioClient 클래스는 API 요청을 보내고 json 데이터를 반환할 것입니다. 여기서 주요 목적은 DioClient 클래스를 get, post, put, patch, delete 메서드로 제한하는 것입니다.\n\n저희 애플리케이션에서는 하나의 API만 사용할 것이므로, Dio를 사용하기 때문에 DioClient라고 이름 짓겠습니다. 애플리케이션이 여러 개의 API와 통신해야 하는 경우, HTTP 요청을 보내는 DioClient와 유사한 클래스가 필요합니다. 이것은 각 네트워크 클래스가 관련된 데이터 원본과 관련되어야 하기 때문입니다.\n\n예를 들어, 영화 데이터에 대해 TMDB API를 사용하고 배우에 대해 BlaBla API를 사용하는 경우, 명명 규칙에 유의해야 합니다. 네이밍의 예시로는 TmdbNetworkManager, BlaBlaClient, CatClient 등이 있을 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\nclass DioClient {\n  Dio _dio;\n\n  DioClient() {\n    _dio = Dio();\n    _dio\n      ..options.baseUrl = AppConstants.baseUrl\n      ..options.headers = {\n        HttpHeaders.contentTypeHeader: ContentType.json.mimeType,\n        HttpHeaders.authorizationHeader: 'Bearer ${AppConstants.apiToken}',\n      }\n      ..options.connectTimeout = const Duration(milliseconds: 15000)\n      ..options.receiveTimeout = const Duration(milliseconds: 15000)\n      ..options.responseType = ResponseType.json\n      ..interceptors.add(\n        PrettyDioLogger(\n          compact: false,\n          logPrint: (object) => log(object.toString(), name: 'TMDB API'),\n        ),\n      );\n  }\n\n  /// * GET\n  Future<Response> get(\n    String url, {\n    Map<String, dynamic>? queryParameters,\n    Options? options,\n    CancelToken? cancelToken,\n    ProgressCallback? onReceiveProgress,\n  }) async {\n    try {\n      final response = await _dio.get(\n        url,\n        queryParameters: queryParameters,\n        options: options,\n        cancelToken: cancelToken,\n        onReceiveProgress: onReceiveProgress,\n      );\n      return response;\n    } on DioException {\n      rethrow;\n    }\n  }\n\n  /// * POST\n  Future<Response> post(\n    String uri, {\n    data,\n    Map<String, dynamic>? queryParameters,\n    Options? options,\n    CancelToken? cancelToken,\n    ProgressCallback? onSendProgress,\n    ProgressCallback? onReceiveProgress,\n  }) async {\n    try {\n      final response = await _dio.post(\n        uri,\n        data: data,\n        queryParameters: queryParameters,\n        options: options,\n        cancelToken: cancelToken,\n        onSendProgress: onSendProgress,\n        onReceiveProgress: onReceiveProgress,\n      );\n      return response;\n    } on DioException {\n      rethrow;\n    }\n  }\n\n  /// * PUT\n  Future<Response> put(\n    String uri, {\n    data,\n    Map<String, dynamic>? queryParameters,\n    Options? options,\n    CancelToken? cancelToken,\n    ProgressCallback? onSendProgress,\n    ProgressCallback? onReceiveProgress,\n  }) async {\n    try {\n      final response = await _dio.put(\n        uri,\n        data: data,\n        queryParameters: queryParameters,\n        options: options,\n        cancelToken: cancelToken,\n        onSendProgress: onSendProgress,\n        onReceiveProgress: onReceiveProgress,\n      );\n      return response;\n    } on DioException {\n      rethrow;\n    }\n  }\n\n  /// * PATCH\n  Future<Response> patch(\n    String uri, {\n    data,\n    Map<String, dynamic>? queryParameters,\n    Options? options,\n    CancelToken? cancelToken,\n    ProgressCallback? onSendProgress,\n    ProgressCallback? onReceiveProgress,\n  }) async {\n    try {\n      final response = await _dio.patch(\n        uri,\n        data: data,\n        queryParameters: queryParameters,\n        options: options,\n        cancelToken: cancelToken,\n        onSendProgress: onSendProgress,\n        onReceiveProgress: onReceiveProgress,\n      );\n      return response;\n    } on DioException {\n      rethrow;\n    }\n  }\n\n  /// * DELETE\n  Future<dynamic> delete(\n    String uri, {\n    data,\n    Map<String, dynamic>? queryParameters,\n    Options? options,\n    CancelToken? cancelToken,\n    ProgressCallback? onSendProgress,\n    ProgressCallback? onReceiveProgress,\n  }) async {\n    try {\n      final response = await _dio.delete(\n        uri,\n        data: data,\n        queryParameters: queryParameters,\n        options: options,\n        cancelToken: cancelToken,\n      );\n      return response;\n    } on DioException {\n      rethrow;\n    }\n  }\n}\n```\n\n## 네트워크 오류 모델\n\n네트워크 오류 모델을 만들어봅시다. 이 모델은 나쁜 응답 오류가 발생할 때 생성되므로 API에서 오류 메시지를 표시할 수 있습니다.\n\nTMDB API의 오류 모델은 아래와 같습니다.\n\n<div class=\"content-ad\"></div>\n\n```json\n@JsonSerializable()\nclass NetworkErrorModel extends Equatable {\n  @JsonKey(name: 'status_code')\n  final int? statusCode;\n  @JsonKey(name: 'status_message')\n  final String? statusMessage;\n\n  const NetworkErrorModel({this.statusCode, this.statusMessage});\n\n  factory NetworkErrorModel.fromJson(Map<String, dynamic> json) {\n    return _$NetworkErrorModelFromJson(json);\n  }\n\n  Map<String, dynamic> toJson() => _$NetworkErrorModelToJson(this);\n\n  @override\n  List<Object?> get props => [statusCode, statusMessage];\n}\n```\n\n## 로컬 데이터베이스\n\n데이터베이스에 접근하는 클래스를 만들어 봅시다.\n\n```json\n/// 로컬 데이터베이스를 나타내는 클래스.\n///\n/// 이 클래스는 Isar 데이터베이스를 초기화하고 액세스하는 방법을 제공합니다.\nclass LocalDatabase {\n  late final Isar _isar;\n  bool _isInitialized = false;\n\n  /// 초기화된 Isar 데이터베이스 인스턴스를 반환합니다.\n  ///\n  /// 데이터베이스가 초기화되지 않은 경우 [IsarError]를 throw합니다.\n  Isar get db => _isInitialized ? _isar : throw IsarError('Isar가 초기화되지 않았습니다.');\n\n  /// Isar 데이터베이스를 초기화합니다.\n  ///\n  /// 데이터베이스가 이미 초기화된 경우 [IsarError]를 throw합니다.\n  Future<void> initialize() async {\n    if (_isInitialized) throw IsarError('Isar가 이미 초기화되었습니다.');\n\n    final directory = await getApplicationDocumentsDirectory();\n    _isar = await Isar.open([MovieDetailCollectionSchema], directory: directory.path);\n\n    _isInitialized = true;\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## 에러 처리\n\nDioException을 사용하여 네트워크 오류를 처리하는 클래스를 만들어 보겠습니다.\n\n```js\nclass NetworkException extends Equatable implements Exception {\n  late final String message;\n  late final int? statusCode;\n\n  NetworkException.fromDioError(DioException dioException) {\n    statusCode = dioException.response?.statusCode;\n\n    switch (dioException.type) {\n      case DioExceptionType.cancel:\n        message = 'API 서버로의 요청이 취소되었습니다';\n        break;\n\n      case DioExceptionType.connectionTimeout:\n        message = 'API 서버와의 연결 시간 초과';\n        break;\n\n      case DioExceptionType.receiveTimeout:\n        message = 'API 서버와의 연결 중 수신 시간 초과';\n        break;\n\n      case DioExceptionType.sendTimeout:\n        message = 'API 서버와의 연결 중 송신 시간 초과';\n        break;\n\n      case DioExceptionType.connectionError:\n        if (dioException.error.runtimeType == SocketException) {\n          message = '인터넷 연결을 확인해주세요';\n          break;\n        } else {\n          message = '예기치 않은 오류가 발생했습니다';\n          break;\n        }\n\n      case DioExceptionType.badCertificate:\n        message = '잘못된 인증서';\n        break;\n\n      case DioExceptionType.badResponse:\n        final model = NetworkErrorModel.fromJson(dioException.response?.data as Map<String, dynamic>);\n        message = model.statusMessage ?? '예기치 않은 오류가 발생했습니다';\n        break;\n\n      case DioExceptionType.unknown:\n        message = '예기치 않은 오류가 발생했습니다';\n        break;\n    }\n  }\n\n  @override\n  List<Object?> get props => [message, statusCode];\n}\n```\n\n그리고 IsarError를 사용하여 로컬 데이터베이스 오류를 처리하는 클래스를 만들어 보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nclass DatabaseException extends Equatable implements Exception {\n  late final String message;\n\n  DatabaseException.fromIsarError(IsarError isarError) : message = isarError.message;\n\n  @override\n  List<Object?> get props => [message];\n}\n```\n\n알겠어요! 여기까지입니다. 이 부분에서는 여기까지 언급할 거예요.\n\n이제 Clean Architecture에 대해 준비되었습니다.\n\n다음 파트\n","ogImage":{"url":"/assets/img/2024-06-20-FlutterCleanArchitecturePart1Introduction_0.png"},"coverImage":"/assets/img/2024-06-20-FlutterCleanArchitecturePart1Introduction_0.png","tag":["Tech"],"readingTime":12},{"title":"플러터닌자 도쿄 2024가 끝났어요","description":"","date":"2024-06-20 13:45","slug":"2024-06-20-FlutterNinjasTokyo2024isover","content":"\n\n플러터닌자 도쿄 2024가 끝났어요!!\n\n가장 즐거웠지만 가장 힘들었던 작업이었어요! 😄\n\n세션 세부 정보는 다음 기사를 확인해주세요. 훌륭한 요약이 제공돼요. (전부 일본어에요)\n\n이 글에서는 플러터닌자를 만들 때 들어간 생각과 감사의 마음, 그리고 2025년을 향한 우리의 포부를 공유하고 싶어요.\n\n<div class=\"content-ad\"></div>\n\n# 플러터닌자가 시작된 방법\n\n먼저, 2020년 4월에 플러터다이가쿠를 시작했습니다. 그 이후로 참가자 수와 엔지니어 수준 모두가 성장했고, 열심히 스터디 세션과 해카톤을 주최하며 일본의 플러터 커뮤니티를 촉진했습니다.\n\n점차적으로 일본에 국한되지 않고 해외 사람들을 포함한 커뮤니티를 만들고 이벤트를 주최하는 게 더 의미있을 것 같다고 느꼈습니다.\n\n이 마음이 시작된 것은 2022년쯤이었는데, 2022년 11월 태국 여행 후, 코로나 상황이 안정되기 시작하자 진지하게 영어 공부를 시작했습니다. 그 이후로 매일 공부를 계속하며 2023년에는 주중 매일 3시간 정도 영어에 몰두했습니다. 심지어 유튜브, 드라마, 애니메이션까지 모든 즐길 거리를 영어로 전환해보며 더 많은 시간을 할애하기도 했습니다.\n\n<div class=\"content-ad\"></div>\n\n그래서 나는 영어 공부(주로 말하기)에 박차를 가했고, 2024년 초에 영어 유튜브 채널을 시작했습니다.\n\n그때쯤 Remi라는 Rivepord 창작자의 트윗을 우연히 발견했는데, 그는 일본에서 Flutter 컨퍼런스가 있는지 물어봤습니다. 그래서 그가 방문하고 싶어하는 Flutter 컨퍼런스가 없는지 물었습니다.\n\n그것이 Remi를 위한 행사를 개최할 수 있다면, 어째서 영어 Flutter 이벤트를 만들지 않는지 하는 아이디어를 불러일으켰습니다. 또한 나에게는 영어 실력을 활용할 수 있는 좋은 기회였습니다.\n\n일본에는 이미 FlutterKaigi라는 주요 Flutter 이벤트가 있습니다.\n\n<div class=\"content-ad\"></div>\n\n작년에 FlutterDaigaku에서 많은 이벤트를 개최했으며, FlutterKaigi와 경쟁 관계인 것으로 생각하는 사람도 있을 수 있지만, 실제로는 아닙니다. 우리는 의도적으로 다른 것을 만들려고 노력하고 있어요. 같은 일을 하는 여러 이벤트가 있다고 해서 좋다고 생각하지 않아요.\n\n또한, FlutterKaigi 팀 멤버들과 일정이 겹치지 않도록 조정하고 갈등을 일으키지 않도록 주의하고 있어요.\n\n원래 iOS 엔지니어였던 저로서, iOSDC와 try! Swift 같은 두 거장 컨퍼런스가 있는 것을 알고 있어요. 저는 FlutterNinjas를 try! Swift의 영어판으로, FlutterKaigi를 일본의 iOSDC로 생각해요.\n\n# 글로벌 참석자들에 의해 감동받았어요\n\n<div class=\"content-ad\"></div>\n\n내 소망대로, 영어 플러터 컨퍼런스를 만들었다는 사실에 너무 기뻐요. 스페인, 독일, 영국, 대만, 한국, 말레이시아 등 다양한 국가의 많은 분들이 일본을 찾아주셔서 정말 감동받았어요.\n\n물론, 플러터닌자들의 매력 뿐만 아니라 일본과 도쿄의 매료도가 있었죠. 많은 일본 팬들이 항상 일본을 방문하고 싶다고 말하는데, 우리는 플러터 엔지니어들에게 완벽한 기회를 제공할 수 있었어요.\n\n플러터닌자들 중 참가자들이 서로 친구를 사귀고, 후에도 후지산과 도쿄 주변을 구경하며 초밥을 즐기는 모습을 보니 마음이 따뜻해졌어요.\n\n# 참가자들과 후원사들에게 감사드립니다\n\n<div class=\"content-ad\"></div>\n\n이번에는 외국에서 오신 연사 분들의 여행 및 4일간의 호텔 숙박비를 지원했어요. 또한 2일간의 점심 식대, 네트워킹 파티 케이터링, 그리고 다양한 선물에도 돈을 썼어요.\n\n참가자들에게는 저렴하지 않은 행사였는데, 코딩 매직과 머니 포워드와 같은 후원사들과 물론 참가자 분들이 후원을 도와주셔서 가능했어요.\n\n많은 기업들이 커뮤니티 후원사가 되었어요. 몇몇은 직접 참석하지는 못했지만 그저 우리를 도울 수 있어서 후원을 해주었어요! 정말 감사합니다.\n\n<img src=\"/assets/img/2024-06-20-FlutterNinjasTokyo2024isover_0.png\" />\n\n<div class=\"content-ad\"></div>\n\nGoogle Flutter 팀은 스왹도 지원해주셔서 최종 추첨이 흥미로워졌어요!\n\n모든 분들 덕분에 적자 없이 재미있는 이벤트를 개최할 수 있었습니다! 이 이벤트의 가치를 믿고 앞으로 나아갈 수 있었던 것은 여러분 덕분이었어요. 누가 참석할지 또 후원사가 우리를 지원해 줄지 예측할 수 없는 상황이었지만, 최악의 경우에 대비하고 있었어요. 다행히도 잘 되었죠.\n\n# Majid에게 특별 감사\n\n안타깝게도 Majid은 FlutterNinjas에 참석하지 못했지만, Codemagic을 소개해주시고 영향력을 행사해주셔서 유럽 플러터 커뮤니티의 많은 분들이 참석할 수 있었어요. Majid께 매우 감사드립니다.\n\n<div class=\"content-ad\"></div>\n\n하지만 노르웨이에서 500명의 이벤트를 주최한 플러터 바이킹에 대한 그의 경험도 망설임 없이 공유했습니다.\n\n사실, Majid와 나는 플러터닌자가 어떻게 진행되고 있는지 논의하기 위해 세 번이나 네 번 만나기도 했습니다. 그는 수익이 나지 않더라도 관심을 가졌습니다. 정말 고마워요.\n\n# 주최팀에 대한 감사\n\n![이미지](/assets/img/2024-06-20-FlutterNinjasTokyo2024isover_1.png)\n\n<div class=\"content-ad\"></div>\n\n↑ 제가 사진에 없는 이유는 애프터 파티에 참석했기 때문입니다. 😂\n\n이 프로젝트를 흥미롭게 여기고 도움을 준 모든 분들에게 정말 감사드립니다. FlutterNinjas 초기 조직 팀의 일원이 된 것은 유익했고, FlutterNinjas를 계속 발전시키고 싶습니다!\n\n# 2025년을 바라보며\n\n올해 배운 교훈 중 하나는 6월 행사를 위해 2월에 장소와 일정을 결정해 일정이 매우 타이트했다는 것입니다. 이로 인해 연사 및 후원사를 모집하는 과정이 서둘러졌으며 더 여유로운 준비가 가능한 여유가 적었습니다.\n\n<div class=\"content-ad\"></div>\n\n이에 대처하기 위해 우리는 이미 2025년 계획을 실행 중이며, 장소를 찾는 것부터 시작하고 있어요.\n\n이번에는 135명이 참가했지만, 다음에는 500명을 대상으로 컨퍼런스를 개최할 계획이에요.\n\n저는 FlutterNinjas가 세계에서 가장 흥미로운 Flutter 컨퍼런스가 될 잠재력이 있다고 믿어요. 유럽 Flutter 컨퍼런스가 500에서 1000명의 참가자를 모은다는 소식을 들었어요. 비록 FlutterNinjas가 아직 그 규모에 이르지는 않지만, 대만, 한국, 인도, 말레이시아의 아시아 플러터 커뮤니티의 주요 멤버들이 일본을 방문하고 행사 분위기를 고취시켰어요. 각국의 참가자로 구성된 행사는 실제로 국제적인 행사였어요. 일본은 이들 아시아 국가들과의 근접성을 바탕으로 동시에 먼 거리이면서 매력적인 관광 목적지로서 상당한 장점을 제공해요.\n\n일본의 Flutter 커뮤니티와 일본 자체를 활성화시키고, 그냥 이런 활동을 즐기기 때문에 이를 계속하고 싶어요.\n\n<div class=\"content-ad\"></div>\n\n2025년에 대한 업데이트를 받으려면 트위터에서 FlutterNinjas를 팔로우해 주세요! \n\n[FlutterNinjas](https://x.com/FlutterNinjas)","ogImage":{"url":"/assets/img/2024-06-20-FlutterNinjasTokyo2024isover_0.png"},"coverImage":"/assets/img/2024-06-20-FlutterNinjasTokyo2024isover_0.png","tag":["Tech"],"readingTime":4},{"title":"플러터 위젯 플러터 앱에 카메라 기능 구현하기","description":"","date":"2024-06-20 13:43","slug":"2024-06-20-FlutterWidgetImplementingCameraFeatureinyourFlutterApp","content":"\n\n안녕하세요 여러분, 어떻게 지내세요? 잠깐 사라졌다가 다시 돌아왔습니다. 지금은 플러터 애플리케이션에 카메라를 구현하는 방법에 대해 설명해 드릴게요.\n\n저는 이 기능을 앱에 추가할 필요가 별로 없었지만, 최근에 작업 중인 애플리케이션에 이 기능을 추가해야 했어요. 여러분도 구현하고 싶어 했던 부분이라면 함께 고고씽해요:\n\n단계 1: pub.dev 사이트에서 \"camera\"라는 플러터 패키지를 import해 주세요.\n\n귀하의 애플리케이션에 카메라 패키지를 종속성으로 추가해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n링크: https://pub.dev/packages/camera\n\n![이미지](/assets/img/2024-06-20-FlutterWidgetImplementingCameraFeatureinyourFlutterApp_0.png)\n\n단계 2: 다른 OS(android 및 ios) 설정:\n\n지금, 이 패키지를 앱에 구현하는 동안, 각 OS에 대한 플러터 앱 코드베이스를 변경해야 합니다.\n\n<div class=\"content-ad\"></div>\n\niOS 구현:\n\nios/Runner/Info.plist에 두 개의 행을 추가하세요:\n\n- Privacy - Camera Usage Description 키와 사용 설명이 있는 한 줄을 추가해주세요.\n- 그리고 Privacy - Microphone Usage Description 키와 사용 설명이 있는 한 줄을 더 추가해주세요.\n\n만약 Info.plist를 텍스트로 편집하는 경우, 다음을 추가하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\n<key>NSCameraUsageDescription</key>\n<string>여기에 사용 설명 입력</string>\n<key>NSMicrophoneUsageDescription</key>\n<string>여기에 사용 설명 입력</string>\n```\n\nAndroid 구현:\n\nandroid/app/build.gradle 파일에서 최소 Android SDK 버전을 21로 변경하세요.\n\n```js\nminSdkVersion 21\n```\n\n<div class=\"content-ad\"></div>\n\nStep 3: 퍼미션 핸들러 패키지와 패스 프로바이더 패키지 설치하기\n\n이 패키지를 설치하는 이유는 사용자에게 우리 애플리케이션에서 장치의 카메라를 사용할 수 있도록 허용하도록 허락을 받으려고 하는 것입니다. 허가가 허용되지 않으면 장치에서 카메라를 사용할 수 없을 것 같습니다. 사진을 찍은 후에는 이미지가 장치에 어디에 저장되었는지 액세스할 수 있어야 하므로 path_provider를 사용합니다.\n\n퍼미션 핸들러 링크: https://pub.dev/packages/permission_handler\n\n![image](/assets/img/2024-06-20-FlutterWidgetImplementingCameraFeatureinyourFlutterApp_1.png)\n\n<div class=\"content-ad\"></div>\n\n경로 제공 링크: [여기](https://pub.dev/packages/path_provider)\n\n![이미지](/assets/img/2024-06-20-FlutterWidgetImplementingCameraFeatureinyourFlutterApp_2.png)\n\n단계 4: 카메라 초기화 및 권한 요청\n\n다음으로 할 일은 앱에서 카메라를 초기화하고 그 과정에서 기기에 있는 카메라 목록을 가져올 수 있습니다. 아래 코드는 권한이 부여되었고 카메라가 초기화된 주요 파일인 main.dart 파일이 어떻게 보이는지 예시입니다.\n\n<div class=\"content-ad\"></div>\n\n```dart\nlate List<CameraDescription> _cameras;\nvoid main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n\n  _cameras = await availableCameras();\n\n  runApp(const MyApp());\n  // runApp(const MyApp());\n}\n\nclass MyApp extends StatefulWidget {\n  const MyApp({super.key});\n\n  @override\n  State<MyApp> createState() => _MyAppState();\n}\n\nclass _MyAppState extends State<MyApp> {\n  @override\n  void initState() {\n    super.initState();\n    requestStoragePermission();\n  }\n\n  void requestStoragePermission() async {\n    // Check if the platform is not web, as web has no permissions\n    if (!kIsWeb) {\n      // Request storage permission\n      var status = await Permission.storage.status;\n      if (!status.isGranted) {\n        await Permission.storage.request();\n      }\n\n      // Request camera permission\n      var cameraStatus = await Permission.camera.status;\n      if (!cameraStatus.isGranted) {\n        await Permission.camera.request();\n      }\n    }\n  }\n\n  // This widget is the root of your application.\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp.router(\n      debugShowCheckedModeBanner: false,\n      routerConfig: router,\n    );\n  }\n}\n```\n\n제 5 단계 : 카메라 기능 구현\n\n카메라 컨트롤러 초기화\n\n_CameraAppState 클래스에서 initState 메서드에서 카메라 컨트롤러를 초기화합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nlate CameraController controller;\n```\n\n여기서, 카메라를 초기화하고 해상도 프리셋을 ResolutionPreset.max로 설정했습니다.\n\n카메라 초기화 처리\n\n카메라를 초기화하고 이 과정 중에 발생할 수 있는 모든 오류를 처리하기 위해 controller.initialize()를 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\ncontroller.initialize().then((_) {\n  if (!mounted) {\n    return;\n  }\n  setState(() {});\n}).catchError((Object e) {\n  if (e is CameraException) {\n    switch (e.code) {\n      case 'CameraAccessDenied':\n        // 여기에서 액세스 오류를 처리합니다.\n        break;\n      default:\n        // 다른 오류를 처리합니다.\n        break;\n    }\n  }\n});\n```\n\nUI 구축하기\n\nUI는 카메라 피드를 표시하는 CameraPreview 위젯과 이미지를 캡처하는 FloatingActionButton으로 구성됩니다. 그래서 FloatingActionButton을 클릭하면 카메라에 의해 표시된 이미지를 캡처할 수 있습니다.\n\n```js\nreturn SafeArea(\n  child: Scaffold(\n    appBar: AppBar(\n      // 앱 바 설정\n    ),\n    body: Stack(\n      children: <Widget>[\n        CameraPreview(controller),\n        Align(\n          alignment: Alignment.bottomCenter,\n          child: Padding(\n            padding: const EdgeInsets.only(bottom: 16.0),\n            child: FloatingActionButton(\n              onPressed: () {\n                _takePicture(); // 사진 촬영 메서드 호출\n              },\n              child: Icon(Icons.camera),\n              backgroundColor: Colors.white,\n              foregroundColor: AppColors.deepBlue,\n            ),\n          ),\n        ),\n      ],\n    ),\n  ),\n);\n```\n\n<div class=\"content-ad\"></div>\n\n이미지 캡처 및 보기\n\n여기에 플로팅 액션 버튼에 연결한 함수를 구현했습니다. 이 함수는 이미지를 캡처하는 유일한 목적으로 사용됩니다:\n\n```js\nvoid _takePicture() async {\n  try {\n    final XFile picture = await controller.takePicture();\n    setState(() {\n      imageFile = picture;\n    });\n    // 이미지를 캡처한 후 이미지 뷰 페이지로 이동\n    Navigator.push(\n      context,\n      MaterialPageRoute(\n        builder: (context) => ImageViewPage(imagePath: imageFile!.path),\n      ),\n    );\n  } catch (e) {\n    print(\"사진 찍기 오류 발생: $e\");\n  }\n}\n```\n\n캡처한 이미지 파일 경로를 가져와 다음 페이지에서 캡처한 이미지를 볼 수 있도록 탐색을 포함했습니다.\n\n<div class=\"content-ad\"></div>\n\n이미지 보기\n\n이제 사진을 찍은 후에는 찍은 이미지를 보고 싶을 것입니다, 맞죠? 찍은 이미지를 볼 수 있는 페이지로 이동하는 것을 허용하는 페이지가 여기 있습니다:\n\n```js\nclass ImageViewPage extends StatefulWidget {\n  final String imagePath;\n  const ImageViewPage({super.key, required this.imagePath});\n\n  @override\n  State<ImageViewPage> createState() => _ImageViewPageState();\n}\n\nclass _ImageViewPageState extends State<ImageViewPage> {\n  bool isLoading = false;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Captured Image'),\n      ),\n      body: Center(\n        child: Image.file(File(widget.imagePath)),\n      ),\n    );\n  }\n}\n```\n\n마무리\n\n<div class=\"content-ad\"></div>\n\n이 가이드에서는 카메라 패키지를 사용하여 Flutter 응용 프로그램에서 간단한 카메라 기능을 구현했습니다. 카메라를 초기화하고 초기화 오류를 처리하며, 캡처 및 이미지 보기를 위한 사용자 친화적인 UI를 제공했습니다. 이는 Flutter 앱에서 이미지 필터, 비디오 녹화 등 더 고급 카메라 기능을 구축하기 위한 기본 단계입니다. 코딩을 즐기세요!\n\n아래는 사진을 찍고 그 작업을 실행하는 페이지의 전체 코드 구현입니다:\n\n```js\nclass CameraApp extends StatefulWidget {\n  final List<CameraDescription> cameras;\n  const CameraApp({super.key, required this.cameras});\n\n  @override\n  State<CameraApp> createState() => _CameraAppState();\n}\n\nclass _CameraAppState extends State<CameraApp> {\n  late CameraController controller;\n  late XFile? imageFile;  // 캡처된 이미지 파일을 저장하는 변수\n\n  @override\n  void initState() {\n    super.initState();\n    controller = CameraController(widget.cameras[1], ResolutionPreset.max);\n    controller.initialize().then((_) {\n      if (!mounted) {\n        return;\n      }\n      setState(() {});\n    }).catchError((Object e) {\n      if (e is CameraException) {\n        switch (e.code) {\n          case 'CameraAccessDenied':\n            // 여기서 액세스 오류 처리\n            break;\n          default:\n            // 다른 오류 처리\n            break;\n        }\n      }\n    });\n  }\n\n  @override\n  void dispose() {\n    controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    if (!controller.value.isInitialized) {\n      return Container();\n    }\n    return SafeArea(\n      child: Scaffold(\n        appBar: AppBar(\n          backgroundColor: AppColors.deepBlue,\n          leading: BackButton(\n            color: Colors.white,\n            onPressed: () {\n              Navigator.pop(context);\n            },\n          ),\n          centerTitle: true,\n          title: Text(\n            '사진 찍기',\n            style: TextStyle(color: Colors.white),\n          ),\n        ),\n        body: Stack(\n          children: <Widget>[\n            CameraPreview(controller),\n            Align(\n              alignment: Alignment.bottomCenter,\n              child: Padding(\n                padding: const EdgeInsets.only(bottom: 16.0),\n                child: FloatingActionButton(\n                  onPressed: () {\n                    _takePicture();  // 사진 찍는 메서드 호출\n                  },\n                  child: Icon(Icons.camera),\n                  backgroundColor: Colors.white,\n                  foregroundColor: AppColors.deepBlue,\n                ),\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  // 사진 찍는 메서드\n  void _takePicture() async {\n    try {\n      final XFile picture = await controller.takePicture();\n      setState(() {\n        imageFile = picture;\n      });\n      // 이미지 캡처 후 이미지 뷰 페이지로 이동\n      Navigator.push(\n        context,\n        MaterialPageRoute(\n          builder: (context) => ImageViewPage(imagePath: imageFile!.path),\n        ),\n      );\n    } catch (e) {\n      print(\"사진 찍기 오류: $e\");\n    }\n  }\n}\n```\n\n<img src=\"https://miro.medium.com/v2/resize:fit:592/1*oqIKI2wzNfzOj1IJ-EDmoQ.gif\" />\n\n\n<div class=\"content-ad\"></div>\n\n텍스트를 위해 감사합니다 👏 재미있게 읽으셨다면 한 번 클릭해 주시고, 계속해서 많은 글 읽어주세요. 함께 해서 즐거웠습니다 😊✌️","ogImage":{"url":"/assets/img/2024-06-20-FlutterWidgetImplementingCameraFeatureinyourFlutterApp_0.png"},"coverImage":"/assets/img/2024-06-20-FlutterWidgetImplementingCameraFeatureinyourFlutterApp_0.png","tag":["Tech"],"readingTime":9},{"title":"플러터에서 모양과 클리핑 마스터하기","description":"","date":"2024-06-20 13:42","slug":"2024-06-20-MasteringShapesandClippinginFlutter","content":"\n\n도형과 상자를 다루는 것은 설계된 UI를 구현하는 방법을 알지 못하면 압도될 수 있습니다. 이 기사에서는 매우 기초부터 시작하여 일부 고급 예제로 이동할 것입니다.\n\n## 1. 도형과 상자란 무엇인가요?\n\n도형은 해당 경로에 의해 정의된 어떤 형태를 나타낼 수 있습니다.\n\n상자는 4개의 점으로 구성된 직사각형 모양을 나타냅니다. 테두리 반경과 같은 추가 속성을 가질 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n위젯 Flutter의 다양한 컨텍스트에서 상자가 나타날 수 있어요. \n\n예를 들어:\n\n- RenderBox: 비 슬리버 컨텍스트의 위젯의 RenderObject\n- BoxDecoration\n- BoxBorder\n\n또한 ShapeDecoration, ShapeBorder와 같은 클래스들도 있어요.\n\n우리는 Container, DecoratedSlivers 또는 DecoratedBoxes를 스타일링하기 위해 자주 BoxDecoration을 사용해요:\n\n<div class=\"content-ad\"></div>\n\n\n```js\nDecoratedBox(\n  decoration: BoxDecoration( // <- this\n    borderRadius: BorderRadius.circular(10),\n    color: Colors.amber,\n  ),\n  child: const SizedBox(height: 200, width: 200),\n)\n```\n\n그냥 이렇게 해서, 결과를 얻습니다:\n\n<img src=\"/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_0.png\" />\n\n대안으로 ShapeDecoration을 사용할 수도 있는데, 이것은 색상, 그림자, 그라디언트의 비슷한 사용자 정의를 제공하지만 주요 차이점은 그 모양 매개변수가 BoxShape 대신 ShapeBorder를 사용한다는 것입니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\nDecoratedBox(\n  decoration: ShapeDecoration( // <- 이 부분\n    color: Colors.amber,\n    shape: BeveledRectangleBorder(borderRadius: BorderRadius.circular(20)),\n  ),\n  child: const SizedBox(height: 200, width: 200),\n)\n```\n\n<img src=\"/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_1.png\" />\n\n그럼 ShapeBorder는 정확히 무엇인가요?\n\n구현을 확인하면 좀 더 명확해집니다. OutlinedBorder, StarBorder, BeveledRectangleBorder와 같은 슈퍼클래스들이 있습니다. 이것들은 위젯을 꾸미기 위한 다양한 모양들입니다. 그리고 WidgetStateOutlinedBorder도 있습니다. WidgetStates에 익숙하지 않다면 해당 기사를 읽어보세요.\n\n\n<div class=\"content-ad\"></div>\n\n경계의 본질은 내부 경로와 외부 경로 2개가 있어야 한다는 것을 의미합니다:\n\n![MasteringShapesandClippinginFlutter](/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_2.png)\n\n베지에 곡선에 익숙하지 않다면, 이 대화식 가이드를 확인하는 것을 추천합니다. 플러터의 Path는 선형, 이차, 삼차 및 콘회의 절을 지원합니다.\n\n용어는 여기까지, 이제 재미있는 일을 시작해 봅시다: 사용자 정의 모양을 만들어 보세요!\n\n<div class=\"content-ad\"></div>\n\n# 2. 사용자 정의 ShapeBorder 구현\n\n위 작업을 수행하려면 ShapeBorder의 슈퍼 클래스 또는 OutlinedBorder를 만들고 다음 메서드를 구현해야 합니다:\n\n- getInnerPath 및 getOuterPath: 해당 경로를 반환하는 메서드\n- paint: 모양을 그리는 메서드\n- scale, copyWith\n\n원하는 메시지 버블 모양을 만들어보겠습니다. 원구획을 사용하고 두께(w) 매개변수를 변수로 사용하세요.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_3.png)\n\n```js\nclass MessageShapeBorder extends OutlinedBorder {\n  final double borderRadius;\n  final double weight;\n\n  const MessageShapeBorder({\n    super.side, \n    this.borderRadius = 50,\n    this.weight = 2.5,\n  });\n\n  ...\n\n}\n```\n\n그 다음으로, getOuterPath 메서드를 구현합니다. 여기서 경로는 아래 왼쪽 모서리에서 시계 방향으로 이동하는 선 및 물결 모양 세그먼트로 구성됩니다.\n\n```js\n  @override\n  Path getOuterPath(Rect rect, {TextDirection? textDirection}) {\n    final double left = rect.left;\n    final double right = rect.right;\n    final double top = rect.top;\n    final double bottom = rect.bottom;\n\n    final radius = borderRadius;\n    final offset = 10;\n\n    return Path()\n      ..moveTo(left, bottom)\n      ..conicTo(left + offset, bottom - offset, left + offset,\n          bottom - 2 * radius, weight)\n      ..lineTo(left + offset, top + radius)\n      ..conicTo(left + offset, top, left + offset + radius, top, weight)\n      ..lineTo(right - radius, top)\n      ..conicTo(right, top, right, top + radius, weight)\n      ..lineTo(right, bottom - radius)\n      ..conicTo(right, bottom, right - radius, bottom, weight)\n      ..close();\n  }\n```\n\n\n<div class=\"content-ad\"></div>\n\n더 명확하게 하기 위해, 아래는 각 행이 하는 작업을 시각적으로 보여줍니다:\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*KKbxvf4nJa9IXIUcPdPUxg.gif)\n\n이제 약간 다른 내부 경로를 만들어 봅시다:\n\n```js\n  @override\n  Path getInnerPath(Rect rect, {TextDirection? textDirection}) {\n    final strokeWidth = side.width;\n\n    final double left = rect.left + strokeWidth;\n    final double right = rect.right - strokeWidth;\n    final double top = rect.top + strokeWidth;\n    final double bottom = rect.bottom - strokeWidth;\n\n    final radius = math.max(0, borderRadius - 10);\n    final offset = 10;\n\n    return Path()\n      ..moveTo(left + offset + radius, bottom)\n      ..conicTo(\n          left + offset, bottom, left + offset, bottom - 2 * radius, weight)\n      ..lineTo(left + offset, top + radius)\n      ..conicTo(left + offset, top, left + offset + radius, top, weight)\n      ..lineTo(right - radius, top)\n      ..conicTo(right, top, right, top + radius, weight)\n      ..lineTo(right, bottom - radius)\n      ..conicTo(right, bottom, right - radius, bottom, weight)\n      ..close();\n  }\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n  @override\n  void paint(Canvas canvas, Rect rect, {TextDirection? textDirection}) {\n    canvas.drawPath(getInnerPath(rect), Paint()..color = side.color);\n  }\n```\n\n<img src=\"/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_4.png\" />\n\n이제 이 모양을 다음과 같이 DecoratedBox에서 사용할 수 있습니다:\n\n```js\nDecoratedBox(\n  decoration: ShapeDecoration(\n    shape: MessageShapeBorder(\n      borderRadius: 30,\n      fillColor: Color(0xFF7ADEFF)\n    ),\n    color: Color(0xFFd6f5ff),\n  ),\n  child: Padding(\n    padding: EdgeInsets.all(20).copyWith(left: 30),\n    child: Text(\"샘플 메시지 텍스트\"),\n  ),\n)\n```\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_5.png\" />\n\n안녕하세요! 코닉 섹션의 무게를 AnimatedBuilder를 사용하여 애니메이션할 수 있습니다. 만약 플러터의 애니메이션에 익숙하지 않다면, 꼭 공식 안내서를 읽어보시기를 강력히 추천합니다.\n\n```js\nMessageShapeBorder(\n  side: BorderSide(color: Color(0xFF7ADEFF), width: animation.value + 2),\n  weight: animation.value,\n  borderRadius: 30\n)\n```\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1088/1*AqcXygpWbTcwMHVyDkAf6A.gif\" />\n\n\n<div class=\"content-ad\"></div>\n\n# 3. 사용 중인 클리퍼\n\nFlutter에서는 여러 내장 클리퍼가 있습니다. 예를 들면:\n\n- 직사각형에 사용하는 ClipRect\n- 둥근 직사각형에 사용하는 ClipRRect\n- 원과 타원에 사용하는 ClipOval\n- 사용자 정의 경로에 사용하는 ClipPath\n\n첫 세 개는 사용하기 매우 간단합니다. 클리핑을 원하는 위젯을 해당 클리퍼로 감싸기만 하면 클리핑 효과를 얻을 수 있습니다. 그러나 이러한 클래스들에 대해 더 알고 싶다면 여기 공식 문서 링크를 참조해주세요.\n\n<div class=\"content-ad\"></div>\n\nClipPath은 CustomClipper를 인수로 사용합니다. 대부분의 경우에는 ShapeBorder를 ShapeBorderClipper에 전달하면 됩니다. 이는 ShapeBorder의 외부 경로로 자식을 클리핑하는 CustomClipper의 구현입니다:\n\n```js\nClipPath(\n  clipper: const ShapeBorderClipper( // <- 이 부분\n    shape: MessageShapeBorder(),\n  ),\n  child: Image.asset(\n    \"assets/6392956.jpg\",\n    height: 300,\n    width: 300,\n    fit: BoxFit.cover,\n    cacheHeight: (300 * MediaQuery.of(context).devicePixelRatio).toInt(),\n  ),\n);\n```\n\n<img src=\"/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_6.png\" />\n\n클리핑이 레이아웃에서 사용될 때마다 새 레이어가 생성되는 점을 주의해야 합니다. 이는 비교적 비용이 많이 드는 작업이므로 가능한 경우 클리핑 대신 데코레이션을 사용하세요.\n\n<div class=\"content-ad\"></div>\n\n# 4. 사용자 지정 클리퍼\n\n일부 경우에는 클리핑에 대해 더 많은 제어가 필요합니다. 예를 들어, 클리핑이 콘텐츠나 일부 형제 위젯에 따라 달라져야 할 때입니다. 콘텐츠에 따라 달라지는 노치가 있는 티켓 모양 위젯을 만들어 봅시다:\n\n![이미지](/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_7.png)\n\n여기서 어려운 점은 상하 자식 위젯의 크기가 다를 수 있고, 노치가 이에 종속되어야 한다는 것입니다. Flutter에서 위젯의 크기 정보는 RenderObject의 하위 클래스인 RenderBox를 사용하여 얻을 수 있습니다. RenderObjects에 익숙하지 않다면, 공식 문서로 이동하여 확인해보세요.\n\n<div class=\"content-ad\"></div>\n\n먼저 레이아웃을 만들고 상단과 하단 자식을 나누는 SizedBox에 GlobalKey를 추가해보겠습니다.\n\n```js\nfinal notchKey = GlobalKey(); // <- 이 부분\n\n...\n\nColumn(\n  children: [\n    widget.topChild,\n    SizedBox(key: notchKey, height: 20), // <- 이 부분\n    widget.bottomChild,\n  ],\n)\n```\n\nGlobalKey를 사용하면 위젯의 BuildContext를 얻을 수 있어요. RenderObject를 얻기 위해 context가 필요한데요. SizedBox의 좌표를 티켓 위젯의 context에서 가져와야 해서 해당 RenderBoxes가 필요해요. 여기에서는 Slivers을 사용하지 않기 때문에 RenderObject를 안전하게 RenderBox로 형변환할 수 있어요.\n\n```js\nClipPath(\n  clipper: _TicketClipper( // <- 우리의 클리퍼\n    notchBox: notchKey.currentContext?.findRenderObject() as RenderBox, // <- 이 부분\n    ancestorBox: context.findRenderObject() as RenderBox, // <- 이 부분\n  ),\n  child: ColoredBox(\n    color: Color(0xFFd6f5ff),\n    child: Column(\n      children: ...\n    ),\n  ),\n)\n```\n\n<div class=\"content-ad\"></div>\n\n\n그리고 클리퍼 자체는 다음과 같이 보일 것입니다:\n\n```js\nclass _TicketClipper extends CustomClipper<Path> {\n  final RenderBox notchBox;\n  final RenderBox ancestorBox;\n\n  _TicketClipper({required this.notchBox, required this.ancestorBox});\n\n  @override\n  Path getClip(Size size) {\n    final widgetRect = RRect.fromRectAndRadius(\n      Rect.fromPoints(Offset.zero, Offset(size.width, size.height)),\n      const Radius.circular(10),\n    );\n\n    final notch = notchBox.localToGlobal(Offset.zero, ancestor: ancestorBox);\n\n    return Path.combine(\n      PathOperation.difference,\n      Path()..addRRect(widgetRect),\n      Path()\n        ..addOval(Rect.fromCenter(\n            center: Offset(0, notch.dy + 10), width: 20, height: 20))\n        ..addOval(Rect.fromCenter(\n            center: Offset(size.width, notch.dy + 10), width: 20, height: 20)),\n    );\n  }\n\n  @override\n  bool shouldReclip(covariant CustomClipper<Path> oldClipper) {\n    ...\n  }\n}\n```\n\nFlutter는 차이, 교차 등의 경로 작업을 지원합니다. 여기서는 둥근 사각형에서 2개의 원을 빼내어 원하는 모양을 얻어낸 것입니다.\n\n<img src=\"/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_8.png\" />\n\n<div class=\"content-ad\"></div>\n\n이 글이 도움이 되셨기를 바랍니다. 새로운 기술을 발견할 때마다 업데이트하겠습니다. 최신 업데이트를 받으시려면 Twitter에서 제 소식을 팔로우해주세요. 전체 코드를 읽고 싶다면 저장소를 확인해주세요.\n\n![마스터링 플러터의 형태와 클리핑](/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_9.png)","ogImage":{"url":"/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_0.png"},"coverImage":"/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_0.png","tag":["Tech"],"readingTime":9},{"title":"웹 어셈블리 웹 애플리케이션을 위한 강력한 동료","description":"","date":"2024-06-19 14:50","slug":"2024-06-19-WebAssemblyAPowerfulAllyforWebApplications","content":"\n\n웹어셈블리 (WebAssembly 또는 Wasm)는 본질적으로는 low-level 언어가 아니라 다른 고성능 언어들인 C, C++, Rust, 심지어 JVM 언어 등을 웹 브라우저에서 실행하기 위해 설계된 바이트코드 형식입니다. 이는 이러한 언어들이 JavaScript와 원활하게 상호작용할 수 있도록 하는 다리 역할을 합니다.\n\nWebAssembly의 주요 장점:\n\n- 향상된 성능: Wasm은 사전 컴파일된 특성으로 연산 집약적 작업에 뛰어납니다. 이는 JavaScript의 해석 오버헤드를 우회하여 그래픽이 많은 응용프로그램, 3D 게임, 복잡한 시뮬레이션 등의 빠른 실행을 이끌어냅니다.\n- 언어 중립성: 개발자는 C++ 또는 Rust와 같은 언어의 전문 지식을 활용하여 Wasm으로 컴파일하고 웹 프로젝트 내에서 원활하게 통합할 수 있습니다. 이로써 코드 재사용이 확대되고 효율적인 개발 워크플로우가 열립니다.\n- 작은 파일 크기: Wasm 모듈은 일반적으로 JavaScript 대비 더 작아서, 더 빠른 로딩 시간과 효율적인 사용자 경험을 제공합니다, 특히 모바일 기기에서 더욱.\n- 보안 샌드박스: Wasm 모듈은 안전한 샌드박스 환경에서 작동하여 DOM 같은 브라우저 리소스에 직접 액세스할 수 없습니다. 이는 웹 애플리케이션의 전반적인 보안 수준을 향상시킵니다.\n- 하드웨어 가속: Wasm은 SIMD(단일 명령어, 다중 데이터)와 같은 하드웨어 기능을 활용하여 병렬 처리를 더 향상시킵니다. 이것은 현대 프로세서에서 성능을 더욱 향상시킵니다.\n- 개선된 가비지 컬렉션: Wasm은 자체 자동 가비지 컬렉션을 내장하지 않지만, JavaScript의 가비지 컬렉터보다 메모리를 더 효율적으로 관리할 수 있도록 개발자들에게 허용됩니다. 특히 엄격한 성능 요구 사항을 갖는 실시간 응용프로그램에 매우 유익할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n![2024-06-19-WebAssemblyAPowerfulAllyforWebApplications_1](/assets/img/2024-06-19-WebAssemblyAPowerfulAllyforWebApplications_1.png)\n\n자바스크립트와의 보완적 관계:\n\nWasm은 자바스크립트를 완전히 대체하기 위한 것이 아닙니다. 대신, Wasm은 연산량이 많고 원시 속도가 중요한 작업에 초점을 맞춘 소중한 동반자로 작용합니다. 자바스크립트는 핵심 브라우저 상호작용, 사용자 인터페이스(UI) 조작, 최고 성능을 요구하지 않는 애플리케이션 로직을 위한 선택 언어로 남아 있습니다.\n\nWasm과 자바스크립트를 전략적으로 결합함으로써, 개발자들은 빠르고 반응적이며 안전하며 유지보수가 용이한 새로운 세대의 웹 애플리케이션을 만들 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n요약하면:\n\nWebAssembly은 웹 개발 분야에서 큰 진전을 가져왔습니다. 높은 성능을 웹 브라우저로 가져다 줄 수 있는 능력은 개발자와 사용자 모두에게 흥미로운 가능성을 제공합니다. 모든 상황에서 JavaScript를 대체하지는 못할지라도, Wasm은 예외적인 웹 경험을 만들 수 있는 강력한 도구입니다.","ogImage":{"url":"/assets/img/2024-06-19-WebAssemblyAPowerfulAllyforWebApplications_0.png"},"coverImage":"/assets/img/2024-06-19-WebAssemblyAPowerfulAllyforWebApplications_0.png","tag":["Tech"],"readingTime":2},{"title":"2024년 최고의 백엔드 프레임워크 10선","description":"","date":"2024-06-19 14:49","slug":"2024-06-19-Top10BackendFrameworksin2024","content":"\n\n백엔드 개발 세계는 끊임없이 발전하는 동적인 환경이에요. 2024년을 맞이하며, 강력한 백엔드 프레임워크들이 인기를 끌고 있고, 혁신적인 방법으로 떠오르는 프레임워크들도 있어요. 함께 2024년 웹 개발 시장을 선도할 상위 10개의 백엔드 프레임워크를 살펴봐요:\n\n![이미지](/assets/img/2024-06-19-Top10BackendFrameworksin2024_0.png)\n\n1. Spring Boot (Java)\n\n- 장점: 빠른 개발, 견고한 생태계, 대규모 애플리케이션에 용이해요.\n- 초점: Java 개발을 단순화하여 대규모 복잡한 프로젝트에 적합해요.\n- 성공 비결: 성숙한 기술, 강력한 커뮤니티 지지, 마이크로서비스 아키텍처에 적합함.\n\n<div class=\"content-ad\"></div>\n\n2. Django (Python)\n\n- 장점: \"전부 들어있다\" 방식, 보안에 중점을 둠.\n- 초점: 빠른 프로젝트와 안전한 웹 애플리케이션에 적합함.\n- 번창하는 이유: 신속한 개발력으로 유명하며 데이터 중심 앱에 적합함.\n\n3. Express.js (Node.js)\n\n- 장점: 미니멀리즘, 유연성, 거대한 커뮤니티.\n- 초점: 핵심 기반; 개발자들이 필요에 맞게 솔루션을 만들 수 있음.\n- 번창하는 이유: 실시간 앱 및 API에 대한 우수한 성능, 다재다능한 생태계.\n\n<div class=\"content-ad\"></div>\n\n## 4. 라라벨 (PHP)\n\n- 강점: 우아한 구문, 일반 웹 앱 기능에 대한 탁월한 도구.\n- 초점: PHP 개발을 즐겁고 효율적으로 만드는 데 집중.\n- 번창하는 이유: 사용 편의성과 개발자 경험에 대한 집중이 지속적인 지원을 끌어들이기 때문입니다.\n\n## 5. 루비온레일스 (루비)\n\n- 강점: 설정 대신 규칙, 개발자 행복.\n- 초점: 최소한의 설정으로 웹 앱을 시작하는 데 집중.\n- 번창하는 이유: 헌신적인 팔로잉과 신속한 프로토타이핑에 대해 계속해서 적합하다는 이유입니다.\n\n<div class=\"content-ad\"></div>\n\n6. ASP.NET Core (C#)\n\n- 장점: 크로스 플랫폼, 우수한 성능, Microsoft의 지원.\n- 초점: 현대적인 .NET 기반 웹 솔루션을 위한 다재다능한 도구 세트.\n- 번창하는 이유: Microsoft 생태계에 있는 사용자들에게 이상적이며 성숙함과 성능을 제공합니다.\n\n7. NestJS (TypeScript/Node.js)\n\n- 장점: 체계적인 접근 방식, TypeScript 활용.\n- 초점: 확장 가능하고 기업용급 Node.js 애플리케이션.\n- 번창하는 이유: Node.js의 강력함을 안전한 유형 및 조직적인 프레임워크와 결합합니다.\n\n<div class=\"content-ad\"></div>\n\n8. Flask (Python)\n\n- 강점: 소규모부터 중간 규모 프로젝트에 이상적인 미니멀리스트 접근 방식.\n- 초첨: 엄격한 방식보다는 간편함과 유연성에 초점.\n- 성공 요인: Python 개발자와 사용자 정의를 우선시하는 소규모 프로젝트에 대한 훌륭한 시작점.\n\n9. Koa.js (Node.js)\n\n- 강점: 경량 기반, 현대적인 기능.\n- 초점: 효율적이고 적응 가능한 API 및 의견 없는 웹 애플리케이션 구축.\n- 성공 요인: 제어와 혁신이 유경험자를 매료시킴.\n\n<div class=\"content-ad\"></div>\n\n10. Phoenix (Elixir)\n\n- 강점: 높은 동시성, 장애 허용성, 함수형 언어인 Elixir로 구축되었습니다.\n- 초점: 초고속, 실시간 웹 애플리케이션 및 분산 시스템.\n- 번창하는 이유: 극단적인 확장성과 신뢰성이 필요한 애플리케이션에 강력한 선택지.\n\n미래를 형성하는 요소\n\n2024년에 백엔드 프레임워크를 선택할 때 다음 추세들을 고려하세요:\n\n<div class=\"content-ad\"></div>\n\n- 클라우드 네이티브 개발: 마이크로서비스와 컨테이너화에 적합한 프레임워크가 수요가 증가할 것입니다.\n- 엣지 컴퓨팅: 응답 시간을 최적화하고 분산형 애플리케이션에 적합한 프레임워크를 찾아보세요.\n- 인공지능과 머신 러닝: AI/ML 파이프라인과 쉽게 통합되는 프레임워크가 가치가 있어집니다.\n\n특정 프레임워크에 대한 깊은 분석, 또는 떠오르는 도전자들에 대한 논의 등을 원하시면 더 긴 게시물이나 심층적인 분석을 제공해 드릴 수 있습니다!","ogImage":{"url":"/assets/img/2024-06-19-Top10BackendFrameworksin2024_0.png"},"coverImage":"/assets/img/2024-06-19-Top10BackendFrameworksin2024_0.png","tag":["Tech"],"readingTime":3},{"title":"2023년 AI 개발자로서의 여정 생성 모델 AI 웹 앱 개발 과정에서 얻은 교훈","description":"","date":"2024-06-19 14:46","slug":"2024-06-19-FromDataScientisttoAIDeveloperLessonsBuildingaGenerativeAIWebAppin2023","content":"\n\n## 수천 명의 사용자를 대상으로 하는 AI 웹 앱을 구축하고자 하는 데이터 과학 열정가를 위한 기술 팁 안내서\n\n![이미지](/assets/img/2024-06-19-FromDataScientisttoAIDeveloperLessonsBuildingaGenerativeAIWebAppin2023_0.png)\n\n만약 대학교나 온라인 강좌 중 하나를 통해 데이터 과학의 세계로 모험을 떴다면, 아마도 ML/AI 소프트웨어 제품을 만들어 사람들이 사용할 수 있는 꿈을 품어 보았을 것입니다. 우리 CS 친구들이 쉽게 코딩하는 것처럼 말이죠.\n\n하지만 풀 스택 웹 개발에 손을 대보면 구성, 배포, 터미널 명령 및 서버 등과 같이 굉장히 어렵게 느껴질 수 있는 장벽에 봉착하게 될 겁니다.\n\n<div class=\"content-ad\"></div>\n\n![2024-06-19-FromDataScientisttoAIDeveloperLessonsBuildingaGenerativeAIWebAppin2023_1.png](/assets/img/2024-06-19-FromDataScientisttoAIDeveloperLessonsBuildingaGenerativeAIWebAppin2023_1.png)\n\n이런 것은 아주 잘 알아요. 도움을 받을 수 없이 시간을 보내다 보니, 저에게 기능이 있는 소프트웨어 앱을 만들어낼 수 없을 거라는 나의 열등감만 깊어졌어요.\n\n그런데 정확히 1년 전인 1월 21일, 여권 문제와 취소된 여행으로 예상치 못하게 여는 주말이 생겼고, AI 앱을 만드는 여행에 나섰어요. 이 여행은 예상치 못한 곳으로 나를 이끌었죠 — 세계 반대편에 있는 공동 창업자와 팀을 이루고, 샌프란시스코 스타트업 가속기에 참가하게 되어, 결국 수천 명의 사용자를 확보하고 상당한 연간 수익을 창출했어요 (우리 앱 'Podsmart!'을 확인해보세요. 우리는 팟캐스트를 요약해요).\n\n![2024-06-19-FromDataScientisttoAIDeveloperLessonsBuildingaGenerativeAIWebAppin2023_2.png](/assets/img/2024-06-19-FromDataScientisttoAIDeveloperLessonsBuildingaGenerativeAIWebAppin2023_2.png)\n\n<div class=\"content-ad\"></div>\n\n하지만 무엇보다 중요한 것은, 그것은 당혹스러운 소프트웨어 개발 세계를 형식적인 컴퓨터 과학/소프트웨어 엔지니어링 배경 없이 탐험하며 고통스러운 여정이었습니다.\n\n따라서 내 첫 번째 소프트웨어 제품을 만들며 지난 일년을 돌아보면, 수천 명의 사용자를 위해 기능적인 웹 앱을 구축하려는 데이터 과학 애호가를 위한 일부 기술적 팁을 모았습니다.\n\n이 가이드는 내가 일 년 동안 겪은 고난과 배움에서 탄생했으며, 1년 전의 나에게 전하고 싶었던 조언을 대변합니다.\n\n참고: 이 팁은 내 개별적인 경험을 바탕으로 한 것이며, 다른 사람들에게는 다르게 작용할 수 있습니다. 또한 여기서 권장된 도구들과는 어떠한 관계나 제휴도 없음을 밝힙니다.\n\n<div class=\"content-ad\"></div>\n\n## 목차\n\n- 원하는 것을 만들고 싶다면\n- YouTube 웹 개발 튜토리얼의 위험성\n  - 팁 #1: React 대신 Next.js 사용\n  - 팁 #2: 스타일링을 위해 Bootstrap 대신 Tailwind CSS 선택\n- 데이터 과학 마인드셋의 함정\n  - 팁 #3: 백엔드로 Flask 대신 FastAPI 선택하고 응답 모델을 엄밀히 정의\n  - 팁 #4: JavaScript 대신 TypeScript 사용\n- 배포에 대해\n  - 팁 #5: 백엔드에 GPU 백엔드로 모델 사용\n  - 팁 #6: 백엔드 배포에 AWS Lambda, 프론트엔드에 Vercel 사용\n- 삶을 편하게 만들기\n  - 팁 #7: React를 사용하여 직접 랜딩 페이지를 만들지 말기\n  - 팁 #8: 사용자 인증 및 결제를 위해 Firebase + Stripe 사용\n  - 팁 #9: 에러 모니터링을 위해 Sentry 구현\n- 결론\n\n# 원하는 것을 만들고 싶을 때\n\n해당 기능을 갖춘 웹 앱을 만들려면 사용자가 상호 작용할 수 있는 웹 인터페이스(프론트엔드 또는 클라이언트)와 데이터 처리, 데이터 저장, ML/AI 모델 호출을 담당하는 서버(백엔드)가 필요합니다.\n\n<div class=\"content-ad\"></div>\n\n(스트림릿에 대해 들어본 적이 있을 수 있어요. 가장 간단한 데모에 적합하지만, 실제로 사용할 수 있는 제품 앱을 만들기에는 사용자 정의 가능성이 부족합니다)\n\n# 유튜브 웹 개발 튜토리얼의 위험성\n\n데이터 과학자로서 소프트웨어 개발의 여러 측면이 나를 불안하게 만듭니다. 망가진 구성에 몇 일을 소비할 위험을 맞이하는 것과 같은 것들이 그 중 하나에요. 무언가가 고장났는데 왜 고장났는지 알 수 없고 어떻게 고칠지 모르는 것보다 더 답답한 것은 없죠.\n\n결과적으로, React 프로젝트 설정, 백엔드 또는 웹사이트 배포 등 전체 프로세스를 세밀하게 보여주는 유튜브 같은 튜토리얼에 절박하게 의존하게 되었습니다.\n\n<div class=\"content-ad\"></div>\n\n돌아봤을 때, 두 가지 주요 단점이 있었어요:\n\n첫째, 여러 개의 상반된하고 잠재적으로 오래된 튜토리얼로 인한 혼란(예를 들어, 새로운 React 버전이 출시될 때). 이로 인해 종종 더 이상 동작하지 않음을 깨달을 때까지 튜토리얼을 따라가게 되었어요.\n\n둘째, 대부분의 튜토리얼은 초보자를 위한 멋진 수업 데모를 만드는 데 중점을 두고 있어요. 그래서 성능 상한선이 낮은 프레임워크를 사용하며 생산 및 확장성에 부족한 코딩 패턴을 강화하게 되죠. 고개를 돌아보니, YouTube 튜토리얼에서 나쁜 코딩 습관을 많이 털어놓는 모습을 보았어요. 그 습관들은 이제 앱을 수천 명의 사용자에게 제공하는 실제 제품으로 발전하는 데 방해가 되고 있죠.\n\n실패로부터 최고의 교훈을 얻는다고 생각해요. 이러한 프로세스는 짜증 나지만 전해 동안 저에게는 막대한 학습 경험이 되었어요. 아마 나의 실패로부터 배울 때 많은 시간을 절약하실 수 있을 거예요.\n\n<div class=\"content-ad\"></div>\n\n## 팁 #1: React 대신에 Next.js를 사용하세요\n\n![이미지](/assets/img/2024-06-19-FromDataScientisttoAIDeveloperLessonsBuildingaGenerativeAIWebAppin2023_3.png)\n\n많은 YouTube 튜토리얼들이 React를 선호하며, 처음에는 그에 따랐습니다.\n\n그러나 결국 사이트의 SEO(검색 엔진 최적화) 성능을 향상시키고 싶어졌습니다 — 이는 더 많은 사용자 획득에 매우 중요합니다. React의 한계인 메타 태그를 동적으로 변경할 수 없고 서버 측 렌더링이 없는 등의 제약은 귀찮은 작업을 요구하며, Next.js로 변경해야 했습니다. 변경 후에는 성능 차이가 확연히 날밤과 같았습니다.\n\n<div class=\"content-ad\"></div>\n\n![image](/assets/img/2024-06-19-FromDataScientisttoAIDeveloperLessonsBuildingaGenerativeAIWebAppin2023_4.png)\n\n어떤 사람들은 React가 초보자에게 더 친숙하다고 말하지만, Vercel(Next.js 개발자)의 예들을 들 수 있는 등 온라인에는 다양한 Next.js 템플릿이 많습니다. 특히 AI 애플리케이션에 대한 것이죠. Next.js는 실제로 거의 모든 AI 애플리케이션에서 사용되는 현대적인 웹 프레임워크입니다.\n\n## 팁 #2: 스타일링을 위해 부트스트랩 대신 Tailwind CSS를 선택하세요.\n\n프론트엔드 UI 여정을 시작할 때, 처음에는 다른 사람들의 튜토리얼을 따라 부트스트랩으로 향했습니다. 왜냐하면 드롭다운이나 아코디언 같은 준비된 컴포넌트로 쉽게 작업할 수 있다는 유혹이 있었기 때문이죠.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-19-FromDataScientisttoAIDeveloperLessonsBuildingaGenerativeAIWebAppin2023_5.png)\n\n하지만 잠시 후, 웹사이트가 매우 추려지고 현대적인 AI 데모 페이지와 비교했을 때 정말 추악해 보인다는 것을 깨달았어요. 그 부트스트랩 답은 느낌이 덜어져 있었는데, 그것은 수정이 어려운 일종의 미적 고집이었고, 혼동스럽게 명명된 CSS 클래스들에 뒤얽혀 있었어요. 그래서 결국, 다시 한번 용감을 내어 내 프론트 엔드 전체를 Tailwind CSS로 새롭게 만들기로 했죠. 3일이 걸렸어요.\n\n![이미지](/assets/img/2024-06-19-FromDataScientisttoAIDeveloperLessonsBuildingaGenerativeAIWebAppin2023_6.png)\n\n현대적이고 깔끔한 UI를 가진 AI 데모 페이지를 본 적이 있다면, 그들이 Tailwind CSS를 사용한 것일 확률이 매우 높아요.\n\n\n<div class=\"content-ad\"></div>\n\n\n![2024-06-19-FromDataScientisttoAIDeveloperLessonsBuildingaGenerativeAIWebAppin2023_7.png](/assets/img/2024-06-19-FromDataScientisttoAIDeveloperLessonsBuildingaGenerativeAIWebAppin2023_7.png)\n\n처음에는 Tailwind에 겁을 먹었어요. 그 긴 구성 요소 정의는 암호처럼 보이는 유틸리티 클래스들로 넘쳐나 초보자 친화적이지 않아 보였거든요. Tailwind에는 미리 구성된 구성 요소가 부족하고 유틸리티 클래스를 기억하는 것이 어려울 것으로 생각했어요. 그런데 이는 전혀 사실이 아니었어요! Tailwind CSS로 만들어진 많은 훌륭한 UI 컴포넌트 라이브러리가 있어요. 저는 Flowbite React를 사용했어요(필요한 모든 컴포넌트가 다 들어있어요!)\n\n# 데이터 과학 마인드셋의 함정\n\n데이터 과학을 공부하다 보니, 파이썬을 정말 좋아하게 되었어요. 파이썬의 간결하고 강력한 코드 구문이 매력적이었어요. 파이썬의 타입 추론 덕분에 모든 변수에 대해 타입을 정의하는 일에서 벗어날 수 있었어요(이 작업은 특히 자바 같은 기초 컴퓨터 과학 수업에서 만난 언어에서 어려운 작업이었어요).\n\n\n<div class=\"content-ad\"></div>\n\n그래서 프론트엔드에는 JavaScript를 사용하고 백엔드에는 Python을 사용하여 API 엔드포인트의 유형을 필수적인 경우가 아닌 한 정의하지 않았어요.\n\n그러나 어플리케이션이 복잡해지면서 프론트엔드와 백엔드 간 예상치 못한 다양한 유형 오류로 코딩 생산성이 떨어졌어요. CS 친구들이 명시적 유형의 중요성을 강조하는 이유를 이제야 이해하게 되었어요. 유형 정의에서의 세심함은 까다롭다는 것뿐만 아니라 필수적이라는 것을 깨달았답니다.\n\n## 꿀팁 #3: 백엔드로 Flask 대신 FastAPI를 선택하고 응답 모델을 엄격하게 정의하세요\n\nYouTube에서 파이썬 백엔드 튜토리얼을 검색하면 대부분의 비디오가 Flask를 지목할 것입니다. 하지만 망가진 시계가 하루에 두 번 맞는 것처럼, 나는 우연히도 FastAPI를 Python 백엔드로 선택했는데, 이는 분명히 올바른 결정이었던 것 같아요.\n\n<div class=\"content-ad\"></div>\n\n웃기게도, 나는 FastAPI의 혜택을 완전히 무시했었어요. 얼마 전까지만 해도 POST 요청을 위한 Pydantic 클래스를 정의하는 필요성을 이해하지 못하고 그것을 도움보다는 번거로운 일로 생각했었죠.\n\nFastAPI에는 몇 가지 혁신적인 장점이 있어요:\n\n- 자동 생성된 API 문서 — 이것은 향후 온보딩할 엔지니어들 (또는 미래의 여러분)이 백엔드 구조를 이해하는 데 매우 유용할 거예요!\n- 코드 작성이 쉬워짐 — FastAPI는 Json 스키마 위에 구축되어 있기 때문에 라우트를 정의하는 것이 Flask보다 훨씬 쉽고 간결해요 — 결과적으로, 저와 같은 초보자들에게도 학습 곡선이 더 낮아요\n- 성능이 더 좋음 — FastAPI는 Flask보다 훨씬 빠르다고 하며 더 적은 메모리를 소비한다고 해요 — 제 앱은 대량의 페이로드를 보내기 때문에 이는 멋진 거에요\n\n![이미지](/assets/img/2024-06-19-FromDataScientisttoAIDeveloperLessonsBuildingaGenerativeAIWebAppin2023_8.png)\n\n<div class=\"content-ad\"></div>\n\n하지만 가장 중요한 것은 FastAPI의 타입 어노테이션이에요!\n\n- FastAPI는 데이터 유효성 검사 라이브러리인 Pydantic 위에 구축되었어요. 이 라이브러리를 사용하면 속성이 있는 클래스로 데이터의 '형태'를 정의할 수 있어요.\n- FastAPI를 사용하면 각 API 경로의 입력 및 출력 타입을 Python 타입 힌트와 Pydantic으로 정의된 클래스를 사용하여 주석으로 달 수 있어요.\n\n이것은 각 경로의 출력이 일관된 데이터 구조를 갖도록 확인해줘요. 하지만 이 기능을 최대한 활용하려면...\n\n## 팁 #4: 자바스크립트 대신 TypeScript를 사용하세요\n\n<div class=\"content-ad\"></div>\n\n오랜 시간동안 저는 프론트엔드 페처 메소드를 수동으로 작성해 왔어요(또한 풀 스택 튜토리얼을 참고하여 배웠죠). 그래서 앱에 새로운 루트를 추가하는 것이 오랫동안 오류가 발생하기 쉬운 과정이었어요.\n\n그래서 저의 대규모 기술 업계 소프트웨어 엔지니어 친구가 API 사양을 사용하여 Typescript 클라이언트 코드를 자동 생성할 수 있다고 말할 때, 제가 깜짝 놀랐던 것을 상상할 수 있죠. (더 많은 FastAPI 문서는 여기를 참조하고, 이 중 하나인 openapi-typescript-codegen을 확인해보세요)\n\n한 순간에 이를 깨달았을 때, 이것이 두 가지 중요한 동시에 해결할 것을 알았어요: 수동 및 오류가 발생하기 쉬운 클라이언트 페처 코드 작성을 제거하고, 백엔드와 프론트엔드 간의 유형 일관성을 보장하기. 이렇게 함으로써 앱의 신뢰성을 저해하던 지속적인 유형 오류를 크게 줄였어요.\n\n<div class=\"content-ad\"></div>\n\n물론 백엔드 라우트에 대한 유형 제약 조건을 설정하는 것은 프론트엔드에서 해당 유형 제약 조건을 강제하는 것만큼 중요합니다. 이는 당연히 TypeScript를 필요로 합니다.\n\n그래서 저는 현재 FastAPI 백엔드에 대한 응답 모델을 정의하고 프론트엔드를 JavaScript에서 TypeScript로 변환하는 힘든 과정을 겪고 있어요. 시작부터 FastAPI와 TypeScript로 작업을 시작한다면 이런 과정을 피할 수 있어요!\n\n# 배포 관련...\n\n나의 데이터 과학 / 머신러닝 수업을 통해 구글 Colab를 사용하고 코드를 실행하는 것에 익숙해졌어요. 그래서 배포라는 생각만으로도 공포를 느끼게 되는건 이상하지 않아요. 그러나 Buildspace 가속기의 창립자가 말한 대로, 소프트웨어 앱을 전 세계에 액세스 가능하게 만들려면 “GTFOL” (Get The F Off Localhost)해야 합니다. 그래서 배포 과정이 가능한 쾌적하도록 하고 싶었죠.\n\n<div class=\"content-ad\"></div>\n\n## 팁 #5: GPU 백엔드에 모달 사용하기\n\n만약 여러분이 직접 모델 (예: 머신 러닝 모델, 이미지 인식, Whisper를 위한 필기 인식, 또는 최근에는 오픈 소스 LLMs인 Llama와 같은)을 배포하고 싶다면, 모델을 호스팅할 GPU 클라우드 제공업체가 필요할 것입니다.\n\n내 조언은 Modal을 선택하고 다시 뒤를 돌아보지 말라는 것입니다.\n\nModal은 최신 애플리케이션용 샘플 코드를 비롯한 최고의 문서 및 학습 자료가 갖춰져 있어요. 오픈 소스 LLMs를 세밀하게 조정해서 사용하거나, LLM 챗봇을 제공하는 것과 같은 다양한 응용 프로그램에 대한 최신 코드가 준비되어 있습니다.\n\n<div class=\"content-ad\"></div>\n\n전체 팟캐스트 전사 앱을 시작했을 때 Modal의 샘플 오디오 전사 코드를 포크하여 시작했어요. 그래서 Modal 없이는 내 앱을 만들지 못했다고 할 수 없을 정도로 중요한 역할을 했어요.\n\n![이미지](/assets/img/2024-06-19-FromDataScientisttoAIDeveloperLessonsBuildingaGenerativeAIWebAppin2023_10.png)\n\nModal은 사용자 친화성에서 빛을 발해요 (특히 배포를 싫어하는 사람으로서 그렇게 말하고 싶어요). 로컬 코드 편집기에서 클라우드 함수를 작성하고, 한 줄의 터미널 명령으로 배포할 수 있어요. 그 대시보드는 AWS와 비교했을 때 사용자 친화적이어서 앱 사용량을 추적하고 성능을 분석하고 오류를 쉽게 추적할 수 있어요.\n\n마지막으로 Modal은 Lambda가 갖고 있지 않거나 구현하기 귀찮은 기능에 대한 탈출구로 작용해요. 예를 들어 파일 저장 (다음 포인트에서 유용할 것…)과 스케줄링 함수 등에 대한 기능에 사용될 때 특히 유용해요.\n\n<div class=\"content-ad\"></div>\n\n## 팁 #6: 백엔드 배포에는 AWS Lambda, 프론트엔드에는 Vercel 사용하기\n\nPython 백엔드를 호스팅할 때, Amazon EC2 또는 AWS Lambda를 사용해야 하는지 헷갈렸어요. 제 앱은 오디오 파일을 저장해야 하는데 파일이 커질 수 있어서, Lambda의 서버리스 아키텍처는 파일을 저장할 목적으로 디자인되지 않았습니다(2GB의 일시적 저장소가 있지만 무지성이었고 지속적이지 않았습니다). 그래서 Amazon EC2를 사용해야 할 것이라고 생각했죠. 그러나 EC2는 설정이 더 복잡하고 항상 켜져 있는 전용 인스턴스이기 때문에 더 비실측하고 확장하기 어려웠어요.\n\n그런데 Modal의 무료 파일 저장소가 구조를 구성하기에 큰 도움이 되었고, Lambda와 호환되도록 백엔드를 구성하고 필요할 때 파일을 Modal에다 다운로드하고 저장할 수 있게 되었어요.\n\n다행히도, 이 영상은 정말 도움이 되었고, 그들의 지침을 딱 따라하면 백엔드를 성공적으로 배포할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n내 프론트엔드 작업에는 Vercel만으로도 충분했어요. 과정이 쉽고, 도메인 비용을 제외하고는 완전히 무료였어요.\n\n# 삶이 더 쉬워지는 방법\n\n개발 과정에서 막 애를 먹는 시간을 크게 절약할 수 있는 잡학지식 3가지 팁...\n\n## 팁 #7: React를 사용하여 자체 랜딩 페이지를 구축하지 마세요\n\n<div class=\"content-ad\"></div>\n\nFull-stack 튜토리얼들 때문에 내가 한 또 다른 실수를 해 버렸어. 리액트로 내 랜딩 페이지를 코드로 작성해야 한다고 속아서. 가능하긴 해 (그리고 나도 해 봤지만), 성능과 디자인 측면에서 한계가 있어. 정확히 성공적인 랜딩 페이지를 만들기 위해 필요한 중요한 특징들이야.\n\n릭트는 실제 AI 앱 인터페이스 같은 사용자 정의 기능에만 더 나아. 랜딩 페이지에는 정적 콘텐츠만 있는데, 대신 Webflow나 Framer 같은 노코드 사이트 빌더를 사용해 랜딩 페이지를 신속하게 만들어야 해 (그리고 랜딩 페이지 제작은 디자이너에게 아웃소싱해서 다른 작업에 집중할 수 있게 해야해!)\n\n## 팁 8: Firebase + Stripe로 사용자 인증과 결제 처리하기\n\n사용자 인증에 관해서는 다시 한 번 선택할 수 있는 옵션이 많아서 혼란스러울 수 있어. 나는 사용자 인증을 처리할 뿐만 아니라 사용자 가입 상태에 따라 액세스를 제어하기 위해 결제 시스템과 통합하는 솔루션이 필요했어.\n\n<div class=\"content-ad\"></div>\n\n수 일 동안 다양한 인증 솔루션을 시도하고 실패한 후에 auth0 등을 찾아 사용해보기도 했지만, Stripe + Firebase가 잘 작동한다는 것을 알게 되었습니다. Firebase에는 Stripe 통합이 있어 결제가 성공하면 사용자의 구독 상태를 업데이트하고, Firebase의 React 클라이언트는 클라이언트 측 인증, Python 클라이언트는 서버 액세스 제어를 잘 처리합니다. 두 개의 동영상(여기와 여기)을 따라하면 이를 앱에 성공적으로 구현할 수 있습니다.\n\n## Tip #9: 에러 모니터링을 위해 Sentry 구현하기\n\n몇 달 동안 제 앱을 사용하는 사용자가 만난 버그에 대해 전혀 모르고 있었습니다. 버그를 발견한 후에나 AWS Cloudwatch 인터페이스를 통해 백엔드 버그를 찾으려고 노력합니다.\n\n![이미지](/assets/img/2024-06-19-FromDataScientisttoAIDeveloperLessonsBuildingaGenerativeAIWebAppin2023_11.png)\n\n<div class=\"content-ad\"></div>\n\n내 공동 창업자가 클라우드 앱의 성능 모니터링과 오류 추적을 위한 도구인 Sentry를 소개해 줄 때까지 계속되었습니다. 프론트엔드와 백엔드를 위해 초기화하기 정말 쉽고, Slack과 통합하여 즉시 오류 알림을 받을 수도 있어요. 그저 인증 시간 초과와 같은 사소하지만 빈번한 오류로 무료 플랜의 월별 오류 예산을 소진하지 않도록 주의하세요. 그것이 제게 일어난 일이었죠 — 그래서 중요한 버그에 대한 로그를 찾고 싶어졌을 때 유료 플랜을 구독해야 했습니다.\n\n보너스 팁 #10: Spotify의 API를 사용하여 웹 앱을 만들려고 시도하지 마세요! Spotify의 API를 통합하여 사용자가 저장된 팟캐스트를 로드할 수 있다고 가정하고 2개월 동안 제 앱을 낭비했어요. 하지만 이를 제품화하려면 할당량 확장 요청을 신청해야 하는데, Spotify가 검토하는 데 한 달 이상 소요됩니다. 그리고 당신의 앱이 AI/ML 모델을 포함하고 있다면 신청이 거의 거부될 가능성이 높아요 (제 앱이 실제로 Spotify 데이터를 활용하여 어떠한 모델을 훈련시키지 않았음에도 불구하고, 그러한 용어가 개발자 정책에서 금지되어 있기 때문입니다).\n\n# 결론\n\n이 기술 가이드가 데이터과학 애호가들을 위한 웹 앱 개발의 일부 측면을 명확하게 해주길 바랍니다.\n\n<div class=\"content-ad\"></div>\n\n만약 이 게시물이 도움이 된다면:\n\n- 다른 제 미디엄 기사도 확인해보세요: AI를 사용해 긴 텍스트를 요약하는 방법, 딥 러닝을 사용해 음악을 생성하는 방법\n- 제 어플을 사용해보세요 — Podsmart은 팟캐스트와 유튜브 영상의 필기본문과 요약을 제공하여 바쁜 지식인들에게 듣기 시간을 절약해줍니다\n- LinkedIn이나 Twitter/X로 제 팔로우를 하고, 메시지나 댓글로 연락해주세요! 데이터 과학과 AI에 관한 모든 아이디어를 공유해보고 싶어합니다\n\n읽어주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-06-19-FromDataScientisttoAIDeveloperLessonsBuildingaGenerativeAIWebAppin2023_0.png"},"coverImage":"/assets/img/2024-06-19-FromDataScientisttoAIDeveloperLessonsBuildingaGenerativeAIWebAppin2023_0.png","tag":["Tech"],"readingTime":12},{"title":"Azure CosmosDB, 중복 검증 스트레로이드 버전","description":"","date":"2024-06-19 14:45","slug":"2024-06-19-AzureCosmosDBZodDataValidationonSteroids","content":"\n\n\n![Azure CosmosDB](/assets/img/2024-06-19-AzureCosmosDBZodDataValidationonSteroids_0.png)\n\n데이터베이스 보호 및 Azure 요금 절감\n\nAzure CosmosDB는 다른 NoSQL 데이터베이스들처럼 훌륭합니다. 빠르고 신뢰할 수 있으며 매우 유연합니다.\n\n그러나 자유는 언제나 대가가 따릅니다. 완전히 스키마 없는 데이터베이스의 경우, 데이터베이스에 들어가는 내용과 데이터를 검색하는 방법에 대해 계산된 결정을 내리게 됩니다. 개발자인 우리에게 책임이 떨어집니다.\n\n\n<div class=\"content-ad\"></div>\n\n가장 흔한 사용 사례 중 하나는 ID별로 레코드/항목을 찾는 것입니다.\n\n이게 얼마나 중요한가요?\n\n그냥 SELECT * FROM c WHERE c.id = \"some-id\" 를 사용하면 될 일이 아닙니까?\n\n또는 Azure CosmosDB SDK를 사용하여 간단히 이렇게 할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nawait container.item(\"some-id\", \"some-id\").read();\n```\n\n둘 다 맞아요.\n\n하지만 처음부터 데이터베이스와 통신할 필요가 없는 경우도 있습니다. 예를 들어:\n\n- ID 입력이 정의되지 않은 경우\n- ID 입력이 null 인 경우\n- ID 입력이 빈 문자열인 경우: \"\"\n- ID 입력에 공백 문자가 포함된 경우: \" some-id\", \"some -id\", 또는 \"some-id\"는 모두 CosmosDB가 허용하지 않는 잘못된 ID입니다.\n- 특별한 사용 사례: ID 입력이 이미 데이터베이스에 적용한 사용자 지정 ID 형식을 준수하지 않는 경우. 예: 모든 ID는 USER-xxx-xxxx-xxxx 등의 형식을 따라야 합니다.\n\n<div class=\"content-ad\"></div>\n\n이 문제를 해결하기 위해 2가지 방법이 있습니다:\n\n- 사용자 정의 함수 작성\n- 스키마 유효성 검사 도구 사용 (예: zod, yup, valibot, typia 등)\n\n두 가지 모두 API로 들어오는 데이터를 어떤 형식으로든 수동으로 유효성을 검사해야 합니다.\n\n방법 1: 사용자 정의 함수 작성\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { ResultAsync, err, ok } from 'neverthrow';\nimport { CosmosClient } from '@azure/cosmos';\n\n// CosmosDB 연결 초기화\nconst endpoint = `데이터베이스_엔드포인트`;\nconst key = `데이터베이스_키`;\nconst client = new CosmosClient({ endpoint, key });\n\n// 작업을 수행할 \"컨테이너\" 설정\nconst container = client.database(`데이터베이스_이름`).container(`컨테이너_이름`);\n\nexport type Post = {\n  id: string;\n  // 다른 속성들\n};\n\nexport const findOnePost = async (\n  id: string,\n): Promise<ResultAsync<Post, Error>> => {\n  // 입력 유효성 검사 - 매우 수동적\n  if (id === undefined || id === null) {\n    return err(new Error(`ID는 정의되거나 null일 수 없습니다`));\n  }\n  if (id === ``) {\n    return err(new Error(`ID는 빈 문자열일 수 없습니다`));\n  }\n  if (id.includes(` `)) {\n    return err(new Error(`ID에는 공백 문자가 포함될 수 없습니다`));\n  }\n  // ... ID가 규격을 준수해야하는 다른 규칙들\n\n  // 데이터베이스 호출\n  const result = await fromPromise(\n    await container.item<Post>(id, id).read(),\n    (e) => e,\n  );\n  if (result.isErr()) {\n    return err(new Error(`데이터베이스에서 항목을 검색하는 데 실패했습니다. 오류 코드: ${result.error['code']}`));\n  }\n\n  // 선택 사항: 데이터베이스에서 검색된 데이터 유효성 검사\n\n  // 게시물 데이터 반환\n  return ok<Post>(result.value.resource);\n};\n```\n\n접근 방법 2: 스키마 유효성 검사 도구(Zod) 사용\n\n```js\nimport { z } from 'zod';\nimport { fromError } from 'zod-validation-error';\nimport { ResultAsync, err, ok } from 'neverthrow';\nimport { CosmosClient } from '@azure/cosmos';\n\n// CosmosDB 연결 초기화\nconst endpoint = `데이터베이스_엔드포인트`;\nconst key = `데이터베이스_키`;\nconst client = new CosmosClient({ endpoint, key });\n\n// 작업을 수행할 \"컨테이너\" 설정\nconst container = client.database(`데이터베이스_이름`).container(`컨테이너_이름`);\n\n// ID 스키마\nconst IdSchema = z\n  .string()\n  .min(8)\n  .refine((value) => {\n    return !value.includes(` `);\n  }, `ID에 공백 문자를 포함할 수 없습니다`)\n  .describe(\n    `입력을 문자열로, 적어도 8자 이상이어야하며 공백 문자를 포함해서는 안됩니다`,\n  );\n\nexport type Post = {\n  id: string;\n  // 다른 속성들\n};\n\nexport const findOnePost = async (\n  id: string,\n): Promise<ResultAsync<Post, Error>> => {\n  // 입력 유효성 검사 - zod 사용\n  const validateInput = IdSchema.safeParse(id);\n  if (!validateInput.success) {\n    const { message } = fromError(validateInput.error);\n    return err(new Error(message));\n  }\n\n  // 데이터베이스 호출\n  const result = await fromPromise(\n    await container.item<Post>(id, id).read(),\n    (e) => e,\n  );\n  if (result.isErr()) {\n    return err(new Error(`데이터베이스에서 항목을 검색하는 데 실패했습니다. 오류 코드: ${result.error['code']}`));\n  }\n\n  // 선택 사항: 데이터베이스에서 검색된 데이터 유효성 검사\n\n  // 게시물 데이터 반환\n  return ok<Post>(result.value.resource);\n};\n```\n\n두 가지 접근 방법이 모두 작동함을 확인할 수 있습니다. 둘 다 Azure CosmosDB 호출 전에 ID 입력의 유효성을 검사합니다.\n\n\n<div class=\"content-ad\"></div>\n\n만약 더 많은 코드를 작성하거나 앱이 매우 작다거나 새로운 npm 패키지를 추가하고 싶지 않다면 첫 번째 방법을 사용하세요.\n\n더 적은 코드를 작성하고 코드베이스의 여러 곳에 동일한 유효성을 적용하려면 두 번째 방법을 사용하세요.\n\n그러나 주요 아이디어는 데이터베이스에 여행을 하기 전에 ID가 유효한지 확인해야 한다는 것입니다.\n\n아래 다이어그램에서는 주황색으로 둘러싸인 부분을 추가하는 중입니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Azure CosmosDB Zod Data Validation on Steroids](/assets/img/2024-06-19-AzureCosmosDBZodDataValidationonSteroids_1.png)\n\n데이터베이스를 요청하지 않으면 매우 사소한 것처럼 보일 수 있지만, 모든 달러가 중요합니다. Azure CosmosDB를 쿼리하는 시기, 방법 및 빈도를 신중히 다루면 큰 Azure 송장에서 자신을 보호할 수 있습니다.\n\n생각을 공유하고 댓글을 달아주세요!\n","ogImage":{"url":"/assets/img/2024-06-19-AzureCosmosDBZodDataValidationonSteroids_0.png"},"coverImage":"/assets/img/2024-06-19-AzureCosmosDBZodDataValidationonSteroids_0.png","tag":["Tech"],"readingTime":5},{"title":"엘로퀀트 깊숙한 학습 라라벨 개발자가 반드시 알아야 할 40가지 잘 사용되지 않는 엘로퀀트 ORM 메서드","description":"","date":"2024-06-19 14:42","slug":"2024-06-19-DeepDiveintoEloquent40RarelyUsedEloquentORMMethodsEveryLaravelDeveloperMUSTKnow","content":"\n\n<img src=\"/assets/img/2024-06-19-DeepDiveintoEloquent40RarelyUsedEloquentORMMethodsEveryLaravelDeveloperMUSTKnow_0.png\" />\n\n안녕하세요! 엘로퀀트에 대해 얼마나 잘 아시나요?\n\n라라벨의 엘로퀀트 ORM은 매우 강력한 도구로, 표현력이 풍부하고 우아한 구문을 사용하여 데이터베이스와 상호 작용할 수 있는 기능을 제공합니다. 많은 개발자들이 find(), where(), first(), get(), save()와 같은 일반적인 메서드를 잘 알고 있지만, 워크플로우를 크게 향상시킬 수 있는 몇 가지 잘 알려지지 않은 메서드들이 있습니다. 이 글에서는 이러한 잘 알려지지 않지만 매우 유용한 엘로퀀트 ORM 메서드 중 일부를 살펴보겠습니다.\n\n일반적인 메서드부터 시작해서 가장 좋은 메서드로 이동해보겠습니다. 여러분은 응용 프로그램의 속도와 효율성을 실제로 향상시킬 수 있는 많은 아름다운 메서드를 보게 될 것입니다. 함께 알아보도록 하죠.\n\n<div class=\"content-ad\"></div>\n\n# 1. tap()\n\n왜: 모델에 변경사항을 적용하고 메서드 체이닝을 위해 모델 자체를 반환합니다.\n\n언제: 객체를 수정하고 즉시 다른 작업에 사용하고 싶을 때 사용하세요.\n\n```js\nUser::find(1)->tap(function ($user) {\n    $user->name = 'Updated Name';\n})->save();\n```\n\n<div class=\"content-ad\"></div>\n\n# 2. firstOrFail()\n\n왜: 유효한 결과를 얻거나 결과가 없는 경우를 처리하기 위해 사용합니다.\n\n언제: 특정 레코드를 가져 와서 존재하지 않는 경우에 오류를 throw하고 싶을 때 사용합니다.\n\n```js\n$user = User::where('email', 'example@example.com')->firstOrFail();\n// 사용자 세부 정보 처리\n```\n\n<div class=\"content-ad\"></div>\n\n# 3. updateOrCreate()\n\n왜: 기존 레코드를 업데이트하거나 새로운 레코드를 생성하여 중복 항목을 방지하기 위해서입니다.\n\n언제: 레코드가 존재하지 않으면 생성되고, 존재한다면 업데이트되도록 하고 싶을 때 사용합니다.\n\n```js\nUser::updateOrCreate(\n    ['email' => 'example@example.com'],\n    ['name' => 'John Doe']\n);\n```\n\n<div class=\"content-ad\"></div>\n\n# 4. increment() / decrement()\n\n이 부분을 정말 좋아해요. 직관적이고 아름다워요. 언제 사용하나요?\n언제 사용: 숫자 열을 하나 이상 증가시키거나 감소시킬 때 사용합니다.\n\n왜 사용하나요: 숫자 열의 값을 효율적으로 업데이트하기 위해.\n\n```js\nUser::where('id', 1)->increment('points'); // 만약 points가 7이면 이제 8이 될 것입니다\nUser::where('id', 1)->decrement('points', 5); // 만약 7이면 2가 될 것입니다\n```\n\n<div class=\"content-ad\"></div>\n\n# 5. withTrashed() / onlyTrashed() / restore()\n\n이 그룹의 메소드들은 라라벨에서 Soft Deletes 기능을 관리하는 데 사용됩니다.\n나는 Soft Deletes에 관한 모든 것을 다룬 매우 상세한 기사를 썼어.\n\n왜: Soft 삭제된 레코드를 관리하기 위해.\n언제: 이러한 메소드를 사용하여 Soft 삭제된 레코드를 포함하거나 오직 포함하거나 되찾을 때.\n\n\n```js\n$users = User::withTrashed()->get();\n$trashedUsers = User::onlyTrashed()->get();\nUser::withTrashed()->where('id', 1)->restore();\n```\n\n<div class=\"content-ad\"></div>\n\n# 6. withoutEvents()\n\n왜: 이벤트 리스너가 작동하는 것을 방지합니다.\n언제: 일괄 가져오기와 같이 이벤트를 발생시키지 않아야 하는 작업을 수행할 때 사용합니다.\n\n외부 시스템에서 대량의 사용자를 가져오고 각 가져온 사용자에 대해 UserCreated 이벤트를 트리거하고 싶지 않아서 환영 이메일을 보내거나 생성마다 로깅하는 것을 피하려고 한다고 상상해보세요.\n\n```js\nUser::withoutEvents(function () {\n    User::create([\n      'name' => 'John Doe', \n      'email' => 'john@example.com'\n    ]);\n    User::create([\n      'name' => 'Jane Doe', \n      'email' => 'jane@example.com'\n    ]);\n});\n```\n\n<div class=\"content-ad\"></div>\n\n# 7. withoutGlobalScopes()\n\n**왜 사용하나요:** 전역 쿼리 제약을 우회하기 위해 사용합니다.\n**언제 사용하나요:** is_published와 같은 전역 스코프를 무시하고 모든 레코드를 가져와야 할 때 사용합니다.\n\n당신의 애플리케이션에는 발행된 게시물만 포함하는 전역 스코프를 가진 Post 모델이 있는 상황을 상상해보세요. 관리자는 컨텐츠를 효율적으로 관리하기 위해 초안 및 미게시된 게시물을 포함한 모든 게시물을 볼 수도 있어야 할 것입니다.\n\n전역 스코프를 무시하고 모든 게시물을 가져오기:\n\n<div class=\"content-ad\"></div>\n\n```js\n$allPosts = Post::withoutGlobalScopes()->get();\nforeach ($allPosts as $post) {\n    echo $post->title . ($post->is_published ? ' (Published)' : ' (Draft)') . \"\\n\";\n}\n```\n\n위 예시에서 withoutGlobalScopes()를 사용하면 관리자가 미게시된 포스트를 필터링하는 전역 범위를 우회하여 모든 포스트를 볼 수 있습니다.\n\nwithoutGlobalScopes()를 사용하는 것은 데이터에 대한 종합적인 액세스가 필요한 관리 작업이나 글로벌 제약 조건이 쿼리에 영향을 미치지 않도록 디버깅 및 테스트 중에 특히 유용합니다.\n\n# 10. is() / isNot()\n\n<div class=\"content-ad\"></div>\n\n이것도 좋아요. 비교와 조건을 확인할 때 매우 간편하고 유용합니다.\n\n왜 필요한가: 두 모델 인스턴스를 비교하기 위해.\n언제 사용하는가: 두 모델이 동일한 인스턴스인지 확인할 때 사용합니다.\n\n```js\n$user1 = User::find(1);\n$user2 = User::find(2);\n\nif ($user1->is($user2)) {\n    // 동일한 사용자\n}\n\nif ($user1->isNot($user2)) {\n    // 동일한 사용자가 아님\n}\n```\n\n# 11. loadMissing()\n\n<div class=\"content-ad\"></div>\n\n예시: User 모델이 있는데 그 모델은 게시물(posts) 관계를 갖고 있습니다. 사용자와 그들의 게시물을 함께 로드하고 싶지만, 게시물 관계가 이미 로드되었는지 확실하지 않을 때가 있습니다.\n\n왜: 이미 로드되지 않은 관계를 조건부로 eager load하여 데이터베이스 쿼리를 최적화하고 N+1 쿼리 문제를 피하기 위해서입니다.\n\n언제: loadMissing()을 사용할 때는 모델 인스턴스에 관계를 로드하고 싶지만 이미 로드되어 있지 않은 경우에만 사용합니다. 특히 특정 조건에 따라 동적으로 로드하고 싶은 조건부 관계 또는 이미 로드된 것들이 섞인 루프에서 관계를 로드할 때 유용합니다.\n\n```js\n$user = User::find(1);\n\n// 'posts' 관계가 이미 로드되었는지 확인\nif (!$user->relationLoaded('posts')) {\n    // 'posts' 관계는 이미 로드되어 있지 않다면 로드\n    $user->loadMissing('posts');\n}\n\n// 이제 중복 쿼리 걱정 없이 'posts' 관계에 접근할 수 있습니다\nforeach ($user->posts as $post) {\n    echo $post->title . \"\\n\";\n}\n```\n\n<div class=\"content-ad\"></div>\n\n# 12. makeHidden() / makeVisible()\n\n왜: 모델 속성의 가시성을 제어하기 위해서입니다.\n언제: 임시로 속성을 숨기거나 보여줄 때 사용합니다. 예를 들어 API 응답에서 사용합니다.\n\n```js\n$user = User::find(1);\n$user->makeHidden('email');\n$user->makeVisible('email');\n```\n\n# 13. touch()\n\n<div class=\"content-ad\"></div>\n\n왜: updated_at 타임스탬프를 업데이트하려고.\n언제: 다른 속성을 변경하지 않고 레코드를 업데이트된 것으로 표시하려면 사용하세요.\n\n```js\n$user = User::find(1);\n$user->touch();\n```\n\n# 14. append()\n\n왜: 모델의 배열이나 JSON 형식에 사용자 정의 속성을 추가하려고.\n언제: 모델의 표현에 추가적인 계산된 속성을 포함하고 싶을 때 사용하세요.\n\n<div class=\"content-ad\"></div>\n\n```php\n$user = User::find(1);\n$user->append('custom_attribute');\n```\n\n안녕하세요! Laravel에서 Json 데이터를 관리하는 방법에 대한 매우 포괄적이고 단계별 자습서를 작성했습니다.\n\n# 15. replicate()\n\n왜: 모델 인스턴스를 복제하기 위함.\n언제: 템플릿을 복제하는 것과 같이 동일한 속성을 가진 새 인스턴스를 생성할 때 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n```php\n$user = User::find(1);\n$newUser = $user->replicate(); // $newUser is matches to $user\n$newUser->save();\n```\n\n## 16. chunkById()\n\n테이블에 20,000,000개의 레코드가 있는 상황을 상상해보세요. 각 레코드에 대해 작업을 수행해야합니다. 이를 어떻게 해야 할까요?\n\n왜: 대규모 데이터 세트를 효율적으로 처리하는 데 사용합니다.\n언제: 대규모 데이터 세트를 처리하여 메모리를 효율적으로 처리하고 대형 테이블에서 더 나은 성능을 얻을 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n특정 작업을 수행해야 하는 20,000,000개 레코드가 있는 데이터베이스 테이블이 있다고 가정해보세요.\n\n```js\nuse App\\Models\\YourModel;\n\nYourModel::orderBy('id')->chunkById(1000, function ($records) {\n    foreach ($records as $record) {\n        // 각 레코드 처리\n    }\n});\n```\n\n참고: chunk()라는 유사한 메소드가 있습니다. 이러한 두 메소드는 유사한 작업을 수행하지만 차이점이 있습니다. 두 가지 모두 대규모 데이터셋을 효율적으로 일괄 처리하여 메모리 과부하를 방지하고 성능을 최적화합니다. 두 메소드는 한 번에 전체 데이터셋을 한꺼번에 메모리로 로드하지 않고 대규모 데이터셋을 이터레이션할 수 있도록 허용합니다. 그러나 데이터 배치를 결정하는 방식에서 차이가 있습니다:\n\nchunk():\n\n<div class=\"content-ad\"></div>\n\n- chunk()은 첫 번째 매개변수로 지정된 청크 당 레코드 수에 따라 데이터 세트를 청크로 나눕니다.\n- 특정한 순서를 고려하지 않고 데이터베이스 테이블에서 레코드를 순차적으로 검색합니다.\n- 각 청크의 레코드는 데이터베이스에서 검색된 순서에 기반하여 가져오며, 주로 기본 키 순서에 따라 순서가 지정되지 않을 수 있습니다.\n- 처리 순서가 중요하지 않거나 데이터를 작은 관리 가능한 청크로 처리해야 할 때이 유용한 방법입니다.\n\nchunkById():\n\n- chunkById()는 레코드의 기본 키(일반적으로 id) 순서를 기반으로 데이터 세트를 청크로 나눕니다.\n- 데이터베이스 테이블에서 레코드를 기본 키 순서에 따라 순차적으로 검색합니다.\n- 각 청크에는 지정된 범위 내의 기본 키를 갖고 있는 레코드가 포함되어, 레코드가 기본 키 순서로 처리되도록 보장합니다.\n- 데이터 마이그레이션이나 기본 키 순서를 기반으로 순차 처리가 필요한 데이터 업데이트와 같은 작업을 수행할 때 유용한 방법입니다.\n\n# 17. existsOr()\n\n<div class=\"content-ad\"></div>\n\n**왜**: 모델이 존재하는 경우 콜백을 실행하거나 기본값을 반환합니다.  \n**언제**: 사용자 정의 로직으로 존재 여부를 처리해야 할 때 사용합니다.\n\n```js\n$exists = User::where('email', 'example@example.com')->existsOr(function () {\n    return 'User does not exist';\n});\n```\n\n# 18. firstOrCreate()\n\n**왜**: 단계를 한 번에 기록을 검색하거나 생성하기 위해 사용합니다.  \n**언제**: 필요한 경우 레코드를 업데이트하거나 생성하여 중복된 항목을 피하기 위해 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n$user = User::firstOrCreate(['email' => 'example@example.com'], ['name' => 'John Doe']);\n```\n\n# 19. firstOrNew()\n\n왜: 저장하지 않고 기존 레코드를 검색하거나 새 레코드를 만들기 위해 사용합니다.\n언제: 기존 레코드를 가져 오거나 영구적으로 저장하지 않고 새 인스턴스를 만들기 위해 사용합니다.\n\n```js\n$user = User::firstOrNew(['email' => 'example@example.com'], ['name' => 'John Doe']);\n```  \n\n<div class=\"content-ad\"></div>\n\n# 20. `sole()`\n\n왜: 하나의 레코드만 가져오거나 예외를 발생시키기 위해 사용합니다.\n언제 사용: 단일하고 고유한 결과를 예상하고 중복을 오류로 처리하고 싶은 경우에 사용합니다.\n\n```js\n$user = User::where('email', 'example@example.com')->sole();\n```\n\n# 21. `findMany()`\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 Markdown 형식으로 변경하세요.\n\n\nWhy: 여러 개의 기본 키로 레코드를 검색하기 위해 사용합니다. \nWhen: 여러 개의 ID가 포함된 배열을 사용하여 한 번에 여러 레코드를 가져오는 데 사용합니다.\n\n```js\n$users = User::findMany([1, 2, 3]);\n```\n\n## 22. update()\n\nWhy: 한 번에 여러 레코드를 업데이트하기 위해 사용합니다.\nWhen: 대량 업데이트를 효율적으로 수행하기 위해 사용합니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\nUser::where('status', 'active')->update(['status' => 'inactive']);\n```\n\n# 23. forceDelete()\n\nWhy: 소프트 삭제된 모델을 영구적으로 삭제하려면 사용하세요.\nWhen: 레코드를 완전히 제거하여 소프트 삭제를 우회할 때 사용하세요.\n\n```js\n$user = User::withTrashed()->find(1);\n$user->forceDelete();\n```\n\n<div class=\"content-ad\"></div>\n\n# 24. getDirty()\n\n이 함수 정말 좋아요. 이 함수를 사용하면 데이터베이스에 저장되기 전 모델에서 변경된 모든 내용을 알 수 있어요.\n\n왜: 변경된 속성들을 확인하려고요.\n언제: 저장하기 전에 수정된 속성들을 확인할 때 사용하세요.\n\n```js\n$user = User::find(1);\n$user->name = '새로운 이름';\n$dirty = $user->getDirty();\n```\n\n<div class=\"content-ad\"></div>\n\n# 25. getOriginal()\n\n왜: 모델 속성의 원래 값 가져오기 위해 사용합니다.\n언제: 변경 전 현재 값과 원래 값 비교할 때 사용합니다.\n\n```js\n$user = User::find(1);\n$original = $user->getOriginal('name');\n```\n\n# 26. setRelation()\n\n<div class=\"content-ad\"></div>\n\n왜: 모델에 특정 관계를 설정하기 위해 사용합니다.\n언제: 모델 인스턴스에 수동으로 관계를 정의할 때 사용합니다.\n\n```js\n$user = User::find(1);\n$user->setRelation('posts', $posts);\n```\n\n# 27. without()\n\n왜: 쿼리에서 특정 관계를 제외하기 위해 사용합니다.\n언제: 불필요한 관계를 제외하여 쿼리를 최적화할 때 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n```javascript\n$user = User::with('posts', 'comments')->without('comments')->find(1);\n```\n\n## 28. preventLazyLoading()\n\n왜: 관계의 게으른 로딩을 방지합니다.\n언제: 개발 중에 의도하지 않은 게으른 로딩을 방지하려면 사용하세요.\n\n```javascript\nModel::preventLazyLoading(!app()->isProduction());\n```\n\n<div class=\"content-ad\"></div>\n\n# 29. withoutTimestamps()\n\n왜: created_at 및 updated_at 타임스탬프의 업데이트를 비활성화합니다.\n언제: 가져오기와 같이 타임스탬프 업데이트를 트리거해서는 안 되는 작업에 사용합니다.\n\n```js\nUser::withoutTimestamps(function () {\n    User::create(['name' => 'John Doe']);\n});\n```\n\n# 30. withCasts()\n\n<div class=\"content-ad\"></div>\n\n라라벨은 모델 속성에 동적으로 캐스팅 규칙을 적용할 수 있습니다. 특정 조건이나 런타임 시나리오에 따라 속성을 어떻게 캐스팅할지 실시간으로 변경할 필요가 있을 때 유용합니다. 예를 들어 사용자 입력이나 데이터베이스 값에 따라 속성을 다른 유형으로 캐스팅할 수 있어 데이터 일관성과 애플리케이션의 유연성을 보장할 수 있습니다.\n\n왜: 캐스팅 규칙을 동적으로 적용하기 위해.\n언제: 속성을 실시간으로 어떻게 캐스팅할지 변경할 때.\n\n```js\n$user = User::withCasts(['is_admin' => 'boolean'])->find(1);\n```\n\n# 31. upsert()\n\n<div class=\"content-ad\"></div>\n\n왜: 일치하는 기준에 따라 레코드를 삽입하거나 업데이트하기 위해서입니다.\n언제: 대량 삽입 또는 업데이트를 수행하여 중복 항목을 피하기 위해 사용합니다.\n\n고유 식별자로 이메일 열을 갖는 사용자 테이블이 있다고 가정해보세요. 해당 테이블에 이메일이 이미 존재하지 않는 경우 새 사용자를 삽입하거나 이미 존재하는 경우 이메일에 해당하는 이름을 업데이트하려고 합니다.\n\n```js\nuse App\\Models\\User;\n\nUser::upsert([\n    ['email' => 'john@example.com', 'name' => 'John Doe'],\n    ['email' => 'jane@example.com', 'name' => 'Jane Doe']\n], ['email'], ['name']);\n```\n\n# 32. 스코프\n\n<div class=\"content-ad\"></div>\n\n왜: 재사용 가능한 쿼리 스코프를 정의하는 데 사용합니다.\n언제: 여러 쿼리에 일반적인 쿼리 제약을 적용하는 데 사용합니다.\n\n```js\n// 사용자 모델에서\npublic function scopeActive($query)\n{\n    return $query->where('status', 'active');\n}\n\n// 사용 방법\n$activeUsers = User::active()->get();\n```\n\n# 33. macro()\n\n이 메소드를 너무 좋아합니다. 원하는대로 사용자 정의한 고유한 메소드를 생성하는 데 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n왜: Eloquent 쿼리 빌더에 사용자 정의 메서드를 정의하기 위해.\n언제: 쿼리 빌더를 확장하여 자체 메서드를 추가하는 데 사용됩니다.\n\n당신의 응용 프로그램에서 사용자의 역할에 따라 사용자를 필터링해야 하는 경우가 자주 있습니다. 이 작업을 간단히 하기 위해 쿼리 빌더에 role()이라는 사용자 지정 매크로를 정의할 수 있습니다.\n\n```js\nuse Illuminate\\Database\\Eloquent\\Builder;\n\n// 'role' 매크로 정의\nBuilder::macro('role', function ($role) {\n    return $this->where('role', $role);\n});\n\n// 사용 예\n$admins = User::role('admin')->get();\n$customers = User::role('customer')->get();\n```\n\n# 34. filter()\n\n<div class=\"content-ad\"></div>\n\n**왜**: 동적 쿼리 필터를 적용하기 위해 사용합니다.\n**언제**: 요청 매개변수를 기반으로 여러 필터를 적용하기 위해 사용하세요.\n\n```js\n// 사용자 모델 내부에서\npublic function scopeFilter($query, $filters)\n{\n    return $filters->apply($query);\n}\n\n// 사용법\n$filters = new UserFilters(['status' => 'active']);\n$filteredUsers = User::filter($filters)->get();\n```\n\n이 예제에서는 User 모델에 filter() scope를 정의하여 필터 세트를 전달 받습니다. 이러한 필터는 UserFilters 객체의 apply() 메서드를 사용하여 쿼리에 적용될 수 있습니다. 이를 통해 $filters 변수에 지정된 다양한 기준에 따라 사용자를 동적으로 필터링할 수 있습니다.\n\nfilter()를 사용하면 데이터베이스 쿼리를 변화하는 요구 사항과 사용자 입력에 더 적응 가능하게 만들어 Laravel 애플리케이션에서 더 유연하고 동적인 데이터 검색이 가능해집니다.\n\n<div class=\"content-ad\"></div>\n\n# 35. whereJsonContains()\n\n왜: 특정 값을 가진 JSON 열을 조회하기 위해 사용합니다.\n언제: 배열 또는 객체를 포함하는 JSON 열을 조회할 때 사용합니다.\n\n```js\n$users = User::whereJsonContains('options->languages', 'en')->get();\n```\n\n라라벨에서 JSON에 관한 모든 것에 대한 문서가 있습니다. 이 곳을 확인해보세요.\n\n<div class=\"content-ad\"></div>\n\n# 36. findOr()\n\n왜: 모델을 검색하거나 찾을 수 없을 때 콜백을 실행하는 데 사용합니다.\n언제: 레코드가 없을 때 사용자 정의 로직을 처리할 때 사용하세요.\n\n```js\n$user = User::findOr(1, function () {\n    return '사용자를 찾을 수 없습니다';\n});\n```\n\n# 37. lockForUpdate()\n\n<div class=\"content-ad\"></div>\n\nLaravel의 Eloquent ORM에 있는 lockForUpdate() 메서드는 트랜잭션 내에서 데이터베이스 행을 업데이트하기 위해 잠그는 데 사용됩니다. 이 메서드를 쿼리에 적용하면 현재 트랜잭션이 완료될 때까지 선택된 행을 수정하는 다른 데이터베이스 트랜잭션이 방지됩니다. 이를 통해 데이터 일관성을 유지하고 여러 트랜잭션이 동시에 같은 행을 업데이트하려고 할 때 충돌을 방지합니다.\n\n왜: 쿼리에 \"for update\" 잠금을 적용합니다.\n언제: 여러 트랜잭션이 귀하의 트랜잭션 중에 행을 수정하는 것을 방지할 때 사용합니다.\n\n```js\n$user = User::where('email', 'example@example.com')->lockForUpdate()->first();\n```\n\n# 38. sharedLock()\n\n<div class=\"content-ad\"></div>\n\n왜: 쿼리에 \"공유 락\"을 적용하려면\n언제: 트랜잭션 기간 동안 선택한 행을 잠그는 데 사용합니다.\n\n금융 애플리케이션이 있다고 가정해보겠습니다. 사용자가 계정 잔액을 볼 수 있는 애플리케이션입니다. 사용자가 잔액을 확인할 때, 다른 트랜잭션이 동시에 계정 잔액을 업데이트하더라도 표시된 금액이 일관되게 유지되도록 보장하고 싶습니다. 이러한 경우에는 트랜잭션 중 사용자 계정에 해당하는 행을 잠글 때 sharedLock()을 사용할 수 있습니다. \n\n```js\nuse App\\Models\\Account;\n\nDB::transaction(function () use ($userId) {\n    $account = Account::where('user_id', $userId)->sharedLock()->first();\n    // 사용자의 계정 잔액 표시\n});\n```\n\n# 39. withSum()\n\n<div class=\"content-ad\"></div>\n\n왜: 관련 모델 속성의 합계를 결과에 추가하려고 합니다.\n언제: 주문 총액을 합산하는 등 관련 모델에서 데이터를 집계해야 할 때 사용합니다.\n\n```js\n$users = User::withSum('posts', 'views')->get(); // 총 게시물\n```\n\n예를 들어 User 모델이 있고 각 사용자가 여러 주문을 가질 수 있다고 가정합니다. 사용자 목록과 주문 금액의 총 합을 함께 검색하려면 withSum()을 사용할 수 있습니다.\n\n```js\nuse App\\Models\\User;\n\n$usersWithTotalOrderAmount = User::withSum('orders', 'amount')->get();\n\nforeach ($usersWithTotalOrderAmount as $user) {\n    echo \"User: {$user->name}, Total Order Amount: {$user->orders_sum_amount}\\n\";\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 예제에서는 `orders` 관계에서 각 사용자의 금액 열의 총 합계를 검색하기 위해 withSum(`orders`, `amount`)이 사용됩니다. 집계된 합계는 각 사용자 객체의 동적으로 생성된 속성 (orders_sum_amount)으로 사용할 수 있습니다.\n\nwithSum()을 사용하여 주 쿼리 결과와 관련된 모델에서 집계된 데이터를 효율적으로 검색하여 코드를 간단하게하고 성능을 향상시킬 수 있습니다.\n\n# 40. withCount()\n\nLaravel의 Eloquent ORM에서 withCount() 메서드는 관련된 모델과 관련 모델의 수를 함께 검색하는 데 사용됩니다. 이것은 추가 쿼리를 수행하거나 수동 계산을 필요로하지 않고 연결된 레코드 수를 검색하려는 경우 유용합니다.\n\n<div class=\"content-ad\"></div>\n\n왜: 관련된 모델의 수를 셀 때 사용합니다.\n언제: 사용자 당 게시물 수와 같이 관련 레코드 수를 얻을 때 사용합니다.\n\n```js\nuse App\\Models\\User;\n\n$usersWithPostCounts = User::withCount('posts')->get();\n\nforeach ($usersWithPostCounts as $user) {\n    echo \"User: {$user->name}, Post Count: {$user->posts_count}\\n\";\n}\n```\n\n위 예시에서 withCount('posts')는 각 사용자와 관련된 게시물 수를 검색하는 데 사용됩니다. 게시물 수는 각 사용자 객체의 동적으로 생성된 속성(posts_count)로 사용할 수 있습니다.\n\nwithCount()를 사용하면 주 쿼리 결과와 함께 데이터베이스로부터 관련 레코드의 수를 효율적으로 검색하여 코드를 단순화하고 성능을 향상시킬 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n우리는 Eloquent에 대해 정말 깊게 알아보았습니다. Laravel 개발자라면 꼭 알아야 할 40가지 사용 빈도가 적은 Eloquent ORM 메서드를 논의했으니 즐기세요!\n\n하지만 마지막까지 읽어준 선물로, 여기 워크플로우를 향상시키고 생산성을 향상시킬 10가지 더 많은 메서드가 있습니다.\n\n- oldest(): 지정된 열을 기준으로 쿼리 결과를 오름차순으로 정렬합니다.\n- latest(): 지정된 열을 기준으로 쿼리 결과를 내림차순으로 정렬합니다.\n- has(): 관계가 있는 레코드만 포함하도록 쿼리를 필터링합니다.\n- whereHas(): 특정 조건과 일치하는 관계가 있는 레코드만 포함하도록 쿼리를 필터링합니다.\n- doesntHave(): 관계가 없는 레코드만 포함하도록 쿼리를 필터링합니다.\n- whereDoesntHave(): 특정 조건과 일치하는 관계가 없는 레코드만 포함하도록 쿼리를 필터링합니다.\n- withPivot(): 중간 테이블 열을 쿼리할 때 추가 피벗 테이블 열을 지정합니다.\n- morphTo(): 관련된 모델이 여러 소스 모델에 속할 수 있는 다형 관계를 정의합니다.\n- morphMany(): 관련된 모델이 여러 소스 모델에 속할 수 있는 다형 일대다 관계를 정의합니다.\n- morphToMany(): 관련된 모델이 여러 소스 모델에 속할 수 있는 다형 다대다 관계를 정의합니다.\n\n<div class=\"content-ad\"></div>\n\n즐겁게 보내세요.\n\n계속 주목하세요!!! 다음 기사에서는 멋진 Laravel 튜토리얼을 더 소개할 예정이에요. 기사가 마음에 드셨길 바래요. 저를 팔로우해주세요 😇 그리고 박수를 좀 👏 부탁드려요. 궁금한 점이 있으면 언제든지 댓글을 남겨주세요.\n\n감사합니다.\n\n끝까지 읽어주셔서 정말 감사합니다. 저를 팔로우하거나 연락할 수 있는 곳:\nTwitter: https://twitter.com/EjimaduPrevail\nEmail: prevailexcellent@gmail.com\nGithub: https://github.com/PrevailExcel\nLinkedIn: https://www.linkedin.com/in/chimeremeze-prevail-ejimadu-3a3535219\nBuyMeCoffee: https://www.buymeacoffee.com/prevail\nChimeremeze Prevail Ejimadu","ogImage":{"url":"/assets/img/2024-06-19-DeepDiveintoEloquent40RarelyUsedEloquentORMMethodsEveryLaravelDeveloperMUSTKnow_0.png"},"coverImage":"/assets/img/2024-06-19-DeepDiveintoEloquent40RarelyUsedEloquentORMMethodsEveryLaravelDeveloperMUSTKnow_0.png","tag":["Tech"],"readingTime":16},{"title":"인터넷의 종말","description":"","date":"2024-06-19 14:40","slug":"2024-06-19-Theendoftheinternet","content":"\n\n![이미지](/assets/img/2024-06-19-Theendoftheinternet_0.png)\n\n알고 있는 대로의 인터넷이 끝나갈 수도 있습니다.\n\n제가 직접 목격한 몇 가지 변화와 우리가 향하고 있는 방향, 안타깝게도 예쁘지 않을 것 같습니다.\n\n긍정적인 시나리오가 있긴 하지만, 아마 대부분의 사람들이 매우 행복해하지 않을 것 같아요.\n\n<div class=\"content-ad\"></div>\n\n한 번 빅 벤에서 인터넷을 내려놓고 조금 더 자세히 살펴보죠. 그렇죠, 손에 들고 있을 수도 있지만 꼭 떨어뜨리지는 마세요!\n\n![인터넷](/assets/img/2024-06-19-Theendoftheinternet_1.png)\n\n# 인터넷\n\n우리는 인터넷을 당연시 여기고, 천천히 끓이는 개구리처럼 여러 해 동안 그 방향으로 이루어지는 변화들을 모두 받아들였습니다.\n\n<div class=\"content-ad\"></div>\n\n- 엄격한 규제: 체크.\n- 검열 및 진실 조작: 체크.\n- 개인 정보 침해 및 추적: 체크.\n- 모든 것이 광고: 응!\n\n그리고 제일 최악의 것은...\n\n- EU가 강요하는 쿠키 배너\n\n![이미지](/assets/img/2024-06-19-Theendoftheinternet_2.png)\n\n<div class=\"content-ad\"></div>\n\n# 주요 변화\n\n## 90년대\n\n저는 1997년에 처음으로 인터넷을 사용하기 시작했습니다. 33600 kbit 모뎀을 사용했는데, 이 글을 다운로드하는 데는 5분 이상이 걸렸을 것입니다.\n\n90년대는 야만 서부였습니다. 모든 것이 허용되었고 누구라도 노골적인 사이트를 삭제할 수 없었습니다. 검열은 없었고, 예쁘지 않은 GIF 광고와 Altavista 검색 엔진이 있었습니다.\n\n<div class=\"content-ad\"></div>\n\n비교할 만하다면, Altavista는 Google과 유사했는데, 그 안에서 유용한 정보를 얻기 위해 특정한 프롬프트 기술을 배워야 했던 곳이었습니다. 익숙한 것 같나요?\n\n![이미지](/assets/img/2024-06-19-Theendoftheinternet_3.png)\n\n# 2000년대 초반\n\n2000년대 초반은 애니메이션 플래시 웹사이트의 시대였습니다 - 모든 디자이너들에게 창의성이 넘치던 시기였죠. 하지만 이 또한 인터넷이 영원히 변화하는 순간이었습니다.\n\n<div class=\"content-ad\"></div>\n\n구글은 1998년에 검색 엔진을 만들었지만 2000년대 초반에 인기를 끌기 시작했습니다. 그리고 2004년에 할배할머니가 알고 있는 페이스북을 만든 하버드 대학 중퇴생 마크 주커버그가 나타났어요.\n\n2000년 10월에 구글은 광고 서비스를 시작했어요. 이것은 매우 상세한 활동 추적을 통해 사람들에게 \"관련성 있는\" 광고를 제공함으로써 인터넷을 영원히 바꾸었습니다.\n\n페이스북은 7년이 걸렸지만 2007년에 자체 광고 프로그램을 시작했어요.\n\n이 모든 추적은 광고주가 제품을 판매하는 데 도움이 되었어요. 모든 게 더 관련성 있게 되었는데, 온라인 개인 정보 보호의 종말이 시작된 것이기도 해요.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-Theendoftheinternet_4.png\" />\n\n요 멋진 시사 당시에는 2009년 페이스북이 '좋아요' 버튼을 출시했어요.\n\n페이스북 외부에서도 무언가를 좋아할 수 있게 해 주는 코드 조각이었죠. 그리고 그 뒤에서는 사용자의 온라인 활동을 추적하여 인터넷을 어떻게 사용하는지에 대한 자세한 지도를 작성했어요.\n\n이것이 뚜렷한 시기였답니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-Theendoftheinternet_5.png\" />\n\n## SEO 운동\n\n당시에는 검색 엔진을 통해서만 발견될 수 있었기 때문에 수십 억 달러의 산업이 시작되었습니다. 검색 엔진 최적화 또는 SEO.\n\n링크 팜을 구매하거나 높은 순위의 사이트에 광고를 실어주는 등 \"더 높은 순위\"를 얻는 여러 기술이 있었습니다.\n\n<div class=\"content-ad\"></div>\n\nSEO 콘텐츠는 사이트에 키워드가 듬뿍 담긴 긴 단락을 추가하여 봇을 속이는 방법이었습니다.\n\n![이미지](/assets/img/2024-06-19-Theendoftheinternet_6.png)\n\n사람들이 읽고 싶어하지 않는 매우 작은 텍스트로 길게 쓰여져 있어서, 인간이 쓰거나 읽고 싶어하지 않는 방식으로 작성되었으며, 전체 제품을 차지하기 시작했습니다.\n\n모든 주요 페이지에는 SEO 전용 섹션이 포함되어 있었지만, \"로봇을 위한 블로그\"가 등장하기 시작했습니다. 알고리즘을 조작하고 더 많은 조회수를 얻기 위해 수백 개의 키워드로 가득 채워진 헛소리 포스트들이 올라오기 시작했습니다.\n\n<div class=\"content-ad\"></div>\n\n만약 실수로 이와 같은 사이트에 도착했다면 빠르게 나가셨을 것입니다. 왜냐하면 우리는 이것을 그냥 알다시피 취급할 뿐이죠 — 쓰레기 SEO 콘텐츠예요.\n\n![이미지](/assets/img/2024-06-19-Theendoftheinternet_7.png)\n\n# AI 시대\n\n우리는 이제 AI 시대에 살고 있습니다. 인덱싱하는 게 아니라 배우기 위해 웹을 탐색하는 다양한 종류의 로봇들이 있죠.\n\n<div class=\"content-ad\"></div>\n\n오픈에이아이는 최근 뉴욕 타임스에 기사 전체를 거의 동일하게 요약했다며 소송을 당했어요. 수천 개의 콘텐츠가 침해되었다고 합니다.\n\n미드저니는 인터넷에서 대부분의 이미지를 가져오고 있는데, 이에 대해 대규모 시위와 데이터 오염 도구가 등장해 이를 막기 위한 노력이 이어졌어요.\n\n빙은 당신이 웹 사이트에 들어가지 않아도 답변해주는 AI 통합을 소개했어요.\n\n![이미지](/assets/img/2024-06-19-Theendoftheinternet_8.png)\n\n<div class=\"content-ad\"></div>\n\n요 아크는 팬들에게 사랑받는 회사로, 이 아이디어를 더욱 발전시키며 브라우저를 재구상하려고 합니다. 이 브라우저는 더 이상 웹사이트를 방문하는 것에 관한 것이 아니라, 대신 봇을 통해 자동으로 작업을 수행하는 것이 주 목적이 될 것입니다.\n\n그러나 이 접근 방식에는 문제가 있습니다.\n\n![이미지](/assets/img/2024-06-19-Theendoftheinternet_9.png)\n\n## 인터넷 루프의 종말\n\n<div class=\"content-ad\"></div>\n\n웹사이트가 트래픽이 없으면 광고 수익을 잃고 사업을 폐업하게 될 거예요.\n\n그러면 봇은 이 웹사이트에서 파싱하고 처리할 새로운 콘텐츠가 없어져서 출력물의 품질이 낮아질 거에요. 그리고 이 과정이 계속해서 반복될 거예요.\n\n## 내 예상\n\n인터넷은 주로 두 가지 주요 부분으로 나눠질 것 같아요.\n\n<div class=\"content-ad\"></div>\n\n한 부분은 무료로 액세스할 수 있을 것이며, AI가 생성한 콘텐츠는 SEO 기사가 10년 전과 같이 사용자 참여율을 높이는 주요 목적으로 제공될 것입니다.\n\n대부분의 사람들은 검색 엔진을 위한 키워드 농장 기사라는 것을 깨달은 후에는 읽기를 계속하지 않았습니다.\n\n![이미지](/assets/img/2024-06-19-Theendoftheinternet_10.png)\n\n## 품질 넷\n\n<div class=\"content-ad\"></div>\n\n인터넷의 다른 부분은 유료 구조로 전환될 것입니다.\n\n높은 품질의 콘텐츠가 주를 이루는데, 대부분은 인간이 만들었습니다. 물론, 조금은 AI의 도움도 받았지만 그 양은 매우 적고 사실 명시될 것입니다.\n\n예를 들어, 교육적인 게시물에서 AI를 사용하여 이미지를 생성하는 경우가 있습니다. 텍스트는 사람이 작성해야 하므로, 그 이미지조차도 AI에서 나왔다는 사실이 명시됩니다. 완벽히 투명하게 공개됩니다.\n\n이 유료 구조는 현실적으로 요금을 지불해야 하는 구조이거나, 이메일로 로그인하고 뉴스레터를 구독하면서 지불하는 방식으로 운영될 것입니다.\n\n<div class=\"content-ad\"></div>\n\n당연하지!\n\n# 로봇 금지\n\n콘텐츠 스크래핑을 방지하기 위한 지속적인 노력이 이루어질 것입니다. 이는 검색 엔진에 나타나는 고품질 콘텐츠가 줄어들 수 있다는 것을 의미합니다.\n\n결과적으로, 인터넷의 자유는 혜택을 완전히 상쇄하게 될 것입니다. 특히 질 좋은 콘텐츠에 대한 지불 능력이 없는 불우한 사람들에게는 이상적인 상황이 성립하지 않을 수 있습니다. 이들은 쓰레기로부터 배우게 되어 삶의 질을 향상하기가 더 어려워질 것입니다.\n\n<div class=\"content-ad\"></div>\n\n다른 분들을 위해 AI가 생성한 콘텐츠를 요약해주기 때문에 이는 콘텐츠의 질을 더 희석시키는 결과를 가져올 수 있어요.\n\n오랜 기간 동안 지속할 수 없는 모델이며, 결국은 인류에게 해로울 것이 분명해요.\n\n하지만 지금은 편리하니까, 그냥 괜찮지 않을까요?\n\n# 인터넷 3.0\n\n<div class=\"content-ad\"></div>\n\n인터넷이 큰 변화를 맞이하고 있어요. 이미 우리는 접속 벽 뒤로 물건을 옮기고 스크래핑을 방지하기 시작했어요. 모든 산업이 최적화 경로를 선택하고 있어요. 심지어 내가 사랑하는 디자인 분야도 그렇죠. \n\n2024년에는 전통적인 검색에서 나타나는 것에 관심을 가지는 사람이 거의 없을 거예요. 대부분의 경우, 사람들은 보다 직접적인 마케팅 기술을 사용할 거예요.\n\n이것은 더욱 가속화될 거예요.\n\n어떻게 생각하세요? 댓글로 알려주세요!\n\n<div class=\"content-ad\"></div>\n\n미래가 두려운 것인지 즐거운 것인지 어떻게 생각하시나요?","ogImage":{"url":"/assets/img/2024-06-19-Theendoftheinternet_0.png"},"coverImage":"/assets/img/2024-06-19-Theendoftheinternet_0.png","tag":["Tech"],"readingTime":5}],"page":"14","totalPageCount":20,"totalPageGroupCount":1,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}