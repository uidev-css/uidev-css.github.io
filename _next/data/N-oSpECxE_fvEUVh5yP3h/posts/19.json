{"pageProps":{"posts":[{"title":"퓨어 매니페스토  웹 표준 기반 디자인 시스템을 위한","description":"","date":"2024-06-19 00:33","slug":"2024-06-19-ThePUREManifestoforWebStandardsbasedDesignSystems","content":"\n\n## 초경량, 웹 표준 기반 디자인 시스템에 대한 기본 규칙\n\n![이미지](/assets/img/2024-06-19-ThePUREManifestoforWebStandardsbasedDesignSystems_0.png)\n\n알고 계실지 모르겠지만, 저는 간단하게 유지하는 것을 선호해요.\n\n![이미지](/assets/img/2024-06-19-ThePUREManifestoforWebStandardsbasedDesignSystems_1.png)\n\n<div class=\"content-ad\"></div>\n\n요즘에는 웹 컴포넌트 전용 PWA를 개발 중이었어요. 구글의 가벼운 라이브러리인 Google Lit을 활용해서요. 이 라이브러리는 무려 5KB밖에 안 되죠.\n\n이 중 하나의 프로젝트는 이미 완성된 피그마 디자인을 가지고 있던 젊은 B2B 스타트업을 위한 것이었어요. 처음에는 목표로 했던 모바일 앱 대신 PWA 기술을 이용하자는 이야기를 나눴을 때, 컴포넌트 라이브러리와 디자인 시스템에 관한 문제가 생겼어요.\n\n앱의 디자인은 신선하고 다채롭고 독창적이었어요. \n\n일반적인 UI 라이브러리(Material Web, FAST, Shoelace 등)를 사용하면 맞춤 작업을 많이 해야 했기 때문에 결정을 내리는 데 시간이 걸렸어요.\n\n<div class=\"content-ad\"></div>\n\n우리만의 사용자 정의 구성 요소 라이브러리로 나아갈까요? 분명히 많은 작업이 필요할 겁니다.\n\n디자인 시스템을 분리하고 Storybook 인스턴스를 만드는 추가 작업이 필요하기 때문에 스마트하게 대응해야 합니다:\n\n- 자체 디자인 시스템 구축은 가능한 최소한의 부담을 동반해야 합니다.\n- 이미 있는 모범 사례를 활용해야 합니다.\n- 언제나 네이티브 솔루션을 지향하고 표준을 준수해야 합니다.\n- 외부 종속성을 최소화하기 위해 최선을 다해야 합니다.\n- 신속히 반복하고 실용적인 선택을 해야 합니다.\n- 열렬하지 않아도 되며 바퀴를 다시 발명하는 것을 막기 위해 좋은 이유가 있을 때 외부 구성 요소를 사용할 여지를 열어두어야 합니다 😉.\n\n제 경험을 바탕으로 PURE 선언을 소개하겠습니다.\n\n<div class=\"content-ad\"></div>\n\n# 1순위: 순수한(의미론적) HTML+CSS 사용하기\n\n적절한 의미론을 가진 표준 HTML+CSS 솔루션을 항상 찾아보세요.\n\n가끔은 표준 의미론적 HTML 이상이 필요하지 않을 수도 있습니다.\n\n```js\n<section class=\"callout warning\">\n  <h3>Warning</h3>\n  <div>This is a simple callout test message.</div>\n</section>\n```\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-19-ThePUREManifestoforWebStandardsbasedDesignSystems_2.png)\n\n가끔은 표준 HTML 구조를 사용하여 흥미로운 사용자 정의 결과를 얻을 수 있습니다. 이는 완전한 의미론적인 응답입니다:\n\n```js\n<hr data-content=\"or\"/>\n```\n\n...약간의 스타일링을 추가하면 멋진 구분선이 될 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n![image](/assets/img/2024-06-19-ThePUREManifestoforWebStandardsbasedDesignSystems_3.png) \n\n# 우선 순위 2: 점진적 향상을 생각하세요\n\n최근 프로젝트 중 하나에서는 Google Material Web의 텍스트 필드 구성 요소를 살펴보았고, 우리의 요구 사항을 충족할 수 있는 완전한 Web 구성 요소를 개발하는 것을 고려했지만, 간단함을 위해 어느 쪽도 사용하지 않기로 결정했습니다.\n\n다음은 'id' 및 'for' 속성을 사용하지 않고도 레이블이 있는 양식 필드를 만드는 방법을 보여주는 내가 항상 사용하는 코드 조각입니다(모든 브라우저에서 오랜 기간 동안 작동되어 왔습니다):\n\n<div class=\"content-ad\"></div>\n\n```js\n<label>\n  <span data-label>Email address</span>\n  <input name=\"email\" type=\"email\" placeholder=\"john@doe.com\">\n</label>\r\n```\n\n간단한 점진적 향상을 작성했는데, 'data-label' 속성을 가진 컨트롤을 자동으로 확장하여 위의 구조로 표시됩니다:\n\n```js\n<input name=\"email\" required\n  data-label=\"Email address\"\n  placeholder=\"john@doe.com\"\n/>\r\n```\n\n<img src=\"/assets/img/2024-06-19-ThePUREManifestoforWebStandardsbasedDesignSystems_4.png\" />\n\n<div class=\"content-ad\"></div>\n\n매우 간단한 점진적 개선 방법은 HTML 입력의 모든 표준 로직이 보존된다는 것을 의미합니다. Web 컴포넌트가 Web Forms에서 일등 시민으로 동작하도록 하는 데 필요한 것과 비교해보면, 절약할 수 있는 규모를 감을 수 있을 겁니다. \n\n우리는 모든 폼 요소에 이 방법을 사용하기로 결정했고, 우리 자체 맞춤형 컴포넌트와 같이 네이티브가 아닌 HTML 요소를 사용하더라도 동일한 점진적 개선을 사용할 수 있습니다:\n\n```js\n<switch-check name=\"email\" required\n  data-label=\"Email address\"\n  placeholder=\"john@doe.com\"\n></switch-check>\n```\n\n# 우선순위 3: 사용자 정의 태그 시험 (스타일 적용하기)\n\n<div class=\"content-ad\"></div>\n\n많은 웹 표준(예: PWA — 이름은 무슨 뜻일까?)과 마찬가지로, 웹 컴포넌트는 HTML 언어 자체의 확장성을 통해 시작되는 점진적인 향상을 제공합니다. 이는 사용자 정의 태그를 사용하는 것으로 이루어져 있습니다.\n\n따라서, 사용자 정의 태그는 웹 컴포넌트가 아닙니다. 웹 컴포넌트는 기능이 첨부된 사용자 정의 태그입니다.\n\n사용자 정의 태그는 단순히 선언함으로써 사용할 수 있으며, 해당 태그에 첨부된 웹 컴포넌트를 정의하지 않고 사용자 정의 태그를 사용하는 것은 HTML 구성 요소화에 유효한 접근 방식일 수 있습니다.\n\n가끔은 의미있는 앵커 포인트가 있는 것이면서 해당 포인트에 특정 사용자 정의 태그 CSS를 첨부하는 것만으로 충분할 수 있습니다. 확실히 잘 선택된 사용자 정의 태그 이름은 향후 개발자가 당신의 애플리케이션 흐름을 읽는 데 도움이 됩니다!\n\n<div class=\"content-ad\"></div>\n\n하지만 사용자 정의 태그를 정의할 때는 언제나 CSS만 적용할 경우(기능은 없음)일까요?\n\n내 기준은 다음과 같습니다:\n\n- 우리의 목표와 가장 일치하는 의미론적 요소가 없습니다.\n- 사용자 정의 태그는 사용자 정의 방식을 따르는 내부 HTML을 기대하는 래퍼입니다.\n\n```js\n<custom-grid columns=\"1\">\n  [내용을 입력하세요]\n</custom-grid>\n```\n\n<div class=\"content-ad\"></div>\n\n위의 예제는 Markdown 형식의 표로 변경해야 합니다.\n\n```js\ncustom-grid {\n  display: grid;\n  grid-gap: var(--gutter-small, .5rem);\n  &[columns=\"1\"]{\n    grid-template-columns: 1fr;\n  }\n}\n```\n\n그리고 다른 복잡한 예제로는 최근에 작성한 TabStrip이 있습니다. 이는 tab-strip라는 사용자 지정 태그를 사용하며 매우 구체적인 콘텐츠를 필요로 합니다: 각 탭은 하나의 링크와 하나의 div로 구성된 섹션으로 표현됩니다.\n\n```js\n<tab-strip>\n  <section id=\"tab1\"><a href=\"#insights\">Tab 1</a>\n    <div class=\"tab-content\" id=\"overview\">\n      Tab 1 content\n    </div>\n  </section>  \n  <section id=\"tab2\"><a href=\"#tab2\">Tab 2</a>\n    <div class=\"tab-content\">\n      Tab 2 content\n    </div>\n  </section>  \n  <section id=\"tab3\"><a href=\"#tab3\">Tab 3</a>\n    <div class=\"tab-content\">\n      Tab 3 content\n    </div>\n  </section>\n</tab-strip>\n```\n\n<div class=\"content-ad\"></div>\n\n물론, 상황이 더 복잡해지면, 예를 들어 탭 콘텐츠를 탭을 클릭할 때 가져와야 하는 경우, 다음 단계는 사용자 정의 태그의 로직을 정의하고 이를 웹 구성 요소로 만드는 것입니다.\n\n# 우선순위 4: 웹 컴포넌트 로직 추가 (Light DOM 사용)\n\n사용자 정의 태그를 사용할 때 트리거되는 기능이 필요한 경우, customElements.define()를 사용하여 해당 기능을 첨부해야 합니다.\n\n많은 경우 전역 스타일링을 활용하거나 전역 상태를 처리하고 버블링 이벤트를 캐치하는 등 JavaScript 기능을 가진 컨테이너 유형의 요소가 필요할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 컨테이너 요소를 고려해보세요:\n\n```js\n<spa-route>\n  [HTML 내용을 입력하세요]\n</spa-route>\n```\n\n```js\nimport {html, LitElement} from \"lit\";\nimport {Router} from \"./router\";\nimport {config} from \"../app-config\";\nimport {until} from \"lit/directives/until.js\";\n\ncustomElements.define(\n  \"spa-route\",\n\n  class PWARenderRoute extends LitElement {\n\n     #router = new Router(config.routes));\n\n    // Light DOM 사용\n    createRenderRoot() {\n      return this;\n    }\n\n    render() {\n      return html`${until(this.#router.matchRoute(), app.loader)}`;\n    }\n  }\n)\n```\n\n이 코드는 SPA 라우터의 간소화된 버전으로, 구성된 라우트에 기반하여 콘텐츠를 렌더링합니다. 완전한 예제는 \"The Browser is your Framework: Building a PWA with only Web Components and Lit\"에서 확인할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n웹 컴포넌트 중심의 PWA에서는 본문 태그 아래에 모든 것을 포함하는 웹 컴포넌트를 두는 것이 모범 사례입니다.\n\n```js\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\"/>\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, user-scalable=1.0, minimum-scale=1.0, maximum-scale=1.0\">\n    <title>My App</title>\n    <link rel=\"manifest\" href=\"/manifest.webmanifest\"/>\n    <meta name=\"apple-mobile-web-app-capable\" content=\"yes\"/>\n    <meta name=\"mobile-web-app-capable\" content=\"yes\"/>\n    <meta name=\"theme-color\" content=\"#655122\"/>\n    <link rel=\"apple-touch-icon\" href=\"/assets/img/icon512px\"/>\n    <link rel=\"shortcut icon\" href=\"/assets/img/favicon.ico\">\n    <link href=\"/assets/css/main.css\" rel=\"stylesheet\"/>\n    <script type=\"module\" defer src=\"/assets/js/app.js\"></script>\n</head>\n\n<body>\n\n<my-app class=\"app-canvas\">\n  <main>\n    <spa-route></spa-route>\n  </main>\n</my-app>\n\n</body>\n\n</html>\n```\n\n그러니까, my-app 구성요소는 글로벌 앱 상태를 관리하고, localStorage를 처리하며, 인증 세션을 관리하며, 버블링 이벤트를 처리합니다.\n\n# 5순위: 완전한 웹 컴포넌트 생성하기 (Shadow DOM 활용)\n\n<div class=\"content-ad\"></div>\n\n위에 표시된 코드 중 일부에서 Light DOM을 사용하는 꿀팁(Light DOM을 사용하면 전역 스타일이 웹 컴포넌트의 태그 아래에 모두 적용됩니다)은 다음과 같은 Lit 코드입니다:\n\n```js\n// Light DOM 사용하기\ncreateRenderRoot() {\n  return this;\n}\n```\n\n기본적으로 LitElement 기반의 웹 컴포넌트는 Shadow DOM을 사용하여 렌더링되므로 확장된 HTMLElement 자체를 반환하여 사용을 비활성화해야 합니다!\n\n커스텀 HTML을 출력하고 문서의 전역 스타일과 격리되어야 하는 커스텀 스타일을 사용하는 복잡한 컴포넌트의 경우, 이 아이디어가 좋지만 몇 가지 추가 복잡성을 받아 들여야 합니다:\n\n<div class=\"content-ad\"></div>\n\n- 먼저 Shadow DOM의 격리 수준에 대해 알아야 합니다. 웹 구성 요소 중에서 복잡한 부분이 있다면 바로 그것입니다.\n- CSS 속성(또는 변수)을 사용하는 것은 추가 작업이 필요합니다.\n- 테마 공유(테두리, 색상, 그림자, 안쪽 간격 등)는 조금 더 복잡하고 설명이 필요합니다.\n- 컨텐츠 배치(슬롯 사용)는 매우 특정하며 항상 명확하지는 않습니다.\n- 접근성 및 사용 용이성 노력(특히 양식 요소를 빌드할 때)은 개발 시간을 늘릴 것입니다.\n\n이렇게 말씀드리는 것에, 많은 구성 요소와 흐름이 있는 복잡한 컨트롤은 물론 단일 단위로 작동합니다. 당연히 매우 가치가 있고, 웹 표준은 이러한 모듈성을 만들기 위한 좋은 방법을 제공합니다.\n\n# 결론\n\n웹 구성 요소 중심의 애플리케이션 개발은 훌륭하고, 초고속 그리고 가벼운 PWA를 제공하지만 웹 구성 요소는 훌륭한 앱을 제공하는 유일한 수단으로 간주되어서는 안 됩니다. 그들에 대한 많은 사용 사례가 있지만, 항상 그것들이 다른 웹 표준과 마찬가지로 점진적 향상의 한 형태임을 염두에 두어야 합니다.\n\n<div class=\"content-ad\"></div>\n\n따라서 코드를 모조리 웹 구성 요소 또는 완전히 격리된 Shadow DOM을 사용하는 것에 대해서는 신중하게 고려해야 합니다.\n\n이 선언은 Lean Startup 관점에서 항상 올바르고 실용적이며 때로는 기회적인 선택을 하는 데 관한 것입니다. 항상 가장 간단하고 지속 가능한 해결책을 찾으려 노력하며 잡기 어려운 방법으로 접근합니다.\n\n가끔은 재사용하기 쉬운 가벼운 구조부터 시작하여 미래에 프로그레시브한 향상을 위한 여지도 남겨두는 것을 의미합니다 😉.\n\nPURE 선언의 많은 개념은 이전 (오픈 소스) 작업에서 기인한 것으로, PurePWA - 파워 & 순수성 (pure-pwa.com)과 같은 작업이 있습니다.","ogImage":{"url":"/assets/img/2024-06-19-ThePUREManifestoforWebStandardsbasedDesignSystems_0.png"},"coverImage":"/assets/img/2024-06-19-ThePUREManifestoforWebStandardsbasedDesignSystems_0.png","tag":["Tech"],"readingTime":8},{"title":"ASPNET 프로젝트를 IIS에 배포하는 단계별 안내","description":"","date":"2024-06-19 00:32","slug":"2024-06-19-AStep-by-StepGuidetoDeployingYourASPNETProjectinIIS","content":"\n\n<img src=\"/assets/img/2024-06-19-AStep-by-StepGuidetoDeployingYourASPNETProjectinIIS_0.png\" />\n\n우선, ASP.NET과 IIS가 무엇을 의미하는지 알아봅시다. ASP.NET은 Microsoft에 의해 만들어진 크로스 플랫폼 오픈 소스 웹 프레임워크로, .NET을 기반으로 현대적인 웹 앱 및 서비스를 구축하는 데 사용됩니다.\n\nInternet Information Service (IIS)는 Microsoft가 만든 유연하고 관리가 용이한 웹 서버로, Windows 시스템에서 실행되어 요청된 HTML 페이지나 파일을 제공합니다. IIS는 HTTP, HTTPS, FTP 등 다양한 프로토콜을 지원하며, 요청 처리, 보안, 로깅, 성능 모니터링 등의 중요한 기능을 제공하여 ASP.NET 애플리케이션을 호스팅하는 데 사용됩니다.\n\nASP.NET 프로젝트를 IIS에 배포하는 것은 개발 환경에서 프로덕션 환경으로 애플리케이션을 옮기는 중요한 단계입니다. IIS를 통해 애플리케이션이 사용자에게 접근 가능하며 강력한 보안 기능과 포괄적인 로깅 및 모니터링 기능을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n이 가이드에서는 ASP.NET 프로젝트를 IIS에 배포하는 과정을 안내해 드리겠습니다. 배포를 위해 프로젝트를 준비하는 단계부터 IIS 설치 및 구성, 프로젝트 배포, 필요한 설정 구성, 배포 테스트까지 모두 다룰 것입니다. 이러한 단계를 따라하면 ASP.NET 애플리케이션을 성공적으로 배포하고 생산 환경에 준비할 수 있을 것입니다.\n\n단계 1: ASP .NET 애플리케이션 준비하기\n\n- Visual Studio에서 프로젝트 빌드\n- 프로젝트를 게시\n- 솔루션 탐색기에서 마우스 오른쪽 단추 클릭하고 게시 선택\n\n![이미지](/assets/img/2024-06-19-AStep-by-StepGuidetoDeployingYourASPNETProjectinIIS_1.png)\n\n<div class=\"content-ad\"></div>\n\n- 발행 대화 상자에서 발행 대상으로 \"폴더\"를 선택합니다.\n\n![이미지](/assets/img/2024-06-19-AStep-by-StepGuidetoDeployingYourASPNETProjectinIIS_2.png)\n\n- 로컬 컴퓨터에 발행된 파일이 저장될 폴더 경로를 지정합니다. 일반적으로 파일이 컴파일되고 배포를 위해 준비되는 임시 폴더입니다.\n\n![이미지](/assets/img/2024-06-19-AStep-by-StepGuidetoDeployingYourASPNETProjectinIIS_3.png)\n\n<div class=\"content-ad\"></div>\n\n- 이제 우리 애플리케이션 빌드가 성공했습니다. 대상 폴더에 파일을 확인할 수 있습니다.\n\n![이미지 설명](/assets/img/2024-06-19-AStep-by-StepGuidetoDeployingYourASPNETProjectinIIS_4.png)\n\n단계 2: IIS 설치\n\n- 먼저 서버에 IIS가 설치되어 있는지 확인하십시오. 그렇지 않은 경우 다음 링크를 클릭하여 IIS를 설치하십시오.\n\n<div class=\"content-ad\"></div>\n\nStep 3: IIS로 프로젝트 배포하기\n\n서버로 파일 복사하기:\n\n- 게시된 파일이 있는 로컬 컴퓨터의 파일 탐색기 창을 엽니다.\n- 게시된 파일들(보통 게시된 폴더 안의 모든 것)을 모두 선택합니다.\n\n<div class=\"content-ad\"></div>\n\n서버에 새 폴더를 만드세요:\n\n- IIS가 설치된 서버에 원격 데스크톱 또는 다른 원격 액세스 방법을 사용하여 연결하세요.\n- 서버에서 C:\\inetpub\\wwwroot로 이동하세요.\n- wwwroot 디렉토리 내에서 마우스 오른쪽 버튼을 클릭하세요.\n- 컨텍스트 메뉴에서 \"새 폴더\"를 선택하세요.\n- 새 폴더에 웹사이트 이름(예: MyAspNetApp)으로 폴더 이름을 지정하세요.\n\n발행된 파일 붙여넣기:\n\n- C:\\inetpub\\wwwroot 내에 생성된 새 폴더(MyAspNetApp)를 더블 클릭하여 엽니다.\n- 로컬 컴퓨터에서 복사한 파일과 폴더를 서버의 이 디렉토리에 붙여넣으세요.\n\n<div class=\"content-ad\"></div>\n\n파일 전송 확인:\n\n- ASP.NET 프로젝트의 모든 파일과 폴더가 서버의 C:\\inetpub\\wwwroot\\MyAspNetApp으로 성공적으로 복사되었는지 확인하세요.\n\n단계 4: IIS 구성\n\n- 이제 제어판에서 IIS 관리자를 검색하세요. 그런 다음 다음과 같은 인터페이스가 표시됩니다. (서버에 관리자 권한이 있는지 확인하세요.)\n\n<div class=\"content-ad\"></div>\n\n\n![Step 1](/assets/img/2024-06-19-AStep-by-StepGuidetoDeployingYourASPNETProjectinIIS_5.png)\n\n- 그런 다음 서버 이름을 마우스 오른쪽 버튼으로 클릭한 후 웹 사이트 추가를 클릭하세요.\n\n![Step 2](/assets/img/2024-06-19-AStep-by-StepGuidetoDeployingYourASPNETProjectinIIS_6.png)\n\n- 웹 사이트 이름을 지정하고 애플리케이션 빌드가 배치된 물리적 경로를 제공하세요(예: C:\\inetpub\\wwwroot\\MyAspNetApp).\n\n\n<div class=\"content-ad\"></div>\n\n\n![A Step-by-Step Guide to Deploying Your ASP.NET Project in IIS 7](/assets/img/2024-06-19-AStep-by-StepGuidetoDeployingYourASPNETProjectinIIS_7.png)\n\n- Give the website host name also.\n\n![A Step-by-Step Guide to Deploying Your ASP.NET Project in IIS 8](/assets/img/2024-06-19-AStep-by-StepGuidetoDeployingYourASPNETProjectinIIS_8.png)\n\nStep 4: Editing the Hosts File to Map IP Address to Hostname\n\n\n<div class=\"content-ad\"></div>\n\n- C 드라이브를 열고 시스템 32 폴더를 찾아주세요. 드라이버 폴더를 열고, 그 후에 etc. 폴더를 열어주세요. 그리고 'Host' 파일을 열어주세요. (C:\\Windows\\System32\\drivers\\etc)\n\n![이미지](/assets/img/2024-06-19-AStep-by-StepGuidetoDeployingYourASPNETProjectinIIS_9.png)\n\n- 메모장을 사용하여 호스트 파일을 열어주세요.\n\n호스트 파일 편집:\n\n<div class=\"content-ad\"></div>\n\n- 호스트 파일의 맨 아래에 IP 주소와 매핑하려는 호스트 이름을 가진 새로운 줄을 추가하세요. 예를 들어:\n192.168.1.100 idenitymanagement.com\n\n![이미지](/assets/img/2024-06-19-AStep-by-StepGuidetoDeployingYourASPNETProjectinIIS_10.png)\n\n- 192.168.1.100을 서버의 IP 주소로, idenitymanagement.com을 ASP.NET 응용 프로그램에 대한 원하는 호스트 이름으로 바꿔주세요.\n\n이제 IIS 관리자로 이동하여 웹 사이트를 찾아보세요. 마우스 오른쪽 버튼 클릭 - `웹 사이트 관리 -` 둘러보기\n\n<div class=\"content-ad\"></div>\n\n\n![Step 1](/assets/img/2024-06-19-AStep-by-StepGuidetoDeployingYourASPNETProjectinIIS_11.png)\n\nNow the application is live in IIS.\n\n![Step 2](/assets/img/2024-06-19-AStep-by-StepGuidetoDeployingYourASPNETProjectinIIS_12.png)\n\nReferences\n\n\n<div class=\"content-ad\"></div>\n\nhttps://learn.microsoft.com/en-us/iis/application-frameworks/scenario-build-an-aspnet-website-on-iis/configuring-step-1-install-iis-and-asp-net-modules\n\nhttps://www.c-sharpcorner.com/article/deploying-asp-net-mvc-application-on-iis-server/","ogImage":{"url":"/assets/img/2024-06-19-AStep-by-StepGuidetoDeployingYourASPNETProjectinIIS_0.png"},"coverImage":"/assets/img/2024-06-19-AStep-by-StepGuidetoDeployingYourASPNETProjectinIIS_0.png","tag":["Tech"],"readingTime":5},{"title":"TypeScript로 API 응답 유형 작성하는 방법","description":"","date":"2024-06-19 00:30","slug":"2024-06-19-HowToWriteAPIResponseTypeswithTypeScript","content":"\n\n## API 응답을 위한 TypeScript 타입을 구성하여 훌륭한 개발 경험, 코드 유지 및 명백한 코딩 오류를 피하세요.\n\n![이미지](/assets/img/2024-06-19-HowToWriteAPIResponseTypeswithTypeScript_0.png)\n\n클라이언트 애플리케이션 개발자들은 매일 API와 작업합니다. 작업의 성공 또는 비즈니스 로직에 따라 API 응답을 표준화하는 것이 좋은 습관입니다. 일반적으로 응답은 상태, 오류 등과 같은 표준 필드를 포함합니다.\n\n이러한 표준 필드를 사용하면 개발자들이 작업 상태에 대응하고 애플리케이션과의 추가 사용자 상호작용을 구축할 수 있습니다. 등록이 성공하면 폼이 닫히고 성공 메시지가 표시되어야 합니다. 그러나 데이터 형식이 잘못된 경우 유효성 검사 오류가 폼에 표시되어야 합니다.\n\n<div class=\"content-ad\"></div>\n\n프로젝트에서 응답 유형을 편리하고 빠르게 유연하게 설명하는 방법에 대한 질문이 발생합니다.\n\n# 마주한 문제\n\n가끔 프로젝트에서 응답 유형은 하나의 유형만 사용하여 여러 선택적 매개변수로 설명됩니다. 대부분의 경우 이것만으로 충분할 수도 있고, TypeScript는 코드를 작성할 때 이러한 매개변수를 제안해 줄 것입니다. 그러나 이러한 매개변수의 존재를 확인하는 추가적인 검사가 필요할 수도 있습니다. 이것이 그러한 유형의 예입니다:\n\n이 접근 방식의 유일한 장점은 단순성입니다. 우리는 ApiData 유형을 어떤 응답 유형에 추가해도 충분합니다.\n\n<div class=\"content-ad\"></div>\n\n그러나 내가 생각하기론, 한 가지 장점은 상당한 단점에 비해 상쇄된다고 믿습니다. 이 방식의 단점은 투명성의 부족입니다.\n\n또한, 이러한 유형을 응답 유형에 추가함으로써 특정 요청의 응답이 정확히 무엇인지 알 수 없게 됩니다. 예를 들어, POST 요청에 대해 API로부터 제한된 응답 시나리오가 나올 수 있다고 상상해봅시다.\n\n다음과 같은 시나리오들이 있을 수 있습니다:\n\n- 상태가 `ok`이고 일부 데이터를 가진 성공한 작업\n- 상태가 `form_errors`이고 오류가 ['', '']인 유효성 오류, 그게 전부입니다\n\n<div class=\"content-ad\"></div>\n\n이 경우에는 `redirect` 상태가 가능한 응답 시나리오로 나타나지 않을 것이에요. 또한 GET 요청의 응답에 왜 errors 매개변수가 필요한지 궁금할 수도 있겠죠?\n\n응답 유형을 보고 정확한 응답 옵션을 알 수 없다는 점이 밝혀졌어요. 모든 가능한 응답 변형을 이해하려면 요청을 보내고 응답을 처리하는 함수의 코드를 열어봐야 해요.\n\n# 응답 유형을 위한 유틸리티 타입\n\n위에서 설명한 단점은 사용자 정의 유틸리티 타입을 사용하여 해결할 수 있어요. 각 시나리오마다 별도의 타입이 있습니다: 성공적인 작업, 서버 오류, 유효성 검사 오류 또는 강제 리디렉션을 위한 개별 타입이 있답니다.\n\n<div class=\"content-ad\"></div>\n\n각 유형은 특정 응답에 대한 모든 가능한 응답 옵션을 반영하기 위해 개별적으로 또는 결합하여 사용할 수 있습니다. 각 유형은 해당 응답에 해당하는 데이터 유형을 전달할 수 있도록 일반 사항을 갖게 될 것입니다.\n\n게다가, 제가 일반적인 ApiRespinse 유형을 만들었습니다. 이 유형에는 여러 유틸리티 유형이 포함되어 있습니다. 각 POST 요청에 대한 모든 시나리오를 추가하는 데 시간을 절약할 수 있게 될 것입니다.\n\n아래는 다양한 시나리오에 대해 이러한 유틸리티 유형을 사용하는 예시입니다:\n\n# 실용적인 차이\n\n<div class=\"content-ad\"></div>\n\n아래는 사용자 프로필의 유형과 사용자 프로필 업데이트 기능에서 반환된 응답의 예시입니다.\n\n이 코드를 TypeScript로 어떻게 린트하는지 보여주는 이미지가 있습니다:\n\n![이미지](/assets/img/2024-06-19-HowToWriteAPIResponseTypeswithTypeScript_1.png)\n\n그림에서 TypeScript가 하이라이트한 대로, 표준 응답의 기대 값 중 일부인 오류, 오류 또는 URL과 같은 값들은 일반적으로 정의되지 않을 수 있다고 linter가 고려합니다. 이는 상태와 함께 추가로 체크가 필요하지만, 이미 이 접근 방식의 문제를 보여줍니다.\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 마크다운 형식으로 변경해주세요.\n\n<div class=\"content-ad\"></div>\n\n이 경우에는 모든 것이 예상대로 작동합니다:\n\n- TypeScript는 해당 상태에 대응하는 표준 필드가 있을 것이라고 이해합니다.\n- 사용자 값이 성공적인 경우를 제외한 모든 응답 유형에서 정의되지 않을 수 있음을 나타냅니다. 그러나 응답의 성공을 확인한 후에는 이 값이 강조되지 않고 정의됩니다.\n\n# 결론\n\n이 유틸리티 타입을 프로젝트에 구현한 후 개발자 경험이 크게 향상되었습니다. 이제 타입이 API가 제공할 수 있는 가능한 응답 시나리오와 완전히 일치합니다.\n\n<div class=\"content-ad\"></div>\n\n위에 표 표시 형식을 Markdown 형식으로 변경하면 특정 응답 유형에서 사용할 수 없는 값이 사용되어 잠재적인 오류를 방지할 수 있습니다. 사용자 값과 같은 경우가 있습니다.\n\n또한 코드에서 응답 처리 구현을 살펴 볼 필요가 없습니다. 실제 응답 유형을 이해하려면 코드를 참고하면 됩니다. 전체 그림을 즉시 확인할 수 있습니다.\n\n이 유틸리티 유형의 작동 방식에 관심이 있다면 Typescript Playground 페이지를 확인해보세요.","ogImage":{"url":"/assets/img/2024-06-19-HowToWriteAPIResponseTypeswithTypeScript_0.png"},"coverImage":"/assets/img/2024-06-19-HowToWriteAPIResponseTypeswithTypeScript_0.png","tag":["Tech"],"readingTime":3},{"title":"제 자동화된 문서 작성 도구로 새로운 Toolips를 만들기","description":"","date":"2024-06-19 00:27","slug":"2024-06-19-CreatingMyNewAutomatedDocumentationWithToolips","content":"\n\n## 소개\n\n올해는 기존의 모든 소프트웨어를 패키징하는 데 상당한 노력을 기울이고, 크게 보완하고 있습니다. 내년에는 가정 서버에서 대형 개인 프로젝트를 배포할 수 있기를 희망하며 이를 위해 노력하고 있습니다. 현재 두 개의 생태계에 진입하여 세 번째를 완성하기 위해 노력 중입니다. 그동안 코딩을 하면서 한 가지 미뤘던 일이 있습니다. 아주 큰 생태계를 먼저 만들 것을 기대했던 럭셔리 Toolips를 이용한 소프트웨어 문서 웹사이트입니다.\n\n이 일을 오랫동안 미루었지만, 소프트웨어 문서 웹사이트를 만드는 시간은 항상 다른 곳에 쓸 수 있지만, 문서 웹사이트를 통해 더 많은 사람이 쉽게 내 소프트웨어를 사용할 수 있는 기회가 되기도 합니다. 또한 프로젝트 주변에 더 많은 기술적 글쓰기와 예제를 만들 수 있는 기회를 제공합니다. 이 모든 것을 고려하여, 오늘은 새 프로젝트 ChifiDocs를 만드는 접근 방식에 대해 이야기하겠습니다.\n\n이 프로젝트는 표준 Toolips 방식을 따라 설정됩니다. new_app을 사용하여 앱을 생성한 다음 ToolipsSession을 추가합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nusing Toolips; Toolips.new_app(\"ChifiDocs\")\nusing Pkg; Pkg.add(\"ToolipsSession\")\n```\n\n```js\nmodule ChifiDocs\nusing Toolips\nusing Toolips.Components\nusing ToolipsSession\n\n# extensions\nlogger = Toolips.Logger()\nsession = Session([\"/\"])\n\n....\n\nexport home, logger, session\nend # ChifiDocs <3\n```\n\n이제 우리는 Julia 측 백엔드를 만들기 시작할 차례입니다.\n\n## 백엔드\n\n\n<div class=\"content-ad\"></div>\n\n툴립을 사용하는 가장 큰 장점 중 하나는 백엔드와 프론트엔드가 동일한 위치에 있고 원활하게 연결되어 있다는 것입니다. 많은 웹 개발 경우에 프론트엔드 서비스와 백엔드 서비스 사이에 통신을 하는 반면, 툴립을 사용하면 콜백 이벤트를 등록하고 연결을 제공함으로써 프론트엔드에서 백엔드를 작업할 수 있습니다.\n\n이 문서 웹사이트에 표시하고 싶은 내용에 대한 아이디어가 있으므로, 백엔드에 몇 가지를 추가해야 합니다. 우선, 내 에코시스템을 쉽게 구성하고 모든 패키지 및 내용을 표현하는 쉬운 방법이 있었으면 합니다. 둘째, 탭 기능이 있었으면 하는데 — 비활성 탭을 어딘가에 저장할 방법이 필요하며, 아마도 서버에 저장할 것입니다 (메모리를 보존하고 상대방의 메모리를 사용할 수도 있습니다). 대부분의 경우에 후자가 더 나은 해결책이지만, 이 경우에는 페이지를 메모리에 보관하는 것이 더 합리적인 선택입니다. 왜냐하면 계속해서 다른 클라이언트에게 동일한 페이지를 제공하고 있기 때문입니다. 우리의 백엔드는 이러한 모듈과 이들의 문서를 보관할 데이터를 수용하기 위해 DocModule 및 DocSystem 구조로 시작할 것입니다.\n\n```js\nmutable struct DocModule\n    mod::Module\n    pages::Vector{Component{<:Any}\n    mdpath::String\nend\n\nmutable struct DocSystem\n    name::String\n    color::String\n    modules::Vector{DocModule}\nend\n```\n\n제가 생각한 두 구조입니다. DocModule은 모듈, 페이지 및 경로인 mdpath를 보관합니다. DocSystem은 범주별 정보를 갖는 일련의 DocModule을 감싼 것으로, 색상과 표시에 대한 이름을 포함합니다. 이 프로젝트에 필요한 마지막 요소는 이 데이터를 보관할 Toolips 서버 확장 기능입니다. Auth에서 제공되는 인증 데이터를 사용하는 등 다른 옵션이 있지만, 이 경우에는 이 모든 것을 처리할 자체 시스템을 개발하여 사용하겠습니다.\n\n<div class=\"content-ad\"></div>\n\n\n```js\nabstract type AbstractDocClient end\n\nmutable struct DocClient <: AbstractDocClient\n    key::String\n    tabs::Vector{Component{<:Any}\nend\n\ngetindex(dc::Vector{<:AbstractDocClient}, ref::String) = begin\n    pos = findfirst(cl::AbstractDocClient -> cl.key == ref, dc)\n    if isnothing(pos)\n\n    end\n    dc[pos]::AbstractDocClient\nend\n\nmutable struct ClientDocLoader <: Toolips.AbstractExtension\n    docsystems::Vector{DocSystem}\n    client_keys::Dict{String, String}\n    clients::Vector{DocClient}\n    pages::Vector{AbstractComponent}\n    ClientDocLoader(docsystems::Vector{DocSystem}) = begin\n        pages::Vector{AbstractComponent} = Vector{AbstractComponent}([generate_menu(doc_systems)])\n        new(docsystems, Dict{String, String}(), Vector{DocClient}(), pages)::ClientDocLoader\n    end\nend\n```\n\n\n이제 이 백엔드에서 프론트엔드를 구축하고 올바른 탭을 클라이언트에 제공해야 합니다. 이 모듈에서 메뉴를 구축하는 `generate_menu`로 시작하겠습니다.\n\n```js\nfunction generate_menu(mods::Vector{DocSystem})\n    menuholder::Component{:div} = div(\"mainmenu\", align = \"center\", \n    children = [begin\n        mdiv = a(string(menu_mod.name) * \"eco\", text = \"$(menu_mod.name)\")\n        style!(mdiv, \"background-color\" => menu_mod.color, \n        \"color\" => \"white\", \"font-size\" => 14pt, \"padding\" => 10px)\n        mdiv::Component{:a}\n    end for menu_mod in mods])\n    menuholder::Component{:div}\nend\n```\n\n또한 `ClientDocLoader`에 대한 `Toolips.on_start` 바인딩을 추가하여 서버가 시작될 때 단순히 그것을 Connection 데이터로 푸시합니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\nfunction on_start(ext::ClientDocLoader, data::Dict{Symbol, <:Any}, routes::Vector{<:AbstractRoute})\n    push!(data, :doc => ext)\nend\n```\n\n결국, 우리는 각 패키지를 나타내는 더 많은 하위 요소를 생성할 것이며, 이러한 요소를 클릭했을 때 표시됩니다. 또한 generate_tabbar 함수를 추가할 것입니다.\n\n```js\nfunction generate_tabbar(client::DocClient)\n\nend\n```\n\n이 함수는 DocClient를 가져와서 탭을 만들 것입니다. 이 함수를 작성하기 전에, 이 모든 것이 어떻게 함께 작동하는지에 대한 보다 명확한 이해를 얻어봅시다.\n\n<div class=\"content-ad\"></div>\n\n```js\nfunction home(c::Toolips.AbstractConnection)\n    # 들어오는 클라이언트를 확인합니다.\n    client_keys = c[:doc].client_keys\n    ip = get_ip(c)\n    if ~(ip in keys(client_keys))\n        \n    end\n    key = client_keys[ip]\n    client::DocClient = c[:doc].clients[key]\n    # 페이지를 구성합니다.\n    pages = c[:doc].pages\n    tabbar = generate_tabbar(client)\n    mainbody::Component{:body} = body(\"main\")\n    style!(mainbody, \"background-color\" => \"#333333\")\n    push!(mainbody, pages[\"mainmenu\"], tabbar)\n    write!(c, mainbody)\nend\n```\n\n이 코드는 꽤 간단한 핸들러입니다. 먼저, 클라이언트가 클라이언트 목록에 등록되었는지 확인합니다. 그렇지 않은 경우 이 조건부에 기본 데이터를 초기화하기 위한 코드가 들어갈 것입니다. 여기서 클라이언트를 로드하고 generate_tabbar를 호출합니다. tabbar와 menu라는 또 다른 변수를 body에 push!하고 Connection에 write!합니다.\n\n이것은 물론 UI를 테스트하고 작동시키기 위한 것입니다. 이제 tabbar를 만들어 봅시다. ClientDocLoader 내에서 menu를 생성하고 있음을 주목해 주세요:\n\n```js\nmutable struct ClientDocLoader <: Toolips.AbstractExtension\n    docsystems::Vector{DocSystem}\n    client_keys::Dict{String, String}\n    clients::Vector{DocClient}\n    pages::Vector{AbstractComponent}\n    ClientDocLoader(docsystems::Vector{DocSystem}) = begin\n        pages::Vector{AbstractComponent} = Vector{AbstractComponent}([generate_menu(doc_systems)])\n        new(docsystems, Dict{String, String}(), Vector{DocClient}(), pages)::ClientDocLoader\n    end\nend\n```\n\n<div class=\"content-ad\"></div>\n\n실제로 탭바부터 시작하는 게 좋을 것 같아요. 아직 메뉴를 정확히 어떻게 할지 확실하지 않으니까요.\n\n```js\nfunction home(c::Toolips.AbstractConnection)\n    # 수신 클라이언트 확인\n    client_keys = c[:doc].client_keys\n    ip = get_ip(c)\n    if ~(ip in keys(client_keys))\n        key::String = Toolips.gen_ref(4)\n        push!(client_keys, ip => key)\n        push!(c[:doc].clients, DocClient(key, [div(\"maintab\", text = \"hello world\")]))\n    end\n    key = client_keys[ip]\n    client::DocClient = c[:doc].clients[key]\n    # 페이지 구성\n    pages = c[:doc].pages\n    tabbar = generate_tabbar(client)\n    mainbody::Component{:body} = body(\"main\")\n    style!(mainbody, \"background-color\" => \"#333333\")\n    push!(mainbody, tabbar)\n    write!(c, mainbody)\nend\n```\n\n해보죠!\n\n```js\ninclude(\"dev.jl\")\n```\n\n<div class=\"content-ad\"></div>\n\n이제 간단한 백엔드가 탭 생성 및 메뉴 생성 시스템에 연결되어 있습니다. 다음으로 이 프로젝트의 프론트엔드 부분을 시작하려 합니다. 작은 본문 패널을 만들고 그 위에 탭을 배치할 것입니다.\n\n## 프론트엔드 시작하기\n\n어떻게 구성할지에 대한 아이디어를 꽤 잡았어요. 여기 내 코드 시작 부분입니다:\n\n```js\n# 페이지 구성\n페이지 = c[:doc].pages\n탭바 = generate_tabbar(client)\n메인바디::Component{:body} = body(\"main\")\n메인컨테이너::Component{:div} = div(\"main-container\")\n메인윈도우::Component{:div} = div(\"main_window\")\n왼쪽메뉴::Component{:div} = div(\"left_menu\")\nstyle!(메인바디, \"background-color\" => \"#333333\")\npush!(메인바디, 탭바)\nwrite!(c, 메인바디)\r\n```\n\n<div class=\"content-ad\"></div>\n\nleft_menu은 현재 페이지를 탐색하는 메뉴로 사용될 예정이며, main_container는 본문과 탭바를 보유할 것입니다. 나중에 대부분의 기능은 외부 함수로 추출하거나 상황에 따라 미리 만들 것입니다. 그러나 지금은 내가 원하는 대로 빠르게 이것을 작성할 수 있게 해주세요.\n\n```js\nfunction home(c::Toolips.AbstractConnection)\n    # 수신 클라이언트 확인\n    client_keys = c[:doc].client_keys\n    ip = get_ip(c)\n    if ~(ip in keys(client_keys))\n        key::String = Toolips.gen_ref(4)\n        push!(client_keys, ip => key)\n        push!(c[:doc].clients, DocClient(key, [div(\"maintab\", text = \"hello world\")]))\n    end\n    key = client_keys[ip]\n    client::DocClient = c[:doc].clients[key]\n    # 페이지 작성\n    pages = c[:doc].pages\n    mainbody::Component{:body} = body(\"main\", align = \"center\")\n    style!(mainbody, \"margin-left\" => 5percent, \"margin-top\" => 5percent, \"background-color\" => \"#333333\", \"display\" => \"flex\")\n    main_container::Component{:div} = div(\"main-container\")\n    style!(main_container, \"height\" => 80percent, \"width\" => 75percent, \"background-color\" => \"white\", \"padding\" => 0px)\n    main_window::Component{:div} = div(\"main_window\")\n    tabbar = generate_tabbar(client)\n    style!(tabbar, \"width\" => 50percent)\n    push!(main_container, tabbar, main_window)\n    left_menu::Component{:div} = div(\"left_menu\")\n    style!(left_menu, \"width\" => 20percent, \"height\" => 80percent, \"background-color\" => \"darkgray\")\n    push!(mainbody, left_menu, main_container)\n    write!(c, mainbody)\nend\n```\n\n물론 이 두 가지는 최종적으로 무한한 높이를 갖게 될 것입니다. 여기서 메뉴가 쉽게 맨 위에 올 수 있다고 생각했습니다.\n\n```js\n    # 페이지 작성\n    pages = c[:doc].pages\n    mainbody::Component{:body} = body(\"main\", align = \"center\")\n    style!(mainbody, \"margin-left\" => 5percent, \"margin-top\" => 5percent, \"background-color\" => \"#333333\", \"display\" => \"flex\", \n    \"transition\" => 1s)\n    main_container::Component{:div} = div(\"main-container\")\n    style!(main_container, \"height\" => 80percent, \"width\" => 75percent, \"background-color\" => \"white\", \"padding\" => 0px, \"display\" => \"flex\", \"flex-direction\" => \"column\", \n    \"border-bottom-right-radius\" => 5px, \"border-top-right-radius\" => 5px, \"border\" => \"2px solid #211f1f\", \"border-left\" => \"none\", \"border-top\" => \"none\")\n    main_window::Component{:div} = div(\"main_window\")\n    tabbar = generate_tabbar(client)\n    style!(tabbar, \"width\" => 50percent)\n    push!(main_container, tabbar, main_window)\n    left_menu::Component{:div} = div(\"left_menu\")\n    style!(left_menu, \"width\" => 20percent, \"height\" => 80percent, \"background-color\" => \"darkgray\", \"border-bottom-left-radius\" => 5px, \"border-top-left-radius\" => 5px)\n    push!(mainbody, pages[\"mainmenu\"], left_menu, main_container)\n    write!(c, mainbody)\nend\n```\n\n<div class=\"content-ad\"></div>\n\n제가 탭에 대해 많은 조정을 했어요:\n\n```js\nfunction generate_tabbar(client::DocClient)\n    tabholder::Component{:div} = div(\"tabs\", align = \"left\",\n    children = [begin\n        taba = a(\"tab$(tab.name)\", text = \"$(tab.name)\")\n        style!(taba, \"padding\" => 10px, \"font-size\" => 13pt, \"font-weight\" => \"bold\", \n        \"color\" => \"#333333\", \"background-color\" => \"lightgray\", \"cursor\" => \"pointer\", \n        \"border-bottom\" => \"1px solid #333333\", \"border-right\" => \"1px solid #333333\")\n        taba\n    end for (e, tab) in enumerate(client.tabs)])\n    childs = tabholder[:children]\n    style!(childs[1], \"background-color\" => \"white\", \"border-bottom\" => \"0px\", \n    \"border-top-left-radius\" => 10px)\n    style!(childs[length(childs)], \"border-top-right-radius\" => 10px)\n    tabholder::Component{:div}\nend\n```\n\n요것은 여전히 꽤 간단한데, 조금 더 잘 정리하고 싶어하지만 현재 상태에 매우 만족해요.\n\n## back-end II\n\n<div class=\"content-ad\"></div>\n\n우리는 독스트링과 마크다운을 위한 자동화된 문서화 시스템을 만들기 위해 노력 중이에요. 하지만 이를 위해 더 많은 백엔드를 구축할 필요가 있을 거예요. 이 일을 진행하기 위한 첫 번째 단계는 DocModule과 DocSystem 타입을 업데이트하여 필요한 모든 것을 확실히 갖추는 것이에요.\n\n중요한 것은 이 문서 빌더를 실제로 개방적으로 구현하고 싶다는 점이에요. 이 빌더가 Chifi 문서만 생성하는 것이 아니라, 모든 것이 문서 생성기에 로드되기를 원해요. 이에 대한 요구사항은 약간 복잡할 수 있어요. 나의 목표는 각 프로젝트의 데이터를 매핑하는 TOML 구성 파일이 필요하다는 것이죠.\n\n[chifi]\ncolor = \"white\"\ntxtcolor = \"#333333\"\nicon = \"\"\n\n[chifi.Chifi]\npath = \"toolips/Toolips\"\ncolor = \"\"\npages = [\"getting-started\", \"firstoverview.md\"]\n\n[parametric]\ncolor = \"#333333\"\ntxtcolor = \"white\"\nicon = \"\"\n\n[parametric.ParametricProcesses]\ncolor = \"#75B2C8\"\ntxtcolor = \"white\"\n\n[toolips]\ncolor = \"#75B2C8\"\ntxtcolor = \"white\"\nicon = \"\"\n\n[toolips.Toolips]\npath = \"toolips/Toolips\"\ncolor = \"\"\npages = [\"getting-started\", \"firstoverview.md\"]\n\n[toolips.ToolipsSession]\npath = \"toolips/ToolipsSession\"\ncolor = \"\"\npages = [\"nil\"]\n\n[gattino]\ncolor = \"#C178B5\"\ntxtcolor = \"white\"\nicon = \"\"\n\n[gattino.Gattino]\npath = \"gattino/Gattino\"\ncolor = \"\"\npages = [\"sample\", \"gattino.md\"]\n\n<div class=\"content-ad\"></div>\n\n다음으로 데이터를 프론트엔드에 채워 넣는 몇 가지 새로운 추가 사항.\n\n```js\nfunction generate_menu(mods::Vector{DocSystem})\n    menuholder::Component{:div} = div(\"mainmenu\", align = \"center\", \n    children = [begin\n        mdiv = a(string(menu_mod.name) * \"eco\", text = \"$(menu_mod.name)\")\n        style!(mdiv, \"background-color\" => menu_mod.color, \n        \"color\" => \"white\", \"font-size\" => \"20pt\", \"padding\" => \"14px\", \"font-weight\" => \"bold\")\n        mdiv::Component{:a}\n    end for menu_mod in mods])\n    style!(menuholder, \"position\" => \"absolute\", \"top\" => \"-100\", \"left\" => \"0\", \"width\" => \"100%\", \"height\" => \"0px\", \n    \"transition\" => \"800ms\")\n    menuholder::Component{:div}\nend\n\nfunction generate_menu(dm::Vector{DocModule})\n    \nend\n\nfunction switch_tabs!(c::AbstractConnection, cm::ComponentModifier, t::String)\n\nend\n\nfunction generate_tabbar(c::AbstractConnection, client::DocClient)\n    tabholder::Component{:div} = div(\"tabs\", align = \"left\",\n    children = [begin\n        labelname = join(split(tab.name, \"-\")[2:3], \" | \")\n        taba = a(\"tab$(tab.name)\", text = \"$labelname\")\n        style!(taba, \"padding\" => \"10px\", \"font-size\" => \"13pt\", \"font-weight\" => \"bold\", \n        \"color\" => \"#333333\", \"background-color\" => \"lightgray\", \"cursor\" => \"pointer\", \n        \"border-bottom\" => \"1px solid #333333\", \"border-right\" => \"1px solid #333333\")\n        on(c, taba, \"click\") do cm::ComponentModifier\n            switch_tabs!(c, cm, tab.name)\n        end\n        taba\n    end for (e, tab) in enumerate(client.tabs)])\n    childs = tabholder[:children]\n    style!(tabholder, \"width\" => \"50%\")\n    style!(childs[1], \"background-color\" => \"white\", \"border-bottom\" => \"0px\", \n    \"border-top-left-radius\" => \"10px\")\n    style!(childs[length(childs)], \"border-top-right-radius\" => \"10px\")\n    return(tabholder, client.tabs[1].name)\nend\n\nfunction build_main(c::AbstractConnection, client::DocClient)\n    tabbar, docname = generate_tabbar(c, client)\n    main_container::Component{:div} = div(\"main-container\", children = [tabbar, div(\"main_window\")])\n    style!(main_container, \"height\" => \"80%\", \"width\" => \"75%\", \"background-color\" => \"white\", \"padding\" => \"0px\", \"display\" => \"flex\", \"flex-direction\" => \"column\", \n    \"border-bottom-right-radius\" => \"5px\", \"border-top-right-radius\" => \"5px\", \"border\" => \"2px solid #211f1f\", \"border-left\" => \"none\", \"border-top\" => \"none\")\n    return(main_container::Component{:div}, docname)\nend\n\nfunction build_leftmenu(c::AbstractConnection, mod::DocModule)\n    [begin \n        pagename = page.name\n        openbutton = button(\"open-$pagename\", text = \"open\")\n        labela = a(\"label-$pagename\", text = replace(pagename, \"-\" => \" \"))\n        pagemenu = div(\"pagemenu\", text = \"\")\n    end for page in mod.pages]\n    left_menu::Component{:div} = div(\"left_menu\")\n    style!(left_menu, \"width\" => \"20%\", \"height\" => \"80%\", \"background-color\" => \"darkgray\", \"border-bottom-left-radius\" => \"5px\", \"border-top-left-radius\" => \"5px\")\n    left_menu::Component{:div}\nend\n\nfunction home(c::Toolips.AbstractConnection)\n    # 수신된 클라이언트 확인\n    client_keys::Dict{String, String} = c[:doc].client_keys\n    ip::String = get_ip(c)\n    if ~(ip in keys(client_keys))\n        key::String = Toolips.gen_ref(4)\n        push!(client_keys, ip => key)\n        push!(c[:doc].clients, DocClient(key, [div(\"chifi-welcome-Chifi\")]))\n    end\n    key = client_keys[ip]\n    client::DocClient = c[:doc].clients[key]\n    # 페이지 작성\n    pages = c[:doc].pages\n    mainbody::Component{:body} = body(\"main\", align = \"center\")\n    style!(mainbody, \"margin-left\" => \"5%\", \"margin-top\" => \"5%\", \"background-color\" => \"#333333\", \"display\" => \"flex\", \n    \"transition\" => \"1s\")\n    main_container::Component{:div}, mod::String = build_main(c, client)\n    ecopage = split(mod, \"-\")\n    @info [docmod.name for docmod in c[:doc].docsystems]\n    @info [docmod.name for docmod in c[:doc].docsystems[\"toolips\"].modules]\n    loaded_page = c[:doc].docsystems[string(ecopage[1])].modules[string(ecopage[3])]\n    left_menu = build_leftmenu(c, loaded_page)\n    push!(mainbody, pages[\"mainmenu\"], left_menu, main_container)\n    write!(c, mainbody)\nend\ndocloader = ClientDocLoader()\n\nfunction start_from_project(path::String = pwd(), mod::Module = Main; ip::Toolips.IP4 = \"127.0.0.1\":8000)\n    docloader.docsystems = read_doc_config(path * \"/config.toml\", mod)\n    start!(ChifiDocs, ip)\nend\r\n```\n\n<div class=\"content-ad\"></div>\n\n@info에 대한 몇 가지 호출도 있습니다. 이는 데이터가 올바르게 로드되었는지 확인하기 위한 점검입니다. 웹 브라우저를 통해 요청을 보냅니다.\n```js\njulia> include(\"dev.jl\")\n  `~/dev/packages/chifi/ChifiDocs`에서 프로젝트를 활성화 중\n[ Info: ChifiDocs [4e841206-9f20-48d9-9ddd-dfd252355962] 사전 컴파일 중\n  `~/dev/packages/chifi/ChifiDocs/chifi`에서 프로젝트를 활성화 중\n┌ Warning: ParametricProcesses에 경로가 없어 건너뛰었습니다\n└ @ ChifiDocs ~/dev/packages/chifi/ChifiDocs/src/DocMods.jl:62\n🌷 toolips> 로드된 라우터 유형: Vector{Toolips.Route{Toolips.AbstractConnection}\n🌷 toolips> 서버가 http://192.168.1.10:8000 에서 수신 대기 중\n      활성 매니페스트 파일: 7개 발견됨\n      활성 아티팩트 파일: 2개 발견됨\n      활성 스크래치 공간: 0개 발견됨\n     삭제된 아티팩트, 리포지토리, 패키지 또는 스크래치 공간 없음\n[ Info: 수신 대기 중: 192.168.1.10:8000, 스레드 id: 1\n   pid              process type             name active\n  –––– ––––––––––––––––––––––––– –––––––––––––––– ––––––\n  1736 ParametricProcesses.Async ChifiDocs router   true\n\n\njulia> [ Info: [\"gattino\", \"parametric\", \"toolips\", \"chifi\"]\n[ Info: [\"ToolipsSession\", \"Toolips\"]\r\n```\n\n마지막으로 언급할 가치가 있는 것은 이 프로젝트의 설정이 실제로 어떻게 로드되는지입니다. 이 프로젝트에는 두 개의 별도 환경이 있습니다. 하나는 문서화할 모듈을 포함하고 다른 하나는 ChifiDocs 빌드에 필요한 종속성을 포함합니다. 전자는 chifi 아래에 포함되어 있습니다. 또한 이 프로젝트에는 각 생태계를 문서화하기 위한 마크다운 및 에셋이 포함되어 있습니다. 자동 빌드 문서 참조와 기타 자동으로 빌드되는 기능을 원하지만 새로운 튜토리얼 문서를 작성하고 제공할 수 있는 능력도 원합니다.\n```js\nshell> tree .\n.\n├── chifi\n│   ├── components.jl\n│   ├── config.toml\n│   ├── getting_started.md\n│   ├── Manifest.toml\n│   ├── modules\n│   │   ├── chifi\n│   │   ├── gattino\n│   │   │   └── Gattino\n│   │   │       └── Gattino.md\n│   │   ├── parametric\n│   │   │   └── ParametricProcesses\n│   │   │       └── ParametricProcesses.md\n│   │   └── toolips\n│   │       ├── Toolips\n│   │       │   └── GettingStarted.md\n│   │       └── ToolipsSession\n│   │           └── ToolipsSession.md\n│   ├── Project.toml\n│   └── public\n├── dev.jl\n├── Manifest.toml\n├── Project.toml\n└── src\n    ├── ChifiDocs.jl\n    └── DocMods.jl\n\n13 directories, 14 files\n```\n\n<div class=\"content-ad\"></div>\n\n여기가 내 dev.jl 파일이에요:\n\n```julia\nusing Pkg; Pkg.activate(\".\")\nusing ChifiDocs\nPkg.activate(\"chifi\")\nusing Revise\ninclude(\"chifi/components.jl\")\ntoolips_process = ChifiDocs.start_from_project(\"chifi\", ChifiDocComponents, ip = \"192.168.1.10\":8000)\n```\n\n그리고 마지막으로 components.jl 파일이에요. 그 파일이 존재하는 이유에 대해 설명하겠습니다.:\n\n```julia\n#== components.jl ==\n`components.jl`은 이 프로젝트에 특화된 특별한 소스 파일이에요. 이 파일은 dev.jl에서 불러와서 사용되며, 마크다운 문서 페이지에 사용자 정의 구성 요소를 작성하고, 문서 페이지에서 사용할 종속성을 로드할 수 있게 해줘요.\n`components.jl` 파일에서는 오직 구성 요소만 내보내야 하며, 이름으로 보간하여 마크다운에서 $를 사용하거나, Julia에서 'interpolate!' 또는 'interpolate_code!'를 사용해야 해요.\n`$`.\n==#\nmodule ChifiDocComponents\nusing Toolips\nusing ToolipsSession\nusing Gattino\n\nmodule Chifi\n\nend\nend\n```\n\n<div class=\"content-ad\"></div>\n\n올 해 제 소프트웨어가 상당히 즐거운 수준에 이르렀어요. Toolips는 함께 작업하기 좋은 웹 개발 프레임워크입니다. Gattino는 이제 사용할 준비가 되었고 두 생태계는 새로운 생태계 추가와 함께 미래의 생태계를 보고 있어요. 그동안 저는 좋은 문서가 필요했었는데, 이제 내가 직접 만들기로 결심했어요.\n\n이 프로젝트는 어느 정도 시간이 걸리겠지만, 최대한 늦어도 6월 말에는 이 문서 브라우저를 공개할 계획이에요 — 많은 기대할 만한 릴리스들과 함께. 곧 다시 다른 생태계와 함께 일할 예정이고, 제 주요 프로젝트인 Olive에 대해 고민해보려 해요. 이미 일부 예비 작업을 시작했는데, IPyCells를 수정하고, OliveHighlighters 패키지를 만들어 하이라이터를 패키징했어요. 그러나 아직 많은 작업이 남아있지만 계속해서 진전을 이뤄가고 그 점이 고맙습니다. 제 진전을 계속 지켜보고 다양한 프로젝트에 관심을 가져주셔서 감사합니다. 올해에는 많은 것들이 더 나아져가고, 올해 말에 제가 더 많은 것들을 제공할 기회를 손에 쥐게 될 것을 기대하고 있어요. 이 프로젝트를 계속할 때 왼쪽 메뉴에 항목을 채우고 내용 영역에 마크다운을 추가할 것이에요. 읽어주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-06-19-CreatingMyNewAutomatedDocumentationWithToolips_0.png"},"coverImage":"/assets/img/2024-06-19-CreatingMyNewAutomatedDocumentationWithToolips_0.png","tag":["Tech"],"readingTime":19},{"title":"리액트에서의 시그널 사용 방법과 사용하지 말아야 하는 이유","description":"","date":"2024-06-19 00:25","slug":"2024-06-19-SignalsinReactHowtoUseThemandWhyYouShouldnt","content":"\n\n<img src=\"/assets/img/2024-06-19-SignalsinReactHowtoUseThemandWhyYouShouldnt_0.png\" />\n\n# 소개\n\n시그널은 본질적으로 반응형 값 홀더로, 값이 변경될 때 해당 값에 종속된 계산 또는 효과를 자동으로 업데이트합니다. 이 방식은 SolidJS와 Angular와 같은 현대 웹 프레임워크에서 특히 유용하며, React의 상태(state) 및 훅(hooks)과 같은 기존 방법보다 상태(state) 및 반응성 관리를 더 효과적으로 지원합니다. 예를 들어, SolidJS에서 시그널을 생성하고 해당 값을 사용하여 업데이트를 트리거할 수 있습니다.\n\n## ECMAScript에 시그널 추가를 위한 공식 제안\n\n<div class=\"content-ad\"></div>\n\nECMAScript 언어의 진화를 감독하는 TC39 위원회가 JavaScript에 새로운 기능으로 신호를 추가하기 위한 공식 제안을 하였습니다. 이 제안은 신호 개념을 표준화하여 언어 내에서 섬세한 반응성을 활성화하는 것을 목표로 합니다. 제안된 API에는 Signal.subtle.Watcher와 같은 여러 신호를 생성하고 관리하는 방법이 포함되어 있어, 개발자들이 신호의 변화를 감지하고 적절히 반응할 수 있도록 합니다.\n\n제안에 대한 자세한 내용은 TC39 위원회가 관리하는 GitHub 리포지토리를 참조하세요.\n\n# 신호의 장점\n\n자동 의존성 추적: 신호는 자동 의존성 추적을 제공하며, 신호의 값이 변경될 때마다 해당 신호에 의존하는 반응형 계산 또는 효과가 자동으로 업데이트됩니다. 이는 수동으로 의존성을 관리하는 것을 제거하여 코드를 단순화하고 오류를 줄이는 것을 의미합니다.\n\n<div class=\"content-ad\"></div>\n\n게으른 평가: 시그널은 필요할 때만 계산을 수행하여 성능을 향상시키는 게으른 평가를 지원합니다. 이를 통해 계산은 결과가 필요할 때에만 수행됩니다.\n\n메모이제이션: React Signals와 마찬가지로 Solid.JS는 비용이 많이 드는 계산의 결과를 캐시함으로써 동일한 입력이 다시 발생할 때 이를 재사용하여 성능을 향상시킵니다.\n\n그래, 이것이 잘 정립된 반응성의 메커니즘입니다. 그런데 UI에서는 어떻게 작용할까요? Solid.JS에서는 이것이 어떻게 작동하는지 살펴봅시다.\n\nSolidJS에서 JSX 컴포넌트는 시그널 값이 변경될 때마다 DOM 노드를 생성하고 업데이트하는 효과로 컴파일됩니다. 다음은 예시 컴포넌트와 그 컴파일된 출력입니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { createSignal } from 'solid-js';\n\nexport const Counter = () => {\n  const [count, setCount] = createSignal(0);\n  return <div>{count()}</div>;\n};\n\n// Compiled output\nimport { createSignal } from 'solid-js';\nimport { template as _$template } from \"solid-js/web\";\nimport { insert as _$insert } from \"solid-js/web\";\n\nconst _tmpl$ = /*#__PURE__*/_$template(`<div></div>`, 2);\n\nexport const Counter = () => {\n  const [count, setCount] = createSignal(0);\n  return (() => {\n    const _el$ = _tmpl$.cloneNode(true);\n    _$insert(_el$, count);\n    return _el$;\n  })();\n};\n```\n\n\n\n컴파일된 출력 내용에서:\n\n- _tmpl$은 컴포넌트의 DOM 구조를 위한 템플릿을 생성합니다.\n- cloneNode은 템플릿을 복제합니다.\n- _insert는 값을 채워넣고 반환된 DOM 요소를 부모 DOM 요소에 삽입합니다.\n\n## 렌더링에서 함수 감싸기\n\n\n<div class=\"content-ad\"></div>\n\n컴포넌트를 렌더링할 때, SolidJS는 신호 의존성의 적절한 설정을 보장하기 위해 함수를 전달해야 합니다. 이렇게 함으로써 의존성의 적절한 관리와 정리를 보장할 수 있습니다:\n\n```js\nimport { render } from 'solid-js/web';\nconst dispose = render(() => <App />, document.getElementById(\"app\"));\n```\n\n그래서 코드에 console.log가 있는 경우, 한 번 실행된 후 반응성 시스템이 작동합니다:\n\n## JavaScript에서 신호에 대한 메커니즘\n\n<div class=\"content-ad\"></div>\n\n시그널은 Pub-Sub (Publish-Subscribe), Observer 및 이벤트 주도 아키텍처와 같은 확립된 패턴을 기반으로 합니다. 각 패턴은 구성 요소를 분리하고 반응적이고 민첩한 시스템을 가능하게 하지만 고유한 방식으로 이러한 목표를 달성합니다.\n\nPub-Sub 패턴: 구성 요소는 중앙 이벤트 버스를 통해 통신하여 발신자와 수신자를 분리합니다.\nObserver 패턴: 객체(주체)는 상태 변경에 대해 알림을 보내는 의존 객체(옵저버) 목록을 유지합니다.\n이벤트 주도 아키텍처: 구성 요소 또는 서비스가 이벤트를 발생시키고 다른 구성 요소가 이를 청취하고 반응합니다.\n\n이러한 것들은 기본적으로 행동과 반응의 아이디어입니다. 시그널은 이러한 패턴에서 요소를 빌려와 세밀한 반응성을 향상시킵니다.\n\n# 성능 및 자동 종속성 관리\n\n<div class=\"content-ad\"></div>\n\n상태 관리에서 가능한 가장 낮은 노드 또는 리프에 구독하는 것은 상태의 가장 작고 가장 세분화된 조각에 집중하는 것을 의미합니다. 이는 상태가 변경될 때 다시 렌더링하거나 다시 계산해야 하는 횟수를 줄여 성능을 크게 향상시킬 수 있습니다. 전체 구성 요소 또는 데이터 구조를 변경할 필요가 없이 일부분이 변경될 때 영향을 받는 구성 요소나 데이터만 업데이트되기 때문입니다.\n\n## 학생 객체를 이용한 예제\n\n학생 객체에는 이름, 성, 그리고 아바타라는 속성이 있습니다. 전체 학생 객체를 구독하는 대신 각 속성을 개별적으로 구독할 수 있습니다.\n\n```js\nfunction Name() {\n  const studentName = useSelector((state) => state.student.name);\n  return <p>{studentName}</p>;\n}\n\nfunction LastName() {\n  const studentLastName = useSelector((state) => state.student.lastname);\n  return <p>{studentLastName}</p>;\n}\n\nfunction Avatar() {\n  const avatar = useSelector((state) => state.student.avatar);\n  return <img src={avatar} />;\n}\n\nfunction StudentExample() {\n  return (\n    <div>\n      <Name/>\n      <LastName/>\n      <Avatar/>\n    </div>\n  );\n}\n\nexport default StudentExample;\n```\n\n<div class=\"content-ad\"></div>\n\n위의 예시에서 이름만 변경될 경우 Name 구성요소만 다시 렌더링되며 StudentExample 전체가 다시 렌더링되지는 않습니다. 이 타겟팅된 반응성은 불필요한 업데이트를 최소화하여 성능을 향상시킵니다.\n\nSolid.JS에서는 그런 게 필요없어요. 이름이 바뀌었어요? 실제 DOM의 내부 HTML 내용만 다시 렌더링돼요!\n\n성능 측면에서 보면, 기본적으로 제공되는 기능은 아니지만 React 애플리케이션에서는 우리가 제어할 수 있는 부분이에요.\n\n## 자동 의존성 관리\n\n<div class=\"content-ad\"></div>\n\n개발자들이 열광하는 또 다른 큰 변화는 자동 의존성 관리입니다. 이에 대해 자세히 설명하지는 않겠지만, 우리 리액트 개발자들은 useEffect와 useMemo의 의존성을 지정하기 지겨워합니다. 리액트 팀은 몇 년간 React Forget Compiler에 대해 얘기해 왔고, 이제 React 19부터 드디어 사용할 수 있습니다.\n\n# 리액트의 시그널(Signals)\n\n따라서 우리는 Signals가 일종의 발행-구독 메커니즘임을 명확히 이해하게 됩니다. 다행히도, 우리를 위해 React에는 외부(리액트 메커니즘 외부) 데이터를 구독할 수 있는 훅이 있습니다. 바로 `useSyncExternalStore`입니다.\n\n`useSyncExternalStore`는 외부 스토어를 구독할 수 있게 해주는 리액트 훅입니다.\n\n<div class=\"content-ad\"></div>\n\n## 매개변수\n\n- subscribe: 단일 콜백 인수를 허용하고 그것을 저장소에 구독하는 함수입니다. 저장소가 변할 때 제공된 콜백을 호출해야 합니다. 이로써 컴포넌트가 다시 렌더링됩니다. subscribe 함수는 구독을 정리하는 함수를 반환해야 합니다.\n- getSnapshot: 컴포넌트에서 필요한 저장소 데이터의 스냅샷을 반환하는 함수입니다. 저장소가 변경되지 않는 동안, getSnapshot에 대한 반복 호출은 동일한 값을 반환해야 합니다. 저장소가 변경되고 반환된 값이 다른 경우(객체의 동등성 비교로 확인), React는 컴포넌트를 다시 렌더링합니다.\n\n우리는 useSignal 훅을 구성하는 것부터 시작해봅시다.\n\n```js\nfunction useSignal<S>(\n  signal: [Accessor<S>, Setter<S>]\n): [S, Dispatch<SetStateAction<S>>] {\n  const [value, setter] = signal;\n  const storeValue = useSyncExternalStore<S>(subscribe, value);\n\n  const setState: Dispatch<SetStateAction<S>> = useCallback(\n    (action: SetStateAction<S>) => {\n      if (typeof action === 'function') {\n        setter((action as (prevState: S) => S)(value()) as any);\n      } else {\n        setter(action as any);\n      }\n    },\n    []\n  );\n\n  return [storeValue, setState];\n}\n```\n\n<div class=\"content-ad\"></div>\n\n우리의 후크는 React 외부에서 만들어진 신호를 받고, 그 값을 useSyncExternalStore로 전달합니다. useSyncExternalStore는 데이터의 '스냅샷'을 반환하는 함수이며 값이 변경될 때마다 실행되는 subscribe 함수를 반환합니다.\n\n문제는 Solid.JS가 모든 것이 렌더링 함수 또는 createRoot 아래에서 실행되어야 한다고 기대한다는 것입니다. 내부적으로 Solid는 \"소유자 스코프\"를 만들어 사용합니다.\n\n내부적으로 계산 (effects, memos 등)은 소유자를 만들며 해당 소유자의 하위 소유자로 생성됩니다. 이 소유권 트리는 Solid가 자동으로 dispose된 계산을 클린업하도록 해주며, 계산이 dispose될 때 하위 트리를 탐색하여 모든 onCleanup 콜백을 호출합니다. createEffect의 종속성이 변경되면 예를 들어, effect는 모든 하위 onCleanup 콜백을 호출한 후에 다시 effect 함수를 실행합니다. getOwner를 호출하면 현재 실행 블록의 폐기를 담당하는 현재 소유자 노드를 반환합니다.\n\n<div class=\"content-ad\"></div>\n\n최종 결과를 확인해봐요:\n\n# 리액트에서 사용하지 말아요. 아직 그렇지 마요.\n\nSignals를 React에서 사용하는 도중에 마주치게 될 도전과 잠재적인 단점을 자세히 살펴봅시다.\n\n1. 호환성 및 통합 문제:\n\n<div class=\"content-ad\"></div>\n\n- 라이프사이클 불일치: React와 SolidJS는 서로 다른 라이프사이클 관리 메커니즘을 가지고 있습니다. React는 부작용 관리를 위해 useEffect와 같은 훅에 의존하는 반면, SolidJS는 createEffect와 소유자 기반 정리를 사용합니다. 이러한 불일치는 React에 신호를 통합할 때 문제를 발생시킬 수 있습니다. 이것은 구독 함수를 설정하는 복잡성에서 확인할 수 있습니다.\n- 범위 및 소유권: SolidJS의 반응형 계산을 위한 소유자 범위는 React의 컴포넌트 라이프사이클과 직접적으로 매핑되지 않아 적절한 정리 및 메모리 누수 방지에 도전이 있을 수 있습니다.\n\n2. 성능 부하:\n\n- 반응성 시스템의 차이: React의 가상 DOM 차이 비교 및 조정 프로세스는 SolidJS의 세심한 반응성과 다릅니다. React에서 신호를 사용하면 이러한 차이로 인해 추가 부하가 발생할 수 있으며, 이로 인해 성능 이점이 상쇄될 수 있습니다.\n- 브릿지 코드 복잡성: React의 상태 관리와 SolidJS 신호 사이의 브릿지를 구현하려면 여분의 코드와 복잡성이 필요합니다. 이는 유지 관리성과 성능에 영향을 미칠 수 있습니다.\n\n3. 개발자 경험:\n\n<div class=\"content-ad\"></div>\n\n- 학습 곡선: React 및 SolidJS의 반응성 모델을 모두 이해해야만 React 내에서 신호를 효과적으로 사용할 수 있습니다. 이 이중 이해는 도전적일 수 있고 개발 초기에 개발 속도를 늦출 수 있습니다.\n- 디버깅 및 도구: 두 가지 다른 시스템을 결합할 때 반응적 업데이트를 디버깅하고 반응성 흐름을 이해하는 것은 더 복잡해질 수 있으며, 버그를 진단하고 해결하는 데 문제가 발생할 수 있습니다.\n\n4. 생태계 및 커뮤니티 지원:\n\n- 제한된 생태계 지원: React 생태계는 많은 라이브러리와 도구가 React의 반응성 모델에 특별히 설계되어 있어 광범위합니다. 신호를 통합하면 이러한 도구의 사용이 제한될 수 있거나 추가적인 해결책이 필요할 수 있습니다.\n- 커뮤니티 관행: React 커뮤니티는 주로 훅 및 상태 관리에 대한 확립된 관행을 따릅니다. 신호를 도입하면 코드베이스에서 팀 환경을 포함해서 단편화와 일관성에 이르기까지 다양한 문제가 발생할 수 있습니다.\n\n하루의 끝에, Signal의 복잡한 객체가 있다면 해당 데이터를 React에 첨부할 때 렌더링은 로컬 상태를 만든 것과 같습니다. 모든 하향식 탐색은 전체 React 트리를 다시 렌더링하게 만들어서 사실상 '세밀한' 반응성을 요소 수준에서 달성할 수 없습니다.\n\n<div class=\"content-ad\"></div>\n\n# 앞으로 나아가는 길\n\n현재, 시그널은 React, React의 병행성, 그리고 컴파일러 메커니즘에서 명확한 위치가 없습니다. 현재 React에서 시그널을 구현하는 것은 쉬운 일일 것입니다.\n\n## 다른 사고 방식 — 제어 흐름 대 데이터 흐름\n\nReact 이전에는 개발자들이 UI를 초기화하고 업데이트하는 데 별도의 로직을 작성했으며, 이로 인해 일관성이 떨어지기도 했습니다. React는 이를 단순화하여 UI가 초기화와 업데이트 사이에서 일관되게 유지되도록 보장합니다. React는 컴포넌트 함수를 다시 실행하고 UI를 최신 상태로 업데이트하여 사용자가 올바른 상태를 확인할 수 있도록 합니다. 이로써 컴포넌트가 처음 나타났는지 업데이트되었는지에 관계없이 사용자가 올바른 상태를 볼 수 있게 됩니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nfunction StudentList({ students, emptyHeading }) {\n  const count = students.length;\n  let heading = emptyHeading;\n  if (count > 0) {\n    const noun = count > 1 ? '학생들' : '학생';\n    heading = count + ' ' + noun;\n  }\n  return <h1>{heading}</h1>;\n}\n```\n\nReact에서는 데이터를 가져와 결정을 내리고 입력을 형식화하여 템플릿에 삽입하는 렌더링 로직을 작성합니다. 이 로직은 초기화 및 업데이트에서 모두 실행되어 UI가 데이터와 동기화된 채로 유지되도록 합니다.\n\nSolid는 템플릿에서 특정 \"구멍(holes)\"만 반응적인 방식으로 다루는 다른 방식을 취합니다. 이는 렌더링 로직에 대해 최상위 제어 흐름을 의존할 수 없다는 것을 의미합니다. 대신 개별 값 주위에 코드를 구조화해야 합니다:\n\n```js\nfunction StudentList(props) {\n  const count = () => props.students.length;\n  const heading = () => {\n    if (count() > 0) {\n      const noun = count() > 1 ? \"학생들\" : \"학생\";\n      return count() + \" \" + noun;\n    } else {\n      return props.emptyHeading;\n    }\n  }\n  return <h1>{heading()}</h1>;\n}\n```\n\n<div class=\"content-ad\"></div>\n\n리액트는 컴포넌트 함수 내에서 if 문과 같은 제어 흐름을 사용할 수 있어 더 많은 로직을 추가하기 쉽게 해줍니다. 반면 솔리드에서는 각 반응형 함수 내에서 조건을 복제해야 합니다 (if(count() ` 0).\n\n두 세계의 장점을 결합하는 것이 목표입니다. 리액트의 간단한 제어 흐름과 솔리드의 성능 최적화를 함께 사용하는 상상을 해보세요. 이렇게 하면 개발자들이 수동 최적화에 대해 걱정하지 않고 명확하고 유지보수 가능한 코드를 작성할 수 있게 될 것입니다.\n\n향후 컴파일러가 코드를 최적화하여 수동 재구성 없이 유사한 성능을 달성할 것을 희망합니다. 이를 통해 리액트의 간편함과 솔리드의 효율성을 함께 얻을 수 있을 것입니다.\n\n# 요약\n\n<div class=\"content-ad\"></div>\n\n신호는 성능 및 자동 종속성 관리 측면에서 중요한 이점을 제공하지만, React에 완벽하게 맞지는 않습니다. 수명주기 관리, 반응성 시스템, 그리고 제어 흐름 대 데이터 흐름이라는 마인드셋의 차이가 있습니다. 지금 당장은 React 개발자로써 기존 도구를 숙달하는 데 집중하고, 희망적으로 React와 SolidJS의 각각의 장점을 결합할 수 있는 잠재적인 미래 개선 사항을 기다릴 필요가 있습니다.","ogImage":{"url":"/assets/img/2024-06-19-SignalsinReactHowtoUseThemandWhyYouShouldnt_0.png"},"coverImage":"/assets/img/2024-06-19-SignalsinReactHowtoUseThemandWhyYouShouldnt_0.png","tag":["Tech"],"readingTime":10},{"title":"나의 Micro SaaS를 위해 99 시간동안 사용하는 기술 스택","description":"","date":"2024-06-19 00:23","slug":"2024-06-19-TechstackthatIuseforMicroSaaS99ofthetime","content":"\n\n현재 많은 기술이 사용 가능하며, 매달 새로운 JS 프레임워크가 출시됩니다. 때로는 처음부터 올바른 기술 스택을 선택하지 않으면 나중에 확장하기 어려울 수 있습니다. 그래서 오늘의 글에서는 제가 Micro SaaS를 개발하는 데 사용하는 기술과 스택을 공유하겠습니다.\n\n하지만 시작하기 전에 제가 쓴 \"SaaS 건설을 위한 치트 코드\"라는 책을 공유하고 싶습니다. 이 책은 성공적인 SaaS 기초를 구축하고 운영하기 위해 필요한 모든 요구 사항과 단계를 강조합니다.\n\n저는 프론트엔드 개발, 백엔드 개발, 데이터베이스, 결제, 클라우드, 보안으로 모든 것을 세분화하여 이해하기 쉽도록 했습니다. 모두 한 가지씩 확인해보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n# 프론트엔드 개발\n\n프론트엔드 개발에서는 대부분 Vite와 React JS를 사용하는 것을 선호합니다. 때로는 Next JS를 사용하여 프로젝트를 구성하기도 합니다. 그러나 대부분의 프로젝트에서 window, location 등과 같은 네이티브 JS 라이브러리가 필요합니다.\n\n또한 간편함을 위해 MUI에서 미리 만들어진 템플릿을 사용하여 많은 시간을 절약했습니다. 저는 프론트엔드에 능숙하지 않으며 SaaS의 MVP 버전을 만들고 아이디어를 검증하고 싶어합니다. 모든 것이 순조롭고 SaaS가 잠재력을 가지고 있다고 느낄 때 스타일링을 더 발전시킬 수 있습니다.\n\n![image](/assets/img/2024-06-19-TechstackthatIuseforMicroSaaS99ofthetime_1.png)\n\n<div class=\"content-ad\"></div>\n\n대부분의 경우에는 개발 중에 ESLint의 체크를 비활성화합니다. 원하는 경우 체크를 유지하여 깨끗하고 좋은 코드를 작성할 수 있습니다.\n\n# Backend Development\n\n이제 백엔드 개발에서, 많은 기능을 갖춘 복잡한 SaaS 프로젝트를 구축할 때 Nest JS를 사용하게 될 것입니다. Nest JS는 Express JS의 심화 버전입니다.\n\n![이미지](/assets/img/2024-06-19-TechstackthatIuseforMicroSaaS99ofthetime_2.png)\n\n<div class=\"content-ad\"></div>\n\n프레임워크는 Express JS를 사용하는 것보다 신뢰성이 높고 확장성이 더 좋아요. 하지만 기능이 적은 SaaS를 개발 중이거나 Micro SaaS를 개발 중이라면 Node JS - Express JS 프레임워크를 사용해 볼 수 있어요. \n\n저는 Micro SaaS에서 코드를 작성할 때 JS를 선호하고, 기능이 많고 Micro SaaS보다 큰 프로젝트에는 TypeScript를 사용하곤 해요. \n\n가끔 CRUD 작업을 빠르게 처리하고 시간을 절약하기 위해 Strapi와 같은 헤드리스 CMS도 사용해요.\n\n![TechstackthatIuseforMicroSaaS99ofthetime_3.png](/assets/img/2024-06-19-TechstackthatIuseforMicroSaaS99ofthetime_3.png)\n\n<div class=\"content-ad\"></div>\n\n또한 Stripe와 Mailchimp와 같은 다른 써드 파티와의 통합을 제공하여 작업과 시간을 절약할 수 있습니다.\n\n# 데이터베이스\n\n데이터베이스로는 대부분의 프로젝트에 MongoDB를 사용하고, 사용자 활동을 수집해야 하는 경우에는 PostgreSQL을 선호합니다.\n\n캐싱이 필요한 경우 Redis를 사용하며, PlanetScale, Redis.com, MongoDB.com과 같은 공급업체에서 데이터베이스를 구하고, Kafka와 같은 큐 서비스가 필요한 경우에는 Upstash를 선호합니다.\n\n<div class=\"content-ad\"></div>\n\n# 결제\n\n구독과 결제에 대해서는 항상 Stripe를 사용합니다. 더 복잡한 세금 문서 작성이 필요하다면, Lemon Squeezy를 사용해보실 수도 있어요. 저는 지난 프로젝트에서 사용해보았는데 도움이 되었어요.\n\n# 호스팅 및 배포\n\n저는 좋은 DevOps 엔지니어가 아니기 때문에, 배포에는 Heroku, Render, 그리고 Firebase와 같은 플랫폼을 주로 사용하는 편입니다.\n\n<div class=\"content-ad\"></div>\n\n저는 클라이언트의 대규모 프로젝트를 처리할 때 Azure와 GCP를 사용해 왔습니다. 이 프로젝트들에는 그들의 크레딧도 함께 사용했습니다.\n\n하지만 여러분의 SaaS 제품이 MVP 단계이고 복잡한 아키텍처가 필요하지 않다면, 프론트엔드 배포에는 Vercel이나 Netlify, API/백엔드 배포에는 Heroku나 Render, 클라우드 스토리지에는 Wasabi, 그리고 서버리스에는 Firebase Cloud Function이나 Vercel Edge Functions를 사용해 볼 수 있습니다. Azure나 AWS보다 덜 복잡하며 모든 것을 한 곳에서 관리하고 싶다면 Digital Ocean도 좋은 선택입니다.\n\nAI 모델 및 배포에 대해서는 Runpod를 선호합니다.\n\n<div class=\"content-ad\"></div>\n\n이외에 오픈 AI API를 사용하고 싶다면, Azure에서 크레딧을 사용하여 사용할 수도 있습니다. 또는 다른 재구축 모델을 사용하려면 Together.ai를 사용합니다.\n\n# 보안\n\n내 SaaS의 보안을 위해서는 먼저 데이터베이스가 공개되지 않도록 해야 합니다. 그리고 주로 보안을 위해 Cloudflare를 사용하여 SaaS를 다양한 공격과 침투로부터 보호합니다.\n\n이외에도 로그인 및 모니터링을 위해 NewRelic 및 Site 24x7을 사용하여 로그와 알림을 유지합니다. 또한 SaaS의 로그 및 알림을 관리하고자 한다면, 제 블로그의 글을 자유롭게 확인해주세요.\n\n<div class=\"content-ad\"></div>\n\n이것은 여러분이 따를 수 있는 기술 스택에 대한 좋은 아이디어를 줄 수 있지만, SaaS에 대한 기술 요구 사항을 잘 조사한 후에 어떤 결정을 내리기 전에 꼭 확인하세요.\n\n그리고, 만약 마케팅에 관해 깊이 파고들고 SaaS에 장기적인 유료 사용자를 확보하는 방법을 알고 싶다면, \"SaaS 성장을 위한 마케팅 전략\"이라는 제 책을 읽어보세요. 이 책은 SaaS를 처음부터 시작하여 실제 유료 사용자들을 확보하는 데 도움이 되는 필요한 모든 단계와 전략을 깊이 있게 다룰 것입니다.","ogImage":{"url":"/assets/img/2024-06-19-TechstackthatIuseforMicroSaaS99ofthetime_0.png"},"coverImage":"/assets/img/2024-06-19-TechstackthatIuseforMicroSaaS99ofthetime_0.png","tag":["Tech"],"readingTime":4},{"title":"지금 익히면 좋은 잘 알려지지 않은 CSS 기능들","description":"","date":"2024-06-19 00:20","slug":"2024-06-19-Lesser-KnownCSSFeaturesThatYouShouldLearnNow","content":"\n\n\n<img src=\"/assets/img/2024-06-19-Lesser-KnownCSSFeaturesThatYouShouldLearnNow_0.png\" />\n\nWWW(월드 와이드 웹)의 발명은 정보를 전 세계적으로 공유하기 위한 새로운 디지털 시대를 만들어 냈습니다. 초기 WWW는 주요 웹 문서 요소 사이의 기본 스타일을 구분하기 위해 의미론적 HTML 태그를 사용하는 순수 HTML 문서만을 가졌습니다. 이후 CSS가 도입되어 의미론적 HTML 태그를 스타일링하는 간단한 키-값 기반 스타일링 언어로 발전했습니다. CSS는 발전함에 따라 현재 웹 디자이너들은 생산적이고 개발자 친화적인 구문을 사용하여 현대적인 스타일, 애니메이션, 반응형 요소, 그리고 이미지 필터를 만들 수 있습니다.\n\n일반적으로 CSS는 미리 정의된 문자열 값 또는 숫자 값이 들어 있는 많은 전통적인 속성을 제공합니다. 현대 CSS 표준은 기본 키-값 구문을 넘어서 함수 및 중첩된 블록(즉, at-rules)을 제공하며, 또한 현대 CSS 구문은 가상 요소, 가상 클래스, 그리고 선택자 조합을 지원합니다. 이 모든 CSS 기능들은 표준 웹 브라우저에서 깔끔하게 작동하는 사용 가능하고 현대적인 웹사이트를 만들기 위해 개발자의 생산성을 향상시키기 위한 것입니다.\n\n이 글에서는 대부분의 웹 디자이너가 자주 사용하지 않는 몇 가지 CSS 기능을 탐색해 보겠습니다. 덜 알려진 이러한 CSS 기능들을 숙달하여 고품질 디자인 요구 사항에 맞추어 CSS 기능을 최적으로 선택하여 생산적으로 웹사이트를 디자인할 수 있습니다!\n\n\n<div class=\"content-ad\"></div>\n\n# 유동 디자인에서 수학 및 그리드 함수 사용하기\n\n전통적인 반응형 디자인 개념은 개발자들에게 장치 뷰포트 크기에 기반하여 웹사이트 레이아웃을 조정하도록 권장합니다. 반면에, 유동 디자인 개념은 상대적인 단위와 CSS 수학 함수를 사용하여 전체 웹사이트 요소를 뷰포트 크기에 동적으로 조정하는 것을 권장합니다.\n\n뷰포트 너비에 기반하여 제목 글꼴 크기를 동적으로 조정해야 한다고 가정해보겠습니다. 최소 및 최대 글꼴 크기 경계를 사용하여 이를 구현하기 위해 CSS clamp() 함수를 사용할 수 있습니다. 이를 한 줄의 솔루션으로 구현할 수 있습니다:\n\n```js\n<style>\n  h1 { font-size: clamp(2.2em, 3vw + 1em, 2.5em) }\n</style>\n\n<h1>CSS 수학 함수</h1>\n```\n\n<div class=\"content-ad\"></div>\n\n위의 clamp 함수 호출은 3vw + 1em 표현식을 사용하여 글꼴 크기를 동적으로 설정하지만, 글꼴 크기가 2.2em 및 2.5em 범위를 넘지 못하도록 제한합니다. 아래 미리보기에서 확인할 수 있습니다:\n\n![clamp function preview](https://miro.medium.com/v2/resize:fit:1400/1*w5nqPkbGDo0Lqq-TM2vtcg.gif)\n\n마찬가지로 min() 및 max() 함수를 사용하여 동적으로 계산된 숫자형 CSS 값을 하나의 경계로만 사용할 수 있습니다. 예를 들어, 다음 CSS 코드는 이전 clamp() 함수 예제의 상한선을 제거합니다:\n\n```css\nh1 { font-size: max(2.2em, 3vw + 1em) }\n```\n\n<div class=\"content-ad\"></div>\n\n슬기로운 디자인 원칙을 따라 레이아웃 요소의 간격 및 크기를 조절하는 데 CSS 수학 함수를 사용할 수 있어요. 또한, 현대 CSS에는 미디어 쿼리를 사용하지 않고 반응형을 개선하기 위한 플루이드 디자인을 구현할 수 있는 그리드 중심 함수들이 여럿 제공돼요.\n\n다음 HTML 코드 스니펫을 살펴보세요:\n\n```js\n<style>\n  .container {\n    display: grid;\n    grid-template-columns: repeat(auto-fill, minmax(20em, 1fr));\n    grid-gap: 1em;\n    justify-self: center;\n\n    > div {\n      background: #ddd;\n      padding: calc(2vw + 0.5em);\n      font-size: calc(1vw + 1em); \n      font-weight: bold;\n      text-align: center;\n      border-radius: 0.5em;\n    }\n  }\n</style>   \n<div class=\"container\">\n  <div>Block 1</div>\n  <div>Block 2</div>\n  <div>Block 3</div>\n  <div>Block 4</div>\n</div>\n```\n\n위의 HTML 스니펫은 repeat() 및 minmax() CSS 그리드 함수를 사용하여 뷰포트 너비를 기준으로 동적 그리드 열 크기를 갖는 플루이드 디자인을 렌더링해요. 아래 미리보기에서 확인할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*vgI9wo0MaP4SriLdBTR3bw.gif)\n\nUtopia fluid design methodology 웹사이트에서 유체 디자인 원칙에 대해 더 읽을 수 있어요.\n\n# CSS Math Stepped Value Functions 사용하기\n\n대부분의 일반 목적 프로그래밍 언어는 일반적인 수학 알고리즘을 구현하기 위한 십진 반올림 함수와 내장된 나머지/모듈로 연산자를 제공합니다. CSS 명세는 여전히 뷰포트 높이를 기반으로 컨테이너 높이를 계산하는 데 사용하는 구식(calc()) 함수가 인기를 얻은 후 더 많은 수학 함수를 소개하기 시작했어요.\n\n\n<div class=\"content-ad\"></div>\n\n2024년 이후로 인기 있는 모든 웹 브라우저는 CSS 엔진에 round(), rem(), 그리고 mod() 스텝 값 함수들을 추가하는 작업을 완료했습니다. 이러한 함수들은 다른 값에 기반하여 스텝 값들을 생성하는 데 도움이 되기 때문에 스텝 값 함수로 소개되었습니다.\n\n--width CSS 변수를 사용하여 1부터 1000 사이의 픽셀 값을 보낼 때, JavaScript를 사용하지 않고 가장 가까운 10을 사용해야 할 경우가 있다고 상상해 봅시다. 다음 CSS 코드 스니펫이 그 역할을 합니다:\n\n```js\n<style>\n  :root { --width: 527px }\n  .container {\n    background: #aaa;\n    width: round(var(--width), 25px);\n    height: 2em;\n  }\n</style>   \n\n<div class=\"container\"></div>\n```\n\n위의 HTML 스니펫을 브라우저에서 실행하고 --width 변수를 증가시켜보세요. 컨테이너의 너비는 25로 나누어 떨어지는 픽셀 값으로만 업데이트됩니다. 아래 미리보기에서 확인할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n\n![Image](https://miro.medium.com/v2/resize:fit:1400/1*IVJjCjbFsDpcMGhr1rh_lQ.gif)\n\nround() 함수는 공식 MDN 문서에 설명된 대로 개발자가 반올림 전략을 사용자 정의할 수 있도록 합니다.\n\nrem() 함수는 CSS 내에서 JavaScript의 % 연산자를 사용하여 특정 나눈 수와 나누는 수의 나머지를 찾아주는 도움이 됩니다. 다음 CSS 코드 스니펫에서 보여지는 것처럼요:\n\n```css\n:root {\n  --width: 50em;\n  --block: 15em;\n  --extra: rem(var(--width), var(--block));  /* --extra: 5em */\n}\n```\n\n<div class=\"content-ad\"></div>\n\nmod() 함수의 동작은 rem() 함수와 유사하지만 결과는 항상 나눗셈자의 부호를 취합니다.\n\n이러한 단계별 값 함수들은 여전히 2024년 기준으로 현재이므로 제작 웹사이트에서 사용하기 전에 기다려야 할 수도 있습니다.\n\n# 전통적인 반응형 디자인을 넘어서 미디어 쿼리 활용하기\n\n과거 대부분의 웹사이트는 고정 너비를 사용했으며 일부는 더 나은 사용성을 위해 사용자가 필요로 하는 특정 화면 해상도까지 언급하기도 했습니다. 과거 개발자들은 이동 트래픽이 증가함에 따라, 서브도메인을 사용하여 별도의 웹사이트를 구축하기도 했습니다. 2010년 경에는 반응형 디자인 개념이 소개되어 CSS 미디어 쿼리를 사용하여 다양한 화면에 대해 매우 사용하기 쉬운 웹사이트 레이아웃을 렌더링하는 방법이 도입되었습니다.\n\n<div class=\"content-ad\"></div>\n\n우리 모두는 미디어 쿼리를 사용한 반응형 디자인 기술에 대해 알고 있습니다. 미디어 쿼리는 반응형 디자인에만 적용되는 것이 아니라 일부 다른 중요한 사용 사례를 해결하기도 합니다.\n\n미디어 쿼리를 사용하여 인쇄 가능한 문서에 대한 사용자 정의 스타일을 제공할 수 있습니다. 화면 전용 세그먼트를 숨기는 방식으로 가능합니다:\n\n```js\n@media print {\n  header, footer {\n    display: none;\n  }\n} \n```\n\n인쇄 미리보기 창을 사용하여 인쇄 미디어 유형을 테스트할 수 있으니, 위의 CSS 코드 스니펫을 현대적인 웹페이지에 추가하고 Ctrl + P 키 조합을 눌러보세요.\n\n<div class=\"content-ad\"></div>\n\n웹 전체 화면 모드에 대한 스타일을 조정할 수 있습니다. 다음과 같이 display-mode 미디어 쿼리 기능을 사용하면 됩니다:\n\n```js\n@media (display-mode: fullscreen) {\n  body {\n    margin: 0;\n    padding: 2em;\n    border: 0.5em solid #aaa;\n  }\n}\n```\n\n위의 CSS 코드 조각은 전체 화면 모드에서만 테두리를 적용합니다. 또한 aspect-ratio 미디어 쿼리 기능을 사용하여 장치의 가로세로 비율도 확인할 수 있습니다:\n\n```js\n@media (aspect-ratio: 16 / 9) {\n  body { background: darkcyan }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n크롬 장치 모드를 사용하면 위의 코드 스니펫을 테스트할 수 있습니다. 아래 미리보기에서 확인할 수 있습니다:\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*Ub5ot2L0jo82ttIZAvkpKA.gif)\n\n미디어 쿼리는 디바이스 방향, 시스템 색상 테마 설정, JavaScript 활성화/비활성화 여부, 화면 DPI (Dots Per Inch) 값 등을 확인하는 다양한 미디어 기능을 제공합니다. 공식 MDN 문서에서 지원하는 모든 미디어 기능을 확인할 수 있습니다.\n\n# CSS로 네이티브 폼 컨트롤 사용자 정의하기\n\n<div class=\"content-ad\"></div>\n\n기본 HTML 폼 컨트롤, 예를 들어 버튼, 텍스트 입력란, 라디오 버튼 및 체크박스는 초기 HTML 사양에서 사용할 수 있었습니다. 이후 HTML 사양은 더 현대적인 웹 앱을 구축하기 위해 range-sliders, date-pickers, color-pickers 등을 소개했습니다. 그러나 대부분의 개발자들은 기본 폼 컨트롤의 사용성에 대한 문제로 이러한 기본 폼 컨트롤을 선호하지 않았으며 CSS 기반의 사용자 정의 폼 컨트롤을 사용했습니다. 그러나 최근 CSS는 기본 폼 컨트롤을 사용자 정의하기 위한 새로운 속성을 도입하기 시작했습니다.\n\naccent-color 속성을 사용하면 기본 폼 컨트롤의 기본 색상 스키마를 변경할 수 있습니다:\n\n```js\n<input type=\"checkbox\" style=\"accent-color: cadetblue\"/>\n<input type=\"radio\" style=\"accent-color: teal\"/>\n<input type=\"range\" style=\"accent-color: hotpink\"/><br/>\n<progress style=\"accent-color: darkcyan\"></progress>\n```\n\n위 코드 스니펫은 다양한 색상 스키마로 기본 폼 컨트롤을 렌더링하며, 다음 미리보기에 나와 있습니다:\n\n<div class=\"content-ad\"></div>\n\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*TZdvLwHpwHwiK901ozI3jQ.gif)\n\n`accent-color` 속성은 입력 색상을 기반으로 기본 폼 컨트롤의 모든 하위 요소를 업데이트하여 접근 가능한 색상 체계를 생성합니다. 해당 예시에서 보여지는 폼 요소들만을 기준으로 현재 이 기능이 작동합니다.\n\nCSS는 `accent-color` 속성과 함께 사용할 `color-scheme` 속성을 제공하여 밝은 테마와 어두운 테마에서 모두 원래의 폼 컨트롤 가시성을 향상시킬 수 있습니다:\n\n```css\n@media (prefers-color-scheme: dark) {\n  body {\n    background-color: black;\n    color: white;\n  }\n\n  input[type=\"checkbox\"], \n  input[type=\"radio\"], \n  input[type=\"range\"], \n  progress {\n    accent-color: white;\n    color-scheme: dark;\n  }\n}\n```\n\n\n<div class=\"content-ad\"></div>\n\n위의 미디어 쿼리는 원시 폼 컨트롤 색 구성을 다음과 같이 변경합니다:\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*cIfznllnpX0t-msAM25vjQ.gif)\n\n앞으로 CSS는 기본 폼 컨트롤 스타일을 조정할 수 있는 새로운 속성을 제공하고 다른 기본 요소에 대한 강조 색 지원을 확대할 예정이지만, 기존의 CSS 기능을 사용하여 텍스트 입력과 버튼을 사용자 정의하는 데 문제가 없습니다.\n\n# CSS 카운터 및 @counter-style 사용하기\n\n<div class=\"content-ad\"></div>\n\nCSS 카운터 기능은 CSS 선택자 내에서 증가/감소시킬 수 있는 카운터를 생성하는 방법을 제공합니다. 이 기능을 다양한 용도에 활용할 수 있습니다. 간단한 용례는 요소 발생 횟수에 따라 카운터 값을 표시하는 것입니다.\n\n다음 HTML 코드 조각을 살펴보세요:\n\n```js\n<style>\n  :root { counter-reset: references }\n  a[href]:empty { text-decoration: none }\n\n  a[href]:empty::after {\n    counter-increment: references;\n    content: '[' counter(references) ']';\n  }\n</style>\n\n<p>\n  Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque in \n  eleifend dolor <a href=\"https://example.com/link1\"></a>. Integer mauris \n  eros, posuere vitae ex feugiat, pretium ultrices \n  ex <a href=\"https://example.com/link2\"></a>. Nulla et nibh feugiat, \n  pharetra ipsum vel, accumsan augue \n  <a href=\"https://example.com/link3\"></a>.\n</p>\n```\n\n위 CSS 정의는 references라는 카운터를 생성하고, CSS 카운터를 사용하여 빈 하이퍼링크 태그에 IEEE 인용 형식을 표시합니다. 여기서, 우리는 :root 선택자 내에서 카운터를 0으로 초기화하고, 모든 빈 하이퍼링크의 ::after 가상 클래스로 카운터를 증가시켰습니다. 마지막으로, 카운터 값을 content 속성을 통해 렌더링하고 counter() 함수를 사용하여 카운터 값을 가져와 표시합니다. 위 HTML 문서는 다음과 같은 결과를 렌더링합니다:\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"/assets/img/2024-06-19-Lesser-KnownCSSFeaturesThatYouShouldLearnNow_1.png\" />\n\nHTML에는 내장된 정렬된 및 정렬되지 않은 목록 스타일이 있지만 특정 시나리오에서는 처음부터 사용자 정의 스타일을 구현하거나 기존 스타일을 확장해야 할 수 있습니다. @counter-style at-rule을 사용하면 새로운 또는 확장된 목록 스타일을 만들 수 있습니다. 내장된 10진수 목록 스타일 유형을 주변 괄호 추가 및 단일 제로 패딩 사용하여 사용자 정의해야 한다고 가정해 보십시오. CSS 카운터로 이 요구 사항을 구현할 수 있지만 @counter-style을 사용하면 이 기능에 대해 작성해야 하는 CSS 코드를 줄일 수 있습니다.\n\n```js\n<style>\n  @counter-style modified-alpha {\n    system: extends alpha;\n    prefix: \"[ \";\n    suffix: \" ] \";\n    pad: 2 \"0\";\n  }\n  \n  ol { list-style-type: modified-alpha }\n</style>\n\n<ol>\n  <li>HTML</li>\n  <li>CSS</li>\n  <li>JavaScript</li>\n  <li>TypeScript</li>\n  <li>Bootstrap</li>\n</ol>\n```\n\n위의 HTML 코드는 사용자 정의 목록 스타일이 적용된 정렬된 목록을 렌더링하며, 다음 미리보기와 같이 표시됩니다:\n\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-Lesser-KnownCSSFeaturesThatYouShouldLearnNow_2.png\" />\n\n@counter-style을 사용하여 이모지와 함께 스타일리쉬한 불릿 포인트를 만들 수도 있어요. 이런 기능은 이 MDN 문서 페이지에서 확인할 수 있어요.\n\n다음 이야기에서는 모든 최신 웹 개발자가 알아야 할 몇 가지 CSS 규칙을 나열했어요:\n\n## CSS Animation 특정 Keyframes를 생성하지 않아도 가능합니다\n\n<div class=\"content-ad\"></div>\n\n과거에는 웹 개발자가 DOM 요소에 애니메이션을 구현하기 위해 JavaScript 알고리즘을 작성해야 했습니다. 이제는 내장 된 요소 변환 알고리즘과 표준 속성을 사용하여 CSS 만을 사용하여 DOM 요소를 애니메이션화 할 수 있습니다. 잘 알려진 CSS 애니메이션 접근 방식은 @keyframes at-rule을 사용한 일련의 키프레임을 활용합니다.\n\n저는 최근 이 흥미로운 기사를 발견했고, 키프레임 내에서 CSS 변수를 업데이트할 수 있다는 사실을 알게 되었습니다. 이 기술을 사용하면 다양한 요소를 다중 키프레임 블록을 작성하지 않고 동적으로 업데이트 된 CSS 변수를 사용하여 애니메이션화 할 수 있습니다.\n\n다음 CSS 코드 스니펫을 살펴보세요:\n\n```js\n@property --t {\n  syntax: \"<number>\";\n  initial-value: 0;\n  inherits: true;\n}\n\n@keyframes tick {\n  from { --t: 0 }\n  to   { --t: 100000 }\n}\n\n:root { animation: tick 86400s linear infinite }\n```\n\n<div class=\"content-ad\"></div>\n\n위의 CSS 코드 스니펫은 사용자 지정 속성(변수)을 정의하고 전역 keyframe 두 개만을 사용하여 해당 속성을 업데이트합니다. 그 다음, 우리는 :root 선택자를 사용하여 --t 변수를 루프로 업데이트하면서 애니메이션을 시작했습니다.\n\n--t 변수를 애니메이션 클록으로 사용하여 CSS 함수를 사용해 애니메이션을 만들 수 있습니다. 여기서는 DOM 요소를 애니메이션화하지 않고 CSS 함수를 사용하여 전역 애니메이션 클록을 시작했는데, 이렇게 하면 어떤 CSS 속성에도 사용할 수 있습니다!\n\n아래 코드 스니펫은 애니메이션 keyframes를 사용하지 않고 위의 애니메이션 클록을 활용하여 두 개의 DOM 요소를 애니메이션화하는 예제입니다:\n\n```js\n<style>\n  /* 이전 CSS 스니펫을 여기에 붙여넣기... */\n\n  div > div {\n    background: #555;\n    width: 2em;\n    height: 2em;\n    margin-top: 2em;\n    border-radius: 50%;\n  }\n  \n  div > div:first-child { translate: calc(sin(var(--t)) * 200px + 200px) }\n  div > div:last-child { translate: calc(cos(var(--t)) * 200px + 200px) }\n\n</style>\n\n<div>\n  <div></div>\n  <div></div>\n</div>\n```\n\n<div class=\"content-ad\"></div>\n\n여기서는 이징 알고리즘을 사용하지 않고도 최신 CSS 삼각함수 덕분에 다음과 같이 부드러운 애니메이션을 만들 수 있어요:\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*p4TDYHRD8_pe72zFZAqWCA.gif)\n\n이 기술을 사용하면 여러 키프레임을 작성하는 데 소비하는 시간을 줄여 CSS 함수로 애니메이션을 만들 수 있어요! 삼각함수는 아직 새로운 기술이라 2023년 기준으로, 웹 앱 사용자가 오래된 웹 브라우저를 사용하는 경우에는 프로덕션에서 사용하기 전에 기다려야 할 수도 있어요.\n\n다음 이야기에서는 모든 현대 웹 디자이너가 알아야 할 CSS 함수를 탐구해볼 거에요:\n\n<div class=\"content-ad\"></div>\n\n읽어 주셔서 감사합니다.","ogImage":{"url":"/assets/img/2024-06-19-Lesser-KnownCSSFeaturesThatYouShouldLearnNow_0.png"},"coverImage":"/assets/img/2024-06-19-Lesser-KnownCSSFeaturesThatYouShouldLearnNow_0.png","tag":["Tech"],"readingTime":11},{"title":"8 웹에서 JS를 사용하여 공유하기 고급 기능 UriBaba","description":"","date":"2024-06-19 00:19","slug":"2024-06-19-8ShareintheWebUsingJSAdvancedFeatureUriBaba","content":"\n\n## 고급 JavaScript 기능으로의 심층 탐구\n\n![이미지](/assets/img/2024-06-19-8ShareintheWebUsingJSAdvancedFeatureUriBaba_0.png)\n\n자바스크립트는 많이 발전해 왔으며 세계에서 널리 사용되는 언어 중 하나입니다. 이 기사에서는 고급 자바스크립트를 사용하여 웹에서 공유 기능에 대해 논의합니다. 이 기능을 사용하면 핸드폰의 앱 목록을 열고 사용자가 어떤 앱에서든 공유할 수 있습니다. 코드와 함께 놀아봅시다.\n\n여러 브라우저에서 실패할 수 있기 때문에 Web API의 지원을 확인하고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// window 대신 globalThis를 사용할 수 있어요\nconst isBrowserSupport = () => globalThis.navigator?.share;\n```\n\n웹 공유 API는 web-share 권한 정책에 의해 제한됩니다. 권한은 지원되지만 부여되지 않았을 경우 canShare() 메서드는 false를 반환할 것입니다.\n\n```js\nconst isShareAPIDataValid = (sharingData) => {\n  if (navigator.canShare) {\n    return navigator.canShare(sharingData);\n  }\n  \n  return true;\n};\n```\n\n그 다음 단계에서는 navigator.share를 사용하여 휴대폰 앱 목록을 열어서 사용자가 어떤 앱에서든 공유할 수 있도록 합시다.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst sharingData = { \n  title: '제목', \n  text: '설명', \n  url: 'https://medium.com/@opensrc0/5-scanner-qr-bar-code-upi-in-the-web-using-js-advanced-feature-uribaba-8407f08ddefd' \n};\n\nnavigator.share(sharingData)\n  .then(() => console.log(sharingData))\n  .catch((error) => console.log(error));\n```\n\n여기까지입니다. 정말 멋지죠. JavaScript의 고급 기능인 navigator.share를 사용하여 웹에서 공유 기능이 가능합니다. 아래는 결합된 코드입니다.\n\n```js\nconst isBrowserSupport = () => globalThis.navigator?.share;\n\nconst isShareAPIDataValid = (sharingData) => {\n  if (navigator.canShare) {\n    return navigator.canShare(sharingData);\n  }\n  \n  return true;\n};\n\nif (isBrowserSupport()) {\n  if (isShareAPIDataValid(sharingData)) {\n    navigator.share(sharingData)\n      .then(() => console.log('성공'))\n      .catch((e) => console.log('오류'));\n  } else {\n    console.log('허가 거부');\n  }\n} else {\n  console.log('지원하지 않는 기능');\n}\n```\n\n![이미지](/assets/img/2024-06-19-8ShareintheWebUsingJSAdvancedFeatureUriBaba_1.png)\n\n\n<div class=\"content-ad\"></div>\n\n웹 개발을 fe-pilot npm 패키지로 업그레이드하세요! https://github.com/opensrc0/fe-pilot\n\nReact로 개발된 이 혁신적인 JavaScript 라이브러리는 웹 애플리케이션을 한 단계 높여주는 최신 기능을 제공합니다. fe-pilot은 일반적으로 많은 코딩 노력이 필요한 고급 기능을 쉽게 통합하는 프로세스를 간소화합니다.\n\n# 유용한 링크:\n\n7. 이미지 처리 및 QR 코드/바코드/UPI 세부 정보 가져오기: https://medium.com/@opensrc0/7-scanning-an-image-qr-bar-code-upi-in-the-web-using-js-advanced-feature-uribaba-d491139f5c02\n\n<div class=\"content-ad\"></div>\n\n8. 지금은 Share Features를 읽고 계십니다.\n\n9. Whatsapp Share: [https://medium.com/@opensrc0/9-whatsapp-share-in-the-web-using-js-advanced-feature-uribaba-919fe89c1840](https://medium.com/@opensrc0/9-whatsapp-share-in-the-web-using-js-advanced-feature-uribaba-919fe89c1840)","ogImage":{"url":"/assets/img/2024-06-19-8ShareintheWebUsingJSAdvancedFeatureUriBaba_0.png"},"coverImage":"/assets/img/2024-06-19-8ShareintheWebUsingJSAdvancedFeatureUriBaba_0.png","tag":["Tech"],"readingTime":3},{"title":"아웃시스템 UI를 사용자 정의하는 포괄적인 CSS 가이드","description":"","date":"2024-06-19 00:17","slug":"2024-06-19-TheComprehensiveCSSGuideforCustomizingOutSystemsUI","content":"\n\n모든 아웃시스템 열정가가 일생 동안 한 가지 일이 있다면 무엇일까요? 네, 있습니다. 아웃시스템 UI를 기반으로 응용 프로그램의 외관을 사용자 정의하는 것입니다.\n\n리액티브 웹 앱을 생성할 때, 예제 화면, 템플릿 및 구성 요소가 준비되어 있어 실제 사용 사례에 배포하고 사용할 수 있습니다. 화면에는 버튼, 아이콘, 글꼴, 색상, 테두리 등이 들어 있어 회사가 필요로 하는 기능을 완벽하게 제공합니다.\n\n다음 단계는 회사의 사내 정체성에 따라 응용 프로그램을 사용자 정의하는 것입니다. 아웃시스템 UI에서 기본 스타일링이 제공되는데, 사용자 정의 CSS를 추가하여 응용 프로그램의 시각적 외관을 사용자 정의할 수 있습니다.\n\n아웃시스템 UI의 기본 테마를 올바르게 덮어쓰기 위해서는 브라우저가 CSS를 렌더링하는 방식을 이해해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n# 시작부터 시작해봅시다\n\n먼저 MyDreamApp이라는 새 모듈을 만들고 Screen1이라는 빈 화면을 생성할 거예요.\n\n제가 기존부터 새로운 반응형 웹 앱을 만들 때, 플랫폼은 자동으로 모듈에 2가지 테마를 추가해요.\n\nOutSystems UI 테마에는 내장된 구성 요소를 위한 모든 CSS가 포함되어 있고, MyDreamApp 테마에는 우리가 직접 만든 CSS 코드를 넣을 거예요.\n\n<div class=\"content-ad\"></div>\n\n기본적으로, 우리는 MyDreamApp 테마를 진입점으로 갖고 있습니다. 이 테마는 OutSystemsUI 테마로 정의되어 있습니다.\n\n![이미지](/assets/img/2024-06-19-TheComprehensiveCSSGuideforCustomizingOutSystemsUI_0.png)\n\n이 Base 테마 접근 방식을 사용하면 여러 개의 테마가 순차적으로 로드될 수 있습니다.\n\n브라우저에서 Screen1을 렌더링할 때 미리 작성된 많은 CSS가 이미 함께 제공된다는 것을 확인할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 표를 분석해보겠습니다.\n\n## _Basics.css\n\n_Basics.css 파일은 플랫폼 코어에서 가져왔어요.\n플랫폼 화면이 올바르게 렌더링되는 데 중요한 CSS 클래스가 처리되는 곳이에요. .OSInline, .OSFillParent 또는 .feedback-message와 같은 것들이 여기에서 정의되어 있어요.\n\n## OutSystemsReactWidgets.css\n\n<div class=\"content-ad\"></div>\n\n플랫폼 코어의 다른 파일은 OutSystemsReactWidgets.css입니다.\n이 CSS 파일에서 플랫폼은 컨테이너, 목록, 입력란, 스위치, 표현식과 같은 위젯들의 스타일링을 다룹니다. 이 위젯들은 Service Studio 툴박스에서 얻을 수 있습니다. 이 위젯들은 OutSystems를 사용하여 개발된 것이 아니라 React 하이코드로 개발되었습니다.\n\n이것들은 필수적인 CSS 파일이며, 우리 애플리케이션에서 제거할 수 없습니다. 이 파일들은 제품 개발을 담당하는 내부 OS 팀에 의해 유지됩니다.\n\n## OutSystemsUI.css\n\n이제 우리는 OutSystems 세계에 들어갑니다. OutSystemsUI.css는 거의 20,000 줄의 CSS 코드를 포함하며, OSUI 키트의 모든 것, 레이아웃 및 패턴, 수정자 클래스, 색상, 크기 등이 스타일링되는 곳입니다.\n\n<div class=\"content-ad\"></div>\n\n위 모든 구성 요소는 OutSystems의 로우 코드를 사용하여 개발되었으며, 플랫폼을 즉시 사용하고 기록 시간에 애플리케이션을 생성할 수 있는 가속기 역할을 합니다.\n\n## MyDreamApp.extra.css\n\nOutSystems는 레이아웃과 화면을 구축하기 위해 간단한 열 기반 접근 방식을 사용합니다. 우리는 열의 수를 구성하고 전체 너비인지 또는 고정 너비인지를 결정하며, Service Studio는 이러한 모든 설정을 MyDreamApp.extra.css 파일에 저장합니다.\n\n![The Comprehensive CSS Guide for Customizing OutSystems UI](/assets/img/2024-06-19-TheComprehensiveCSSGuideforCustomizingOutSystemsUI_1.png)\n\n<div class=\"content-ad\"></div>\n\n\"If we set Grid Type to (None), this file is not created.\n\n## MyDreamApp.css\n\nFinally, only one file remains: MyDreamApp.css. This is where we will do most of our work and write custom CSS to override OutSystems UI default styling.\"\n\n<div class=\"content-ad\"></div>\n\n테마 편집기를 사용하여 몇 가지 설정을 사용자 정의하면, Service Studio가 CSS 변수를 생성하여 MyDreamApp.css 파일 안에 배치할 것입니다. 이러한 변수들은 우리 애플리케이션의 전반적인 모양과 느낌에 영향을 미칠 것입니다.\n\n![이미지](/assets/img/2024-06-19-TheComprehensiveCSSGuideforCustomizingOutSystemsUI_2.png)\n\n![이미지](/assets/img/2024-06-19-TheComprehensiveCSSGuideforCustomizingOutSystemsUI_3.png)\n\nOutSystemsUI.css에도 동일한 CSS 변수들이 포함되어 있으며, 테마 편집기에 의해 사용자 정의할 수 있습니다. 또한, 모든 변수에 대한 미리 작성된 기본값이 있습니다.\n\n<div class=\"content-ad\"></div>\n\nMyDreamApp.css 파일이 OutSystemsUI.css 파일보다 늦게 로드되기 때문에 우리의 사용자 정의 CSS 변수가 OSUI에서 오는 변수를 덮어씁니다.\n\n이러한 변수들은 :root 요소에 적용되기 때문에 글로벌입니다.\n\n테마 편집기에서 모든 스타일을 재설정하면 MyDreamApp.css 파일이 완전히 비어있게 됩니다.\n\n이제 기본 제공 파일을 이해했으니 우리는 그것들을 재정의할 준비를 할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nOutSystems 플랫폼에서 많은 것들과 마찬가지로 CSS를 빠르게 많이 작성하는 것이 쉽습니다. 그러나 많은 작업을 하는 것이 모든 것을 잘 해결한다는 것을 의미하지는 않습니다. 그러므로 CSS가 실제로 어떻게 작동하는 지 알아보도록 하겠습니다.\n\n# CSS가 작동하는 방식\n\nOutSystems UI 테마를 가장 효과적으로 재정의하려면 다음과 같이 세 가지 CSS 주제에 대해 이야기해야 합니다:\n\n- 캐스케이딩\n- 상속\n- 특이성\n\n<div class=\"content-ad\"></div>\n\n# 계단식\n\nCSS에서의 \"cascading(계단식)\"은 스타일 규칙이 여러 소스에서 \"cascade(폭포처럼)\" 내려간다는 사실을 의미합니다. 이는 CSS에는 내재된 계층 구조가 있어 우선순위가 높은 스타일이 우선순위가 낮은 규칙을 덮어 씁니다.\n\n다음 예제를 분석해 봅시다:\n\n```js\n// first.css 파일\nh1 {\n  font-family: \"Courier New\";\n  color: red;\n}\n\n// second.css 파일\nh1 {\n  color: green;\n}\n```\n\n<div class=\"content-ad\"></div>\n\n다음은 `h1` 요소에 대한 계산된 스타일 결과입니다:\n\n```js\ncolor: green;\ndisplay: block;\nfont-family: \"Courier New\";\nfont-size: 2em;\nfont-weight: 700;\n// ... 몇 가지 더\n```\n\n여기 몇 가지 주요 개념을 확인해 보겠습니다:\n\n- \"green\" 색상은 \"red\" 색상 뒤에 나오기 때문에 우선권을 갖습니다\n(그래서 CSS 파일을 작성하거나 가져올 때 순서가 중요한 이유입니다)\n- 요소는 다른 셀렉터에서 여러 속성을 추가할 수 있습니다\n(모두 요소에 추가되어 적용됩니다)\n- HTML 요소에는 사용자 에이전트가 정의한 기본 속성이 있습니다\n(이것이 브라우저 간에 차이가 나는 이유 중 하나입니다)\n\n<div class=\"content-ad\"></div>\n\n# 상속\n\nCSS의 맥락에서 상속은 HTML 요소의 특정 스타일 속성이 해당 요소의 하위 요소로 전달되는 과정입니다.\n\n다음 속성들이 이에 해당합니다:\n\n- color\n- font-family\n- font-size\n- font-style\n- font-weight\n- text-align\n- (다른 많은 속성들...)\n\n<div class=\"content-ad\"></div>\n\n자손들에게 상속됩니다.\n\n따라서 `body`에 색상이나 글꼴 크기를 설정하면 그 설정에 영향을 받는 모든 하위 요소에 영향을 줍니다.\n\n이 동작은 매우 유용하지만 오용 시 매우 위험할 수도 있습니다.\n예를 들어, 요소에 text-align: center를 사용하면 모든 하위 HTML 노드도 중앙 정렬됩니다.\n\n다른 속성은 다중상속되지 않으며 각 요소마다 명시적으로 정의해야 합니다. 이에는 다음이 포함됩니다:\n\n<div class=\"content-ad\"></div>\n\n- 배경색\n- 테두리\n- 표시\n- 여백\n- 안쪽여백\n- (다른 많은 항목들…)\n\n# 특이성\n\n가장 중요하면서도 재미있게 다루는 항목입니다.\n\n특이성은 브라우저가 요소에 적합한 CSS 선언을 결정하는 알고리즘이며, 이는 다시 요소에 적용할 속성 값을 결정합니다.\n\n<div class=\"content-ad\"></div>\n\n다음 3개의 열을 고려해 봅시다: a, band c.\n\n![image](/assets/img/2024-06-19-TheComprehensiveCSSGuideforCustomizingOutSystemsUI_4.png)\n\n특이성은 각 열의 선택자 수를 세어 세 부분 값으로 형성됩니다. 다음은 작동 방식입니다:\n\n- ID 선택자: 각 id 선택자에 1을 a 값에 추가합니다.\n- 클래스 선택자, 속성 선택자 및 가상 클래스: 각각에 1을 b 값에 추가합니다.\n- 유형 선택자 및 가상 요소: 각각에 1을 c 값에 추가합니다.\n\n<div class=\"content-ad\"></div>\n\n가장 구체적인 예를 몇 가지 살펴봅시다:\n\n- body .wrapper #header ' '\n특이성: (1, 1, 1)\n- #main ' '\n특이성: (1, 0, 0)\n- .container .content ' '\n특이성: (0, 2, 0)\n- div ' '\n특이성: (0, 0, 1)\n\n전체 선택자 *, 결합자 +, `, ~ 및 부정 가상 클래스 :not는 그 자체로 특이성을 추가하지 않습니다.\n\n동일한 요소에 여러 CSS 규칙이 적용되는 경우 특이성이 가장 높은 규칙이 이길 것입니다. 특이성 값이 동일한 경우 CSS 파일에서 마지막으로 선언된 규칙이 적용되며, 앞에서 언급한 계단식을 따릅니다.\n\n<div class=\"content-ad\"></div>\n\n## 인라인 스타일\n\n인라인 스타일은 특이성을 고려하지 않습니다. 왜냐하면 이들은 계층의 일찍 평가됩니다. 이들의 규칙은 특이성 알고리즘이 평가하는 것보다 우선합니다.\n\n## !important\n\nCSS 선택자에 !important를 사용하면 특이성이나 인라인 스타일에 관계없이 다른 규칙을 재정의합니다. 그러나 CSS를 유지하는데 더 어렵게 만들기 때문에 조심해서 사용해야 합니다. 이것은 모든 것의 어머니입니다.\n\n<div class=\"content-ad\"></div>\n\n# 개발자 도구\n\n브라우저 개발자 도구는 CSS가 브라우저에서 어떻게 렌더링되는지 이해하는 데도 큰 도움이 됩니다.\n\n다음 이미지를 분석해 봅시다. 동일한 파일인 OutSystemsUI.css에서 여러 CSS 선택자들이 있습니다:\n\n![OutSystemsUI CSS Image](/assets/img/2024-06-19-TheComprehensiveCSSGuideforCustomizingOutSystemsUI_5.png)\n\n<div class=\"content-ad\"></div>\n\n일부 중요한 개념들:\n\n- CSS 선택자는 선택된 요소에 적용되는 순서대로 위에서 아래로 표시됩니다;\n- CSS 선택자에 마우스를 올리면 브라우저가 계산된 특이성을 표시합니다. (0, 4, 1)이 어떻게 계산되었는지 이해할 수 있나요?\n- 1845번 라인의 CSS 선택자(0,3,0)가 9419번 라인의 것(0,2,1)보다 더 구체적이며 그래서 계층구조에서 뒤에 위치합니다.\n\n그러니 브라우저 개발자 도구를 열어 CSS가 실제로 해석되는 방법을 이해하는 데 궁극적인 도움을 받아보세요.\n\n# 그 다음에는 무엇을 해볼까요?\n\n<div class=\"content-ad\"></div>\n\nCSS 작성을 시작해보세요!\n\n수정하고 싶은 속성을 식별한 다음, Developer Tools를 확인하여 대상이 되는 OutSystems UI CSS 클래스를 확인하세요.\n\n우리가 작성한 사용자 정의 테마 파일 MyDreamApp.css는 OutSystemsUI.css 이후에 로드됩니다. 이는 같은 특이성을 갖는 규칙은 나중에 로드되므로 우선적으로 적용됨을 의미합니다.\n\n하지만 이것만으로 OSUI 코드의 모든 것을 무시할 수 있는 것은 아닙니다.\n\n<div class=\"content-ad\"></div>\n\n코드가 실제로 적용되려면 더 높은 구체성이 필요합니다.\n\n이제 진짜 의미를 알게 되었어요. 😄\n\n# 몇 가지 조언\n\n- 불필요한 CSS 선택자를 작성하거나 OSUI에서 완전한 규칙을 코드베이스로 직접 복사하는 것을 피하세요. 때로는 OSUI 팀이 릴리스 사이에 구성 요소 구조를 변경하고 규칙이 작동을 멈출 수 있습니다. 절대 필요한 최소한만 사용하세요.\n- 재사용 가능한 CSS 클래스를 만들고 구성 요소에 적용하여 사용자 정의 코드를 내부에 유지하세요.\n- 래퍼 CSS 클래스만 있으면(예: 레이아웃에) b 구체성 열에 1 포인트를 추가하고 그 안의 모든 것을 대상으로 지정하고 재정의할 수 있습니다.\n- 가능한 경우 수정자 CSS 클래스와 함께 ExtendedClass 입력 매개변수를 사용하세요.\n때로는 CSS를 전혀 작성할 필요가 없을 수도 있어요. 😎\nOutSystems UI에서 이미 사용 가능한 유틸리티 클래스와 CSS 변수를 확인해보세요. 🤩 https://outsystemsui.outsystems.com/OutSystemsUIWebsite/CheatSheet\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\nOutSystems UI 킷은 사용 준비가 되어 있어서 그대로 사용하면 아름다운 애플리케이션을 만들 수 있습니다.\n\n하지만 모든 제품이 같은 모습이어야 하는 것은 아닙니다! 때때로 우리는 애플리케이션의 외관을 일부 CSS 코드로 사용자 정의해야 합니다.\n\n이 기사에 설명된 브라우저가 CSS를 렌더링하는 방법과 개념을 이해하면 OutSystems UI를 기반으로 한 애플리케이션의 외관을 최적화한 CSS 코드를 쓸 수 있어서 노력을 최소화하면서 애플리케이션의 외관을 수정할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n만약 이 글을 즐겼다면 👏 버튼을 눌러주세요.\n다른 글들도 확인하시고 댓글로 연락주세요!\n\n이 글이 도움이 되었다면, 더 많은 글을 쓸 동기부여가 되겠어요. 🥰\n\n![이미지](/assets/img/2024-06-19-TheComprehensiveCSSGuideforCustomizingOutSystemsUI_6.png)","ogImage":{"url":"/assets/img/2024-06-19-TheComprehensiveCSSGuideforCustomizingOutSystemsUI_0.png"},"coverImage":"/assets/img/2024-06-19-TheComprehensiveCSSGuideforCustomizingOutSystemsUI_0.png","tag":["Tech"],"readingTime":8},{"title":"플러터를 이용한 크로스 플랫폼 개발하기","description":"","date":"2024-06-19 00:16","slug":"2024-06-19-Cross-PlatformDevelopmentwithFlutter","content":"\n\n<img src=\"/assets/img/2024-06-19-Cross-PlatformDevelopmentwithFlutter_0.png\" />\n\n플러터(Flutter)는 Google에서 개발한 오픈 소스 프레임워크로, 모바일, 웹, 데스크톱 및 임베디드 장치용으로 아름다운 고성능 앱을 구축하는 데 사용됩니다. 그 핵심 장점은 무엇일까요? 하나의 코드베이스에서 이러한 애플리케이션을 만들 수 있다는 것입니다! 이는 빠른 개발, 쉬운 유지 보수 및 일관된 사용자 경험을 각 플랫폼에서 제공할 수 있음을 의미합니다.\n\n여기서 플러터가 크로스 플랫폼 개발에 좋은 선택인 이유를 살펴보겠습니다:\n\n- 하나의 코드베이스: 코드를 한 번 작성하고 iOS, Android, 웹, 데스크톱과 같은 여러 플랫폼에 배포하여 개발 시간과 비용을 줄일 수 있습니다.\n- 빠르고 효율적: Flutter는 부드러운 성능을 위해 Dart라는 현대적인 객체 지향 언어를 사용하고 원시 코드로 직접 컴파일합니다.\n- 핫 리로드: 거의 즉시 앱에 반영되는 코드 변경 사항을 볼 수 있어 개발 주기를 가속화합니다.\n- 아름다운 UI: 플러터는 각 플랫폼에서 네이티브처럼 보이며 놀라운 사용자 인터페이스를 디자인할 수 있는 풍부한 위젯과 도구를 제공합니다.\n- 선언적 UI: 어떻게 한 줄씩 구현하는 방법보다 UI가 어떻게 보여야 하는지에 집중할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n여기서는 크로스 플랫폼 개발에 Flutter를 사용하는 추가 혜택들을 소개해 드립니다:\n\n- 커다란 커뮤니티 및 리소스: Flutter는 개발자 커뮤니티가 활발하며 방대한 문서와 온라인 자습서, 리소스가 풍부합니다.\n- 복잡한 앱에 적합함: Flutter는 간단한 앱을 넘어서 복잡한 기능 및 통합을 처리할 수 있습니다.\n- 구글 지원: 구글의 지원 아래, Flutter는 지속적인 발전을 이루고 있으며 장기 프로젝트에 안정성과 신뢰성을 제공합니다.\n\nFlutter가 당신에게 적합한가요?\n\n다음 프로젝트에 Flutter를 고려해 보세요 만약:\n\n<div class=\"content-ad\"></div>\n\n- 고성능 앱을 다양한 플랫폼에 구축하고 싶어요.\n- 빠른 개발 주기와 효율적 코딩을 중요시합니다.\n- 아름답고 사용자 정의 가능한 UI를 우선시합니다.\n- 강력한 커뮤니티와 구글의 지원이 있는 프레임워크를 찾고 있습니다.\n\n플러터로 시작하기\n\n지금 바로 시작할 준비가 되셨나요? 아래는 시작하는 데 도움이 되는 자료들입니다:\n\n- 공식 플러터 웹사이트: https://flutter.dev/\n- 플러터 시작하기 튜토리얼: https://docs.flutter.dev/get-started/codelab\n- 플러터 문서: https://docs.flutter.dev/\n\n<div class=\"content-ad\"></div>\n\n플러터를 사용하면 개발 프로세스를 간소화하고 더 넓은 사용자에게 접근하며 모든 플랫폼용 탁월한 앱을 만들 수 있어요.","ogImage":{"url":"/assets/img/2024-06-19-Cross-PlatformDevelopmentwithFlutter_0.png"},"coverImage":"/assets/img/2024-06-19-Cross-PlatformDevelopmentwithFlutter_0.png","tag":["Tech"],"readingTime":2}],"page":"19","totalPageCount":20,"totalPageGroupCount":1,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}