{"pageProps":{"posts":[{"title":"플러터에서 Firebase Cloud Messaging API HTTP V1를 사용하는 방법","description":"","date":"2024-06-20 13:52","slug":"2024-06-20-HowtouseFirebaseCloudMessagingAPIHTTPV1inFlutter","content":"\n\n만약 해당 이야기가 유용하다고 생각되면 왼쪽에 50개의 박수를 주세요.\n\n최근 Firebase Messages가 HTTP V1으로 이주되었습니다. Flutter 콘솔에서는 다음과 같이 보입니다.\n\n![image](/assets/img/2024-06-20-HowtouseFirebaseCloudMessagingAPIHTTPV1inFlutter_0.png)\n\n본 문서에서는 새 API로 이주하는 과정을 설명하겠습니다.\n\n<div class=\"content-ad\"></div>\n\n# 단계 1. 발신자 ID 수집하기\n\n`프로젝트 설정`에서` 클라우드 메시징`으로 이동하여 발신자 ID를 복사하고, 나중에 사용할 겁니다.\n\n페이지로 이동: [이 링크](https://console.firebase.google.com/u/0/project/PROJECT_NAME/settings/cloudmessaging)\n\n![이미지](/assets/img/2024-06-20-HowtouseFirebaseCloudMessagingAPIHTTPV1inFlutter_1.png)\n\n<div class=\"content-ad\"></div>\n\n# 단계 2. Firebase Messaging 클라이언트용 키 수집\n\n1. Firebase 콘솔에서 발신자 ID 옆의 `Manage Service Accounts` 버튼을 클릭합니다. 이 버튼을 클릭하면 https://console.cloud.google.com/iam-admin/serviceaccounts로 이동됩니다.\n\n페이지는 다음과 같이 보여야 합니다:\n\n![이미지](/assets/img/2024-06-20-HowtouseFirebaseCloudMessagingAPIHTTPV1inFlutter_2.png)\n\n<div class=\"content-ad\"></div>\n\n2. 어카운트를 클릭하고 'KEYS' 탭을 선택한 후 키를 추가하세요. 그러면 컴퓨터로 키가 담긴 JSON 파일이 다운로드됩니다.\n\n![이미지](/assets/img/2024-06-20-HowtouseFirebaseCloudMessagingAPIHTTPV1inFlutter_3.png)\n\n이를 리포지토리에 복사하여 붙여넣기하세요 (이 예시에서는 'data/your-key-from-cloud-console.json'에). pubspec.yaml에 에셋 경로를 추가하는 것을 잊지 마세요.\n\n# 단계 3. 구글 API Auth 라이브러리 설치\n\n<div class=\"content-ad\"></div>\n\n```js\nflutter pub add googleapis_auth\n```\n\n# 단계 4. 코드\n\n기존의 HTTP 요청은 다음과 같았습니다:\n\n```js\n// 더 이상 유효하지 않은 코드:\n\nhttp.post(\n  Uri.parse('https://fcm.googleapis.com/fcm/send'),\n  headers: {\n    'Content-Type': 'application/json',\n    'Authorization': 'key=$fcmServerToken',\n  },\n  body: body,\n)\n```\n\n<div class=\"content-ad\"></div>\n\n구글 API 인증 라이브러리를 사용해야 하는 새로운 유효한 코드입니다.\n\n```dart\nimport 'package:googleapis_auth/auth_io.dart' as auth;\nimport 'dart:convert';\nimport 'package:flutter/services.dart';\nimport 'dart:developer' as devtools show log;\n\nFuture<bool> sendPushMessage({\n  required String recipientToken,\n  required String title,\n  required String body,\n}) async {\n  final jsonCredentials = await rootBundle\n      .loadString('data/your-key-from-cloud-console.json');\n  final creds = auth.ServiceAccountCredentials.fromJson(jsonCredentials);\n  \n  final client = await auth.clientViaServiceAccount(\n    creds,\n    ['https://www.googleapis.com/auth/cloud-platform'],\n  );\n  \n  final notificationData = {\n    'message': {\n      'token': recipientToken,\n      'notification': {'title': title, 'body': body}\n    },\n  };\n  \n  const String senderId = '736705283357';\n  final response = await client.post(\n    Uri.parse('https://fcm.googleapis.com/v1/projects/$senderId/messages:send'),\n    headers: {\n      'content-type': 'application/json',\n    },\n    body: jsonEncode(notificationData),\n  );\n  \n  client.close();\n  if (response.statusCode == 200) {\n    return true; // Success!\n  }\n\n  devtools.log(\n      'Notification Sending Error Response status: ${response.statusCode}');\n  devtools.log('Notification Response body: ${response.body}');\n  return false;\n}\n```\n\n감사합니다! 이 스토리가 유용하다면 왼쪽에 50개의 박수를 남겨주세요.","ogImage":{"url":"/assets/img/2024-06-20-HowtouseFirebaseCloudMessagingAPIHTTPV1inFlutter_0.png"},"coverImage":"/assets/img/2024-06-20-HowtouseFirebaseCloudMessagingAPIHTTPV1inFlutter_0.png","tag":["Tech"],"readingTime":3},{"title":"플러터에서 빌드 변형 설정하기 포괄적인 안내","description":"","date":"2024-06-20 13:52","slug":"2024-06-20-SettingUpBuildVariantsinFlutterAComprehensiveGuide","content":"\n\n현대 앱 개발에서는 다양한 빌드 변형을 관리하는 것이 중요합니다. 플러터(Flutter)에서 빌드 변형은 개발, 스테이징 및 프로덕션과 같이 여러 버전의 앱을 구성할 수 있도록 해줍니다. 각각이 API 엔드포인트, 기능 플래그 및 기타 환경별 설정과 같은 고유의 구성을 가지고 있습니다. 이 안내서에서는 플러터 프로젝트에서 빌드 변형을 설정하는 방법을 안내해 드릴 예정입니다.\n\n# 단계 1: 구성 파일 만들기\n\n첫 번째 단계는 각 빌드 변형을 위한 별도의 구성 파일을 만드는 것입니다. 이러한 파일에는 환경별 설정이 포함됩니다.\n\n- 플러터 프로젝트의 루트에 config 디렉토리를 생성합니다.\n- 각 빌드 변형을 위해 config 디렉토리 내에 JSON 구성 파일을 추가합니다:\n\n<div class=\"content-ad\"></div>\n\n- config/development.json\n- config/staging.json\n- config/production.json\n\n각 구성 파일은 다음과 같을 수 있습니다:\n\n![이미지](/assets/img/2024-06-20-SettingUpBuildVariantsinFlutterAComprehensiveGuide_0.png)\n\n# 단계 2: 구성 로더 생성\n\n<div class=\"content-ad\"></div>\n\n다음으로, 빌드 변형에 따라 적절한 구성 파일을 로드할 클래스를 만들어보겠습니다.\n\n- lib/config_loader.dart라는 새 파일을 생성하세요:\n\n```dart\nimport 'dart:convert';\nimport 'package:flutter/services.dart';\n\nclass ConfigLoader {\n  final String environment;\n\n  ConfigLoader({required this.environment});\n\n  Future<Map<String, dynamic>> load() async {\n    final String configString = await rootBundle.loadString('config/$environment.json');\n    return json.decode(configString);\n  }\n}\n```\n\n2. lib/config.dart 파일을 생성하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nclass Config {\n  final String apiBaseUrl;\n  final bool debug;\n\n  Config({required this.apiBaseUrl, required this.debug});\n\n  factory Config.fromJson(Map<String, dynamic> json) {\n    return Config(\n      apiBaseUrl: json['apiBaseUrl'],\n      debug: json['debug'],\n    );\n  }\n}\n```\n\n![Setting up build variants in Flutter](/assets/img/2024-06-20-SettingUpBuildVariantsinFlutterAComprehensiveGuide_1.png)\n\n# 단계 3: 설정을 사용하도록 메인 파일 수정\n\n빌드 변형에 기반하여 구성 파일을 로드하도록 메인.dart 파일을 수정하세요.\n\n<div class=\"content-ad\"></div>\n\n- 구성을로드하도록 main.dart를 아래와 같이 편집하세요\n\n```js\nFuture<void> main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n  String envFile = \"development\";\n\n  const flavor = String.fromEnvironment('FLAVOR');\n\n  switch (flavor) {\n    case 'development':\n      envFile = \"development\";\n      break;\n    case 'staging':\n      envFile = \"staging\";\n      break;\n    case 'production':\n      envFile = \"release\";\n      break;\n  }\n\n  // 구성로드\n  final configLoader = ConfigLoader(environment: envFile); // 환경에 따라 변경\n  final config = await configLoader.load();\n\n  print(config.apiBaseUrl);\n  runApp(const MyApp());\n}\n```\n\n# 단계 4: build.gradle (Android)에서 빌드 변형 정의\n\nandroid/app/build.gradle 파일에 build variants를 정의하십시오. 이렇게하면 환경 변수를 Dart 코드로 전달할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n- 안드로이드 앱의 build.gradle 파일을 편집하세요:\n\n```js\nandroid {\n    ...\n\n    flavorDimensions \"env\"\n    productFlavors {\n        dev {\n            dimension \"env\"\n            buildConfigField \"String\", \"ENV\", \"\\\"development\\\"\"\n        }\n        staging {\n            dimension \"env\"\n            buildConfigField \"String\", \"ENV\", \"\\\"staging\\\"\"\n        }\n        prod {\n            dimension \"env\"\n            buildConfigField \"String\", \"ENV\", \"\\\"production\\\"\"\n        }\n    }\n}\n```\n\n# 단계 5: (iOS)에서 빌드 변형 정의하기\n\n## 설정 구성:\n\n<div class=\"content-ad\"></div>\n\n- 워크스페이스 파일 열기:\n\n프로젝트를 .xcodeproj 파일이 아닌 .xcworkspace 파일을 사용하여 열어야 합니다. 워크스페이스 파일에는 CocoaPods나 기타 도구로 관리되는 프로젝트와 종속성에 대한 참조가 포함되어 있습니다.\n\n2. 프로젝트 설정으로 이동:\n\n- Xcode에서 프로젝트 네비게이터(일반적으로 왼쪽에 위치)에서 프로젝트를 선택합니다.\n- 이렇게 하면 다양한 설정을 구성할 수 있는 프로젝트 편집기가 열립니다. \n\n<div class=\"content-ad\"></div>\n\n3. 환경 설정 관리:\n\n- 프로젝트 네비게이터 상단에 있는 프로젝트 이름을 클릭하여 프로젝트 설정에 액세스합니다.\n- 다른 빌드 설정을 구성하려는 대상을 선택합니다 (예: Runner).\n\n4. 환경 설정 추가 또는 편집:\n\n- 정보 탭을 클릭합니다.\n- Debug 및 Release와 같은 다양한 빌드 구성을 관리할 수 있는 환경 설정 섹션을 볼 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n+ 버튼을 클릭하고 \"Debug\"을 복제하거나 \"Release\"를 복사하여 사용자 정의 구성물을 추가할 수 있어요. 그리고 나서 그 구성물을 원하는 대로 (예: Debug-staging, Debug-production) 이름을 바꿔주세요.\n\n5. 빌드 설정 구성:\n\n- 새로 생성된 구성물을 선택합니다.\n- 필요에 따라 빌드 설정을 조정합니다. 일반적으로 API 엔드포인트, 환경 변수 또는 각 구성에 특정한 번들 식별자와 같은 설정이 포함됩니다.\n\n6. 변경 사항을 저장하세요.\n\n<div class=\"content-ad\"></div>\n\n- 변경을 저장하려면 파일 ` 저장 또는 Cmd + S를 클릭하세요.\n\n## 설정 체계:\n\n- 체계 수정:\n\n- Xcode에서 툴바에 있는 일반적으로 중지 버튼 옆의 체계 드롭다운을 클릭합니다.\n- 체계 수정...을 선택합니다.\n\n<div class=\"content-ad\"></div>\n\n### 2. 스킴 구성 관리:\n\n- 스킴 편집기에서 동작 목록을 볼 수 있습니다 (예: 실행, 테스트, 프로파일 등).\n- 각 동작에는 고유한 구성이 있습니다 (예: 실행 동작의 디버그).\n- 기존 구성 (예: 디버그)을 복제하여 새로운 구성 (예: 릴리스, 스테이징)을 만들 수 있습니다.\n\n### 3. 스킴별 빌드 구성 설정:\n\n- 각 동작 (예: 실행)에 대해 드롭다운에서 적절한 빌드 구성 (디버그, 릴리스 또는 사용자 정의 구성)을 선택하세요.\n\n<div class=\"content-ad\"></div>\n\n4. 실행 대상 구성하기:\n\n- 동일한 Scheme 편집기에서 앱이 실행될 대상을 구성할 수 있습니다 (예: 시뮬레이터 장치 유형, 연결된 장치).\n\n- Scheme 변경 사항 저장하기:\n\n- Scheme 변경 사항을 저장하려면 확인을 클릭하세요.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-20-SettingUpBuildVariantsinFlutterAComprehensiveGuide_2.png)\n\n# 단계 6. 다른 플레이버 실행/빌드하기\n\n명령줄을 사용하여 원하는 플레이버로 앱을 실행하세요. --flavor 플래그와 -t 플래그를 사용하여 빌드 플레이버와 대상 파일을 지정합니다.\n\n터미널에서 아래의 주석을 사용하세요\n\n\n<div class=\"content-ad\"></div>\n\n\nflutter run --flavor development -t lib/main.dart // 개발용\n\nflutter run --flavor staging -t lib/main.dart    // 스테이징용\n\nflutter run --flavor production -t lib/main.dart // 프로덕션 또는 릴리스용\n\n\nAndroid 빌드하려면 터미널에서 다음 주석을 사용하세요\n\n\nflutter build apk --flavor development -t lib/main.dart\n\nflutter build apk --flavor staging -t lib/main.dart\n\nflutter build apk --flavor production -t lib/main.dart\n\n\niOS 빌드하려면 터미널에서 다음 주석을 사용하세요\n\n\n<div class=\"content-ad\"></div>\n\n```js\nflutter build ios --flavor development -t lib/main.dart\n\nflutter build ios --flavor staging -t lib/main.dart\n\nflutter build ios --flavor production -t lib/main.dart\n```\n\n# 단계 6: 또한 안드로이드 스튜디오에서 실행 구성 설정을 설정할 수 있습니다\n\n- 실행/디버그 구성을 엽니다:\n\n- 안드로이드 스튜디오에서 Run ` Edit Configurations...`로 이동합니다.\n\n<div class=\"content-ad\"></div>\n\n2. 새로운 Flutter 구성 만들기:\n\n- 새 구성을 추가하려면 + 버튼을 클릭합니다.\n- 목록에서 Flutter를 선택합니다.\n\n3. 개발 플레이버 구성하기:\n\n- 구성 이름을 Flutter 개발과 같이 지정합니다.\n- 대상을 main.dart로 설정합니다.\n- 추가 실행 인수 필드에서 다트 정의로 플레이버를 추가합니다: --dart-define=FLAVOR=development.\n- 선택적으로 빌드 섹션 아래에서 개발을 빌드 플레이버 필드로 설정할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n4. 스테이징 플레이버 구성:\n\n- 다른 구성을 만들기 위해 위 단계를 반복합니다.\n- 이름을 플러터 스테이징으로 지정합니다.\n- 타겟을 main.dart로 설정합니다.\n- 추가 실행 인수 필드에 Dart Define으로 플레이버를 추가합니다: --dart-define=FLAVOR=staging.\n- 빌드 플레이버 필드를 스테이징으로 설정합니다.\n\n5. 프로덕션 플레이버 구성:\n\n- 다른 구성을 만들기 위해 단계를 반복합니다.\n- 이름을 플러터 프로덕션으로 지정합니다.\n- 타겟을 main.dart로 설정합니다.\n- 추가 실행 인수 필드에 Dart Define으로 플레이버를 추가합니다: --dart-define=FLAVOR=production.\n- 빌드 플레이버 필드를 프로덕션으로 설정합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-20-SettingUpBuildVariantsinFlutterAComprehensiveGuide_3.png)\n\n# 결론\n\n위의 단계를 따라가면, 플러터 앱에서 여러 빌드 변형을 효율적으로 관리하여 개발, 테스트 및 프로덕션을 위한 다른 환경을 유지하기 쉬워집니다. 이 설정을 통해 각 빌드 변형이 자체 구성 및 리소스를 가질 수 있도록하여 개발 및 배포 프로세스를 더 효율적으로 할 수 있습니다.\n\n의문이나 질문이 있으면 언제든지 연락해 주세요. LinkTree를 통해 저에게 연락할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n행복한 코딩하세요! :)","ogImage":{"url":"/assets/img/2024-06-20-SettingUpBuildVariantsinFlutterAComprehensiveGuide_0.png"},"coverImage":"/assets/img/2024-06-20-SettingUpBuildVariantsinFlutterAComprehensiveGuide_0.png","tag":["Tech"],"readingTime":7},{"title":"플러터 vs 코틀린 멀티플랫폼 크로스 플랫폼 개발의 미래","description":"","date":"2024-06-20 13:50","slug":"2024-06-20-FluttervsKotlinMultiplatformTheFutureofCross-PlatformDevelopment","content":"\n\n<img src=\"/assets/img/2024-06-20-FluttervsKotlinMultiplatformTheFutureofCross-PlatformDevelopment_0.png\" />\n\n모바일 앱 개발은 더 이상 어려운 일이 되어갑니다. 아름다운 인터페이스, 뛰어난 성능, 그리고 모든 플랫폼의 사용자에게 도달하는 능력을 원합니다. 그러나 안드로이드와 iOS용 네이티브 앱을 코딩하는 시간(또는 예산)이 있는 사람은 누구일까요? 여기 모바일, 웹, 그리고 데스크톱용 앱의 신들: Flutter와 Kotlin Multiplatform (KMP)이 나서 있습니다.\n\n# 왼쪽 구석, 관중들의 애호가: Flutter!\n\n날렵한 Dart 언어와 강력한 렌더링 엔진으로 Flutter는 단일 코드베이스로 모바일, 웹, 데스크톱용 매력적이고 네이티브한 느낌의 앱을 만들 수 있습니다. 앱 개발을 위한 레고 블록을 생각해보세요 — 재사용 가능한 위젯을 함께 조립하여 상상하는 모든 것을 만들어냅니다. Flutter는 초고속 개발 주기를 위한 핫 리로드 기능과 여러분을 돕기 위해 함께 해 줄 거대한 커뮤니티를 자랑합니다.\n\n<div class=\"content-ad\"></div>\n\n# 하지만, 도전자가 나타났어요! Kotlin Multiplatform이 무대에 등장했습니다!\n\n이 챔피언은 항상 인기 있는 Kotlin 언어를 활용하여 앱의 로직을 여러 플랫폼 간에 공유할 수 있게 해줍니다. KMP는 네이티브 성능과 UI에서 빛을 발하는데 — 안드로이드나 iOS에서도 각 플랫폼에 맞는 코드를 작성하여 앱이 훌륭하게 동작하도록 할 수 있습니다.\n\n## 그래서, 이 에픽 배틀에서 누가 이길까요?\n\n## 자세한 전투를 살펴보겠습니다!\n\n<div class=\"content-ad\"></div>\n\n라운드 1: 개발 속도\n\n플러터의 핫 리로드 및 단일 코드베이스는 빠른 개발을 위한 명확한 우승자입니다. 변경 사항이 즉시 반영되어 코딩 열풍을 유지할 수 있습니다.\n\n라운드 2: 네이티브 느낌과 성능\n\nKMP는 여기서 플러터를 제쳐두고 있습니다. 일부 네이티브 UI 개발을 허용함으로써 KMP는 각 플랫폼에서 앱이 진정으로 편안함을 느끼도록 보장합니다. 게다가 일부 경우에는 KMP가 성능을 조금 더 끌어올릴 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n라운드 3: 학습 곡선\n\n만약 Kotlin에 익숙하다면 KMP는 더 익숙할 수 있습니다. 그러나 Flutter의 Dart 언어는 비교적 쉽게 배울 수 있으며 다양한 자원들이 풍부하여 빠르게 습득할 수 있습니다.\n\n라운드 4: 커뮤니티와 지원\n\nFlutter와 KMP는 열정적인 커뮤니티를 보유하고 있지만, Flutter의 더 많은 사용자들로 인해 더 많은 자원과 튜토리얼을 쉽게 찾을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 강점과 약점을 확인해봅시다\n\n## Flutter의 강점\n\n- 단일 코드베이스: 한 번 작성하여 여러 플랫폼에서 실행할 수 있습니다. Flutter를 사용하면 Android, iOS, 웹 및 데스크톱 애플리케이션에 대해 단일 코드베이스를 사용할 수 있습니다.\n- 핫 리로드: 앱을 다시 시작하지 않고 실시간으로 변경 사항을 확인할 수 있어 개발 프로세스를 가속화합니다.\n- 풍부한 위젯 라이브러리: 맞춤 설정 가능한 다양한 위젯 컬렉션을 제공하여 복잡한 UI를 쉽게 작성할 수 있습니다.\n- 성능: Flutter의 성능은 컴파일된 성격과 효율적인 렌더링 엔진으로 인해 원시 앱에 근접합니다.\n\n## Flutter의 약점\n\n<div class=\"content-ad\"></div>\n\n- 앱 크기: 플러터 앱은 네이티브 앱에 비해 더 큰 파일 크기를 가질 수 있습니다.\n- 제한된 생태계: 성장하고 있지만, 플러터의 생태계는 여전히 더 확립된 프레임워크보다 작을 수 있습니다.\n- Dart 언어: Dart는 JavaScript 또는 Kotlin과 같은 언어보다 널리 사용되지 않아 처음 개발자들에게는 학습 곡선이 있을 수 있습니다.\n\n## 코틀린 멀티플랫폼의 장점\n\n- 공유 비즈니스 로직: 네이티브 UI를 유지하면서 여러 플랫폼 간에 비즈니스 로직을 공유할 수 있습니다.\n- 상호 운용성: 코틀린은 자바와 100% 상호 운용이 가능하여 기존 안드로이드 프로젝트와 쉽게 통합할 수 있습니다.\n- 네이티브 성능: 코틀린 멀티플랫폼을 통해 플랫폼별 UI가 가능하므로 성능이 네이티브 응용 프로그램과 동등합니다.\n- 성장하는 커뮤니티: 구글의 코틀린을 안드로이드 개발의 선호 언어로 지원하면서 코틀린 커뮤니티가 견고히 성장하고 있습니다.\n\n## 코틀린 멀티플랫폼의 약점\n\n<div class=\"content-ad\"></div>\n\n- 복잡성: 플랫폼별 코드와 공유 코드를 함께 관리하는 것은 복잡할 수 있으며 신중한 아키텍처가 필요합니다.\n- 툴 및 라이브러리 한정성: Kotlin Multiplatform을 위한 툴과 서드파티 라이브러리는 Flutter용 것만큼 성숙하지 않습니다.\n- 학습 곡선: 개발자들은 Kotlin과 해당 플랫폼 고유의 개발 환경에 익숙해져야 합니다.\n\n# 사용 사례\n\n## Flutter를 사용해야 하는 경우\n\n- 스타트업 및 MVPs: 최소한의 제품을 빠르게 개발하고 배포할 때\n- 통일된 UI: 여러 플랫폼에 걸쳐 일관된 UI가 필요할 때\n- 개발 효율성: 개발 속도와 효율성이 중요할 때\n\n<div class=\"content-ad\"></div>\n\n## Kotlin Multiplatform을 사용해야 하는 경우\n\n- 기존 프로젝트: 기존 안드로이드 프로젝트와 통합할 때.\n- 플랫폼별 UI: 플랫폼별 UI를 필요로하지만 비즈니스 로직을 공유하고 싶을 때.\n- 성능 중심 애플리케이션: 성능과 네이티브 통합이 중요한 경우.\n\n# 최종 결론: 비김!\n\nFlutter와 KMP는 모두 크로스 플랫폼 개발에 탁월한 선택지입니다. 여러분의 우선 순위를 고려해보세요: 빠른 개발과 통합된 코드베이스? Flutter를 선택하세요. 화려한 UI와 최고의 성능? KMP가 당신의 최고의 선택일 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n그렇죠! 두 가지를 시도해 보는 게 최선의 방법입니다. 조금 실험을 해보면, 어떤 도구가 빠르게 훌륭한 모바일 앱을 만드는 데 도움이 되는지 알아낼 거예요.\n\n# 자주 묻는 질문\n\n## 1. 어떤 프레임워크가 더 좋은 성능을 제공하나요: Flutter 또는 Kotlin Multiplatform?\n\n두 프레임워크 모두 우수한 성능을 제공하지만, 접근 방식이 다릅니다. Flutter는 컴파일된 성질과 효율적인 렌더링 엔진 덕분에 네이티브에 가까운 성능을 제공합니다. Kotlin Multiplatform은 플랫폼별 UI를 허용하기 때문에 UI가 해당 플랫폼의 네이티브 언어로 작성되어 성능이 네이티브 앱과 크게 차이나지 않을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 2. Dart을 배우기 어렵다고 생각하시나요? Kotlin과 비교하여\n\n이것은 당신의 배경에 달려 있어요. Dart는 상대적으로 쉽게 배울 수 있습니다, 특히 JavaScript 경험이 있는 경우에요. Kotlin 또한 간단하게 배우기 쉬운 편이며, 특히 Java 배경이 있는 경우에는 Java와 완전히 상호 운용 가능하기 때문에요.\n\n## 3. Flutter를 웹 개발에 사용할 수 있나요?\n\n네, Flutter는 웹 개발을 지원해요. 동일한 코드베이스를 사용하여 모바일 및 데스크톱 애플리케이션에 사용하는 것과 동일한 코드로 반응형 웹 애플리케이션을 만들 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n## 4. 코틀린 Multiplatform은 제작용으로 준비되어 있나요?\n\n코틀린 Multiplatform은 여전히 발전 중이지만 이미 많은 회사들이 제작 단계에서 사용하고 있습니다. 특히 각 플랫폼별 UI 코드를 유지하면서 비즈니스 로직을 공유하는 데 도움이 됩니다.\n\n## 5. 새로운 스타트업을 위해 어떤 프레임워크를 선택해야 하나요?\n\n새로운 스타트업이나 MVP의 경우, 플러터는 개발 주기가 빠르고 다중 플랫폼을 위한 단일 코드베이스, 그리고 다양한 위젯 라이브러리로 인해 종종 더 나은 선택입니다. 모든 플랫폼에서 일관된 UI로 빠르게 시장에 진입할 수 있도록 도와줍니다.","ogImage":{"url":"/assets/img/2024-06-20-FluttervsKotlinMultiplatformTheFutureofCross-PlatformDevelopment_0.png"},"coverImage":"/assets/img/2024-06-20-FluttervsKotlinMultiplatformTheFutureofCross-PlatformDevelopment_0.png","tag":["Tech"],"readingTime":5},{"title":"Flutter 앱을 테마화해보세요 ThemeData와 ColorScheme에 대한 안내","description":"","date":"2024-06-20 13:49","slug":"2024-06-20-ThemeYourFlutterAppAGuidetoThemeDataandColorScheme","content":"\n\n다음을 먼저 말씀드리기 전에 알아두어야 할 점이 있어요. 많은 기사들이 이 주제에 대해 매체와 다른 소스에서 제공되고 있기 때문에, 이 기사의 필요성이 무엇인지 궁금해졌죠?\n\n이 기사에서는 ThemeData 위젯의 주요 포인트와 저의 개발 경험 중 가장 많이 사용하는 매개변수에 초점을 맞추어, 각 매개변수가 어떻게 애플리케이션에 영향을 미치는지에 대해 간단한 설명을 제공할 예정이에요.\n\n궁금하신가요? 계속 읽어보세요 🤗.\n\n## ThemeData 사용의 주요 이점\n\n<div class=\"content-ad\"></div>\n\n- 일관된 외관 유지: 앱의 색상 팔레트, 글꼴, 모양 및 기타 시각 요소를 캡슐화하는 단일 ThemeData 객체를 정의하세요. 이 테마를 모든 화면에 일관되게 적용하여 통일된 및 인식할 수 있는 브랜드 아이덴티티를 유지하세요.\n- 다양한 테마를 생성하세요: 밝은 모드, 어플리케이션 섹션 또는 사용자 환경에 따라 여러 ThemeData 객체를 정의하세요.\n- 한 번 테마를 정의하고 모든 곳에서 사용하세요: 개별 위젯에 시각적 스타일을 수동으로 설정하는 대신 앱에서 적절한 ThemeData를 적용하세요. 이렇게 하면 코드 중복이 줄어들고 유지 관리가 간단해집니다.\n- 중앙 통제 및 업데이트: ThemeData 객체를 변경하면 해당 변경 사항이 자동으로 앱 전체에 퍼지므로 일관성이 유지되고 반복적인 편집이 줄어듭니다.\n- 접근성 있는 변형 만들기: 시각 장애가 있는 사용자를 위한 고대비 테마와 같은 특정 접근성 요구를 가진 사용자를 위한 별도의 ThemeData 객체를 구축하세요.\n\n그래서, ThemeData가 어떻게 도움이 되는지 알게 되었으니, 이것을 어떻게 앱에 구현하는지 알아볼까요? 저랑 함께 하세요 😊.\n\n다크 모드 및 라이트 모드를 위한 기본 테마를 구현하는 간단한 가이드가 여기 있습니다.\n\n## 전역 클래스 생성\n\n<div class=\"content-ad\"></div>\n\n먼저 애플리케이션 내에서 ThemeData를 관리하는 전역 클래스를 만드는 것이 첫 번째 단계입니다. 이 클래스에는 ColorSheme를 사용하여 다른 ThemeData 인스턴스를 만드는 메서드가 포함되어 있습니다.\n\n```dart\nclass GlobalThemData {\n  static ThemeData themeData(ColorScheme colorScheme, Color focusColor) {\n    return ThemeData(colorScheme: colorScheme, focusColor: focusColor);\n  }\n}\n```\n\nfocusColor : 이 색상은 TextFields 및 TextFormField와 같은 위젯에 사용되며 위젯이 기본 포커스를 갖고 있음을 나타냅니다.\n\n나중에 이 기사에서 ColorSheme에 대해 자세히 논의할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이제 GlobalThemeData 클래스에서 직접 액세스할 수 있는 추가적인 공용 변수를 만들 수 있습니다.\n\n- lightColorScheme: 라이트 테마용 ColorScheme을 보유합니다.\n- darkColorScheme: 다크 테마용 ColorScheme을 보유합니다.\n- lightThemeData: 라이트 테마용 ThemeData을 보유합니다.\n\n<div class=\"content-ad\"></div>\n\n`darkThemeData`: 다크 테마를 위한 ThemeData를 보유합니다.\n\n```js\nclass GlobalThemData {\n  static final Color _lightFocusColor = Colors.black.withOpacity(0.12);\n  static final Color _darkFocusColor = Colors.white.withOpacity(0.12);\r\n```\n\n```js\r\n  static ThemeData lightThemeData = themeData(lightColorScheme, _lightFocusColor);\n     \n  static ThemeData darkThemeData = themeData(darkColorScheme, _darkFocusColor);\n  static ThemeData themeData(ColorScheme colorScheme, Color focusColor) {\n    return ThemeData(colorScheme: colorScheme, focusColor: focusColor);\n  }\n  static const ColorScheme lightColorScheme = ColorScheme();\n  static const ColorScheme darkColorScheme = ColorScheme();\n}\r\n```\n\n제 코드를 함께 작성 중이라면 ColorSheme()에서 필수 매개변수 오류 경고를 받을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n다음 단계에서 이를 고칠 수 있어요.\n\n## ColorSheme\n\nColorSheme의 색상은 쌍으로 구성되어 있어요. 첫 번째는 색상 자체이고, 두 번째는 해당 색상에 사용할 수 있는 색상으로, 텍스트 및 다른 요소 등이 있어요.\n\n![ColorSheme](/assets/img/2024-06-20-ThemeYourFlutterAppAGuidetoThemeDataandColorScheme_0.png)\n\n<div class=\"content-ad\"></div>\n\n플러터 ThemData에 컬러 테마를 만들 때 필수 컬러 10가지입니다. 각 컬러의 값은 선택사항입니다.\n\n- primary: 애플리케이션에서 가장 많이 사용되는 색상입니다.\n\n- onPrimary: 텍스트, 아이콘 등 프라이머리 컬러 위에 색상이 적용되는 요소에 사용됩니다.\n\n- secondary: 프라이머리 컬러보다 눈에 띄지 않지만 필요한 요소(필터 칩, 토글 버튼, 배경 요소 등)에 대한 보조 색상을 정의합니다.\n\n<div class=\"content-ad\"></div>\n\nonSecondary: 이 색은 보조 색 위에 적용되는 요소의 색상을 지정하는 데 사용됩니다.\n\nerror: 이 색은 오류 메시지나 경고와 같이 문제를 나타내는 데 사용됩니다. 마치 문제를 나타내기 위해 깜박이는 빨간 불빛인 것처럼요.\n\nonError: 이 색상은 에러 색상 위에 잘 어울리는 텍스트 색으로, 쉽게 읽을 수 있도록 하기 위해 빨간 표지판에 표시되는 흰색 텍스트와 같은 색상이에요.\n\nbackground: 전체 애플리케이션의 주요 배경색입니다. 이는 모든 다른 UI 요소가 배치되는 캔버스로 생각할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n배경색 위에 있는 요소를 색칠하는 데 사용되는 색입니다.\n\n 표면 : 카드, 시트, 대화 상자 등과 같은 UI 요소의 기본 색상으로 사용됩니다.\n\n 표면 위에 있는 요소에 색칠하는 데 사용됩니다.\n\n그래서 우리는 lightColorScheme 및 darkColorScheme 변수를 다음과 같이 설정할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```dart\nstatic const ColorScheme lightColorScheme = ColorScheme(\n    primary: Color(0xFFB93C5D),\n    onPrimary: Colors.black,\n    secondary: Color(0xFFEFF3F3),\n    onSecondary: Color(0xFF322942),\n    error: Colors.redAccent,\n    onError: Colors.white,\n    background: Color(0xFFE6EBEB),\n    onBackground: Colors.white,\n    surface: Color(0xFFFAFBFB),\n    onSurface: Color(0xFF241E30),\n    brightness: Brightness.light,\n  );\n```\n\n```dart\nstatic const ColorScheme darkColorScheme = ColorScheme(\n    primary: Color(0xFFFF8383),\n    secondary: Color(0xFF4D1F7C),\n    background: Color(0xFF241E30),\n    surface: Color(0xFF1F1929),\n    onBackground: Color(0x0DFFFFFF),\n    error: Colors.redAccent,\n    onError: Colors.white,\n    onPrimary: Colors.white,\n    onSecondary: Colors.white,\n    onSurface: Colors.white,\n    brightness: Brightness.dark,\n  );\n```\n\n지금까지 우리는 밝은 테마(light)와 어두운 테마(dark)를 위한 ColorScheme을 설정했어요. 이제 이를 ThemeData에서 어떻게 사용하는지 알아볼게요.\n\n## ThemeData 생성\n\n<div class=\"content-ad\"></div>\n\n우리는 GlobalThemeData의 themeData 메서드를 수정하여 전달할 적절한 ColorScheme 값을 사용하여 ThemeData를 구성해야 합니다.\n\n```js\nstatic ThemeData themeData(ColorScheme colorScheme, Color focusColor) {\n    return ThemeData(\n        colorScheme: colorScheme,\n        canvasColor: colorScheme.background,\n        scaffoldBackgroundColor: colorScheme.background,\n        highlightColor: Colors.transparent,\n        focusColor: focusColor\n       );\n  }\n```\n\n- canvasColor: 전체 화면이나 앱 창의 배경색상을 나타내는 속성입니다. 다른 모든 UI 요소를 배치하는 기본 색상을 정의합니다.\n- scaffoldBackgroundColor: 이것은 특히 scaffold 자체의 배경색상을 정의합니다. 앱 바, 본문 콘텐츠 영역 및 하단 내비게이션 바 (있는 경우)을 포함합니다.\n- highlightColor: 이 속성은 사용자가 위젯을 누르고 누르고 있을 때 잠시 표시되는 색상을 정의합니다. 사용자에게 상호 작용이 등록되었음을 시각적으로 알려줍니다.\n- focusColor: 이 속성은 현재 포커스를 받은 요소를 시각적으로 나타내는 데 사용되는 색상을 정의합니다. 이것은 현재 키보드 입력을 받을 요소를 강조하는데 유용할 수 있습니다.\n\n이것들은 예시일 뿐이며, 살펴볼 다른 ThemeData 옵션이 더 많이 있습니다.\n\n<div class=\"content-ad\"></div>\n\n그래서 최종 GlobalThemeData 클래스는 이렇게 보일 것입니다.\n\n```js\nclass GlobalThemData {\n  static final Color _lightFocusColor = Colors.black.withOpacity(0.12);\n  static final Color _darkFocusColor = Colors.white.withOpacity(0.12);\n\n  static ThemeData lightThemeData =\n      themeData(lightColorScheme, _lightFocusColor);\n  static ThemeData darkThemeData = themeData(darkColorScheme, _darkFocusColor);\n  static ThemeData themeData(ColorScheme colorScheme, Color focusColor) {\n    return ThemeData(\n      colorScheme: colorScheme,\n      canvasColor: colorScheme.background,\n      scaffoldBackgroundColor: colorScheme.background,\n      highlightColor: Colors.transparent,\n      focusColor: focusColor\n    );\n  }\n  static const ColorScheme lightColorScheme = ColorScheme(\n    primary: Color(0xFFB93C5D),\n    onPrimary: Colors.black,\n    secondary: Color(0xFFEFF3F3),\n    onSecondary: Color(0xFF322942),\n    error: Colors.redAccent,\n    onError: Colors.white,\n    background: Color(0xFFE6EBEB),\n    onBackground: Colors.white,\n    surface: Color(0xFFFAFBFB),\n    onSurface: Color(0xFF241E30),\n    brightness: Brightness.light,\n  );\n  static const ColorScheme darkColorScheme = ColorScheme(\n    primary: Color(0xFFFF8383),\n    secondary: Color(0xFF4D1F7C),\n    background: Color(0xFF241E30),\n    surface: Color(0xFF1F1929),\n    onBackground: Color(0x0DFFFFFF),\n    error: Colors.redAccent,\n    onError: Colors.white,\n    onPrimary: Colors.white,\n    onSecondary: Colors.white,\n    onSurface: Colors.white,\n    brightness: Brightness.dark,\n  );\n}\n```\n\n예! 우리는 어플리케이션을 위한 아름다운 테마를 만들었어요. 그 다음 단계는 무엇일까요?\n\n<div class=\"content-ad\"></div>\n\n## ThemeData 설정\n\nMaterialApp에서 원하는 테마를 설정합니다.\n\n```dart\nclass MyApp extends StatelessWidget {\n  const MyApp({Key key}) : super(key: key);\n  \n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      debugShowCheckedModeBanner: false,\n      title: 'Flutter Demo',\n      themeMode: ThemeMode.light, // 또는 ThemeMode.dark\n      theme: GlobalThemData.lightThemeData,\n      darkTheme: GlobalThemData.darkThemeData,\n      home: const ShowCaseHome(),\n    );\n  }\n}\n```\n\n이렇게 하면 기본적인 라이트 테마가 앱에 적용됩니다. 다크 모드로 전환할 수도 있습니다. 동적으로 전환하기 위해 InheritedWidget 또는 Provider의 강력함을 탐험할 수 있습니다. 이 내용은 이 글의 범위를 벗어납니다. 필요하면 향후 글에서 자세히 논의할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n소중한 정보를 얻으셨길 바라요. 읽어 주셔서 감사합니다! 🤗","ogImage":{"url":"/assets/img/2024-06-20-ThemeYourFlutterAppAGuidetoThemeDataandColorScheme_0.png"},"coverImage":"/assets/img/2024-06-20-ThemeYourFlutterAppAGuidetoThemeDataandColorScheme_0.png","tag":["Tech"],"readingTime":8},{"title":"플러터Flutter에서 환경 변수 설정하기","description":"","date":"2024-06-20 13:48","slug":"2024-06-20-ConfiguringEnvironmentVariablesinFlutter","content":"\n\n우리 앱이 개발, 스테이징, 프로덕션 등 여러 환경을 지원해야 하는 경우가 많습니다.\n\n여러 라이브러리를 사용하여 특정 환경과 관련된 변수를 선언할 수 있습니다. 오늘은 Flutter가 이 기능을 네이티브로 제공하여 간단하고 효율적으로 만드는 방법에 대해 설명하려고 합니다.\n\n![이미지](/assets/img/2024-06-20-ConfiguringEnvironmentVariablesinFlutter_0.png)\n\n# 환경 변수 선언\n\n<div class=\"content-ad\"></div>\n\n## dart-define 사용하기\n\nFlutter는 flutter run 및 flutter build 명령에 대해 --dart-define 옵션을 사용하여 환경 변수를 정의하는 쉬운 방법을 제공합니다.\n\n예를 들어, 개발 환경에서 서버 URL을 선언하고 싶다면 다음과 같이 할 수 있습니다:\n\n```js\nflutter run --dart-define server_url=https://mywonderfulserver.development.com\n```\n\n<div class=\"content-ad\"></div>\n\n개발 API 키를 선언하고 싶을 때는 어떻게 하면 될까요? 단순히 다른 --dart-define를 추가하면 됩니다:\n\n```js\nflutter run --dart-define server_url=https://mywonderfulserver.development.com --dart-define api_key=mydevelopmentapikey\n```\n\n이 방법은 환경 변수가 몇 개 없을 때 잘 작동하지만, 변수가 많아질수록 가독성이 떨어질 수 있습니다. 변수의 수가 늘어날수록 관리하기 번거로워지고 변수를 빼먹거나 잘못 입력할 수 있는 실수가 발생할 수 있습니다.\n\n## dart-define-from-file 사용하기\n\n<div class=\"content-ad\"></div>\n\n만약 모든 변수를 파일에 넣고 그 파일을 사용할 수 있다면 어떨까요? --dart-define 방식의 가독성과 관리 용이성 문제를 해결하기 위해 Flutter는 --dart-define-from-file 옵션을 지원합니다.\n\n이를 통해 모든 변수를 파일에 넣고 해당 파일을 flutter run 또는 flutter build 명령에 선언할 수 있습니다.\n\n이전의 예제를 생각해보겠습니다. 개발 환경을 선언하는 server_url 및 api_key 두 변수가 있는 경우를 고려해 봅시다. 이를 직접 명령줄에 정의하는 대신 env/development.json이라는 JSON 파일을 만들 수 있습니다.\n\n```js\n{\n  \"server_url\": \"https://mywonderfulserver.development.com\",\n  \"api_key\": \"mydevelopmentapikey\"\n}\n```\n\n<div class=\"content-ad\"></div>\n\n그리고 파일을 전달해 주세요:\n\n```js\nflutter run --dart-define-from-file env/development.json\n```\n\n이 방법은 훨씬 확장 가능하고 가독성을 크게 향상시킵니다. 파일을 사용함으로써 환경 변수를 중앙 집중화하여 필요에 따라 쉽게 관리하고 업데이트할 수 있습니다.\n\n# 환경 변수 읽기\n\n<div class=\"content-ad\"></div>\n\n환경 변수를 선언하는 방법에 상관없이 코드에서 그 값을 읽는 방법은 일관되게 유지됩니다. 일반적으로 이러한 변수를 읽는 유일한 목적의 정적 상수 필드가 있는 클래스를 사용하여 이러한 변수를 읽는 것이 일반적입니다. 이렇게 하면 응용 프로그램 전체에서 쉽게 접근할 수 있습니다.\n\n다음은 그러한 클래스의 예시입니다:\n\n```js\nclass Environment {\n  const Environment._();\n\n  static const String serverUrl = String.fromEnvironment('server_url');\n  static const String apiKey = String.fromEnvironment('api_key');\n}\n```\n\n이 방법은 환경 변수를 처리하는 깔끔하고 조직적인 방법을 제공합니다. 또한 환경 파일에서 int 또는 bool 값도 동일한 방법으로 읽을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```dart\nstatic const int magicInt = int.fromEnvironment('magic_number');\nstatic const bool magicBool = bool.fromEnvironment('magic_bool');\n```\n\n`fromEnvironment` 팩토리는 키가 선언되지 않았을 때 오버라이드 가능한 기본값으로 설정됩니다.\n\n```dart\n// `defaultValue`가 지정되지 않은 경우, String.fromEnvironment는 \"\"를 기본값으로 사용합니다\nstatic const String stringValue = String.fromEnvironment('string_key', defaultValue: 'Hello');\n// int.fromEnvironment는 기본값으로 0을 사용합니다\nstatic const String intValue = int.fromEnvironment('int_key', defaultValue: 42);\n// bool.fromEnvironment는 기본값으로 false를 사용합니다\nstatic const String boolValue = int.fromEnvironment('bool_key', defaultValue: true);\n```\n\n# 결론\n\n\n<div class=\"content-ad\"></div>\n\n저는 처음부터 Flutter를 사용해왔는데요, 환경 설정 방법을 소개한 이후로 계속 사용해왔습니다. 이 방법 덕분에 많은 시간을 절약할 수 있고 앱을 다양한 환경에서 지원할 수 있어 매우 유연하게 유지할 수 있습니다. Flutter의 기본 환경 변수 처리 기능을 활용함으로써 개발 프로세스를 최적화하고 오류를 줄이며 더 깨끗한 코드를 유지할 수 있습니다.\n\n좋은 하루 보내세요!\n\n# 참고문헌","ogImage":{"url":"/assets/img/2024-06-20-ConfiguringEnvironmentVariablesinFlutter_0.png"},"coverImage":"/assets/img/2024-06-20-ConfiguringEnvironmentVariablesinFlutter_0.png","tag":["Tech"],"readingTime":4},{"title":"Flutter의 Clean Architecture 파트1 - 소개","description":"","date":"2024-06-20 13:46","slug":"2024-06-20-FlutterCleanArchitecturePart1Introduction","content":"\n\n\n![image](/assets/img/2024-06-20-FlutterCleanArchitecturePart1Introduction_0.png)\n\n소프트웨어 개발에서는 체계적이고 유지보수 가능한 코드베이스를 유지하는 것이 매우 중요합니다. 이때 Clean Architecture가 등장하여 코드베이스를 모듈식, 독립적이고 테스트 가능한 방식으로 구성하는 데 도움을 줍니다. 이 글에서는 Clean Architecture가 무엇인지, Flutter에서 어떻게 구현하는지, 그리고 프로젝트에 어떤 이점을 가져다 줄 수 있는지 살펴보겠습니다.\n\n커피를 마시고 준비하세요! 오랜 여정이 시작됩니다.\n\n## Flutter에서 Clean Architecture를 사용해야 하는 이유\n\n\n<div class=\"content-ad\"></div>\n\n클린 아키텍처는 모듈화, 유지보수 가능성, 테스트 가능성을 향상시켜 주는 소프트웨어 설계 철학입니다. 각 층으로 코드를 분리하여 애플리케이션을 구조화하며, 크고 복잡한 앱에 특히 유용합니다.\n\n## 장점\n\n- 모듈성과 독립성: 애플리케이션을 독립적인 부분으로 분할하고 각각을 별도로 관리 및 개발합니다.\n- 쉬운 테스트 가능성: 비즈니스 로직을 독립적으로 테스트하여 오류를 감지하기 쉽습니다.\n- 테스트 주도 개발 (TDD): TDD 원칙과 잘 부합합니다. 먼저 비즈니스 로직에 대한 테스트를 작성한 후 그 테스트를 통과할 코드를 구현할 수 있습니다.\n- 미래 확장성: 새로운 기능을 추가하거나 기존 기능을 수정하는 데 더 적은 노력이 필요합니다.\n- 재사용성: 비즈니스 로직을 다른 프로젝트나 플랫폼에서 재사용할 수 있습니다.\n- 관심사 분리: 비즈니스 로직과 사용자 인터페이스 (UI) 사이의 명확한 경계를 유지함으로써 팀 구성을 더 잘 조직화할 수 있습니다.\n- 유지보수 용이성: 층 간 의존성을 줄여 코드 유지보수를 단순화합니다.\n- 변경에 대한 유연성: 데이터 소스나 서비스를 변경하기 쉽게 합니다.\n- 좋은 문서화: 프로젝트 이해와 유지보수를 위해 구조와 작동원리를 명확히 정의합니다.\n\n클린 아키텍처는 데이터층, 도메인층, 프레젠테이션 층으로 구성되어 있습니다. 각 층은 구별된 책임과 제한된 의존성을 가지고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-20-FlutterCleanArchitecturePart1Introduction_1.png)\n\n코딩을 시작하기 전에 짧게 예제에 대해 설명하겠습니다:\n\nTMDB 플랫폼의 API를 사용하여 기본 영화 애플리케이션을 구축할 예정입니다. 이 응용 프로그램은 API에서 인기 있는 및 최상위 영화 목록을 검색하고 표시할 것입니다. 사용자는 배우 세부 정보를 포함한 영화 정보에 액세스할 수 있습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:600/1*opIWWgVq6ZlP_x5sdV0LDA.gif)\n\n\n<div class=\"content-ad\"></div>\n\n사용할 패키지 목록\n\n```js\ndependencies:\n  # 라우팅을 위해 => https://pub.dev/packages/auto_route\n  auto_route: ^7.8.3\n\n  # 이미지 캐싱을 위해 => https://pub.dev/packages/cached_network_image\n  cached_network_image: ^3.3.0\n\n  # 네트워크 요청을 위해 => https://pub.dev/packages/dio\n  dio: ^5.3.3\n\n  # 동등성을 위해 => https://pub.dev/packages/equatable\n  equatable: ^2.0.5\n\n  # 테마를 위해 => https://pub.dev/packages/flex_color_scheme\n  flex_color_scheme: ^7.3.1\n\n  flutter:\n    sdk: flutter\n\n  # 상태 관리를 위해 => https://pub.dev/packages/flutter_bloc\n  flutter_bloc: ^8.1.3\n\n  # 환경 변수를 위해 => https://pub.dev/packages/flutter_dotenv\n  flutter_dotenv: ^5.1.0\n\n  # 자산 코드 생성을 위해 => https://pub.dev/packages/flutter_gen\n  flutter_gen: ^5.4.0\n\n  # 유용한 훅을 위해 => https://pub.dev/packages/flutter_hooks\n  flutter_hooks: ^0.20.3\n\n  # 책임성을 위해 => https://pub.dev/packages/flutter_screenutil\n  flutter_screenutil: ^5.9.0\n\n  # SVG를 위해 => https://pub.dev/packages/flutter_svg\n  flutter_svg: ^2.0.9\n\n  # 함수형 프로그래밍을 위해 => https://pub.dev/packages/fpdart\n  fpdart: ^1.1.0\n\n  # 의존성 주입을 위해 => https://pub.dev/packages/get_it\n  get_it: ^7.6.4\n\n  # 테마 또는 로캘 관리를 위해 => https://pub.dev/packages/hydrated_bloc\n  hydrated_bloc: ^9.1.2\n\n  intl: ^0.19.0\n\n  # 로컬 데이터 소스를 위해\n  isar: ^3.1.0+1\n  isar_flutter_libs: ^3.1.0+1\n\n  # API 모델 생성을 위해 => https://pub.dev/packages/json_annotation\n  json_annotation: ^4.8.1\n\n  # 앱 데이터 디렉토리\n  path_provider: ^2.1.1\n\n  # 개발자를 위한 dio 인터셉터 => https://pub.dev/packages/pretty_dio_logger\n  pretty_dio_logger: ^1.3.1\n\n  # 반짝거림 효과를 위해 => https://pub.dev/packages/shimmer\n  shimmer: ^3.0.0\n\n  # URL 런처를 위해 => https://pub.dev/packages/url_launcher\n  url_launcher: ^6.2.2\n\ndev_dependencies:\n  # auto_route 생성기 => https://pub.dev/packages/auto_route_generator\n  auto_route_generator: ^7.3.1\n\n  # bloc 테스트를 위해 => https://pub.dev/packages/bloc_test\n  bloc_test: ^9.1.4\n\n  build_runner: ^2.4.6\n  flutter_gen_runner: ^5.4.0\n  flutter_lints: ^3.0.1\n  flutter_test:\n    sdk: flutter\n\n  # 로컬 데이터 소스\n  isar_generator: ^3.1.0+1\n\n  # API 모델 생성을 위해 => https://pub.dev/packages/json_serializable\n  json_serializable: ^6.7.1\n\n  # 테스트를 위해 => https://pub.dev/packages/mockito\n  mockito: ^5.4.4\n```\n\n## HTTP 요청\n\nflutter_dotenv 패키지를 사용하여 간단한 애플리케이션 상수 클래스를 만들어 봅시다.\n\n<div class=\"content-ad\"></div>\n\n```js\nclass AppConstants {\n  final baseUrl = '${dotenv.env['BASE_URL']}'; //* https://api.themoviedb.org/3\n  final apiToken = '${dotenv.env['API_TOKEN']}'; //* your TMDB token. (sign up here https://developer.themoviedb.org/docs)\n}\n```\n\nHTTP 요청을 위한 클래스를 만들어 봅시다. DioClient 클래스는 API 요청을 보내고 json 데이터를 반환할 것입니다. 여기서 주요 목적은 DioClient 클래스를 get, post, put, patch, delete 메서드로 제한하는 것입니다.\n\n저희 애플리케이션에서는 하나의 API만 사용할 것이므로, Dio를 사용하기 때문에 DioClient라고 이름 짓겠습니다. 애플리케이션이 여러 개의 API와 통신해야 하는 경우, HTTP 요청을 보내는 DioClient와 유사한 클래스가 필요합니다. 이것은 각 네트워크 클래스가 관련된 데이터 원본과 관련되어야 하기 때문입니다.\n\n예를 들어, 영화 데이터에 대해 TMDB API를 사용하고 배우에 대해 BlaBla API를 사용하는 경우, 명명 규칙에 유의해야 합니다. 네이밍의 예시로는 TmdbNetworkManager, BlaBlaClient, CatClient 등이 있을 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\nclass DioClient {\n  Dio _dio;\n\n  DioClient() {\n    _dio = Dio();\n    _dio\n      ..options.baseUrl = AppConstants.baseUrl\n      ..options.headers = {\n        HttpHeaders.contentTypeHeader: ContentType.json.mimeType,\n        HttpHeaders.authorizationHeader: 'Bearer ${AppConstants.apiToken}',\n      }\n      ..options.connectTimeout = const Duration(milliseconds: 15000)\n      ..options.receiveTimeout = const Duration(milliseconds: 15000)\n      ..options.responseType = ResponseType.json\n      ..interceptors.add(\n        PrettyDioLogger(\n          compact: false,\n          logPrint: (object) => log(object.toString(), name: 'TMDB API'),\n        ),\n      );\n  }\n\n  /// * GET\n  Future<Response> get(\n    String url, {\n    Map<String, dynamic>? queryParameters,\n    Options? options,\n    CancelToken? cancelToken,\n    ProgressCallback? onReceiveProgress,\n  }) async {\n    try {\n      final response = await _dio.get(\n        url,\n        queryParameters: queryParameters,\n        options: options,\n        cancelToken: cancelToken,\n        onReceiveProgress: onReceiveProgress,\n      );\n      return response;\n    } on DioException {\n      rethrow;\n    }\n  }\n\n  /// * POST\n  Future<Response> post(\n    String uri, {\n    data,\n    Map<String, dynamic>? queryParameters,\n    Options? options,\n    CancelToken? cancelToken,\n    ProgressCallback? onSendProgress,\n    ProgressCallback? onReceiveProgress,\n  }) async {\n    try {\n      final response = await _dio.post(\n        uri,\n        data: data,\n        queryParameters: queryParameters,\n        options: options,\n        cancelToken: cancelToken,\n        onSendProgress: onSendProgress,\n        onReceiveProgress: onReceiveProgress,\n      );\n      return response;\n    } on DioException {\n      rethrow;\n    }\n  }\n\n  /// * PUT\n  Future<Response> put(\n    String uri, {\n    data,\n    Map<String, dynamic>? queryParameters,\n    Options? options,\n    CancelToken? cancelToken,\n    ProgressCallback? onSendProgress,\n    ProgressCallback? onReceiveProgress,\n  }) async {\n    try {\n      final response = await _dio.put(\n        uri,\n        data: data,\n        queryParameters: queryParameters,\n        options: options,\n        cancelToken: cancelToken,\n        onSendProgress: onSendProgress,\n        onReceiveProgress: onReceiveProgress,\n      );\n      return response;\n    } on DioException {\n      rethrow;\n    }\n  }\n\n  /// * PATCH\n  Future<Response> patch(\n    String uri, {\n    data,\n    Map<String, dynamic>? queryParameters,\n    Options? options,\n    CancelToken? cancelToken,\n    ProgressCallback? onSendProgress,\n    ProgressCallback? onReceiveProgress,\n  }) async {\n    try {\n      final response = await _dio.patch(\n        uri,\n        data: data,\n        queryParameters: queryParameters,\n        options: options,\n        cancelToken: cancelToken,\n        onSendProgress: onSendProgress,\n        onReceiveProgress: onReceiveProgress,\n      );\n      return response;\n    } on DioException {\n      rethrow;\n    }\n  }\n\n  /// * DELETE\n  Future<dynamic> delete(\n    String uri, {\n    data,\n    Map<String, dynamic>? queryParameters,\n    Options? options,\n    CancelToken? cancelToken,\n    ProgressCallback? onSendProgress,\n    ProgressCallback? onReceiveProgress,\n  }) async {\n    try {\n      final response = await _dio.delete(\n        uri,\n        data: data,\n        queryParameters: queryParameters,\n        options: options,\n        cancelToken: cancelToken,\n      );\n      return response;\n    } on DioException {\n      rethrow;\n    }\n  }\n}\n```\n\n## 네트워크 오류 모델\n\n네트워크 오류 모델을 만들어봅시다. 이 모델은 나쁜 응답 오류가 발생할 때 생성되므로 API에서 오류 메시지를 표시할 수 있습니다.\n\nTMDB API의 오류 모델은 아래와 같습니다.\n\n<div class=\"content-ad\"></div>\n\n```json\n@JsonSerializable()\nclass NetworkErrorModel extends Equatable {\n  @JsonKey(name: 'status_code')\n  final int? statusCode;\n  @JsonKey(name: 'status_message')\n  final String? statusMessage;\n\n  const NetworkErrorModel({this.statusCode, this.statusMessage});\n\n  factory NetworkErrorModel.fromJson(Map<String, dynamic> json) {\n    return _$NetworkErrorModelFromJson(json);\n  }\n\n  Map<String, dynamic> toJson() => _$NetworkErrorModelToJson(this);\n\n  @override\n  List<Object?> get props => [statusCode, statusMessage];\n}\n```\n\n## 로컬 데이터베이스\n\n데이터베이스에 접근하는 클래스를 만들어 봅시다.\n\n```json\n/// 로컬 데이터베이스를 나타내는 클래스.\n///\n/// 이 클래스는 Isar 데이터베이스를 초기화하고 액세스하는 방법을 제공합니다.\nclass LocalDatabase {\n  late final Isar _isar;\n  bool _isInitialized = false;\n\n  /// 초기화된 Isar 데이터베이스 인스턴스를 반환합니다.\n  ///\n  /// 데이터베이스가 초기화되지 않은 경우 [IsarError]를 throw합니다.\n  Isar get db => _isInitialized ? _isar : throw IsarError('Isar가 초기화되지 않았습니다.');\n\n  /// Isar 데이터베이스를 초기화합니다.\n  ///\n  /// 데이터베이스가 이미 초기화된 경우 [IsarError]를 throw합니다.\n  Future<void> initialize() async {\n    if (_isInitialized) throw IsarError('Isar가 이미 초기화되었습니다.');\n\n    final directory = await getApplicationDocumentsDirectory();\n    _isar = await Isar.open([MovieDetailCollectionSchema], directory: directory.path);\n\n    _isInitialized = true;\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## 에러 처리\n\nDioException을 사용하여 네트워크 오류를 처리하는 클래스를 만들어 보겠습니다.\n\n```js\nclass NetworkException extends Equatable implements Exception {\n  late final String message;\n  late final int? statusCode;\n\n  NetworkException.fromDioError(DioException dioException) {\n    statusCode = dioException.response?.statusCode;\n\n    switch (dioException.type) {\n      case DioExceptionType.cancel:\n        message = 'API 서버로의 요청이 취소되었습니다';\n        break;\n\n      case DioExceptionType.connectionTimeout:\n        message = 'API 서버와의 연결 시간 초과';\n        break;\n\n      case DioExceptionType.receiveTimeout:\n        message = 'API 서버와의 연결 중 수신 시간 초과';\n        break;\n\n      case DioExceptionType.sendTimeout:\n        message = 'API 서버와의 연결 중 송신 시간 초과';\n        break;\n\n      case DioExceptionType.connectionError:\n        if (dioException.error.runtimeType == SocketException) {\n          message = '인터넷 연결을 확인해주세요';\n          break;\n        } else {\n          message = '예기치 않은 오류가 발생했습니다';\n          break;\n        }\n\n      case DioExceptionType.badCertificate:\n        message = '잘못된 인증서';\n        break;\n\n      case DioExceptionType.badResponse:\n        final model = NetworkErrorModel.fromJson(dioException.response?.data as Map<String, dynamic>);\n        message = model.statusMessage ?? '예기치 않은 오류가 발생했습니다';\n        break;\n\n      case DioExceptionType.unknown:\n        message = '예기치 않은 오류가 발생했습니다';\n        break;\n    }\n  }\n\n  @override\n  List<Object?> get props => [message, statusCode];\n}\n```\n\n그리고 IsarError를 사용하여 로컬 데이터베이스 오류를 처리하는 클래스를 만들어 보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nclass DatabaseException extends Equatable implements Exception {\n  late final String message;\n\n  DatabaseException.fromIsarError(IsarError isarError) : message = isarError.message;\n\n  @override\n  List<Object?> get props => [message];\n}\n```\n\n알겠어요! 여기까지입니다. 이 부분에서는 여기까지 언급할 거예요.\n\n이제 Clean Architecture에 대해 준비되었습니다.\n\n다음 파트\n","ogImage":{"url":"/assets/img/2024-06-20-FlutterCleanArchitecturePart1Introduction_0.png"},"coverImage":"/assets/img/2024-06-20-FlutterCleanArchitecturePart1Introduction_0.png","tag":["Tech"],"readingTime":12},{"title":"플러터닌자 도쿄 2024가 끝났어요","description":"","date":"2024-06-20 13:45","slug":"2024-06-20-FlutterNinjasTokyo2024isover","content":"\n\n플러터닌자 도쿄 2024가 끝났어요!!\n\n가장 즐거웠지만 가장 힘들었던 작업이었어요! 😄\n\n세션 세부 정보는 다음 기사를 확인해주세요. 훌륭한 요약이 제공돼요. (전부 일본어에요)\n\n이 글에서는 플러터닌자를 만들 때 들어간 생각과 감사의 마음, 그리고 2025년을 향한 우리의 포부를 공유하고 싶어요.\n\n<div class=\"content-ad\"></div>\n\n# 플러터닌자가 시작된 방법\n\n먼저, 2020년 4월에 플러터다이가쿠를 시작했습니다. 그 이후로 참가자 수와 엔지니어 수준 모두가 성장했고, 열심히 스터디 세션과 해카톤을 주최하며 일본의 플러터 커뮤니티를 촉진했습니다.\n\n점차적으로 일본에 국한되지 않고 해외 사람들을 포함한 커뮤니티를 만들고 이벤트를 주최하는 게 더 의미있을 것 같다고 느꼈습니다.\n\n이 마음이 시작된 것은 2022년쯤이었는데, 2022년 11월 태국 여행 후, 코로나 상황이 안정되기 시작하자 진지하게 영어 공부를 시작했습니다. 그 이후로 매일 공부를 계속하며 2023년에는 주중 매일 3시간 정도 영어에 몰두했습니다. 심지어 유튜브, 드라마, 애니메이션까지 모든 즐길 거리를 영어로 전환해보며 더 많은 시간을 할애하기도 했습니다.\n\n<div class=\"content-ad\"></div>\n\n그래서 나는 영어 공부(주로 말하기)에 박차를 가했고, 2024년 초에 영어 유튜브 채널을 시작했습니다.\n\n그때쯤 Remi라는 Rivepord 창작자의 트윗을 우연히 발견했는데, 그는 일본에서 Flutter 컨퍼런스가 있는지 물어봤습니다. 그래서 그가 방문하고 싶어하는 Flutter 컨퍼런스가 없는지 물었습니다.\n\n그것이 Remi를 위한 행사를 개최할 수 있다면, 어째서 영어 Flutter 이벤트를 만들지 않는지 하는 아이디어를 불러일으켰습니다. 또한 나에게는 영어 실력을 활용할 수 있는 좋은 기회였습니다.\n\n일본에는 이미 FlutterKaigi라는 주요 Flutter 이벤트가 있습니다.\n\n<div class=\"content-ad\"></div>\n\n작년에 FlutterDaigaku에서 많은 이벤트를 개최했으며, FlutterKaigi와 경쟁 관계인 것으로 생각하는 사람도 있을 수 있지만, 실제로는 아닙니다. 우리는 의도적으로 다른 것을 만들려고 노력하고 있어요. 같은 일을 하는 여러 이벤트가 있다고 해서 좋다고 생각하지 않아요.\n\n또한, FlutterKaigi 팀 멤버들과 일정이 겹치지 않도록 조정하고 갈등을 일으키지 않도록 주의하고 있어요.\n\n원래 iOS 엔지니어였던 저로서, iOSDC와 try! Swift 같은 두 거장 컨퍼런스가 있는 것을 알고 있어요. 저는 FlutterNinjas를 try! Swift의 영어판으로, FlutterKaigi를 일본의 iOSDC로 생각해요.\n\n# 글로벌 참석자들에 의해 감동받았어요\n\n<div class=\"content-ad\"></div>\n\n내 소망대로, 영어 플러터 컨퍼런스를 만들었다는 사실에 너무 기뻐요. 스페인, 독일, 영국, 대만, 한국, 말레이시아 등 다양한 국가의 많은 분들이 일본을 찾아주셔서 정말 감동받았어요.\n\n물론, 플러터닌자들의 매력 뿐만 아니라 일본과 도쿄의 매료도가 있었죠. 많은 일본 팬들이 항상 일본을 방문하고 싶다고 말하는데, 우리는 플러터 엔지니어들에게 완벽한 기회를 제공할 수 있었어요.\n\n플러터닌자들 중 참가자들이 서로 친구를 사귀고, 후에도 후지산과 도쿄 주변을 구경하며 초밥을 즐기는 모습을 보니 마음이 따뜻해졌어요.\n\n# 참가자들과 후원사들에게 감사드립니다\n\n<div class=\"content-ad\"></div>\n\n이번에는 외국에서 오신 연사 분들의 여행 및 4일간의 호텔 숙박비를 지원했어요. 또한 2일간의 점심 식대, 네트워킹 파티 케이터링, 그리고 다양한 선물에도 돈을 썼어요.\n\n참가자들에게는 저렴하지 않은 행사였는데, 코딩 매직과 머니 포워드와 같은 후원사들과 물론 참가자 분들이 후원을 도와주셔서 가능했어요.\n\n많은 기업들이 커뮤니티 후원사가 되었어요. 몇몇은 직접 참석하지는 못했지만 그저 우리를 도울 수 있어서 후원을 해주었어요! 정말 감사합니다.\n\n<img src=\"/assets/img/2024-06-20-FlutterNinjasTokyo2024isover_0.png\" />\n\n<div class=\"content-ad\"></div>\n\nGoogle Flutter 팀은 스왹도 지원해주셔서 최종 추첨이 흥미로워졌어요!\n\n모든 분들 덕분에 적자 없이 재미있는 이벤트를 개최할 수 있었습니다! 이 이벤트의 가치를 믿고 앞으로 나아갈 수 있었던 것은 여러분 덕분이었어요. 누가 참석할지 또 후원사가 우리를 지원해 줄지 예측할 수 없는 상황이었지만, 최악의 경우에 대비하고 있었어요. 다행히도 잘 되었죠.\n\n# Majid에게 특별 감사\n\n안타깝게도 Majid은 FlutterNinjas에 참석하지 못했지만, Codemagic을 소개해주시고 영향력을 행사해주셔서 유럽 플러터 커뮤니티의 많은 분들이 참석할 수 있었어요. Majid께 매우 감사드립니다.\n\n<div class=\"content-ad\"></div>\n\n하지만 노르웨이에서 500명의 이벤트를 주최한 플러터 바이킹에 대한 그의 경험도 망설임 없이 공유했습니다.\n\n사실, Majid와 나는 플러터닌자가 어떻게 진행되고 있는지 논의하기 위해 세 번이나 네 번 만나기도 했습니다. 그는 수익이 나지 않더라도 관심을 가졌습니다. 정말 고마워요.\n\n# 주최팀에 대한 감사\n\n![이미지](/assets/img/2024-06-20-FlutterNinjasTokyo2024isover_1.png)\n\n<div class=\"content-ad\"></div>\n\n↑ 제가 사진에 없는 이유는 애프터 파티에 참석했기 때문입니다. 😂\n\n이 프로젝트를 흥미롭게 여기고 도움을 준 모든 분들에게 정말 감사드립니다. FlutterNinjas 초기 조직 팀의 일원이 된 것은 유익했고, FlutterNinjas를 계속 발전시키고 싶습니다!\n\n# 2025년을 바라보며\n\n올해 배운 교훈 중 하나는 6월 행사를 위해 2월에 장소와 일정을 결정해 일정이 매우 타이트했다는 것입니다. 이로 인해 연사 및 후원사를 모집하는 과정이 서둘러졌으며 더 여유로운 준비가 가능한 여유가 적었습니다.\n\n<div class=\"content-ad\"></div>\n\n이에 대처하기 위해 우리는 이미 2025년 계획을 실행 중이며, 장소를 찾는 것부터 시작하고 있어요.\n\n이번에는 135명이 참가했지만, 다음에는 500명을 대상으로 컨퍼런스를 개최할 계획이에요.\n\n저는 FlutterNinjas가 세계에서 가장 흥미로운 Flutter 컨퍼런스가 될 잠재력이 있다고 믿어요. 유럽 Flutter 컨퍼런스가 500에서 1000명의 참가자를 모은다는 소식을 들었어요. 비록 FlutterNinjas가 아직 그 규모에 이르지는 않지만, 대만, 한국, 인도, 말레이시아의 아시아 플러터 커뮤니티의 주요 멤버들이 일본을 방문하고 행사 분위기를 고취시켰어요. 각국의 참가자로 구성된 행사는 실제로 국제적인 행사였어요. 일본은 이들 아시아 국가들과의 근접성을 바탕으로 동시에 먼 거리이면서 매력적인 관광 목적지로서 상당한 장점을 제공해요.\n\n일본의 Flutter 커뮤니티와 일본 자체를 활성화시키고, 그냥 이런 활동을 즐기기 때문에 이를 계속하고 싶어요.\n\n<div class=\"content-ad\"></div>\n\n2025년에 대한 업데이트를 받으려면 트위터에서 FlutterNinjas를 팔로우해 주세요! \n\n[FlutterNinjas](https://x.com/FlutterNinjas)","ogImage":{"url":"/assets/img/2024-06-20-FlutterNinjasTokyo2024isover_0.png"},"coverImage":"/assets/img/2024-06-20-FlutterNinjasTokyo2024isover_0.png","tag":["Tech"],"readingTime":4},{"title":"플러터 위젯 플러터 앱에 카메라 기능 구현하기","description":"","date":"2024-06-20 13:43","slug":"2024-06-20-FlutterWidgetImplementingCameraFeatureinyourFlutterApp","content":"\n\n안녕하세요 여러분, 어떻게 지내세요? 잠깐 사라졌다가 다시 돌아왔습니다. 지금은 플러터 애플리케이션에 카메라를 구현하는 방법에 대해 설명해 드릴게요.\n\n저는 이 기능을 앱에 추가할 필요가 별로 없었지만, 최근에 작업 중인 애플리케이션에 이 기능을 추가해야 했어요. 여러분도 구현하고 싶어 했던 부분이라면 함께 고고씽해요:\n\n단계 1: pub.dev 사이트에서 \"camera\"라는 플러터 패키지를 import해 주세요.\n\n귀하의 애플리케이션에 카메라 패키지를 종속성으로 추가해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n링크: https://pub.dev/packages/camera\n\n![이미지](/assets/img/2024-06-20-FlutterWidgetImplementingCameraFeatureinyourFlutterApp_0.png)\n\n단계 2: 다른 OS(android 및 ios) 설정:\n\n지금, 이 패키지를 앱에 구현하는 동안, 각 OS에 대한 플러터 앱 코드베이스를 변경해야 합니다.\n\n<div class=\"content-ad\"></div>\n\niOS 구현:\n\nios/Runner/Info.plist에 두 개의 행을 추가하세요:\n\n- Privacy - Camera Usage Description 키와 사용 설명이 있는 한 줄을 추가해주세요.\n- 그리고 Privacy - Microphone Usage Description 키와 사용 설명이 있는 한 줄을 더 추가해주세요.\n\n만약 Info.plist를 텍스트로 편집하는 경우, 다음을 추가하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\n<key>NSCameraUsageDescription</key>\n<string>여기에 사용 설명 입력</string>\n<key>NSMicrophoneUsageDescription</key>\n<string>여기에 사용 설명 입력</string>\n```\n\nAndroid 구현:\n\nandroid/app/build.gradle 파일에서 최소 Android SDK 버전을 21로 변경하세요.\n\n```js\nminSdkVersion 21\n```\n\n<div class=\"content-ad\"></div>\n\nStep 3: 퍼미션 핸들러 패키지와 패스 프로바이더 패키지 설치하기\n\n이 패키지를 설치하는 이유는 사용자에게 우리 애플리케이션에서 장치의 카메라를 사용할 수 있도록 허용하도록 허락을 받으려고 하는 것입니다. 허가가 허용되지 않으면 장치에서 카메라를 사용할 수 없을 것 같습니다. 사진을 찍은 후에는 이미지가 장치에 어디에 저장되었는지 액세스할 수 있어야 하므로 path_provider를 사용합니다.\n\n퍼미션 핸들러 링크: https://pub.dev/packages/permission_handler\n\n![image](/assets/img/2024-06-20-FlutterWidgetImplementingCameraFeatureinyourFlutterApp_1.png)\n\n<div class=\"content-ad\"></div>\n\n경로 제공 링크: [여기](https://pub.dev/packages/path_provider)\n\n![이미지](/assets/img/2024-06-20-FlutterWidgetImplementingCameraFeatureinyourFlutterApp_2.png)\n\n단계 4: 카메라 초기화 및 권한 요청\n\n다음으로 할 일은 앱에서 카메라를 초기화하고 그 과정에서 기기에 있는 카메라 목록을 가져올 수 있습니다. 아래 코드는 권한이 부여되었고 카메라가 초기화된 주요 파일인 main.dart 파일이 어떻게 보이는지 예시입니다.\n\n<div class=\"content-ad\"></div>\n\n```dart\nlate List<CameraDescription> _cameras;\nvoid main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n\n  _cameras = await availableCameras();\n\n  runApp(const MyApp());\n  // runApp(const MyApp());\n}\n\nclass MyApp extends StatefulWidget {\n  const MyApp({super.key});\n\n  @override\n  State<MyApp> createState() => _MyAppState();\n}\n\nclass _MyAppState extends State<MyApp> {\n  @override\n  void initState() {\n    super.initState();\n    requestStoragePermission();\n  }\n\n  void requestStoragePermission() async {\n    // Check if the platform is not web, as web has no permissions\n    if (!kIsWeb) {\n      // Request storage permission\n      var status = await Permission.storage.status;\n      if (!status.isGranted) {\n        await Permission.storage.request();\n      }\n\n      // Request camera permission\n      var cameraStatus = await Permission.camera.status;\n      if (!cameraStatus.isGranted) {\n        await Permission.camera.request();\n      }\n    }\n  }\n\n  // This widget is the root of your application.\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp.router(\n      debugShowCheckedModeBanner: false,\n      routerConfig: router,\n    );\n  }\n}\n```\n\n제 5 단계 : 카메라 기능 구현\n\n카메라 컨트롤러 초기화\n\n_CameraAppState 클래스에서 initState 메서드에서 카메라 컨트롤러를 초기화합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nlate CameraController controller;\n```\n\n여기서, 카메라를 초기화하고 해상도 프리셋을 ResolutionPreset.max로 설정했습니다.\n\n카메라 초기화 처리\n\n카메라를 초기화하고 이 과정 중에 발생할 수 있는 모든 오류를 처리하기 위해 controller.initialize()를 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\ncontroller.initialize().then((_) {\n  if (!mounted) {\n    return;\n  }\n  setState(() {});\n}).catchError((Object e) {\n  if (e is CameraException) {\n    switch (e.code) {\n      case 'CameraAccessDenied':\n        // 여기에서 액세스 오류를 처리합니다.\n        break;\n      default:\n        // 다른 오류를 처리합니다.\n        break;\n    }\n  }\n});\n```\n\nUI 구축하기\n\nUI는 카메라 피드를 표시하는 CameraPreview 위젯과 이미지를 캡처하는 FloatingActionButton으로 구성됩니다. 그래서 FloatingActionButton을 클릭하면 카메라에 의해 표시된 이미지를 캡처할 수 있습니다.\n\n```js\nreturn SafeArea(\n  child: Scaffold(\n    appBar: AppBar(\n      // 앱 바 설정\n    ),\n    body: Stack(\n      children: <Widget>[\n        CameraPreview(controller),\n        Align(\n          alignment: Alignment.bottomCenter,\n          child: Padding(\n            padding: const EdgeInsets.only(bottom: 16.0),\n            child: FloatingActionButton(\n              onPressed: () {\n                _takePicture(); // 사진 촬영 메서드 호출\n              },\n              child: Icon(Icons.camera),\n              backgroundColor: Colors.white,\n              foregroundColor: AppColors.deepBlue,\n            ),\n          ),\n        ),\n      ],\n    ),\n  ),\n);\n```\n\n<div class=\"content-ad\"></div>\n\n이미지 캡처 및 보기\n\n여기에 플로팅 액션 버튼에 연결한 함수를 구현했습니다. 이 함수는 이미지를 캡처하는 유일한 목적으로 사용됩니다:\n\n```js\nvoid _takePicture() async {\n  try {\n    final XFile picture = await controller.takePicture();\n    setState(() {\n      imageFile = picture;\n    });\n    // 이미지를 캡처한 후 이미지 뷰 페이지로 이동\n    Navigator.push(\n      context,\n      MaterialPageRoute(\n        builder: (context) => ImageViewPage(imagePath: imageFile!.path),\n      ),\n    );\n  } catch (e) {\n    print(\"사진 찍기 오류 발생: $e\");\n  }\n}\n```\n\n캡처한 이미지 파일 경로를 가져와 다음 페이지에서 캡처한 이미지를 볼 수 있도록 탐색을 포함했습니다.\n\n<div class=\"content-ad\"></div>\n\n이미지 보기\n\n이제 사진을 찍은 후에는 찍은 이미지를 보고 싶을 것입니다, 맞죠? 찍은 이미지를 볼 수 있는 페이지로 이동하는 것을 허용하는 페이지가 여기 있습니다:\n\n```js\nclass ImageViewPage extends StatefulWidget {\n  final String imagePath;\n  const ImageViewPage({super.key, required this.imagePath});\n\n  @override\n  State<ImageViewPage> createState() => _ImageViewPageState();\n}\n\nclass _ImageViewPageState extends State<ImageViewPage> {\n  bool isLoading = false;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Captured Image'),\n      ),\n      body: Center(\n        child: Image.file(File(widget.imagePath)),\n      ),\n    );\n  }\n}\n```\n\n마무리\n\n<div class=\"content-ad\"></div>\n\n이 가이드에서는 카메라 패키지를 사용하여 Flutter 응용 프로그램에서 간단한 카메라 기능을 구현했습니다. 카메라를 초기화하고 초기화 오류를 처리하며, 캡처 및 이미지 보기를 위한 사용자 친화적인 UI를 제공했습니다. 이는 Flutter 앱에서 이미지 필터, 비디오 녹화 등 더 고급 카메라 기능을 구축하기 위한 기본 단계입니다. 코딩을 즐기세요!\n\n아래는 사진을 찍고 그 작업을 실행하는 페이지의 전체 코드 구현입니다:\n\n```js\nclass CameraApp extends StatefulWidget {\n  final List<CameraDescription> cameras;\n  const CameraApp({super.key, required this.cameras});\n\n  @override\n  State<CameraApp> createState() => _CameraAppState();\n}\n\nclass _CameraAppState extends State<CameraApp> {\n  late CameraController controller;\n  late XFile? imageFile;  // 캡처된 이미지 파일을 저장하는 변수\n\n  @override\n  void initState() {\n    super.initState();\n    controller = CameraController(widget.cameras[1], ResolutionPreset.max);\n    controller.initialize().then((_) {\n      if (!mounted) {\n        return;\n      }\n      setState(() {});\n    }).catchError((Object e) {\n      if (e is CameraException) {\n        switch (e.code) {\n          case 'CameraAccessDenied':\n            // 여기서 액세스 오류 처리\n            break;\n          default:\n            // 다른 오류 처리\n            break;\n        }\n      }\n    });\n  }\n\n  @override\n  void dispose() {\n    controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    if (!controller.value.isInitialized) {\n      return Container();\n    }\n    return SafeArea(\n      child: Scaffold(\n        appBar: AppBar(\n          backgroundColor: AppColors.deepBlue,\n          leading: BackButton(\n            color: Colors.white,\n            onPressed: () {\n              Navigator.pop(context);\n            },\n          ),\n          centerTitle: true,\n          title: Text(\n            '사진 찍기',\n            style: TextStyle(color: Colors.white),\n          ),\n        ),\n        body: Stack(\n          children: <Widget>[\n            CameraPreview(controller),\n            Align(\n              alignment: Alignment.bottomCenter,\n              child: Padding(\n                padding: const EdgeInsets.only(bottom: 16.0),\n                child: FloatingActionButton(\n                  onPressed: () {\n                    _takePicture();  // 사진 찍는 메서드 호출\n                  },\n                  child: Icon(Icons.camera),\n                  backgroundColor: Colors.white,\n                  foregroundColor: AppColors.deepBlue,\n                ),\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  // 사진 찍는 메서드\n  void _takePicture() async {\n    try {\n      final XFile picture = await controller.takePicture();\n      setState(() {\n        imageFile = picture;\n      });\n      // 이미지 캡처 후 이미지 뷰 페이지로 이동\n      Navigator.push(\n        context,\n        MaterialPageRoute(\n          builder: (context) => ImageViewPage(imagePath: imageFile!.path),\n        ),\n      );\n    } catch (e) {\n      print(\"사진 찍기 오류: $e\");\n    }\n  }\n}\n```\n\n<img src=\"https://miro.medium.com/v2/resize:fit:592/1*oqIKI2wzNfzOj1IJ-EDmoQ.gif\" />\n\n\n<div class=\"content-ad\"></div>\n\n텍스트를 위해 감사합니다 👏 재미있게 읽으셨다면 한 번 클릭해 주시고, 계속해서 많은 글 읽어주세요. 함께 해서 즐거웠습니다 😊✌️","ogImage":{"url":"/assets/img/2024-06-20-FlutterWidgetImplementingCameraFeatureinyourFlutterApp_0.png"},"coverImage":"/assets/img/2024-06-20-FlutterWidgetImplementingCameraFeatureinyourFlutterApp_0.png","tag":["Tech"],"readingTime":9},{"title":"플러터에서 모양과 클리핑 마스터하기","description":"","date":"2024-06-20 13:42","slug":"2024-06-20-MasteringShapesandClippinginFlutter","content":"\n\n도형과 상자를 다루는 것은 설계된 UI를 구현하는 방법을 알지 못하면 압도될 수 있습니다. 이 기사에서는 매우 기초부터 시작하여 일부 고급 예제로 이동할 것입니다.\n\n## 1. 도형과 상자란 무엇인가요?\n\n도형은 해당 경로에 의해 정의된 어떤 형태를 나타낼 수 있습니다.\n\n상자는 4개의 점으로 구성된 직사각형 모양을 나타냅니다. 테두리 반경과 같은 추가 속성을 가질 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n위젯 Flutter의 다양한 컨텍스트에서 상자가 나타날 수 있어요. \n\n예를 들어:\n\n- RenderBox: 비 슬리버 컨텍스트의 위젯의 RenderObject\n- BoxDecoration\n- BoxBorder\n\n또한 ShapeDecoration, ShapeBorder와 같은 클래스들도 있어요.\n\n우리는 Container, DecoratedSlivers 또는 DecoratedBoxes를 스타일링하기 위해 자주 BoxDecoration을 사용해요:\n\n<div class=\"content-ad\"></div>\n\n\n```js\nDecoratedBox(\n  decoration: BoxDecoration( // <- this\n    borderRadius: BorderRadius.circular(10),\n    color: Colors.amber,\n  ),\n  child: const SizedBox(height: 200, width: 200),\n)\n```\n\n그냥 이렇게 해서, 결과를 얻습니다:\n\n<img src=\"/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_0.png\" />\n\n대안으로 ShapeDecoration을 사용할 수도 있는데, 이것은 색상, 그림자, 그라디언트의 비슷한 사용자 정의를 제공하지만 주요 차이점은 그 모양 매개변수가 BoxShape 대신 ShapeBorder를 사용한다는 것입니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\nDecoratedBox(\n  decoration: ShapeDecoration( // <- 이 부분\n    color: Colors.amber,\n    shape: BeveledRectangleBorder(borderRadius: BorderRadius.circular(20)),\n  ),\n  child: const SizedBox(height: 200, width: 200),\n)\n```\n\n<img src=\"/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_1.png\" />\n\n그럼 ShapeBorder는 정확히 무엇인가요?\n\n구현을 확인하면 좀 더 명확해집니다. OutlinedBorder, StarBorder, BeveledRectangleBorder와 같은 슈퍼클래스들이 있습니다. 이것들은 위젯을 꾸미기 위한 다양한 모양들입니다. 그리고 WidgetStateOutlinedBorder도 있습니다. WidgetStates에 익숙하지 않다면 해당 기사를 읽어보세요.\n\n\n<div class=\"content-ad\"></div>\n\n경계의 본질은 내부 경로와 외부 경로 2개가 있어야 한다는 것을 의미합니다:\n\n![MasteringShapesandClippinginFlutter](/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_2.png)\n\n베지에 곡선에 익숙하지 않다면, 이 대화식 가이드를 확인하는 것을 추천합니다. 플러터의 Path는 선형, 이차, 삼차 및 콘회의 절을 지원합니다.\n\n용어는 여기까지, 이제 재미있는 일을 시작해 봅시다: 사용자 정의 모양을 만들어 보세요!\n\n<div class=\"content-ad\"></div>\n\n# 2. 사용자 정의 ShapeBorder 구현\n\n위 작업을 수행하려면 ShapeBorder의 슈퍼 클래스 또는 OutlinedBorder를 만들고 다음 메서드를 구현해야 합니다:\n\n- getInnerPath 및 getOuterPath: 해당 경로를 반환하는 메서드\n- paint: 모양을 그리는 메서드\n- scale, copyWith\n\n원하는 메시지 버블 모양을 만들어보겠습니다. 원구획을 사용하고 두께(w) 매개변수를 변수로 사용하세요.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_3.png)\n\n```js\nclass MessageShapeBorder extends OutlinedBorder {\n  final double borderRadius;\n  final double weight;\n\n  const MessageShapeBorder({\n    super.side, \n    this.borderRadius = 50,\n    this.weight = 2.5,\n  });\n\n  ...\n\n}\n```\n\n그 다음으로, getOuterPath 메서드를 구현합니다. 여기서 경로는 아래 왼쪽 모서리에서 시계 방향으로 이동하는 선 및 물결 모양 세그먼트로 구성됩니다.\n\n```js\n  @override\n  Path getOuterPath(Rect rect, {TextDirection? textDirection}) {\n    final double left = rect.left;\n    final double right = rect.right;\n    final double top = rect.top;\n    final double bottom = rect.bottom;\n\n    final radius = borderRadius;\n    final offset = 10;\n\n    return Path()\n      ..moveTo(left, bottom)\n      ..conicTo(left + offset, bottom - offset, left + offset,\n          bottom - 2 * radius, weight)\n      ..lineTo(left + offset, top + radius)\n      ..conicTo(left + offset, top, left + offset + radius, top, weight)\n      ..lineTo(right - radius, top)\n      ..conicTo(right, top, right, top + radius, weight)\n      ..lineTo(right, bottom - radius)\n      ..conicTo(right, bottom, right - radius, bottom, weight)\n      ..close();\n  }\n```\n\n\n<div class=\"content-ad\"></div>\n\n더 명확하게 하기 위해, 아래는 각 행이 하는 작업을 시각적으로 보여줍니다:\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*KKbxvf4nJa9IXIUcPdPUxg.gif)\n\n이제 약간 다른 내부 경로를 만들어 봅시다:\n\n```js\n  @override\n  Path getInnerPath(Rect rect, {TextDirection? textDirection}) {\n    final strokeWidth = side.width;\n\n    final double left = rect.left + strokeWidth;\n    final double right = rect.right - strokeWidth;\n    final double top = rect.top + strokeWidth;\n    final double bottom = rect.bottom - strokeWidth;\n\n    final radius = math.max(0, borderRadius - 10);\n    final offset = 10;\n\n    return Path()\n      ..moveTo(left + offset + radius, bottom)\n      ..conicTo(\n          left + offset, bottom, left + offset, bottom - 2 * radius, weight)\n      ..lineTo(left + offset, top + radius)\n      ..conicTo(left + offset, top, left + offset + radius, top, weight)\n      ..lineTo(right - radius, top)\n      ..conicTo(right, top, right, top + radius, weight)\n      ..lineTo(right, bottom - radius)\n      ..conicTo(right, bottom, right - radius, bottom, weight)\n      ..close();\n  }\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n  @override\n  void paint(Canvas canvas, Rect rect, {TextDirection? textDirection}) {\n    canvas.drawPath(getInnerPath(rect), Paint()..color = side.color);\n  }\n```\n\n<img src=\"/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_4.png\" />\n\n이제 이 모양을 다음과 같이 DecoratedBox에서 사용할 수 있습니다:\n\n```js\nDecoratedBox(\n  decoration: ShapeDecoration(\n    shape: MessageShapeBorder(\n      borderRadius: 30,\n      fillColor: Color(0xFF7ADEFF)\n    ),\n    color: Color(0xFFd6f5ff),\n  ),\n  child: Padding(\n    padding: EdgeInsets.all(20).copyWith(left: 30),\n    child: Text(\"샘플 메시지 텍스트\"),\n  ),\n)\n```\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_5.png\" />\n\n안녕하세요! 코닉 섹션의 무게를 AnimatedBuilder를 사용하여 애니메이션할 수 있습니다. 만약 플러터의 애니메이션에 익숙하지 않다면, 꼭 공식 안내서를 읽어보시기를 강력히 추천합니다.\n\n```js\nMessageShapeBorder(\n  side: BorderSide(color: Color(0xFF7ADEFF), width: animation.value + 2),\n  weight: animation.value,\n  borderRadius: 30\n)\n```\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1088/1*AqcXygpWbTcwMHVyDkAf6A.gif\" />\n\n\n<div class=\"content-ad\"></div>\n\n# 3. 사용 중인 클리퍼\n\nFlutter에서는 여러 내장 클리퍼가 있습니다. 예를 들면:\n\n- 직사각형에 사용하는 ClipRect\n- 둥근 직사각형에 사용하는 ClipRRect\n- 원과 타원에 사용하는 ClipOval\n- 사용자 정의 경로에 사용하는 ClipPath\n\n첫 세 개는 사용하기 매우 간단합니다. 클리핑을 원하는 위젯을 해당 클리퍼로 감싸기만 하면 클리핑 효과를 얻을 수 있습니다. 그러나 이러한 클래스들에 대해 더 알고 싶다면 여기 공식 문서 링크를 참조해주세요.\n\n<div class=\"content-ad\"></div>\n\nClipPath은 CustomClipper를 인수로 사용합니다. 대부분의 경우에는 ShapeBorder를 ShapeBorderClipper에 전달하면 됩니다. 이는 ShapeBorder의 외부 경로로 자식을 클리핑하는 CustomClipper의 구현입니다:\n\n```js\nClipPath(\n  clipper: const ShapeBorderClipper( // <- 이 부분\n    shape: MessageShapeBorder(),\n  ),\n  child: Image.asset(\n    \"assets/6392956.jpg\",\n    height: 300,\n    width: 300,\n    fit: BoxFit.cover,\n    cacheHeight: (300 * MediaQuery.of(context).devicePixelRatio).toInt(),\n  ),\n);\n```\n\n<img src=\"/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_6.png\" />\n\n클리핑이 레이아웃에서 사용될 때마다 새 레이어가 생성되는 점을 주의해야 합니다. 이는 비교적 비용이 많이 드는 작업이므로 가능한 경우 클리핑 대신 데코레이션을 사용하세요.\n\n<div class=\"content-ad\"></div>\n\n# 4. 사용자 지정 클리퍼\n\n일부 경우에는 클리핑에 대해 더 많은 제어가 필요합니다. 예를 들어, 클리핑이 콘텐츠나 일부 형제 위젯에 따라 달라져야 할 때입니다. 콘텐츠에 따라 달라지는 노치가 있는 티켓 모양 위젯을 만들어 봅시다:\n\n![이미지](/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_7.png)\n\n여기서 어려운 점은 상하 자식 위젯의 크기가 다를 수 있고, 노치가 이에 종속되어야 한다는 것입니다. Flutter에서 위젯의 크기 정보는 RenderObject의 하위 클래스인 RenderBox를 사용하여 얻을 수 있습니다. RenderObjects에 익숙하지 않다면, 공식 문서로 이동하여 확인해보세요.\n\n<div class=\"content-ad\"></div>\n\n먼저 레이아웃을 만들고 상단과 하단 자식을 나누는 SizedBox에 GlobalKey를 추가해보겠습니다.\n\n```js\nfinal notchKey = GlobalKey(); // <- 이 부분\n\n...\n\nColumn(\n  children: [\n    widget.topChild,\n    SizedBox(key: notchKey, height: 20), // <- 이 부분\n    widget.bottomChild,\n  ],\n)\n```\n\nGlobalKey를 사용하면 위젯의 BuildContext를 얻을 수 있어요. RenderObject를 얻기 위해 context가 필요한데요. SizedBox의 좌표를 티켓 위젯의 context에서 가져와야 해서 해당 RenderBoxes가 필요해요. 여기에서는 Slivers을 사용하지 않기 때문에 RenderObject를 안전하게 RenderBox로 형변환할 수 있어요.\n\n```js\nClipPath(\n  clipper: _TicketClipper( // <- 우리의 클리퍼\n    notchBox: notchKey.currentContext?.findRenderObject() as RenderBox, // <- 이 부분\n    ancestorBox: context.findRenderObject() as RenderBox, // <- 이 부분\n  ),\n  child: ColoredBox(\n    color: Color(0xFFd6f5ff),\n    child: Column(\n      children: ...\n    ),\n  ),\n)\n```\n\n<div class=\"content-ad\"></div>\n\n\n그리고 클리퍼 자체는 다음과 같이 보일 것입니다:\n\n```js\nclass _TicketClipper extends CustomClipper<Path> {\n  final RenderBox notchBox;\n  final RenderBox ancestorBox;\n\n  _TicketClipper({required this.notchBox, required this.ancestorBox});\n\n  @override\n  Path getClip(Size size) {\n    final widgetRect = RRect.fromRectAndRadius(\n      Rect.fromPoints(Offset.zero, Offset(size.width, size.height)),\n      const Radius.circular(10),\n    );\n\n    final notch = notchBox.localToGlobal(Offset.zero, ancestor: ancestorBox);\n\n    return Path.combine(\n      PathOperation.difference,\n      Path()..addRRect(widgetRect),\n      Path()\n        ..addOval(Rect.fromCenter(\n            center: Offset(0, notch.dy + 10), width: 20, height: 20))\n        ..addOval(Rect.fromCenter(\n            center: Offset(size.width, notch.dy + 10), width: 20, height: 20)),\n    );\n  }\n\n  @override\n  bool shouldReclip(covariant CustomClipper<Path> oldClipper) {\n    ...\n  }\n}\n```\n\nFlutter는 차이, 교차 등의 경로 작업을 지원합니다. 여기서는 둥근 사각형에서 2개의 원을 빼내어 원하는 모양을 얻어낸 것입니다.\n\n<img src=\"/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_8.png\" />\n\n<div class=\"content-ad\"></div>\n\n이 글이 도움이 되셨기를 바랍니다. 새로운 기술을 발견할 때마다 업데이트하겠습니다. 최신 업데이트를 받으시려면 Twitter에서 제 소식을 팔로우해주세요. 전체 코드를 읽고 싶다면 저장소를 확인해주세요.\n\n![마스터링 플러터의 형태와 클리핑](/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_9.png)","ogImage":{"url":"/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_0.png"},"coverImage":"/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_0.png","tag":["Tech"],"readingTime":9},{"title":"웹 어셈블리 웹 애플리케이션을 위한 강력한 동료","description":"","date":"2024-06-19 14:50","slug":"2024-06-19-WebAssemblyAPowerfulAllyforWebApplications","content":"\n\n웹어셈블리 (WebAssembly 또는 Wasm)는 본질적으로는 low-level 언어가 아니라 다른 고성능 언어들인 C, C++, Rust, 심지어 JVM 언어 등을 웹 브라우저에서 실행하기 위해 설계된 바이트코드 형식입니다. 이는 이러한 언어들이 JavaScript와 원활하게 상호작용할 수 있도록 하는 다리 역할을 합니다.\n\nWebAssembly의 주요 장점:\n\n- 향상된 성능: Wasm은 사전 컴파일된 특성으로 연산 집약적 작업에 뛰어납니다. 이는 JavaScript의 해석 오버헤드를 우회하여 그래픽이 많은 응용프로그램, 3D 게임, 복잡한 시뮬레이션 등의 빠른 실행을 이끌어냅니다.\n- 언어 중립성: 개발자는 C++ 또는 Rust와 같은 언어의 전문 지식을 활용하여 Wasm으로 컴파일하고 웹 프로젝트 내에서 원활하게 통합할 수 있습니다. 이로써 코드 재사용이 확대되고 효율적인 개발 워크플로우가 열립니다.\n- 작은 파일 크기: Wasm 모듈은 일반적으로 JavaScript 대비 더 작아서, 더 빠른 로딩 시간과 효율적인 사용자 경험을 제공합니다, 특히 모바일 기기에서 더욱.\n- 보안 샌드박스: Wasm 모듈은 안전한 샌드박스 환경에서 작동하여 DOM 같은 브라우저 리소스에 직접 액세스할 수 없습니다. 이는 웹 애플리케이션의 전반적인 보안 수준을 향상시킵니다.\n- 하드웨어 가속: Wasm은 SIMD(단일 명령어, 다중 데이터)와 같은 하드웨어 기능을 활용하여 병렬 처리를 더 향상시킵니다. 이것은 현대 프로세서에서 성능을 더욱 향상시킵니다.\n- 개선된 가비지 컬렉션: Wasm은 자체 자동 가비지 컬렉션을 내장하지 않지만, JavaScript의 가비지 컬렉터보다 메모리를 더 효율적으로 관리할 수 있도록 개발자들에게 허용됩니다. 특히 엄격한 성능 요구 사항을 갖는 실시간 응용프로그램에 매우 유익할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n![2024-06-19-WebAssemblyAPowerfulAllyforWebApplications_1](/assets/img/2024-06-19-WebAssemblyAPowerfulAllyforWebApplications_1.png)\n\n자바스크립트와의 보완적 관계:\n\nWasm은 자바스크립트를 완전히 대체하기 위한 것이 아닙니다. 대신, Wasm은 연산량이 많고 원시 속도가 중요한 작업에 초점을 맞춘 소중한 동반자로 작용합니다. 자바스크립트는 핵심 브라우저 상호작용, 사용자 인터페이스(UI) 조작, 최고 성능을 요구하지 않는 애플리케이션 로직을 위한 선택 언어로 남아 있습니다.\n\nWasm과 자바스크립트를 전략적으로 결합함으로써, 개발자들은 빠르고 반응적이며 안전하며 유지보수가 용이한 새로운 세대의 웹 애플리케이션을 만들 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n요약하면:\n\nWebAssembly은 웹 개발 분야에서 큰 진전을 가져왔습니다. 높은 성능을 웹 브라우저로 가져다 줄 수 있는 능력은 개발자와 사용자 모두에게 흥미로운 가능성을 제공합니다. 모든 상황에서 JavaScript를 대체하지는 못할지라도, Wasm은 예외적인 웹 경험을 만들 수 있는 강력한 도구입니다.","ogImage":{"url":"/assets/img/2024-06-19-WebAssemblyAPowerfulAllyforWebApplications_0.png"},"coverImage":"/assets/img/2024-06-19-WebAssemblyAPowerfulAllyforWebApplications_0.png","tag":["Tech"],"readingTime":2}],"page":"14","totalPageCount":21,"totalPageGroupCount":2,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}