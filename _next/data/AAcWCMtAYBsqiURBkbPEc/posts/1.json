{"pageProps":{"posts":[{"title":"Dart에서 Extension Types으로 할 수 있는 것들","description":"","date":"2024-06-22 00:40","slug":"2024-06-22-WhatcanIdowithExtensionTypesinDart","content":"\n\nDart 3.3 확장 타입\n\n![Image](/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_0.png)\n\n공식 문서는 다음과 같이 시작합니다:\n\n확장 타입은 강력한 타입 래퍼로 작용하는 컴파일 시간 추상화입니다. 성능 최적화를 위해 도입되었으며 네이티브 코드와의 향상된 상호작용을 제공합니다. Zero-cost 래퍼로서, 다른 언어와 통신할 때 Wrapper 클래스와 Helper 클래스와 관련된 전형적인 메모리 비용을 제거합니다.\n\n<div class=\"content-ad\"></div>\n\n일반 클래스 래퍼는 런타임에서 작동하며 항상 클래스 및 객체 사용량의 오버헤드가 발생하여 메모리 사용량과 GC(Garbage Collection) 비용이 증가합니다. 단기간에 많은 래퍼 인스턴스가 생성되는 시나리오에서는 이 부담이 상당해집니다.\n\n확장 유형은 특정 유형의 확장으로 컴파일 시간에 확인되므로 런타임에서는 원래 표현 유형으로 되돌아가며 추상화가 사라집니다. 따라서 확장 유형을 사용하면 응용 프로그램에 비용이 발생하지 않아 매우 효율적인 개발 방법이 됩니다.\n확장 유형은 정적 JavaScript 상호 운용을 가능하게 하며, 기존 JavaScript 유형과의 원활한 상호 작용을 허용합니다.\n\n# 혜택\n\n<div class=\"content-ad\"></div>\n\n## 유연한 제한과 확장\n\n기존 유형(예: int 또는 String)을 속성, 함수 및 다른 API를 추가하여 향상시킬 수 있습니다.\n\n## 더 명확한 추상화\n\n기본 표현 유형의 복잡성을 숨겨 의미 있는 확장을 가능하게 하여 코드 가독성과 유지 관리성을 향상시킵니다.\n\n<div class=\"content-ad\"></div>\n\n## 편리하고 안전한 상호 운용성\n\nDart 사용자 정의 유형은 기본 유형에 액세스하는 것만큼 간단하여 유형 안전성을 제공합니다. 이는 네이티브 플랫폼 및 다른 언어와의 상호 운용성에 특히 유용하며, 프로세스를 간소화합니다.\n\n## 향상된 성능\n\n각 서비스마다 Wrapper 클래스를 생성하지 않아 추가 메모리 오버헤드가 발생하지 않습니다. 특히 대량 데이터 집합이나 빈번한 객체 작업을 처리할 때 성능에 민감한 시나리오에 이상적입니다.\n\n<div class=\"content-ad\"></div>\n\n# 개발\n\n확장 형식은 선언될 때 기본 생성자가 자동으로 포함됩니다.\n\n```js\nextension type MyId(int id) {}\n\nvoid main(List<String> arguments) {\n  final id = MyId(1);\n  \n  print(id); // 1 \n  print(id.runtimeType); // int\n}\n```\n\n어떤 경우에도 확장 형식에 의해 래핑된 형식은 \"표현 형식\"으로 불리며 서브타입이 아닙니다. 따라서 일반적으로 표현 형식과 사용자 정의 확장 형식은 서로 값 할당이 불가능합니다.\n\n<div class=\"content-ad\"></div>\n\n사용자 정의된 새로운 속성과 함수 인터페이스가 없을 때에는 기능적인 작업이 없습니다. int의 원래 동작이 제한됩니다.\n\n![extension types in Dart](/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_1.png)\n\n기존 유형에 대해서는 더 많은 확장이나 유형의 제약 사항에 대해 노출되는 것이 아닌 사용 가능한 API만 노출되며, 그렇게 함으로써 일부 허용되지 않는 작업을 피할 수 있습니다. 우리가 필요로 하는 의미 있는 함수를 추가할 수 있습니다.\n\n```dart\nextension type MyId(int id) {\n  operator >(MyId other) => id > other.id;\n  \n  bool isBiggerThan(MyId other) => id > other.id;\n}\n\nvoid main(List<String> arguments) {\n  MyId safeId = MyId(200);\n  safeId + 10; // Compile error: No '+' operator.\n  safeId - 10; // Compile error: No '-' operator.\n  safeId > 10; // Compile error: Wrong type.\n  safeId > MyId(300); // ✅\n\n  int number = 100;\n  number = safeId; // Compile error: Wrong type.\n  number = safeId as int; // ✅ Cast to representation type.\n  safeId = number as MyId; // ✅ Cast to extension type.\n\n  print(safeId.isBiggerThan(MyId(300))); // false\n}\n```\n\n<div class=\"content-ad\"></div>\n\n서비스나 네이티브 API와 상호 작용 후 반환된 값은 int를 사용하여 가독성을 높일 수 있어요. 확장 유형을 통해 특정 이름을 지정할 수 있어요. 이렇게 하면 한눈에 이해하기 쉬워져요.\n\n확장 유형과 표현 유형은 as 캐스팅을 사용하여 직접 변환할 수 있어요. 재미있는 점은 상속 관계가 아님에도 불구하고 강제로 변환할 수도 있어요.\n\n```js\ni = id as int; // ✅\ni = -1;\nid = i as Id;  // ✅\n```\n\n다트 클래스처럼 확장 유형을 일반적으로 처리하고 인스턴스화하고 사용자 정의 함수를 호출할 수 있는 예제가 있어요. 다트는 이를 일반 int로 컴파일해요.\n\n<div class=\"content-ad\"></div>\n\n```dart\nextension type Wrapper(int i) {\n  void showValue() {\n    print('my value is $i');\n  }\n}\n\nvoid main() {\n  final wrapper = Wrapper(42);\n  wrapper.showValue(); // Prints 'my value is 42'\n}\n```\n\n공식 설명에 따르면 익스텐션 타입은 네이티브 코드와의 상호 운용성을 위해 유용하며, 간접 비용을 발생시키지 않고 네이티브 타입을 직접 사용할 수 있으면서도 깔끔한 Dart API를 제공합니다.\n\n# 제네릭\n\n익스텐션 타입과 제네릭을 함께 사용하기:\n\n\n<div class=\"content-ad\"></div>\n\n```dart\nextension type MyList<T>(List<T> elements) {\n void add(T value) => elements.add(value);\n}\n\nvoid main(List<String> arguments) {\n  MyList list = MyList<int>([1, 2]);\n  list.add(3);\n\n  final normalList = list as List<int>;\n  print(list); // [1, 2, 3]\n  print(normalList); // [1, 2, 3]\n}\n```\n\n# 생성자\n\nExtension 타입은 여러 개의 생성자를 가질 수 있습니다:\n\n- 일반 생성자\n- 명명된 생성자\n- private 생성자 문법을 사용한 숨겨진 생성자\n\n\n<div class=\"content-ad\"></div>\n\n```dart\nextension type Password._(String value) {\n  Password(this.value) {\n    assert(value.length >= 8);\n    \n    if (value.length < 8) {\n      throw Exception('Password must be at least 8 characters long');\n    }\n  }\n\n  Password.random() : value = _generateRandomPassword();\n\n  static String _generateRandomPassword() => ...;\n\n  bool get isValid => value.length >= 8;\n}\n\nvoid main(List<String> arguments) {\n  // 암시적 명명되지 않은 생성자.\n  Password password = Password('abcdefghijklmnopqrstuvwxyz'); // ✅\n\n  // 명명된 생성자.\n  password = Password.random(); // ✅\n  password = Password('hello12'); // Exception: Password must be at least 8 characters long\n  password = 'hello' as Password; // ✅\n}\n```\n\n기억하세요, 암시적 주 생성자에서는 assert() 체크나 다른 작업을 사용할 수 없습니다. 기본 생성자를 재정의하고 assert 체크를 추가하세요. 기본 생성자를 내부적으로(private) 만드세요.\n```dart\nextension type Password._(String value) {\n\n  Password(this.value) {\n    assert(value.length >= 8);\n    \n    if (value.length < 8) {\n      throw Exception('Password must be at least 8 characters long');\n    }\n  }\n  \n}\n```\n\n# 안전한 Alias\n\n\n<div class=\"content-ad\"></div>\n\nimplements를 사용하면 Extension Types가 기본 유형을 노출하여 Representation 타입의 모든 멤버 및 사용자 지정 도우미 API에 액세스할 수 있습니다. 이는 원래 유형의 기능을 제공하면서도 별칭 및 타입 안전성 확인을 제공합니다.\n\n```js\nextension type Height(double _) implements double {}\nextension type Weight(double _) implements double {}\n\ndouble calculateBmi(Height height, Weight weight) => weight / ( height * height);\n\nvoid main() {\n  var height = Height(1.75);\n  var weight = Weight(65);\n  var bmi = calculateBmi(height, weight);\n  print(bmi); // 21.22448979591837\n  \n  bmi = calculateBmi(1.64, 54.0);     // ❌ 컴파일 타임 오류\n  bmi = calculateBmi(weight, height); // ❌ 컴파일 타임 오류\n}\n```\n\n기존 타입에 새로운 인터페이스 추가하기:\n\n```js\nextension type MyId(int id) implements int {\n  MyId get value => this;\n}\n\nvoid main(List<String> arguments) {\n  final safeId = MyId(100);\n  safeId + 1; // 101\n  safeId - 1; // 99\n  safeId * 2; // 200\n  safeId / 2; // 50\n  safeId % 3; // 1\n  safeId.toString(); // '100'\n\n  int normalId = safeId; // 100\n  final safeId2 = safeId + normalId; // 200\n  final safeId3 = 10 + safeId; // 110\n}\n```\n\n<div class=\"content-ad\"></div>\n\n기존의 기능적 동작을 재정의하고 확장 타입의 멤버들은 완전히 부모 타입의 동일한 이름을 가진 멤버들을 대체하여 새 구현 방법을 제공합니다.\n\n```js\n확장 타입 MyId(int id)은 int를 구현합니다 {\n  bool get isEven => true;\n}\n\nvoid main(List<String> arguments) {\n  final myId = MyId(101);\n  print(myId.isEven); // true\n}\n```\n\n# 다른 시나리오\n\n## 다중 타입 확장\n\n<div class=\"content-ad\"></div>\n\n보통, 확장 유형은 하나의 유형을 확장합니다. 여러 정보가 있는 경우 Record를 사용할 수 있습니다.\n\n```js\ntypedef UserInfo = ({String email, String password});\n\nextension type User(UserInfo info) {\n  void printInfo() => print(\"Email: ${info.email}, Password: ${info.password}\");\n}\n\nvoid main(List<String> arguments) {\n  final user = User(\n    (\n      email: 'extension@gmail.com',\n      password: 'types',\n    ),\n  );\n  user.printInfo(); // Email: extension@gmail.com, Password: types\n}\n```\n\n## 테스트용 모의 데이터\n\n테스트에서 Extension Types를 사용하는 것도 가능합니다. Mock 클래스에 따르면 코드를 약간 조정하기만 하면 됩니다. 일반 클래스와의 차이점은 인터페이스를 구현하지 않은 경우 일반 클래스는 컴파일 경고를 표시하지만, Extension Types는 표시하지 않는다.\n\n<div class=\"content-ad\"></div>\n\n\n## JSON 접근\n\nJSON 데이터에 대한 Extension Types 활용.\n\n```js\nfinal userMap = json.decode(r'''\n  {\n    \"name\": {\n      \"first\": \"Yii\",\n      \"last\": \"Chen\"\n    },\n    \"email\": \"ab20803@gmail.com\"\n  }\n'''); // Map<String, dynamic>\n\nextension type User(Map<String, dynamic> _) {\n  Name get name => _['name'] as Name;\n  String get email => _['email'] as String;\n}\nextension type Name(Map<String, dynamic> _) {\n  String get first => _['first'] as String;\n  String get last => _['last'] as String;\n}\nvoid main() {\n  final person = User(userMap);\n  print(person.name.first);   // Yii\n  print(person.name.last);    // Chen\n  print(person.email);        // ab20803@gmail.com\n  print(person.email.length); // 17\n}\n```\n\n\n<div class=\"content-ad\"></div>\n\n# 상호 운용성\n\n현재 Extension Types은 주로 dart: js_interop 패키지에서 사용되며, 익숙한 구문을 사용하여 JavaScript API에 액세스하고 상호 작용할 수 있도록 합니다. 이 패키지는 JSObject 및 JSAny와 같은 많은 JS 관련 유형을 정의하여 Dart와 네이티브 플랫폼 간의 안전한 통신을 보장합니다. C++와 같은 다른 언어도 이 접근 방식에서 혜택을 볼 수 있습니다.\n\n![image](/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_2.png)\n\nexternal → 이 키워드는 일반적으로 다른 언어에서 사용하는 외부 함수에 액세스할 수 있도록 합니다. 따라서 Dart 상호 운용성 개발에서 자주 볼 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n@JS() → 만약 Dart 측에서 다른 이름을 구현하거나 동일한 JavaScript API를 가리키는 여러 Dart API를 작성하려는 경우, 상호 운용성을 위해 JS API의 이름을 정의할 수 있습니다.\n\n## 패키지 예시\n\nflutter_soloud는 C++을 기반으로 개발된 오디오 엔진 및 패키지로, 낮은 지연 시간, 고성능 플레이어를 제공합니다. 소스 코드에서 재생 기능을 실행하고자 할 때, player.cpp의 play 함수로 시작하여 최종적으로 Dart 측에서는 소리 작업의 ID를 얻기 위해 soloud.play()를 실행합니다.\n\n사용자 정의 SoundHandle은 가독성과 성능을 보장하기 위해 ID를 래핑합니다.\n\n<div class=\"content-ad\"></div>\n\n```dart\nfinal soloud = SoLoud.instance;\nawait soloud.init();\nfinal source = await soloud.loadAsset('path/to/asset.mp3');\n\nSoundHandle soundHandle = await soloud.play(source); // id(int)\n\nawait soloud.stop(soundHandle);\nawait soloud.disposeSource(soundHandle);\n```\n\n전체 API 작업 프로세스를 간단히 살펴보겠습니다:\n\n- player.cpp의 play()를 사용하여 오디오 핸들을 얻습니다.\n\n![Extension Types in Dart](/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_3.png)\n\n\n<div class=\"content-ad\"></div>\n\n2. 양쪽 간의 통신을 처리하기 위해 bindings_player_ffi.dart를 사용하여 얻은 핸들 ID를 SoundHandle으로 래핑합니다.\n\n![image](/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_4.png)\n\n3. Flutter 쪽에서는 soloud.dart를 사용하여 play()를 호출한 후 Record 유형의 결과를 반환합니다. 해당 newHandle을 추출하여 필요한 ID인 ID를 얻을 수 있습니다.\n\n![image](/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_5.png)\n\n<div class=\"content-ad\"></div>\n\n4. Dart 쪽에서는 음향 컨트롤 작업을 위해 의미 있는 확장 유형인 SoundHandle을 사용하여 id가 랩핑됩니다.\n\n![이미지](/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_6.png)\n\n# 고급 사용법\n\n팩토리 생성자: 다른 유형의 확장이 Representation 유형에 적용될 수 있습니다. 이를 통해 연산을 여러 확장 유형에 재사용할 수 있습니다 (다중 상속과 유사).\n\n<div class=\"content-ad\"></div>\n\n```js\nextension type Number(int i) {\n  const factory Number.zero() = Number2;\n}\n\nextension type Number2(int i) implements Number { \n  const Number2(int value) : this(i: value);\n}\n```\n\n# 기억해주세요\n\n확장 유형(Extension Type)은 컴파일 시간에 래핑 동작입니다. 런타임에는 존재하지 않습니다. 런타임에서는 어떤 유형의 쿼리나 작업이라도 표현 유형(Representation Type)에 적용됩니다. 이로 인해 확장 유형은 안전하지 않은 추상화이며 원래 표현 유형을 항상 찾을 수 있고 런타임에서 기본 객체에 액세스할 수 있습니다.\n\n```js\nextension type Id(int value) {}\n\nvoid idToInt() {\n  var id = Id(1);\n\n  // 'id'의 런타임 유형은 표현 유형 'int'.\n  if (id is int) print(id.value); // 1\n\n  // 런타임에서 'id'에 'int' 메서드 사용 가능.\n  if (id case int x) print(x.toString()); // 1\n  switch (id) {\n    case int(:final isEven):\n      print(\"$id (${isEven ? \"짝수\" : \"홀수\"})\"); // 1 (홀수)\n  }\n}\n\nvoid intToId() {\n  int i = 2;\n\n  if (i is Id) print(\"예\"); // 예\n\n  if (i case Id id) print(\"값: ${id.value}\"); // 값: 2\n\n  switch (i) {\n    case Id(:var value):\n      print(\"값: $value\"); // 값: 2\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n# 요약\n\n- **확장 유형**은 기존 유형을 제한할 수도 있고, 새로운 기능을 제공할 수도 있습니다.\n- **확장 유형**의 본질을 이해하는 것이 중요합니다. 이들은 컴파일 시에만 존재하며 런타임에서는 무시되며 **표현 유형**으로 표시됩니다.\n- **확장 유형**은 특정 상황에서 비용을 절약하고, 특히 상호 운용성 개발에서 성능을 크게 향상시킬 수 있습니다.\n\n# 확장 유형 비교\n\n- **확장 메서드**: 기존 유형에 간단한 기능을 추가하는 데 적합합니다.\n- **확장 유형**: 기존 유형을 향상시키고, 복잡한 기능을 구현하며, 다른 프로그래밍 언어와의 상호 운용성을 최적화하는 데 적합합니다.\n\n<div class=\"content-ad\"></div>\n\n# 참고\n\n- [Dart 언어 확장 유형](https://dart.dev/language/extension-types)\n- [Dart 상호 운용성 및 JS 상호 운용 사용법](https://dart.dev/interop/js-interop/usage)\n- [Dart 3.3 소개](https://medium.com/dartlang/dart-3-3-325bf2bf6c13)\n- [Dart와 Flutter 확장 유형에 대한 소개](https://ildysilva.medium.com/what-are-flutter-and-dart-extension-types-896eda0a3ddf)\n- [Dart 언어에 대한 유용한 기능과 팁](https://qiita.com/Cat_sushi/items/987e7eee469793369ef8)\n- [Flutter와 Dart의 개요](https://qiita.com/Cat_sushi/items/87742dc3a886dd984f46)\n- [imaNNeO 유튜브 채널](https://www.youtube.com/watch?v=YHsi1Gfz5UU&ab_channel=imaNNeO)\n- [FlutterUruguay 유튜브 채널](https://www.youtube.com/watch?v=SyFNB81p-OY&t=3276s&ab_channel=FlutterUruguay)\n- [Prof.DiegoAntunes 유튜브 채널](https://www.youtube.com/watch?v=2TJIOpBDMnU&ab_channel=Prof.DiegoAntunes)\n\n# 다른 글들\n\n- 2024년 4월 'Flutter Monthly' 😍\n- 2024년 3월 'Flutter Monthly' 😍\n- 2024년 2월 'Flutter Monthly' 😍\n- Flutter 3.19 및 Dart 3.3 업데이트 포인트!\n- 2024년 1월 'Flutter Monthly' 😍\n- 개발 기술 향상을 위한 Dart 3 사용하기. 더 많은 예제와 팁.\n- 2023년 12월 'Flutter Monthly' 😍\n- 2023년 11월 'Flutter Monthly' 😍\n- Dart 3를 숙지해서 삶을 쉽게 만들기!\n- Flutter 3.16 및 Dart 3.2 요약!\n- 2023년 10월 'Flutter Monthly' 😍\n- 2023년 9월 'Flutter Monthly' 😍\n- 2023년 8월 'Flutter Monthly' 😍\n- 2023년 7월 'Flutter Monthly' 😍","ogImage":{"url":"/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_0.png"},"coverImage":"/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_0.png","tag":["Tech"],"readingTime":12},{"title":"웹 어키텍처 혁신 WebAssembly, Angular v9의 비밀과 NgRx 활용 방법 24화","description":"","date":"2024-06-22 00:23","slug":"2024-06-22-Episode2424VerticalArchitecturesWebAssemblyAngularv9sSecretNgRx","content":"\n\n![Episode2424VerticalArchitecturesWebAssemblyAngularv9sSecretNgRx_0](/assets/img/2024-06-22-Episode2424VerticalArchitecturesWebAssemblyAngularv9sSecretNgRx_0.png)\n\n브랜든 로버츠는 왜 Angular 9가 가장 높은 다운로드율을 보이는지를 공개했습니다. 만프레드 스테이어는 수직 구조에 대해 이야기했습니다. Evgeniy Tuboltsev는 Angular에서 WebAssembly를 통합하는 방법에 대한 안내서를 게시했으며, NgRx 18가 릴리스되었습니다.\n\n# 수직 구조\n\nAngular 커뮤니티 미팅에서 만프레드 스테이어가 Angular에서 DDD에 대한 강화 버전을 소개했습니다.\n\n<div class=\"content-ad\"></div>\n\n그는 다른 작업을 담당하는 네 가지 유형의 팀이 존재하는 팀 토폴로지 모델에 대해 언급했습니다:\n\n1. 플랫폼 서비스 팀\n2. 전문화 팀\n3. 지원 팀\n4. 가치 흐름 팀\n\n## NgRx 18\n\nNgRx는 Angular에서 가장 인기 있는 상태 관리 라이브러리로, v18에서 발표되어 Angular 18과 호환되게 되었습니다.\n\n<div class=\"content-ad\"></div>\n\n신호 스토어를 사용하려면 주의하세요. 나중에 **안정화**되고 아직 릴리스되지 않았습니다.\n\nAngular 18에서 사용하려면 `npm i @ngrx/signals@next`를 실행하거나 스키매틱(또한 `next` 태그 사용)을 사용하세요.\n\n# Angular 9 뒤의 비밀\n\n현재 Angular은 주간 약 350만 번 다운로드되어 React와 Vue에 이어 세 번째로 가장 많이 다운로드되는 프레임워크입니다.\n\n<div class=\"content-ad\"></div>\n\n앵귤러 9가 45만 회 다운로드되었다고 합니다. 현재 버전이 18인데, 그것은 조금 이상하네요.\n\n브랜든 로버츠가 발견했는데, 앵귤러 9는 코들라이저의 의존성입니다. 코들라이저는 타입스크립트 ESLint가 나오기 전에 우리가 사용한 라이브러리입니다.\n\n코들라이저는 많은 애플리케이션에 포함되어 있을 가능성이 매우 높지만, 활성적으로 사용되지는 않고 있으므로 개발자들은 제거해야 할 것입니다.\n\n통계에 따르면, 코들라이저의 현재 다운로드 수는 60만 회입니다.\n\n<div class=\"content-ad\"></div>\n\n코드라이저가 없다면 Angular의 다운로드 수는 17% 떨어질 것입니다.\n\n# 웹어셈블리 & 앵귤러\n\n웹어셈블리는 자바스크립트보다 다른 언어로 작성된 응용 프로그램을 브라우저에서 실행할 수 있게 해줍니다. 게다가 실행 속도는 거의 네이티브 코드와 비슷합니다.\n\nEvgeniy Tuboltsev가 러스트로 작성된 응용 프로그램을 웹어셈블리로 이식하고 Angular에서 사용하는 방법을 보여준 기사를 썼습니다. 비교해보면, 그의 예시는 자바스크립트와 비교했을 때 세 배 빠르게 실행됩니다.","ogImage":{"url":"/assets/img/2024-06-22-Episode2424VerticalArchitecturesWebAssemblyAngularv9sSecretNgRx_0.png"},"coverImage":"/assets/img/2024-06-22-Episode2424VerticalArchitecturesWebAssemblyAngularv9sSecretNgRx_0.png","tag":["Tech"],"readingTime":2},{"title":"웹 개발자의 새로운 베스트 프렌드 AI , 머신러닝 활용 방법","description":"","date":"2024-06-22 00:18","slug":"2024-06-22-TheWebDevelopersNewBestFriendAIMachineLearning","content":"\n\n# AI 및 기계 학습을 통한 웹 애플리케이션의 변혁적 역할\n\n## 소개\n\n기술 발전의 끊임없이 변화하는 풍경 속에서 인공 지능(AI)과 기계 학습(ML)이 변혁적인 역할로 부상하여 산업을 재구성하고 디지털 세계와 상호 작용하는 방식을 재정의하고 있습니다. 몇 년 동안 다양한 경험을 가진 숙련된 웹 기술 전문가로서, 나는 이러한 기술이 웹 개발에 미친 깊은 영향을 직접 목도했습니다. 지능형 웹 애플리케이션부터 간소화된 개발 프로세스 및 향상된 사용자 경험까지, AI와 ML은 웹을 구축하고 상호 작용하는 방식을 혁신하고 있습니다. 본 블로그 포스트에서는 이러한 최첨단 기술이 웹 개발 풍경에 미치는 다각적인 영향을 탐험하는 여정을 떠날 것입니다.\n\n## 지능형 웹 애플리케이션의 시대:\n\n<div class=\"content-ad\"></div>\n\n정적인 일반적인 웹사이트의 날들이 멀어지고 있습니다. AI와 ML의 통합으로 웹 어플리케이션이 지능적이고 적응 가능하며 매우 개인화된 경험으로 발전해 왔습니다. 이 변화의 대표적인 사례인 인기 있는 비디오 스트리밍 플랫폼은 ML 알고리즘을 활용하여 각 사용자의 독특한 시청 기록을 기반으로 영화와 TV 프로그램을 맞춤형으로 추천합니다. 사용자 기호, 평가 및 참여 패턴을 포함한 방대한 양의 데이터를 분석함으로써, 이러한 플랫폼은 사용자가 만족하고 계속해서 이용하는 맞춤형 경험을 제공합니다.\n\n마찬가지로 전자 상거래 거물들은 AI와 ML의 파워를 이용하여 온라인 쇼핑을 혁신하고 있습니다. 지능형 제품 추천부터 동적 가격 책정 및 사기 탐지까지, 이러한 기술은 기업이 제공물을 최적화하고 고객 만족도를 향상시키며 수익 성장을 도모할 수 있게 했습니다. 한 연구 결과에 따르면, AI와 ML 기술을 도입한 소매업체들은 수익이 높아지고 비용이 줄어 2-3%의 수익 증가와 1-2%의 비용 절감을 경험했다고 나타났습니다.\n\n## 웹 개발 워크플로우 최적화하기:\n\n웹 개발의 사용자에게 보여지는 측면을 변형하는 것을 넘어서, AI와 ML은 개발 프로세스 자체를 혁신하고 있습니다. 한 가지 중요한 영향은 반복적이고 시간이 많이 소요되는 작업의 자동화입니다. 마이크로소프트에서 개발된 Sketch2Code와 같은 도구는 AI를 활용하여 손그림 와이어프레임을 기능적인 HTML 코드로 변환하여 개발자들이 매뉴얼 코딩에 소요되는 시간을 아낄 수 있습니다. 이 도구는 더 이상 유지되지는 않지만, 자동화 뿐만 아니라 개발 프로세스를 가속화시키며 개발자들이 보다 복잡하고 창의적인 작업에 집중할 수 있도록 도와주었습니다. 알찬 프로젝트였던 Sketch2Code는 마이크로소프트로부터 공식 웹사이트가 더 이상 제공되지 않으며, 이에 대한 최신 업데이트도 없습니다. 해당 프로젝트에 대한 개발 또는 미래 계획에 대한 마이크로소프트의 최신 소식도 없는 것으로 나타납니다.\n\n<div class=\"content-ad\"></div>\n\n하지만 Sketch2Code는 더 이상 활발히 유지되고 있지 않지만, 그가 개척한 개념은 AI를 활용한 웹 개발 분야에서 혁신을 이끌어내고 있습니다.\n\n뿐만 아니라, AI 기반의 코드 완성 및 지능적인 코드 제안은 웹 개발자에게 없어서는 안 될 필수 도구가 되었습니다. GitHub Copilot과 같은 플랫폼은 OpenAI의 GPT-3/4/4o 언어 모델을 기반으로 개발자에게 문맥을 고려한 코드 제안과 자동 코드 완성 기능을 제공하여 개발 프로세스를 가속화시키고 더욱 효율적인 코드를 작성하며 최상의 사례 채용을 촉진합니다. 개발자 커뮤니티의 집단적인 지식을 활용함으로써, 이러한 AI 기반 도구들은 코딩 전문성을 민주화시키고 모든 레벨의 개발자들에게 힘을 실어줍니다.\n\n<div class=\"content-ad\"></div>\n\n## 사용자 상호작용 및 접근성 향상:\n\nAI 및 ML은 웹 사이트의 사용자 상호작용 및 접근성을 향상시키는 데 중요한 역할을 하고 있습니다. NLP(자연어 처리) 및 ML 알고리즘을 기반으로 한 챗봇은 웹 사이트에서 보다 보편적으로 사용되며 즉각적인 고객 지원과 안내를 제공합니다. 이러한 지능형 어시스턴트는 제품 정보부터 문제 해결까지 다양한 질문을 다룰 수 있으며 인적 자원을 확보하고 고객 만족도를 향상시킵니다. 인기 연구에 따르면, 2024년 말까지 챗봇이 고객 상호작용의 70%를 처리할 것으로 예측되어 웹 개발 생태계에서 그 중요성이 증가하고 있습니다.\n\n또한, AI 및 ML은 장애를 가진 사용자들이 웹 사이트에 더 잘 접근할 수 있도록 돕는 데 활용되고 있습니다. 이미지 인식 알고리즘은 이미지에 대한 대체 텍스트를 자동으로 생성하여 스크린 리더에 의존하는 시각 장애인 사용자들이 접근할 수 있게 합니다. 게다가, AI 기반 도구는 웹 사이트 디자인을 분석하고 접근성을 향상시키기 위한 권고 사항을 제공함으로써 웹 사이트가 포괄적이고 접근성 표준을 준수하도록 보장합니다. 접근성을 우선시함으로써 웹 개발자들은 보다 넓은 관객들에게 맞춘 디지털 경험을 창출하고 디지털 포용성을 촉진할 수 있습니다.\n\n## 실시간 개인화와 최적화:\n\n<div class=\"content-ad\"></div>\n\nAI 및 기계 학습의 가장 흥미로운 응용 중 하나는 웹 개발에서의 실시간 개인화와 최적화입니다. 사용자의 행동, 선호도 및 상호 작용을 분석하여 웹 사이트는 콘텐츠, 레이아웃 및 기능을 동적으로 조정하여 각 사용자에게 맞춤 경험을 제공할 수 있습니다. 이러한 개인화 수준은 사용자 참여를 높일 뿐만 아니라 전환율과 고객 충성도를 향상시킵니다.\n\n예를 들어, ML 알고리즘을 사용하여 제작된 뉴스 웹 사이트는 사용자의 읽기 습관을 분석하고 관심사에 기반해 기사를 추천하여 사용자를 계속해서 참여시키고 정보를 제공할 수 있습니다. 마찬가지로, e-러닝 플랫폼은 학생의 성적 및 학습 스타일에 따라 콘텐츠와 난이도를 적응하여 개인화되고 효과적인 학습 경험을 보장할 수 있습니다. 연구 결과, 개인화된 경험은 매출을 20% 증가시킨다고 밝혀져 있으며, 이는 비즈니스 결과에 미치는 개인화의 중요성을 강조합니다.\n\n## 현대 웹 개발 도구와 기술:\n\nAI 및 기계 학습의 도입은 현대 웹 개발 도구와 기술의 등장으로 크게 촉진되었습니다. 이러한 도구와 프레임워크는 개발자에게 AI 및 기계 학습 기능을 자연스럽게 웹 애플리케이션에 통합할 수 있는 필요한 인프라 및 자원을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n## TensorFlow.js:\n\nTensorFlow.js는 Google에서 개발한 오픈 소스 라이브러리로, 개발자들이 브라우저에서 ML 모델을 직접 빌드하고 배포할 수 있게 해줍니다. TensorFlow.js를 사용하면 웹 개발자들은 서버 측 처리에 의존하지 않고 이미지 분류, 감정 분석, 예측 모델링과 같은 작업을 수행할 수 있는 지능형 웹 애플리케이션을 만들 수 있습니다. 이를 통해 개발자들은 더 많은 상호작용과 반응형 사용자 경험을 만들어낼 수 있습니다.\n\n## 서버리스 컴퓨팅 플랫폼:\n\n웹 개발 분야에서 또 다른 혁신적인 기술은 AWS Lambda, Google Cloud Functions, Azure Functions과 같은 서버리스 컴퓨팅 플랫폼의 등장입니다. 이러한 플랫폼을 통해 개발자들은 인공 지능과 기계 학습 모델을 확장 가능하고 비용 효율적으로 실행할 수 있으며, 인프라 관리를 할 필요가 없습니다. 서버리스 컴퓨팅을 활용함으로써, 웹 개발자들은 지능적인 기능과 기능을 구축하는 데 집중할 수 있고, 클라우드 제공업체가 기반 인프라를 관리해줍니다.\n\n<div class=\"content-ad\"></div>\n\n미리 훈련된 AI 모델 및 API:\n\n또한, 미리 훈련된 AI 모델과 API의 이용가능성은 웹 개발자들이 애플리케이션에 AI 기능을 통합하는 것을 더욱 쉽게 만들어주었습니다. Google Cloud Vision API, Amazon Rekognition, Microsoft Cognitive Services와 같은 서비스는 이미지 인식, 자연어 처리, 감정 분석과 같은 작업에 대한 준비된 AI 모델을 제공하여 개발자들이 이를 활용할 수 있습니다. 이러한 API를 활용함으로써, 웹 개발자들은 AI 전문 지식의 필요없이 빠르게 애플리케이션에 지능적인 기능들을 추가할 수 있습니다.\n\n인기 있는 클라우드 제공 업체의 AI 및 ML 서비스:\n\nAmazon Web Services (AWS):\n\n<div class=\"content-ad\"></div>\n\n- Amazon SageMaker: 모든 개발자와 데이터 과학자에게 ML 모델을 빠르게 구축, 훈련 및 배포할 수 있는 완전히 관리되는 서비스입니다.\n- Amazon Rekognition: 응용 프로그램에 이미지 및 비디오 분석 기능을 쉽게 추가할 수 있는 서비스입니다.\n- Amazon Polly: 텍스트를 생동감있는 음성으로 변환하여 음성 대화형 제품을 완전히 새롭게 구축할 수 있는 서비스입니다.\n\nGoogle Cloud Platform (GCP):\n\n- Google Cloud AI Platform: ML 모델을 구축, 배포 및 관리할 수 있는 통합 플랫폼입니다.\n- Google Cloud Vision API: 강력한 이미지 분석 기능을 제공합니다.\n- Google Dialogflow: 챗봇과 같은 대화형 인터페이스를 구축하는 스위트입니다.\n\nMicrosoft Azure:\n\n<div class=\"content-ad\"></div>\n\n- Azure Machine Learning: ML 모델을 구축하고 배포하는 포괄적인 서비스입니다.\n- Azure Cognitive Services: 시각, 음성, 언어 및 의사 결정을 위한 API 및 서비스의 모음입니다.\n- Azure Bot Service: 지능적이고 기업용 봇을 만들 수 있게 해줍니다.\n\n웹 개발의 미래:\n\nAI와 ML이 전례없는 속도로 발전함에 따라 웹 개발의 미래는 매우 밝아 보입니다. IoT(Internet of Things), 증강 현실(AR), 가상 현실(VR)과 같은 다른 신흥 트렌드와 이러한 기술들의 통합은 몰입형이자 지능적인 웹 경험을 위한 새로운 가능성을 열어줄 것입니다.\n\n사용자의 물리적 환경에 맞게 웹사이트가 신속하게 적응하고, IoT 장치를 활용해 맥락에 맞는 경험을 제공하는 상상해 보세요. 제품을 구매하기 전 실제 환경에서 제품을 시각화할 수 있는 AR을 지원하는 웹사이트를 상상해 보세요. AI, ML 및 이러한 신흥 기술들의 융합은 웹 개발에서 가능한 범위의 경계를 재정의할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n또한, AI 및 ML 도구의 민주화는 보다 넓은 범위의 개발자들이 지능적인 웹 애플리케이션을 만들 수 있게됩니다. 로우코드 및 노코드 플랫폼과 사전 학습된 AI 모델을 결합하면 모든 기술 수준의 개발자가 데이터 과학이나 머신러닝에 대한 심도 있는 전문 지식이 필요하지 않고도 이러한 기술의 힘을 활용할 수 있게 될 것입니다.\n\n결론:\n\nAI 및 머신러닝이 웹 개발에 미치는 영향은 깊고 광범위하며 혁신적입니다. 지능적인 웹 애플리케이션부터 개발 워크플로의 최적화, 향상된 사용자 상호작용 및 실시간 개인화까지, 이러한 기술들은 우리가 웹사이트를 구축하고 상호작용하는 방식을 형태로 재구성하고 있습니다. 웹 개발자로서 우리는 이러한 발전을 수용하고 지속적으로 기술을 적응시키며 그 잠재력을 활용하여 더 매력적이고 효율적이며 사용자 중심의 웹 경험을 창출해야 합니다.\n\n그러나 여정은 아직 끝나지 않았습니다. AI 및 ML 분야는 지속적으로 진화하고 새로운 발전이 급격히 등장하고 있습니다. 웹 개발자로서 우리는 호기심을 갖고 새로운 가능성을 탐험하고 웹 개발의 미래를 형성하는 데 적극적으로 기여해야 합니다. 이렇게 함으로써 우리는 트렌드에 앞설뿐만 아니라 혁신을 주도하고 가능한 범위의 한계를 넓힐 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n그래서, AI와 머신 러닝의 영향을 받아 다가가 봅시다. 창의성과 열정이 우리를 이끄는 새로운 지능적이고 맞춤형이며 접근성 있는 웹 경험을 만들면서 우리의 웹 개발 미래를 설계해봅시다. 웹 개발의 미래는 흥미 진진한 기회로 가득차 있으며 함께하면 전 세계 사용자들에게 직관적이고 매력적이며 더 나은 디지털 환경을 형성할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-22-TheWebDevelopersNewBestFriendAIMachineLearning_0.png"},"coverImage":"/assets/img/2024-06-22-TheWebDevelopersNewBestFriendAIMachineLearning_0.png","tag":["Tech"],"readingTime":7},{"title":"Progressive Web Applications PWA로 첫 오프라인 웹 앱 만드는 방법 ","description":"","date":"2024-06-22 00:15","slug":"2024-06-22-BuildYourFirstOfflineWebAppftProgressiveWebApplications","content":"\n\n![이미지](/assets/img/2024-06-22-BuildYourFirstOfflineWebAppftProgressiveWebApplications_0.png)\n\n제목과 간단한 소개로 이미 아이디어를 얻으셨겠지만, 오늘은 Progressive Web Application (PWA)에 대해 배우겠습니다. PWA는 이름에서 알 수 있듯 기존 애플리케이션을 더 나은 방향으로 발전시킨 것이며, 이 기사에서는 PWA에 대한 간략한 소개를 제공하여 다음 프로젝트에서 쉽게 시작할 수 있도록 도와드리겠습니다.\n\n## 기사 하이라이트\n\n- 설치 가능한 웹 앱\n- 오프라인 지원 및 캐싱\n- 백그라운드 동기화\n- 푸시 알림\n- 네트워크 가로채기\n- 자원 캐싱\n\n<div class=\"content-ad\"></div>\n\n## 웹 앱을 프로그레시브 웹 앱으로 변환하기\n\n웹 앱의 몇 가지 주요 특성들이 해당 앱을 PWA로 만들어줍니다. 반응성, 설치 가능성, 오프라인 기능, 백그라운드 동기화, 알림 등이 있습니다. 기존 애플리케이션을 PWA로 변환하려면 비즈니스 요구에 맞게 PWA의 특성을 하나씩 추가하면 됩니다.\n\n반응성은 CSS와 미디어 쿼리를 추가하여 달성할 수 있습니다. manifest.json 파일 추가에 대한 설명은 이 문서를 참조하십시오. manifest.json에는 설치된 앱이 기기에서 보일 모습을 정의하는 다양한 속성이 있습니다. 예를 들어, 이름, 아이콘, 설치 배너, 방향 등을 정의합니다.\n\n브라우저와 운영 체제에 크게 의존하는 오프라인 지원과 알림과 같은 다른 기능들은 서비스 워커가 필요합니다. 이에 대해 다음 섹션에서 더 자세히 이야기해보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n# 서비스 워커와 그 생명주기\n\n서비스 워커는 브라우저에 의해 관리되고 제어되는 다른 스레드에서 작동합니다. 사용자가 귀하의 앱을 사용하는 동안 해당 브라우저에서 서비스 워커를 지원하지 않을 수 있으므로 해당 경우에 대비하여 엣지 케이스를 피할 수 있는 체크를 추가해야 합니다.\n\n서비스 워커의 생명주기는 기기에 설치된 일반 네이티브 응용 프로그램과 거의 동일합니다. 이 유사성을 유지하면 서비스 워커에 대한 이해와 작업이 훨씬 더 쉬워집니다.\n\n![이미지](/assets/img/2024-06-22-BuildYourFirstOfflineWebAppftProgressiveWebApplications_1.png)\n\n<div class=\"content-ad\"></div>\n\n이제 서비스 워커가 무엇인지 명확해졌으니, 그들의 주요 기능 몇 가지를 살펴보겠습니다.\n\n# 오프라인 지원 및 캐싱 (네트워크 가로채기 및 백그라운드 동기화)\n\n앱을 완전히 오프라인으로 만들려면 앱에서 네트워크를 사용할 수 없을 때 GET 및 POST 요청을 처리해야합니다. 한 가지씩 살펴보겠습니다.\n\n## 캐싱\n\n<div class=\"content-ad\"></div>\n\n서비스 워커를 사용하면 fetch API를 통해 수행되는 모든 네트워크 요청을 가로챌 수 있으며, 해당 요청을 브라우저 캐시에 저장하여 캐시할 수 있습니다.\n\n![이미지](/assets/img/2024-06-22-BuildYourFirstOfflineWebAppftProgressiveWebApplications_2.png)\n\n위 예시에서 볼 수 있듯이, 우리는 네트워크 요청을 가로채고 캐시에 해당 항목이 있는 경우에는 다시 사용하고, 그렇지 않으면 서버에 요청을 하여 데이터를 가져와서 캐시에 저장하는 것을 볼 수 있습니다.\n\n## 정적 자산 캐싱\n\n<div class=\"content-ad\"></div>\n\n만약 캐시해야 할 엔드포인트가 무엇인지 모르는 경우, 매 요청을 가로채는 이벤트 리스너를 설치하는 것이 매우 효과적입니다. 그러나 CSS, JavaScript 파일 및 이미지와 같은 경우 우리가 정확히 URL을 알고 있는 경우 내장 함수를 사용하여 모든 입력 엔드포인트를 캐시하고 캐시에 저장할 수 있습니다.\n\n![이미지](/assets/img/2024-06-22-BuildYourFirstOfflineWebAppftProgressiveWebApplications_3.png)\n\n여기에서 우리가 논의한 것은 단지 비즈니스의 성격에 따른 기본 캐싱 전략뿐입니다.\n\n다음은 널리 사용되는 몇 가지 인기있는 캐싱 기술 목록입니다.\n\n<div class=\"content-ad\"></div>\n\n- 캐시 후 네트워크 (먼저 캐시에 리소스가 있는지 확인한 후 있으면 거기서 서비스하고, 그렇지 않으면 네트워크에 도달).\n- 네트워크 후 캐시 (먼저 리소스를 네트워크를 통해 검색할 수 있는지 확인하고 가능하면 그것에 우선순위를 부여하고, 네트워크 요청이 실패하면 캐시된 리소스로 대체).\n- 캐시와 네트워크 (이 전략에서는 먼저 캐시에 리소스가 있는지 확인한 후 있으면 거기에서 서비스하고, 동시에 서버에서 리소스를 가져오는 네트워크 호출을 하여 이전에 서비스된 리소스로 대체합니다).\n\n원하는 캐시 전략을 사용하거나 애플리케이션의 특성에 기반하여 고유한 전략을 고안할 수 있습니다.\n\n## 배경 동기화\n\n이전 섹션에서 주로 GET 요청을 가로채는 방법에 대해 설명했습니다. 이번 섹션에서는 앱 외부에서 데이터를 받는 POST 요청과 함께 작동하는 방법에 대해 논의하겠습니다. 네트워크가 사용 불가능한 경우 아무것도 할 수 없습니다. 이를 처리하려면 POST 데이터를 어딘가에 저장해야 합니다(IndexedDB 또는 캐시) 그러고나서 앱이 다시 온라인 상태가 되면 동기화합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-22-BuildYourFirstOfflineWebAppftProgressiveWebApplications_4.png)\n\n![image](/assets/img/2024-06-22-BuildYourFirstOfflineWebAppftProgressiveWebApplications_5.png)\n\n제가 첫 번째로 하는 작업은 SyncManager의 사용 가능 여부를 확인하는 것입니다. 사용 가능하다면 'sync-new-posts' 태그로 요청을 대기열에 넣습니다 (이 요청은 나중에 서비스 워커가 동기화 이벤트를 식별하는 데 사용될 것입니다). 이 동기화 요청은 나중에 브라우저에 의해 자동으로 처리되어 네트워크 상황이 적절할 때 즉시 요청을 전송할 것입니다.\n\n![image](/assets/img/2024-06-22-BuildYourFirstOfflineWebAppftProgressiveWebApplications_6.png)\n\n\n<div class=\"content-ad\"></div>\n\n# 푸시 알림\n\n알림은 OS 수준의 기능입니다. 알림의 몇 가지 특성은 모든 OS에 공통되며 비즈니스 요구에 따라 사용자에게 표시할 알림 종류를 결정하고 그에 따라 알림을 빌드하는 옵션을 전달할 수 있습니다.\n\n다른 기능과 마찬가지로 브라우저나 기기에서 해당 기능을 사용할 수 없는 경우에는 앱에 확인 및 예비조치를 취해주세요.\n\n## 푸시 알림 설정하기 (구독)\n\n<div class=\"content-ad\"></div>\n\n알림을 표시하려면 서비스 워커 등록 객체에 있는 showNotification 함수를 사용하면 됩니다.\n\n![image](/assets/img/2024-06-22-BuildYourFirstOfflineWebAppftProgressiveWebApplications_7.png)\n\n푸시 알림(서버를 통해 트리거)을 하려면 vapid 키를 사용하여 클라이언트를 서버와 인증하는 구독을 설정해야 합니다 (vapid 키는 웹 푸시를 통해 생성됩니다).\n\n- 팔로드 백엔드 인증을 위해 퍼블릭 키(클라이언트용) 및 프라이빗 키(서버용)를 생성하여 프론트엔드를 백엔드와 인증합니다.\n- 사용자가 앱에서 푸시 알림을 선택하면 pushManager의 getSubscription 함수를 사용하여 구독 세부정보를 생성합니다. 이 정보는 아래와 같이 나타납니다.\n\n<div class=\"content-ad\"></div>\n\n![2024-06-22-BuildYourFirstOfflineWebAppftProgressiveWebApplications_8.png](/assets/img/2024-06-22-BuildYourFirstOfflineWebAppftProgressiveWebApplications_8.png)\n\n이 정보는 데이터베이스에 저장되며 엔드포인트를 사용하여 브라우저에 요청이 전송됩니다. (크롬의 경우 fcm.googleapi...로 시작하는 브라우저마다 다를 수 있음), 서버는 브라우저의 엔드포인트로 요청을 보내며 브라우저 서버는 해당 요청을 브라우저로 전달하는 역할을 합니다.\n\n![2024-06-22-BuildYourFirstOfflineWebAppftProgressiveWebApplications_9.png](/assets/img/2024-06-22-BuildYourFirstOfflineWebAppftProgressiveWebApplications_9.png)\n\n프론트엔드 푸시 이벤트 리스너는 알림 요청이 도착하면 해당 요청을 수신하여 클라이언트 측 코드에 따라 작동합니다.\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-22-BuildYourFirstOfflineWebAppftProgressiveWebApplications_10.png)\n\n## 알림 옵션 사용자 정의\n\n비즈니스 요구 사항에 맞게 사용자 지정할 수 있는 알림 옵션이 여러 가지 있습니다. 해당 문서를 확인하여 해당 옵션을 배우고 사용 중인 알림 옵션이 널리 지원되는지 확인하세요.\n\n## 문제 해결하기 (생활을 쉽게 만들어 줄 수 있습니다)\n\n<div class=\"content-ad\"></div>\n\n- 모든 작업을 정확히 수행했다고 생각하더라도 알림이 표시되지 않는 경우에는 기기 설정 및 웹 사이트 권한을 확인해보세요.\n- 누군가 검사 탭에서 사이트 데이터를 지우면(아래 옵션에서) 구독이 사라지고 DB에서 사용할 수 없게 될 것입니다(기본적으로 알림이 작동을 멈출 것이므로 이 시나리오를 처리해야 합니다).\n\n![Web App Image](/assets/img/2024-06-22-BuildYourFirstOfflineWebAppftProgressiveWebApplications_11.png)\n\n## 알림 작업 청취\n\n서비스 워커의 notificationclick 및 notificationclose에 두 가지 이벤트 리스너가 더 있습니다. 사용자가 알림과 상호 작용하는 것을 트리거할 것이며, 이는 사용자가 곧 알림 옵션에 따라 무언가를 수행하길 원할 경우 유용할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-22-BuildYourFirstOfflineWebAppftProgressiveWebApplications_12.png)\n\n# 서비스 워커를 관리하는 편리한 도구: Workbox\n\n지금까지 우리가 논의한 모든 코드와 기술은 우리가 직접 작성한 것이었습니다. 그러나 캐싱과 기타 기본적인 것들은 나중에 문제를 일으킬 수 있습니다.\n\n- 코드의 캐시 버전을 업데이트할 때마다.\n- 정적 자산을 수동으로 캐시 배열에 추가하기\n\n\n<div class=\"content-ad\"></div>\n\n모든 이 기본 사항은 쉽게 잊혀질 수 있고 앱이 프로덕션에서 버그가 있는 것처럼 느껴질 수 있습니다. 그래서 이 문제를 피하고 다른 기본 서비스 워커 기능을 자동화하기 위해 workbox를 사용할 수 있습니다. workbox는 개발자의 삶을 쉽게 만들어주는 많은 내장 메소드를 제공하며 자주 사용되는 서비스 워커 기술을 구현할 수 있습니다.\n\n## 전문가 팁\n\n서비스 워커의 위치(URL 또는 파일 이름)를 변경하는 것을 피하십시오. 그렇게 하면 이전 서비스 워커와 병렬로 실행되는 다른 서비스 워커가 등록되는 문제가 발생할 수 있습니다. [참고]\n\n이 문서에 대한 제안이나 교정 사항이 있으면 언제든지 환영합니다. 더 많은 글을 위해 팔로우 해주세요. 그 때까지 즐거운 코딩!❤.\n\n<div class=\"content-ad\"></div>\n\n## 쉽게 설명한 영어 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 글쓴이를 튼튼히 응원하고 팔로우해 주세요 👏\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문하기: CoFeed | Differ\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요.","ogImage":{"url":"/assets/img/2024-06-22-BuildYourFirstOfflineWebAppftProgressiveWebApplications_0.png"},"coverImage":"/assets/img/2024-06-22-BuildYourFirstOfflineWebAppftProgressiveWebApplications_0.png","tag":["Tech"],"readingTime":7},{"title":"개발자라면 반드시 알아야 할 잘 알려지지 않은 파이썬 모듈 9가지","description":"","date":"2024-06-22 00:08","slug":"2024-06-22-Lesser-KnownPythonModulesThatEveryDeveloperShouldKnow","content":"\n\n\n![image](/assets/img/2024-06-22-Lesser-KnownPythonModulesThatEveryDeveloperShouldKnow_0.png)\n\n인기 있는 일반 목적 프로그래밍 언어마다, 코드 작성 생산성을 향상시키기 위해 사전 개발된 함수 또는 클래스를 사용하는 데 도움이 되는 기능들을 갖춘, 잘 구성된 표준 라이브러리가 있습니다. 어떤 프로그래밍...\n","ogImage":{"url":"/assets/img/2024-06-22-Lesser-KnownPythonModulesThatEveryDeveloperShouldKnow_0.png"},"coverImage":"/assets/img/2024-06-22-Lesser-KnownPythonModulesThatEveryDeveloperShouldKnow_0.png","tag":["Tech"],"readingTime":1},{"title":"CS50 경험 공유 2024 최신 강의 리뷰 및 배우는 방법","description":"","date":"2024-06-21 23:59","slug":"2024-06-21-MyCS50experience","content":"\n\n\n![My CS50 Experience](/assets/img/2024-06-21-MyCS50experience_0.png)\n\n몇 달 전, 프로그래밍 여정에서 무엇을 해야 할지 전혀 감이 오지 않았어요. 그런 다음 몇몇 유튜버와 친구들의 충고 덕분에 내 CS50 여정을 시작했어요. 말하고 싶은 게—정말 훌륭한 경험이었어요!\n\n# 몇 주 전에 CS50 코스를 완료했어요\n\n- Scratch, C, 데이터 구조, 메모리 관리, HTML, CSS, SQLite, Python, JavaScript, Flask 등과 같은 다양한 기술들을 탐험하고 배우며 실패하고 이해했죠.\n- 이러한 기술들의 기초를 이렇게 짧은 시간 안에 이해하고 창의적인 설명과 시범을 통해 배웠던 것은 놀라운 경험이었어요.\n\n\n<div class=\"content-ad\"></div>\n\n\n![2024-06-21-MyCS50experience_1.png](/assets/img/2024-06-21-MyCS50experience_1.png)\n\n- 매주 해당되는 문제 세트들은 정말 도전적이었고 내 지식과 프로그래밍 기술을 향상시키는 데 도움이 되었어요.\n\n# 문제 세트\n\n- 솔직히 말해서, 문제 세트는 최고의 것 중 하나였고, 브라이언이 문제와 해결책을 설명하는 짧은 단편이 놀랍었어요.\n- 64비트 수학을 활용하여 일반 이미지를 다양한 필터로 변환하는 문제 세트, GET 및 POST 요청의 라우팅을 찾고 Flask에서 다양한 작업을 수행해야 했던 재무 문제 세트, 그리고 데이터베이스 레코드를 활용해 도둑을 잡아야 했던 Fiftyville은 정말 흥미진진한 경험이었어요.\n\n\n<div class=\"content-ad\"></div>\n\n# 가장 자신없을 때\n\n- 지금은 그 경험이 훌륭했다고 말하지만, 그 코스를 수강할 때는 언제나 가짜인 줄로 느꼈습니다.\n- 제가 진짜 수행할 수 있을지 항상 의심했지만, 거기에 함께 수강한 친구가 있었어요. 그 친구 덕분에 이제는 완료에 관한 블로그를 쓰고 있답니다 🙂\n\n# 최종 프로젝트\n\n- 코스의 마지막 부분에 도착하여 최종 프로젝트를 수행할 때, 계속해서 어떻게 진행해야 할지, 무엇을 만들어야 할지, 그리고 어떤 기술을 사용해야 할지 등 많은 질문으로 인해 혼란스러웠어요.\n- 그때 나만의 문제를 살펴보려고 노력했어요. 항상 두 개의 웹사이트나 앱을 오가며 lofi study beats를 듣고 할 일 목록을 유지하는 데 어려움을 겪었어요. 만약 이 두 가지를 하나로 결합할 수 있다면 어떨까 하는 생각이 들었죠?\n- 그 웹사이트가 놀라울 정도로 위대하거나 세상을 변화시키는 것은 아니지만, 어쨌든 나는 사용할 수 있을 거라고 생각해요.\n- 그래서 생산성과 습관을 결합하는 웹사이트를 만들기로 결심했어요. 예를 들어, lofi study beats와 할 일 목록을 합치는 것이요.\n\n<div class=\"content-ad\"></div>\n\n## 웹 사이트 링크:- http://ashishnagmoti.pythonanywhere.com/\n\n- 튜토리얼 링크: https://youtu.be/NlTR48V-_rs?si=qCaCIaMN0fsdA0YP\n\n-\n\n# 결론\n\n- 마지막으로 이렇게 멋진 경험을 한 것은 제 학습 여정 중 가장 놀라운 일 중 하나였습니다. CS에 진입하고 싶은 사람에게 꼭 추천드립니다.\n\n이것이 제 경험이었습니다. 여러분의 생각/경험을 댓글에 공유해 주세요.","ogImage":{"url":"/assets/img/2024-06-21-MyCS50experience_0.png"},"coverImage":"/assets/img/2024-06-21-MyCS50experience_0.png","tag":["Tech"],"readingTime":2},{"title":"구글 클래스룸으로 교사와 학생을 하나로 Flutter를 사용한 크로스 플랫폼 개발 방법","description":"","date":"2024-06-21 23:54","slug":"2024-06-21-CrossPlatformdevelopmentwithFlutterHowGoogleClassroomgetsteachersandstudentsonthesamepage","content":"\n\nGoogle의 Classroom 앱은 원래 2014년에 시작되어 전 세계의 1억 5천만 교육자와 학생들이 수업 내에서 숙제, 성적 및 커뮤니케이션을 조직화하는 데 사용됩니다. Android 및 iOS에서 사용할 수 있으며, 개발은 처음 시작된 해부터 이어져 왔으며, 이동 플랫폼의 변화 시대를 겪었습니다. 그 다양한 변화를 관리하는 것은 어려운 일이었습니다.\n\n동기화를 위한 노력에도 불구하고, 2021년에는 7년 뒤에도 Classroom 앱의 독특한 Android 및 iOS 코드베이스가 특징, UI 및 구현에서 점진적으로 멀어졌습니다. 동일한 UI에 대해 다른 접근 방식을 취한 화면과 같은 가장 명백한 차이부터 인증 및 앱 시작 로직의 차이와 같이 덜 명백한 차이까지; Classroom은 유지 및 향상하기 어려운 앱으로 변모했고, 두 코드베이스가 소규모 개발자 풀에 부담을 주었습니다.\n\n지속적인 현상 유지, 더 많은 개발자 추가, 크로스 플랫폼 프레임워크를 사용한 두 코드베이스의 완전한 재작성이 포함된 다양한 옵션이 있었습니다. 개선에 헌신하는 팀은 상태 quo 옵션을 제외하고, 이미 존재하는 두 코드베이스를 안정화하는 데 필요한 조치를 평가한 후, 단순히 더 많은 개발자를 추가하는 것으로는 부족하다고 판단했습니다. 결국 팀은 그들의 세 번째 선택인 Flutter를 사용하여 단일 소스, 크로스 플랫폼 솔루션으로 Classroom을 재상상하기로 결정했습니다.\n\n# Flutter가 Classroom 앱을 어떻게 간단하게 만들었는지\n\n<div class=\"content-ad\"></div>\n\n## 일관성 없는 UIs \n\nGoogle Classroom의 가장 뚜렷한 문제 중 하나는 UI의 변화로, 선생님들이 안드로이드와 iOS UI를 깊이 알아야 했습니다. 학생들이 한 플랫폼에서 보는 숙제 화면과 지침에 관한 질문을 받았을 때, 다른 플랫폼에서 본 화면과의 비교로 답변이 상당히 혼란스러울 수 있습니다.\n\n![UI variations](/assets/img/2024-06-21-CrossPlatformdevelopmentwithFlutterHowGoogleClassroomgetsteachersandstudentsonthesamepage_0.png)\n\n일반적인 접근 방식은 시간이 지남에 따라 차이가 벌어지는 별도의 팀이 개발한 별도의 클라이언트 앱입니다. 이를 방지하기 위해서는 매우 일관된 작업을 통해 모든 기능을 동기화해야 합니다. 그것과 대조적으로, 플러터의 본질은 기본 설정으로 UI가 동일하며 [1], 사용자의 이점을 위해 적응성을 위한 노력(자주 발생)이 있을 때까지만 다른 방향으로 빗겨나갑니다.\n\n<div class=\"content-ad\"></div>\n\n## 혼동된 비즈니스 로직\n\n클래스룸의 안드로이드 및 iOS 클라이언트가 맞지 않았던 유일한 곳은 사용자 인터페이스뿐만이 아니었습니다. 일부 복잡한 비즈니스 로직을 클라이언트로 오프로드하는 서버 측 솔루션에 의해 형성된 과거의 클래스룸 앱은 또한 핵심 구현에서의 차이를 처리했습니다. 가끔씩 플랫폼별 버그가 발생하기도 했으며 (엔지니어가 재현하려는 노력을 좌절시키는 경우도 있었습니다!), 이는 양쪽 구현의 정확성을 평가하려는 사람에게 상당한 정신적 부담을 줬습니다.\n\nFlutter를 사용하여 클래스룸을 다시 작성함으로써, Flutter가 네이티브 플랫폼 상호작용을 처리하는 방식 때문에, 이전에 보고되지 않았던 수많은 버그들이 간단히 해결되었습니다.\n\n원래 코드에서는 수년에 걸친 지속적인 개발로 UI, 비즈니스 및 플랫폼별 로직 간의 경계가 가끔씩 흐려졌습니다. 이는 사용자의 버그 보고가 거의 항상 전체 호출 스택이 잠재적으로 죄가 있는 지 절대적으로 구분해야하는 큰 노력임을 의미했습니다. 요청한 파일이 로드되지 않는 이유가 파일 시스템을 잘못 읽어서, 비즈니스 로직에서 미스통신 때문에, 아니면 UI가 파일을 수신하지만 그 후로 파일을 잃어버린 것일까요? 그것을 알아내는 유일한 방법은 모든 것을 조사하는 것뿐이었습니다.\n\n<div class=\"content-ad\"></div>\n\n물론, 플러터 개발자들도 누구나 할 수 있는 것처럼 이 경계를 흐려지게 만들고 로직을 섞을 수 있지만, 수업실 엔지니어링 팀은 프레임워크 모베르 베스트 프랙티스를 따르는 것이 이를 쉽게 드러내게 만드는 것으로 발견했습니다. 플러터의 선언적 UI 시스템은 UI 위젯 내에서 실수로 비지니스 로직을 배치하는 것을 강력히 권고하며, 새로운 MVVM 아키텍처는 실수 없이 정리된 책임 층을 강제할 수 있도록 도와주었습니다. 이는 플러터 위젯 뒤에 있는 방대한 코드베이스 내에서 분명한 레이어를 유지할 수 있도록 해주는 데 도움이 되었습니다.\n\n플러터 앱은 여전히 주기적으로 기본 플랫폼과 통신해야 합니다 — 어쨌든, 숙제를 업로드하고 볼 수 있는 사용자 경로는 파일 시스템을 사용하지 않으면 이뤄질 수 없습니다. 하지만 여기서도 플러터는 플랫폼별 로직을 전용 플러그인으로 격리하는 패턴을 따라 일상적인 디스크 I/O와 같은 것이 소속되지 말아야 하는 곳으로 슬금슬금 스니킹되는 것을 방지했습니다. 아래 예제는 플러터 앱이 전체 호출 스택을 혼란스럽지 않게 하면서 파일 시스템에 액세스하는 현실적인 방법을 보여줍니다.\n\n```dart\nimport \"dart:io\";\nimport \"package:path/path.dart\" as path;\nimport \"package:path_provider/path_provider.dart\" as path_provider;\n\n// 특정 과제에 대한 학생의 저장된 숙제를 불러오는 함수\n// 반환된 값의 exists() 함수는 학생이 숙제를 먹은 경우 False를 반환합니다.\nFuture<File> getHomework(Assignment assignment) async {\n  // `path_provider` 패키지를 사용하여 플랫폼별 파일 시스템 특성을 추상화합니다\n  final Directory homeworkDirectory = \n    await path_provider.getApplicationSupportDirectory();\n\n  // 학생이 업로드한 숙제를 추출합니다\n  return File(\n    path.join([homeworkDirectory.absolute.path, assignment.name]),\n  );\n}\n```\n\n이 예는 간단합니다. 수업실 엔지니어링 팀은 궁극적으로 플랫폼과 더 복잡한 상호작용을 포함하는 자체 플러그인을 개발했습니다. 흥미로운 점은, 이렇게 함으로써 그들의 네이티브 코드가 원래의 네이티브 앱보다 디버깅하기 쉬워졌습니다. 이게 가능했던 이유는 무엇일까요? Flutter 플러그인에서 반복하지 않기(Don’t Repeat Yourself, DRY) 원칙을 따르면 가능한 한 많은 비지니스 로직을 다트 코드로 올려놓고, 네이티브 상호작용을 위한 가장 간단한 메서드 호출만 남겨두기 때문입니다. 이는 도메인 로직과 플랫폼 로직 사이에 확고한 분리를 강요하여, 수업실의 안드로이드나 iOS 코드의 오류가 단일 책임 함수에 격리되어 쉽게 이해할 수 있는 것이었습니다.\n\n<div class=\"content-ad\"></div>\n\n## 성능 저하\n\n사용자의 여정이 실패할 때, 모두가 동의하는 반드시 해결해야 할 명확한 버그가 제출됩니다. 하지만 앱 시작 시간이 점점 악화되어온 지어 올 해 말로 얼마전 앱이 출시된 후 몇 년 동안 변해온 문제와 같은 더 부드러운 문제에 대해 어떻게 해야 할까요? 여러 클라이언트를 동기화하는 것에 대한 우려를 더하면, 앱의 느린 시작 흐름을 해결하는 작업은 절망적인 일처럼 느껴집니다.\n\n여기서 Flutter이 도움을 주어 문제를 악화시키지 않으면서 충분히 빠른 속도로 도와주었고, 더 중요한 것은 깨끗한 출발의 기회를 제공했습니다. 개발 몇 년을 끌어온 기존 문제를 해결하는 대신 새로운 것을 구축하고 있다는 사실로, Classroom 팀은 중복되는 API 호출을 제거하고 다른 독립적인 API 호출을 병렬화하며, 모든 것이 해결될 때까지 shimmer 효과와 다른 UI 미리보기를 표시함으로써 권한 부여 및 시작 흐름을 명확히 했습니다. 결과는 앱 시작 시간의 놀라운 80% 감소였습니다!\n\n## 주석 기능\n\n<div class=\"content-ad\"></div>\n\n대부분의 Classroom 기능은 과제와 업로드된 숙제와 같은 내용을 공유하는 사용자들을 모아주는 비교적 일상적인 앱으로 볼 수 있습니다. 그러나 한 가지 기능이 분명히 복잡하게 빛을 발합니다. Classroom의 주요 기능 중 하나는 파일 공유입니다. 여기서 교사와 학생 모두가 파일을 만들고 보고 편집할 수 있으며, 자유형 주석을 추가할 수 있습니다. 마치 펜이나 마커로 직접 종이에 그림을 그리는 것처럼 자유롭게 주석을 추가할 수 있습니다. 이 주석 공유 기능은 이미 Classroom의 내장 Android 및 iOS 클라이언트에 존재했기 때문에 Flutter로 이식하는 것이 어려웠던 문제였습니다. \n\nClassroom 팀은 이 주석 기능을 플랫폼별 구현을 별도의 라이브러리로 위임하는 플러그인으로 재패키지할 수 있었습니다. 파일 주석에 대해, 해당 기능은 이미 Google One, Google Keep 및 이전 Classroom 앱에서 사용되는 기존 네이티브 라이브러리들을 감싼 얇은 래퍼로 되어 있었습니다. 내부적으로 Android와 iOS는 파일 공유 주변에 서로 다른 구현 요구 사항이 있습니다. iOS에서는 Classroom 앱이 네이티브 뷰를 통해 파일에 액세스하지만, Android에서는 Google Keep 앱을 직접 엽니다. 그러나 좋은 플러그인 디자인 원칙을 통해 이러한 구현 세부 사항을 격리시키고 앱의 나머지 부분에서 깨끗하고 일관된 Dart API를 노출할 수 있었습니다. 결과적으로 Classroom의 \"가장 복잡한\" 기능 중 하나가 Flutter로 성공적으로 이식되었습니다.\n\n아래는 Android에서 Classroom 주석 기능의 시각화입니다. 네이티브 및 Flutter UI 구성 요소의 혼합이 나와 있습니다.\n\n![Classroom Annotation Feature on Android](/assets/img/2024-06-21-CrossPlatformdevelopmentwithFlutterHowGoogleClassroomgetsteachersandstudentsonthesamepage_1.png)\n\n<div class=\"content-ad\"></div>\n\n보다 넓게 바라보면, 플러터에서의 전형적인 플러그인 디자인은 다음과 같이 구성되어 있습니다. 단일하고 간결한 인터페이스가 플랫폼별 라이브러리를 로드하며, 이 라이브러리들은 다시 FFI 또는 JNI를 사용하여 기본 플랫폼과 통신합니다. 이를 통해 플러터 앱은 빌드 대상의 모든 플랫폼별 네이티브 API와 상호 작용할 수 있으며, 이러한 고려 사항을 Dart 코드로 유출시키지 않습니다.\n\n![이미지](/assets/img/2024-06-21-CrossPlatformdevelopmentwithFlutterHowGoogleClassroomgetsteachersandstudentsonthesamepage_2.png)\n\n# 되돌아보며\n\n## 개발 속도\n\n<div class=\"content-ad\"></div>\n\n클래스룸 팀은 앱을 다시 작성하는 데 2년이 걸렸습니다. 초기 프로토타입 단계에서 1명의 엔지니어로 시작하여 개발의 절정 단계에서는 10명의 정규 엔지니어로 성장한 팀과 함께 작업했습니다. 이것은 작은 투자가 아니지만, 개발 및 유지 보수가 영원히 빨라진다는 약속을 바탕으로 하였습니다. 클래스룸은 2023년 6월에 iOS에서 플러터 재작업을 시작하고, 2024년 1월에 Android에서 발표하여 프로젝트를 완료했습니다. 그 이후로 새로운 기능에 소요된 평균 엔지니어링 시간이 3분의 2 감소했고, 개발자 속도가 3배 증가했습니다! 2년간 새로운 기능을 기다린 이후 스테이크홀더들은 기다렸던 ✨빠른 기능 개발✨의 도래로 기뻐하고 있습니다.\n\n클래스룸 팀이 다시 작성을 결정한 부분 중 하나는, 프로젝트가 결코 \"끝나지 않을\" 것이라는 것을 인지하였기 때문입니다. 새로운 기능이 미래에도 계속 추가될 것으로 예상되었습니다. 이는 다소 비용이 많이 들더라도 언젠가는 그 대가를 치룰 것이라는 설득력 있는 이유가 되었습니다. 클래스룸 팀이 다시 작성에서 투자 회수 포인트에 도달할 때까지의 공식은 다음과 같습니다:\n\n![수식](/assets/img/2024-06-21-CrossPlatformdevelopmentwithFlutterHowGoogleClassroomgetsteachersandstudentsonthesamepage_3.png)\n\niOS를 출시한 이후 9개월 동안, 클래스룸은 플러터가 제공하는 개발자 속도 3배 증가로 초기 투자의 40%를 이미 회수했다고 추정하고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 개발자 경험\n\n개발 속도가 증가하여 가장 행복해하는 사람들은 이해 관계자보다 개발자들입니다. 교실 팀의 경우, 개발 속도가 3배 증가한 것은 각 기능을 한 번만 작성하거나(또는 무거운 네이티브 구성 요소가 있는 경우에는 최대 1.5배 작성), 종종 몇 달씩 격리되어 있는 두 팀 간의 조정 비용을 제거하고, 물론 핫 리로드가 결합된 결과입니다. 핫 리로드만으로도 약 99%의 재구축 시간 감소를 이뤘으며, 이것은 교실 팀의 사기를 높여 두 네이티브 클라이언트로부터 얻었던 것보다 더욱 크게 향상시켰습니다. 교실 팀은 Flutter로 전환한 후 엔지니어를 쉽게 유치하고 유지할 수 있었습니다.\n\n게다가, 교실 팀은 새로운 기능을 구현하는 데 평균적으로 최소 50% 더 적은 코드 라인이 필요하다는 사실을 발견했습니다. 실제로는, 재작업 중에 구축한 모든 기능이 두 네이티브 클라이언트에서 실제로 구현되어 있지 않았기 때문에 감소율은 상당히 높을 수 있습니다. 다시 말해, 이전 모든 기능뿐만 아니라(예: iOS의 오프라인 지원 포함) 큰 기능 차이를 완벽하게 수행하는데 필요한 코드의 50% 정도만으로 충분합니다.\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\n교실 팀은 리라이트를 시작한 지 약 2년 후에 Android 및 iOS로 그들의 앱을 출시했으며 추가적인 기능을 추가하여 초기 투자의 40%를 상환했습니다. 새로운 앱은 이전 것보다 거의 5배 빠르게 실행되어 개발자와 최종 사용자가 시간과 귀찮음을 절약할 수 있었습니다. 미래를 전망해 보면, 새로운 기능은 이전 상태보다 개발 비용이 1/3이며 두 플랫폼에서 동시에 릴리스되고 문제 해결 및 유지보수가 더 쉽습니다. 교실이 플러터로 전환한 후 사용자, 개발자 및 이해당사자들의 사기는 그들의 미래를 투자하는 것으로 바뀐 후에 이전보다 더 높아졌습니다.","ogImage":{"url":"/assets/img/2024-06-21-CrossPlatformdevelopmentwithFlutterHowGoogleClassroomgetsteachersandstudentsonthesamepage_0.png"},"coverImage":"/assets/img/2024-06-21-CrossPlatformdevelopmentwithFlutterHowGoogleClassroomgetsteachersandstudentsonthesamepage_0.png","tag":["Tech"],"readingTime":8},{"title":"CSS 네이티브 중첩 기능 완벽 해부하기","description":"","date":"2024-06-21 23:52","slug":"2024-06-21-UnpackingNativeCSSNesting","content":"\n\n\n![이미지](/assets/img/2024-06-21-UnpackingNativeCSSNesting_0.png)\n\nCSS와 씨름한 시간이 있다면(솔직히 말해서 누가 안 했겠어요?), 그것이 약간 혼란스러워질 수 있다는 것을 알고 계실 겁니다. 선택자가 쌓이고 규칙이 곳곳에 흩어지며, 이 모든 것은 어떤 개발자라도 더 간단한 방법을 열망하게 만듭니다.\n\n좋은 소식이 있습니다! 여러분의 호소가 들려졌습니다. 이제 우리에게는 기본 CSS 중첩이 있습니다. 새끼 새의 아늑한 집처럼 들릴지도 모르지만, 믿어봐요. 실제로 그것보다 더 멋집니다.\n\n## 무슨 큰일인가요?\n\n\n<div class=\"content-ad\"></div>\n\n옛날에는 (좋아, 몇 년 전) CSS 규칙을 중첩해서 더 정리된 모습으로 만들고 싶다면 Sass나 Less와 같은 전처리기를 사용해야 했습니다. 이 도구들은 좋았지만, 워크플로에 추가 단계를 넣는 번거로움이 있었습니다. 브라우저가 이해할 수 있도록 코드를 컴파일해야 했습니다.\n\n기본 CSS 중첩을 통해 추가 도구가 필요하지 않은 상태에서 CSS 파일 내에서 규칙을 중첩할 수 있습니다. 마치 항상 원하던 내장형 캐비닛 정리함을 얻은 것 같은 느낌이에요 (모든 것이 자리를 차지하고 있어요), 그리고 필요한 것을 찾기가 훨씬 쉽습니다.\n\n## 코드 보여줘!\n\n그만 얘기하고, 몇 가지 예제로 이 작업이 어떻게 작동하는지 확인해보세요:\n\n<div class=\"content-ad\"></div>\n\n기본 중첩:\n\n```js\n/* 중첩 없이 */\n.card { 배경색: 흰색; 패딩: 20px; }\n.card h2 { 글꼴 크기: 24px; }\n.card p { 줄 높이: 1.6; }\n.card a { 색상: 파란색; }\n\n\n/* 중첩 사용 */\n.card {\n  배경색: 흰색;\n  패딩: 20px;\n\n  h2 { 글꼴 크기: 24px; }\n  p { 줄 높이: 1.6; }\n  a { 색상: 파란색; }\n}\n```\n\n가상 클래스와 함께 중첩:\n\n```js\n/* 중첩 없이 */\n.btn { /* ...버튼 스타일... */ }\n.btn:hover { 배경색: #0056b3; 색상: 흰색; }\n.btn:active { 박스 그림자: inset 0 3px 5px rgba(0, 0, 0, 0.125); }\n\n\n/* 중첩 사용 */\n.btn {\n  /* ...버튼 스타일... */\n\n  &:hover {\n    배경색: #0056b3;\n    색상: 흰색;\n  }\n\n  &:active {\n    박스 그림자: inset 0 3px 5px rgba(0, 0, 0, 0.125);\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n미디어 쿼리와 중첩 사용하기:\n\n```js\n/* 중첩 없이 */\n.container { width: 960px; margin: 0 auto; }\n@media (max-width: 768px) {\n  .container { width: 100%; padding: 0 15px; }\n}\n\n\n/* 중첩 사용 */\n.container {\n  width: 960px;\n  margin: 0 auto;\n\n  @media (max-width: 768px) {\n    width: 100%;\n    padding: 0 15px;\n  }\n}\n```\n\n## 중첩을 채택해야 하는 이유\n\n- 가독성: 관련된 스타일을 함께 유지하여 코드를 읽고 이해하기 쉽게 만듭니다 (누가 깔끔한 코드를 싫어하겠어요?).\n- 유지보수성: 무언가를 변경해야 할 때 관련 규칙을 찾기가 훨씬 간단합니다.\n- 반복 최소화: 동일한 부모 선택기를 반복해서 입력할 필요가 없습니다. (솔직히 말해서, 할 일이 아직 많은데 말이죠.)\n- 효율성: 네이티브 CSS 중첩을 사용하면 반복되는 선택기를 제거하여 파일 크기를 조금 줄일 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 주의 사항 몇 가지\n\n- 브라우저 지원: 중첩은 상대적으로 새로운 개념이므로 전면적으로 도입하기 전에 각 브라우저가 지원하는지 확인해보세요. (호환성을 확인하려면 caniuse.com과 같은 도구를 사용할 수 있습니다.)\n- 과도한 중첩: 중첩을 지나치게 사용하지 마세요. 너무 많은 수준은 코드를 이해하기 어렵게 만들 수 있습니다. (프로젝트에 \"적절한\" 중첩 수준을 찾아보세요.)\n\n## 중첩해 보세요!\n\n기본 CSS 중첩은 스타일시트의 구조와 가독성을 개선하는 간단하면서도 강력한 방법입니다. 그러니 더 이상 기다릴 이유가 있나요? 중첩을 시작해서 업무 흐름에서 만드는 차이를 보세요.\n\n<div class=\"content-ad\"></div>\n\n네이티브 CSS 중첩에 대해 더 알아보기 위해 문서를 확인해보세요:\n\n- [MDN Native CSS Nesting](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_nesting)\n- [Chrome DevTools CSS Nesting](https://developer.chrome.com/docs/css-ui/css-nesting)\n\n그리고, 도움이 되었다면 팔로우하기를 잊지마세요! 소프트웨어 엔지니어링 및 특히 웹 개발의 흥미로운 세계에 대한 팁, 통찰력 및 업데이트를 공유하는 걸 좋아합니다. 즐겨 사용하세요!","ogImage":{"url":"/assets/img/2024-06-21-UnpackingNativeCSSNesting_0.png"},"coverImage":"/assets/img/2024-06-21-UnpackingNativeCSSNesting_0.png","tag":["Tech"],"readingTime":3},{"title":"Flutter에서 리프레시 토큰 사용하는 방법 모바일","description":"","date":"2024-06-21 23:50","slug":"2024-06-21-FlutterRefreshtokenmobileside","content":"\n\n플러터에서 Dio를 사용하여 토큰을 새로 고치는 방법\n\n![image](/assets/img/2024-06-21-FlutterRefreshtokenmobileside_0.png)\n\n현대 모바일 애플리케이션에서는 사용자 인증 세션을 원활하게 유지하는 것이 사용자 경험에 매우 중요합니다. 인증을 관리하는 효과적인 방법 중 하나는 리프레시 토큰을 사용하는 것입니다. 이 기사에서는 Dio를 사용하여 플러터 애플리케이션에서 리프레시 토큰을 처리하는 방법에 대해 살펴보겠습니다.\n\n토큰이란 무엇인가요?\n토큰은 토큰 기반 인증에서 애플리케이션이 API에 액세스할 수 있도록 허용하는 데 사용됩니다. 사용자가 성공적으로 인증하고 액세스 권한을 부여한 후 애플리케이션은 액세스 토큰을 받아들이고 대상 API를 호출할 때 자격 증명으로서 액세스 토큰을 전달합니다. 전달된 토큰은 API에게 전달된 토큰의 소유자가 API에 액세스할 권한이 있으며 승인 중에 부여된 범위에 따라 특정 조치를 수행할 수 있음을 알립니다.\n\n<div class=\"content-ad\"></div>\n\n리프레시 토큰이 무엇인가요?\n리프레시 토큰은 사용자가 다시 인증을 받지 않고 새로운 엑세스 토큰을 얻는 메커니즘입니다. 일반적으로 엑세스 토큰은 보안상의 이유로 수명이 짧지만, 리프레시 토큰은 더 오래 지속됩니다. 엑세스 토큰이 만료되면 리프레시 토큰을 사용하여 새로운 엑세스 토큰을 얻을 수 있어 사용자의 세션을 중단시키지 않고 유지할 수 있습니다.\n\n단계별로 리프레시 토큰 구현하기\n\nDio의 인스턴스를 구성하고 초기화하는 'DioFactory' 클래스를 만드세요.\n\n```js\nclass DioFactory {\n\n  Future<Dio> getDio() async {\n    Dio dio = Dio();\n\n    Map<String, String> headers = {\n      contentType: applicationJson,\n      accept: applicationJson,\n    };\n\n    dio.options = BaseOptions(\n      baseUrl: ConstantsApi.baseUrl,\n      headers: headers,\n      receiveTimeout: const Duration(milliseconds: Constants.apiTimeOut),\n      sendTimeout: const Duration(milliseconds: Constants.apiTimeOut),\n      connectTimeout: const Duration(milliseconds: Constants.apiTimeOut),\n    );\n\n    if (!kReleaseMode) {\n      dio.interceptors.add(\n        PrettyDioLogger(\n          requestHeader: true,\n          requestBody: true,\n          responseHeader: true,\n          error: true,\n        ),\n      );\n    }\n\n    return dio;\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\nApiService 클래스는 Dio를 사용하여 API 요청을 처리하고 인증 토큰을 관리하기 위해 설계된 포괄적인 서비스 레이어입니다. 이 클래스와 기능에 대한 자세한 설명을 제공합니다.\n\n01- 클래스 선언 및 필드\n“_dio1”과 “_dio2”는 \"Dio\"의 인스턴스입니다. “_dio1”은 일반 API 요청에 사용되고, “_dio2”는 토큰 갱신 요청에 사용됩니다.\n\n```js\nclass ApiService {\n  final Dio _dio1;\n  final Dio _dio2;\n  final AppPreferences _appPref;\n\n  ApiService(\n    this._dio1,\n    this._dio2,\n    this._appPref,\n  ) {\n    _dio1.interceptors.add(\n      InterceptorsWrapper(\n        onRequest: _onRequest,\n        onError: _onError,\n      ),\n    );\n  }\n}\n```\n\n02- 인터셉터\n\n<div class=\"content-ad\"></div>\n\n생성자는 요청 및 오류 처리를 처리하기 위해 \"dio\"에 인터셉터를 추가합니다.\n\n오류 인터셉터:\n이 메서드는 오류를 처리합니다. 특히, 오류가 401 Unauthorized인 경우 토큰을 새로 고치려고 시도합니다.\n\n```js\n_onError(DioException e, ErrorInterceptorHandler handler) async {\n  if(e.response?.statusCode == 401) {\n    _refreshToken(e, handler);\n  } else {\n    handler.next(e);\n  }\n}\n```\n\n03- 토큰 새로고침 로직\n\" _refreshToken \"메서드는 새 액세스 토큰을 받아오기 위해 리프레시 토큰을 사용하려고 시도합니다.\n\n<div class=\"content-ad\"></div>\n\n- 성공하면 저장된 토큰을 업데이트하고 원래 요청을 다시 시도합니다.\n- 새로 고침이 실패하는 경우 (특히 새로 고침 토큰도 잘못된 경우), 사용자를 로그아웃 처리하고 오류를 거절합니다.\n\n```js\n  Future<void> _refreshToken(DioException e, ErrorInterceptorHandler handler) async {\n    try {\n      final refreshToken = _appPref.getRefreshToken();\n      final response = await _dio2.post(\n        ConstantsApi.refreshTokenUrl,\n        data: {'refreshToken': refreshToken},\n      );\n      _appPref.setToken(response.data['accessToken']);\n      _appPref.setRefreshToken(response.data['refreshToken']);\n      handler.resolve(await _dio1.fetch(e.requestOptions));\n    } catch (error) {\n      if (error is DioException) {\n        if (error.response?.statusCode == 401) {\n          _logout();\n          handler.reject(e);\n        } else {\n          handler.next(error);\n        }\n      } else {\n        handler.next(e);\n      }\n    }\n  }\n```\n\n위 단계를 따라 하면 Dio를 사용하여 Flutter 애플리케이션에서 새로 고침 토큰을 처리할 수 있어서 사용자가 원할한 경험을 얻을 수 있습니다. 이 방법은 Dio 인스턴스의 구성을 중앙 집중화하고 토큰을 효율적으로 관리하는 데 도움이 됩니다.","ogImage":{"url":"/assets/img/2024-06-21-FlutterRefreshtokenmobileside_0.png"},"coverImage":"/assets/img/2024-06-21-FlutterRefreshtokenmobileside_0.png","tag":["Tech"],"readingTime":4},{"title":"데이터베이스에서 UUID 사용을 중단해야 하는 이유","description":"","date":"2024-06-21 23:49","slug":"2024-06-21-StopUsingUUIDsinYourDatabase","content":"\n\n<img src=\"/assets/img/2024-06-21-StopUsingUUIDsinYourDatabase_0.png\" />\n\n데이터베이스에서 행을 고유하게 식별하는 가장 일반적인 방법 중 하나는 UUID 필드를 사용하는 것입니다.\n\n그러나 이 접근 방식은 성능 경고사항이 있으니 유의하셔야 합니다.","ogImage":{"url":"/assets/img/2024-06-21-StopUsingUUIDsinYourDatabase_0.png"},"coverImage":"/assets/img/2024-06-21-StopUsingUUIDsinYourDatabase_0.png","tag":["Tech"],"readingTime":1}],"page":"1","totalPageCount":21,"totalPageGroupCount":2,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}