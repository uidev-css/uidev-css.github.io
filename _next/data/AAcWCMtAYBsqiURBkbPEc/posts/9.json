{"pageProps":{"posts":[{"title":"Flutter로 크로스 플랫폼 앱을 만드는 방법","description":"","date":"2024-06-21 21:06","slug":"2024-06-21-HowToUseFlutterforBuildingCross-PlatformApps","content":"\n\n구글은 기술 산업에서 많은 혁신을 이끌어 온 주요한 역할을 해왔어요. 그중 하나가 플러터(Flutter)라는 강력한 프레임워크인데, 개발자들 사이에서 폭넓게 인기를 얻고 있어요. 플러터는 크로스 플랫폼 앱 개발을 용이하게 해주는 능력으로 특히 유명해요. 그리고 더욱 흥미로운 점은 플러터가 이제 웹 개발까지 지원하며, 개발자들이 단일 코드베이스를 사용해 크로스 플랫폼 웹 앱을 만들 수 있다는 것이에요. 이 글에서는 플러터의 크로스 플랫폼 앱 개발에 사용되는 장점을 탐색하고, 웹 개발을 위해 플러터로 시작하는 단계별 안내를 제공할 거에요.\n\n# 플러터를 사용한 크로스 플랫폼 앱의 장점\n\n단일 코드베이스: 플러터의 가장 큰 장점 중 하나는 코드를 한 번 작성하면 iOS, Android 및 웹에서 원활하게 배포할 수 있는 크로스 플랫폼 앱 개발을 가능하게 한다는 것이에요. 이는 코드를 한 번만 작성하고 iOS, Android 및 웹에 쉽게 배포할 수 있어 소중한 시간과 노력을 아낄 수 있게 해줘요.\n빠른 개발: Flutter는 Hot Reload라는 기능을 제공하는데, 이를 통해 개발자들은 편집을 할 때 즉시 실시간 변경 사항을 볼 수 있어요. 이는 개발 과정을 크게 가속화하여 생산성을 향상시킵니다. 개발자들은 손쉽게 앱을 세밀하게 조정할 수 있어요.\n아름다운 반응형 UI: Flutter는 사용자 인터페이스를 구축하기 위한 선언적인 방법을 제공하며 다양한 사용자 지정 위젯과 UI 요소를 제공해요. 이를 통해 다양한 플랫폼에서 네이티브 같은 경험을 제공하는 멋진 반응형 디자인을 쉽게 만들 수 있어요.\n네이티브 성능: Flutter 앱은 네이티브 코드로 컴파일되어 고성능을 보장해요. Skia 그래픽 라이브러리를 활용하여 Flutter는 부드러운 애니메이션과 빠른 렌더링을 가능하게 하며, 시각적으로 매력적인 것 뿐만 아니라 고성능의 앱을 제공해줘요.\n네이티브 기능 및 API에 액세스: Flutter는 개발자들에게 네이티브 기능과 API에 직접 액세스 권한을 부여해요. 디바이스 센서, 카메라, 위치 서비스 또는 플랫폼별 API에 액세스해야 할 때, Flutter는 프레임워크와 네이티브 기능 간의 간극을 메우는 플러그인을 제공해요.\n\n# 웹 개발을 위해 플러터로 시작하기:\n\n<div class=\"content-ad\"></div>\n\n이제 Flutter의 크로스 플랫폼 앱을 위한 장점을 탐색했으니, Flutter 웹 개발을 시작하는 방법에 대해 알아봅시다.\nFlutter 설치: 먼저 시스템에 Flutter SDK를 설치하여 시작하세요. 여러 운영 체제에 대한 자세한 설치 지침은 Flutter 공식 웹사이트에서 확인할 수 있습니다. 터미널에서 Flutter의 명령줄 도구에 어디서든 접근할 수 있도록 필요한 환경 변수를 설정해 주세요.\nIDE 설정: Flutter 개발을 지원하는 통합 개발 환경(IDE)을 선택해주세요. 인기 있는 옵션은 Flutter 익스텐션을 지원하는 Visual Studio Code, Android Studio 또는 Flutter 플러그인을 가진 IntelliJ IDEA 등이 있습니다. 원하는 IDE를 설치하고 Flutter 개발을 위해 구성하세요.\n새로운 Flutter 프로젝트 생성: 터미널이나 명령 프롬프트를 열고 Flutter의 명령줄 도구를 사용하여 새로운 Flutter 프로젝트를 생성하세요. 다음 명령을 실행하세요: flutter create my_web_app, my_web_app은 원하는 프로젝트 이름으로 대체해주세요. 이 명령은 기본 프로젝트 구조와 필요한 파일을 생성합니다.\n프로젝트 실행: 터미널이나 명령 프롬프트를 사용하여 프로젝트 디렉토리로 이동하고 다음 명령을 사용하여 프로젝트를 실행하세요: cd my_web_app 다음으로 flutter run -d chrome. 이 명령은 Flutter 웹 앱을 구글 크롬에서 실행합니다. 원하는 브라우저로 \"크롬\"을 대체할 수 있습니다.\n개발 시작: 앱이 실행 중이면 lib/main.dart 파일을 수정하여 Flutter 웹 앱을 개발을 시작하세요. 이 파일은 앱의 주 진입점으로 기능합니다. Flutter의 위젯 기반 아키텍처를 활용하여 사용자 인터페이스를 작성하고 상호 작용을 처리하며 상태를 관리하세요.\n\n## Flutter 웹 개발의 미래:\n\nFlutter의 웹 개발로의 확장은 크로스 플랫폼 앱 개발에 흥미로운 가능성을 열었습니다. Flutter를 사용하면 개발자들은 동일한 코드베이스로 네이티브 경험과 유사한 고품질 웹 앱을 만들 수 있습니다.\nFlutter 웹 개발의 미래는 더 많은 모험을 약속합니다. Flutter 팀과 활기찬 개발자 커뮤니티는 계속해서 Flutter의 웹 기능을 개선하고 최적화하여 새로운 기능, 향상된 성능 및 더 나은 툴 지원을 제공합니다. Flutter 생태계는 번창하며 웹 개발에 맞춘 ​​새로운 패키지와 리소스의 수가 증가하고 있습니다.\n\nFlutter가 웹에 대해 성숙해질수록 더 많은 기업과 개발자들이 이 프레임워크를 교차 플랫폼 웹 앱 구축의 기본 선택지로 채택할 것으로 예상됩니다. Flutter의 아름다운 UI 제공, 우수한 성능 및 다중 플랫폼에서 코드 재사용의 능력은 현재와 미래를 고려한 웹 개발에 매력적인 선택지로 만들어줍니다. 결론적으로, Flutter는 교차 플랫폼 앱 개발의 새로운 시대를 열었으며 웹 개발에 완벽하게 통합되어 앱 제작의 미래를 형성할 준비가 되어 있습니다. 숙련된 개발자이든 초심자이든 Flutter는 여러 플랫폼에서 쉽게 앱 아이디어를 현실로 만들기 위한 도구와 능력을 제공합니다.","ogImage":{"url":"/assets/img/2024-06-21-HowToUseFlutterforBuildingCross-PlatformApps_0.png"},"coverImage":"/assets/img/2024-06-21-HowToUseFlutterforBuildingCross-PlatformApps_0.png","tag":["Tech"],"readingTime":3},{"title":"Flutter 웹의 혁신적인 새로운 기능 게임 체인저 ","description":"","date":"2024-06-21 21:05","slug":"2024-06-21-FlutterWebNewFeatureGameChanger","content":"\n\nFlutter WebAssembly: 빠른 웹 앱 만들기\n\n모바일 네이티브 앱처럼 부드럽고 반응성 있는 웹 앱을 원한 적이 있나요? 플러터(WebAssembly와 함께 여러분의 꿈을 현실로 만듭니다!\n\nWebAssembly란?\n\n웹 브라우저가 복잡한 작업을 빠르게 처리할 수 있도록 하는 특별한 코드 형식을 상상해보세요. 그것이 바로 WebAssembly입니다. 이것은 C++과 같은 언어를 웹에서 컴파일하고 실행하여 네이티브 앱과 유사한 성능을 달성할 수 있게 합니다.\n\n<div class=\"content-ad\"></div>\n\n플러터와 웹어셈블리를 함께 사용하는 이유는 무엇일까요?\n\n플러터는 이미 모바일과 데스크탑에서 빠르고 아름다운 UI로 유명합니다. 이제 웹어셈블리를 사용하여 웹 프로젝트에 동일한 속도를 제공할 수 있습니다! 이는 다음을 의미합니다:\n\n- 빠른 성능: 웹어셈블리를 통해 그래픽이 많거나 복잡한 계산이 필요한 웹 앱도 원활하게 실행됩니다.\n- 한 번 작성하고 모든 곳에서 실행: 모바일, 웹, 데스크톱용 단일 코드베이스로 앱을 개발할 수 있습니다.\n- 빠른 개발: 플러터의 핫 리로드를 통해 변경 사항을 즉시 확인할 수 있습니다.\n- 미래를 대비: 웹어셈블리가 지원되어 계속 사용됨으로써 앞으로 뭐가 될지에 대비할 수 있습니다.\n\n시작하기\n\n<div class=\"content-ad\"></div>\n\n시작해볼 준비가 되셨나요? 아래에 간단한 개요가 있어요:\n\n- Flutter 설치: 컴퓨터에 최신 버전이 설치되어 있는지 확인해보세요.\n- 프로젝트 생성: Flutter 명령줄 도구를 사용하여 새 프로젝트를 시작하세요.\n- WebAssembly 구성: 구성 파일에서 WebAssembly을 타겟팅하도록 프로젝트를 설정하세요.\n- 빌드 및 배포: 웹용으로 프로젝트를 빌드하고 웹 서버에 배포하세요.\n\n함께 무언가를 만들어 봐요!\n\n버튼을 누른 횟수를 계속 추적하는 간단한 카운터 앱을 상상해보세요. 이것이 Flutter와 WebAssembly로 만들어진 앱이 보일 것입니다:\n\n<div class=\"content-ad\"></div>\n\n- 새 프로젝트 만들기: Flutter CLI를 사용하여 새 프로젝트를 만듭니다.\n- 코드 작성: 코드는 카운터 변수를 만들고 탭할 때 카운터가 증가하는 버튼을 만드는 과정을 포함할 것입니다.\n- 빌드 및 배포: 위 단계를 따라 앱을 웹에 빌드하고 배포합니다.\n\n미래는 빠릅니다\n\n플러터와 WebAssembly는 웹 개발을 변화시키는 혁신적인 기술입니다. 이러한 기술이 발전함에 따라 더 빠르고 강력한 웹 앱을 기대할 수 있습니다. 그래서 무엇을 기다리고 있나요? 지금 플러터와 WebAssembly로 빠른 웹 앱을 만들기 시작해 보세요!\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/0*DoLvv_b5xizTNwA2.gif\" />","ogImage":{"url":"/assets/img/2024-06-21-FlutterWebNewFeatureGameChanger_0.png"},"coverImage":"/assets/img/2024-06-21-FlutterWebNewFeatureGameChanger_0.png","tag":["Tech"],"readingTime":2},{"title":"Flutter에서 InheritedWidget 사용하기 간단한 카운터 예제","description":"","date":"2024-06-21 21:03","slug":"2024-06-21-UsingInheritedWidgetinFlutterASimpleCounterExample","content":"\n\n\n![사진](/assets/img/2024-06-21-UsingInheritedWidgetinFlutterASimpleCounterExample_0.png)\n\n플러터에서 상태를 관리하는 것은 어렵지만, 특히 여러 위젯 간에 데이터를 공유해야 할 때 더 어려울 수 있습니다. InheritedWidget은 이 문제를 해결하는 데 도움이 되는 플러터의 강력한 기능으로, 위젯이 공유된 데이터에 효율적으로 액세스할 수 있도록 합니다. 이 글에서는 간단한 카운터 예제와 함께 InheritedWidget을 어떻게 사용하는지 살펴보겠습니다.\n\n단계 1: Inherited Widget 생성\n\n먼저, AppState라는 InheritedWidget을 만들겠습니다. 이 위젯은 공유 상태(이 경우 카운터)를 보유하고 이를 하위 항목에 제공할 것입니다.\n\n\n<div class=\"content-ad\"></div>\n\n\n```js\nimport 'package:flutter/material.dart';\n\nclass AppState extends InheritedWidget {\n  final int counter;\n  final Widget child;\n\n  AppState({\n    required this.counter,\n    required this.child,\n  }) : super(child: child);\n\n  static AppState? of(BuildContext context) {\n    return context.dependOnInheritedWidgetOfExactType<AppState>();\n  }\n\n  @override\n  bool updateShouldNotify(AppState oldWidget) {\n    return oldWidget.counter != counter;\n  }\n}\n```\n\nAppState 클래스에서:\n\n- counter와 child를 초기화하는 생성자를 정의합니다.\n- of 메서드는 하위 위젯이 AppState에 액세스할 수 있도록 합니다.\n- updateShouldNotify 메서드는 하위 항목에 변경 사항을 알리는 시점을 결정합니다.\n\n단계 2: State를 관리하는 StatefulWidget 생성\n\n\n<div class=\"content-ad\"></div>\n\n다음으로 상태를 관리하는 StatefulWidget 인 MyApp을 만들겠습니다. 이 위젯은 상태를 업데이트하고 필요할 때 다시 빌드를 트리거할 것입니다.\n\n```js\nclass MyApp extends StatefulWidget {\n  @override\n  _MyAppState createState() => _MyAppState();\n}\n\nclass _MyAppState extends State<MyApp> {\n  int _counter = 0;\n\n  void _incrementCounter() {\n    setState(() {\n      _counter++;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return AppState(\n      counter: _counter,\n      child: MaterialApp(\n        home: Scaffold(\n          appBar: AppBar(\n            title: Text('Inherited Widget demo'),\n          ),\n          body: CounterDisplay(),\n          floatingActionButton: FloatingActionButton(\n            onPressed: _incrementCounter,\n            child: Icon(Icons.add),\n          ),\n        ),\n      ),\n    );\n  }\n}\n```\n\n단계 3: Inherited Widget을 사용하는 위젯 생성\n\n마지막으로, 우리는 InheritedWidget을 사용하여 카운터 값을 액세스하고 표시하는 CounterDisplay라는 StatelessWidget을 만들 것입니다.\n\n<div class=\"content-ad\"></div>\n\n```dart\nclass CounterDisplay extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    final appState = AppState.of(context);\n\n    return Center(\n      child: Text(\n        'Counter: ${appState?.counter}',\n        style: TextStyle(fontSize: 22),\n      ),\n    );\n  }\n}\n```\n\nCounterDisplay 클래스에서:\n\n- AppState를 액세스하고 카운터 값을 검색하려면 of 메서드를 사용합니다.\n- Text 위젯에 카운터 값을 표시합니다.\n\n이 코드를 실행해 봅시다.\n\n\n<div class=\"content-ad\"></div>\n\n앱을 실행하려면 MyApp을 인수로 사용하여 runApp 함수를 호출하겠습니다.\n\n```js\nvoid main() => runApp(MyApp());\n```","ogImage":{"url":"/assets/img/2024-06-21-UsingInheritedWidgetinFlutterASimpleCounterExample_0.png"},"coverImage":"/assets/img/2024-06-21-UsingInheritedWidgetinFlutterASimpleCounterExample_0.png","tag":["Tech"],"readingTime":3},{"title":"Flutter  Firebase로 푸시 알림 구현하는 완벽 가이드","description":"","date":"2024-06-21 21:01","slug":"2024-06-21-FlutterFirebasePushNotificationsCompleteGuide","content":"\n\n<img src=\"/assets/img/2024-06-21-FlutterFirebasePushNotificationsCompleteGuide_0.png\" />\n\n# 푸시 알림이란 무엇인가요?\n\n푸시 알림은 모바일 앱이나 웹사이트에서 기기로 보내는 메시지로, 기기가 활발하게 사용되지 않는 경우에도 전송됩니다. 일반적으로 사용자에게 새로운 콘텐츠나 기능을 알리거나 관심이 있을 수 있는 내용을 상기시키기 위해 사용됩니다.\n\n# 모바일 앱 개발에서 푸시 알림의 장점은 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n- 사용자 참여 향상: 푸시 알림을 통해 사용자가 앱에 계속해서 참여하도록 유도할 수 있습니다. 사용자가 앱을 활발하게 사용하지 않을 때에도 이를 통해 전반적인 앱 사용량과 인기를 증가시킬 수 있습니다.\n- 유지율 증가: 푸시 알림을 통해 사용자에게 앱을 상기시킬 수 있어, 유지율을 높이고 앱을 제거하는 사용자 수를 줄일 수 있습니다.\n- 타겟팅 메시징: 푸시 알림은 사용자의 관심사나 행동을 기반으로 특정 사용자나 그룹을 대상으로 할 수 있습니다. 이를 통해 앱 개발자는 사용자에게 개인화되고 관련성 높은 메시지를 보낼 수 있어 알림의 효과를 높일 수 있습니다.\n- 수익 증대: 푸시 알림을 통해 인앱 구매나 기타 수익화 기회를 홍보할 수 있어, 앱 개발자의 수익을 향상시킬 수 있습니다.\n- 고객 서비스 향상: 푸시 알림을 통해 업데이트나 경고와 같은 시기적절하고 관련성 있는 정보를 제공할 수 있습니다. 이를 통해 전반적인 고객 경험과 앱에 대한 만족도를 향상시킬 수 있습니다.\n\n# Firebase Cloud Messaging (FCM)이란?\n\n![이미지](/assets/img/2024-06-21-FlutterFirebasePushNotificationsCompleteGuide_1.png)\n\nFirebase에 따르면, FCM은 무료로 메시지를 신뢰할 수 있게 전송할 수 있는 크로스 플랫폼 메시징 솔루션이라고 합니다.\n\n<div class=\"content-ad\"></div>\n\nFCM은 Android, iOS 및 웹 사용자에게 메시지와 알림을 보낼 수 있는 크로스 플랫폼 메시징 솔루션입니다. 구글은 FCM을 Firebase 스위트의 일부로 제공하여 모바일 앱 개발을 위한 도구 및 서비스를 제공합니다.\n\nFCM을 사용하면 사용자 관심사, 앱 사용 방식 및 위치에 따라 특정 기기 또는 기기 그룹에 메시지를 보낼 수 있습니다. 알림, 푸시 알림 및 데이터 페이로드를 포함한 다양한 유형의 메시지를 보낼 수 있습니다. FCM은 또한 메시지 예약, 기기 그룹 관리 및 분석과 같은 기능을 제공합니다.\n\nFCM은 기존 앱 인프라와 쉽게 통합되고 사용하기 쉽게 설계되었습니다. 간단한 API를 사용하며 Firebase Analytics와 같은 다른 Firebase 서비스와 통합하여 모바일 앱 개발을 위한 포괄적인 도구 세트를 제공합니다.\n\n# 플러터 앱에서 Firebase FCM을 통해 푸시 알림을 수신하는 방법 — 구현\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-21-FlutterFirebasePushNotificationsCompleteGuide_2.png)\n\n플러터와 FCM에서 3가지 디바이스 상태\n\n- Foreground(전경): 어플리케이션이 열려 있고 보여지며 사용 중일 때입니다.\n- Background(최소화): 사용자가 장치에서 \"홈\" 버튼을 누르거나 앱 전환기를 통해 다른 앱으로 전환하거나 다른 탭(웹)에서 앱을 열었을 때 보통 발생합니다.\n- Terminated(종료됨): 장치가 잠겨 있거나 어플리케이션이 실행되지 않을 때입니다. 사용자는 장치의 앱 전환기 UI를 통해 앱을 닫거나 탭(웹)을 닫아 어플리케이션을 종료할 수 있습니다.\n\n이 프로세스가 어떻게 작동하는지 보려면 이 동영상을 시청해보세요.\n\n\n<div class=\"content-ad\"></div>\n\n구현 단계\n\n- CMD에서\n\n- Node.js를 다운로드 및 설치하십시오. https://nodejs.org/en/\n- firebase 도구 설치: npm install -g firebase-tools (CMD)\n- \"firebase login\"을 실행하고 Google 계정을 선택하십시오 (CMD)\n\n2. 플러터 프로젝트 터미널에서\n\n<div class=\"content-ad\"></div>\n\n- 그런 다음 플러터 프로젝트를 열고 터미널에서 다음 명령을 실행하세요\n- dart pub global activate flutterfire_cli\n- flutterfire configure (만약 이 명령이 \"flutterfire가 인식되지 않습니다.\"와 같은 오류를 발생시킨다면, 시스템 환경 변수에 \"C:\\Users\\*사용자명*\\AppData\\Local\\Pub\\Cache\\bin\"을 새 항목으로 추가해야 합니다. 이제 오류 없이 명령을 실행할 수 있어야 합니다.) \n\n3. Firebase 콘솔에서\n\n- 새 Firebase 프로젝트를 생성하고 Firebase FCM(메시징/클라우드 메시징으로도 알려짐)를 활성화하세요.\n\n4. 그런 다음 플러터 프로젝트의 main.dart에 다음 종속성을 추가하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\n// 의존성\nimport 'package:firebase_core/firebase_core.dart';\nimport '/firebase_options.dart'; // 이 파일은 \"flutterfire config\" 명령어로 생성됩니다.\nimport 'package:firebase_messaging/firebase_messaging.dart';\n```\n\n5. 이제 main.dart에 다음 라인을 추가하여 Firebase Messaging을 초기화합니다.\n\n```js\n// 초기화\nWidgetsFlutterBinding.ensureInitialized();\n\nawait Firebase.initializeApp(\n  options: DefaultFirebaseOptions.currentPlatform,\n);\n\nFirebaseMessaging messaging = FirebaseMessaging.instance;\n\nNotificationSettings settings = await messaging.requestPermission(\n  alert: true,\n  announcement: false,\n  badge: true,\n  carPlay: false,\n  criticalAlert: false,\n  provisional: false,\n  sound: true,\n);\n\nprint('사용자가 허용한 권한: ${settings.authorizationStatus}');\n```\n\n6. 이제 main.dart에 다음 라인을 추가하여 \"백그라운드 메시지\"를 받습니다.\n\n\n<div class=\"content-ad\"></div>\n\n```dart\n// 백그라운드 메시지 수신\nFuture<void> _firebaseMessagingBackgroundHandler(RemoteMessage message) async {\n  await Firebase.initializeApp();\n  print(\"백그라운드 메시지 처리 중: ${message.messageId}\");\n}\n```\n\n```dart\n// 백그라운드 메시지 수신 대기\nWidgetsFlutterBinding.ensureInitialized();\nFirebaseMessaging.onBackgroundMessage(_firebaseMessagingBackgroundHandler);\n```\n\n7. 그런 다음 main.dart에 다음 줄을 추가하여 \"전경 메시지\"를 받습니다.\n\n```dart\n// 전경 메시지 수신\nFirebaseMessaging.onMessage.listen((RemoteMessage message) {\n  print('전경에서 메시지를 받았어요!');\n  print('메시지 데이터: ${message.data}');\n\n  if (message.notification != null) {\n    print('메시지에 알림도 포함되어 있어요: ${message.notification}');\n  }\n});\n```\n\n<div class=\"content-ad\"></div>\n\n# 중요\n\n- (공통):\n- 클라우드 메시징 패키지는 애플리케이션을 Firebase Cloud Messaging (FCM) 서비스에 연결합니다.\n- 메시지 페이로드를 무료로 디바이스로 직접 보낼 수 있습니다.\n- 각 메시지 페이로드는 최대 4KB까지 가능합니다.\n- (iOS 전용):\n- iOS 플랫폼에서 Firebase 메시징을 테스트하려면 실제 디바이스가 필요합니다.\n\n# 받을 수 있는 3가지 메시지 유형\n\n메시지 페이로드를 세 가지 유형 중 하나로 볼 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n- 알림 전용 메시지: 페이로드에는 사용자에게 표시되는 알림 속성이 포함되어 있습니다.\n- 데이터 전용 메시지: \"silent message\"로도 알려진 이 페이로드에는 데이터 속성 내에 사용자가 필요에 따라 사용할 수 있는 사용자 정의 키/값 쌍이 포함되어 있습니다. 이러한 메시지는 \"우선 순위가 낮음\"으로 간주됩니다(나중에 더 자세히 설명합니다).\n- 알림 및 데이터 메시지: 알림 및 데이터 속성을 모두 포함하는 페이로드입니다.\n\n# 상호 작용 처리\n\n알림은 사용자에게 보이는 신호이므로 사용자가 해당 신호에 상호 작용하는 것이 일반적입니다(눌러서). Android 및 iOS 모두의 기본 동작은 애플리케이션을 열도록 하는 것입니다. 애플리케이션이 종료된 경우 시작되고, 백그라운드 상태인 경우 화면으로 가져옵니다.\n\n알림의 내용에 따라 애플리케이션이 열릴 때 사용자 상호 작용을 처리하고 싶을 수 있습니다. 예를 들어, 알림을 통해 새로운 채팅 메시지가 전송되고 사용자가 그것을 누른 경우, 애플리케이션이 열릴 때 특정 대화를 열도록 하고 싶을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nfirebase-messaging 패키지는 이 상호작용을 다루는 두 가지 방법을 제공합니다:\n\n- getInitialMessage(): 애플리케이션이 종료된 상태에서 열리면 RemoteMessage가 포함된 Future가 반환됩니다. RemoteMessage를 사용하면 해당 메시지는 제거됩니다.\n- onMessageOpenedApp: 백그라운드 상태에서 애플리케이션이 열릴 때 RemoteMessage를 게시하는 Stream입니다.\n\n사용자에 대한 원활한 사용자 경험을 위해 두 시나리오를 모두 처리하는 것이 좋습니다. 아래의 코드 예시는 이를 어떻게 달성할 수 있는지 보여줍니다:\n\n```js\nclass Application extends StatefulWidget {\n  @override\n  State<StatefulWidget> createState() => _Application();\n}\n\nclass _Application extends State<Application> {\n  // 모든 메시지에 'type' 키를 포함하는 데이터 필드가 있다고 가정합니다.\n  Future<void> setupInteractedMessage() async {\n    // 애플리케이션이 종료된 상태에서 열린 이유가 된 메시지를 가져옵니다.\n    RemoteMessage? initialMessage =\n        await FirebaseMessaging.instance.getInitialMessage();\n\n    // 메시지가 'type'이 'chat'인 데이터 속성도 포함하고 있다면\n    // 채팅 화면으로 이동합니다.\n    if (initialMessage != null) {\n      _handleMessage(initialMessage);\n    }\n\n    // 애플리케이션이 백그라운드에 있을 때 상호작용을 다루기 위해 \n    // Stream 리스너를 통해 처리합니다.\n    FirebaseMessaging.onMessageOpenedApp.listen(_handleMessage);\n  }\n  \n  void _handleMessage(RemoteMessage message) {\n    if (message.data['type'] == 'chat') {\n      Navigator.pushNamed(context, '/chat', \n        arguments: ChatArguments(message),\n      );\n    }\n  }\n\n  @override\n  void initState() {\n    super.initState();\n\n    // initState()이 비동기일 수 없기 때문에 상호작용하는 메시지를 다루는 \n    // 코드를 비동기 함수에서 실행합니다.\n    setupInteractedMessage();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Text(\"...\");\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n# 특정 화면으로 이동하는 방법\n\n```js\nvoid _handleMessage(RemoteMessage message) {\n    // 메시지 객체 내용 확인\n    RemoteNotification? notification = message.notification;\n    //AndroidNotification? android = message.notification?.android;\n\n    print(\"notification: $notification\");\n    print(\"message data: ${message.data}\");\n\n    Get.toNamed(Routes.getNotificationDetailScreen(), arguments: [\n      {\"message\": message}\n    ]);\n}\n\n// 상호 작용 처리\nFirebaseMessaging.onMessageOpenedApp.listen(_handleMessage);\n```\n\n![이미지 1](/assets/img/2024-06-21-FlutterFirebasePushNotificationsCompleteGuide_3.png)\n\n![이미지 2](/assets/img/2024-06-21-FlutterFirebasePushNotificationsCompleteGuide_4.png)\n\n<div class=\"content-ad\"></div>\n\n## 참고 자료:\n\n- https://www.youtube.com/watch?v=3lsP1jZNqjE\n- https://stackoverflow.com/questions/70320263/the-term-flutterfire-is-not-recognized-as-the-name-of-a-cmdlet-function-scri\n- https://firebase.flutter.dev/docs/cli/\n- https://firebase.google.com/docs/cli#install-cli-windows\n- https://firebase.flutter.dev/docs/overview/\n- https://medium.com/@rysesoft/flutter-push-notification-with-fcm-6e7a95f5abb6\n- https://firebase.flutter.dev/docs/messaging/apple-integration/\n- https://www.youtube.com/watch?v=54vgoPgB8xE\n- https://pub.dev/packages/flutterfire_cli/install\n- https://pub.dev/packages/firebase_core/install\n- https://www.youtube.com/watch?v=2tjuUwNx6qk\n- https://firebase.flutter.dev/docs/messaging/usage/\n- https://medium.com/firebase-developers/flutter-fcm-how-to-navigate-to-a-particular-screen-after-tapping-on-push-notification-8cb5d5111ee6\n- https://pub.dev/packages/flutter_local_notifications\n- https://firebase.flutter.dev/docs/messaging/usage/\n- https://pub.dev/documentation/firebase_messaging_platform_interface/latest/firebase_messaging_platform_interface/RemoteMessage-class.html\n- https://firebase.google.com/docs/cloud-messaging/flutter/receive","ogImage":{"url":"/assets/img/2024-06-21-FlutterFirebasePushNotificationsCompleteGuide_0.png"},"coverImage":"/assets/img/2024-06-21-FlutterFirebasePushNotificationsCompleteGuide_0.png","tag":["Tech"],"readingTime":9},{"title":"Flutter는 2024년에도 살아남을까 크로스플랫폼 개발의 미래","description":"","date":"2024-06-21 20:59","slug":"2024-06-21-IsFlutterDyingin2024FutureofCross-PlatformDevelopment","content":"\n\n<img src=\"/assets/img/2024-06-21-IsFlutterDyingin2024FutureofCross-PlatformDevelopment_0.png\" />\n\n2024년에 플러터가 관련성을 잃고 있는 걸까요? 코틀린 멀티플랫폼, 리액트 네이티브, 퀘이사르 프레임워크, 네이티브스크립트와 비교해보세요.\n\n# 소개\n\n2017년 출시 이후, 구글의 오픈소스 UI 소프트웨어 개발 툴킷인 플러터는 크로스 플랫폼 개발 분야에서 주목받는 역할을 해왔습니다. 개발자들이 단일 코드베이스로 모바일, 웹 및 데스크톱용으로 네이티브 애플리케이션을 만들 수 있게 합니다. 그러나 크로스 플랫폼 개발 프레임워크의 변화하는 풍경과 증가하는 경쟁으로 인해, 2024년에 플러터의 관련성과 지속 가능성에 대한 의문이 제기됩니다. 이 기사는 플러터의 상태, 코틀린 멀티플랫폼, 리액트 네이티브, 퀘이사르 프레임워크, 네이티브스크립트와 구글의 플러터에 대한 미래로드맵에 대해 탐구합니다.\n\n<div class=\"content-ad\"></div>\n\n# 플러터의 부상\n\n플러터는 고성능 렌더링 엔진, 풍부한 사전 디자인 위젯 세트 및 튼튼한 개발자 도구로 인해 빠르게 주목을 받았습니다. iOS와 Android에서 네이티브와 유사한 성능과 외관을 제공하는 능력으로, 개발자들 사이에서 인기 있는 선택지로 자리매김하였습니다. 알리바바, 구글 애즈, BMW와 같은 주요 기업들이 채택함으로써 플러터의 잠재력과 다재다능성을 강조하였습니다.\n\n# 현재의 플러터 상태\n\n2024년 현재, 플러터는 크로스 플랫폼 개발 시장에서 중요한 역할을 하고 있습니다. 그러나 환경은 매우 동적이며, 중요한 것은 지속적인 혁신과 커뮤니티 지원으로 영향력을 유지하는 것입니다. 플러터의 현재 상태를 살펴보기 위해서는 GitHub에서의 활동을 살펴봄으로써 커뮤니티 참여와 진행 중인 개발의 주요 지표를 파악할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## GitHub Metrics\n\n- Stars: 2024년 중반 기준으로 Flutter는 GitHub에서 15만 개 이상의 스타를 획득했습니다. 이 지표는 해당 프레임워크가 개발자들 사이에서 널리 사용되고 인기를 얻고 있다는 것을 보여줍니다.\n- Commits: Flutter는 지난 몇 년 동안 수천 건의 기여를 받으며 꾸준한 커밋을 계속하고 있습니다. 이는 활발한 개발과 지속적인 향상을 나타냅니다.\n- Issues 및 Pull Requests: 많은 수의 이슈 및 풀 리퀘스트는 활성화된 커뮤니티와 프레임워크를 개선하려는 지속적인 노력을 보여줍니다.\n\n# 2024년의 경쟁\n\nFlutter는 강세를 유지하고 있지만, Kotlin Multiplatform, React Native, Quasar Framework, 그리고 NativeScript와 같은 여러 프레임워크도 널리 인기를 얻고 있으며 크로스 플랫폼 개발에 매력적인 대안을 제공하고 있습니다. 함께 상태와 영향을 살펴보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n## Kotlin Multiplatform\n\nKotlin Multiplatform (KMP)은 교차 플랫폼 개발 환경에서 부상 중인 플레이어입니다. JetBrains에서 개발한 KMP는 안드로이드, iOS 및 웹을 포함한 여러 플랫폼에 대한 공통 코드 작성을 허용합니다. Kotlin은 Java와의 상호 운용성 및 간결한 구문으로 개발자들 사이에서 인기가 높습니다.\n\n- GitHub Stars: Kotlin Multiplatform은 약 10k개의 스타를 모아 사람들의 인기를 반영하고 있습니다.\n- Commits: 이 프로젝트는 꾸준한 커밋과 적극적인 기여를 보이며, 강력한 커뮤니티 지원과 지속적인 개발을 시사합니다.\n- 채택: Netflix와 Cash App과 같은 회사들이 애플리케이션의 일부에 KMP를 도입함으로써 실용성을 진열하고 있습니다.\n\n## React Native\n\n<div class=\"content-ad\"></div>\n\nReact Native은 Facebook에서 지원하는 가장 기반이 탄탄한 크로스 플랫폼 프레임워크 중 하나입니다. JavaScript와 React를 활용하여 개발자들이 모바일 애플리케이션을 만들 수 있습니다.\n\n- GitHub Stars: React Native은 GitHub에서 11만 개 이상의 스타를 받아 널리 사용되고 커뮤니티 지원을 받고 있습니다.\n- 커밋: 프로젝트는 자주 커밋되고 업데이트되어 경쟁력을 유지하고 있습니다.\n- 채택: Facebook, Instagram, Airbnb 등 주요 기업들이 React Native을 사용하며 견고성과 다재다능성을 입증하고 있습니다.\n\n## Quasar Framework\n\nQuasar Framework은 Vue.js를 사용하여 크로스 플랫폼 애플리케이션을 만들기 위한 강력한 프레임워크입니다. 데스크톱 및 모바일 애플리케이션과 PWA(Progressive Web Apps)을 지원합니다.\n\n<div class=\"content-ad\"></div>\n\n- GitHub Stars: Quasar은 약 25,000개의 스타를 모았으며, 특정한 사용자들의 관심이 있는 것을 보여줍니다.\n- 커밋: Quasar는 정기적인 커밋과 업데이트로 활발하게 개발되고 있습니다.\n- 채택: Flutter나 React Native만큼 널리 사용되지는 않지만, Quasar는 유연성과 성능에 대한 칭찬을 받으며 충실한 사용자층을 보유하고 있습니다.\n\n## NativeScript\n\nNativeScript는 JavaScript, TypeScript 또는 Angular를 사용하여 모바일 앱을 개발할 수 있는 오픈 소스 프레임워크입니다. 네이티브 API에 직접 액세스할 수 있어 네이티브 수준의 성능을 제공합니다.\n\n- GitHub Stars: NativeScript는 GitHub에서 약 21,000개의 스타를 보유하고 있습니다.\n- 커밋: 이 프레임워크는 지속적인 기여와 업데이트를 받고 있습니다.\n- 채택: SAP와 Puma와 같은 기업들이 NativeScript를 사용하며 기업급 애플리케이션을 제공할 수 있는 능력을 보여주고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 구글의 플러터 로드맵\n\n구글은 플러터의 성공에 큰 관심을 가지고 있으며, 플러터의 장기적인 성공을 결정하는 구글의 로드맵과 미래 계획은 중요합니다. 구글은 공식 블로그 포스트와 소셜 미디어를 통해 발표된 다양한 공지사항과 업데이트를 통해 플러터에 대한 헌신을 보여주고 있습니다.\n\n## 공식 공지사항\n\n- 플러터 3.0 릴리스: 2023년에 구글은 플러터 3.0을 발표했으며, 이를 통해 성능 개선, 새로운 위젯, 그리고 웹 및 데스크톱 플랫폼과의 통합 개선 사항 등이 도입되었습니다. 이 릴리스는 구글이 플러터를 진정한 멀티 플랫폼 프레임워크로 만들기 위한 헌신을 강조했습니다.\n- 퓨시아 OS 통합: 구글의 실험적 운영 체제인 퓨시아는 주요 개발 프레임워크로 플러터를 사용합니다. 이 통합은 플러터의 장기적인 지원과 투자를 시사합니다.\n- 파트너십 및 에코시스템 확장: 구글은 다양한 기업들과의 파트너십을 육성하고 플러터 생태계를 확장하고 있습니다. 이는 Firebase, 구글 클라우드, 서드파티 라이브러리와 같은 도구 및 서비스와의 협업을 포함합니다.\n\n<div class=\"content-ad\"></div>\n\n## 앞으로의 계획\n\n- 향상된 도구 및 개발자 경험: Google은 Flutter의 개발 도구인 Dart 프로그래밍 언어, DevTools 및 Visual Studio Code 및 Android Studio와의 통합을 계속 개선할 예정입니다.\n- 웹 및 데스크톱 개선: Flutter의 모바일 기능이 이미 잘 알려져 있지만, Google은 웹 및 데스크톱 성능을 향상시키는 데 중점을 두고 있습니다. 이는 웹 표준에 대한 더 나은 지원, 더 빠른 로딩 시간 및 더 많은 데스크톱 특화 기능을 포함합니다.\n- 성능 및 안정성에 초점: Flutter 앱이 모든 플랫폼에서 원활하게 실행되는 것을 보장하는 것이 우선입니다. Google은 프레임워크를 최적화하여 일관된 성능과 안정성을 제공하도록 노력하고 있습니다.\n- 커뮤니티 참여: Google은 커뮤니티 기여의 중요성을 인식합니다. 오픈 소스 기여를 지원하는 계획, 이벤트 조직, 그리고 더 나은 문서 제공을 통해 활기찬 Flutter 커뮤니티를 육성하는 데 노력하고 있습니다.\n\n# 분석과 전망\n\n## Flutter의 장점\n\n<div class=\"content-ad\"></div>\n\n- 단일 코드베이스: 플러터는 여러 플랫폼에 대해 하나의 코드베이스를 사용할 수 있는 능력이 강력한 매력으로 남아 있습니다. 이는 개발 시간과 비용을 상당히 줄입니다.\n- 성능: 네이티브에 가까운 성능을 보여주는 플러터는 복잡하고 그래픽 집중적인 애플리케이션에 특히 큰 장점을 가지고 있습니다.\n- 다양한 UI 구성요소: 사전에 디자인된 다양한 위젯 집합은 매우 사용자 정의 및 반응형 UI 디자인을 가능하게 합니다.\n\n## 도전과 경쟁\n\n- 학습 곡선: 플러터는 비교적 쉽게 배울 수 있지만, 여전히 다른 언어에 익숙한 사람들에게는 장벽이 될 수 있는 다트를 배워야 합니다.\n- 경쟁 환경: React Native와 Kotlin Multiplatform과 같은 프레임워크들은 강력한 경쟁자입니다. React Native의 자바스크립트 기반 접근방식과 Kotlin의 네이티브 상호 운용성은 매력적인 대안입니다.\n- 생태계와 커뮤니티: 플러터는 강력한 커뮤니티를 가지고 있지만, 자바스크립트(React Native)와 자바/코틀린(Kotlin Multiplatform)의 거대한 생태계와 경쟁합니다.\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\n2024년에 Flutter가 사라질까요? 답은 틀림없이 '아니오'입니다. 경쟁적인 환경에도 불구하고 Google의 강력한 지원과 활기찬 커뮤니티에 의해 뒷받침되면서 Flutter는 지속적으로 성장하고 있습니다. 이 프레임워크의 지속적인 발전과 성능, 도구, 및 멀티 플랫폼 능력에 대한 전략적인 향상을 통해, 향후 몇 년 동안의 발전과 성장을 보장합니다.\n\nFlutter는 모바일, 웹, 그리고 데스크탑 애플리케이션을 위한 단일 코드베이스 솔루션을 제공할 수 있는 능력으로 매우 중요합니다. 그러나 언제나 선도하려면 Kotlin Multiplatform, React Native, Quasar Framework, 그리고 NativeScript와 같은 경쟁 업체들이 제기하는 도전에 대처해야 합니다. Google은 지속적으로 혁신하고 프레임워크를 향상시킴으로써, Flutter를 2024년 이후로도 교차 플랫폼 개발의 최고 선택으로 확고히 할 것으로 보입니다.","ogImage":{"url":"/assets/img/2024-06-21-IsFlutterDyingin2024FutureofCross-PlatformDevelopment_0.png"},"coverImage":"/assets/img/2024-06-21-IsFlutterDyingin2024FutureofCross-PlatformDevelopment_0.png","tag":["Tech"],"readingTime":6},{"title":"상속 위젯에 대한 심층 분석 Flutter 개발자가 알아야 할 모든 것","description":"","date":"2024-06-21 20:56","slug":"2024-06-21-InheritedWidgetsIn-depth","content":"\n\n![image](/assets/img/2024-06-21-InheritedWidgetsIn-depth_0.png)\n\n안녕하세요 여러분! 👋\n\n여러분이 Theme.of(context) 또는 MediaQuery.of(context)를 작성할 때 뒷면에서 무슨 일이 일어나는지 궁금했던 적이 있나요?🤔 그렇지 않다면, 이 글에서는 InheritedWidgets에 대해 모든 것을 배우고 재미난 사실 몇 가지를 알게될 거예요 😉\n\n이 블로그는 초심자와 경험 많은 개발자 모두를 위해 작성되었으므로 모두가 이로부터 혜택을 받을 수 있습니다. 그러니 더 이상 말이 필요 없죠, 시작해봅시다 😄\n\n<div class=\"content-ad\"></div>\n\n## 목차:\n\n- 상속 위젯의 필요성\n- 상속 위젯의 구현\n- 상속 위젯이란\n- 따를 규칙 몇 가지\n- 데모\n- 결론\n\n# 상속 위젯의 필요성\n\n우리는 모두 플러터에서 모든 것이 위젯이라고 들어본 적이 있습니다. 이 문장은 사실이 아니지만, 위젯은 플러터 앱을 개발할 때 중요한 역할을 합니다.\n\n<div class=\"content-ad\"></div>\n\n플러터(Flutter)에서는 StateLessWidget, StatefulWidget, RenderObjectWidget 등 다양한 유형의 위젯이 있어요. 하지만 대부분의 경우에는 StatelessWidget과 StatefulWidgets를 주로 사용해요. 그럼 InheritedWidget은 어디에 있을까요? 🤔\n\nInheritedWidget의 필요성을 이해하기 위해 이 위젯 트리의 예제를 살펴보겠어요:\n\n![이미지](/assets/img/2024-06-21-InheritedWidgetsIn-depth_1.png)\n\n이제 함께 살펴봐요:\n\n<div class=\"content-ad\"></div>\n\n- CustomText 위젯에서 userName 속성에 액세스하고 싶어요. 그러나 이 속성에 액세스하기 위해서는 userName 속성을 모든 위젯의 생성자 안에 전달해야 해요 🏗️\n- 여기서 보면, CustomText로 들어가기 위해 단지 3개의 위젯에서 userName을 전달해야 했어요. 하지만, 이를 위해 많은 표준 코드를 작성해야 했죠. 또한, 모든 위젯에 의존성을 만들어야 했는데, 이는 좋지 않은 방법이에요.\n\n따라서, 모든 위젯의 생성자에 데이터를 전달하는 방법보다 꼼꼼한 💪 해결책이 필요했어요 🏗️\n\n알아챈대로, InheritedWidget이 이 문제를 해결하는 방법이에요 😉 그렇다면, InheritedWidget이 이 문제를 해결하는 데 어떻게 도움이 되는 걸까요? 이 질문에 대한 대답을 드리기 위해, 아래 그래프📈를 보고 제대로 이해해보세요.\n\n<img src=\"/assets/img/2024-06-21-InheritedWidgetsIn-depth_2.png\" />\n\n<div class=\"content-ad\"></div>\n\n호출할 수 있는 데이터에 대해 알고 싶을 때, 상위 레벨에 InheritedWidget을 넣을 수 있다는 점을 확인할 수 있어요. 멋있죠?😃\n\n이제 코드에서 이를 어떻게 구현할 수 있는지 살펴보겠어요.\n\n# Inherited Widget의 구현\n\n- InheritedWidget을 생성하려면 클래스를 InheritedWidget으로 확장해야 합니다.\n- 그런 다음 updateShouldNotify 메서드를 구현해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n한 예를 통해 이 개념을 익혀봅시다:\n\n여기에는 이야기할 몇 가지 새로운 내용이 있습니다:\n\n- 생성자에서 자식 위젯을 가져오고 updateShouldNotify 메서드: 이 메서드는 InheritedWidget 내부의 데이터가 변경될 때마다 호출됩니다. 이 메서드가 true를 반환하면, 이 InheritedWidget에 의존하는 자식 위젯들이 다시 빌드될 것을 의미합니다. 이 메서드에서는 이전 InheritedWidget을 가져와서 InheritedWidget 내부의 데이터가 변경되었는지 확인할 수 있습니다. 너무 복잡해 보이나요? 걱정하지 마세요. 이에 대해 깊이 있는 이야기를 나중에 할 거에요 😉\n- static UserDataInheritedWidget? of(BuildContext context): InheritedWidget로부터 데이터를 가져오고 싶을 때는 이 메서드를 호출하여 InheritedWidget 내부의 데이터를 가져올 수 있습니다.\n\n이제 Theme.of(context)나 MediaQuery.of(context) 같은 코드를 작성할 때마다 실제로는 해당 InheritedWidget로부터 데이터를 가져오고 있었음을 알게 되었죠.\n\n<div class=\"content-ad\"></div>\n\n이제 자식 위젯에서 데이터를 가져오는 방법을 살펴보겠습니다. \n\nInheritedWidget의 참조를 가져오려면 StatelessWidget의 경우 build 메서드나 StatefulWidget의 경우 didChangeDependencies 메서드에 다음과 같이 이 문장을 작성할 수 있습니다:\n\n![image](/assets/img/2024-06-21-InheritedWidgetsIn-depth_3.png)\n\n![image](/assets/img/2024-06-21-InheritedWidgetsIn-depth_4.png)\n\n<div class=\"content-ad\"></div>\n\n이제 InheritedWidget을 사용하는 방법을 알게 되었으니, 이에 대해 더 깊이 파보겠습니다🤖.\n\n# Inherited Widget 깊이 알아보기\n\n다음 라인을 살펴보세요: UserDataInheritedWidget.of(context)?.userName\n\n- 이 라인에서는 Widget 트리의 맨 위에 위치한 UserDataInheritedWidget의 참조를 얻고 있습니다.\n- 따라서 .of(context)를 작성할 때마다, 당신의 위젯(우리의 경우 DemoWidget)이 UserDataInheritedWidget의 청취자(listener👂)로 등록됩니다.\n- 따라서 UserDataInheritedWidget 내부의 값이 바뀔 때마다, 이에 종속된 위젯들이 다시 빌드됩니다. 이에 대한 예시는 마지막에 볼 것입니다.\n\n<div class=\"content-ad\"></div>\n\n## InheritedWidget에서 데이터에 액세스 할 때 지켜야 할 몇 가지 규칙:\n\n- StatefulWidget의 initState 내에서 .of(context) 메서드를 호출하는 것을 피해야 합니다. InheritedWidget의 구성이 변경되어도 위젯이 다시 빌드되지 않기 때문에 ❌\n- build, didChangeDependencies 또는 didUpdateWidget 내에서 .of(context) 메서드를 호출할 수 있습니다 ✅\n\n다음은 .of(context) 메서드를 호출할 수 있는 예시입니다:\n\n![이미지](/assets/img/2024-06-21-InheritedWidgetsIn-depth_5.png)\n\n<div class=\"content-ad\"></div>\n\n알겠어요. 이 라이프사이클 메서드 안에서 .of(context) 메서드를 호출할 수 있지만, 어떻게 작동하는지 궁금하시군요? 🤔\n\n이에 대한 답변을 하기 위해서, 우선 didChangeDependencies에서 어떤 종속성을 다루고 있는지 알아보겠습니다. 🤔💭\n\n답은 이 종속성이 dependOnInheritWidgetOfExactType 함수에 의해 생성된다는 점입니다. 이 함수는 InheritedWidget의 static of(BuildContext context) 메서드를 만들 때 구현되었습니다.\n\n그러므로 InheritedWidget 내부의 데이터💽가 변경될 때마다 didChangeDependencies 메서드가 호출될 것입니다.\n\n<div class=\"content-ad\"></div>\n\nbuild 메소드 내부에서도 .of(context)을 호출할 수 있어요. 성능 차이가 크지 않기 때문에 didChangeDependencies 내부에 이 메소드를 사용하는 것이 좋아요. 더 큰 앱에는 많은 위젯이 있기 때문에요.\n\n이제 InheritedWidgets에 대해 깊게 알았으니, 의존하는 위젯을 다시 빌드할 수 있도록 InheritedWidget의 구성을 변경하는 방법을 살펴봐요.\n\n# 데모:\n\n- 먼저, InheritedWidget을 확장하는 ColorWidget을 만들어봅시다:\n\n<div class=\"content-ad\"></div>\n\n- 여기서는 위젯의 생성자 안에 color와 함께 onColorChanged 메서드를 전달하고 있습니다.\n- updateShouldNotify에서는 색이 변경되었는지 확인하고 있습니다. 그리고 변경되었을 경우, true를 반환하여 이 InheritedWidget에 의존하는 위젯들이 다시 빌드되도록 합니다.\n\n이제 이 InheritedWidget을 위젯 트리에 삽입하는 StatefulWidget의 코드를 살펴보겠습니다:\n\n- 이 StatefulWidget에서는 색을 설정하는 ColorWidget을 삽입하는데, 이는 InheritedWidget입니다. ElevetedButton을 누르면 색을 녹색으로 설정합니다.\n- 상태 객체의 color 변수가 InheritedWidget에 전달됩니다.\n\n이제 Column 내에 있는 ColorCardWidget의 코드를 살펴보겠습니다:\n\n<div class=\"content-ad\"></div>\n\n여기서 StatelessWidget을 보면 InheritedWidget에서 색상🎨을 받아오고 있습니다. 따라서 색상의 값이 변경될 때마다 ColorCardWidget이 다시 빌드됩니다.\n\n이제 코드를 실행하면 다음과 같은 출력을 볼 수 있어요:\n\n![Image](https://miro.medium.com/v2/resize:fit:748/0*glpgY0XHAbtBZWPz.gif)\n\n그러므로 .of(context) 메서드를 작성함으로써 해당 위젯을 InheritedWidget의 리스너로 등록하여 InheritedWidget 내부 데이터가 변경될 때 자체를 다시 빌드할 수 있다는 것을 확인할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n위 예제를 직접 시도하고 싶다면 제 GitHub 저장소를 확인해보세요:\n\n이 글을 통해 상속 위젯에 대해 어떤 통찰을 얻을 수 있었기를 바랍니다. 이 부분 중 이해하지 못한 부분이 있다면 의견란이나 제 LinkedIn 및 Twitter에서 질문해주세요.\n\n## 계속해서 박수를 보내주세요 👏 (박수를 50번 치는 것으로 감사의 표시를 할 수 있습니다)\n\n## 참고문헌:","ogImage":{"url":"/assets/img/2024-06-21-InheritedWidgetsIn-depth_0.png"},"coverImage":"/assets/img/2024-06-21-InheritedWidgetsIn-depth_0.png","tag":["Tech"],"readingTime":6},{"title":"다양한 Firebase 프로젝트로 Android 및 iOS용 Flutter 빌드 플래버 구성 방법","description":"","date":"2024-06-21 20:53","slug":"2024-06-21-BuildflavorsinFlutterAndroidandiOSwithdifferentFirebaseprojectsperflavor","content":"\n\n\n[업데이트 2020년 3월 7일]\n- iOS와 Android에서 다른 플레이버용 앱 아이콘 설명 추가함\n\n\n다양한 시도와 오류 끝에, 특히 iOS에서 플레이버가 작동하도록 하기 위해 이 기사를 쓰기로 결정했습니다. 그래서 곧 바로 플러터에서 플레이버 빌드에 대해 자세히 알아보겠습니다.\n\n## 플레이버가 필요한 이유\n\n플레이버는 일반적으로 앱을 dev 및 prod와 같은 다른 환경으로 빌드하는 데 사용됩니다.\n예를 들어,\n- 앱의 개발 버전은 dev.api.myapp.com에 위치한 API 호스트를 가리키도록 할 수 있음\n- 그리고 앱의 프로덕션 버전은 api.myapp.com을 가리키도록 할 수 있음\n\n\n<div class=\"content-ad\"></div>\n\n이 값들을 변수로 하드 코딩하고 각 환경에 앱을 수동으로 빌드하는 대신, 올바른 방법은 플레이버를 사용하고 빌드 시간 구성으로 이러한 값들을 제공하는 것입니다.\n\n재밌게도, 이 기사는 어떻게 다른 API 호스트를 처리하는지에 대한 사용 사례를 다루지 않습니다. 또 다른 기사가 이를 잘 다룬다고 생각하며, 그 정보를 반복하고 싶지는 않았어요. 동일한 내용에 대한 자세한 내용은 \"Flutter Ready to Go\"를 참조해주세요. (이 기사에서 다루는 내용은 다음 섹션에서 설명합니다)\n\n거의 모든 앱을 출시하는 사람들이 플레이버를 사용해야 한다고 생각하지만, 대부분의 사람들이 더 오래 동안 사용하지 않는다는 것을 알아봤어요. 보통 초기 설정 관성은 나중에 처리할 수 있을만큼 충분하기 때문에, 최종적으로 개발자들이 의도치 않게 시간을 많이 낭비하게 된다는 것을 알 수 있어요. 유감스럽게도, Flutter의 경우 아직도 *그렇게* 간단하게 설정되지 않으므로, 이 기사가 도움이 되기를 바랍니다.\n\n## Flutter 플레이버 문서에 대한 한 가지 참고사항\n\n<div class=\"content-ad\"></div>\n\n플러터 플레이버 지원은 공식 문서에서 아직 매우 잘 문서화되어 있지 않습니다. 이 문제는 아래의 세 가지 기사를 가리키고 있습니다.\n\n- Flutter 앱의 플레이버 생성(Android 전용)\n- Flutter ready to go (Android 전용)\n- Flutter에 플레이버 주입(Android 및 iOS)\n\nAndroid 설정은 상당히 간단합니다. 반면 iOS 설정은 자세한 부분이 부족하고 따라가기 어려웠습니다. 그래서 이 기사를 쓴 이유가 두 가지 있습니다.\n\n- 위의 기사들 위에 쌓아서, 각기 다른 플레이버에 대해 Firebase 프로젝트를 설정하는 방법도 설명합니다.\n- iOS 플레이버 설정에 대해 더 깊게 파고들어 단계를 더 명확하게 설명하려고 했습니다. 그래서 당신이 이 작업을 수행하는 데 내가 한 것 만큼의 시간을 들이지 않으셔도 되도록 했습니다.\n\n<div class=\"content-ad\"></div>\n\n## 이 튜토리얼의 접근 방식\n\n두 가지 플레이버(dev, prod)가 있는 샘플 앱을 만들어 볼 것입니다.\n각 단계 후에 커밋이 있으므로 코드 차이를 살펴보고 모든 변경 사항을 이해할 수 있습니다. 물론 상세한 지침도 제공하겠습니다. 이미 있는 앱에 대해서도 쉽게 이 지침을 사용할 수 있을 것입니다.\n\n샘플 앱은 여기 있습니다\n\n멋지죠? 그럼 이제 단계를 따라 출발해봅시다...\n\n<div class=\"content-ad\"></div>\n\n## 단계 1: 기본 플러터 앱 초기화\n\n기본 플러터 프로젝트를 생성하려면 flutter create flavor_test을 실행하세요. 특별한 것은 없어요.. 이것은 샘플 앱의 첫 번째 커밋입니다.\n\n![이미지](/assets/img/2024-06-21-BuildflavorsinFlutterAndroidandiOSwithdifferentFirebaseprojectsperflavor_0.png)\n\n## 단계 2: 앱을 Firebase에 연결하도록 구성하기\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-21-BuildflavorsinFlutterAndroidandiOSwithdifferentFirebaseprojectsperflavor_1.png\" />\n\nFirebase 콘솔에서 iOS 및 Android 앱을 만들고 각각 GoogleService-Info.plist 및 google-services.json을 다운로드하세요. Firebase를 Flutter 프로젝트에 추가하는 자세한 지침은 여기에서 확인할 수 있습니다 - https://firebase.google.com/docs/flutter/setup\n\n이 단계에서는 main.dart 파일을 업데이트하여 로컬이 아닌 Firebase Realtime DB에 카운터를 저장하였습니다. Firebase Realtime DB를 콘솔을 통해 설정하고 쓰기 액세스를 허용하는 보안 규칙을 추가해주세요.\n\n이 커밋 후 앱은 아래와 같이 나타납니다 -\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-21-BuildflavorsinFlutterAndroidandiOSwithdifferentFirebaseprojectsperflavor_2.png)\n\n다음 링크로 변경 사항을 확인할 수 있습니다 — \n\nCode Diff : Step 1 to Step 2\nhttps://github.com/animeshjain/flavor_test/compare/step_1_init...step_2_firebase\n\n\n## 단계 3: Android에 빌드 플레이버 추가하기\n\n<div class=\"content-ad\"></div>\n\n운영 환경용 새 Firebase 프로젝트를 만들 수 있습니다\n\n![이미지](/assets/img/2024-06-21-BuildflavorsinFlutterAndroidandiOSwithdifferentFirebaseprojectsperflavor_3.png)\n\n<div class=\"content-ad\"></div>\n\n프로젝트에 Android 앱도 만들어서 google-services.json 파일을 다운로드하고 손쉽게 접근할 수 있도록 해주세요. 곧 앱에 추가할 예정이에요.\n\n재미로, --flavor 플래그를 사용하여 앱을 실행하려고 시도할 때 플러터가 무슨 말을 하는지 확인해봅시다.\n\n![이미지](/assets/img/2024-06-21-BuildflavorsinFlutterAndroidandiOSwithdifferentFirebaseprojectsperflavor_4.png)\n\napp/build.gradle에 flavors를 추가하고 다음과 같이 되어야 해요.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-21-BuildflavorsinFlutterAndroidandiOSwithdifferentFirebaseprojectsperflavor_5.png\" />\n\n개발 플레이버는 기본 applicationId로 com.kanily.flavortest를 사용하며, 프로덕션 플레이버는 프로덕션 플레이버 정의에서 정의된 flavor별 applicationId인 com.kanily.flavortest.prod를 사용할 것입니다. 또한 AndroidManifest.xml에서 앱 이름을 하드 코딩하는 대신에 사용 중인 app_name이라는 문자열 리소스를 정의했습니다. 마지막으로, google-services.json은 소스 폴더 하위에 flavor와 일치하는 이름의 서브폴더에 넣을 수 있습니다. Firebase 문서에서 -\n\n<img src=\"/assets/img/2024-06-21-BuildflavorsinFlutterAndroidandiOSwithdifferentFirebaseprojectsperflavor_6.png\" />\n\n따라서 이러한 설정으로 관리할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n- 각각 다른 플레이버용 앱 ID를 사용하여 장치에 여러 플레이버를 동시에 설치할 수 있습니다.\n- 각기 다른 애플리케이션 이름을 사용하여 사용자/테스터/개발자가 쉽게 구별할 수 있습니다.\n- 각 플레이버가 고유한 Firebase 프로젝트를 가리키게 됩니다 (파일을 플레이버 이름과 동일한 폴더에 배치하는 규칙에 따라 자동으로 처리됩니다).\n\n이제 다음 명령어를 사용하여 앱을 실행할 수 있습니다.\n\nflutter run --flavor dev 또는 flutter run --flavor prod\n\n이제 두 앱을 장치에 설치하고 병렬로 실행할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n위의 코드 변경 사항을 확인하려면 다음과 같이 코드를 보시면 됩니다 —\n\n```js\n코드 변경 내역: Step 2부터 Step 3로\nhttps://github.com/animeshjain/flavor_test/compare/step_2_firebase...step_3_android_flavors\n```\n\n## 단계 4: iOS에 빌드 플레이버 추가\n\niOS 플레이버를 설정하는 것은 더 복잡할 수 있습니다. 또한, iOS 구성은 대부분 XCode UI를 사용하여 진행되며 텍스트 편집기에서 설정 파일을 편집하는 것이 아닙니다 😱. 이 설명은 말로 설명하기에 상당히 복잡하기 때문에 이해를 돕기 위해 모든 조치를 녹화하고 스크린캐스트 GIF로 제공했습니다. 그러니 물 한 잔 마시고 허리띠를 매고 준비하세요…\n\n<div class=\"content-ad\"></div>\n\n플러터 런 명령을 사용하여 iOS 장치/시뮬레이터를 대상으로 실행해 봅시다.\n\n\nflutter run --flavor dev\n\n\n![이미지](/assets/img/2024-06-21-BuildflavorsinFlutterAndroidandiOSwithdifferentFirebaseprojectsperflavor_7.png)\n\n이제 custom schemas라는 것을 설정해야 하는 것 같아요. Xcode를 열고 ios/Runner.xcworkspace를 열어 보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n그리고, 여기에 개발자라고 불리는 사용자 지정 체계를 설정하는 방법이 있습니다...\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*tctD2CuUZuCV4FcFIXXddw.gif)\n\n이제 다시 flutter run --flavor dev를 실행합니다...\n\n![image](/assets/img/2024-06-21-BuildflavorsinFlutterAndroidandiOSwithdifferentFirebaseprojectsperflavor_8.png)\n\n<div class=\"content-ad\"></div>\n\n플러터는 Debug-dev 나 유사한 이름의 빌드 구성을 기대한다고 에러 메시지에 나와 있네요. 이 빌드 구성들을 만들어봅시다...\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*XsDo_Kv4UPiS-Qeix9YEEA.gif)\n\n다시 flutter run --flavor dev을 시도해봅니다...\n\n![image](/assets/img/2024-06-21-BuildflavorsinFlutterAndroidandiOSwithdifferentFirebaseprojectsperflavor_9.png)\n\n<div class=\"content-ad\"></div>\n\n그럼 이제 잘 되었네요. 그러나 지금은 빌드 구성을 사용자 정의하지 않았기 때문에 앱은 이전과 동일한 구성으로 실행 중입니다. 기본 빌드 구성 및 빌드 스키마를 prod로 변경해보겠습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*3TPzQMrFbtwBoe3-seCDhg.gif)\n\n빌드 구성을 복제했기 때문에 개발 구성은 아직 기존 스키마(이제 prod로 변경된)에 연결되어 있습니다. 이것도 수정해 봅시다...\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*qXSwfOJfHFWmBgnb2Rqzrw.gif)\n\n<div class=\"content-ad\"></div>\n\n이제 두 개의 스키마가 각각의 빌드 구성에 연결되었습니다. 이제 스키마별로 사항을 사용자 정의할 수 있습니다. 우선 두 스키마를 위해 앱 번들 식별자를 다르게 변경해 봅시다. 안드로이드에서 우리의 프로덕션 애플리케이션 식별자는 com.kanily.flavortest.prod이었는데, iOS의 번들 식별자는 안드로이드의 애플리케이션 식별자와 동일합니다. 그래서 우리의 프로덕션 번들 식별자를 com.kanily.flavortest.prod로 변경해 봅시다...\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*huXgYB4sDD092hq75PAnyg.gif)\n\n또한 앱을 위해 서로 다른 표시 이름을 사용하고 싶습니다. 그러나 대상의 빌드 설정에는 표시 이름 매개변수가 없습니다. 따라서 사용자 정의 매개변수를 만들고 대신 사용하도록 하겠습니다...\n\n[2020년 5월 5일 업데이트. Stanford Lin님의 댓글 감사합니다]\n\n<div class=\"content-ad\"></div>\n\n플러터 iOS 빌드 방법에 변경 사항이 있어서 이 비디오는 조금 오래됐습니다. 아마 다음과 같은 오류가 발생할 것입니다.\n\n```js\nCould not find the built application bundle at build/ios/iphoneos/Runner.app\n```\n\n이 오류를 피하려면 일반 설정 탭의 표시 이름 속성에 `$(APP_DISPLAY_NAME)`을 추가하는 대신 Info.plist 파일을 업데이트하여 새로운 속성을 포함해야 합니다.\n\n```js\n<dict>\n...\n<key>CFBundleDisplayName</key>\n<string>$(APP_DISPLAY_NAME)</string>\n...\n</dict>\n```\n\n<div class=\"content-ad\"></div>\n\n일반 설정 탭에서 더 이상 Display Name 속성을 변경할 필요가 없습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*VJhfqIi3-Y365nfM3D99BQ.gif)\n\n마지막으로, 빌드 구성에 따라 다른 GoogleServices-Info.plist를 사용하는 방법을 찾아야 합니다. 이를 실행시간에 앱 시작 시 수행하거나 Firebase 사용을 시작할 때 적합한 구성 파일을 명시적으로 지정하여 Firebase를 초기화하는 것을 제안하는 해결책도 있습니다(https://firebase.google.com/docs/projects/multiprojects에 Firebase 문서에서도 같은 것을 제안합니다). 하지만 저는 앱 번들이 생성될 때 올바른 파일이 자동으로 사용되도록 기본 위치에 올바른 파일을 빌드 시간에 복사하는 다른 옵션을 선호합니다.\n\n이를 달성하기 위해 먼저 각 플레이버용 GoogleServices-Info.plist 파일을 다음과 같이 별도의 폴더에 유지합니다...\n\n<div class=\"content-ad\"></div>\n\n맨처음 코드 조각을 Markdown 글서식에 맞게 변경해볼게요. \n\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*2QT0g0XVi72daZz3tYJdmw.gif)\n\n\nXCode에 config 폴더를 명확히 복사한 후 해당 위치에서 명령줄 또는 탐색기를 통해 XCode에 명시적으로 드래그앤드랍 해주세요. XCode가 명시적으로 추가하기 전까지는 프로젝트 참조에 추가되지 않습니다. 프로젝트 디렉토리에 보관된 파일/폴더는 기본적으로 더해지지 않아요. 위 단계를 따른 후 XCode 폴더 구조는 아래와 같이 보일 거예요.\n\n\n![이미지](/assets/img/2024-06-21-BuildflavorsinFlutterAndroidandiOSwithdifferentFirebaseprojectsperflavor_10.png)\n\n\n이제 빌드 프로세스에 단계를 추가하여 각각의 GoogleServices-Info.plist 파일이 올바른 위치로, 즉 Runner 디렉토리 내부로 복사되도록 해야 합니다. 이는 새로운 Run script 빌드 단계를 타겟에 추가함으로써 성취할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*5tcidmX4DPIvskHpgtec0Q.gif\" />\n\n위의 스크립트를 사용했어요...\n\n[2020년 6월 23일 업데이트. Dharma Teja Nuli님의 코멘트에 감사드립니다.]\n\n여기서 코멘트를 편리하게 요약하면:\n\n<div class=\"content-ad\"></div>\n\n그리고 이제 다 끝났어요! 이제 flutter run --flavor dev 또는 flutter run --flavor prod 명령어를 실행할 수 있어요.\n\n그러면 iOS 기기 / 시뮬레이터에 각각 다른 Firebase DB에 연결되는 별도의 앱이 설치될 거예요!\n\n```js\n코드 차이: 단계 3에서 단계 4로\nhttps://github.com/animeshjain/flavor_test/compare/step_3_android_flavors...step_4_ios_flavors\n```\n\n<div class=\"content-ad\"></div>\n\n## 단계 5: 다른 플레이버용 앱 아이콘 추가\n\n가끔은 다른 이름만으로는 충분하지 않을 수 있습니다. 기기에 여러 가지 플레이버가 설치된 경우 시각적으로 명확하게 구분하기 위해 다른 앱 아이콘을 원할 수도 있습니다.\n\n지금까지 Flutter에서 제공하는 기본 런처 아이콘을 사용했지만, 단계를 설명하기 위해 프로드 및 데브를 위한 두 개의 아이콘을 만들었습니다.\n\n- Android용 단계\n\n<div class=\"content-ad\"></div>\n\n기본값으로 고려하는 플레이버에 따라 이 아이콘 중 하나는 android/app/src/main/res 폴더로 이동하여 모든 크기에 대한 기존 ic_launcher.png 파일을 대체할 수 있습니다. 저는 default 폴더에 개발자 아이콘을 넣을 것입니다.\n\n![아이콘 이미지](/assets/img/2024-06-21-BuildflavorsinFlutterAndroidandiOSwithdifferentFirebaseprojectsperflavor_11.png)\n\n프로드 플레이버의 경우, 몇몇 분들이 추측하신 것처럼, 우리는 간단히 prod 폴더에 res 폴더를 만들어 모든 크기별 폴더를 추가하면 됩니다. 그러면 디렉토리 구조는 다음과 같이 보일 것입니다.\n\n![디렉토리 구조](/assets/img/2024-06-21-BuildflavorsinFlutterAndroidandiOSwithdifferentFirebaseprojectsperflavor_12.png)\n\n<div class=\"content-ad\"></div>\n\n참고: 개발 앱 아이콘 파일을 특정히 dev 폴더에 넣을 수도 있습니다. 안드로이드는 먼저 플레이버별 디렉토리를 찾아보고, 그곳에서 찾을 수 없는 경우에는 기본 디렉토리인 main으로 되돌아가 그 안에 있는 리소스를 사용합니다.\n\n안드로이드에서 아이콘은 다음과 같이 보입니다 -\n\n![Android Icon](/assets/img/2024-06-21-BuildflavorsinFlutterAndroidandiOSwithdifferentFirebaseprojectsperflavor_13.png)\n\n- iOS 설정 방법\n\n<div class=\"content-ad\"></div>\n\n위에서 JSON 파일의 내용을 복사하고 붙여넣기하여 manifest.json 파일을 만들고 해당 파일을 등록합니다.\n\n<div class=\"content-ad\"></div>\n\n마침내 모든 설명을 마쳤습니다. 이 튜토리얼이 iOS에서 특히 플레이버를 설정하는 데 어떤 혼란을 해소하는 데 도움이 되길 바랍니다. 아래에는 이 작업을 수행하려고 노력하면서 발견한 유용한 기사/자료들이 있습니다.\n\n## 부가 자료\n\n- 플러터 플레이버(및 빌드 모드 — 디버그, 릴리스, 프로파일)가 해당 OS별 빌드 구조로 매핑되는 방식을 설명하는 깃헙 풀 리퀘스트 — [링크](https://github.com/flutter/flutter/pull/11734)\n- XCode가 앱을 빌드하는 방법에 대한 심화 학습을 원하는 분들을 위한 자료 — [링크](https://www.youtube.com/watch?v=yazY8hCO46s)\n- XCode 빌드를 실행하는 플러터 커맨드 라인 도구 소스 코드 — [링크](https://github.com/flutter/flutter/blob/27b058a41473d5ef136f3874ed6f0a2ccaf969d0/packages/flutter_tools/lib/src/ios/xcodeproj.dart)\n- Dart 코드에서 플레이버를 구현하는 방법에 대한 설명 — [링크](https://medium.com/flutter-community/flutter-ready-to-go-e59873f9d7de)","ogImage":{"url":"/assets/img/2024-06-21-BuildflavorsinFlutterAndroidandiOSwithdifferentFirebaseprojectsperflavor_0.png"},"coverImage":"/assets/img/2024-06-21-BuildflavorsinFlutterAndroidandiOSwithdifferentFirebaseprojectsperflavor_0.png","tag":["Tech"],"readingTime":11},{"title":"플러터에서 Expansion Tile 사용 방법","description":"","date":"2024-06-21 20:50","slug":"2024-06-21-ExpansionTileinFlutter","content":"\n\n\n![Image](/assets/img/2024-06-21-ExpansionTileinFlutter_0.png)\n\n안녕하세요 독자 여러분, 이 기사에서는 플러터 앱에 확장 가능한 목록 타일을 추가하는 방법에 대해 알아보겠습니다. 이것은 우리가 목록 뷰에서 목록 타일을 사용하는 방식과 유사합니다. 따라서 시작하기 전에 오늘 어떤 것을 달성하고 싶은지 먼저 살펴보겠습니다.\n\n![Image](https://miro.medium.com/v2/resize:fit:700/0*SAyKoBHKRJMTrECc.gif)\n\n## 확장 타일이란 무엇인가요?\n\n\n<div class=\"content-ad\"></div>\n\n플러터에서의 확장 타일은 이미 리스트 뷰에서 사용해본 ListTile과 거의 비슷하지만, 유일한 차이점은 사용자가 타일을 확장하거나 축소하여 타일에 대한 자세한 정보를 볼 수 있다는 것입니다. 위 이미지에서 확장 타일의 예시를 볼 수 있어요.\n\n확장 타일은 주로 ListTile에 몇 가지 추가 정보를 추가하고 싶지만, 그 정보가 처음에는 필요하지 않을 때 사용됩니다. 사용자가 보고 싶을 때 볼 수 있어요.\n\n## ListView 만들기\n\n확장 리스트 뷰를 만들기 전에 기본 리스트 뷰와 리스트 타일만 있는 리스트 뷰를 만들어 볼게요. 이를 위해, 그냥 단순히 ListView.builder()를 scaffold의 body에 추가하면 돼요.\n\n<div class=\"content-ad\"></div>\n\n```dart\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n        appBar: AppBar(\n          title: const Text(\"\"),\n        ),\n        body: ListView.builder(\n          itemCount: 10,\n          itemBuilder: (context, index) {\n            return Card(\n              child: ListTile(\n                title: Text(\"사용자 $index\"),\n              ),\n            );\n          },\n        ));\n  }\n}\n```\n\n이제 리스트 뷰는 다음과 같이 보일 것입니다.\n\n![ExpansionTile in Flutter](/assets/img/2024-06-21-ExpansionTileinFlutter_1.png)\n\n## ListView에 ExpansionTile 추가하기\n\n<div class=\"content-ad\"></div>\n\n기본 목록 보기가 준비되었습니다. 목록의 항목을 확장 가능하게 만들려면 ListTile 위젯을 ExpansionTile로 변경하면 됩니다.\n\n```js\nbody: ListView.builder(\n    itemCount: 10,\n    itemBuilder: (context, index) {\n      return Card(\n        child: ExpansionTile(\n          title: Text(\"User $index\"),\n        ),\n      );\n    },\n```\n\nExpansionTile로 ListTile을 변경한 후에는 타일 끝에 화살표가 있는 것을 볼 수 있습니다. 이제 타일을 클릭하면 타일이 확장되고 강조 표시되며 화살표 방향이 바뀝니다.\n\n<img src=\"https://miro.medium.com/v2/resize:fit:600/0*dQi0SoELCTbErmxf.gif\" />\n\n<div class=\"content-ad\"></div>\n\n하지만 타일이 확장되면 아무것도 보이지 않습니다. 이는 ExpansionTile에서 children 매개변수를 제공해야하기 때문입니다. 우리가 children으로 전달하는 어떤 위젯이든, 타일을 확장할 때 표시됩니다.\n\n```js\n return Card(\n  child: ExpansionTile(\n    title: Text(\"User $index\"),\n    children: [\n      Text(\"Name : User $index\"),\n      Text(\"Phone No: $index\"),\n      const Text(\"isAdmin: No\")\n    ],\n  ),\n);\n```\n\n<img src=\"https://miro.medium.com/v2/resize:fit:700/0*SAyKoBHKRJMTrECc.gif\" />\n\n이제 우리의 목표가 달성되었습니다. 확장 가능한 자식을 가진 리스트 뷰입니다. 그러나 확장된 타일이 멋지지 않습니다. 그렇기 때문에 ExpansionTile 생성자에는 타일을 더 매력적으로 만들기 위해 사용할 수 있는 다른 매개변수들이 몇 가지 있습니다. 한 번 살펴보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n## ExpansionTile 위젯의 매개변수\n\n생성자\n\n```js\n ExpansionTile({\n  Key? key,\n  Widget? leading,\n  required Widget title,\n  Widget? subtitle,\n  void Function(bool)? onExpansionChanged,\n  List<Widget> children = const <Widget>[],\n  Widget? trailing,\n  bool initiallyExpanded = false,\n  bool maintainState = false,\n  EdgeInsetsGeometry? tilePadding,\n  CrossAxisAlignment? expandedCrossAxisAlignment,\n  Alignment? expandedAlignment,\n  EdgeInsetsGeometry? childrenPadding,\n  Color? backgroundColor,\n  Color? collapsedBackgroundColor,\n  Color? textColor,\n  Color? collapsedTextColor,\n  Color? iconColor,\n  Color? collapsedIconColor,\n  ShapeBorder? shape,\n  ShapeBorder? collapsedShape,\n  Clip? clipBehavior,\n  ListTileControlAffinity? controlAffinity,\n})\n```\n\n위는 ExpansionTile 위젯의 생성자이며 대부분의 매개변수는 ListTile과 유사하지만 ExpansionTile에서 새로운 매개변수가 있습니다.\n\n<div class=\"content-ad\"></div>\n\nonExpansionChanged\n사용자가 타일을 클릭할 때 호출되는 함수입니다. 이 함수에는 Boolean isExpanded 매개변수가 전달됩니다. 사용자가 타일을 확장했다면 값은 true가 되고, 사용자가 타일을 축소했다면 값은 false가 됩니다.\n\n```js\nonExpansionChanged: (value) {\n  ScaffoldMessenger.of(context).showSnackBar(SnackBar(\n      content: Text(\n        \"$index 타일 ${value ? \"확장됨\" : \"축소됨\"}\")));\n},\n```\n\n<img src=\"https://miro.medium.com/v2/resize:fit:420/0*FcINjFqIXC2ok_q6.gif\" />\n\ninitiallyExpanded\n위젯의 첫 번째 빌드 시에 타일을 기본적으로 확장하는 경우 true를 전달하는 부울 변수입니다.\n\n<div class=\"content-ad\"></div>\n\n```dart\nExpansionTile(\n  title: Text(\"사용자 $index\"),\n  initiallyExpanded: index.isEven, // 모든 짝수 타일이 기본적으로 확장됨\n  children: [\n    Text(\"이름: 사용자 $index\"),\n    Text(\"전화번호: $index\"),\n    const Text(\"isAdmin: 아니요\")\n  ],\n),\n```\n\n![ExpansionTileinFlutter_2](/assets/img/2024-06-21-ExpansionTileinFlutter_2.png)\n\nmaintainState\n타일이 확장되고 축소될 때 체일드의 상태를 유지할지 여부를 지정합니다.\n\ntrue인 경우 타일이 축소될 때도 체일드는 트리에 유지됩니다. false인 경우 (기본값) 타일이 축소될 때 체일드가 트리에서 제거되고 확장 시에 다시 생성됩니다.\n\n<div class=\"content-ad\"></div>\n\nexpandedCrossAxisAlignment\n타일이 확장될 때 각 자식의 정렬을 지정합니다.\n\n확장된 타일의 내부에서는 [children]을 위해 [Column] 위젯을 사용하며, crossAxisAlignment 매개변수는 [Column]으로 직접 전달됩니다.\n\n```dart\nreturn Card(\n  child: ExpansionTile(\n    title: Text(\"User $index\"),\n    maintainState: true,\n    expandedCrossAxisAlignment: CrossAxisAlignment.end,\n    children: [\n      Row(\n        children: const [Text(\"This is a Row\")],\n      ),\n      Text(\"Name: User $index\"),\n      Text(\"Phone No: $index\"),\n      const Text(\"isAdmin: No\")\n    ],\n  ),\n);\n```\n\n<div class=\"content-ad\"></div>\n\nexpandedAlignment\n이 속성은 확장된 타일 내부의 자식 요소를 정렬합니다.\n\n```js\nExpansionTile(\n                title: Text(\"User $index\"),\n                maintainState: true,\n                expandedAlignment: Alignment.centerLeft,\n                children: [\n                  Text(\"Name : User $index\"),\n                  Text(\"Phone No: $index\"),\n                  const Text(\"isAdmin: No\")\n                ],\n              ),\n```\n\nchildrenPadding\n이름에서 알 수 있듯이 확장된 위젯 내 자식 요소 주위의 여백입니다.\n\nbackgroundColor 및 collapsedBackgroundColor\n이것은 타일이 축소되거나 확장되었을 때 적용되는 배경색입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nreturn Card(\n              child: ExpansionTile(\n                title: Text(\"사용자 $index\"),\n                maintainState: true,\n                backgroundColor: Colors.red,\n                collapsedBackgroundColor: Colors.yellow,\n                children: [\n                  Text(\"이름: 사용자 $index\"),\n                  Text(\"전화번호: $index\"),\n                  const Text(\"관리자 권한: 아니요\")\n                ],\n              ),\n            );\n```\n\n<img src=\"https://miro.medium.com/v2/resize:fit:424/0*DuYJu0s-ySdjEb9V.gif\" />\n\ntextColor, collapsedTextColor, iconColor, collapsedIconColor\n이것은 타일이 확장되었거나 축소될 때 텍스트와 아이콘의 색상입니다.\n\n```js\nreturn Card(\n              child: ExpansionTile(\n                title: Text(\"사용자 $index\"),\n                maintainState: true,\n                textColor: Colors.red,\n                collapsedTextColor: Colors.yellow,\n                iconColor: Colors.red,\n                collapsedIconColor: Colors.yellow,\n                children: [\n                  Text(\"이름: 사용자 $index\"),\n                  Text(\"전화번호: $index\"),\n                  const Text(\"관리자 권한: 아니요\")\n                ],\n              ),\n            );\n``` \n\n\n<div class=\"content-ad\"></div>\n\nshape 및 collapsedShape\n이 매개변수를 사용하여 타일이 축소 또는 확장될 때 모양을 변경할 수 있습니다.\n\n```js\nreturn Padding(\n              padding: const EdgeInsets.all(8.0),\n              child: ExpansionTile(\n                title: Text(\"User $index\"),\n                maintainState: true,\n                backgroundColor: Colors.red,\n                collapsedBackgroundColor: Colors.yellow,\n                shape: const RoundedRectangleBorder(\n                    borderRadius: BorderRadius.all(Radius.circular(20))),\n                collapsedShape: const RoundedRectangleBorder(\n                    borderRadius: BorderRadius.all(Radius.circular(50))),\n                children: [\n                  Text(\"이름: User $index\"),\n                  Text(\"전화번호: $index\"),\n                  const Text(\"관리자: 아니요\")\n                ],\n              ),\n            );\n```\n\n![이미지](https://miro.medium.com/v2/resize:fit:424/0*NELwUxIbDKIkdFS-.gif)\n\ncontrolAffinity\n일반적으로 확장 화살표 아이콘을 타일의 선행 또는 후행 가장자리에 강제로 배치하는 데 사용됩니다.\n\n<div class=\"content-ad\"></div>\n\n기본적으로 [controlAffinity]의 값은 [ListTileControlAffinity.platform]이며, 이는 확장 화살표 아이콘이 타일의 뒷부분에 표시된다는 것을 의미합니다.\n\n## 결론\n\n요약하면, ExpansionTile 위젯은 Flutter 앱에서 확장 가능하고 접을 수 있는 콘텐츠를 생성하는 데 유용한 도구입니다. 몇 줄의 코드로 깔끔한 사용자 인터페이스를 만들어 사용자들이 쉽게 더 많은 정보에 액세스할 수 있도록 할 수 있습니다.\n\n이 기사가 ExpansionTile 위젯에 대한 유용한 소개를 제공하고 여러분이 자신의 Flutter 개발 프로젝트에 이를 통합하도록 영감을 주었기를 바랍니다.\n\n<div class=\"content-ad\"></div>\n\n# 함께해요\n\n이 글을 읽어 주셔서 감사합니다. 만약 마음에 드셨다면 더 많은 글을 읽어보고 저를 팔로우해주세요.\n\nhttps://www.linkedin.com/in/aakashpamnani/","ogImage":{"url":"/assets/img/2024-06-21-ExpansionTileinFlutter_0.png"},"coverImage":"/assets/img/2024-06-21-ExpansionTileinFlutter_0.png","tag":["Tech"],"readingTime":9},{"title":"플러터와 다트에서 코드 난독화 신비로운 코드 이해하기","description":"","date":"2024-06-21 20:49","slug":"2024-06-21-ObfuscationinFlutterandDartMysteriouscodes","content":"\n\n![image](/assets/img/2024-06-21-ObfuscationinFlutterandDartMysteriouscodes_0.png)\n\n안녕하세요, 이 글에서는 플러터와 다트 코드 난독화, 플러터의 중요한 주제 중 하나를 배우게 됩니다.\n\n먼저, 난독화가 무엇인지 알아보겠습니다.\n\n난독화는 코드를 사람이 해독할 수 없도록 만드는 과정입니다. 이는 역공학 공격을 어렵게 만들어서 애플리케이션의 보안을 높이기 위해 사용됩니다. 플러터와 다트는 난독화를 위한 일부 내장 도구와 방법을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n# 왜 난독화를 사용해야 하나요?\n\n- 보안: 코드를 알아보기 어렵게 만들어 악의적 사용자가 코드를 이해하고 남용하는 것을 어렵게 합니다.\n- 지적 재산권: 코드를 보호하여 지적 재산권을 안전하게 지킵니다.\n- 용량 감소: 어떤 경우에는 난독화가 코드의 크기를 줄이는 데 도움이 될 수도 있습니다.\n\n시작해봅시다! 🥷🏻\n\n- 플러터 프로젝트를 만들어보세요.\n\n<div class=\"content-ad\"></div>\n\n\n```js\nflutter create my_app\ncd my_app\n```\n\n2. 프로젝트 구조화\n\n난독화를 활성화하려면 flutter 빌드 명령에 몇 가지 추가 매개변수를 추가해야 합니다. Android 및 iOS 모두를 위해 난독화하는 방법을 살펴보겠습니다.\n\nAndroid용으로는;\n\n\n<div class=\"content-ad\"></div>\n\n- android/app/build.gradle 파일을 열어주세요.\n- buildTypes 섹션에서 릴리스 구성을 다음과 같이 업데이트해주세요:\n\n```js\nandroid {\n    ...\n    buildTypes {\n        release {\n            ...\n            minifyEnabled true\n            shrinkResources true\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n}\n```\n\n- Proguard 규칙을 지정하려면 android/app/proguard-rules.pro 파일을 생성하고 다음 줄을 추가해주세요:\n\n```js\n# Flutter 난독화\n-ignorewarnings\n-keep class io.flutter.app.** { *; }\n-keep class io.flutter.plugin.** { *; }\n-keep class io.flutter.util.** { *; }\n-keep class io.flutter.view.** { *; }\n-keep class io.flutter.embedding.** { *; }\n-keep class io.flutter.embedding.engine.** { *; }\n-keep class io.flutter.embedding.android.** { *; }\n-keep class io.flutter.embedding.engine.plugins.** { *; }\n-keep class io.flutter.plugin.common.** { *; }\n-keep class io.flutter.plugin.platform.** { *; }\n```\n\n<div class=\"content-ad\"></div>\n\niOS에서는 다음을 수행하실 수 있습니다:\n\n- Open theios/Runner.xcodeproj 파일을 엽니다.\n- 빌드 설정 섹션에서 'Other Swift Flags' 설정을 찾아서 -D DART_OBFUSCATION을 추가합니다.\n\n3. 난독화된 애플리케이션 컴파일\n\n다음 명령어를 사용하여 Android 및 iOS용 난독화된 빌드를 생성합니다:\n\n<div class=\"content-ad\"></div>\n\n안드로이드:\n\n```js\nflutter build apk --release --obfuscate --split-debug-info=./build_info\n```\n\niOS:\n\n```js\nflutter build ios --release --obfuscate --split-debug-info=./build_info\n```\n\n<div class=\"content-ad\"></div>\n\n이 명령어들은 난독화된 코드의 디버그 정보 파일을 지정된 디렉토리에 넣습니다. 이 파일들은 디버깅 및 충돌 보고서 해결에 중요합니다.\n\n4. 애플리케이션 파일 검토\n\n난독화 프로세스의 결과물인 APK 또는 IPA 파일을 열어 코드가 숨겨져 있는지 확인할 수 있습니다. Android APK 파일을 검토하기 위해서는 apktool 또는 유사한 도구를 사용할 수 있습니다. iOS IPA 파일은 class-dump 또는 otool과 같은 도구를 사용할 수 있습니다.\n\n- Android APK 파일 검토:\napktool을 사용하여 APK 파일을 디컴파일합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\napktool d my_app.apk -o output_dir\n```\n\n- iOS IPA 파일을 조사해보세요:\nIPA 파일을 열고 Payload 디렉토리에서 응용 프로그램 파일을 추출하세요. class-dump나 otool을 사용하여 응용 프로그램 파일을 조사하세요.\n\n```js\nclass-dump -H MyApp -o output_dir\n```\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\n위의 단계를 따라 코드를 난독화하여 응용 프로그램의 안전성을 높일 수 있습니다. 이를 정기적으로 수행함으로써 응용 프로그램의 보안을 지속적으로 보호할 수 있습니다.\n\n독자 여러분, 읽어주셔서 감사합니다!\n새로운 기사에서 뵙겠습니다 💙\n\n제 계정을 여기에서 확인하고 질문을 하실 수 있습니다 ✨\n\n트위터에서 플러터 커뮤니티를 팔로우해보세요:\nhttps://www.twitter.com/FlutterComm","ogImage":{"url":"/assets/img/2024-06-21-ObfuscationinFlutterandDartMysteriouscodes_0.png"},"coverImage":"/assets/img/2024-06-21-ObfuscationinFlutterandDartMysteriouscodes_0.png","tag":["Tech"],"readingTime":3},{"title":"ThemeExtension으로 Flutter 맞춤 테마 만들기  템플릿 제공","description":"","date":"2024-06-21 20:46","slug":"2024-06-21-FlutterCustomThemewithThemeExtensionTemplates","content":"\n\n<img src=\"/assets/img/2024-06-21-FlutterCustomThemewithThemeExtensionTemplates_0.png\" />\n\n이 글에서는 ThemeExtensions를 사용하여 Flutter에서 사용자 정의 테마를 만드는 과정을 안내해 드리겠습니다. Color 및 TextStyle 확장을 위한 템플릿을 제공해 드릴 것이며, 내장 ColorScheme 및 TextTheme을 사용하지 않는 것을 권장하는 이유도 설명해 드리겠습니다(대부분의 경우 99%는 Material 사양을 따르지 않기 때문입니다).\n\n빠른 이동:\n\n- 문제점\n- 사용자 정의 색상 추가 방법\n- 밝은 모드와 어두운 모드 구현 방법\n- 사용자 정의 텍스트 스타일 추가 방법\n- Text 위젯에 대한 기본 TextStyle\n- 마무리(추가 링크)\n\n<div class=\"content-ad\"></div>\n\n## 문제\n\n새로운 Flutter 프로젝트를 시작할 때마다 앱에 재사용 가능한 스타일을 정의해야 합니다. 보통, 디자인 시스템에 기반한 스타일을 정의하며, 그것은 대개(사실은 절대로) Material입니다. TextStyle 토큰들(headlineLarge, bodyMedium, ...)은 Material 명명 규칙을 따르지 않습니다; 디자인 항목들은 팔레트(빨간색, 회색, ...)에서 색상을 사용하고, 색상 체계(accent, primary, background, ...)에서는 사용하지 않습니다. 이 모든 것을 살펴보고 Flutter 앱에 어떻게 적용해야 할지 모를 때가 있습니다.\n\n먼저, ThemeData를 확장하거나 고유한 사용자 정의 테마 클래스를 작성할 수 있다고 생각할 수 있지만, 그렇게 하지 마십시오. 이 기사에서 보여드리는 Flutter 앱에 자연스럽게 통합되는 훨씬 더 나은 방법이 있습니다(ThemeExtension). 하지만 먼저, 왜 내장된 Material ColorScheme 및 TextTheme에 디자인을 통합하기를 추천하지 않는지 살펴보겠습니다.\n\n## ColorScheme 및 TextTheme가 디자인에 적합하지 않은 이유\n\n<div class=\"content-ad\"></div>\n\n플러터는 전역 앱 테마를 설정하기 위해 ThemeData 클래스를 제공합니다. 이 클래스에는 여러 내장 위젯을 위한 많은 속성이 포함되어 있지만, 주요 속성은 ColorScheme과 TextTheme이라고 할 수 있어요. 이것들은 \"괜찮은\"데요, 하지만 여러분의 디자인이 머티리얼 사양을 따르는 경우에만 해당합니다. 그렇지 않으면 대부분의 경우, 디자인 시스템은 서로 다른 이름 및 색상 및 텍스트 스타일 토큰 수를 가지게 될 거에요.\n\n어쩌면 일부 색상 및 텍스트 스타일 토큰이 일치할 수도 있지만, 나머지는 일치하지 않을 수 있어요. 일부 토큰을 매핑해 볼 수도 있겠죠 (디자인: h1 - 코드: headlineLarge), 그리고 다른 토큰을 별도의 위치에 넣어 볼 수도 있어요 (ThemeExtension 또는 다른 곳). 하지만 이것은 좋은 해결책이 될 수 없어요. 이것은 이해하기 어려운 토큰 이름 매핑과 유지 및 수정이 어려운 앱 테마의 분산 선언으로 이어질 거에요. 왜 굳이 사용자 지정 디자인 시스템을 머티리얼에 넣으려고 하나요?\n\n그래서 나는 모든 사용자 지정 스타일을 완전히 제어할 수 있는 사용자 정의 ThemeExtension(s)에 넣으라고 권장해요. 혜택:\n\n- 필요한 속성을 추가, 이름 변경, 삭제할 수 있어요.\n- 머티리얼 사양이나 플러터 업데이트에 의존하지 않아요.\n- 모든 관련된 스타일이 1곳에 모이며 ColorScheme과 ExtraColorScheme 사이로 흩어지지 않아요.\n\n<div class=\"content-ad\"></div>\n\n게다가 GitHub Copilot 또는 제가 제공할 템플릿을 사용하면 매우 쉽게 작성할 수 있습니다.\n\n내가 여전히 Theme과 ThemeData를 사용하고 직접 클래스를 만들지 말 것을 추천하는 이유는 Flutter가 이미 이러한 클래스를 사용하여 필요한 모든 것을 갖추고 있기 때문입니다. UI 부분을 위한 테마 재정의, 내장 위젯의 기본 스타일링, 기본 텍스트 스타일 설정, 라이트 및 다크 모드 전환 지원 등이 모두 포함되어 있습니다. 이미 존재하는 것(ThemeExtensions)을 확장하는 것이 더 쉬울 때에는 직접 클래스를 작성할 필요가 없습니다.\n\n# Flutter에서 ThemeExtension을 사용하여 사용자 정의 색상 추가하는 방법\n\nFlutter 앱에 사용자 정의 색상을 추가하려면 3단계만 거치면 됩니다:\n\n<div class=\"content-ad\"></div>\n\n- 사용자 정의 색상 정의\n- 색상을 위한 ThemeExtension 생성\n- Light 및 Dark 모드를 위한 확장 기능 초기화\n\n## 단계 1: AppPalette\n\nAppPalette는 디자인 시스템에서 사용되는 색상 코드를 정의하는 클래스입니다. 복잡한 것은 아니며, 단순히 정적 속성을 가진 클래스일 뿐입니다:\n\n```js\nabstract class AppPalette {\n  // 빨강\n  static const red = Colors.red;\n  static const imperialRed = Color(0xFFE54B4B);\n\n  // 흰색\n  static const seashell = Color(0xFFF7EBE8);\n\n  // 회색\n  static const grey = _GreyColors();\n}\n\n/// 팔레트에서 색상을 그룹화하는 대체 방법.\n/// \n/// 단점은 이러한 값들이 상수가 아니기 때문에\n/// 생성자 기본 값으로 사용할 수 없다는 것입니다.\n///\n/// 사용 예: `AppPalette.grey.grey50`.\nclass _GreyColors {\n  const _GreyColors();\n\n  final grey50 = const Color(0xFFFAFAFA);\n  final grey100 = const Color(0xFFF5F5F5);\n}\n```\n\n<div class=\"content-ad\"></div>\n\n노트:\n\n- AppPalette는 추상입니다. 왜냐하면 우리는 이를 실체화할 필요가 없기 때문입니다.\n- _GreyColors는 비공개입니다. 직접 액세스하는 것이 아니라 AppPalette를 통해서만 액세스를 허용합니다.\n\n## 단계 2: AppColorsExtension + 템플릿\n\n여기서는 테마 익스텐션을 정의하고 copyWith() 및 lerp() 메소드를 구현해야 합니다. 이 예제에서는 주요 및 배경 속성만 있는데도 간단한 작업에 대해 너무 많은 코드처럼 보일 수 있지만, 코드 생성 없이는 이를 해결할 방법이 없습니다. (링크는 엔딩 섹션에 있음).\n\n<div class=\"content-ad\"></div>\n\n```dart\nclass AppColorsExtension extends ThemeExtension<AppColorsExtension> {\n  AppColorsExtension({\n    required this.primary,\n    required this.background,\n  });\n\n  final Color primary;\n  final Color background;\n\n  @override\n  ThemeExtension<AppColorsExtension> copyWith({\n    Color? primary,\n    Color? background,\n  }) {\n    return AppColorsExtension(\n      primary: primary ?? this.primary,\n      background: background ?? this.background,\n    );\n  }\n\n  @override\n  ThemeExtension<AppColorsExtension> lerp(\n    covariant ThemeExtension<AppColorsExtension>? other,\n    double t,\n  ) {\n    if (other is! AppColorsExtension) {\n      return this;\n    }\n\n    return AppColorsExtension(\n      primary: Color.lerp(primary, other.primary, t)!,\n      background: Color.lerp(background, other.background, t)!,\n    );\n  }\n}\n```\n\n참고:\n\n- lerp()는 다른 ThemeExtension 개체와 선형 보간을 수행하고 테마를 변경할 때 애니메이션을 만듭니다.\n\n전체 확장 템플릿 링크는 여기에 있습니다. 현재 내장 ColorScheme과 모든 속성이 동일하지만 필요에 맞게 추가, 이름 바꾸기 및 삭제할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n🔗 AppColorsExtension 템플릿\n\n## 단계 3: 밝은 모드와 어두운 모드\n\n이 단계는 다음 섹션에서 진행될 예정이에요 😅\n\n참고로, Chopper 요청에 HTTP Authorization 헤더를 추가하고 401 Unauthorized 응답일 때 재시도하는 방법에 대한 제 다른 글도 확인해보시기를 추천해요.\n\n<div class=\"content-ad\"></div>\n\n이제 다시 플러터 테마링으로 돌아왔어요! 🙂\n\n# 플러터에서 라이트 모드와 다크 모드를 구현하는 방법\n\n다시 한 번, 3가지 간단한 단계만 따르면 돼요:\n\n- 라이트와 다크 테마 데이터를 정의하세요.\n- MaterialApp에 그 데이터들을 전달하세요.\n- MaterialApp에 올바른 ThemeMode를 전달하세요.\n\n<div class=\"content-ad\"></div>\n\n## 단계 1: App 테마\n\n이 클래스는 ThemeExtensions와 테마 모드를 프로그래밍적으로 전환할 수 있는 기능을 가진 라이트 및 다크 모드용 Flutter ThemeData 게터를 포함하고 있습니다. 우선 게터를 구현해봅시다.\n\n```js\nclass AppTheme {\n  //\n  // 라이트 테마\n  //\n\n  static final light = ThemeData.light().copyWith(\n    extensions: [\n      _lightAppColors,\n    ],\n  );\n\n  static final _lightAppColors = AppColorsExtension(\n    primary: const Color(0xff6200ee),\n    onPrimary: Colors.white,\n    secondary: const Color(0xff03dac6),\n    onSecondary: Colors.black,\n    error: const Color(0xffb00020),\n    onError: Colors.white,\n    background: Colors.white,\n    onBackground: Colors.black,\n    surface: Colors.white,\n    onSurface: Colors.black,\n  );\n\n  //\n  // 다크 테마\n  //\n\n  static final dark = ThemeData.dark().copyWith(\n    extensions: [\n      _darkAppColors,\n    ],\n  );\n\n  static final _darkAppColors = AppColorsExtension(\n    primary: const Color(0xffbb86fc),\n    onPrimary: Colors.black,\n    secondary: const Color(0xff03dac6),\n    onSecondary: Colors.black,\n    error: const Color(0xffcf6679),\n    onError: Colors.black,\n    background: const Color(0xff121212),\n    onBackground: Colors.white,\n    surface: const Color(0xff121212),\n    onSurface: Colors.white,\n  );\n}\n```\n\n참고:\n\n<div class=\"content-ad\"></div>\n\n- 여기서는 템플릿에서 AppColorsExtension의 전체 버전을 사용했습니다.\n\n❗중요. 공식 문서에서는 다음과 같이 확장을 액세스합니다: Theme.of(context).extension`MyColors`()! 하지만 이것은 너무 길고 사용하기 어려울 수 있습니다. Dart 확장 메서드의 강력함을 활용하는 좋은 솔루션이 없다는 것이 안타깝습니다.\n\n```js\nextension AppThemeExtension on ThemeData {\n  /// 사용 예시: Theme.of(context).appColors;\n  AppColorsExtension get appColors =>\n      extension<AppColorsExtension>() ?? AppTheme._lightAppColors;\n}\n```\n\n참고:\n\n<div class=\"content-ad\"></div>\n\n- 만약 이 확장 기능이 AppTheme._lightAppColors에 액세스해야 한다면 AppTheme과 같은 파일에 작성되어야 합니다.\n\n❗또 하나의 개선점입니다. 매번 Theme.of(context)를 작성하는 것이 너무 길 수 있으므로 BuildContext에 다른 확장 메소드를 추가하는 것을 선호합니다:\n\n```js\nextension ThemeGetter on BuildContext {\n  // 사용 예: `context.theme`\n  ThemeData get theme => Theme.of(this);\n}\n```\n\n최종 사용 방법은 다음과 같습니다: context.theme.appColors. 멋지죠? ✨ 추가로 유용한 확장 기능은 'Flutter에서 누락된 확장 기능'에 대한 제 논문에서 찾아볼 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n## 단계 2-3: 플러터에서 라이트 모드와 다크 모드 전환하는 방법\n\n플러터에서 라이트 모드와 다크 모드를 전환하려면 MaterialApp에서 theme 및 darkTheme 속성을 지정해야 합니다. 또한 앱의 현재 테마 모드를 결정하는 themeMode 속성도 제공해야 합니다. ThemeMode은 3가지 옵션을 가지고 있는 enum입니다:\n\n- ThemeMode.light\n- ThemeMode.dark\n- ThemeMode.system\n\n상태 관리를 위해 저는 ChangeNotifier를 사용했습니다. 더 복잡한 것을 사용할 필요가 없어서입니다. 나중에 BuildContext 없이 ThemeMode를 변경해야 할 경우 get_it 또는 사용하는 다른 패키지에 이 클래스를 등록할 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nclass AppTheme with ChangeNotifier {\n  ThemeMode _themeMode = ThemeMode.system;\n\n  ThemeMode get themeMode => _themeMode;\n\n  set themeMode(ThemeMode themeMode) {\n    _themeMode = themeMode;\n    notifyListeners();\n  }\n\n  ...\n}\n```\n\n이제 MaterialApp에 넣어 봅시다:\n\n```js\nvoid main() {\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return ChangeNotifierProvider(\n      // 1. MaterialApp 위에 AppTheme를 제공하여\n      // 모든 페이지에서 사용할 수 있습니다.\n      create: (_) => AppTheme(),\n      builder: (context, _) => MaterialApp(\n        title: 'Flutter Demo',\n        // 2. 라이트 테마를 제공합니다.\n        theme: AppTheme.light,\n        // 3. 다크 테마를 제공합니다.\n        darkTheme: AppTheme.dark,\n        // 4. AppTheme 변경 사항 (ThemeMode)을 감시합니다.\n        themeMode: context.watch<AppTheme>().themeMode,\n        debugShowCheckedModeBanner: false,\n        home: const MyHomePage(title: 'Flutter Demo Home Page'),\n      ),\n    );\n  }\n}\n```\n\n참고:\n\n\n<div class=\"content-ad\"></div>\n\n- ChangeNotifierProvider은 provider 패키지에서 제공됩니다. 이미 알고 계실 거라 믿어요 😅\n\n테마모드를 업데이트해보세요:\n\n```js\nvoid darkMode() {\n  context.read<AppTheme>().themeMode = ThemeMode.dark;\n}\n```\n\n축하합니다 🎉 ThemeExtension을 사용하여 사용자 정의 앱 테마를 만드셨군요. 이제는 커스텀 텍스트 스타일도 추가해볼까요?\n\n<div class=\"content-ad\"></div>\n\n# 플러터에서 ThemeExtension을 사용하여 사용자 지정 텍스트 스타일 추가하는 방법\n\n텍스트 스타일은 라이트 모드와 다크 모드 사이에 변경되지 않기 때문에 대부분의 경우, 테마 확장을 생성할 필요가 없고 간단한 const TextStyle 선언이 충분합니다. 그러나 두 가지 방법을 모두 보여드리겠습니다. 두 단계만으로 완성됩니다.\n\n## 단계 1: AppTypography\n\n이 클래스는 AppPalette와 동일한 용도로 사용되며 코드에서 디자인의 스타일을 정의합니다.\n\n<div class=\"content-ad\"></div>\n\n\n추상 클래스 AppTypography {\n  고정된 body1 = TextStyle(\n    fontSize: 16,\n    fontWeight: FontWeight.normal,\n  );\n\n  고정된 h1 = TextStyle(\n    fontSize: 96,\n    fontWeight: FontWeight.w300,\n  );\n}\n\n\n참고:\n\n- 만일 색상을 추가 클래스와 함께 그룹화하는 두 번째 방법이 마음에 들었다면, 이곳에서도 사용할 수 있습니다.\n\n이제 이러한 스타일을 다음과 같이 사용할 수 있습니다:\n\n\n<div class=\"content-ad\"></div>\n\n```dart\nstyle: AppTypography.h1.copyWith(color: context.theme.appColors.error)\n```\n\n## 플러터에서 Text 위젯을 위한 기본 TextStyle\n\nText 위젯을 위한 기본 TextStyle을 설정하려면 TextTheme에서 bodyMedium을 설정해야 합니다. 다음은 예제입니다:\n\n```dart\nstatic final light = () {\n    final defaultTheme = ThemeData.light();\n\n    return defaultTheme.copyWith(\n      textTheme: defaultTheme.textTheme.copyWith(\n        // 참고: Text 위젯을 위한 기본 텍스트 스타일\n        bodyMedium: AppTypography.body1.copyWith(color: Colors.black),\n      ),\n      extensions: [\n        _lightAppColors,\n      ],\n    );\n  }();\r\n```\n\n<div class=\"content-ad\"></div>\n\n## 단계 2: AppTextThemeExtension + 템플릿\n\n텍스트 스타일을 위한 ThemeExtension을 생성하려면 색상과 같은 방법을 따라야합니다.\n\n```js\nclass AppTextTheme extends ThemeExtension<AppTextTheme> {\n  const AppTextTheme({\n    required this.body1,\n    required this.h1,\n  });\n\n  final TextStyle body1;\n  final TextStyle h1;\n\n  @override\n    ThemeExtension<AppTextTheme> copyWith({\n    TextStyle? body1,\n    TextStyle? h1,\n  }) {\n    return AppTextTheme(\n      body1: body1 ?? this.body1,\n      h1: h1 ?? this.h1,\n    );\n  }\n\n  @override\n  ThemeExtension<AppTextTheme> lerp(\n    covariant ThemeExtension<AppTextTheme>? other,\n    double t,\n  ) {\n    if (other is! AppTextTheme) {\n      return this;\n    }\n\n    return AppTextTheme(\n      body1: TextStyle.lerp(body1, other.body1, t)!,\n      h1: TextStyle.lerp(h1, other.h1, t)!,\n    );\n  }\n}\n```\n\n위는 간단한 예제이지만, 여기에서는 내장된 TextTheme과 동일한 모든 (사용되지 않는) 속성을 갖춘 전체 템플릿을 제공합니다. 필요한 대로 추가, 이름 변경, 삭제할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n🔗 AppTextThemeExtension 템플릿\n\n친구야! Light와 Dark ThemeData에 이 확장 프로그램을 추가하지 않도록 잊지 마세요:\n\n```js\nclass AppTheme with ChangeNotifier {\n\n  ...\n\n  static final light = () {\n    final defaultTheme = ThemeData.light();\n\n    return defaultTheme.copyWith(\n      textTheme: defaultTheme.textTheme.copyWith(\n        // 참고: Text 위젯에 대한 기본 텍스트 스타일입니다.\n        bodyMedium: AppTypography.body1.copyWith(color: Colors.black),\n      ),\n      extensions: [\n        _lightAppColors,\n        // 1. 여기\n        _lightTextTheme,\n      ],\n    );\n  }();\n\n  static final _lightAppColors = ...;\n\n  // 2. 여기\n  static final _lightTextTheme = AppTextThemeExtension(\n    body1: AppTypography.body1.copyWith(color: _lightAppColors.onBackground),\n    h1: AppTypography.h1.copyWith(color: Colors.black),\n  );\n\n  ...\n\n}\n\nextension AppThemeExtension on ThemeData {\n  AppColorsExtension get appColors =>\n      extension<AppColorsExtension>() ?? AppTheme._lightAppColors;\n\n  // 3. 그리고 여기\n  AppTextThemeExtension get appTextTheme =>\n      extension<AppTextThemeExtension>() ?? AppTheme._lightTextTheme;\n}\n```\n\n🎉 다시 한 번 축하드려요! 이제는 TextStyles에 대한 ThemeExtension이 생겼어요. 아래 전체 소스 코드를 확인해보세요.\n\n<div class=\"content-ad\"></div>\n\n# 마무리\n\n## 소스 코드\n\n템플릿:\n\n- 🔗 AppColorsExtension\n- 🔗 AppTextThemeExtension\n\n<div class=\"content-ad\"></div>\n\n풀 앱 예시:\n\n## 확장 가능한 부분\n\n- get_it이나 다른 패키지에 AppTheme을 등록하여 BuildContext 없이 액세스할 수 있습니다.\n- 선택한 ThemeMode를 shared_preferences에 저장합니다.\n\n## Flutter ThemeExtension 생성기\n\n<div class=\"content-ad\"></div>\n\n그 패키지는 ThemeExtension을 생성하는 것을 볼 수 있었지만, 나는 항상 최소한의 생성이 좋다고 생각해서 사용해보지는 않았어. 게다가, GitHub Copilot을 사용하면 필요한 보일러플레이트 코드를 쉽게 작성할 수 있어.\n\n## 더 많은 자료\n\n- 테마 문서.\n- ThemeExtension 문서.\n- DefaultTextStyle.merge() — 사용자 정의 위젯에서 기본 TextStyle을 처리하는 데 도움이 됨.\n\n읽어주셔서 감사합니다. 안녕 👋","ogImage":{"url":"/assets/img/2024-06-21-FlutterCustomThemewithThemeExtensionTemplates_0.png"},"coverImage":"/assets/img/2024-06-21-FlutterCustomThemewithThemeExtensionTemplates_0.png","tag":["Tech"],"readingTime":13}],"page":"9","totalPageCount":21,"totalPageGroupCount":2,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}