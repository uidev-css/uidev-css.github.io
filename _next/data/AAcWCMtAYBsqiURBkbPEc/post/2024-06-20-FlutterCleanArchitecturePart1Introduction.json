{"pageProps":{"post":{"title":"Flutter의 Clean Architecture 파트1 - 소개","description":"","date":"2024-06-20 13:46","slug":"2024-06-20-FlutterCleanArchitecturePart1Introduction","content":"\n\n\n![image](/assets/img/2024-06-20-FlutterCleanArchitecturePart1Introduction_0.png)\n\n소프트웨어 개발에서는 체계적이고 유지보수 가능한 코드베이스를 유지하는 것이 매우 중요합니다. 이때 Clean Architecture가 등장하여 코드베이스를 모듈식, 독립적이고 테스트 가능한 방식으로 구성하는 데 도움을 줍니다. 이 글에서는 Clean Architecture가 무엇인지, Flutter에서 어떻게 구현하는지, 그리고 프로젝트에 어떤 이점을 가져다 줄 수 있는지 살펴보겠습니다.\n\n커피를 마시고 준비하세요! 오랜 여정이 시작됩니다.\n\n## Flutter에서 Clean Architecture를 사용해야 하는 이유\n\n\n<div class=\"content-ad\"></div>\n\n클린 아키텍처는 모듈화, 유지보수 가능성, 테스트 가능성을 향상시켜 주는 소프트웨어 설계 철학입니다. 각 층으로 코드를 분리하여 애플리케이션을 구조화하며, 크고 복잡한 앱에 특히 유용합니다.\n\n## 장점\n\n- 모듈성과 독립성: 애플리케이션을 독립적인 부분으로 분할하고 각각을 별도로 관리 및 개발합니다.\n- 쉬운 테스트 가능성: 비즈니스 로직을 독립적으로 테스트하여 오류를 감지하기 쉽습니다.\n- 테스트 주도 개발 (TDD): TDD 원칙과 잘 부합합니다. 먼저 비즈니스 로직에 대한 테스트를 작성한 후 그 테스트를 통과할 코드를 구현할 수 있습니다.\n- 미래 확장성: 새로운 기능을 추가하거나 기존 기능을 수정하는 데 더 적은 노력이 필요합니다.\n- 재사용성: 비즈니스 로직을 다른 프로젝트나 플랫폼에서 재사용할 수 있습니다.\n- 관심사 분리: 비즈니스 로직과 사용자 인터페이스 (UI) 사이의 명확한 경계를 유지함으로써 팀 구성을 더 잘 조직화할 수 있습니다.\n- 유지보수 용이성: 층 간 의존성을 줄여 코드 유지보수를 단순화합니다.\n- 변경에 대한 유연성: 데이터 소스나 서비스를 변경하기 쉽게 합니다.\n- 좋은 문서화: 프로젝트 이해와 유지보수를 위해 구조와 작동원리를 명확히 정의합니다.\n\n클린 아키텍처는 데이터층, 도메인층, 프레젠테이션 층으로 구성되어 있습니다. 각 층은 구별된 책임과 제한된 의존성을 가지고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-20-FlutterCleanArchitecturePart1Introduction_1.png)\n\n코딩을 시작하기 전에 짧게 예제에 대해 설명하겠습니다:\n\nTMDB 플랫폼의 API를 사용하여 기본 영화 애플리케이션을 구축할 예정입니다. 이 응용 프로그램은 API에서 인기 있는 및 최상위 영화 목록을 검색하고 표시할 것입니다. 사용자는 배우 세부 정보를 포함한 영화 정보에 액세스할 수 있습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:600/1*opIWWgVq6ZlP_x5sdV0LDA.gif)\n\n\n<div class=\"content-ad\"></div>\n\n사용할 패키지 목록\n\n```js\ndependencies:\n  # 라우팅을 위해 => https://pub.dev/packages/auto_route\n  auto_route: ^7.8.3\n\n  # 이미지 캐싱을 위해 => https://pub.dev/packages/cached_network_image\n  cached_network_image: ^3.3.0\n\n  # 네트워크 요청을 위해 => https://pub.dev/packages/dio\n  dio: ^5.3.3\n\n  # 동등성을 위해 => https://pub.dev/packages/equatable\n  equatable: ^2.0.5\n\n  # 테마를 위해 => https://pub.dev/packages/flex_color_scheme\n  flex_color_scheme: ^7.3.1\n\n  flutter:\n    sdk: flutter\n\n  # 상태 관리를 위해 => https://pub.dev/packages/flutter_bloc\n  flutter_bloc: ^8.1.3\n\n  # 환경 변수를 위해 => https://pub.dev/packages/flutter_dotenv\n  flutter_dotenv: ^5.1.0\n\n  # 자산 코드 생성을 위해 => https://pub.dev/packages/flutter_gen\n  flutter_gen: ^5.4.0\n\n  # 유용한 훅을 위해 => https://pub.dev/packages/flutter_hooks\n  flutter_hooks: ^0.20.3\n\n  # 책임성을 위해 => https://pub.dev/packages/flutter_screenutil\n  flutter_screenutil: ^5.9.0\n\n  # SVG를 위해 => https://pub.dev/packages/flutter_svg\n  flutter_svg: ^2.0.9\n\n  # 함수형 프로그래밍을 위해 => https://pub.dev/packages/fpdart\n  fpdart: ^1.1.0\n\n  # 의존성 주입을 위해 => https://pub.dev/packages/get_it\n  get_it: ^7.6.4\n\n  # 테마 또는 로캘 관리를 위해 => https://pub.dev/packages/hydrated_bloc\n  hydrated_bloc: ^9.1.2\n\n  intl: ^0.19.0\n\n  # 로컬 데이터 소스를 위해\n  isar: ^3.1.0+1\n  isar_flutter_libs: ^3.1.0+1\n\n  # API 모델 생성을 위해 => https://pub.dev/packages/json_annotation\n  json_annotation: ^4.8.1\n\n  # 앱 데이터 디렉토리\n  path_provider: ^2.1.1\n\n  # 개발자를 위한 dio 인터셉터 => https://pub.dev/packages/pretty_dio_logger\n  pretty_dio_logger: ^1.3.1\n\n  # 반짝거림 효과를 위해 => https://pub.dev/packages/shimmer\n  shimmer: ^3.0.0\n\n  # URL 런처를 위해 => https://pub.dev/packages/url_launcher\n  url_launcher: ^6.2.2\n\ndev_dependencies:\n  # auto_route 생성기 => https://pub.dev/packages/auto_route_generator\n  auto_route_generator: ^7.3.1\n\n  # bloc 테스트를 위해 => https://pub.dev/packages/bloc_test\n  bloc_test: ^9.1.4\n\n  build_runner: ^2.4.6\n  flutter_gen_runner: ^5.4.0\n  flutter_lints: ^3.0.1\n  flutter_test:\n    sdk: flutter\n\n  # 로컬 데이터 소스\n  isar_generator: ^3.1.0+1\n\n  # API 모델 생성을 위해 => https://pub.dev/packages/json_serializable\n  json_serializable: ^6.7.1\n\n  # 테스트를 위해 => https://pub.dev/packages/mockito\n  mockito: ^5.4.4\n```\n\n## HTTP 요청\n\nflutter_dotenv 패키지를 사용하여 간단한 애플리케이션 상수 클래스를 만들어 봅시다.\n\n<div class=\"content-ad\"></div>\n\n```js\nclass AppConstants {\n  final baseUrl = '${dotenv.env['BASE_URL']}'; //* https://api.themoviedb.org/3\n  final apiToken = '${dotenv.env['API_TOKEN']}'; //* your TMDB token. (sign up here https://developer.themoviedb.org/docs)\n}\n```\n\nHTTP 요청을 위한 클래스를 만들어 봅시다. DioClient 클래스는 API 요청을 보내고 json 데이터를 반환할 것입니다. 여기서 주요 목적은 DioClient 클래스를 get, post, put, patch, delete 메서드로 제한하는 것입니다.\n\n저희 애플리케이션에서는 하나의 API만 사용할 것이므로, Dio를 사용하기 때문에 DioClient라고 이름 짓겠습니다. 애플리케이션이 여러 개의 API와 통신해야 하는 경우, HTTP 요청을 보내는 DioClient와 유사한 클래스가 필요합니다. 이것은 각 네트워크 클래스가 관련된 데이터 원본과 관련되어야 하기 때문입니다.\n\n예를 들어, 영화 데이터에 대해 TMDB API를 사용하고 배우에 대해 BlaBla API를 사용하는 경우, 명명 규칙에 유의해야 합니다. 네이밍의 예시로는 TmdbNetworkManager, BlaBlaClient, CatClient 등이 있을 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\nclass DioClient {\n  Dio _dio;\n\n  DioClient() {\n    _dio = Dio();\n    _dio\n      ..options.baseUrl = AppConstants.baseUrl\n      ..options.headers = {\n        HttpHeaders.contentTypeHeader: ContentType.json.mimeType,\n        HttpHeaders.authorizationHeader: 'Bearer ${AppConstants.apiToken}',\n      }\n      ..options.connectTimeout = const Duration(milliseconds: 15000)\n      ..options.receiveTimeout = const Duration(milliseconds: 15000)\n      ..options.responseType = ResponseType.json\n      ..interceptors.add(\n        PrettyDioLogger(\n          compact: false,\n          logPrint: (object) => log(object.toString(), name: 'TMDB API'),\n        ),\n      );\n  }\n\n  /// * GET\n  Future<Response> get(\n    String url, {\n    Map<String, dynamic>? queryParameters,\n    Options? options,\n    CancelToken? cancelToken,\n    ProgressCallback? onReceiveProgress,\n  }) async {\n    try {\n      final response = await _dio.get(\n        url,\n        queryParameters: queryParameters,\n        options: options,\n        cancelToken: cancelToken,\n        onReceiveProgress: onReceiveProgress,\n      );\n      return response;\n    } on DioException {\n      rethrow;\n    }\n  }\n\n  /// * POST\n  Future<Response> post(\n    String uri, {\n    data,\n    Map<String, dynamic>? queryParameters,\n    Options? options,\n    CancelToken? cancelToken,\n    ProgressCallback? onSendProgress,\n    ProgressCallback? onReceiveProgress,\n  }) async {\n    try {\n      final response = await _dio.post(\n        uri,\n        data: data,\n        queryParameters: queryParameters,\n        options: options,\n        cancelToken: cancelToken,\n        onSendProgress: onSendProgress,\n        onReceiveProgress: onReceiveProgress,\n      );\n      return response;\n    } on DioException {\n      rethrow;\n    }\n  }\n\n  /// * PUT\n  Future<Response> put(\n    String uri, {\n    data,\n    Map<String, dynamic>? queryParameters,\n    Options? options,\n    CancelToken? cancelToken,\n    ProgressCallback? onSendProgress,\n    ProgressCallback? onReceiveProgress,\n  }) async {\n    try {\n      final response = await _dio.put(\n        uri,\n        data: data,\n        queryParameters: queryParameters,\n        options: options,\n        cancelToken: cancelToken,\n        onSendProgress: onSendProgress,\n        onReceiveProgress: onReceiveProgress,\n      );\n      return response;\n    } on DioException {\n      rethrow;\n    }\n  }\n\n  /// * PATCH\n  Future<Response> patch(\n    String uri, {\n    data,\n    Map<String, dynamic>? queryParameters,\n    Options? options,\n    CancelToken? cancelToken,\n    ProgressCallback? onSendProgress,\n    ProgressCallback? onReceiveProgress,\n  }) async {\n    try {\n      final response = await _dio.patch(\n        uri,\n        data: data,\n        queryParameters: queryParameters,\n        options: options,\n        cancelToken: cancelToken,\n        onSendProgress: onSendProgress,\n        onReceiveProgress: onReceiveProgress,\n      );\n      return response;\n    } on DioException {\n      rethrow;\n    }\n  }\n\n  /// * DELETE\n  Future<dynamic> delete(\n    String uri, {\n    data,\n    Map<String, dynamic>? queryParameters,\n    Options? options,\n    CancelToken? cancelToken,\n    ProgressCallback? onSendProgress,\n    ProgressCallback? onReceiveProgress,\n  }) async {\n    try {\n      final response = await _dio.delete(\n        uri,\n        data: data,\n        queryParameters: queryParameters,\n        options: options,\n        cancelToken: cancelToken,\n      );\n      return response;\n    } on DioException {\n      rethrow;\n    }\n  }\n}\n```\n\n## 네트워크 오류 모델\n\n네트워크 오류 모델을 만들어봅시다. 이 모델은 나쁜 응답 오류가 발생할 때 생성되므로 API에서 오류 메시지를 표시할 수 있습니다.\n\nTMDB API의 오류 모델은 아래와 같습니다.\n\n<div class=\"content-ad\"></div>\n\n```json\n@JsonSerializable()\nclass NetworkErrorModel extends Equatable {\n  @JsonKey(name: 'status_code')\n  final int? statusCode;\n  @JsonKey(name: 'status_message')\n  final String? statusMessage;\n\n  const NetworkErrorModel({this.statusCode, this.statusMessage});\n\n  factory NetworkErrorModel.fromJson(Map<String, dynamic> json) {\n    return _$NetworkErrorModelFromJson(json);\n  }\n\n  Map<String, dynamic> toJson() => _$NetworkErrorModelToJson(this);\n\n  @override\n  List<Object?> get props => [statusCode, statusMessage];\n}\n```\n\n## 로컬 데이터베이스\n\n데이터베이스에 접근하는 클래스를 만들어 봅시다.\n\n```json\n/// 로컬 데이터베이스를 나타내는 클래스.\n///\n/// 이 클래스는 Isar 데이터베이스를 초기화하고 액세스하는 방법을 제공합니다.\nclass LocalDatabase {\n  late final Isar _isar;\n  bool _isInitialized = false;\n\n  /// 초기화된 Isar 데이터베이스 인스턴스를 반환합니다.\n  ///\n  /// 데이터베이스가 초기화되지 않은 경우 [IsarError]를 throw합니다.\n  Isar get db => _isInitialized ? _isar : throw IsarError('Isar가 초기화되지 않았습니다.');\n\n  /// Isar 데이터베이스를 초기화합니다.\n  ///\n  /// 데이터베이스가 이미 초기화된 경우 [IsarError]를 throw합니다.\n  Future<void> initialize() async {\n    if (_isInitialized) throw IsarError('Isar가 이미 초기화되었습니다.');\n\n    final directory = await getApplicationDocumentsDirectory();\n    _isar = await Isar.open([MovieDetailCollectionSchema], directory: directory.path);\n\n    _isInitialized = true;\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## 에러 처리\n\nDioException을 사용하여 네트워크 오류를 처리하는 클래스를 만들어 보겠습니다.\n\n```js\nclass NetworkException extends Equatable implements Exception {\n  late final String message;\n  late final int? statusCode;\n\n  NetworkException.fromDioError(DioException dioException) {\n    statusCode = dioException.response?.statusCode;\n\n    switch (dioException.type) {\n      case DioExceptionType.cancel:\n        message = 'API 서버로의 요청이 취소되었습니다';\n        break;\n\n      case DioExceptionType.connectionTimeout:\n        message = 'API 서버와의 연결 시간 초과';\n        break;\n\n      case DioExceptionType.receiveTimeout:\n        message = 'API 서버와의 연결 중 수신 시간 초과';\n        break;\n\n      case DioExceptionType.sendTimeout:\n        message = 'API 서버와의 연결 중 송신 시간 초과';\n        break;\n\n      case DioExceptionType.connectionError:\n        if (dioException.error.runtimeType == SocketException) {\n          message = '인터넷 연결을 확인해주세요';\n          break;\n        } else {\n          message = '예기치 않은 오류가 발생했습니다';\n          break;\n        }\n\n      case DioExceptionType.badCertificate:\n        message = '잘못된 인증서';\n        break;\n\n      case DioExceptionType.badResponse:\n        final model = NetworkErrorModel.fromJson(dioException.response?.data as Map<String, dynamic>);\n        message = model.statusMessage ?? '예기치 않은 오류가 발생했습니다';\n        break;\n\n      case DioExceptionType.unknown:\n        message = '예기치 않은 오류가 발생했습니다';\n        break;\n    }\n  }\n\n  @override\n  List<Object?> get props => [message, statusCode];\n}\n```\n\n그리고 IsarError를 사용하여 로컬 데이터베이스 오류를 처리하는 클래스를 만들어 보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nclass DatabaseException extends Equatable implements Exception {\n  late final String message;\n\n  DatabaseException.fromIsarError(IsarError isarError) : message = isarError.message;\n\n  @override\n  List<Object?> get props => [message];\n}\n```\n\n알겠어요! 여기까지입니다. 이 부분에서는 여기까지 언급할 거예요.\n\n이제 Clean Architecture에 대해 준비되었습니다.\n\n다음 파트\n","ogImage":{"url":"/assets/img/2024-06-20-FlutterCleanArchitecturePart1Introduction_0.png"},"coverImage":"/assets/img/2024-06-20-FlutterCleanArchitecturePart1Introduction_0.png","tag":["Tech"],"readingTime":12},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-06-20-FlutterCleanArchitecturePart1Introduction_0.png\" alt=\"image\"></p>\n<p>소프트웨어 개발에서는 체계적이고 유지보수 가능한 코드베이스를 유지하는 것이 매우 중요합니다. 이때 Clean Architecture가 등장하여 코드베이스를 모듈식, 독립적이고 테스트 가능한 방식으로 구성하는 데 도움을 줍니다. 이 글에서는 Clean Architecture가 무엇인지, Flutter에서 어떻게 구현하는지, 그리고 프로젝트에 어떤 이점을 가져다 줄 수 있는지 살펴보겠습니다.</p>\n<p>커피를 마시고 준비하세요! 오랜 여정이 시작됩니다.</p>\n<h2>Flutter에서 Clean Architecture를 사용해야 하는 이유</h2>\n<p>클린 아키텍처는 모듈화, 유지보수 가능성, 테스트 가능성을 향상시켜 주는 소프트웨어 설계 철학입니다. 각 층으로 코드를 분리하여 애플리케이션을 구조화하며, 크고 복잡한 앱에 특히 유용합니다.</p>\n<h2>장점</h2>\n<ul>\n<li>모듈성과 독립성: 애플리케이션을 독립적인 부분으로 분할하고 각각을 별도로 관리 및 개발합니다.</li>\n<li>쉬운 테스트 가능성: 비즈니스 로직을 독립적으로 테스트하여 오류를 감지하기 쉽습니다.</li>\n<li>테스트 주도 개발 (TDD): TDD 원칙과 잘 부합합니다. 먼저 비즈니스 로직에 대한 테스트를 작성한 후 그 테스트를 통과할 코드를 구현할 수 있습니다.</li>\n<li>미래 확장성: 새로운 기능을 추가하거나 기존 기능을 수정하는 데 더 적은 노력이 필요합니다.</li>\n<li>재사용성: 비즈니스 로직을 다른 프로젝트나 플랫폼에서 재사용할 수 있습니다.</li>\n<li>관심사 분리: 비즈니스 로직과 사용자 인터페이스 (UI) 사이의 명확한 경계를 유지함으로써 팀 구성을 더 잘 조직화할 수 있습니다.</li>\n<li>유지보수 용이성: 층 간 의존성을 줄여 코드 유지보수를 단순화합니다.</li>\n<li>변경에 대한 유연성: 데이터 소스나 서비스를 변경하기 쉽게 합니다.</li>\n<li>좋은 문서화: 프로젝트 이해와 유지보수를 위해 구조와 작동원리를 명확히 정의합니다.</li>\n</ul>\n<p>클린 아키텍처는 데이터층, 도메인층, 프레젠테이션 층으로 구성되어 있습니다. 각 층은 구별된 책임과 제한된 의존성을 가지고 있습니다.</p>\n<p><img src=\"/assets/img/2024-06-20-FlutterCleanArchitecturePart1Introduction_1.png\" alt=\"이미지\"></p>\n<p>코딩을 시작하기 전에 짧게 예제에 대해 설명하겠습니다:</p>\n<p>TMDB 플랫폼의 API를 사용하여 기본 영화 애플리케이션을 구축할 예정입니다. 이 응용 프로그램은 API에서 인기 있는 및 최상위 영화 목록을 검색하고 표시할 것입니다. 사용자는 배우 세부 정보를 포함한 영화 정보에 액세스할 수 있습니다.</p>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:600/1*opIWWgVq6ZlP_x5sdV0LDA.gif\" alt=\"이미지\"></p>\n<p>사용할 패키지 목록</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-attr\">dependencies</span>:\n  # 라우팅을 위해 => <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//pub.dev/packages/auto_route</span>\n  <span class=\"hljs-attr\">auto_route</span>: ^<span class=\"hljs-number\">7.8</span><span class=\"hljs-number\">.3</span>\n\n  # 이미지 캐싱을 위해 => <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//pub.dev/packages/cached_network_image</span>\n  <span class=\"hljs-attr\">cached_network_image</span>: ^<span class=\"hljs-number\">3.3</span><span class=\"hljs-number\">.0</span>\n\n  # 네트워크 요청을 위해 => <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//pub.dev/packages/dio</span>\n  <span class=\"hljs-attr\">dio</span>: ^<span class=\"hljs-number\">5.3</span><span class=\"hljs-number\">.3</span>\n\n  # 동등성을 위해 => <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//pub.dev/packages/equatable</span>\n  <span class=\"hljs-attr\">equatable</span>: ^<span class=\"hljs-number\">2.0</span><span class=\"hljs-number\">.5</span>\n\n  # 테마를 위해 => <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//pub.dev/packages/flex_color_scheme</span>\n  <span class=\"hljs-attr\">flex_color_scheme</span>: ^<span class=\"hljs-number\">7.3</span><span class=\"hljs-number\">.1</span>\n\n  <span class=\"hljs-attr\">flutter</span>:\n    <span class=\"hljs-attr\">sdk</span>: flutter\n\n  # 상태 관리를 위해 => <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//pub.dev/packages/flutter_bloc</span>\n  <span class=\"hljs-attr\">flutter_bloc</span>: ^<span class=\"hljs-number\">8.1</span><span class=\"hljs-number\">.3</span>\n\n  # 환경 변수를 위해 => <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//pub.dev/packages/flutter_dotenv</span>\n  <span class=\"hljs-attr\">flutter_dotenv</span>: ^<span class=\"hljs-number\">5.1</span><span class=\"hljs-number\">.0</span>\n\n  # 자산 코드 생성을 위해 => <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//pub.dev/packages/flutter_gen</span>\n  <span class=\"hljs-attr\">flutter_gen</span>: ^<span class=\"hljs-number\">5.4</span><span class=\"hljs-number\">.0</span>\n\n  # 유용한 훅을 위해 => <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//pub.dev/packages/flutter_hooks</span>\n  <span class=\"hljs-attr\">flutter_hooks</span>: ^<span class=\"hljs-number\">0.20</span><span class=\"hljs-number\">.3</span>\n\n  # 책임성을 위해 => <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//pub.dev/packages/flutter_screenutil</span>\n  <span class=\"hljs-attr\">flutter_screenutil</span>: ^<span class=\"hljs-number\">5.9</span><span class=\"hljs-number\">.0</span>\n\n  # <span class=\"hljs-variable constant_\">SVG</span>를 위해 => <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//pub.dev/packages/flutter_svg</span>\n  <span class=\"hljs-attr\">flutter_svg</span>: ^<span class=\"hljs-number\">2.0</span><span class=\"hljs-number\">.9</span>\n\n  # 함수형 프로그래밍을 위해 => <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//pub.dev/packages/fpdart</span>\n  <span class=\"hljs-attr\">fpdart</span>: ^<span class=\"hljs-number\">1.1</span><span class=\"hljs-number\">.0</span>\n\n  # 의존성 주입을 위해 => <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//pub.dev/packages/get_it</span>\n  <span class=\"hljs-attr\">get_it</span>: ^<span class=\"hljs-number\">7.6</span><span class=\"hljs-number\">.4</span>\n\n  # 테마 또는 로캘 관리를 위해 => <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//pub.dev/packages/hydrated_bloc</span>\n  <span class=\"hljs-attr\">hydrated_bloc</span>: ^<span class=\"hljs-number\">9.1</span><span class=\"hljs-number\">.2</span>\n\n  <span class=\"hljs-attr\">intl</span>: ^<span class=\"hljs-number\">0.19</span><span class=\"hljs-number\">.0</span>\n\n  # 로컬 데이터 소스를 위해\n  <span class=\"hljs-attr\">isar</span>: ^<span class=\"hljs-number\">3.1</span><span class=\"hljs-number\">.0</span>+<span class=\"hljs-number\">1</span>\n  <span class=\"hljs-attr\">isar_flutter_libs</span>: ^<span class=\"hljs-number\">3.1</span><span class=\"hljs-number\">.0</span>+<span class=\"hljs-number\">1</span>\n\n  # <span class=\"hljs-variable constant_\">API</span> 모델 생성을 위해 => <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//pub.dev/packages/json_annotation</span>\n  <span class=\"hljs-attr\">json_annotation</span>: ^<span class=\"hljs-number\">4.8</span><span class=\"hljs-number\">.1</span>\n\n  # 앱 데이터 디렉토리\n  <span class=\"hljs-attr\">path_provider</span>: ^<span class=\"hljs-number\">2.1</span><span class=\"hljs-number\">.1</span>\n\n  # 개발자를 위한 dio 인터셉터 => <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//pub.dev/packages/pretty_dio_logger</span>\n  <span class=\"hljs-attr\">pretty_dio_logger</span>: ^<span class=\"hljs-number\">1.3</span><span class=\"hljs-number\">.1</span>\n\n  # 반짝거림 효과를 위해 => <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//pub.dev/packages/shimmer</span>\n  <span class=\"hljs-attr\">shimmer</span>: ^<span class=\"hljs-number\">3.0</span><span class=\"hljs-number\">.0</span>\n\n  # <span class=\"hljs-variable constant_\">URL</span> 런처를 위해 => <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//pub.dev/packages/url_launcher</span>\n  <span class=\"hljs-attr\">url_launcher</span>: ^<span class=\"hljs-number\">6.2</span><span class=\"hljs-number\">.2</span>\n\n<span class=\"hljs-attr\">dev_dependencies</span>:\n  # auto_route 생성기 => <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//pub.dev/packages/auto_route_generator</span>\n  <span class=\"hljs-attr\">auto_route_generator</span>: ^<span class=\"hljs-number\">7.3</span><span class=\"hljs-number\">.1</span>\n\n  # bloc 테스트를 위해 => <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//pub.dev/packages/bloc_test</span>\n  <span class=\"hljs-attr\">bloc_test</span>: ^<span class=\"hljs-number\">9.1</span><span class=\"hljs-number\">.4</span>\n\n  <span class=\"hljs-attr\">build_runner</span>: ^<span class=\"hljs-number\">2.4</span><span class=\"hljs-number\">.6</span>\n  <span class=\"hljs-attr\">flutter_gen_runner</span>: ^<span class=\"hljs-number\">5.4</span><span class=\"hljs-number\">.0</span>\n  <span class=\"hljs-attr\">flutter_lints</span>: ^<span class=\"hljs-number\">3.0</span><span class=\"hljs-number\">.1</span>\n  <span class=\"hljs-attr\">flutter_test</span>:\n    <span class=\"hljs-attr\">sdk</span>: flutter\n\n  # 로컬 데이터 소스\n  <span class=\"hljs-attr\">isar_generator</span>: ^<span class=\"hljs-number\">3.1</span><span class=\"hljs-number\">.0</span>+<span class=\"hljs-number\">1</span>\n\n  # <span class=\"hljs-variable constant_\">API</span> 모델 생성을 위해 => <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//pub.dev/packages/json_serializable</span>\n  <span class=\"hljs-attr\">json_serializable</span>: ^<span class=\"hljs-number\">6.7</span><span class=\"hljs-number\">.1</span>\n\n  # 테스트를 위해 => <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//pub.dev/packages/mockito</span>\n  <span class=\"hljs-attr\">mockito</span>: ^<span class=\"hljs-number\">5.4</span><span class=\"hljs-number\">.4</span>\n</code></pre>\n<h2>HTTP 요청</h2>\n<p>flutter_dotenv 패키지를 사용하여 간단한 애플리케이션 상수 클래스를 만들어 봅시다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AppConstants</span> {\n  final baseUrl = <span class=\"hljs-string\">'${dotenv.env['</span><span class=\"hljs-variable constant_\">BASE_URL</span><span class=\"hljs-string\">']}'</span>; <span class=\"hljs-comment\">//* https://api.themoviedb.org/3</span>\n  final apiToken = <span class=\"hljs-string\">'${dotenv.env['</span><span class=\"hljs-variable constant_\">API_TOKEN</span><span class=\"hljs-string\">']}'</span>; <span class=\"hljs-comment\">//* your TMDB token. (sign up here https://developer.themoviedb.org/docs)</span>\n}\n</code></pre>\n<p>HTTP 요청을 위한 클래스를 만들어 봅시다. DioClient 클래스는 API 요청을 보내고 json 데이터를 반환할 것입니다. 여기서 주요 목적은 DioClient 클래스를 get, post, put, patch, delete 메서드로 제한하는 것입니다.</p>\n<p>저희 애플리케이션에서는 하나의 API만 사용할 것이므로, Dio를 사용하기 때문에 DioClient라고 이름 짓겠습니다. 애플리케이션이 여러 개의 API와 통신해야 하는 경우, HTTP 요청을 보내는 DioClient와 유사한 클래스가 필요합니다. 이것은 각 네트워크 클래스가 관련된 데이터 원본과 관련되어야 하기 때문입니다.</p>\n<p>예를 들어, 영화 데이터에 대해 TMDB API를 사용하고 배우에 대해 BlaBla API를 사용하는 경우, 명명 규칙에 유의해야 합니다. 네이밍의 예시로는 TmdbNetworkManager, BlaBlaClient, CatClient 등이 있을 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DioClient</span> {\n  <span class=\"hljs-title class_\">Dio</span> _dio;\n\n  <span class=\"hljs-title class_\">DioClient</span>() {\n    _dio = <span class=\"hljs-title class_\">Dio</span>();\n    _dio\n      ..<span class=\"hljs-property\">options</span>.<span class=\"hljs-property\">baseUrl</span> = <span class=\"hljs-title class_\">AppConstants</span>.<span class=\"hljs-property\">baseUrl</span>\n      ..<span class=\"hljs-property\">options</span>.<span class=\"hljs-property\">headers</span> = {\n        <span class=\"hljs-title class_\">HttpHeaders</span>.<span class=\"hljs-property\">contentTypeHeader</span>: <span class=\"hljs-title class_\">ContentType</span>.<span class=\"hljs-property\">json</span>.<span class=\"hljs-property\">mimeType</span>,\n        <span class=\"hljs-title class_\">HttpHeaders</span>.<span class=\"hljs-property\">authorizationHeader</span>: <span class=\"hljs-string\">'Bearer ${AppConstants.apiToken}'</span>,\n      }\n      ..<span class=\"hljs-property\">options</span>.<span class=\"hljs-property\">connectTimeout</span> = <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Duration</span>(<span class=\"hljs-attr\">milliseconds</span>: <span class=\"hljs-number\">15000</span>)\n      ..<span class=\"hljs-property\">options</span>.<span class=\"hljs-property\">receiveTimeout</span> = <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Duration</span>(<span class=\"hljs-attr\">milliseconds</span>: <span class=\"hljs-number\">15000</span>)\n      ..<span class=\"hljs-property\">options</span>.<span class=\"hljs-property\">responseType</span> = <span class=\"hljs-title class_\">ResponseType</span>.<span class=\"hljs-property\">json</span>\n      ..<span class=\"hljs-property\">interceptors</span>.<span class=\"hljs-title function_\">add</span>(\n        <span class=\"hljs-title class_\">PrettyDioLogger</span>(\n          <span class=\"hljs-attr\">compact</span>: <span class=\"hljs-literal\">false</span>,\n          <span class=\"hljs-attr\">logPrint</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">object</span>) =></span> <span class=\"hljs-title function_\">log</span>(object.<span class=\"hljs-title function_\">toString</span>(), <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'TMDB API'</span>),\n        ),\n      );\n  }\n\n  <span class=\"hljs-comment\">/// * GET</span>\n  <span class=\"hljs-title class_\">Future</span>&#x3C;<span class=\"hljs-title class_\">Response</span>> <span class=\"hljs-title function_\">get</span>(\n    <span class=\"hljs-title class_\">String</span> url, {\n    <span class=\"hljs-title class_\">Map</span>&#x3C;<span class=\"hljs-title class_\">String</span>, dynamic>? queryParameters,\n    <span class=\"hljs-title class_\">Options</span>? options,\n    <span class=\"hljs-title class_\">CancelToken</span>? cancelToken,\n    <span class=\"hljs-title class_\">ProgressCallback</span>? onReceiveProgress,\n  }) <span class=\"hljs-keyword\">async</span> {\n    <span class=\"hljs-keyword\">try</span> {\n      final response = <span class=\"hljs-keyword\">await</span> _dio.<span class=\"hljs-title function_\">get</span>(\n        url,\n        <span class=\"hljs-attr\">queryParameters</span>: queryParameters,\n        <span class=\"hljs-attr\">options</span>: options,\n        <span class=\"hljs-attr\">cancelToken</span>: cancelToken,\n        <span class=\"hljs-attr\">onReceiveProgress</span>: onReceiveProgress,\n      );\n      <span class=\"hljs-keyword\">return</span> response;\n    } on <span class=\"hljs-title class_\">DioException</span> {\n      rethrow;\n    }\n  }\n\n  <span class=\"hljs-comment\">/// * POST</span>\n  <span class=\"hljs-title class_\">Future</span>&#x3C;<span class=\"hljs-title class_\">Response</span>> <span class=\"hljs-title function_\">post</span>(\n    <span class=\"hljs-title class_\">String</span> uri, {\n    data,\n    <span class=\"hljs-title class_\">Map</span>&#x3C;<span class=\"hljs-title class_\">String</span>, dynamic>? queryParameters,\n    <span class=\"hljs-title class_\">Options</span>? options,\n    <span class=\"hljs-title class_\">CancelToken</span>? cancelToken,\n    <span class=\"hljs-title class_\">ProgressCallback</span>? onSendProgress,\n    <span class=\"hljs-title class_\">ProgressCallback</span>? onReceiveProgress,\n  }) <span class=\"hljs-keyword\">async</span> {\n    <span class=\"hljs-keyword\">try</span> {\n      final response = <span class=\"hljs-keyword\">await</span> _dio.<span class=\"hljs-title function_\">post</span>(\n        uri,\n        <span class=\"hljs-attr\">data</span>: data,\n        <span class=\"hljs-attr\">queryParameters</span>: queryParameters,\n        <span class=\"hljs-attr\">options</span>: options,\n        <span class=\"hljs-attr\">cancelToken</span>: cancelToken,\n        <span class=\"hljs-attr\">onSendProgress</span>: onSendProgress,\n        <span class=\"hljs-attr\">onReceiveProgress</span>: onReceiveProgress,\n      );\n      <span class=\"hljs-keyword\">return</span> response;\n    } on <span class=\"hljs-title class_\">DioException</span> {\n      rethrow;\n    }\n  }\n\n  <span class=\"hljs-comment\">/// * PUT</span>\n  <span class=\"hljs-title class_\">Future</span>&#x3C;<span class=\"hljs-title class_\">Response</span>> <span class=\"hljs-title function_\">put</span>(\n    <span class=\"hljs-title class_\">String</span> uri, {\n    data,\n    <span class=\"hljs-title class_\">Map</span>&#x3C;<span class=\"hljs-title class_\">String</span>, dynamic>? queryParameters,\n    <span class=\"hljs-title class_\">Options</span>? options,\n    <span class=\"hljs-title class_\">CancelToken</span>? cancelToken,\n    <span class=\"hljs-title class_\">ProgressCallback</span>? onSendProgress,\n    <span class=\"hljs-title class_\">ProgressCallback</span>? onReceiveProgress,\n  }) <span class=\"hljs-keyword\">async</span> {\n    <span class=\"hljs-keyword\">try</span> {\n      final response = <span class=\"hljs-keyword\">await</span> _dio.<span class=\"hljs-title function_\">put</span>(\n        uri,\n        <span class=\"hljs-attr\">data</span>: data,\n        <span class=\"hljs-attr\">queryParameters</span>: queryParameters,\n        <span class=\"hljs-attr\">options</span>: options,\n        <span class=\"hljs-attr\">cancelToken</span>: cancelToken,\n        <span class=\"hljs-attr\">onSendProgress</span>: onSendProgress,\n        <span class=\"hljs-attr\">onReceiveProgress</span>: onReceiveProgress,\n      );\n      <span class=\"hljs-keyword\">return</span> response;\n    } on <span class=\"hljs-title class_\">DioException</span> {\n      rethrow;\n    }\n  }\n\n  <span class=\"hljs-comment\">/// * PATCH</span>\n  <span class=\"hljs-title class_\">Future</span>&#x3C;<span class=\"hljs-title class_\">Response</span>> <span class=\"hljs-title function_\">patch</span>(\n    <span class=\"hljs-title class_\">String</span> uri, {\n    data,\n    <span class=\"hljs-title class_\">Map</span>&#x3C;<span class=\"hljs-title class_\">String</span>, dynamic>? queryParameters,\n    <span class=\"hljs-title class_\">Options</span>? options,\n    <span class=\"hljs-title class_\">CancelToken</span>? cancelToken,\n    <span class=\"hljs-title class_\">ProgressCallback</span>? onSendProgress,\n    <span class=\"hljs-title class_\">ProgressCallback</span>? onReceiveProgress,\n  }) <span class=\"hljs-keyword\">async</span> {\n    <span class=\"hljs-keyword\">try</span> {\n      final response = <span class=\"hljs-keyword\">await</span> _dio.<span class=\"hljs-title function_\">patch</span>(\n        uri,\n        <span class=\"hljs-attr\">data</span>: data,\n        <span class=\"hljs-attr\">queryParameters</span>: queryParameters,\n        <span class=\"hljs-attr\">options</span>: options,\n        <span class=\"hljs-attr\">cancelToken</span>: cancelToken,\n        <span class=\"hljs-attr\">onSendProgress</span>: onSendProgress,\n        <span class=\"hljs-attr\">onReceiveProgress</span>: onReceiveProgress,\n      );\n      <span class=\"hljs-keyword\">return</span> response;\n    } on <span class=\"hljs-title class_\">DioException</span> {\n      rethrow;\n    }\n  }\n\n  <span class=\"hljs-comment\">/// * DELETE</span>\n  <span class=\"hljs-title class_\">Future</span>&#x3C;dynamic> <span class=\"hljs-title function_\">delete</span>(\n    <span class=\"hljs-title class_\">String</span> uri, {\n    data,\n    <span class=\"hljs-title class_\">Map</span>&#x3C;<span class=\"hljs-title class_\">String</span>, dynamic>? queryParameters,\n    <span class=\"hljs-title class_\">Options</span>? options,\n    <span class=\"hljs-title class_\">CancelToken</span>? cancelToken,\n    <span class=\"hljs-title class_\">ProgressCallback</span>? onSendProgress,\n    <span class=\"hljs-title class_\">ProgressCallback</span>? onReceiveProgress,\n  }) <span class=\"hljs-keyword\">async</span> {\n    <span class=\"hljs-keyword\">try</span> {\n      final response = <span class=\"hljs-keyword\">await</span> _dio.<span class=\"hljs-title function_\">delete</span>(\n        uri,\n        <span class=\"hljs-attr\">data</span>: data,\n        <span class=\"hljs-attr\">queryParameters</span>: queryParameters,\n        <span class=\"hljs-attr\">options</span>: options,\n        <span class=\"hljs-attr\">cancelToken</span>: cancelToken,\n      );\n      <span class=\"hljs-keyword\">return</span> response;\n    } on <span class=\"hljs-title class_\">DioException</span> {\n      rethrow;\n    }\n  }\n}\n</code></pre>\n<h2>네트워크 오류 모델</h2>\n<p>네트워크 오류 모델을 만들어봅시다. 이 모델은 나쁜 응답 오류가 발생할 때 생성되므로 API에서 오류 메시지를 표시할 수 있습니다.</p>\n<p>TMDB API의 오류 모델은 아래와 같습니다.</p>\n<pre><code class=\"hljs language-json\">@JsonSerializable()\nclass NetworkErrorModel extends Equatable <span class=\"hljs-punctuation\">{</span>\n  @JsonKey(name<span class=\"hljs-punctuation\">:</span> 'status_code')\n  final int? statusCode;\n  @JsonKey(name<span class=\"hljs-punctuation\">:</span> 'status_message')\n  final String? statusMessage;\n\n  const NetworkErrorModel(<span class=\"hljs-punctuation\">{</span>this.statusCode<span class=\"hljs-punctuation\">,</span> this.statusMessage<span class=\"hljs-punctuation\">}</span>);\n\n  factory NetworkErrorModel.fromJson(Map&#x3C;String<span class=\"hljs-punctuation\">,</span> dynamic> json) <span class=\"hljs-punctuation\">{</span>\n    return _$NetworkErrorModelFromJson(json);\n  <span class=\"hljs-punctuation\">}</span>\n\n  Map&#x3C;String<span class=\"hljs-punctuation\">,</span> dynamic> toJson() => _$NetworkErrorModelToJson(this);\n\n  @override\n  List&#x3C;Object?> get props => <span class=\"hljs-punctuation\">[</span>statusCode<span class=\"hljs-punctuation\">,</span> statusMessage<span class=\"hljs-punctuation\">]</span>;\n<span class=\"hljs-punctuation\">}</span>\n</code></pre>\n<h2>로컬 데이터베이스</h2>\n<p>데이터베이스에 접근하는 클래스를 만들어 봅시다.</p>\n<pre><code class=\"hljs language-json\"><span class=\"hljs-comment\">/// 로컬 데이터베이스를 나타내는 클래스.</span>\n<span class=\"hljs-comment\">///</span>\n<span class=\"hljs-comment\">/// 이 클래스는 Isar 데이터베이스를 초기화하고 액세스하는 방법을 제공합니다.</span>\nclass LocalDatabase <span class=\"hljs-punctuation\">{</span>\n  late final Isar _isar;\n  bool _isInitialized = <span class=\"hljs-literal\"><span class=\"hljs-keyword\">false</span></span>;\n\n  <span class=\"hljs-comment\">/// 초기화된 Isar 데이터베이스 인스턴스를 반환합니다.</span>\n  <span class=\"hljs-comment\">///</span>\n  <span class=\"hljs-comment\">/// 데이터베이스가 초기화되지 않은 경우 [IsarError]를 throw합니다.</span>\n  Isar get db => _isInitialized ? _isar <span class=\"hljs-punctuation\">:</span> throw IsarError('Isar가 초기화되지 않았습니다.');\n\n  <span class=\"hljs-comment\">/// Isar 데이터베이스를 초기화합니다.</span>\n  <span class=\"hljs-comment\">///</span>\n  <span class=\"hljs-comment\">/// 데이터베이스가 이미 초기화된 경우 [IsarError]를 throw합니다.</span>\n  Future&#x3C;void> initialize() async <span class=\"hljs-punctuation\">{</span>\n    if (_isInitialized) throw IsarError('Isar가 이미 초기화되었습니다.');\n\n    final directory = await getApplicationDocumentsDirectory();\n    _isar = await Isar.open(<span class=\"hljs-punctuation\">[</span>MovieDetailCollectionSchema<span class=\"hljs-punctuation\">]</span><span class=\"hljs-punctuation\">,</span> directory<span class=\"hljs-punctuation\">:</span> directory.path);\n\n    _isInitialized = <span class=\"hljs-literal\"><span class=\"hljs-keyword\">true</span></span>;\n  <span class=\"hljs-punctuation\">}</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre>\n<h2>에러 처리</h2>\n<p>DioException을 사용하여 네트워크 오류를 처리하는 클래스를 만들어 보겠습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">NetworkException</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Equatable</span> implements <span class=\"hljs-title class_\">Exception</span> {\n  late final <span class=\"hljs-title class_\">String</span> message;\n  late final int? statusCode;\n\n  <span class=\"hljs-title class_\">NetworkException</span>.<span class=\"hljs-title function_\">fromDioError</span>(<span class=\"hljs-params\">DioException dioException</span>) {\n    statusCode = dioException.<span class=\"hljs-property\">response</span>?.<span class=\"hljs-property\">statusCode</span>;\n\n    <span class=\"hljs-keyword\">switch</span> (dioException.<span class=\"hljs-property\">type</span>) {\n      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-title class_\">DioExceptionType</span>.<span class=\"hljs-property\">cancel</span>:\n        message = <span class=\"hljs-string\">'API 서버로의 요청이 취소되었습니다'</span>;\n        <span class=\"hljs-keyword\">break</span>;\n\n      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-title class_\">DioExceptionType</span>.<span class=\"hljs-property\">connectionTimeout</span>:\n        message = <span class=\"hljs-string\">'API 서버와의 연결 시간 초과'</span>;\n        <span class=\"hljs-keyword\">break</span>;\n\n      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-title class_\">DioExceptionType</span>.<span class=\"hljs-property\">receiveTimeout</span>:\n        message = <span class=\"hljs-string\">'API 서버와의 연결 중 수신 시간 초과'</span>;\n        <span class=\"hljs-keyword\">break</span>;\n\n      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-title class_\">DioExceptionType</span>.<span class=\"hljs-property\">sendTimeout</span>:\n        message = <span class=\"hljs-string\">'API 서버와의 연결 중 송신 시간 초과'</span>;\n        <span class=\"hljs-keyword\">break</span>;\n\n      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-title class_\">DioExceptionType</span>.<span class=\"hljs-property\">connectionError</span>:\n        <span class=\"hljs-keyword\">if</span> (dioException.<span class=\"hljs-property\">error</span>.<span class=\"hljs-property\">runtimeType</span> == <span class=\"hljs-title class_\">SocketException</span>) {\n          message = <span class=\"hljs-string\">'인터넷 연결을 확인해주세요'</span>;\n          <span class=\"hljs-keyword\">break</span>;\n        } <span class=\"hljs-keyword\">else</span> {\n          message = <span class=\"hljs-string\">'예기치 않은 오류가 발생했습니다'</span>;\n          <span class=\"hljs-keyword\">break</span>;\n        }\n\n      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-title class_\">DioExceptionType</span>.<span class=\"hljs-property\">badCertificate</span>:\n        message = <span class=\"hljs-string\">'잘못된 인증서'</span>;\n        <span class=\"hljs-keyword\">break</span>;\n\n      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-title class_\">DioExceptionType</span>.<span class=\"hljs-property\">badResponse</span>:\n        final model = <span class=\"hljs-title class_\">NetworkErrorModel</span>.<span class=\"hljs-title function_\">fromJson</span>(dioException.<span class=\"hljs-property\">response</span>?.<span class=\"hljs-property\">data</span> <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">Map</span>&#x3C;<span class=\"hljs-title class_\">String</span>, dynamic>);\n        message = model.<span class=\"hljs-property\">statusMessage</span> ?? <span class=\"hljs-string\">'예기치 않은 오류가 발생했습니다'</span>;\n        <span class=\"hljs-keyword\">break</span>;\n\n      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-title class_\">DioExceptionType</span>.<span class=\"hljs-property\">unknown</span>:\n        message = <span class=\"hljs-string\">'예기치 않은 오류가 발생했습니다'</span>;\n        <span class=\"hljs-keyword\">break</span>;\n    }\n  }\n\n  @override\n  <span class=\"hljs-title class_\">List</span>&#x3C;<span class=\"hljs-title class_\">Object</span>?> get props => [message, statusCode];\n}\n</code></pre>\n<p>그리고 IsarError를 사용하여 로컬 데이터베이스 오류를 처리하는 클래스를 만들어 보겠습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DatabaseException</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Equatable</span> implements <span class=\"hljs-title class_\">Exception</span> {\n  late final <span class=\"hljs-title class_\">String</span> message;\n\n  <span class=\"hljs-title class_\">DatabaseException</span>.<span class=\"hljs-title function_\">fromIsarError</span>(<span class=\"hljs-title class_\">IsarError</span> isarError) : message = isarError.<span class=\"hljs-property\">message</span>;\n\n  @override\n  <span class=\"hljs-title class_\">List</span>&#x3C;<span class=\"hljs-title class_\">Object</span>?> get props => [message];\n}\n</code></pre>\n<p>알겠어요! 여기까지입니다. 이 부분에서는 여기까지 언급할 거예요.</p>\n<p>이제 Clean Architecture에 대해 준비되었습니다.</p>\n<p>다음 파트</p>\n</body>\n</html>\n"},"__N_SSG":true}