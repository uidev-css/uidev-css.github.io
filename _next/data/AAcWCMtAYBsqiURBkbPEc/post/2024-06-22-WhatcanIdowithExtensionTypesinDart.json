{"pageProps":{"post":{"title":"Dart에서 Extension Types으로 할 수 있는 것들","description":"","date":"2024-06-22 00:40","slug":"2024-06-22-WhatcanIdowithExtensionTypesinDart","content":"\n\nDart 3.3 확장 타입\n\n![Image](/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_0.png)\n\n공식 문서는 다음과 같이 시작합니다:\n\n확장 타입은 강력한 타입 래퍼로 작용하는 컴파일 시간 추상화입니다. 성능 최적화를 위해 도입되었으며 네이티브 코드와의 향상된 상호작용을 제공합니다. Zero-cost 래퍼로서, 다른 언어와 통신할 때 Wrapper 클래스와 Helper 클래스와 관련된 전형적인 메모리 비용을 제거합니다.\n\n<div class=\"content-ad\"></div>\n\n일반 클래스 래퍼는 런타임에서 작동하며 항상 클래스 및 객체 사용량의 오버헤드가 발생하여 메모리 사용량과 GC(Garbage Collection) 비용이 증가합니다. 단기간에 많은 래퍼 인스턴스가 생성되는 시나리오에서는 이 부담이 상당해집니다.\n\n확장 유형은 특정 유형의 확장으로 컴파일 시간에 확인되므로 런타임에서는 원래 표현 유형으로 되돌아가며 추상화가 사라집니다. 따라서 확장 유형을 사용하면 응용 프로그램에 비용이 발생하지 않아 매우 효율적인 개발 방법이 됩니다.\n확장 유형은 정적 JavaScript 상호 운용을 가능하게 하며, 기존 JavaScript 유형과의 원활한 상호 작용을 허용합니다.\n\n# 혜택\n\n<div class=\"content-ad\"></div>\n\n## 유연한 제한과 확장\n\n기존 유형(예: int 또는 String)을 속성, 함수 및 다른 API를 추가하여 향상시킬 수 있습니다.\n\n## 더 명확한 추상화\n\n기본 표현 유형의 복잡성을 숨겨 의미 있는 확장을 가능하게 하여 코드 가독성과 유지 관리성을 향상시킵니다.\n\n<div class=\"content-ad\"></div>\n\n## 편리하고 안전한 상호 운용성\n\nDart 사용자 정의 유형은 기본 유형에 액세스하는 것만큼 간단하여 유형 안전성을 제공합니다. 이는 네이티브 플랫폼 및 다른 언어와의 상호 운용성에 특히 유용하며, 프로세스를 간소화합니다.\n\n## 향상된 성능\n\n각 서비스마다 Wrapper 클래스를 생성하지 않아 추가 메모리 오버헤드가 발생하지 않습니다. 특히 대량 데이터 집합이나 빈번한 객체 작업을 처리할 때 성능에 민감한 시나리오에 이상적입니다.\n\n<div class=\"content-ad\"></div>\n\n# 개발\n\n확장 형식은 선언될 때 기본 생성자가 자동으로 포함됩니다.\n\n```js\nextension type MyId(int id) {}\n\nvoid main(List<String> arguments) {\n  final id = MyId(1);\n  \n  print(id); // 1 \n  print(id.runtimeType); // int\n}\n```\n\n어떤 경우에도 확장 형식에 의해 래핑된 형식은 \"표현 형식\"으로 불리며 서브타입이 아닙니다. 따라서 일반적으로 표현 형식과 사용자 정의 확장 형식은 서로 값 할당이 불가능합니다.\n\n<div class=\"content-ad\"></div>\n\n사용자 정의된 새로운 속성과 함수 인터페이스가 없을 때에는 기능적인 작업이 없습니다. int의 원래 동작이 제한됩니다.\n\n![extension types in Dart](/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_1.png)\n\n기존 유형에 대해서는 더 많은 확장이나 유형의 제약 사항에 대해 노출되는 것이 아닌 사용 가능한 API만 노출되며, 그렇게 함으로써 일부 허용되지 않는 작업을 피할 수 있습니다. 우리가 필요로 하는 의미 있는 함수를 추가할 수 있습니다.\n\n```dart\nextension type MyId(int id) {\n  operator >(MyId other) => id > other.id;\n  \n  bool isBiggerThan(MyId other) => id > other.id;\n}\n\nvoid main(List<String> arguments) {\n  MyId safeId = MyId(200);\n  safeId + 10; // Compile error: No '+' operator.\n  safeId - 10; // Compile error: No '-' operator.\n  safeId > 10; // Compile error: Wrong type.\n  safeId > MyId(300); // ✅\n\n  int number = 100;\n  number = safeId; // Compile error: Wrong type.\n  number = safeId as int; // ✅ Cast to representation type.\n  safeId = number as MyId; // ✅ Cast to extension type.\n\n  print(safeId.isBiggerThan(MyId(300))); // false\n}\n```\n\n<div class=\"content-ad\"></div>\n\n서비스나 네이티브 API와 상호 작용 후 반환된 값은 int를 사용하여 가독성을 높일 수 있어요. 확장 유형을 통해 특정 이름을 지정할 수 있어요. 이렇게 하면 한눈에 이해하기 쉬워져요.\n\n확장 유형과 표현 유형은 as 캐스팅을 사용하여 직접 변환할 수 있어요. 재미있는 점은 상속 관계가 아님에도 불구하고 강제로 변환할 수도 있어요.\n\n```js\ni = id as int; // ✅\ni = -1;\nid = i as Id;  // ✅\n```\n\n다트 클래스처럼 확장 유형을 일반적으로 처리하고 인스턴스화하고 사용자 정의 함수를 호출할 수 있는 예제가 있어요. 다트는 이를 일반 int로 컴파일해요.\n\n<div class=\"content-ad\"></div>\n\n```dart\nextension type Wrapper(int i) {\n  void showValue() {\n    print('my value is $i');\n  }\n}\n\nvoid main() {\n  final wrapper = Wrapper(42);\n  wrapper.showValue(); // Prints 'my value is 42'\n}\n```\n\n공식 설명에 따르면 익스텐션 타입은 네이티브 코드와의 상호 운용성을 위해 유용하며, 간접 비용을 발생시키지 않고 네이티브 타입을 직접 사용할 수 있으면서도 깔끔한 Dart API를 제공합니다.\n\n# 제네릭\n\n익스텐션 타입과 제네릭을 함께 사용하기:\n\n\n<div class=\"content-ad\"></div>\n\n```dart\nextension type MyList<T>(List<T> elements) {\n void add(T value) => elements.add(value);\n}\n\nvoid main(List<String> arguments) {\n  MyList list = MyList<int>([1, 2]);\n  list.add(3);\n\n  final normalList = list as List<int>;\n  print(list); // [1, 2, 3]\n  print(normalList); // [1, 2, 3]\n}\n```\n\n# 생성자\n\nExtension 타입은 여러 개의 생성자를 가질 수 있습니다:\n\n- 일반 생성자\n- 명명된 생성자\n- private 생성자 문법을 사용한 숨겨진 생성자\n\n\n<div class=\"content-ad\"></div>\n\n```dart\nextension type Password._(String value) {\n  Password(this.value) {\n    assert(value.length >= 8);\n    \n    if (value.length < 8) {\n      throw Exception('Password must be at least 8 characters long');\n    }\n  }\n\n  Password.random() : value = _generateRandomPassword();\n\n  static String _generateRandomPassword() => ...;\n\n  bool get isValid => value.length >= 8;\n}\n\nvoid main(List<String> arguments) {\n  // 암시적 명명되지 않은 생성자.\n  Password password = Password('abcdefghijklmnopqrstuvwxyz'); // ✅\n\n  // 명명된 생성자.\n  password = Password.random(); // ✅\n  password = Password('hello12'); // Exception: Password must be at least 8 characters long\n  password = 'hello' as Password; // ✅\n}\n```\n\n기억하세요, 암시적 주 생성자에서는 assert() 체크나 다른 작업을 사용할 수 없습니다. 기본 생성자를 재정의하고 assert 체크를 추가하세요. 기본 생성자를 내부적으로(private) 만드세요.\n```dart\nextension type Password._(String value) {\n\n  Password(this.value) {\n    assert(value.length >= 8);\n    \n    if (value.length < 8) {\n      throw Exception('Password must be at least 8 characters long');\n    }\n  }\n  \n}\n```\n\n# 안전한 Alias\n\n\n<div class=\"content-ad\"></div>\n\nimplements를 사용하면 Extension Types가 기본 유형을 노출하여 Representation 타입의 모든 멤버 및 사용자 지정 도우미 API에 액세스할 수 있습니다. 이는 원래 유형의 기능을 제공하면서도 별칭 및 타입 안전성 확인을 제공합니다.\n\n```js\nextension type Height(double _) implements double {}\nextension type Weight(double _) implements double {}\n\ndouble calculateBmi(Height height, Weight weight) => weight / ( height * height);\n\nvoid main() {\n  var height = Height(1.75);\n  var weight = Weight(65);\n  var bmi = calculateBmi(height, weight);\n  print(bmi); // 21.22448979591837\n  \n  bmi = calculateBmi(1.64, 54.0);     // ❌ 컴파일 타임 오류\n  bmi = calculateBmi(weight, height); // ❌ 컴파일 타임 오류\n}\n```\n\n기존 타입에 새로운 인터페이스 추가하기:\n\n```js\nextension type MyId(int id) implements int {\n  MyId get value => this;\n}\n\nvoid main(List<String> arguments) {\n  final safeId = MyId(100);\n  safeId + 1; // 101\n  safeId - 1; // 99\n  safeId * 2; // 200\n  safeId / 2; // 50\n  safeId % 3; // 1\n  safeId.toString(); // '100'\n\n  int normalId = safeId; // 100\n  final safeId2 = safeId + normalId; // 200\n  final safeId3 = 10 + safeId; // 110\n}\n```\n\n<div class=\"content-ad\"></div>\n\n기존의 기능적 동작을 재정의하고 확장 타입의 멤버들은 완전히 부모 타입의 동일한 이름을 가진 멤버들을 대체하여 새 구현 방법을 제공합니다.\n\n```js\n확장 타입 MyId(int id)은 int를 구현합니다 {\n  bool get isEven => true;\n}\n\nvoid main(List<String> arguments) {\n  final myId = MyId(101);\n  print(myId.isEven); // true\n}\n```\n\n# 다른 시나리오\n\n## 다중 타입 확장\n\n<div class=\"content-ad\"></div>\n\n보통, 확장 유형은 하나의 유형을 확장합니다. 여러 정보가 있는 경우 Record를 사용할 수 있습니다.\n\n```js\ntypedef UserInfo = ({String email, String password});\n\nextension type User(UserInfo info) {\n  void printInfo() => print(\"Email: ${info.email}, Password: ${info.password}\");\n}\n\nvoid main(List<String> arguments) {\n  final user = User(\n    (\n      email: 'extension@gmail.com',\n      password: 'types',\n    ),\n  );\n  user.printInfo(); // Email: extension@gmail.com, Password: types\n}\n```\n\n## 테스트용 모의 데이터\n\n테스트에서 Extension Types를 사용하는 것도 가능합니다. Mock 클래스에 따르면 코드를 약간 조정하기만 하면 됩니다. 일반 클래스와의 차이점은 인터페이스를 구현하지 않은 경우 일반 클래스는 컴파일 경고를 표시하지만, Extension Types는 표시하지 않는다.\n\n<div class=\"content-ad\"></div>\n\n\n## JSON 접근\n\nJSON 데이터에 대한 Extension Types 활용.\n\n```js\nfinal userMap = json.decode(r'''\n  {\n    \"name\": {\n      \"first\": \"Yii\",\n      \"last\": \"Chen\"\n    },\n    \"email\": \"ab20803@gmail.com\"\n  }\n'''); // Map<String, dynamic>\n\nextension type User(Map<String, dynamic> _) {\n  Name get name => _['name'] as Name;\n  String get email => _['email'] as String;\n}\nextension type Name(Map<String, dynamic> _) {\n  String get first => _['first'] as String;\n  String get last => _['last'] as String;\n}\nvoid main() {\n  final person = User(userMap);\n  print(person.name.first);   // Yii\n  print(person.name.last);    // Chen\n  print(person.email);        // ab20803@gmail.com\n  print(person.email.length); // 17\n}\n```\n\n\n<div class=\"content-ad\"></div>\n\n# 상호 운용성\n\n현재 Extension Types은 주로 dart: js_interop 패키지에서 사용되며, 익숙한 구문을 사용하여 JavaScript API에 액세스하고 상호 작용할 수 있도록 합니다. 이 패키지는 JSObject 및 JSAny와 같은 많은 JS 관련 유형을 정의하여 Dart와 네이티브 플랫폼 간의 안전한 통신을 보장합니다. C++와 같은 다른 언어도 이 접근 방식에서 혜택을 볼 수 있습니다.\n\n![image](/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_2.png)\n\nexternal → 이 키워드는 일반적으로 다른 언어에서 사용하는 외부 함수에 액세스할 수 있도록 합니다. 따라서 Dart 상호 운용성 개발에서 자주 볼 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n@JS() → 만약 Dart 측에서 다른 이름을 구현하거나 동일한 JavaScript API를 가리키는 여러 Dart API를 작성하려는 경우, 상호 운용성을 위해 JS API의 이름을 정의할 수 있습니다.\n\n## 패키지 예시\n\nflutter_soloud는 C++을 기반으로 개발된 오디오 엔진 및 패키지로, 낮은 지연 시간, 고성능 플레이어를 제공합니다. 소스 코드에서 재생 기능을 실행하고자 할 때, player.cpp의 play 함수로 시작하여 최종적으로 Dart 측에서는 소리 작업의 ID를 얻기 위해 soloud.play()를 실행합니다.\n\n사용자 정의 SoundHandle은 가독성과 성능을 보장하기 위해 ID를 래핑합니다.\n\n<div class=\"content-ad\"></div>\n\n```dart\nfinal soloud = SoLoud.instance;\nawait soloud.init();\nfinal source = await soloud.loadAsset('path/to/asset.mp3');\n\nSoundHandle soundHandle = await soloud.play(source); // id(int)\n\nawait soloud.stop(soundHandle);\nawait soloud.disposeSource(soundHandle);\n```\n\n전체 API 작업 프로세스를 간단히 살펴보겠습니다:\n\n- player.cpp의 play()를 사용하여 오디오 핸들을 얻습니다.\n\n![Extension Types in Dart](/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_3.png)\n\n\n<div class=\"content-ad\"></div>\n\n2. 양쪽 간의 통신을 처리하기 위해 bindings_player_ffi.dart를 사용하여 얻은 핸들 ID를 SoundHandle으로 래핑합니다.\n\n![image](/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_4.png)\n\n3. Flutter 쪽에서는 soloud.dart를 사용하여 play()를 호출한 후 Record 유형의 결과를 반환합니다. 해당 newHandle을 추출하여 필요한 ID인 ID를 얻을 수 있습니다.\n\n![image](/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_5.png)\n\n<div class=\"content-ad\"></div>\n\n4. Dart 쪽에서는 음향 컨트롤 작업을 위해 의미 있는 확장 유형인 SoundHandle을 사용하여 id가 랩핑됩니다.\n\n![이미지](/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_6.png)\n\n# 고급 사용법\n\n팩토리 생성자: 다른 유형의 확장이 Representation 유형에 적용될 수 있습니다. 이를 통해 연산을 여러 확장 유형에 재사용할 수 있습니다 (다중 상속과 유사).\n\n<div class=\"content-ad\"></div>\n\n```js\nextension type Number(int i) {\n  const factory Number.zero() = Number2;\n}\n\nextension type Number2(int i) implements Number { \n  const Number2(int value) : this(i: value);\n}\n```\n\n# 기억해주세요\n\n확장 유형(Extension Type)은 컴파일 시간에 래핑 동작입니다. 런타임에는 존재하지 않습니다. 런타임에서는 어떤 유형의 쿼리나 작업이라도 표현 유형(Representation Type)에 적용됩니다. 이로 인해 확장 유형은 안전하지 않은 추상화이며 원래 표현 유형을 항상 찾을 수 있고 런타임에서 기본 객체에 액세스할 수 있습니다.\n\n```js\nextension type Id(int value) {}\n\nvoid idToInt() {\n  var id = Id(1);\n\n  // 'id'의 런타임 유형은 표현 유형 'int'.\n  if (id is int) print(id.value); // 1\n\n  // 런타임에서 'id'에 'int' 메서드 사용 가능.\n  if (id case int x) print(x.toString()); // 1\n  switch (id) {\n    case int(:final isEven):\n      print(\"$id (${isEven ? \"짝수\" : \"홀수\"})\"); // 1 (홀수)\n  }\n}\n\nvoid intToId() {\n  int i = 2;\n\n  if (i is Id) print(\"예\"); // 예\n\n  if (i case Id id) print(\"값: ${id.value}\"); // 값: 2\n\n  switch (i) {\n    case Id(:var value):\n      print(\"값: $value\"); // 값: 2\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n# 요약\n\n- **확장 유형**은 기존 유형을 제한할 수도 있고, 새로운 기능을 제공할 수도 있습니다.\n- **확장 유형**의 본질을 이해하는 것이 중요합니다. 이들은 컴파일 시에만 존재하며 런타임에서는 무시되며 **표현 유형**으로 표시됩니다.\n- **확장 유형**은 특정 상황에서 비용을 절약하고, 특히 상호 운용성 개발에서 성능을 크게 향상시킬 수 있습니다.\n\n# 확장 유형 비교\n\n- **확장 메서드**: 기존 유형에 간단한 기능을 추가하는 데 적합합니다.\n- **확장 유형**: 기존 유형을 향상시키고, 복잡한 기능을 구현하며, 다른 프로그래밍 언어와의 상호 운용성을 최적화하는 데 적합합니다.\n\n<div class=\"content-ad\"></div>\n\n# 참고\n\n- [Dart 언어 확장 유형](https://dart.dev/language/extension-types)\n- [Dart 상호 운용성 및 JS 상호 운용 사용법](https://dart.dev/interop/js-interop/usage)\n- [Dart 3.3 소개](https://medium.com/dartlang/dart-3-3-325bf2bf6c13)\n- [Dart와 Flutter 확장 유형에 대한 소개](https://ildysilva.medium.com/what-are-flutter-and-dart-extension-types-896eda0a3ddf)\n- [Dart 언어에 대한 유용한 기능과 팁](https://qiita.com/Cat_sushi/items/987e7eee469793369ef8)\n- [Flutter와 Dart의 개요](https://qiita.com/Cat_sushi/items/87742dc3a886dd984f46)\n- [imaNNeO 유튜브 채널](https://www.youtube.com/watch?v=YHsi1Gfz5UU&ab_channel=imaNNeO)\n- [FlutterUruguay 유튜브 채널](https://www.youtube.com/watch?v=SyFNB81p-OY&t=3276s&ab_channel=FlutterUruguay)\n- [Prof.DiegoAntunes 유튜브 채널](https://www.youtube.com/watch?v=2TJIOpBDMnU&ab_channel=Prof.DiegoAntunes)\n\n# 다른 글들\n\n- 2024년 4월 'Flutter Monthly' 😍\n- 2024년 3월 'Flutter Monthly' 😍\n- 2024년 2월 'Flutter Monthly' 😍\n- Flutter 3.19 및 Dart 3.3 업데이트 포인트!\n- 2024년 1월 'Flutter Monthly' 😍\n- 개발 기술 향상을 위한 Dart 3 사용하기. 더 많은 예제와 팁.\n- 2023년 12월 'Flutter Monthly' 😍\n- 2023년 11월 'Flutter Monthly' 😍\n- Dart 3를 숙지해서 삶을 쉽게 만들기!\n- Flutter 3.16 및 Dart 3.2 요약!\n- 2023년 10월 'Flutter Monthly' 😍\n- 2023년 9월 'Flutter Monthly' 😍\n- 2023년 8월 'Flutter Monthly' 😍\n- 2023년 7월 'Flutter Monthly' 😍","ogImage":{"url":"/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_0.png"},"coverImage":"/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_0.png","tag":["Tech"],"readingTime":12},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>Dart 3.3 확장 타입</p>\n<p><img src=\"/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_0.png\" alt=\"Image\"></p>\n<p>공식 문서는 다음과 같이 시작합니다:</p>\n<p>확장 타입은 강력한 타입 래퍼로 작용하는 컴파일 시간 추상화입니다. 성능 최적화를 위해 도입되었으며 네이티브 코드와의 향상된 상호작용을 제공합니다. Zero-cost 래퍼로서, 다른 언어와 통신할 때 Wrapper 클래스와 Helper 클래스와 관련된 전형적인 메모리 비용을 제거합니다.</p>\n<p>일반 클래스 래퍼는 런타임에서 작동하며 항상 클래스 및 객체 사용량의 오버헤드가 발생하여 메모리 사용량과 GC(Garbage Collection) 비용이 증가합니다. 단기간에 많은 래퍼 인스턴스가 생성되는 시나리오에서는 이 부담이 상당해집니다.</p>\n<p>확장 유형은 특정 유형의 확장으로 컴파일 시간에 확인되므로 런타임에서는 원래 표현 유형으로 되돌아가며 추상화가 사라집니다. 따라서 확장 유형을 사용하면 응용 프로그램에 비용이 발생하지 않아 매우 효율적인 개발 방법이 됩니다.\n확장 유형은 정적 JavaScript 상호 운용을 가능하게 하며, 기존 JavaScript 유형과의 원활한 상호 작용을 허용합니다.</p>\n<h1>혜택</h1>\n<h2>유연한 제한과 확장</h2>\n<p>기존 유형(예: int 또는 String)을 속성, 함수 및 다른 API를 추가하여 향상시킬 수 있습니다.</p>\n<h2>더 명확한 추상화</h2>\n<p>기본 표현 유형의 복잡성을 숨겨 의미 있는 확장을 가능하게 하여 코드 가독성과 유지 관리성을 향상시킵니다.</p>\n<h2>편리하고 안전한 상호 운용성</h2>\n<p>Dart 사용자 정의 유형은 기본 유형에 액세스하는 것만큼 간단하여 유형 안전성을 제공합니다. 이는 네이티브 플랫폼 및 다른 언어와의 상호 운용성에 특히 유용하며, 프로세스를 간소화합니다.</p>\n<h2>향상된 성능</h2>\n<p>각 서비스마다 Wrapper 클래스를 생성하지 않아 추가 메모리 오버헤드가 발생하지 않습니다. 특히 대량 데이터 집합이나 빈번한 객체 작업을 처리할 때 성능에 민감한 시나리오에 이상적입니다.</p>\n<h1>개발</h1>\n<p>확장 형식은 선언될 때 기본 생성자가 자동으로 포함됩니다.</p>\n<pre><code class=\"hljs language-js\">extension type <span class=\"hljs-title class_\">MyId</span>(int id) {}\n\n<span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\">List&#x3C;<span class=\"hljs-built_in\">String</span>> <span class=\"hljs-variable language_\">arguments</span></span>) {\n  final id = <span class=\"hljs-title class_\">MyId</span>(<span class=\"hljs-number\">1</span>);\n  \n  <span class=\"hljs-title function_\">print</span>(id); <span class=\"hljs-comment\">// 1 </span>\n  <span class=\"hljs-title function_\">print</span>(id.<span class=\"hljs-property\">runtimeType</span>); <span class=\"hljs-comment\">// int</span>\n}\n</code></pre>\n<p>어떤 경우에도 확장 형식에 의해 래핑된 형식은 \"표현 형식\"으로 불리며 서브타입이 아닙니다. 따라서 일반적으로 표현 형식과 사용자 정의 확장 형식은 서로 값 할당이 불가능합니다.</p>\n<p>사용자 정의된 새로운 속성과 함수 인터페이스가 없을 때에는 기능적인 작업이 없습니다. int의 원래 동작이 제한됩니다.</p>\n<p><img src=\"/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_1.png\" alt=\"extension types in Dart\"></p>\n<p>기존 유형에 대해서는 더 많은 확장이나 유형의 제약 사항에 대해 노출되는 것이 아닌 사용 가능한 API만 노출되며, 그렇게 함으로써 일부 허용되지 않는 작업을 피할 수 있습니다. 우리가 필요로 하는 의미 있는 함수를 추가할 수 있습니다.</p>\n<pre><code class=\"hljs language-dart\"><span class=\"hljs-keyword\">extension</span> type MyId(<span class=\"hljs-built_in\">int</span> id) {\n  <span class=\"hljs-keyword\">operator</span> >(MyId other) => id > other.id;\n  \n  <span class=\"hljs-built_in\">bool</span> isBiggerThan(MyId other) => id > other.id;\n}\n\n<span class=\"hljs-keyword\">void</span> main(<span class=\"hljs-built_in\">List</span>&#x3C;<span class=\"hljs-built_in\">String</span>> arguments) {\n  MyId safeId = MyId(<span class=\"hljs-number\">200</span>);\n  safeId + <span class=\"hljs-number\">10</span>; <span class=\"hljs-comment\">// Compile error: No '+' operator.</span>\n  safeId - <span class=\"hljs-number\">10</span>; <span class=\"hljs-comment\">// Compile error: No '-' operator.</span>\n  safeId > <span class=\"hljs-number\">10</span>; <span class=\"hljs-comment\">// Compile error: Wrong type.</span>\n  safeId > MyId(<span class=\"hljs-number\">300</span>); <span class=\"hljs-comment\">// ✅</span>\n\n  <span class=\"hljs-built_in\">int</span> number = <span class=\"hljs-number\">100</span>;\n  number = safeId; <span class=\"hljs-comment\">// Compile error: Wrong type.</span>\n  number = safeId <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">int</span>; <span class=\"hljs-comment\">// ✅ Cast to representation type.</span>\n  safeId = number <span class=\"hljs-keyword\">as</span> MyId; <span class=\"hljs-comment\">// ✅ Cast to extension type.</span>\n\n  <span class=\"hljs-built_in\">print</span>(safeId.isBiggerThan(MyId(<span class=\"hljs-number\">300</span>))); <span class=\"hljs-comment\">// false</span>\n}\n</code></pre>\n<p>서비스나 네이티브 API와 상호 작용 후 반환된 값은 int를 사용하여 가독성을 높일 수 있어요. 확장 유형을 통해 특정 이름을 지정할 수 있어요. 이렇게 하면 한눈에 이해하기 쉬워져요.</p>\n<p>확장 유형과 표현 유형은 as 캐스팅을 사용하여 직접 변환할 수 있어요. 재미있는 점은 상속 관계가 아님에도 불구하고 강제로 변환할 수도 있어요.</p>\n<pre><code class=\"hljs language-js\">i = id <span class=\"hljs-keyword\">as</span> int; <span class=\"hljs-comment\">// ✅</span>\ni = -<span class=\"hljs-number\">1</span>;\nid = i <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">Id</span>;  <span class=\"hljs-comment\">// ✅</span>\n</code></pre>\n<p>다트 클래스처럼 확장 유형을 일반적으로 처리하고 인스턴스화하고 사용자 정의 함수를 호출할 수 있는 예제가 있어요. 다트는 이를 일반 int로 컴파일해요.</p>\n<pre><code class=\"hljs language-dart\"><span class=\"hljs-keyword\">extension</span> type Wrapper(<span class=\"hljs-built_in\">int</span> i) {\n  <span class=\"hljs-keyword\">void</span> showValue() {\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">'my value is <span class=\"hljs-subst\">$i</span>'</span>);\n  }\n}\n\n<span class=\"hljs-keyword\">void</span> main() {\n  <span class=\"hljs-keyword\">final</span> wrapper = Wrapper(<span class=\"hljs-number\">42</span>);\n  wrapper.showValue(); <span class=\"hljs-comment\">// Prints 'my value is 42'</span>\n}\n</code></pre>\n<p>공식 설명에 따르면 익스텐션 타입은 네이티브 코드와의 상호 운용성을 위해 유용하며, 간접 비용을 발생시키지 않고 네이티브 타입을 직접 사용할 수 있으면서도 깔끔한 Dart API를 제공합니다.</p>\n<h1>제네릭</h1>\n<p>익스텐션 타입과 제네릭을 함께 사용하기:</p>\n<pre><code class=\"hljs language-dart\"><span class=\"hljs-keyword\">extension</span> type MyList&#x3C;T>(<span class=\"hljs-built_in\">List</span>&#x3C;T> elements) {\n <span class=\"hljs-keyword\">void</span> add(T value) => elements.add(value);\n}\n\n<span class=\"hljs-keyword\">void</span> main(<span class=\"hljs-built_in\">List</span>&#x3C;<span class=\"hljs-built_in\">String</span>> arguments) {\n  MyList list = MyList&#x3C;<span class=\"hljs-built_in\">int</span>>([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>]);\n  list.add(<span class=\"hljs-number\">3</span>);\n\n  <span class=\"hljs-keyword\">final</span> normalList = list <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">List</span>&#x3C;<span class=\"hljs-built_in\">int</span>>;\n  <span class=\"hljs-built_in\">print</span>(list); <span class=\"hljs-comment\">// [1, 2, 3]</span>\n  <span class=\"hljs-built_in\">print</span>(normalList); <span class=\"hljs-comment\">// [1, 2, 3]</span>\n}\n</code></pre>\n<h1>생성자</h1>\n<p>Extension 타입은 여러 개의 생성자를 가질 수 있습니다:</p>\n<ul>\n<li>일반 생성자</li>\n<li>명명된 생성자</li>\n<li>private 생성자 문법을 사용한 숨겨진 생성자</li>\n</ul>\n<pre><code class=\"hljs language-dart\"><span class=\"hljs-keyword\">extension</span> type Password._(<span class=\"hljs-built_in\">String</span> value) {\n  Password(<span class=\"hljs-keyword\">this</span>.value) {\n    <span class=\"hljs-keyword\">assert</span>(value.length >= <span class=\"hljs-number\">8</span>);\n    \n    <span class=\"hljs-keyword\">if</span> (value.length &#x3C; <span class=\"hljs-number\">8</span>) {\n      <span class=\"hljs-keyword\">throw</span> Exception(<span class=\"hljs-string\">'Password must be at least 8 characters long'</span>);\n    }\n  }\n\n  Password.random() : value = _generateRandomPassword();\n\n  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-built_in\">String</span> _generateRandomPassword() => ...;\n\n  <span class=\"hljs-built_in\">bool</span> <span class=\"hljs-keyword\">get</span> isValid => value.length >= <span class=\"hljs-number\">8</span>;\n}\n\n<span class=\"hljs-keyword\">void</span> main(<span class=\"hljs-built_in\">List</span>&#x3C;<span class=\"hljs-built_in\">String</span>> arguments) {\n  <span class=\"hljs-comment\">// 암시적 명명되지 않은 생성자.</span>\n  Password password = Password(<span class=\"hljs-string\">'abcdefghijklmnopqrstuvwxyz'</span>); <span class=\"hljs-comment\">// ✅</span>\n\n  <span class=\"hljs-comment\">// 명명된 생성자.</span>\n  password = Password.random(); <span class=\"hljs-comment\">// ✅</span>\n  password = Password(<span class=\"hljs-string\">'hello12'</span>); <span class=\"hljs-comment\">// Exception: Password must be at least 8 characters long</span>\n  password = <span class=\"hljs-string\">'hello'</span> <span class=\"hljs-keyword\">as</span> Password; <span class=\"hljs-comment\">// ✅</span>\n}\n</code></pre>\n<p>기억하세요, 암시적 주 생성자에서는 assert() 체크나 다른 작업을 사용할 수 없습니다. 기본 생성자를 재정의하고 assert 체크를 추가하세요. 기본 생성자를 내부적으로(private) 만드세요.</p>\n<pre><code class=\"hljs language-dart\"><span class=\"hljs-keyword\">extension</span> type Password._(<span class=\"hljs-built_in\">String</span> value) {\n\n  Password(<span class=\"hljs-keyword\">this</span>.value) {\n    <span class=\"hljs-keyword\">assert</span>(value.length >= <span class=\"hljs-number\">8</span>);\n    \n    <span class=\"hljs-keyword\">if</span> (value.length &#x3C; <span class=\"hljs-number\">8</span>) {\n      <span class=\"hljs-keyword\">throw</span> Exception(<span class=\"hljs-string\">'Password must be at least 8 characters long'</span>);\n    }\n  }\n  \n}\n</code></pre>\n<h1>안전한 Alias</h1>\n<p>implements를 사용하면 Extension Types가 기본 유형을 노출하여 Representation 타입의 모든 멤버 및 사용자 지정 도우미 API에 액세스할 수 있습니다. 이는 원래 유형의 기능을 제공하면서도 별칭 및 타입 안전성 확인을 제공합니다.</p>\n<pre><code class=\"hljs language-js\">extension type <span class=\"hljs-title class_\">Height</span>(double _) implements double {}\nextension type <span class=\"hljs-title class_\">Weight</span>(double _) implements double {}\n\ndouble <span class=\"hljs-title function_\">calculateBmi</span>(<span class=\"hljs-title class_\">Height</span> height, <span class=\"hljs-title class_\">Weight</span> weight) => weight / ( height * height);\n\n<span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">var</span> height = <span class=\"hljs-title class_\">Height</span>(<span class=\"hljs-number\">1.75</span>);\n  <span class=\"hljs-keyword\">var</span> weight = <span class=\"hljs-title class_\">Weight</span>(<span class=\"hljs-number\">65</span>);\n  <span class=\"hljs-keyword\">var</span> bmi = <span class=\"hljs-title function_\">calculateBmi</span>(height, weight);\n  <span class=\"hljs-title function_\">print</span>(bmi); <span class=\"hljs-comment\">// 21.22448979591837</span>\n  \n  bmi = <span class=\"hljs-title function_\">calculateBmi</span>(<span class=\"hljs-number\">1.64</span>, <span class=\"hljs-number\">54.0</span>);     <span class=\"hljs-comment\">// ❌ 컴파일 타임 오류</span>\n  bmi = <span class=\"hljs-title function_\">calculateBmi</span>(weight, height); <span class=\"hljs-comment\">// ❌ 컴파일 타임 오류</span>\n}\n</code></pre>\n<p>기존 타입에 새로운 인터페이스 추가하기:</p>\n<pre><code class=\"hljs language-js\">extension type <span class=\"hljs-title class_\">MyId</span>(int id) implements int {\n  <span class=\"hljs-title class_\">MyId</span> get value => <span class=\"hljs-variable language_\">this</span>;\n}\n\n<span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\">List&#x3C;<span class=\"hljs-built_in\">String</span>> <span class=\"hljs-variable language_\">arguments</span></span>) {\n  final safeId = <span class=\"hljs-title class_\">MyId</span>(<span class=\"hljs-number\">100</span>);\n  safeId + <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// 101</span>\n  safeId - <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// 99</span>\n  safeId * <span class=\"hljs-number\">2</span>; <span class=\"hljs-comment\">// 200</span>\n  safeId / <span class=\"hljs-number\">2</span>; <span class=\"hljs-comment\">// 50</span>\n  safeId % <span class=\"hljs-number\">3</span>; <span class=\"hljs-comment\">// 1</span>\n  safeId.<span class=\"hljs-title function_\">toString</span>(); <span class=\"hljs-comment\">// '100'</span>\n\n  int normalId = safeId; <span class=\"hljs-comment\">// 100</span>\n  final safeId2 = safeId + normalId; <span class=\"hljs-comment\">// 200</span>\n  final safeId3 = <span class=\"hljs-number\">10</span> + safeId; <span class=\"hljs-comment\">// 110</span>\n}\n</code></pre>\n<p>기존의 기능적 동작을 재정의하고 확장 타입의 멤버들은 완전히 부모 타입의 동일한 이름을 가진 멤버들을 대체하여 새 구현 방법을 제공합니다.</p>\n<pre><code class=\"hljs language-js\">확장 타입 <span class=\"hljs-title class_\">MyId</span>(int id)은 int를 구현합니다 {\n  bool get isEven => <span class=\"hljs-literal\">true</span>;\n}\n\n<span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\">List&#x3C;<span class=\"hljs-built_in\">String</span>> <span class=\"hljs-variable language_\">arguments</span></span>) {\n  final myId = <span class=\"hljs-title class_\">MyId</span>(<span class=\"hljs-number\">101</span>);\n  <span class=\"hljs-title function_\">print</span>(myId.<span class=\"hljs-property\">isEven</span>); <span class=\"hljs-comment\">// true</span>\n}\n</code></pre>\n<h1>다른 시나리오</h1>\n<h2>다중 타입 확장</h2>\n<p>보통, 확장 유형은 하나의 유형을 확장합니다. 여러 정보가 있는 경우 Record를 사용할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\">typedef <span class=\"hljs-title class_\">UserInfo</span> = ({<span class=\"hljs-title class_\">String</span> email, <span class=\"hljs-title class_\">String</span> password});\n\nextension type <span class=\"hljs-title class_\">User</span>(<span class=\"hljs-title class_\">UserInfo</span> info) {\n  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">printInfo</span>() => <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"Email: ${info.email}, Password: ${info.password}\"</span>);\n}\n\n<span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\">List&#x3C;<span class=\"hljs-built_in\">String</span>> <span class=\"hljs-variable language_\">arguments</span></span>) {\n  final user = <span class=\"hljs-title class_\">User</span>(\n    (\n      <span class=\"hljs-attr\">email</span>: <span class=\"hljs-string\">'extension@gmail.com'</span>,\n      <span class=\"hljs-attr\">password</span>: <span class=\"hljs-string\">'types'</span>,\n    ),\n  );\n  user.<span class=\"hljs-title function_\">printInfo</span>(); <span class=\"hljs-comment\">// Email: extension@gmail.com, Password: types</span>\n}\n</code></pre>\n<h2>테스트용 모의 데이터</h2>\n<p>테스트에서 Extension Types를 사용하는 것도 가능합니다. Mock 클래스에 따르면 코드를 약간 조정하기만 하면 됩니다. 일반 클래스와의 차이점은 인터페이스를 구현하지 않은 경우 일반 클래스는 컴파일 경고를 표시하지만, Extension Types는 표시하지 않는다.</p>\n<h2>JSON 접근</h2>\n<p>JSON 데이터에 대한 Extension Types 활용.</p>\n<pre><code class=\"hljs language-js\">final userMap = json.<span class=\"hljs-title function_\">decode</span>(r<span class=\"hljs-string\">''</span><span class=\"hljs-string\">'\n  {\n    \"name\": {\n      \"first\": \"Yii\",\n      \"last\": \"Chen\"\n    },\n    \"email\": \"ab20803@gmail.com\"\n  }\n'</span><span class=\"hljs-string\">''</span>); <span class=\"hljs-comment\">// Map&#x3C;String, dynamic></span>\n\nextension type <span class=\"hljs-title class_\">User</span>(<span class=\"hljs-title class_\">Map</span>&#x3C;<span class=\"hljs-title class_\">String</span>, dynamic> _) {\n  <span class=\"hljs-title class_\">Name</span> get name => _[<span class=\"hljs-string\">'name'</span>] <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">Name</span>;\n  <span class=\"hljs-title class_\">String</span> get email => _[<span class=\"hljs-string\">'email'</span>] <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">String</span>;\n}\nextension type <span class=\"hljs-title class_\">Name</span>(<span class=\"hljs-title class_\">Map</span>&#x3C;<span class=\"hljs-title class_\">String</span>, dynamic> _) {\n  <span class=\"hljs-title class_\">String</span> get first => _[<span class=\"hljs-string\">'first'</span>] <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">String</span>;\n  <span class=\"hljs-title class_\">String</span> get last => _[<span class=\"hljs-string\">'last'</span>] <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">String</span>;\n}\n<span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"></span>) {\n  final person = <span class=\"hljs-title class_\">User</span>(userMap);\n  <span class=\"hljs-title function_\">print</span>(person.<span class=\"hljs-property\">name</span>.<span class=\"hljs-property\">first</span>);   <span class=\"hljs-comment\">// Yii</span>\n  <span class=\"hljs-title function_\">print</span>(person.<span class=\"hljs-property\">name</span>.<span class=\"hljs-property\">last</span>);    <span class=\"hljs-comment\">// Chen</span>\n  <span class=\"hljs-title function_\">print</span>(person.<span class=\"hljs-property\">email</span>);        <span class=\"hljs-comment\">// ab20803@gmail.com</span>\n  <span class=\"hljs-title function_\">print</span>(person.<span class=\"hljs-property\">email</span>.<span class=\"hljs-property\">length</span>); <span class=\"hljs-comment\">// 17</span>\n}\n</code></pre>\n<h1>상호 운용성</h1>\n<p>현재 Extension Types은 주로 dart: js_interop 패키지에서 사용되며, 익숙한 구문을 사용하여 JavaScript API에 액세스하고 상호 작용할 수 있도록 합니다. 이 패키지는 JSObject 및 JSAny와 같은 많은 JS 관련 유형을 정의하여 Dart와 네이티브 플랫폼 간의 안전한 통신을 보장합니다. C++와 같은 다른 언어도 이 접근 방식에서 혜택을 볼 수 있습니다.</p>\n<p><img src=\"/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_2.png\" alt=\"image\"></p>\n<p>external → 이 키워드는 일반적으로 다른 언어에서 사용하는 외부 함수에 액세스할 수 있도록 합니다. 따라서 Dart 상호 운용성 개발에서 자주 볼 수 있습니다.</p>\n<p>@JS() → 만약 Dart 측에서 다른 이름을 구현하거나 동일한 JavaScript API를 가리키는 여러 Dart API를 작성하려는 경우, 상호 운용성을 위해 JS API의 이름을 정의할 수 있습니다.</p>\n<h2>패키지 예시</h2>\n<p>flutter_soloud는 C++을 기반으로 개발된 오디오 엔진 및 패키지로, 낮은 지연 시간, 고성능 플레이어를 제공합니다. 소스 코드에서 재생 기능을 실행하고자 할 때, player.cpp의 play 함수로 시작하여 최종적으로 Dart 측에서는 소리 작업의 ID를 얻기 위해 soloud.play()를 실행합니다.</p>\n<p>사용자 정의 SoundHandle은 가독성과 성능을 보장하기 위해 ID를 래핑합니다.</p>\n<pre><code class=\"hljs language-dart\"><span class=\"hljs-keyword\">final</span> soloud = SoLoud.instance;\n<span class=\"hljs-keyword\">await</span> soloud.init();\n<span class=\"hljs-keyword\">final</span> source = <span class=\"hljs-keyword\">await</span> soloud.loadAsset(<span class=\"hljs-string\">'path/to/asset.mp3'</span>);\n\nSoundHandle soundHandle = <span class=\"hljs-keyword\">await</span> soloud.play(source); <span class=\"hljs-comment\">// id(int)</span>\n\n<span class=\"hljs-keyword\">await</span> soloud.stop(soundHandle);\n<span class=\"hljs-keyword\">await</span> soloud.disposeSource(soundHandle);\n</code></pre>\n<p>전체 API 작업 프로세스를 간단히 살펴보겠습니다:</p>\n<ul>\n<li>player.cpp의 play()를 사용하여 오디오 핸들을 얻습니다.</li>\n</ul>\n<p><img src=\"/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_3.png\" alt=\"Extension Types in Dart\"></p>\n<ol start=\"2\">\n<li>양쪽 간의 통신을 처리하기 위해 bindings_player_ffi.dart를 사용하여 얻은 핸들 ID를 SoundHandle으로 래핑합니다.</li>\n</ol>\n<p><img src=\"/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_4.png\" alt=\"image\"></p>\n<ol start=\"3\">\n<li>Flutter 쪽에서는 soloud.dart를 사용하여 play()를 호출한 후 Record 유형의 결과를 반환합니다. 해당 newHandle을 추출하여 필요한 ID인 ID를 얻을 수 있습니다.</li>\n</ol>\n<p><img src=\"/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_5.png\" alt=\"image\"></p>\n<ol start=\"4\">\n<li>Dart 쪽에서는 음향 컨트롤 작업을 위해 의미 있는 확장 유형인 SoundHandle을 사용하여 id가 랩핑됩니다.</li>\n</ol>\n<p><img src=\"/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_6.png\" alt=\"이미지\"></p>\n<h1>고급 사용법</h1>\n<p>팩토리 생성자: 다른 유형의 확장이 Representation 유형에 적용될 수 있습니다. 이를 통해 연산을 여러 확장 유형에 재사용할 수 있습니다 (다중 상속과 유사).</p>\n<pre><code class=\"hljs language-js\">extension type <span class=\"hljs-title class_\">Number</span>(int i) {\n  <span class=\"hljs-keyword\">const</span> factory <span class=\"hljs-title class_\">Number</span>.<span class=\"hljs-title function_\">zero</span>() = <span class=\"hljs-title class_\">Number2</span>;\n}\n\nextension type <span class=\"hljs-title class_\">Number2</span>(int i) implements <span class=\"hljs-title class_\">Number</span> { \n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Number2</span>(int value) : <span class=\"hljs-title function_\">this</span>(<span class=\"hljs-attr\">i</span>: value);\n}\n</code></pre>\n<h1>기억해주세요</h1>\n<p>확장 유형(Extension Type)은 컴파일 시간에 래핑 동작입니다. 런타임에는 존재하지 않습니다. 런타임에서는 어떤 유형의 쿼리나 작업이라도 표현 유형(Representation Type)에 적용됩니다. 이로 인해 확장 유형은 안전하지 않은 추상화이며 원래 표현 유형을 항상 찾을 수 있고 런타임에서 기본 객체에 액세스할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\">extension type <span class=\"hljs-title class_\">Id</span>(int value) {}\n\n<span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">idToInt</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">var</span> id = <span class=\"hljs-title class_\">Id</span>(<span class=\"hljs-number\">1</span>);\n\n  <span class=\"hljs-comment\">// 'id'의 런타임 유형은 표현 유형 'int'.</span>\n  <span class=\"hljs-keyword\">if</span> (id is int) <span class=\"hljs-title function_\">print</span>(id.<span class=\"hljs-property\">value</span>); <span class=\"hljs-comment\">// 1</span>\n\n  <span class=\"hljs-comment\">// 런타임에서 'id'에 'int' 메서드 사용 가능.</span>\n  <span class=\"hljs-keyword\">if</span> (id <span class=\"hljs-keyword\">case</span> int x) <span class=\"hljs-title function_\">print</span>(x.<span class=\"hljs-title function_\">toString</span>()); <span class=\"hljs-comment\">// 1</span>\n  <span class=\"hljs-keyword\">switch</span> (id) {\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-title function_\">int</span>(:final isEven):\n      <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"$id (${isEven ? \"</span>짝수<span class=\"hljs-string\">\" : \"</span>홀수<span class=\"hljs-string\">\"})\"</span>); <span class=\"hljs-comment\">// 1 (홀수)</span>\n  }\n}\n\n<span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">intToId</span>(<span class=\"hljs-params\"></span>) {\n  int i = <span class=\"hljs-number\">2</span>;\n\n  <span class=\"hljs-keyword\">if</span> (i is <span class=\"hljs-title class_\">Id</span>) <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"예\"</span>); <span class=\"hljs-comment\">// 예</span>\n\n  <span class=\"hljs-keyword\">if</span> (i <span class=\"hljs-keyword\">case</span> <span class=\"hljs-title class_\">Id</span> id) <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"값: ${id.value}\"</span>); <span class=\"hljs-comment\">// 값: 2</span>\n\n  <span class=\"hljs-keyword\">switch</span> (i) {\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-title class_\">Id</span>(:<span class=\"hljs-keyword\">var</span> value):\n      <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"값: $value\"</span>); <span class=\"hljs-comment\">// 값: 2</span>\n  }\n}\n</code></pre>\n<h1>요약</h1>\n<ul>\n<li><strong>확장 유형</strong>은 기존 유형을 제한할 수도 있고, 새로운 기능을 제공할 수도 있습니다.</li>\n<li><strong>확장 유형</strong>의 본질을 이해하는 것이 중요합니다. 이들은 컴파일 시에만 존재하며 런타임에서는 무시되며 <strong>표현 유형</strong>으로 표시됩니다.</li>\n<li><strong>확장 유형</strong>은 특정 상황에서 비용을 절약하고, 특히 상호 운용성 개발에서 성능을 크게 향상시킬 수 있습니다.</li>\n</ul>\n<h1>확장 유형 비교</h1>\n<ul>\n<li><strong>확장 메서드</strong>: 기존 유형에 간단한 기능을 추가하는 데 적합합니다.</li>\n<li><strong>확장 유형</strong>: 기존 유형을 향상시키고, 복잡한 기능을 구현하며, 다른 프로그래밍 언어와의 상호 운용성을 최적화하는 데 적합합니다.</li>\n</ul>\n<h1>참고</h1>\n<ul>\n<li><a href=\"https://dart.dev/language/extension-types\" rel=\"nofollow\" target=\"_blank\">Dart 언어 확장 유형</a></li>\n<li><a href=\"https://dart.dev/interop/js-interop/usage\" rel=\"nofollow\" target=\"_blank\">Dart 상호 운용성 및 JS 상호 운용 사용법</a></li>\n<li><a href=\"https://medium.com/dartlang/dart-3-3-325bf2bf6c13\" rel=\"nofollow\" target=\"_blank\">Dart 3.3 소개</a></li>\n<li><a href=\"https://ildysilva.medium.com/what-are-flutter-and-dart-extension-types-896eda0a3ddf\" rel=\"nofollow\" target=\"_blank\">Dart와 Flutter 확장 유형에 대한 소개</a></li>\n<li><a href=\"https://qiita.com/Cat_sushi/items/987e7eee469793369ef8\" rel=\"nofollow\" target=\"_blank\">Dart 언어에 대한 유용한 기능과 팁</a></li>\n<li><a href=\"https://qiita.com/Cat_sushi/items/87742dc3a886dd984f46\" rel=\"nofollow\" target=\"_blank\">Flutter와 Dart의 개요</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=YHsi1Gfz5UU&#x26;ab_channel=imaNNeO\" rel=\"nofollow\" target=\"_blank\">imaNNeO 유튜브 채널</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=SyFNB81p-OY&#x26;t=3276s&#x26;ab_channel=FlutterUruguay\" rel=\"nofollow\" target=\"_blank\">FlutterUruguay 유튜브 채널</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=2TJIOpBDMnU&#x26;ab_channel=Prof.DiegoAntunes\" rel=\"nofollow\" target=\"_blank\">Prof.DiegoAntunes 유튜브 채널</a></li>\n</ul>\n<h1>다른 글들</h1>\n<ul>\n<li>2024년 4월 'Flutter Monthly' 😍</li>\n<li>2024년 3월 'Flutter Monthly' 😍</li>\n<li>2024년 2월 'Flutter Monthly' 😍</li>\n<li>Flutter 3.19 및 Dart 3.3 업데이트 포인트!</li>\n<li>2024년 1월 'Flutter Monthly' 😍</li>\n<li>개발 기술 향상을 위한 Dart 3 사용하기. 더 많은 예제와 팁.</li>\n<li>2023년 12월 'Flutter Monthly' 😍</li>\n<li>2023년 11월 'Flutter Monthly' 😍</li>\n<li>Dart 3를 숙지해서 삶을 쉽게 만들기!</li>\n<li>Flutter 3.16 및 Dart 3.2 요약!</li>\n<li>2023년 10월 'Flutter Monthly' 😍</li>\n<li>2023년 9월 'Flutter Monthly' 😍</li>\n<li>2023년 8월 'Flutter Monthly' 😍</li>\n<li>2023년 7월 'Flutter Monthly' 😍</li>\n</ul>\n</body>\n</html>\n"},"__N_SSG":true}