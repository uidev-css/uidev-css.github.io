{"pageProps":{"posts":[{"title":"이제는 당연한 기술, GraphQL 사용법","description":"","date":"2024-06-22 15:57","slug":"2024-06-22-GraphQLisFinallyBoring","content":"\n\n## GraphQL의 종말에 대한 보고는 크게 과장되었습니다. 대신에 트렌드를 넘어서 성숙하고 신뢰할 수 있는 GraphQL이 기관을 더 나게 만드는 방법을 살펴봅시다.\n\n[기술 이름을 여기에 입력]이 죽고 있다는 이야기를 듣게 될 때마다 한 잔 들어보세요. GraphQL은 최근 이러한 내러티브의 주요 주제가 되고 있습니다. 그 종말에 대한 주장, \"무너졌다\"는 생각은 개발자들 사이에서 곳곳에 퍼져 있습니다.\n\n<img src=\"/assets/img/2024-06-22-GraphQLisFinallyBoring_0.png\" />\n\n말할 필요도 없이, 이는 매우 안전하지 않은 음주 게임입니다.\n\n<div class=\"content-ad\"></div>\n\nGraphQL이 죽고 있지는 않아요. 이젠 새로운, 블리딩 엣지 기술은 아니지만, 테크 트위터 포스터 아동으로서 더 이상 대놓고 화제가 되지는 않았어요. 온라인 포럼에서의 뜨거운 논쟁과 흥미로운 주장들은 없어졌지만, GraphQL 그 자체는 견고하고, 잘 이해되는 도구로 성숙해져서 현재 실제 사용되며, 현실 세계의 문제를 해결하는 데 잘 확립되어 있어요.\n\nGraphQL이 드디어 지루해졌어요.\n\n# 지루함의 미덕\n\n지루함은 안정적이에요. 지루함은 신뢰할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\nGraphQL이 StackOverflow Trends를 보고 있다면 정체되었을 수도 있어요...\n\n![이미지](/assets/img/2024-06-22-GraphQLisFinallyBoring_1.png)\n\n...하지만 저는 이것이 초기 흥분 주기의 폭풍 뒤의 침묵이며, 개발자 생태계 내에서의 역할과 목적에 대한 보다 세밀한 이해를 가능케 한다고 주장할 거예요.\n\n제가 설명해 드릴게요.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-22-GraphQLisFinallyBoring_2.png\" />\n\n2015년에는 GraphQL이 최고의 기술로 손 꼽히더니 2023년에는 이젠 여러분의 도구 상자 속의 또 다른 도구가 되었습니다.\n\n여기서 오해가 나타난 것 같아요. GraphQL의 초기 흥행 주기 동안 개발자들 사이에서 REST API를 대체할 것으로 송고되어 자리를 털었습니다. 먼지가 내리고 실용적인 구현이 펼쳐지며, 점점 더 많은 조직에서 운영에 활용할 때, 우리는 하나 분명한 진실을 발견했어요 — GraphQL도 어떤 기술처럼 마법의 탄환은 아니었다는 것.\n\n우리는 GraphQL이 어떤 부분에서 뛰어난 일을 하는지 깨달았어요 — API 조합이 필요하거나 데이터 종속성을 연합해야 하는 경우에는 확실한 선택입니다. GraphQL은 프론트엔드와 백엔드 팀 간의 조직적인 격차를 메우는 데 뛰어난 능력을 발휘했으며, 모든 사람이 합의할 수 있는 공유 계약으로서 우리를 이어주었습니다. 모바일 앱을 만들어야 하고 느린 장치와 네트워크를 고려해야 할 때는 GraphQL이 최선의 선택이 될 거예요.\n\n<div class=\"content-ad\"></div>\n\nGraphQL의 최적 사용 사례와 그렇지 않은 사례를 파악하고, 함정과 절충 사항을 파악했으며, 실 서비스 환경에서의 배포 방법을 알아냈습니다. 그 결과, GraphQL이 지루해진 것이죠.\n\n괜찮아요.\n\n8년 뒤에 GraphQL이 '지루하다'는 것은 후퇴가 아니라, 그에 대한 관심이 식은 반면 GraphQL 자체가 성공했다는 것을 의미합니다.\n\n# GraphQL은 이제 주류가 되었습니다\n\n<div class=\"content-ad\"></div>\n\n이제 많은 회사들이 어떤 형태로든 GraphQL을 사용하고 있습니다.\n\n![GraphQLisFinallyBoring_3](/assets/img/2024-06-22-GraphQLisFinallyBoring_3.png)\n\n예를 들어 Shopify은 GraphQL 스키마가 제공하는 강타입 구조를 활용하여 클라이언트-서버 데이터 매핑을 원활하게 하고 있다. 이전에 Shopify의 외부 REST API에 대한 변경 사항이 발생하면 클라이언트 앱이 오동작하여 클라이언트 측 개발자들이 필드를 정적으로 유형화하고 무료로 전달되는 JSON 응답을 매번 변환해야 했기 때문에 위험이 증가했습니다. GraphQL 스키마는 강력한 형식 지원을 통해 신뢰성, 유형 안정성 및 효율적인 계약 관리를 육성하는 기반을 제공했습니다. 대부분의 기관(예: GitHub)에 대해, 프론트엔드를 위한 직관적인 쿼리 메커니즘이 GraphQL 도입에 대한 수익을 가져다주는 유일한 필수 조건입니다.\n\n그러나 다양한 '지루한' 기술을 사용하고 있지만 지식을 격리하는 서로 다른 팀이 있는 경우는 어떨까요? 이 경우 안정적이고 신뢰할 수 있는 기술을 사용한다고 해도, 지식 격리는 여전히 증가된 조직적 위험을 감수하고 있다는 것을 의미합니다.\n\n<div class=\"content-ad\"></div>\n\n여기서 연합 GraphQL이 도움이 될 수 있습니다. 페더레이션은 여러분이 떨어져 있는 API (gRPC, REST, SOAP, 그리고 심지어 GraphQL도 포함하여) 및 기타 데이터 의존성을 통합 인터페이스로 결합할 수 있는 능력을 제공합니다. 즉, 조직 내 모든 팀을 위한 단일 GraphQL 엔드포인트를 제공하고, 아마도 기업에서 GraphQL 채택을 촉진하는 사용 사례입니다. 단일 GraphQL 엔드포인트를 통해 여러분은 고유한 도전 과제를 직면하게 될 수 있는데, 이는 대부분의 개발자들이 절대로 경험할 수 없는 것들입니다: 확장성을 희생하지 않으면서 구성, 중앙 통제, 팀 독립성, 또는 변화하는 요구 사항에 대한 적응력 등이 있습니다.\n\n연합 GraphQL 아키텍처를 사용하면 조직 데이터 \"풀\"에 추가된 모든 데이터가 즉시 모든 팀에서 사용할 수 있게 됩니다. Walmart, Zillow, Netflix와 같은 모든 기업들은 새로운 데이터 소스를 조직의 중앙 그래프에 포함시키기만 하면(물론, 이것은 다른 연합 GraphQL API일 수도 있습니다) 즉시 모든 팀이 쿼리하고 새롭고 흥미로운 비즈니스 사용 사례를 만들어내기 시작할 수 있습니다. 이 연합 아키텍처는 고유한 데이터 접근 정책, 유효성 검사, 인증 메커니즘 및 프로토콜, 그리고 감시 통제를 확립하고 시행하는 것을 가능하게 하며, 잠재적인 병목 현상을 파악하고 GDPR, HIPAA 등과 같은 산업 규제 준수를 보장하는 데 도움이 되는 것이죠.\n\nGraphQL은 REST API의 대체재가 될만한 것이 아닌 고유한 공간을 조각내어 서비스합니다. 웹 개발이 발전하는 속도를 고려할 때, 몇 년 뒤에 여러분이 GraphQL의 고유한 강점과 완벽하게 일치하는 독특한 문제에 직면할 수도 있습니다. 심지어 프론트엔드 팀이 GraphQL 스키마를 사용하여 커스텀 디렉티브를 통해 회사의 기술 부채를 추적하는 예도 본 적이 있습니다. 즉, 이를 통해 백엔드 팀이 프론트엔드 코드베이스에 들어가지 않고도 리팩토링을 계획할 수 있었던 것이죠. 상당히 독특한 조직적인 사용 사례입니다.\n\n죽어가는 기술로 소문난 기술로서 이것이 나쁘다고 할 수 있을까요?\n\n<div class=\"content-ad\"></div>\n\n# 미래를 내다보며\n\n저기요, 이 글에서 중요한 건 GraphQL이 죽지 않았다는 것이라면서도 현재로서는 이러한 잠재적인 사용 사례가 정말 설득력이 없다는 걸 느끼신다면... 직감을 믿으세요.\n\n만약 진정으로 원한다면 토크 렌치로 못을 박을 수도 있지만, 여러분이 향상된 인프라 투자나 이제부터 감수해야 할 운영 상의 어려움을 감수할 가치가 있을지는 의문입니다.\n\n마찬가지로, CRUD 앱을 운영하는 소규모 팀이라면 REST API가 필요한 경우 GraphQL을 끼워 맞추지 않는 게 좋습니다 — 그리고 그 경우에는 OpenAPI REST가 당장 채택해야 할 \"지루한\" 기술입니다.\n\n<div class=\"content-ad\"></div>\n\n그러나 조직 또는 애플리케이션이 성장할 것으로 예상되면 다중 데이터 종속성이나 연합된 아키텍처를 예측할 수 있습니다. GraphQL을 채택하는 것이 전략적인 결정일 수 있습니다. 그리고 WunderGraph와 같은 도구가 이를 실현하는 데 도움이 될 수 있습니다.\n\nWunderGraph는 하나가 아닌 두 제품이며, 어떤 제품을 선택할지는 현재 가장 긴급한 필요에 달려 있습니다.\n\n## WunderGraph Gateway\n\n여러 다른 API를 관리해야 하는 경우, 각각의 스타일, 인증 프로토콜, 아키텍처를 갖는 다양한 API를 효과적으로 관리하고 싶다면 WunderGraph Gateway가 필요할 것입니다. WunderGraph Gateway는 여러분이 원하는 것입니다. 이것은 SQL/NoSQL DB(플래닛스케일과 같은 DBaaS도 포함됨), Prisma와 같은 ORM, SOAP, OpenAPI REST 또는 GraphQL API, Apollo 연합, OpenAuth, Auth0 등 OIDC/non-OIDC 호환 인증 공급자까지 여러분의 모든 다양한 데이터 원본을 통합할 수 있는 무료이며 오픈 소스 (Apache 2.0 라이센스) Backend-for-Frontend 프레임워크입니다. 이를 통해 이러한 데이터 소스를 모두 간단한 종속성 배열로 추가할 수 있고, 이를 기반으로 전체적으로 안전한 클라이언트를 생성할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nWunderGraph은 개발 환경에서 GraphQL을 사용하여 모든 데이터 소스를 탐색하고 이를 단일 가상 그래프로 통합하여 원하는 데이터를 얻기 위해 GraphQL 연산을 정의합니다. 그리고 클라이언트로는 어떠한 GraphQL도 전달되지 않고 GraphQL 엔드포인트도 공개되지 않습니다. 대신 WunderGraph는 지속적인 쿼리를 사용합니다. 가상 그래프에 대한 작성한 임의의 GraphQL 연산은 해싱되고 서버에 저장됩니다. 클라이언트는 해당 해싱 이름을 호출하여 액세스할 수 있으며, WunderGraph BFF 서버에는 알려진 해시 목록이 있습니다. 사용자가 정의한 지속적인 쿼리 수만큼만 알려진 해시가 있으며, 클라이언트 요청에 대해 유효한 해시에만 응답하며 각 작업에 대해 고유한 엔드포인트로 제공합니다.\n\nGraphQL의 채택 이점을 모두 누리면서 단점은 없앴습니다. 빠르고 효율적인 캐싱 전략과 공개 GraphQL API를 역공학하여 데이터베이스를 잠재적으로 유출하는 사용자를 방지할 수 있습니다.\n\n## WunderGraph Cosmo\n\n만약 당신이 무엇을 하고 있는지 알고 있고, Federation V1/V2 아키텍처가 정말 원하는 것이라면 WunderGraph Cosmo가 딱입니다. 이것은 벤더 잠금이 없는 GraphQL Federation을 위한 오픈 소스 (Apache 2.0 라이선스) 플랫폼입니다. 모든 데이터의 제어권을 유지할 수 있는 완전 자체 호스팅 솔루션으로서, Apollo GraphOS의 대안인 오픈 표준을 기반으로 구축되어 있습니다. 대규모로 통합된 그래프를 구축, 관리 및 협업하려는 경우 필요한 모든 기능을 포함하고 있습니다. 스키마 레지스트리가 있어서 변경사항과 구성 오류를 확인할 수 있으며, 빠르고 효율적인 Federation V1/V2 호환 라우터, 그래프 시각화 및 피더레이션 GraphQL을 위한 분석/분산 추적 플랫폼이 포함되어 있습니다.\n\n<div class=\"content-ad\"></div>\n\n기업용 사례에서는 라이선싱 및 데이터 거버넌스(순응을 보장하기 위함)가 중요합니다. Cosmo가 OSI 승인 라이선스인 Apache 2.0에 따라 제공되며 완전히 자체 호스팅이 가능하기 때문에 엔터프라이즈에서 페더레이티드 GraphQL 채택을 위한 최적의 선택입니다. 더 좋은 점은 이미 Apollo Studio/GraphOS를 사용하고 있다면 페더레이티드 그래프를 관리하는 데 한 번의 클릭만으로 마이그레이션할 수 있습니다.\n\n# 요약하자면...\n\nGraphQL의 소멸에 관한 보고는 크게 과장되었습니다.\n\nGraphQL이 안정적인 무역말을 하도록 변하는 것은 전혀 놀라운 일이 아닙니다. 이것이 성공이라는 것이죠. 새로운 기술이 지나치게 과대평가되던 시기를 겪은 뒤에 이를 극복하고, 생존하며 개발자의 무기함에 신뢰할 수 있는 도구로 자리 잡고, 특정한 실제 문제들을 해결하기 위해 노력합니다. GraphQL이 추세에서 평정기에 접어 들었다는 것을 인정하는 것은 그 하락의 선언이 아니라 그 성숙함에 대한 증거입니다.\n\n<div class=\"content-ad\"></div>\n\n사실 GraphQL은 다양한 API 스타일이 점점 더 보편화되면서 더욱 중요해지고 있습니다. GraphQL Federation의 능력은 다양한 API, 마이크로서비스, 데이터 소스를 통합하여 일관된 연합 구조로 만드는 데 거대한 잠재력을 갖고 있습니다. 규모 확장 시, Federation은 각 팀이나 서비스의 독립성을 희생하지 않고 공유 데이터 풀에 효율적으로 액세스할 수 있는 연결된 시스템을 구축하는 데 우리가 가진 최고의 도구입니다.\n\nWunderGraph (Cosmo, 또는 Gateway와 같은)와 같은 OSI(Open Source Initiative)가 승인한 오픈 소스 도구는 기업들이 라이선스 장벽 없이 GraphQL을 채택할 수 있을 뿐만 아니라 데이터 거버넌스 및 분산 자율성을 유지하면서 다양하고 분리된 진화하는 기술과 함께 작업하기를 더 쉽게 만들어 줍니다.","ogImage":{"url":"/assets/img/2024-06-22-GraphQLisFinallyBoring_0.png"},"coverImage":"/assets/img/2024-06-22-GraphQLisFinallyBoring_0.png","tag":["Tech"],"readingTime":7},{"title":"12로 만드는 셀프 호스팅 디지털 아이덴티티 구축 방법","description":"","date":"2024-06-22 15:56","slug":"2024-06-22-ICreatedAComprehensiveSelf-HostedDigitalIdentityfor12month","content":"\n\n## 스마트 검색, 블로그, 뉴스레터, 분석, 제휴 마케팅, RSS 피드 — 모두 자체 호스팅되고 월 12달러 미만!\n\n![이미지](/assets/img/2024-06-22-ICreatedAComprehensiveSelf-HostedDigitalIdentityfor12month_0.png)\n\n지난 2개월 동안 나는 블로그 웹사이트, 뉴스레터 시스템, 웹 트래픽 분석, 제휴 마케팅, 스마트 AI 검색, 그리고 예전 방식의 RSS 피드를 모두 포함한 포괄적인 디지털 아이덴티티를 만들었습니다.\n\n이들을 사용하던 다양한 프로프라이터리 도구는 월 100달러 이상 지출이었지만, 이제는 모든 것을 디지턈 오션 인스턴스에서 자체 호스팅하면 월 12달러로 가능합니다.\n\n<div class=\"content-ad\"></div>\n\n지난 8주 동안 시스템을 구축해 왔는데, 다른 블로그 포스트에서 제가 배운 내용을 공유해 왔어요. 그런데 이번 블로그 포스트에서는 그 모든 것을 한데 모아서 큰 그림을 이해하는 데 도움이 되도록 할 거에요.\n\n관심 있으시다면, 시작해볼까요?\n\n# 웹사이트 스택\n\n모든 것은 제 웹사이트 https://irtizahafiz.com에서 시작돼요.\n\n<div class=\"content-ad\"></div>\n\n많은 다양한 기술이 이것을 만드는 데 사용되었습니다. 따라서 기술 스택을 나열하기 전에 카테고리화해 보겠습니다.\n\n- 프론트엔드 — NextJS, ChakraUI\n- 백엔드 — FastAPI, Postgres, Nginx\n- 보안 — Nginx Rate Limits, Let’s Encrypt SSL Certificates\n- 배포 — Nginx Reverse Proxy, Digital Ocean Droplet\n\n곧 듣게 될 다른 모든 기술들과 함께, 저의 웹사이트는 Digital Ocean 인스턴스 안에서 자체 호스팅되어 있습니다.\n\nNextJS 서버, 백엔드 API 엔드포인트, Postgres 데이터베이스를 포함해 모든 것이 동일한 머신에 있습니다.\n\n<div class=\"content-ad\"></div>\n\n웹사이트는 서버 측에서 렌더링되어 SEO 이점이 매우 크며, 모든 콘텐츠는 정적으로 생성되므로 반응성이 뛰어납니다.\n\n# 블로그 및 유튜브 인프라\n\n대부분의 개인 웹사이트와 마찬가지로, 내 웹사이트의 주요 목적은 내가 게시하는 모든 콘텐츠의 홈으로 기능하는 것입니다.\n\n구체적으로는 내 블로그 글과 유튜브 동영상입니다.\n\n<div class=\"content-ad\"></div>\n\n나의 YouTube 동영상에 관한 경우, 제 모든 메타데이터 - 제목, 설명, URL -을 Postgres 데이터베이스에 저장합니다. 내 웹사이트에서는 동영상을 호스팅하는 대신 YouTube 동영상에 링크를 제공합니다. 그것이 더 합리적이라고 생각했거든요.\n\n하지만, 블로그 글은 내가 직접 호스팅합니다.\n\n내 NextJS 앱에서 모든 블로그 글은 Markdown 파일로 저장됩니다. 특별한 형식인 mdx를 사용하는데, 이것은 Markdown 파일을 업그레이드한 것으로 생각할 수 있습니다. 이 형식을 사용하면 코드 블록을 렌더링하거나 Markdown 콘텐트 내에 \"좋아요\" 카운터, 날짜 선택기 등과 같은 동적 React 컴포넌트를 넣을 수 있습니다.\n\n빌드 시간에 NextJS 앱은 모든 블로그 콘텐츠를 정적으로 생성합니다.\n\n<div class=\"content-ad\"></div>\n\n저는 이 설정이 매우 직관적이라고 생각해요. 일반적인 마크다운 파일에 작성하는 것은 매우 간단해요. NextJS는 내 마크다운 파일을 읽기 쉬운 웹페이지로 바꾸는 모든 번거로운 작업을 처리하기 때문에 게시하는 것은 아주 쉬워요.\n\nSquarespace나 Ghost 같은 플랫폼이 제공하는 콘텐츠 관리 시스템(CMS)이 없으면, 이 정도면 충분하다고 생각해요.\n\n# 뉴스레터 및 메일링 리스트 관리자\n\n자체 호스팅 여정을 시작할 때, 무료 뉴스레터나 메일링 리스트 관리자를 만드는 것이 가장 복잡할 것이라는 것을 알고 있었어요.\n\n<div class=\"content-ad\"></div>\n\n좋은 예로는 Ghost, Squarespace, MailChimp 등의 플랫폼이 있습니다. 구독/해지 양식, 규정 준수 알림, 거부 링크, 템플릿, 캠페인 일정 등을 처리해줍니다.\n\n비슷한 기능 세트를 갖춘 것을 0부터 만드는 것은 고려할 수 없었습니다.\n\n여기 Listmonk이 나왔습니다.\n\nListmonk은 자체 호스트할 수 있는 무료 오픈 소스 뉴스레터 및 메일링리스트 관리자입니다.\n\n<div class=\"content-ad\"></div>\n\n요즘 여기에 관해 글을 썼어. 관심이 있으면 참고해봐. 간단히 말하자면, 1만 명의 구독자 이메일 뉴스레터 시스템을 호스팅하는 데 필요한 기능의 90%를 제공해줘. Digital Ocean 인스턴스에서 호스팅 중이고, 따라서 비용은 $0이야.\n\n# 웹 분석\n\n웹사이트를 만드는 것도 중요하지만, 성능을 측정하고 사용자 행동을 최적화하는 것도 중요해.\n\n좋은 분석 도구가 없으면 올바른 컨텐츠가 올바른 사람들에게 제공되는지 판단하기 어려워. 이런 사용자 통찰력을 제공하는 가장 일반적인 도구는 Google Analytics야.\n\n<div class=\"content-ad\"></div>\n\n하지만 여러 가지 이유로 인해 - 이곳과 이곳에서 썼던 것들에 대해 썼었지만 - 저는 대신에 비공개, 무료, 그리고 오픈 소스 대안을 선택했습니다.\n\n우마미(Umami)를 소개합니다.\n\nListmonk과 유사하게, 우마미도 전통적으로 필요한 기능의 거의 90%를 제공하며 완전한 개인 정보 보호를 유지할 수 있고, 비용은 $0입니다.\n\n이것을 통해 웹사이트 성능과 고객 상호 작용을 추적할 수 있으며, 전환 퍼널을 측정하는 데 사용하는 사용자 정의 이벤트를 추적할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n모든 고객 데이터는 내 디지털 오션 서버에 호스팅된 포스트그레스 데이터베이스에 로컬로 저장되어 있습니다. 따라서 개인 정보 보호와 안전이 모두 보장됩니다.\n\n# 스마트 검색\n\n지금까지 관심 가져 주셔서 감사합니다. 이제 여러분과 공유할 가장 흥미로운 기능이 있어요.\n\n사용자가 나의 모든 블로그와 유튜브 비디오를 검색할 수 있는 Open AI 기반의 스마트 검색입니다.\n\n<div class=\"content-ad\"></div>\n\n저는 이 주제에 대해 몇 가지 깊이 있는 조사를 했어요: '실시간 스마트 검색 파이프라인 구축하기'와 'OpenAI 임베딩 및 Postgres 벡터를 사용한 AI 검색 기능 구축하기'에 대해 찾아보고 싶다면요.\n\n위에서 설명한 모든 것과 비슷하게, 이 기능을 지원하는 모든 인프라는 무료로 동일한 Digital Ocean 클러스터에 호스팅되어 있어요.\n\n다만 하나의 비용 구성 요소가 있습니다 — OpenAI의 임베딩 API를 사용하는 데 필요한 $$$요.\n\n보통 몇 센트밖에 안 돼요. 이를 더 줄이기 위해, 파이프라인의 각 단계에 캐시를 구현했어요. 이 캐시 또한 제 서버에 로컬로 호스팅되어요.\n\n<div class=\"content-ad\"></div>\n\n모든 기능 중에서도 \"스마트 검색\" 기능이 가장 기쁨을 주었어요. 그래서 여러분이 이것을 시도해 보길 원해요. https://irtizahafiz.com 에서 확인해보세요.\n\n# RSS 피드\n\n그럼 이것으로 하나의 간단하지만 강력한 기능인 RSS 피드를 마무리하겠습니다.\n\n저는 RSS 피드의 열렬한 팬이에요.\n\n<div class=\"content-ad\"></div>\n\n알고리즘에 따르기보다는, 내가 존경하는 사람들의 콘텐츠를 명시적으로 따르는 것을 선호해요. 그리고 그들의 블로그를 내 RSS 피드에 추가해요.\n\n읽을 시간이 생기면, 알고리즘에서 주는 것이 아니라 내가 의도적으로 RSS 피드에서 가져와요.\n\n그래서 내 블로그 글 전체를 포함한 RSS 피드를 공개하는 것이 중요했어요.\n\npython-feedgen을 사용하여 RSS 피드를 정의하는 XML 파일을 구성했어요. 이 피드는 내 로컬에 호스팅된 모든 Markdown 파일을 위해 만들어졌어요.\n\n<div class=\"content-ad\"></div>\n\n매번 새 블로그 글을 게시할 때마다, 제 서버에서 스크립트가 실행되어 RSS 피드를 업데이트하고 파일을 https://irtizahafiz.com/feed.xml에 게시합니다.\n\n원하시는 RSS 피드 리더에 피드를 가져올 수 있습니다.\n\n# 마무리\n\n이것까지 읽어주셨다면, 유익하게 받아들여 주셨으면 좋겠습니다.\n\n<div class=\"content-ad\"></div>\n\n월 12달러 미만으로 이러한 포괄적인 디지털 존재를 만들어 나가는 것이 정말 즐겁습니다.\n\n제품군을 전부 만드는 것이 흥미로웠을 뿐만 아니라 블로그, 뉴스레터, 분석, 스마트 검색, RSS 피드까지 자체 호스팅하고 개인 정보 보호에 중점을 둔 기술을 사용할 수 있다는 것도 멋졌습니다.\n\n저를 따라와 주실 수 있는 몇 가지 방법이 있습니다: Medium에서 나를 팔로우하거나, 웹사이트를 구독하거나, YouTube에서 나를 팔로우해주세요.","ogImage":{"url":"/assets/img/2024-06-22-ICreatedAComprehensiveSelf-HostedDigitalIdentityfor12month_0.png"},"coverImage":"/assets/img/2024-06-22-ICreatedAComprehensiveSelf-HostedDigitalIdentityfor12month_0.png","tag":["Tech"],"readingTime":5},{"title":"개발자가 WCAG을 읽는 방법","description":"","date":"2024-06-22 15:54","slug":"2024-06-22-HowadevelopershouldreadWCAG","content":"\n\n\n![이미지](/assets/img/2024-06-22-HowadevelopershouldreadWCAG_0.png)\n\n# 왜 WCAG를 읽기 어려운가요\n\nWCAG는 가독성으로 유명하지 않아요.\n\n접근성에 대해 처음 알게 되었을 때, 읽어보려 했어요. 몇 번의 낮잠과 커피 뒤에 결국 포기했죠. 그 이유는 프로그래밍 언어나 마크업 언어를 배우려고 시도한 것처럼 읽으려고 했기 때문이에요.\n\n\n<div class=\"content-ad\"></div>\n\n그래서 왜 안 될까요? 나는 스스로 공부한 개발자니까요. C 언어를 스스로 배울 수 있다면, 웹 접근성도 충분히 다룰 수 있을 거에요, 맞죠?\n\n웹 접근성 세계로 뛰어들려고 하는 개발자이거나 좀 더 접근성 있는 콘텐츠를 제공하려는 분이라면, 아마도 WCAG에 가서 다른 튜토리얼이나 안내랑 비슷하겠거니 생각할 것입니다.\n\n스포일러: 아닙니다.\n\n이건 어려울 수 있어요. 복잡해서 그런 게 아니라, 굉장히 추상적이고 모호하게 쓰여져 있어서 읽기 어려울 수 있어요. 예시를 찾아야 하고, 그 용어들만큼은 그냥... 음.\n\n<div class=\"content-ad\"></div>\n\nWCAG은 마크업, 스타일 또는 스크립트를 중심으로 하지 않습니다. 원칙을 중심으로 하고 있습니다. 이것을 이해하면 더 쉬워집니다.\n\n저는 웹 개발을 처음 배울 때 책을 사용했어요. 웹의 역사, 웹 서버 동작 방식 및 다른 필수적인 내용을 다 읽었을까요? 저도 아니에요!\n\n\"어떻게 모든 것을 만드는지 보여줘!\"\n\n그래서 \"첫 번째 웹 페이지 만들기\" 섹션으로 스킵하고 거기서부터 시작했어요. 만약 접근성에 대해 이와 같은 것을 찾고 있다면, 이것이 당신을 위한 것입니다.\n\n<div class=\"content-ad\"></div>\n\n# WCAG을 읽는 방법을 추천합니다\n\n다음 링크를 새 탭에서 열고 시작해보세요: [WCAG 2.2](링크)\n\n페이지의 왼쪽 탐색 창에서 전체 목차를 찾을 수 있습니다. 매우 익숙해지세요 - 자주 사용하게 될 거예요.\n\n<div class=\"content-ad\"></div>\n\n페이지를 처음부터 끝까지 읽지 않는 것이 좋습니다. 대신에 추가적인 공부의 기초가 되는 가장 관련성이 높은 부분을 읽는 것을 제안합니다.\n\n당신이 예전처럼 나와 같다면, \"무엇을 해야 할까요...?\"라는 질문에 대한 답변을 원할 것입니다. 문서 자체, 역사, 또는 원칙들에 대한 세부사항은 아닙니다. 불행히도, 원칙에서 벗어날 수 없습니다. 참고하세요. 일반 아이디어에서 시작해서 구체적인 실행으로 이어나가세요. 이렇게 하면 미래에 WCAG를 쉽게 탐색할 수 있게 될 것입니다.\n\n다음은 WCAG를 읽기를 제안하는 순서입니다:\n\n- 원칙 (일급 번호 매겨진 점): 웹 접근성의 기초를 제공하는 주요 아이디어\n- 지침 (이중 번호 매겨진 점): 성공 기준을 그룹화하는 기본 접근성 목표\n- 구체적인 용어\n- 성공 기준 (가장 관련성이 높은 것들): 준수를 측정하는 검사 가능한 기준\n- SC 페이지 이해\n\n<div class=\"content-ad\"></div>\n\n다시 말해서: 먼저 넓게, 그 다음으로는 깊게 학습하세요.\n\n어떤 것을 외우려고 하지 마세요. 이 안내서의 목적은 웹 접근성의 기본 원리를 이해하는 데 도움을 주는 것뿐입니다. 이 안내서를 완료하면, 필요한 구체적인 해결책을 쉽게 찾을 수 있을 것입니다.\n\n## 원칙\n\n아래에 나열된 원칙에서는, 웹 접근성 이해 안내서의 네 가지 원칙 섹션에서의 텍스트가 포함되어 있습니다.\n\n<div class=\"content-ad\"></div>\n\n다음은 원칙들입니다:\n\n- 인지 가능: 정보 및 사용자 인터페이스 구성 요소는 사용자가 인지할 수 있는 방식으로 제시되어야 합니다. 즉, 사용자는 제시되는 정보를 인식할 수 있어야 합니다 (모든 감각으로는 가시적이지 않아야 함).\n- 작동 가능: 사용자 인터페이스 구성 요소 및 탐색은 작동 가능해야 합니다. 이는 사용자가 인터페이스를 작동할 수 있어야 함을 의미합니다 (사용자가 수행할 수 없는 상호 작용을 요구해서는 안 됨).\n- 이해 가능: 정보 및 사용자 인터페이스의 작동은 이해할 수 있어야 합니다. 즉, 사용자는 정보뿐만 아니라 사용자 인터페이스의 작동도 이해할 수 있어야 합니다 (콘텐츠나 작동이 사용자의 이해를 넘어서서는 안 됨).\n- 견고: 콘텐츠는 보조 기술을 포함한 다양한 사용자 에이전트에서 해석할 수 있는 충분히 견고해야 합니다. 이는 기술이 발전함에 따라 사용자가 콘텐츠에 접근할 수 있어야 함을 의미합니다 (기술 및 사용자 에이전트가 진화할 때에도 콘텐츠가 접근 가능하도록 유지되어야 함).\n\n쉽죠?\n\nWCAG가 사용자에 대해 언급할 때(예: 인지 가능: \"... 사용자에게 제시되어야 함...\"), 능력, 입력 메커니즘(마우스, 키보드, 음성 인식 등), 출력 메커니즘(모니터, 스크린 리더, 점자 디바이스 등)이 다양한 사용자를 가리킨다는 것을 기억해주세요.\n\n<div class=\"content-ad\"></div>\n\n## 지침\n\n한 단계 더 깊게 파는 것으로 가봅시다 — 바로 지침입니다. 두 번째 수준에서 (1.1 텍스트 대체, 1.2 시간 기반 미디어, 1.3 적응 가능 등) 이를 찾을 수 있을 겁니다.\n\nWCAG 페이지와 이 페이지를 왔다갔다 하는 수고를 덜어드리기 위해, 여기에 그대로 적힌 내용을 안내해 드릴게요:\n\n- 1.1 텍스트 대체: 비텍스트 콘텐츠에 대한 텍스트 대체물을 제공하여 큰 글씨, 점자, 음성, 기호 또는 간단한 언어 등 다른 형태로 변경할 수 있게 합니다.\n- 1.2 시간 기반 미디어: 시간 기반 미디어에 대한 대체물을 제공합니다.\n- 1.3 적응 가능: 정보나 구조를 잃지 않고 다른 방식(예: 간단한 레이아웃)으로 제공될 수 있는 콘텐츠를 생성합니다.\n- 1.4 구별 가능: 전경과 배경을 분리하여 사용자가 내용을 쉽게 볼 수 있도록 합니다.\n- 2.1 키보드 접근 가능: 모든 기능을 키보드로 이용할 수 있게 합니다.\n- 2.2 충분한 시간: 사용자가 콘텐츠를 읽고 사용하는 데 충분한 시간을 제공합니다.\n- 2.3 발작 및 신체 반응: 발작이나 신체 반응을 일으킬 수 있는 방식으로 콘텐츠를 디자인하지 않습니다.\n- 2.4 탐색 가능: 사용자가 내비게이션을 도와주고 콘텐츠를 찾고 자신의 위치를 파악할 수 있는 방법을 제공합니다.\n- 2.5 입력 방식: 키보드 이상의 다양한 입력을 통해 기능을 조작하기 쉽도록 합니다.\n- 3.1 가독성: 텍스트 콘텐츠를 읽기 쉽고 이해하기 쉽도록 합니다.\n- 3.2 예측 가능성: 웹 페이지가 예측 가능한 방식으로 표시되고 작동할 수 있도록 합니다.\n- 3.3 입력 지원: 사용자가 실수를 피하고 수정하는 데 도움을 줍니다.\n- 4.1 호환성: 보조 기술을 포함한 현재와 미래의 사용자 에이전트와의 호환성을 극대화합니다.\n\n<div class=\"content-ad\"></div>\n\n\"그런데 어떻게 해야 할까요?\"라고 궁금해하고 있을 수 있습니다. 유감스럽게도 답을 얻으려면 조금 더 깊이 파고들어야 할 것입니다. 성공 기준에서도 종종 일반적인 답변만 제공됩니다. 하지만 걱정하지 마세요 — 이 기사의 뒷부분에서 예시를 보여드릴 거에요.\n\n## 구체적인 용어\n\n성공 기준을 다루기 전에 몇 가지 용어에 대해 알아두면 좋을 것 같아요. 알겠어요, 알겠어요 — \"그냥 진행하자!\"라고 생각할 수 있겠죠? 중요한데요, WCAG에서 사용하는 몇 가지 용어는 개발자들이 사용하고 있는 용어들과 다른 의미를 가지고 있습니다.\n\n컴포넌트/사용자 인터페이스 컴포넌트\n\n<div class=\"content-ad\"></div>\n\n사용자들에게 단일 기능을 제어하는 것으로 인식되는 콘텐츠의 일부입니다. 일반적으로 입력 컨트롤입니다.\n\n컨텍스트 변경\n\n보조 기술 사용자들에게 혼란을 일으킬 수 있는 쉬운 변경들 — 이는 새 탭에서 열기, 초점을 갖는 요소 변경, 또는 페이지를 크게 변경하는 것을 포함할 수 있습니다.\n\n제목들\n\n<div class=\"content-ad\"></div>\n\n`h1`부터 `h6`까지, `th` 요소의 \"헤더\"와 혼동되지 않도록 주의해주세요.\n\n이름\n\n프로그래밍적으로 지정된 레이블 텍스트입니다. 이는 레이블의 텍스트, aria-label 속성의 값 또는 aria-labelledby로 지정된 레이블로 사용되는 텍스트일 수 있습니다. 이것은 name 속성과 혼동해서는 안 됩니다.\n\n역할\n\n<div class=\"content-ad\"></div>\n\n요소의 목적입니다. 이는 기본 HTML 요소를 사용하지 않을 때에만 관련이 있습니다. 예를 들어 `select` 컨트롤 대신 `div`를 사용할 때입니다. `select` 컨트롤의 역할은 내재적인데 (역할에 대해 추가 조치가 필요하지 않음), `select` 역할을 하는 `div`는 역할 속성이 필요합니다.\n\n## 성공 기준\n\n일부 웹 접근성 옹호자들은 이에 동의하지 않을 수 있지만, 첫 번째로 웹 접근성 가이드라인의 일부 성공 기준만 살펴보는 것을 권장합니다. 이것은 WCAG와 웹 접근성에 대한 기초를 이해하는 데 좋은 기반이 될 것입니다.\n\n항상 나중에 다시 찾아올 수 있습니다. 당신을 웹 접근성 옹호자로 만들려는 것이 아닙니다. WCAG를 읽는 데 이끌어주기 위해 노력하고 있을 뿐입니다. 적어도 당신이 코드에 작은 변경을 가하여 보다 접근성이 더 좋은 콘텐츠를 제공하도록 영감을 받기를 희망합니다.\n\n<div class=\"content-ad\"></div>\n\n제 경험 상 가장 일반적으로 위배되는 기준이 포함된 Criteria를 포함했습니다. 내가 포함한 Criteria에 동의하지 않는다면 알려줘도 괜찮아.\n\n성공 기준(SC), 준수 수준(A는 최소한의 수준이며, 따라서 가장 중요함), 그리고 기본 설명을 나열하고 있어. 나는 Criteria의 아이디어를 전달하기 위해 detail이 아닌 항목을 포함하지 않고 있어:\n\n- SC 1.1.1 비텍스트 콘텐츠 (수준 A): 사용자에게 제공되는 모든 비텍스트 콘텐츠에는 해당 목적을 충족하는 대체 텍스트가 제공돼야 해 (예외 사항이 있음).\n- SC 1.3.1 정보 및 관계 (수준 A): 프레젠테이션을 통해 전달되는 정보, 구조, 및 관계는 프로그램적으로 결정될 수 있거나 텍스트로 제공돼야 함.\n- SC 1.3.3 감각적 특징 (수준 A): 내용을 이해하고 작동하기 위한 지침은 모양, 색상, 크기, 시각적 위치, 방향, 또는 소리와 같은 구성 요소의 감각적 특성에만 의존해서는 안 돼.\n- SC 1.4.1 색상 사용 (수준 A): 정보 전달, 동작 표시, 응답 유도, 또는 시각적 요소 구별의 유일한 시각 수단으로 색상을 사용해서는 안 돼.\n...\n\n아직 따라 오고 있어? 멋져! 이제 본론으로 들어가 보자.\n\n\n\n<div class=\"content-ad\"></div>\n\n## 성공 기준 페이지 이해하기\n\n![이미지](/assets/img/2024-06-22-HowadevelopershouldreadWCAG_2.png)\n\n각 성공 기준과 관련된 “이해” 링크가 함께 제공됩니다. 이를 통해 해당 기준 및 이를 충족하는 방법에 대한 매우 유용한 정보를 얻을 수 있습니다. 일반적으로 다음과 같은 내용을 포함합니다:\n\n- 의도: 기준의 목적 및 해결을 시도하는 문제\n- 혜택: 기준을 충족할 때 누가 혜택을 받고 어떻게\n- 예시\n- 자료: 기준에서 다루는 주제에 대한 비공식 자료\n- 기법: 기준을 충족하는 해결책으로의 링크 — 일반적으로 충분한(기준을 충족하는 해결책), 자문(필수적이지 않은 기법, 단지 제안만), 실패(기준을 충족하지 못하는 예시)으로 구분됩니다. 특정 해결 방안을 찾고 있다면, 여기에서 찾을 수 있습니다.\n- 주요 용어\n- 테스트 규칙: 기준 테스트에 도움이 되는 부분적 검사 규칙입니다. 기억하세요: 테스트 규칙 중 하나라도 실패하면 관련 기준도 실패입니다 — 하지만 모든 테스트 규칙을 통과하는 것이 항상 기준을 충족한다는 의미는 아닙니다.\n\n<div class=\"content-ad\"></div>\n\n실제 기준을 충족(또는 미달)한 예제를 찾고 싶다면, 해당 내용은 기법 섹션에서 찾을 수 있습니다.\n\n“어떻게 충족시킬 것인지” 링크에 대해 궁금할 수도 있습니다. 저는 이 링크를 사용하지 않는데, 보통 “이해” 페이지에서 이미 제공되는 정보를 포함하고 있고, 자주 업데이트되지 않는 것으로 보입니다.\n\n# 결론\n\n웹 개발자이며 보다 접근성 있는 콘텐츠를 제공하려고 한다면, 감사합니다! 웹은 여러분과 같은 개발자가 더 많이 필요합니다.\n\n<div class=\"content-ad\"></div>\n\n이 글은 개발자를 접근성 옹호자나 전문가로 만들기 위한 것은 아닙니다. 이 글은 올바른 일을 하려는데 WCAG의 분량과 언어에 압도되는 개발자들을 위해 썼어요.\n\n사용법에 익숙해지면, 접근성 질문에 빨리 대답할 수 있게 될 거에요.\n\n기억해 주세요: WCAG를 만족하는 것은 내용을 규정에 맞게 만드는 것뿐이고, 접근성은 단지 시작에 불과해요. 접근성은 개선하고 콘텐츠의 이용 가능성을 확대하기 위한 끝없는 노력이에요.\n\n요약하면, WCAG는 시작에 불과해요.\n\n<div class=\"content-ad\"></div>\n\n# 링크\n\n## WCAG\n\n- WCAG 2.2\n- WCAG 2 개요\n- WCAG 이해를 위한 소개\n- WCAG 2.2 충족 방법 (빠른 참고)\n\n## 더 많은 자료\n\n<div class=\"content-ad\"></div>\n\n- 디지털 접근성으로 향하는 길, Xurxe Toivo García가 쓴 글\n- 더 나은 개발자가 되는 방법: 접근성을 고려하여 빌드하기, India의 글\n\n## 나의 관련 기사\n\n- 접근성에 대한 관심은 필수 사항이 아닙니다\n- 접근성 체크리스트 (제 1부): 일반적으로 놓치는 다섯 가지 항목\n- 접근성 체크리스트 (제 2부): 일반적으로 놓치는 네 가지 항목\n- WCAG 2.2 — 드디어 여기에 있습니다","ogImage":{"url":"/assets/img/2024-06-22-HowadevelopershouldreadWCAG_0.png"},"coverImage":"/assets/img/2024-06-22-HowadevelopershouldreadWCAG_0.png","tag":["Tech"],"readingTime":7},{"title":"대시보드 UI 디자인 예시 크리에이티브와 마케팅  258번째 컬렉션","description":"","date":"2024-06-22 15:52","slug":"2024-06-22-DashboardUIDesignExamplesCreativeMarketingvol258","content":"\n\n## 디지털 마케팅 분야를 위해 디자인된 창의적이고 마케팅 대시보드를 살펴보세요. 창의적인 웹 앱 개발팀이 만들어, 예술적이면서도 기능적인 대시보드를 제공합니다.\n\n## 게임 스트림 웹사이트 플랫폼 UI 디자인\n\n👨‍🎨 Roohi Koohi ✦\n\n대시보드 디자인은 시각적으로 눈에 띄며, 대비와 가독성을 위해 다크 모드를 효과적으로 활용합니다.\n\n<div class=\"content-ad\"></div>\n\n인터페이스는 직관적인 레이아웃으로 빛나며 실시간 데이터, 사용자 정의 옵션 및 상호 작용 요소를 원활하게 통합합니다.\n\n주목할 만한 기능으로는 아이콘 활용이 돋보이고 잘 정리된 내비게이션이 사용자 참여와 데이터 접근성을 향상시킵니다.\n\n## 작업 관리 대시보드\n\n👨‍🎨 파이어아트 UI/UX\n👥 파이어아트 스튜디오\n\n<div class=\"content-ad\"></div>\n\n대시보드 디자인은 사용성과 시각적 명확성에 중점을 둔 깔끔하고 최소주의적인 레이아웃을 특징으로 합니다.\n\n중요한 요소로는 프로젝트 일정과 성과 지표에 대한 빠른 통찰을 제공하는 주요 달력과 활동 추적기가 포함되어 있습니다.\n\n섬세한 색상과 명확한 타이포그래피의 사용이 가독성을 높이며, 시간 추적 및 작업 관리 도구의 통합은 생산성 모니터링을 위한 포괄적인 기능을 제공합니다.\n\n## NexusX — 인공지능 기반 분산형 블록체인 거래 플랫폼\n\n<div class=\"content-ad\"></div>\n\n👨‍💻 Outcrowd\n\n이 대시보드 디자인은 세련된 어두운 테마로 빛나는데, 데이터 시각화를 효과적으로 부각시킵니다.\n\n실시간 분석과 AI 기반 통찰력을 통합하여 가치 있는 최신 정보를 제공합니다.\n\n자세한 재무 개요와 사용자 친화적 레이아웃 등 주요 기능을 갖추어 사용성과 기능성을 향상시켜 포괄적인 데이터 분석이 가능합니다.\n\n<div class=\"content-ad\"></div>\n\n## AlignUI 디자인 시스템 ✤ Apex 대시보드\n\n👨‍🎨 Ümit Çelik\n\n이 재무 및 은행 대시보드는 구조화된 레이아웃으로 뛰어나며 총 매출 및 총 주문과 같은 주요 재무 지표를 강조합니다.\n\n다크 테마는 제시된 분석 및 데이터 트렌드에 집중하는 데 도움이 됩니다. 사이드바 내비게이션은 사용성을 향상시키며 데이터 카테고리의 명확한 분할은 효율적인 사용자 상호 작용과 빠른 데이터 검색을 지원합니다.\n\n<div class=\"content-ad\"></div>\n\n## AR 마케팅 모바일 iOS 앱 디자인 템플릿\n\n👨‍🎨 Svetlana Kolpakova\n👥 Purrweb UI/UX Agency\n\n이 대시보드 디자인은 투명한 위젯 스타일로 인상적이며 현대적이고 공기처럼 맑은 미학을 제공합니다.\n\n성장, 분석 및 사용자 방문과 같은 주요 지표가 중요하게 표시되어 있어 데이터를 쉽게 이해할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n색상 코딩과 명확한 타이포그래피 사용은 가독성을 높여주고, 전체적인 레이아웃은 효율적인 의사 결정을 위한 필수 정보에 빠르게 접근할 수 있도록 합니다.\n\n## My Credit Score — 금융 대시보드 UI UX 디자인\n\n👨‍🎨 Extej UI UX 디자인 에이전시\n\n이 대시보드는 주요 금융 메트릭에 우선순위를 두는 깔끔하고 직관적인 레이아웃으로 빛납니다.\n\n<div class=\"content-ad\"></div>\n\n그라데이션 색상과 선명한 굵은 타이포그래피를 사용하여 가독성과 시각적 매력을 높였어요.\n\n참고할 점은 상세한 신용 점수 순위와 포괄적인 빛 그래프가 있는데, 이는 사용자들이 자신의 금융 건강 상태를 빠르고 효과적으로 파악할 수 있도록 도와줘요.\n\n## DaxCapMarket — 암호화폐 대시보드\n\n👨‍🎨 Dipa Product\n👥 Dipa Inhouse\n\n<div class=\"content-ad\"></div>\n\n이 대시보드는 명확하고 조직적인 레이아웃으로 금융 분석에 이상적입니다. 중요한 구성 요소는 주요 가격 차트와 유동성 세부 정보로, 한눈에 다양한 통찰을 제공합니다.\n\n사이드바 탐색과 여백 활용은 사용자 경험을 향상시켜 데이터에 쉽게 접근하고 소화할 수 있도록 합니다.\n\n## motmotan — 물류 대시보드 관리자\n\n👨‍🎨 Bayu Sasmita🍃\n👥 Caraka\n\n<div class=\"content-ad\"></div>\n\n제공된 대시보드 디자인은 명확성과 효율성에 중점을 둔 매우 기능적입니다.\n\n핵심 강점은 트렌드 그래프와 상세 배송 목록에서 확인할 수 있는 재무 및 운영 지표의 동적 개요입니다. 레이아웃은 빠른 통찰과 조치를 용이하게하며, 운영 효율성 및 의사 결정에 중요합니다.\n\n## 자금 관리 대시보드\n\n👨‍🎨 사존\n\n<div class=\"content-ad\"></div>\n\n대시보드 디자인은 밝고 환영하는 색상 구성을 활용하여 총 보유 자산 및 대출 자금과 같은 핵심 금융 데이터에 효과적으로 관심을 집중시킵니다.\n\n레이아웃은 간소화되었으며 사용자 중심으로 구성되어, 거래부터 계좌 개요까지 다양한 금융 카테고리를 쉽게 탐색할 수 있도록 지원합니다.\n\n특히, 개인화된 인사말은 사용자 참여를 촉진하여 맞춤형 탐색 경험을 제공합니다.\n\n## 온라인 교육 — 웹 디자인\n\n<div class=\"content-ad\"></div>\n\n👨‍🎨 Anastasia Golovko\n\n이 교육 플랫폼 대시보드의 디자인은 깔끔하고 사용자 친화적인 인터페이스로 모범사례입니다. 이는 다양한 강좌에 쉽게 접근할 수 있도록 돕는다.\n\n부드러운 파스텔 색상과 간단한 아이콘을 잘 활용하여, 학습하기에 유리한 지루하지 않는 환경을 만들었다.\n\n강좌 평가 및 학생 참여 지표와 같은 주요 요소가 효과적으로 강조되어, 사용자 상호작용과 유지를 촉진한다.\n\n<div class=\"content-ad\"></div>\n\n## 작업 관리 시스템\n\n👨‍🎨 Yev Ledenov\n👥 Ledo\n\n이 교육 플랫폼 대시보드는 사용자 참여와 진행 추적을 강조한 훌륭한 디자인입니다.\n\n깨끗한 선과 부드러운 색상 팔레트의 사용은 수업 완료율과 기술 성공률과 같은 주요 지표를 강조하는 데 도움이 됩니다.\n\n<div class=\"content-ad\"></div>\n\n구조화된 레이아웃은 약속을 위한 캘린더와 자세한 생산성 그래프를 통합하여 사용자 경험을 원활하게 만들어주며, 계획 수립과 진척 평가를 모두 촉진합니다.\n\n## 위젯 및 필터 디자인, 암호화폐 앱 | Lazarev\n\n👨‍🎨 Lazarev. UX/UI\n👥 Lazarev.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*A6v4U_EmVPbWVx0Ny0mXcA.gif)\n\n<div class=\"content-ad\"></div>\n\n이 대시보드는 다양한 모듈을 통해 실시간 데이터를 전달하여 금융 지표와 사용자 정의 가능한 뉴스 피드를 정교하게 통합하여 보여줍니다.\n\n다크 테마는 데이터 제시를 보완하여 시각적 매력과 가독성을 높입니다.\n\n시장 스크리너와 뉴스 소스 필터 옵션과 같은 핵심 기능은 사용자의 특정한 요구 사항을 충족시키도록 맞추어져 있어, 동적 시장 환경에서 효율적인 정보 소비와 의사 결정을 촉진합니다.\n\n## 통계 2.0\n\n<div class=\"content-ad\"></div>\n\n👨‍🎨 DStudio®\n\n대시보드 디자인은 강렬한 색상 블록을 효과적으로 활용하여 다양한 건강 지표를 세분화하고 시각적으로 매력적이며 쉽게 탐색 가능한 인터페이스를 만들어 냈습니다.\n\n병상 점유율 및 환자 수와 같은 주요 요소들이 명확하고 간결하게 제시됩니다.\n\n동적이고 실시간 데이터 시각화의 포함은 신속한 의사 결정을 지원하며 병원 경영을 위한 대시보드의 기능성을 향상시킵니다.\n\n<div class=\"content-ad\"></div>\n\n## 웹 앱 대시보드\n\n👨‍🎨 아미르 레만\n\n이 생산성 대시보드는 부드러운 파스텔 컬러 팔레트를 활용하여 과제 관리에 적합한 안정적인 사용자 환경을 만들어냅니다.\n\n디자인은 완료된 작업, 진행 중인 프로젝트, 그리고 커뮤니케이션에 대한 잘 정의된 섹션을 제공하여 사용자 경험을 최적화합니다.\n\n<div class=\"content-ad\"></div>\n\n진행 추적 그래프 및 일정 통합과 같은 주요 기능이 강조되어 있어 사용자 생산성을 모니터링하고 향상시키는 데 매우 효율적입니다.","ogImage":{"url":"/assets/img/2024-06-22-DashboardUIDesignExamplesCreativeMarketingvol258_0.png"},"coverImage":"/assets/img/2024-06-22-DashboardUIDesignExamplesCreativeMarketingvol258_0.png","tag":["Tech"],"readingTime":5},{"title":"SaaS 구축 전에 반드시 알아야 할 필수 요구사항 10가지","description":"","date":"2024-06-22 15:51","slug":"2024-06-22-RequirementsyouneedtohavebeforebuildingSaaS","content":"\n\n<img src=\"/assets/img/2024-06-22-RequirementsyouneedtohavebeforebuildingSaaS_0.png\" />\n\n만약 SaaS 프로젝트를 시작할 때 적절한 프로세스, 시스템 및 문서를 갖추고 있다면, 성공할 가능성이 높겠죠. 그렇지 않으면 나중에 문제에 직면할 수 있습니다. 그렇다면 성공적인 SaaS 비즈니스를 운영하려면 무엇이 필요한지 살펴보겠습니다.\n\n시작하기 전에, 제가 마케팅에 관한 책을 썼습니다. 만약 깊이 있는 마케팅을 하고 SaaS에 장기 유지 고객을 확보하는 방법에 대해 알고 싶다면, \"당신의 SaaS를 성장시키는 마케팅 전략\"을 확인해보세요. 이 책은 SaaS를 처음부터 시작하여 실제 유저를 확보하는 데 필요한 단계와 전략을 자세히 다루어 도와드릴 것입니다.\n\n더 나은 이해를 위해 이 기사를 \"문서, 도구, 팀, 결제\"라는 4가지 주요 범주로 나누었습니다. 하나씩 시작해보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n# 1. 문서 및 연구\n\n적절한 문서 작성 및 문서 목록 확인이 필요합니다. 필요한 중요 문서들은 아래와 같습니다.\n\n작업 범위: SaaS를 위해 개발되어야 하는 모든 기능 요구 사항이 포함된 Excel 문서입니다. Excel 대신 Word 파일을 만들 수도 있습니다.\n\n로드맵: 로드맵은 작업 범위를 기반으로 구축됩니다. 작업 범위에는 SaaS를 위해 필요한 모든 기능이 추가되어 있습니다. 이제 로드맵에서는 MVP, MMP 및 기타 단계로 개발해야 하는 기능들을 분류할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n기술 분석: 이 문서는 SaaS를 개발하기 위해 필요한 기술 스택 및 다른 서드파티 서비스에 대한 이해를 포함할 것입니다. 또한 유료 구독이나 라이선스에 대한 요금도 포함될 것입니다.\n\n플로우 차트: 이름에서 알 수 있듯이 SaaS의 모든 기능을 사용하기 위해 계정을 생성하는 사용자 흐름을 플로우 차트로 가지고 있어야 합니다. 이는 다른 사람들이 더 잘 이해하고 전진할 수 있도록 도와줄 것입니다.\n\n약관 문서: SaaS 개발을 시작하기 전에 개발팀과 코드 및 기타 것들을 소유할 것이라고 명시적으로 하는 약관과 서비스 이용 약관을 명확히 정해야 합니다. 또한 코드에 발생하는 버그가 프로젝트 완료 후 4개월 이내에 개발팀에 의해 무료 또는 매우 적은 요금으로 수정되어야 한다는 것을 확인해야 합니다. 이와 같은 것들은 SaaS 개발을 시작하기 전 합의되어야 할 필요가 있습니다.\n\nGTM 전략: GTM 전략은 당신의 SaaS의 시장 잠재력을 알려줄 것이므로 매우 중요합니다. 잠재 구매자가 어디 있고 그 규모는 얼마나 되며, 경쟁사가 있는지 그 시장 규모는 무엇인지 알아야 합니다. 또한 브랜드 인지도를 만들기 위해 얼마나 많은 돈이 필요하며 사용자를 확보하기 위해 마케팅에 얼마나 많은 자금이 필요한지에 대한 개념을 가져야 합니다.\n\n<div class=\"content-ad\"></div>\n\nSaaS를 개발하기 전에 반드시 해야 할 중요한 문서/연구 몇 가지가 있습니다.\n\n## 2. 도구 및 API\n\nJIRA나 Trello와 같은 프로젝트 관리 도구가 필요하며, 모든 작업을 유지하고 SPRINTS의 진행 상황을 확인할 수 있습니다. 또한 GitHub, GitLab 또는 BitBucket과 같은 버전 관리 시스템에 계정이 필요합니다. 모든 코드가 보관됩니다.\n\n기술 문서에 따르면, 필요에 따라 3rd party 서비스로부터 API를 사용해야 하며, 배포에 필요한 클라우드에 계정이 있어야 합니다.\n\n<div class=\"content-ad\"></div>\n\n앞으로 나중에 사용하지 않으려는 API 또는 서비스를 제거할 수 있게 하기 위해 모두 한 곳에 목록을 작성하는 것이 좋습니다.\n\n# 3. 팀\n\n팀을 구성하는 데는 프로젝트 매니저, 개발 팀, 디자인 팀, QA 팀 및 데브옵스 팀이 필요합니다. 고용할 팀은 이들 사람들을 포함하거나 적어도 대부분을 포함해야 합니다.\n\n첫 번째 팀을 구성한다면 Upwork과 같은 에스크로 시스템을 사용하여 작업 및 결과물을 보호받을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 4. 결제\n\n결제에 대해서 다시 말씀드리자면, 팀이 새로운 경우에는 에스크로를 사용하는 것이 좋지만, Stripe, Wise, 또는 Razorpay를 이용하여 송장을 처리할 수도 있습니다.\n\n또한 이미 낸 송장 정보와 아직 납부하지 않은 내역을 파악하는 것이 중요합니다. 따라서 Notion을 사용하여 추적하거나 구글 스프레드시트도 사용할 수 있습니다.\n\n적절한 시스템, 프로세스, 문서를 올바른 위치에 마련한다면 SaaS 비즈니스를 원활하게 운영할 수 있습니다. 이 기사가 유익했기를 바라며, 궁금한 사항이 있으면 댓글로 알려주세요. 문의사항이 있으면 언제든지 연락해주세요.\n\n<div class=\"content-ad\"></div>\n\n또한, AI를 활용한 SaaS 비즈니스를 성공적으로 운영하는 데 대해 깊이 파고들고 싶다면 모든 핵심 전략과 포인트를 알고 싶다면, \"Cheat Code for Building AI-Driven SaaS\"라는 책을 썼어. 이 책은 광범위한 지침을 제공하며 AI를 활용한 SaaS를 구축하는 데 도움이 될 거야.\n\n커뮤니티의 일원이 되어 주셔서 감사해! 떠나시기 전에:\n\n- 작가를 클랩하고 팔로우해주시기 바랍니다️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문하기: CoFeed | Differ\n- PlainEnglish.io에서 더 많은 콘텐츠 확인하기","ogImage":{"url":"/assets/img/2024-06-22-RequirementsyouneedtohavebeforebuildingSaaS_0.png"},"coverImage":"/assets/img/2024-06-22-RequirementsyouneedtohavebeforebuildingSaaS_0.png","tag":["Tech"],"readingTime":3},{"title":"UDP DNS 서버 시작하기 Nodejs로 쉽게 따라하는 방법","description":"","date":"2024-06-22 15:49","slug":"2024-06-22-StartingMyUDPDNSServer","content":"\n나의 최근 생태계 업데이트에서는 완료 직전에 있는 여러 패키지를 소개했어요. 해당 업데이트에서 논의된 패키지 중 하나는 현재 Julia General에 병합 중인 새 Toolips 확장 프로그램인 ToolipsUDP입니다. ToolipsUDP는 Toolips 생태계를 만들면서 초기화한 프로젝트인데, 프로젝트에 사용 목적이 없었기 때문에 빨리 만들었어요.\n\n패키지가 현재 등록 중이니, 이제 UDP 서버가 필요한(또는 UDP 서버를 선호하는) 애플리케이션이 있다고 가정하는 것이 적절할 것 같아요. 이 가정은 맞아요. 이 경우의 나의 애플리케이션은 도메인 네임 서버 또는 DNS입니다. 도메인 네임 서버를 처음부터 직접 만들어 보지는 않았지만 이러한 종류의 서버를 실행해 본 경험이 있어요. 몇 가지 예비 연구를 진행했고, 이 프로젝트의 일부 측면은 꽤 복잡하지만 목표는 매우 간단합니다. 받은 요청 헤더를 응답 헤더로 변환하여 다시 보내는 것이죠. 이것은 이 유형의 네트워킹에서 일반적인 것입니다.\n\n오늘 이 프로젝트에 많은 작업을 하지는 않겠지만, 이러한 작업을 용이하게 하는 유형 시스템을 만들기 시작하고, 서버 및 ToolipsUDP를 만드는 것을 시작할 거에요. 오늘 만들 프로젝트 링크는 여기 있어요:\n\n# 프로젝트\n\n<div class=\"content-ad\"></div>\n\nToolips 프로젝트를 시작하려면 보통 Toolips.new_app 또는 Toolips.new_webapp 함수를 사용합니다. 이 경우, UDPServer를 사용하여 new_app을 만들어야 합니다; 이를 위해, 우리는 new_app에 UDPServer을 제공하기만 하면 됩니다. 시작해 봅시다!\n\n```js\n11:58 AM|emma|julia🩷> julia\n               _\n   _       _ _(_)_     |  문서: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  도움말을 보려면 \"?\"를 입력하세요, 패키지 도움말을 보려면 \"]\"를 입력하세요.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  버전 1.9.2 (2023-07-05)\n _/ |\\__'_|_|_|\\__'_|  |  Fedora 38 빌드\n|__/                   |\n\njulia>\n(@v1.9) pkg> add https://github.com/ChifiSource/ToolipsUDP.jl\n     Cloning git-repo `https://github.com/ChifiSource/ToolipsUDP.jl`\n    Updating git-repo `https://github.com/ChifiSource/ToolipsUDP.jl\n```\n\n```js\njulia> ToolipsUDP.new_app(\"ChiNS\", UDPServer)\n  프로젝트 ChiNS 생성 중:\n    ChiNS/Project.toml\n    ChiNS/src/ChiNS.jl\n  `~/dev/packages/julia/ChiNS`의 프로젝트 활성화 중\n    Updating git-repo `https://github.com/ChifiSource/Toolips.jl.git`\n...\n```\n\n이것은 new_app의 다른 방법이며, 따라서 Toolips에서도 이를 호출할 수 있습니다. 여기서 우리의 새로운 서버 설정을 살펴보세요. 기본 설정에 몇 가지 수정을 가했는데, 아마도 향후 버전에서도 수정될 것입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nmodule ChiNS\nusing Toolips\nusing ToolipsUDP\n\nfunction start(ip::String = \"127.0.0.1\", port::Int64 = 2000)\n    myserver = UDPServer() do c::UDPConnection\n        println(c.packet)\n        println(c.ip)\n        println(c.port)\n    end\n    myserver.start()\n    myserver\nend\n\nfunction send_to_my_server(myserver::UDPServer, data::String)\n    server2 = UDPServer(\"127.0.0.1\", 2005)\n    server2.start()\n    ToolipsUDP.send(server2, \"test\", myserver.host, myserver.port)\nend\nend # - module\n```\n\ndev.jl을 포함하면 우리 서버는 즉시 시작됩니다.\n\n```js\njulia> include(\"dev.jl\")\n  Activating project at `~/dev/packages/julia/ChiNS`\n[ Info: Precompiling ChiNS [3335ca11-6bce-43d8-b1c1-b64d7d07a7e2]\nToolipsUDP.UDPServer\nUDP server: 127.0.0.1:2000\nstatus: active (4)\n```\n\n더 흥미로운 일을 위해 다른 터미널에서 클라이언트 서버를 열 것입니다. 이렇게 하면 서버가 무엇을 말하는지 보다 쉽게 파악할 수 있습니다. 같은 터미널에서 두 서버가 병렬로 출력되는 것보다 더 편리합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\njulia> using ToolipsUDP\n\njulia> client = UDPServer(\"127.0.0.1\", 2020) do c\n           println(c.packet)\n       end\nUDPServer\nUDP 서버: 127.0.0.1:2020\n상태: 비활성 (1)\n```\n\n서버를 server.start로 시작한 다음 데이터를 보내려면 send를 사용하십시오.\n\n```js\njulia> client.start()\nTask (runnable) @0x00007f17303fb080\n\njulia> send(client, \"hello world\", \"127.0.0.1\", 2000)\n```\n\n다른 터미널에서 수신된 포트, 패킷 및 IP가 표시됩니다.\n\n<div class=\"content-ad\"></div>\n\n```js\njulia> include(\"dev.jl\")\n  Activating project at `~/dev/packages/julia/ChiNS`\n[ Info: ChiNS [3335ca11-6bce-43d8-b1c1-b64d7d07a7e2]을 컴파일 중\nToolipsUDP.UDPServer\nUDP 서버: 127.0.0.1:2000\n상태: 활성화됨 (4)\n\njulia> hello world\n127.0.0.1\n2020\n```\n\n## UDP 예제\n\n다음 예제로 들어가기 전에, 응답이 주어지는 또 다른 간단한 UDP 예제를 시도해보겠습니다. 응답은 send 및 respond를 사용하여 제공할 수 있습니다.send를 사용하면 현재 클라이언트에 직접 보낼 수 있습니다. 이는 UDPConnection, UDPServer 또는 호스트 IP 및 포트로 수동으로 수행할 수 있습니다. respond는 Connection과 응답만 받기 때문에 간단합니다.\n\n```js\nfunction start(ip::String = \"127.0.0.1\", port::Int64 = 2000)\n    myserver = UDPServer() do c::UDPConnection\n        name = c.packet\n        respond(c, \"hello $name!\")\n    end\n    myserver.start()\n    myserver\nend\n```\n\n<div class=\"content-ad\"></div>\n\n핸들러 함수가 없어서 dev.jl과 작업시에 리비전이 변경되지 않습니다. 이 부분은 수정될 예정이지만, 일단은 재시작이 필요합니다.\n\n```js\njulia> include(\"dev.jl\")\n  `~/dev/packages/julia/ChiNS`에서 프로젝트를 활성화 중\n[ Info: ChiNS [3335ca11-6bce-43d8-b1c1-b64d7d07a7e2] 사전 컴파일 중\nToolipsUDP.UDPServer\nUDP 서버: 127.0.0.1:2000\n상태: 활성 (4)\n```\n\n이제 데이터를 전송할 때마다 인사를 받을 수 있습니다.\n\n```js\njulia> ToolipsUDP.send(newserv, \"emma\", \"127.0.0.1\", 2000)\n\njulia> 안녕 emma !\n```\n\n<div class=\"content-ad\"></div>\n\n우리의 베이스 프로젝트를 완료하고 ChiNS를 준비하기 위해, 제가 지금까지 한 것을 삭제하고 새 핸들러 함수를 만들겠습니다. 이 함수는 이 프로젝트를 공식적으로 시작하는 데 사용될 것입니다.\n\n```js\nmodule ChiNS\nusing Toolips\n\nusing ToolipsUDP\n\nfunction handler(c::UDPConnection)\n\nend\n\nfunction start(ip::String = \"127.0.0.1\", port::Int64 = 2000)\n    myserver = UDPServer(handler)\n    myserver.start()\n    myserver\nend\n\nfunction send_to_my_server(myserver::UDPServer, data::String)\n    server2 = UDPServer(\"127.0.0.1\", 2005)\n    server2.start()\n    ToolipsUDP.send(server2, \"test\", myserver.host, myserver.port)\nend\n\nend # - module\n```\n\n## DNS 헤더\n\n과거에 이름 서버를 호스팅한 적이 있지만, 이번이 확실히 처음으로 서버를 만드는 것입니다. 사실, 이는 저에게 접속 없는 네트워킹에서 이 정도로 저수준으로 작업하는 것은 처음이죠 (통합 API의 일부로 고수준 UDP 네트워킹을 한 적은 있지만 그 자체로 한 적은 없습니다). 그렇기 때문에 이 주제가 제게 새롭기 때문에 DNS 패킷 구조에 대한 이 개요는 이 프로젝트를 진행하는 데 매우 유용했습니다.\n\n<div class=\"content-ad\"></div>\n\n고려할 점은, 먼저 해야 할 일은 이 문서의 두 번째 페이지에 자세히 설명된 응답 필드를 복제하기 위해 노력해야 한다는 것입니다. 이를 위해 데이터 구조를 사용할 것이므로, 그것이 많은 일을 훨씬 쉽게 만들 것으로 생각합니다. DNS 패킷 구조를 복제하면서 전체 응답 구조를 만들기 시작하겠습니다. 이 네임 서버는 서버가 컨트롤하는 도메인에만 사용되도록 의도되었기 때문에 권한(Authority)이나 추가(Additional)와 같은 필드들과 작업할 필요는 없을 것입니다. 하지만 시간이 지남에 따라 이러한 필드들이 추가될 수 있습니다. 이 유형의 서버의 좋은 점은 꽤 멋진 네임 서버를 만들어내기 위해 충분히 실현 가능한 최소 기능 제품이 있다는 것입니다. 이에 대해 고려할 때, 우리의 DNSResponse 구조는 상당히 간단합니다.\n\n```js\nmutable struct DNSResponse\n    header::DNSHeader\n    question::Any\n    answer::Any\nend\n```\n\n또한 DNSHeader 구조가 필요합니다. 질문과 답변의 타이핑이 정확히 무엇인지 확신할 수 없으므로, 현재 이 필드들은 Any로 설정되어 있습니다. 시작하는 데 주된 관심사는 물론 DNSHeader입니다. DNSHeader 유형의 구조에는 사용하지 않을 많은 필드들이 있습니다. 그러나 구현을 위해 이러한 모든 필드들을 DNSHeader에 넣고 현재 필드들을 간소화하기 위해 내부 생성자를 사용할 것입니다. 여기서 시작하는 것만 기억해주시기 바랍니다. 디자인의 많은 측면이 불확실하기 때문에 이러한 것들을 많이 변경하게 될 것이라고 확신합니다.\n\n```js\nmutable struct DNSFlags\n    QR::Bool\n    opcode::Int64\n    AA::Bool\n    TC::Bool\n    RD::Bool\n    RA::Bool\n    RCOD::Int64\nend\n\nmutable struct DNSHeader\n    ID::String\n    flags::DNSFlags\n    QDCOUNT::String\n    ANCOUNT::String\n    NSCOUNT::String\n    ARCOUNT::String\nend\n\nmutable struct DNSResponse\n    header::DNSHeader\n    question::Any\n    answer::Any\nend\n```\n\n<div class=\"content-ad\"></div>\n\n모든 필드를 간단히 살펴봅시다.\n\n- QR은 쿼리인지 응답인지를 지정합니다.\n- opcode는 사용할 쿼리 유형을 나타냅니다.\n- AA는 서버가 권위 있는지 여부입니다.\n- TC는 데이터가 잘린 여부를 나타냅니다.\n- RD는 클라이언트가 재귀를 요청했는지 여부를 나타냅니다.\n- RA는 재귀 사용 가능 여부를 클라이언트에게 알려주는 응답입니다.\n- RCOD는 우리의 응답 코드입니다.\n\n- ID는 트랜잭션 ID로, 두 서버가 올바르게 통신 중임을 인식합니다.\n- flags는 우리의 플래그입니다.\n- QDCOUNT는 질문 수를 나타내는데, 대부분은 하나일 것입니다.\n- ANCOUNT는 응답 수입니다.\n- NSCOUNT는 네임 서버 개수입니다.\n- ARCOUNT는 추가적인 리소스 레코드의 수입니다.\n\n이러한 데이터를 고려할 때, 최소 기능 제품을 얻기 위해 몇 가지 필드만 사용할 것입니다. 또한, DNSQuestion 및 DNSHeader 유형을 최종적으로 생성할 것입니다. 지금은 조금 돌아가서 응답 작업을 시작하겠습니다. 필드 섹션에서 언급했듯이, 트랜잭션 ID는 16옥텟(비트) 또는 두 바이트입니다. 8의 배수일 때 데이터를 나누지 않고 데이터를 검색할 수 있어 좋습니다. 이에 맞게 데이터의 첫 두 글자를 가져와서 이를 출력하겠습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nfunction build_response(data::String)\n    tid = data[1:2]\n    println(tid)\nend\n\nfunction handler(c::UDPConnection)\n    response = build_response(c.packet)\nend\n```\n\n이제 DNS를 실제로 테스트하기 위해 dig를 사용할 것입니다. dig 서비스는 DNS 서버를 프로파일링하고 진행 상황을 테스트하기 위해 헤더를 보낼 수 있는 간단한 DNS 클라이언트입니다. 이를 위해 dig는 두 가지 인수를 가져야 합니다 — 호스트 이름과 IP입니다. 또한 서버의 포트를 54로 설정해주어야 합니다. 이는 포트 80 아래에 있기 때문에 방화벽 구성도 필요합니다. 이름을 출력해보겠습니다. 한 터미널에서 서버 버전을 시작했습니다. 그리고 여기서 dig를 사용했습니다.\n\n```js\n02:00 PM|emma|~🩷> dig chifi.dev @127.0.0.1\n;; 통신 오류 127.0.0.1#53: 시간이 초과되었습니다\n```\n\n서버가 요청에 아직 응답하지 않았기 때문에 몇 초 후에 시간 초과가 발생했습니다. Julia REPL에서 거래 ID를 출력합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\njulia> U�\n```\n\n## 플래그\n\n우리가 만들어야 하는 헤더의 다음 부분은 플래그의 행입니다. 지난 예제는 꽤 간단했지만, 우리는 두 바이트만 가져오면 되었습니다. 이번에는 우리의 코드를 옥텟으로 나눠야 할 것입니다. 세 번째 바이트부터 다섯 번째까지 데이터가 제공되는 새로운 함수를 만들 것인데, 플래그 섹션도 두 바이트이기 때문입니다.\n\n```js\nfunction build_response(data::String)\n    tid = data[1:2]\n    println(\"Transaction ID: \", tid)\n    flags = build_flags(data[3:5])\nend\n```\n\n<div class=\"content-ad\"></div>\n\n우리 국기 작업을 시작하려면 코드를 옥텟으로 나눠 보겠습니다:\n\n```js\nfunction build_flags(data::String)\n    bits = join([bitstring(s) for s in Vector{UInt8}(data)])\nend\n```\n\n이제 필요한 각 필드의 비트를 간단히 색인하겠습니다. 또한 parse를 사용하여 타입을 구문 분석하고, DNSFlags를 구성하기 위한 준비를 하겠습니다.\n\n```js\nfunction build_flags(data::String)\n    bits = join([bitstring(s) for s in Vector{UInt8}(data)])\n    println(\"질의/응답: \", bits[1])\n    println(\"opcode: \", parse(Int64, bits[2:5]))\n    println(\"AA: \", parse(Bool, bits[6]))\n    println(\"TC: \", parse(Bool, bits[7]))\n    println(\"RD: \", parse(Bool, bits[8]))\n    println(\"RA: \", parse(Bool, bits[9]))\n    println(\"Z: \", String(bits[10:12]))\n    println(\"응답 코드: \", String(bits[13:16]))\nend\n```\n\n<div class=\"content-ad\"></div>\n\n자요! 다시 쿼리에 대답해 보는 것을 시도해 봅시다.\n\n```js\nTransaction ID: �4\n0\nQuery/response: 0\nopcode: 0\nAA: false\nTC: false\nRD: true\nRA: false\nZ: 010\nResponse code: 0000\n```\n\n잘 되었네요! 이제 모든 플래그가 완료되었고, 이 데이터를 DNSFlags 생성자에 시간에 맞춰 삽입하는 것만 남았습니다.\n\n```js\nfunction build_flags(data::String)\n    bits::String = join([bitstring(s) for s in Vector{UInt8}(data)])\n    DNSFlags(parse(Bool, bits[1]), parse(Int64, bits[2:5]), parse(Bool, bits[6]), parse(Bool, bits[7]), parse(Bool, bits[8]),\n    parse(Bool, bits[9]), String(bits[10:12]), parse(Int64, bits[13:16]))::DNSFlags\nend\n```\n\n<div class=\"content-ad\"></div>\n\n이제 build_response 함수에는 ID와 플래그를 받는 핸들러가 있습니다.\n\n```js\nfunction build_response(data::String)\n    tid = data[1:2]\n    println(\"Transaction ID: \", tid)\n    flags::DNSFlags = build_flags(data[3:5])\n\nend\n```\n\n이제 DNSHeader를 구성하기 위해 QDCOUNT, ANCOUNT, NSCOUNT 및 ARCOUNT가 필요합니다.\n\n```js\nmutable struct DNSHeader\n    ID::String\n    flags::DNSFlags\n    QDCOUNT::String\n    ANCOUNT::String\n    NSCOUNT::String\n    ARCOUNT::String\nend\n```\n\n<div class=\"content-ad\"></div>\n\n일단 헤더를 구축하는 것으로 여기에서 마무리하겠습니다. 이 프로젝트를 곧 더 개발할 계획이며, 이 프로젝트의 개발은 한동안 계속될 것으로 예상됩니다. 궁극적으로 목표는 이 프로젝트를 2월까지 완료하는 것이라, 모든 것을 고려할 때 정말 순조롭게 진행 중입니다. 물론 상황이 더 복잡해질 것으로 상상하고 있지만, 지금까지 이 프로젝트는 정말 재미있었고 실행 중이라는 점이 정말 기쁩니다.\n\nToolipsUDP 또한 작동 중입니다. ToolipsUDP 인터페이스에 대해 많은 것을 좋아합니다. 특히 응답 및 UDP 연결 기능의 간결함을 정말 좋아합니다. 그러나 이 초기 버전에서 초기 결함이 분명히 느껴졌습니다. 첫째, 기본 앱이 그리 좋지 않았습니다. UDP로 개발하기에 적합한 기반이 제공되지 않았고 UDP 프로젝트를 대상으로 한 것으로 보였습니다. ToolipsUDP를 더 많이 작업하면 변화할 것입니다. 또한 정말 거슬리는 것은 오류 처리 부분이 매우 부족하다는 것입니다. 이 기본 버전의 ToolipsUDP는 이 프로젝트를 충분히 지원할 수 있지만, 상황은 패키지 업데이트로 더 원할하게 진행될 것이고, 시간이 지날수록 반드시 업데이트를 계속할 것입니다.\n\n## 네트워크 서버의 끝\n\n<img src=\"/assets/img/2024-06-22-StartingMyUDPDNSServer_0.png\" />\n\n<div class=\"content-ad\"></div>\n\n이 글에서 마지막으로 이야기하고 싶은 것은, 도메인 네임 서버를 비롯한 내 네트워크 애플리케이션에 사용할 좋은 작은 서버를 구입했다는 것입니다. 이 서버는 25달러에 구매했어요.\n\n그래서 저는 쿼드 코어 제온을 얻었어요 - 정확한 모델은 기억하지 못하고, 이 기기를 제대로 켜본 적이 없어요 (VGA 케이블이 없어요) 하지만 클럭 속도는 대략 3.5 GHz 정도로 보입니다. 이 서버는 작은 350w 파워 서플라이가 달려 있어요 (저는 이 상황에 이상적으로 생각해요,) 그리고 8GB RAM이 달려 있고 최대 32GB까지 확장할 수 있어요. 또한 서버에 라이저가 함께 제공되었는데, 이는 약 2인치 정도로 카드를 지원할 수 있어요. 물론, 거기서의 도전은 파워 서플라이와 파워 부족이에요. 저는 파워칼러 레드 드래곤 로우 프로파일 5500XT를 검토했었는데, 이 카드는 모든 조건을 만족해요 —\n\n- AMD (리눅스)\n- 꽤 강력한 카드, 사실\n- 작음\n- 파워 연결포트 없음\n\n그러나 이렇게 되면 나 자신에게 조금 더 이상을 이유로 해야겠죠; 이 기기에 정말 그래픽 카드가 필요한가? 제 마음속에선 멋지기 때문에 원하는 거예요 - 그리고 또한, 설정을 마친 후에 다시 연결해야 할 필요가 생길 때 VGA 디스플레이 이상을 갖는 것이 유용할 것 같아요. 그러나 이렇게 되면 TDP가 늘어나고, 거의 항상 모니터를 사용하지 않을 것인데 그TDP 증가를 감당할 가치가 있는지 모르겠어요. 물론, OpenCL이 있지만, 이 서버는 네트워크 애플리케이션용으로 계획된 서버이고 \"중량 화물을 옮기는\" 서버는 아니에요.\n\n<div class=\"content-ad\"></div>\n\n내 계획에 대한 감을 줄이기 위해 말하자면, 하나의 서버가 간단한 응용 프로그램, 엔드포인트, 데이터베이스 및 DNS를 관리하게 할 계획입니다. 이 서버는 괴물이 될 필요가 없어요. DNS 및 API 요청을 빠르게 처리할 정도로 빠르지만 계산할 양이 많지 않거나 메모리에 저장할 데이터가 많지는 않을 거에요. 이 외에 두 번째 서버가 있을 예정인데, 이 서버에는 두 개의 프로세서와 최소한 200GB의 메모리가 필요합니다. 이 용도로 살펴본 모델들은 보통 총 400GB 정도의 메모리를 제공합니다.\n\n말할 필요도 없이, 이 모든 프로젝트를 배포하기 위해 앞으로 많은 작업이 남아 있습니다. 꽤 중요한 웹 생태계의 소프트웨어 및 하드웨어 부분을 상당히 빠르게 구축 중이며, 정말 기대돼요. 다음 프로젝트 업데이트에서 더 많은 정보를 공유할 때까지 기다릴 수 없어요. 좋은 하루 보내세요!\n","ogImage":{"url":"/assets/img/2024-06-22-StartingMyUDPDNSServer_0.png"},"coverImage":"/assets/img/2024-06-22-StartingMyUDPDNSServer_0.png","tag":["Tech"],"readingTime":12},{"title":"Flutter 상태 관리 BLoC와 Provider 비교 어떤 걸 선택해야 할까","description":"","date":"2024-06-22 15:47","slug":"2024-06-22-FlutterStateManagementBLoCVSProvider","content":"\n세부 비교\n\n![flutter-state-management](/assets/img/2024-06-22-FlutterStateManagementBLoCVSProvider_0.png)\n\n상태 관리는 모든 애플리케이션을 구축하는 중요한 측면이며 특히 모바일 앱에서 중요합니다. 플러터(Flutter)에서 상태 관리는 앱에서 변경될 수 있는 데이터를 관리하고 해당 데이터를 사용자 인터페이스에 반영하는 과정입니다.\n\n플러터에서 상태 관리에는 여러 패턴이 있지만, 가장 인기 있는 두 가지는 BLoC (Business Logic Component)와 Provider입니다. 이 두 패턴은 모두 플러터 앱의 상태를 관리하기 쉽게 만들어 주지만 각각 다른 방식으로 작동하며 다른 사용 사례에 적합합니다.\n\n<div class=\"content-ad\"></div>\n\nBLoC(Business Logic Component)은 애플리케이션의 비즈니스 로직을 사용자 인터페이스에서 분리하는 디자인 패턴입니다. 이는 UI와 BLoC 간에 데이터를 전달하는 데 스트림을 사용하며, 애플리케이션의 상태를 관리하기 위해 Provider 패키지와 함께 사용할 수 있습니다.\n\n반면에 Provider는 애플리케이션의 상태를 관리하기 위한 패키지입니다. InheritedWidget을 사용하여 상태를 위젯 트리 아래로 전파합니다. BLoC를 사용하는 더 단순하고 가벼운 대안이지만, 덜 강력하고 유연하지 않습니다.\n\n이 블로그 포스트에서는 이 두 상태 관리 패턴을 자세히 살펴보고, Flutter 앱에서 언제 사용해야 하는지, 어떻게 작동하는지, 또한 BLoC와 Provider를 상세히 비교하고 각 패턴의 장점과 단점을 논의할 것입니다.\n\nBLoC(Business Logic Component) 패턴은 애플리케이션의 비즈니스 로직을 사용자 인터페이스에서 분리하는 방법입니다. UI와 BLoC 간에 데이터를 전달하기 위해 스트림을 사용하여 Flutter 앱의 상태를 쉽게 관리할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nBLoC 패턴의 기본 구성 요소는 BLoC 자체입니다. 이는 비즈니스 로직을 처리하는 역할을 담당합니다. BLoC는 이벤트 스트림(예: 사용자 입력)을 가져와서 상태 스트림을 업데이트하는 데 사용합니다. 그런 다음 UI는 상태 스트림을 청취하고 그에 따라 업데이트할 수 있습니다.\n\n다음은 카운터를 증가하는 간단한 BLoC 예제입니다:\n\n```js\nclass CounterBloc {\n  final _counterController = StreamController<int>();\n  Stream<int> get counter => _counterController.stream;\n  void increment() {\n    _counterController.sink.add(_counterController.value + 1);\n  }\n  void dispose() {\n    _counterController.close();\n  }\n}\n```\n\n이 예제에서 CounterBloc 클래스에는 비공개 \\_counterController StreamController와 공개 counter 스트림이 있습니다. increment 메서드는 이벤트를 가져와 스트림의 현재 값에 1을 추가하고, dispose는 더 이상 필요하지 않을 때 스트림을 닫는 데 사용됩니다.\n\n<div class=\"content-ad\"></div>\n\nBLoC 사용의 장점은 다음과 같습니다:\n\n- 코드 구성: BLoC는 비즈니스 로직과 UI 로직을 분리하여 유지 관리, 테스트, 가독성을 높입니다.\n- 확장성: BLoC의 모듈식 접근 방식은 앱을 성장시킬 때 확장하기 쉽게 만듭니다.\n\n다음은 위의 BLoC를 플러터 위젯 트리에 구현하는 예시입니다:\n\n```js\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return BlocProvider<CounterBloc>(\n      create: (context) => CounterBloc(),\n      child: MaterialApp(\n        home: CounterPage(),\n      ),\n    );\n  }\n}\n\nclass CounterPage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    final bloc = BlocProvider.of<CounterBloc>(context);\n\n    return Scaffold(\n      body: Center(\n        child: StreamBuilder<int>(\n          stream: bloc.counter,\n          initialData: 0,\n          builder: (context, snapshot) {\n            return Text('${snapshot.data}');\n          },\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          bloc.increment();\n        },\n        child: Icon(Icons.add),\n      ),\n    );\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\nBLoC을 사용하는 한 가지 단점은 설정 및 사용이 더 복잡할 수 있고 구현하는 데 더 많은 시간과 노력이 필요할 수 있다는 것입니다. 또한 몇 가지 경우에는 단순한 경우에 스트림 컨트롤러 및 스트림 빌더의 필요가 하나의 Provider가 더 적합한 경우도 있을 수 있습니다.\n\nProvider 패턴은 Flutter 애플리케이션의 상태를 관리하기 위한 패키지입니다. InheritedWidget을 사용하여 상태를 위젯 트리 아래로 전파하여 앱 전체에서 상태에 쉽게 액세스하고 업데이트할 수 있도록 돕습니다.\n\nProvider에서 앱 상태를 보유하는 ChangeNotifier와 ChangeNotifier를 보유하는 ChangeNotifierProvider가 있습니다. ChangeNotifierProvider는 ChangeNotifier의 인스턴스를 취하고 위젯 트리 안에 있는 위젯에 노출합니다.\n\n다음은 Provider를 사용한 간단한 Counter 앱 예시입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nclass CounterModel with ChangeNotifier {\n  int _count = 0;\n\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n```\n\n이 예시에서 CounterModel 클래스는 카운터를 나타내는 int 값이 있는 ChangeNotifier이며, 카운터를 업데이트하는 increment 메서드와 UI에 변경 사항을 알리기 위해 notifyListeners()를 호출하는 기능을 가지고 있습니다.\n\n위의 CounterModel을 Flutter 위젯 트리에 구현하는 예시는 아래와 같습니다.\n\n```js\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return ChangeNotifierProvider(\n      create: (_) => CounterModel(),\n      child: MaterialApp(\n        home: CounterPage(),\n      ),\n    );\n  }\n}\n\nclass CounterPage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    final counter = Provider.of<CounterModel>(context);\n\n    return Scaffold(\n      body: Center(\n        child: Text('${counter.count}'),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          counter.increment();\n        },\n        child: Icon(Icons.add),\n      ),\n    );\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\nProvider를 사용하는 장점 중 하나는 사용하기 쉽고 간단하다는 것입니다. 특히 작고 간단한 앱에 사용하기에 매우 간편합니다.\n\n하지만, Provider는 BLoC에 비해 강력하고 유연성이 부족하며, 더 크고 복잡한 앱의 상태를 관리하기 어려울 수 있습니다. 또한 코드 구성을 위한 구체적인 구조를 제공하지 않아 애플리케이션이 성장함에 따라 더 복잡하고 이해하기 어려운 코드로 이어질 수 있습니다.\n\n이 섹션에서는 BLoC (비즈니스 로직 컴포넌트)와 Provider를 아키텍처, 코드 구성, 사용 편의성, 확장성 및 디버깅/테스트 측면에서 비교할 것입니다.\n\n- BLoC는 응용 프로그램의 비즈니스 로직을 사용자 인터페이스에서 분리하는 더 복잡하고 강력한 패턴입니다. UI와 BLoC 간에 데이터를 통신하는 데 스트림을 사용하며, Provider 패키지와 함께 사용할 수 있습니다. 반면에 Provider는 InheritedWidget을 사용하여 상태를 위젯 트리 아래로 전파하는 더 간단하고 가벼운 패턴입니다.\n\n<div class=\"content-ad\"></div>\n\n- BLoC은 비즈니스 로직과 UI 로직을 분리하여 상태를 관리하는 더 모듈화되고 조직적인 방식을 따릅니다. 이로 인해 코드가 유지보수 가능하고 테스트 가능하며 가독성이 높아집니다. Provider는 간단한 해결책이지만 애플리케이션이 커짐에 따라 더 복잡하고 이해하기 어려운 코드로 이어질 수 있습니다. Provider는 특정 구조를 제공하지 않기 때문입니다.\n\n- Provider는 일반적으로 설정하고 사용하기 쉽다고 여겨지며 특히 작고 간단한 앱에 적합합니다. 반면에 BLoC은 설정하고 사용하기에 더 복잡할 수 있으며 구현하는 데 더 많은 시간과 노력을 필요로 할 수 있습니다.\n\n- BLoC은 더 크고 복잡한 앱에 더 적합하며, 상태를 관리하는 더 조직화되고 모듈화된 방식을 허용하여 앱이 성장할수록 더 쉽게 확장할 수 있습니다. 반면에 Provider는 작거나 간단한 앱에 더 적합하며 큰 앱의 복잡성을 쉽게 처리하지 못할 수 있습니다.\n\n- BLoC 아키텍처는 버그를 감지하고 코드를 테스트하고 다른 부분에 영향을 주지 않고 변경하는 것이 쉽습니다. Provider는 BLoC만큼 디버깅과 테스트하기에 적합하지 않으며 독립성과 모듈성의 수준을 제공하지 않기 때문입니다.\n\n<div class=\"content-ad\"></div>\n\n이 문서에서는 플러터 앱용 두 가지 인기있는 상태 관리 패턴인 BLoC (Business Logic Component)과 Provider에 대해 논의했습니다. 이 두 패턴은 플러터 앱의 상태를 더 쉽게 관리할 수 있도록 설계되었지만, 접근 방식이 다르며 다른 사용 사례에 적합합니다.\n\nBLoC는 애플리케이션의 비즈니스 로직을 사용자 인터페이스와 분리하는 강력하고 유연한 패턴입니다. 이는 UI와 BLoC 간에 데이터를 통신하는 데 스트림을 사용하며, 대규모 및 복잡한 앱에 적합합니다. 반면 Provider는 더 간단하고 가벼운 패턴으로, InheritedWidget을 사용하여 상태를 위젯 트리 아래로 전파합니다. 이는 더 작거나 간단한 앱에 적합합니다.\n\n이 글의 주요 요점은 다음과 같습니다:\n\n- BLoC는 대규모 및 복잡한 앱에 적합한 강력하고 유연한 패턴입니다.\n- Provider는 더 작거나 더 간단한 앱에 적합한 더 간단하고 가벼운 패턴입니다.\n- BLoC와 Provider는 플러터 앱의 상태를 관리하는 데 유용하며, 다른 사용 사례에 적합합니다.\n- 상태 관리 패턴을 선택할 때 앱의 특정 요구 사항을 고려하는 것이 중요합니다. 이는 앱의 크기와 복잡성뿐만 아니라 그로 인해 달성하려는 목표도 포함해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n만약 당신의 앱이 작고 간단하며 비즈니스 로직과 UI 로직을 분리할 필요가 없다면, Provider가 좋은 선택일 것입니다. 만약 당신의 앱이 더 복잡하거나 비즈니스 로직과 UI 로직을 분리하고 싶다면, BLoC가 더 나은 선택일 것입니다. 그러나 결국, 당신의 앱의 구체적인 요구사항을 평가하고 사용 사례에 가장 잘 맞는 상태 관리 패턴을 선택하는 것이 항상 더 나은 방법입니다.\n\n이 블로그 게시물 작성 시 다음 소스가 사용되었습니다:\n\n- Flutter 상태 관리 문서: https://flutter.dev/docs/development/data-and-backend/state-mgmt\n- BLoC 패턴: https://www.didierboelens.com/2018/08/reactive-programming---streams---bloc/\n- Provider 패키지: https://pub.dev/packages/provider\n\nFlutter에서 상태 관리에 대해 더 자세히 알고 싶은 독자들을 위해 다음 리소스들이 유용할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n- **Provider 패키지에 대한 Flutter 문서**: [여기](https://pub.dev/packages/provider#-readme-tab)\n- **BLoC 패턴에 대한 Flutter 문서**: [여기](https://flutter.dev/docs/development/data-and-backend/state-mgmt/options#bloc--rx)\n- **Flutter에서의 고급 상태 관리**: [여기](https://www.youtube.com/watch?v=RS36gBEp8OI&t=898s)\n\n그 외 다양한 Flutter 상태 관리 옵션과 패키지가 있다는 점도 알아두면 좋아요. 필요에 따라 몇 가지 다른 옵션들을 탐색해보실 수도 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-22-FlutterStateManagementBLoCVSProvider_0.png"},"coverImage":"/assets/img/2024-06-22-FlutterStateManagementBLoCVSProvider_0.png","tag":["Tech"],"readingTime":8},{"title":"Flutter 레이아웃 치트 시트 완벽 가이드","description":"","date":"2024-06-22 15:45","slug":"2024-06-22-FlutterLayoutCheatSheet","content":"\n플러터를 위한 간단한 레이아웃 샘플이 필요하신가요?\n제가 마련한 플러터 레이아웃 코드 조각을 소개합니다. 시각적 예시를 풍부하고 간결하게 제시할 거에요.\n아직은 작업 중이라 샘플 목록은 계속 늘어날 거예요. 플러터 위젯의 활용에 더 초점을 맞출 거라 구성요소를 보여주는 것보다는 (플러터 갤러리가 그런 부분에 뛰어나거든요!)\n플러터 레이아웃에 문제가 있거나 다른 사람들과 코드 조각을 공유하고 싶다면 말씀해주세요!\n\n이 기사는 다음 언어로도 제공됩니다:\n\n- Eddy에 의해 포르투갈어\n\n애니메이션에 관한 유사한 기사가 궁금하시다면, Flutter Animations Cheat Sheet를 확인해보세요.\n\n<div class=\"content-ad\"></div>\n\n# 목차\n\n- 행 및 열\n- 내재 너비 및 내재 높이\n- 쌓기\n- 확장\n- 제약 상자\n- 정렬\n- 컨테이너\n  - 장식: BoxDecoration\n    - 이미지: DecorationImage\n    - 테두리: Border\n    - 경계 반지름: BorderRadius\n    - 모양: BoxShape\n    - 그림자: BoxShadow 목록\n    - 그라데이션: RadialGradient\n    - 배경 혼합 모드: BlendMode\n- 재료\n  - 모양: BeveledRectangleBorder\n- 슬리버\n  - SliverFillRemaining\n- SizedBox\n- 안전 영역\n\n# 행 및 열\n\n## 주축 정렬\n\n<div class=\"content-ad\"></div>\n\n```js\nRow /*또는 Column*/(\n  mainAxisAlignment: MainAxisAlignment.start,\n  children: <Widget>[\n    Icon(Icons.star, size: 50),\n    Icon(Icons.star, size: 50),\n    Icon(Icons.star, size: 50),\n  ],\n),\n```\n\n```js\nRow /*또는 Column*/(\n  mainAxisAlignment: MainAxisAlignment.center,\n  children: <Widget>[\n    Icon(Icons.star, size: 50),\n    Icon(Icons.star, size: 50),\n    Icon(Icons.star, size: 50),\n  ],\n),\n```\n\n```js\nRow /*또는 Column*/(\n  mainAxisAlignment: MainAxisAlignment.end,\n  children: <Widget>[\n    Icon(Icons.star, size: 50),\n    Icon(Icons.star, size: 50),\n    Icon(Icons.star, size: 50),\n  ],\n),\n```\n\n```js\nRow /*또는 Column*/(\n  mainAxisAlignment: MainAxisAlignment.spaceBetween,\n  children: <Widget>[\n    Icon(Icons.star, size: 50),\n    Icon(Icons.star, size: 50),\n    Icon(Icons.star, size: 50),\n  ],\n),\n```\n\n<div class=\"content-ad\"></div>\n\n표태그를 다음과 같이 Markdown 형식으로 변경하십시오.\n\n```js\nRow /*or Column*/(\n  mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n  children: <Widget>[\n    Icon(Icons.star, size: 50),\n    Icon(Icons.star, size: 50),\n    Icon(Icons.star, size: 50),\n  ],\n),\n```\n\n```js\nRow /*or Column*/(\n  mainAxisAlignment: MainAxisAlignment.spaceAround,\n  children: <Widget>[\n    Icon(Icons.star, size: 50),\n    Icon(Icons.star, size: 50),\n    Icon(Icons.star, size: 50),\n  ],\n),\n```\n\n<img src=\"/assets/img/2024-06-22-FlutterLayoutCheatSheet_0.png\" />\n\n다른 텍스트의 기준선을 정렬해야 한다면 CrossAxisAlignment.baseline을 사용해야 합니다.\n\n<div class=\"content-ad\"></div>\n\nRow(\ncrossAxisAlignment: CrossAxisAlignment.baseline,\ntextBaseline: TextBaseline.alphabetic,\nchildren: <Widget>[\nText(\n'Baseline',\nstyle: Theme.of(context).textTheme.display3,\n),\nText(\n'Baseline',\nstyle: Theme.of(context).textTheme.body1,\n),\n],\n),\n\n## CrossAxisAlignment\n\nRow /_or Column_/(\ncrossAxisAlignment: CrossAxisAlignment.start,\nchildren: <Widget>[\nIcon(Icons.star, size: 50),\nIcon(Icons.star, size: 200),\nIcon(Icons.star, size: 50),\n],\n),\n\nRow /_or Column_/(\ncrossAxisAlignment: CrossAxisAlignment.center,\nchildren: <Widget>[\nIcon(Icons.star, size: 50),\nIcon(Icons.star, size: 200),\nIcon(Icons.star, size: 50),\n],\n),\n\n<div class=\"content-ad\"></div>\n\n```js\nRow /*또는 Column*/(\n  crossAxisAlignment: CrossAxisAlignment.end,\n  children: <Widget>[\n    Icon(Icons.star, size: 50),\n    Icon(Icons.star, size: 200),\n    Icon(Icons.star, size: 50),\n  ],\n),\n```\n\n```js\nRow /*또는 Column*/(\n  crossAxisAlignment: CrossAxisAlignment.stretch,\n  children: <Widget>[\n    Icon(Icons.star, size: 50),\n    Icon(Icons.star, size: 200),\n    Icon(Icons.star, size: 50),\n  ],\n),\n```\n\n## MainAxisSize\n\n```js\nRow /*또는 Column*/(\n  mainAxisSize: MainAxisSize.max,\n  children: <Widget>[\n    Icon(Icons.star, size: 50),\n    Icon(Icons.star, size: 50),\n    Icon(Icons.star, size: 50),\n  ],\n),\n```\n\n<div class=\"content-ad\"></div>\n\nRow /_or Column_/(\nmainAxisSize: MainAxisSize.min,\nchildren: <Widget>[\nIcon(Icons.star, size: 50),\nIcon(Icons.star, size: 50),\nIcon(Icons.star, size: 50),\n],\n),\n\n# IntrinsicWidth and IntrinsicHeight\n\nWant all the widgets inside Row or Column to be as tall/wide as the tallest/widest widget? Search no more!\n\nIn case you have this kind of layout:\n\n<div class=\"content-ad\"></div>\n\n```js\n위젯 build(BuildContext context) {\n  return Scaffold(\n    appBar: AppBar(title: Text('IntrinsicWidth')),\n    body: Center(\n      child: Column(\n        children: <Widget>[\n          RaisedButton(\n            onPressed: () {},\n            child: Text('Short'),\n          ),\n          RaisedButton(\n            onPressed: () {},\n            child: Text('A bit Longer'),\n          ),\n          RaisedButton(\n            onPressed: () {},\n            child: Text('The Longest text button'),\n          ),\n        ],\n      ),\n    ),\n  );\n}\n```\n\n만약 모든 버튼을 가장 넓은 것처럼 넓게 만들고 싶다면 IntrinsicWidth를 사용하세요:\n\n<img src=\"/assets/img/2024-06-22-FlutterLayoutCheatSheet_2.png\" />\n\n<div class=\"content-ad\"></div>\n\n```js\n위젯 build(BuildContext context) {\n  return Scaffold(\n    appBar: AppBar(title: Text('IntrinsicWidth')),\n    body: Center(\n      child: IntrinsicWidth(\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.stretch,\n          children: <Widget>[\n            RaisedButton(\n              onPressed: () {},\n              child: Text('Short'),\n            ),\n            RaisedButton(\n              onPressed: () {},\n              child: Text('A bit Longer'),\n            ),\n            RaisedButton(\n              onPressed: () {},\n              child: Text('The Longest text button'),\n            ),\n          ],\n        ),\n      ),\n    ),\n  );\n}\n\n비슷한 문제가 있지만 위젯을 가장 큰 높이에 맞추고 싶다면 IntrinsicHeight와 Row 위젯의 조합을 사용하면 됩니다.\n\n# Stack\n\n위젯을 서로 겹쳐 놓을 때 사용합니다.\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n@override\nWidget build(BuildContext context) {\n  Widget main = Scaffold(\n    appBar: AppBar(title: Text('Stack')),\n  );\n\n  return Stack(\n    fit: StackFit.expand,\n    children: <Widget>[\n      main,\n      Banner(\n        message: \"Top Start\",\n        location: BannerLocation.topStart,\n      ),\n      Banner(\n        message: \"Top End\",\n        location: BannerLocation.topEnd,\n      ),\n      Banner(\n        message: \"Bottom Start\",\n        location: BannerLocation.bottomStart,\n      ),\n      Banner(\n        message: \"Bottom End\",\n        location: BannerLocation.bottomEnd,\n      ),\n    ],\n  );\n}\n```\n\n자체 위젯을 사용하려면 Positioned 위젯에 배치하셔야 합니다.\n\n<img src=\"/assets/img/2024-06-22-FlutterLayoutCheatSheet_4.png\" />\n\n<div class=\"content-ad\"></div>\n\n```js\n위젯 build(BuildContext context) {\n  return Scaffold(\n    appBar: AppBar(title: Text('Stack')),\n    body: Stack(\n      fit: StackFit.expand,\n      children: <Widget>[\n        Material(color: Colors.yellowAccent),\n        Positioned(\n          top: 0,\n          left: 0,\n          child: Icon(Icons.star, size: 50),\n        ),\n        Positioned(\n          top: 340,\n          left: 250,\n          child: Icon(Icons.call, size: 50),\n        ),\n      ],\n    ),\n  );\n}\n```\n\n만약 상하값을 추측하기 싫다면 LayoutBuilder를 사용하여 값을 가져올 수 있어요\n\n![이미지](/assets/img/2024-06-22-FlutterLayoutCheatSheet_5.png)\n\n```js\nWidget build(BuildContext context) {\n  const iconSize = 50;\n  return Scaffold(\n    appBar: AppBar(title: Text('Stack with LayoutBuilder')),\n    body: LayoutBuilder(\n      builder: (context, constraints) =>\n        Stack(\n          fit: StackFit.expand,\n          children: <Widget>[\n            Material(color: Colors.yellowAccent),\n            Positioned(\n              top: 0,\n              child: Icon(Icons.star, size: iconSize),\n            ),\n            Positioned(\n              top: constraints.maxHeight - iconSize,\n              left: constraints.maxWidth - iconSize,\n              child: Icon(Icons.call, size: iconSize),\n            ),\n          ],\n        ),\n    ),\n  );\n}\n```\n\n<div class=\"content-ad\"></div>\n\n# 확장된\n\n확장된은 Flexbox 레이아웃과 함께 작동하며 여러 항목 간의 공간을 효율적으로 분배하는 데 좋습니다.\n\n![이미지](/assets/img/2024-06-22-FlutterLayoutCheatSheet_6.png)\n\n```js\nRow(\n  children: <Widget>[\n    Expanded(\n      child: Container(\n        decoration: const BoxDecoration(color: Colors.red),\n      ),\n      flex: 3,\n    ),\n    Expanded(\n      child: Container(\n        decoration: const BoxDecoration(color: Colors.green),\n      ),\n      flex: 2,\n    ),\n    Expanded(\n      child: Container(\n        decoration: const BoxDecoration(color: Colors.blue),\n      ),\n      flex: 1,\n    ),\n  ],\n),\n```\n\n<div class=\"content-ad\"></div>\n\n# ConstrainedBox\n\n기본적으로 대부분의 위젯은 가능한 한 적은 공간을 사용합니다:\n\n![ConstrainedBox Example](/assets/img/2024-06-22-FlutterLayoutCheatSheet_7.png)\n\n```js\nCard(child: const Text('Hello World!'), color: Colors.yellow)\n```\n\n<div class=\"content-ad\"></div>\n\nConstrainedBox 위젯을 사용하면 원하는 대로 남은 공간을 활용할 수 있어요.\n\n![ConstrainedBox Example](/assets/img/2024-06-22-FlutterLayoutCheatSheet_8.png)\n\n```js\nConstrainedBox(\n  constraints: BoxConstraints.expand(),\n  child: const Card(\n    child: const Text('Hello World!'),\n    color: Colors.yellow,\n  ),\n),\n```\n\nBoxConstraints를 사용하면 위젯이 차지할 수 있는 공간의 양을 지정할 수 있어요. 높이와 너비의 최소 및 최대 값을 지정해요.\n\n<div class=\"content-ad\"></div>\n\n다음은 BoxConstraints.expand을 사용할 때의 동작입니다:\n\n![image](/assets/img/2024-06-22-FlutterLayoutCheatSheet_9.png)\n\n```js\nConstrainedBox(\n  constraints: BoxConstraints.expand(height: 300),\n  child: const Card(\n    child: const Text('Hello World!'),\n    color: Colors.yellow,\n  ),\n),\n```\n\n이것은 다음과 동일합니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nConstrainedBox(\n  constraints: BoxConstraints(\n    minWidth: double.infinity,\n    maxWidth: double.infinity,\n    minHeight: 300,\n    maxHeight: 300,\n  ),\n  child: const Card(\n    child: const Text('Hello World!'),\n    color: Colors.yellow,\n  ),\n),\n```\n\n# Align\n\n때때로 위젯을 적절한 크기로 설정하는 데 어려움을 겪을 때가 있습니다. 예를 들어, 원치 않는 스트레칭이 계속 발생하는 경우가 있습니다:\n\n<img src=\"/assets/img/2024-06-22-FlutterLayoutCheatSheet_10.png\" />\n\n<div class=\"content-ad\"></div>\n\n위와 같은 상황이 발생하는 예시는 Column에 CrossAxisAlignment.stretch를 가진 경우이며, 버튼만 늘어지지 않도록 원할 때 발생합니다:\n\n![image](/assets/img/2024-06-22-FlutterLayoutCheatSheet_11.png)\n\n```js\nWidget build(BuildContext context) {\n  return Scaffold(\n    appBar: AppBar(title: Text('Align: without Align')),\n    body: Column(\n      crossAxisAlignment: CrossAxisAlignment.stretch,\n      children: <Widget>[\n        Align(\n          child: RaisedButton(\n            onPressed: () {},\n            child: const Text('Button'),\n          ),\n        ),\n      ],\n    ),\n  );\n}\n```\n\n위젯이 설정한 제약을 수용하지 않을 때는 첫 번째로 Align으로 감싸 보세요.\n\n<div class=\"content-ad\"></div>\n\n# 컨테이너\n\n가장 많이 사용되는 위젯 중 하나입니다! 그리고 그 이유가 있어요:\n\n## 레이아웃 도구로서의 컨테이너\n\n컨테이너의 높이와 너비를 지정하지 않으면, 자식 요소의 크기에 맞추게 됩니다\n\n<div class=\"content-ad\"></div>\n\n![Flutter Layout Cheat Sheet](/assets/img/2024-06-22-FlutterLayoutCheatSheet_12.png)\n\n```js\nWidget build(BuildContext context) {\n  return Scaffold(\n    appBar: AppBar(title: Text('Container as a layout')),\n    body: Container(\n      color: Colors.yellowAccent,\n      child: Text(\"Hi\"),\n    ),\n  );\n}\n```\n\nIf you want to stretch the Container to match its parent, use `double.infinity` for the `height` and `width` properties\n\n![Flutter Layout Cheat Sheet](/assets/img/2024-06-22-FlutterLayoutCheatSheet_13.png)\n\n<div class=\"content-ad\"></div>\n\n```js\n위젯 build(BuildContext context) {\n    return Scaffold(\n        appBar: AppBar(title: Text('Container를 레이아웃으로 사용하기')),\n        body: Container(\n            height: double.infinity,\n            width: double.infinity,\n            color: Colors.yellowAccent,\n            child: Text(\"안녕하세요\"),\n        ),\n    );\n}\n```\n\n## Decoration으로 Container 스타일링\n\nContainer의 배경에 영향을 주기 위해 color 속성을 사용할 수 있습니다. 그러나 decoration 및 foregroundDecoration을 사용할 수도 있습니다. (이 두 속성을 사용하면 Container의 전체적인 모양을 완전히 바꿀 수 있지만 이후에 다른 스타일에 대해 이야기할 것입니다. 그것은 꽤 큰 주제이기 때문에!)\ndecoration은 항상 자식 위에 배치되지만, foregroundDecoration은 자식 위에 배치됩니다.\n\n<img src=\"/assets/img/2024-06-22-FlutterLayoutCheatSheet_14.png\" />\n\n<div class=\"content-ad\"></div>\n\n```js\n위젯 빌드(BuildContext context) {\n  return Scaffold(\n    appBar: AppBar(title: Text('Container.decoration')),\n    body: Container(\n      height: double.infinity,\n      width: double.infinity,\n      decoration: BoxDecoration(color: Colors.yellowAccent),\n      child: Text(\"안녕하세요\"),\n    ),\n  );\n}\n```\n\n![이미지](/assets/img/2024-06-22-FlutterLayoutCheatSheet_15.png)\n\n```js\n위젯 빌드(BuildContext context) {\n  return Scaffold(\n    appBar: AppBar(title: Text('Container.foregroundDecoration')),\n    body: Container(\n      height: double.infinity,\n      width: double.infinity,\n      decoration: BoxDecoration(color: Colors.yellowAccent),\n      foregroundDecoration: BoxDecoration(\n        color: Colors.red.withOpacity(0.5),\n      ),\n      child: Text(\"안녕하세요\"),\n    ),\n  );\n}\n```\n\n## Transform으로서의 Container\n\n<div class=\"content-ad\"></div>\n\n만약 레이아웃을 변경하기 위해 Transform 위젯을 사용하고 싶지 않다면, Container에서 직접 transform 속성을 사용할 수 있습니다.\n\n![이미지](/assets/img/2024-06-22-FlutterLayoutCheatSheet_16.png)\n\n```js\nWidget build(BuildContext context) {\n  return Scaffold(\n    appBar: AppBar(title: Text('Container.transform')),\n    body: Container(\n      height: 300,\n      width: 300,\n      transform: Matrix4.rotationZ(pi / 4),\n      decoration: BoxDecoration(color: Colors.yellowAccent),\n      child: Text(\n        \"안녕\",\n        textAlign: TextAlign.center,\n      ),\n    ),\n  );\n}\n```\n\n# BoxDecoration\n\n<div class=\"content-ad\"></div>\n\n일반적으로 장식은 컨테이너 위젯에 사용되어 컨테이너가 어떻게 보이는지를 변경합니다.\n\n### 이미지: DecorationImage\n\n배경으로 이미지를 넣습니다:\n\n![image](/assets/img/2024-06-22-FlutterLayoutCheatSheet_17.png)\n\n<div class=\"content-ad\"></div>\n\n```js\nScaffold(\n  appBar: AppBar(title: Text('image: DecorationImage')),\n  body: Center(\n    child: Container(\n      height: 200,\n      width: 200,\n      decoration: BoxDecoration(\n        color: Colors.yellow,\n        image: DecorationImage(\n          fit: BoxFit.fitWidth,\n          image: NetworkImage(\n            'https://flutter.io/images/catalog-widget-placeholder.png',\n          ),\n        ),\n      ),\n    ),\n  ),\n);\n```\n\n## border: Border\n\nContainer의 테두리가 어떻게 보일지를 지정합니다.\n\n![image](/assets/img/2024-06-22-FlutterLayoutCheatSheet_18.png)\n\n<div class=\"content-ad\"></div>\n\n```js\nScaffold(\n  appBar: AppBar(title: Text('border: Border')),\n  body: Center(\n    child: Container(\n      height: 200,\n      width: 200,\n      decoration: BoxDecoration(\n        color: Colors.yellow,\n        border: Border.all(color: Colors.black, width: 3),\n      ),\n    ),\n  ),\n);\n```\n\n## borderRadius: BorderRadius\n\n모서리를 둥글게 만듭니다.\n\ndecoration의 모양이 BoxShape.circle인 경우 borderRadius는 작동하지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nScaffold(\n  appBar: AppBar(title: Text('borderRadius: BorderRadius')),\n  body: Center(\n    child: Container(\n      height: 200,\n      width: 200,\n      decoration: BoxDecoration(\n        color: Colors.yellow,\n        border: Border.all(color: Colors.black, width: 3),\n        borderRadius: BorderRadius.all(Radius.circular(18)),\n      ),\n    ),\n  ),\n);\n```\n\n## shape: BoxShape\n\n박스의 장식은 사각형/정사각형 또는 타원/원이 될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n다른 모양을 사용하려면 BoxDecoration 대신 ShapeDecoration을 사용할 수 있습니다.\n\n![ShapeDecoration](/assets/img/2024-06-22-FlutterLayoutCheatSheet_20.png)\n\n```js\nScaffold(\n  appBar: AppBar(title: Text('shape: BoxShape')),\n  body: Center(\n    child: Container(\n      height: 200,\n      width: 200,\n      decoration: ShapeDecoration(\n        color: Colors.yellow,\n        shape: BoxShape.circle,\n      ),\n    ),\n  ),\n);\n```\n\n## boxShadow: List`BoxShadow`\n\n<div class=\"content-ad\"></div>\n\n아래는 Container에 그림자를 추가한 코드입니다.\n\n이 매개변수는 여러 가지 그림자를 지정하고 병합할 수 있으므로 목록 형태로 제공됩니다.\n\n![그림자 추가](/assets/img/2024-06-22-FlutterLayoutCheatSheet_21.png)\n\n```js\nScaffold(\n  appBar: AppBar(title: Text('boxShadow: List<BoxShadow>')),\n  body: Center(\n    child: Container(\n      height: 200,\n      width: 200,\n      decoration: BoxDecoration(\n        color: Colors.yellow,\n        boxShadow: const [\n          BoxShadow(blurRadius: 10),\n        ],\n      ),\n    ),\n  ),\n);\n```\n\n<div class=\"content-ad\"></div>\n\n## 그라데이션\n\n그라데이션에는 선형 그라데이션(LinearGradient), 원형 그라데이션(RadialGradient) 및 스윕 그라데이션(SweepGradient) 세 가지 유형이 있습니다.\n\n![Gradient](/assets/img/2024-06-22-FlutterLayoutCheatSheet_22.png)\n\n```js\nScaffold(\n  appBar: AppBar(title: Text('gradient: LinearGradient')),\n  body: Center(\n    child: Container(\n      height: 200,\n      width: 200,\n      decoration: BoxDecoration(\n        gradient: LinearGradient(\n          colors: const [\n            Colors.red,\n            Colors.blue,\n          ],\n        ),\n      ),\n    ),\n  ),\n);\n```\n\n<div class=\"content-ad\"></div>\n\n![Flutter Layout Cheat Sheet 23](/assets/img/2024-06-22-FlutterLayoutCheatSheet_23.png)\n\n```js\nScaffold(\n  appBar: AppBar(title: Text('gradient: RadialGradient')),\n  body: Center(\n    child: Container(\n      height: 200,\n      width: 200,\n      decoration: BoxDecoration(\n        gradient: RadialGradient(\n          colors: const [Colors.yellow, Colors.blue],\n          stops: const [0.4, 1.0],\n        ),\n      ),\n    ),\n  ),\n);\n```\n\n![Flutter Layout Cheat Sheet 24](/assets/img/2024-06-22-FlutterLayoutCheatSheet_24.png)\n\n```js\nScaffold(\n  appBar: AppBar(title: Text('gradient: SweepGradient')),\n  body: Center(\n    child: Container(\n      height: 200,\n      width: 200,\n      decoration: BoxDecoration(\n        gradient: SweepGradient(\n          colors: const [\n            Colors.blue,\n            Colors.green,\n            Colors.yellow,\n            Colors.red,\n            Colors.blue,\n          ],\n          stops: const [0.0, 0.25, 0.5, 0.75, 1.0],\n        ),\n      ),\n    ),\n  ),\n);\n```\n\n<div class=\"content-ad\"></div>\n\n## backgroundBlendMode\n\n`backgroundBlendMode`은 BoxDecoration의 가장 복잡한 속성입니다.\n이 속성은 BoxDecoration의 색상/그라데이션을 섞고, BoxDecoration이 위에 있는 것과 혼합하는 역할을 합니다.\n\n`backgroundBlendMode`를 사용하면 `BlendMode` 열거형에서 지정된 다양한 알고리즘을 사용할 수 있습니다.\n\n먼저, `backgroundBlendMode`를 사용하여 Container의 자식 위에 그려지는 `foregroundDecoration`을 BoxDecoration으로 설정해 봅시다. (반면 decoration은 자식 뒤에 그려집니다)\n\n<div class=\"content-ad\"></div>\n\n```js\nScaffold(\n  appBar: AppBar(title: Text('backgroundBlendMode')),\n  body: Center(\n    child: Container(\n      height: 200,\n      width: 200,\n      foregroundDecoration: BoxDecoration(\n        backgroundBlendMode: BlendMode.exclusion,\n        gradient: LinearGradient(\n          colors: const [\n            Colors.red,\n            Colors.blue,\n          ],\n        ),\n      ),\n      child: Image.network(\n        'https://flutter.io/images/catalog-widget-placeholder.png',\n      ),\n    ),\n  ),\n);\n```\n\n`backgroundBlendMode`은 해당 Container에만 영향을 미치는 것이 아닙니다.\n\n`backgroundBlendMode`은 Container에서 상위 위젯 트리에 올라가 있는 모든 색상을 변경합니다.\n아래 코드는 이미지를 그리는 부모 Container와 `backgroundBlendMode`를 사용하는 자식 Container가 있지만, 이전과 동일한 효과를 얻을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nScaffold(\n  appBar: AppBar(title: Text('backgroundBlendMode')),\n  body: Center(\n    child: Container(\n      decoration: BoxDecoration(\n        image: DecorationImage(\n          image: NetworkImage(\n            'https://flutter.io/images/catalog-widget-placeholder.png',\n          ),\n        ),\n      ),\n      child: Container(\n        height: 200,\n        width: 200,\n        foregroundDecoration: BoxDecoration(\n          backgroundBlendMode: BlendMode.exclusion,\n          gradient: LinearGradient(\n            colors: const [\n              Colors.red,\n              Colors.blue,\n            ],\n          ),\n        ),\n      ),\n    ),\n  ),\n);\n```\n\n# Material\n\nBorder with cut corners\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-22-FlutterLayoutCheatSheet_27.png\" />\n\n```js\nScaffold(\n  appBar: AppBar(title: Text('shape: BeveledRectangleBorder')),\n  body: Center(\n    child: Material(\n      shape: const BeveledRectangleBorder(\n        borderRadius: BorderRadius.all(Radius.circular(20)),\n        side: BorderSide(color: Colors.black, width: 4),\n      ),\n      color: Colors.yellow,\n      child: Container(\n        height: 200,\n        width: 200,\n      ),\n    ),\n  ),\n);\n```\n\n# Slivers\n\n# SliverFillRemaining\n\n<div class=\"content-ad\"></div>\n\n이 위젯은 콘텐츠를 중앙 정렬하고 싶을 때 공간이 충분하지 않은 경우에 교체할 수 없습니다. 대화형 예제 있어요!\n\n![FlutterLayoutCheatSheet_28](/assets/img/2024-06-22-FlutterLayoutCheatSheet_28.png)\n\n```js\nScaffold(\n  appBar: AppBar(title: Text('SliverFillRemaining')),\n  body: CustomScrollView(\n    slivers: [\n      SliverFillRemaining(\n        hasScrollBody: false,\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: const [\n            FlutterLogo(size: 200),\n            Text(\n              '로고와 함께 중앙 정렬되어야 하는 가장 긴 텍스트입니다',\n              textAlign: TextAlign.center,\n            ),\n          ],\n        ),\n      ),\n    ],\n  ),\n);\n```\n\n중앙 정렬된 콘텐츠에 공간이 충분하지 않은 경우 SliverFillRemaining이 스크롤 가능해집니다.\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-22-FlutterLayoutCheatSheet_29.png)\n\n만약 SliverFillRemaining이 없었다면 컨텐츠가 이렇게 오버플로될 것입니다:\n\n![이미지](/assets/img/2024-06-22-FlutterLayoutCheatSheet_30.png)\n\n## 남은 공간 채우기\n\n<div class=\"content-ad\"></div>\n\n내용을 가운데 정렬하는 데 유용한 SliverFillRemaining은 뷰포트의 여유 공간을 채웁니다. 이 위젯을 사용하려면 CustomScrollView에 배치되어야하며 마지막 슬리버여야합니다.\n\n![이미지](/assets/img/2024-06-22-FlutterLayoutCheatSheet_31.png)\n\n공간이 충분하지 않은 경우 위젯은 스크롤 가능해집니다.\n\n![이미지](/assets/img/2024-06-22-FlutterLayoutCheatSheet_32.png)\n\n<div class=\"content-ad\"></div>\n\n```js\nScaffold(\n  appBar: AppBar(title: Text('SliverFillRemaining')),\n  body: CustomScrollView(\n    slivers: [\n      SliverList(\n        delegate: SliverChildListDelegate(const [\n          ListTile(title: Text('First item')),\n          ListTile(title: Text('Second item')),\n          ListTile(title: Text('Third item')),\n          ListTile(title: Text('Fourth item')),\n        ]),\n      ),\n      SliverFillRemaining(\n        hasScrollBody: false,\n        child: Container(\n          color: Colors.yellowAccent,\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: const [\n              FlutterLogo(size: 200),\n              Text(\n                'This is some longest text that should be centered'\n                'together with the logo',\n                textAlign: TextAlign.center,\n              ),\n            ],\n          ),\n        ),\n      ),\n    ],\n  ),\n);\n```\n\n## SizedBox\n\n가장 간단하지만 가장 유용한 위젯 중 하나입니다\n\n### ConstrainedBox로서의 SizedBox\n\n<div class=\"content-ad\"></div>\n\nSizedBox는 ConstrainedBox와 비슷한 방식으로 작동할 수 있어요.\n\n![image](/assets/img/2024-06-22-FlutterLayoutCheatSheet_33.png)\n\n```js\nSizedBox.expand(\n  child: Card(\n    child: Text('Hello World!'),\n    color: Colors.yellowAccent,\n  ),\n),\n```\n\n## SizedBox를 패딩으로 사용하기\n\n<div class=\"content-ad\"></div>\n\n여백이나 여백을 추가해야 할 때는 Padding 또는 Container 위젯을 선택할 수 있습니다. 그러나 이러한 방식은 Sizedbox를 추가하는 것보다 더 길고 가독성이 떨어질 수 있습니다.\n\n![FlutterLayoutCheatSheet_34](/assets/img/2024-06-22-FlutterLayoutCheatSheet_34.png)\n\n```js\nColumn(\n  children: <Widget>[\n    Icon(Icons.star, size: 50),\n    const SizedBox(height: 100),\n    Icon(Icons.star, size: 50),\n    Icon(Icons.star, size: 50),\n  ],\n),\n```\n\n## SizedBox를 사용한 보이지 않는 객체\n\n<div class=\"content-ad\"></div>\n\n많은 시간에 따라 위젯을 숨기거나 표시하고 싶을 때가 많습니다.\n\n```js\nWidget build(BuildContext context) {\n  bool isVisible = ...\n  return Scaffold(\n    appBar: AppBar(\n      title: Text('isVisible = $isVisible'),\n    ),\n    body: isVisible\n      ? Icon(Icons.star, size: 150)\n      : const SizedBox(),\n  );\n}\n```\n\nSizedBox에는 const 생성자가 있으므로 const SizedBox()를 사용하는 것이 정말 저렴합니다\\*\\*.\n\n\\*\\*보다 저렴한 해결책은 Opacity 위젯을 사용하고 투명도 값을 0.0으로 변경하는 것입니다. 이 해결책의 단점은 주어진 위젯이 보이지 않을 뿐 아직 공간을 차지할 것이라는 점입니다.\n\n<div class=\"content-ad\"></div>\n\n# SafeArea\n\n다양한 플랫폼에서 안드로이드의 상태 바(Status Bar)나 아이폰 X의 노치(Notch)와 같은 특별한 영역이 있습니다.\n\n이러한 영역 아래에는 그리기를 피할 필요가 있습니다.\n\n이 문제의 해결책은 SafeArea 위젯입니다 (SafeArea를 사용한 예시).\n\n```js\nWidget build(BuildContext context) {\n  return Material(\n    color: Colors.blue,\n    child: SafeArea(\n      child: SizedBox.expand(\n        child: Card(color: Colors.yellowAccent),\n      ),\n    ),\n  );\n}\n```\n\n<div class=\"content-ad\"></div>\n\n중요한 질문이 있으시면 놓치지 않으려면 트위터에서 저에게 개인 메시지를 보내주세요!\n","ogImage":{"url":"/assets/img/2024-06-22-FlutterLayoutCheatSheet_0.png"},"coverImage":"/assets/img/2024-06-22-FlutterLayoutCheatSheet_0.png","tag":["Tech"],"readingTime":24},{"title":"Flutter 위젯 초기화 후 함수 실행하는 방법","description":"","date":"2024-06-22 15:42","slug":"2024-06-22-HowtoFlutterrunningfunctionsafterwidgetinitialization","content":"\n\n이 글에서는 WidgetsBinding.instance.addPostFrameCallback 메서드를 자세히 검토하고 싶습니다.\n\n![image](/assets/img/2024-06-22-HowtoFlutterrunningfunctionsafterwidgetinitialization_0.png)\n\n예를 들어 서버에서 가져온 데이터로 데이터 그리드를 표시하거나 UI가 렌더링된 후에 대화 상자를 표시하려고 합니다. 이를 어떻게 구현할까요?\n\n아마 이미 이해하신 것처럼 WidgetsBinding.instance.addPostFrameCallback 메서드를 사용할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n## WidgetsBinding.instance.addPostFrameCallback은 무엇인가요?\n\nWidgetsBinding.instance.addPostFrameCallback은 플러터(Flutter)에서 개발자가 현재 프레임이 그려진 후에 콜백을 실행할 수 있도록 하는 메서드입니다. 이는 이 콜백 내의 코드가 플러터 프레임워크가 빌드 및 레이아웃 단계를 완료하고 화면에 프레임이 렌더링된 후에 실행된다는 것을 의미합니다.\n\n다음은 사용 방법의 기본 예시입니다:\n\n```js\nWidgetsBinding.instance.addPostFrameCallback((_) {\n  ...\n});\n```\n\n<div class=\"content-ad\"></div>\n\nUnderscore _ 는 콜백의 매개변수로 사용되며, 이는 프레임의 지속 시간을 의미합니다.\n\n하지만 한 걸음 물러나서 \"프레임\"에 대해 이야기해 봅시다. 프레임이라는 개념은 프레임워크가 사용자 인터페이스를 렌더링하는 방식에 중요합니다.\n\n## 프레임이란?\n\nFlutter는 UI를 초당 60프레임(fps) 또는 120Hz 업데이트를 지원하는 장치에서는 초당 120프레임으로 렌더링되도록 설계되었습니다. 각 렌더링을 프레임이라고 합니다. 즉, 대략 16ms마다 UI가 업데이트되어 애니메이션 또는 UI의 다른 변경 사항이 반영됩니다. 16ms보다 오랜 시간이 걸리는 프레임은 디스플레이 장치에서 간섭(부드럽지 않은 모션)을 일으킵니다.\n\n<div class=\"content-ad\"></div>\n\n성능 문제가 발생할 수 있습니다. 프레임을 구축, 레이아웃, 페인트하거나 합성하는 데 필요한 작업 시간이 이 시간 예산을 초과하면 프레임이 삭제되고 눈에 띄는 지연이 발생할 수 있습니다.\n\n새 프레임을 레이아웃하고 페인트할 때 엔진은 자동으로 handleDrawFrame을 호출하며, 이는 drawFrame을 호출하고(빌드 및 렌더 파이프라인을 활성화하여 프레임을 생성)합니다.\n\n각 프레임은 다음 단계로 구성됩니다:\n\n- 빌드 단계:\n\n<div class=\"content-ad\"></div>\n\n- 빌드 단계에서는 Flutter가 위젯 트리를 구성합니다. 트리의 각 위젯은 현재 상태를 기반으로 새 위젯 인스턴스를 생성하기 위해 빌드 메서드를 호출합니다.\n이 단계는 위젯 트리의 다른 부분에 대해 여러 번 발생할 수 있지만, 최종적으로 하나의 프레임으로 렌더링됩니다.\n\n2. 레이아웃 단계:\n\n- 레이아웃 단계에서는 Flutter가 각 위젯의 크기와 위치를 계산합니다. 이 단계는 각 위젯이 화면에 어떻게 배치되어야 하는지 결정하는 데 중요합니다.\n위젯은 제약 조건을 트리로 내려보내고, 각 위젯은 이러한 제약 조건을 기반으로 자체 크기를 조정합니다.\n\n3. 페인트 단계:\n\n<div class=\"content-ad\"></div>\n\n- 페인트 단계에서 Flutter는 각 위젯을 캔버스로 렌더링합니다. 이 단계는 텍스트, 이미지 및 모양을 포함한 위젯의 시각적 표현을 그리는 과정입니다.\n페인팅 프로세스는 매우 최적화되어 있어 Flutter가 복잡한 UI를 효율적으로 렌더링할 수 있습니다.\n\n4. 합성 단계:\n\n- 합성 단계는 그려진 레이어를 최종 이미지로 결합하여 화면에 표시합니다.\n이 단계를 통해 Flutter는 클리핑, 변형 및 투명도와 같은 시각적 효과를 별도의 레이어를 병합하여 효율적으로 처리할 수 있습니다.\n\n## WidgetsBinding.instance.addPostFrameCallback 및 프레임\n\n<div class=\"content-ad\"></div>\n\nWidgetsBinding.instance.addPostFrameCallback은 현재 프레임이 렌더링된 후에 실행될 콜백을 예약하는 메서드입니다.\n\n프레임 렌더링 프로세스에 대해 이해하는 것이 매우 중요합니다:\n\n- 프레임 이후: addPostFrameCallback로 등록된 콜백은 현재 프레임의 빌드, 레이아웃, 페인트 및 합성 단계가 모두 완료된 후에 실행됩니다. 이는 콜백이 실행되기 전에 UI가 완전히 업데이트되었음을 보장합니다.\n- 일회성 실행: 이 콜백은 한 번만 실행되며 프레임이 렌더링된 직후 즉시 실행됩니다. 반복 작업을 위해서는 콜백을 다시 등록해야 합니다.\n\n## addPostFrameCallback 메서드의 사용 사례.\n\n<div class=\"content-ad\"></div>\n\n- 일회성 초기화 논리: 위젯 트리가 빌드된 후 한 번 실행해야 하는 코드에 주로 사용됩니다.\n\n```js\n@override\nvoid initState() {\n  super.initState();\n  WidgetsBinding.instance.addPostFrameCallback((_) {\n    // 여기서 후프레임 초기화를 수행합니다.\n    _showDialog();\n  });\n}\n```\n\n2. 레이아웃 계산: 위젯의 크기와 위치에 의존하는 작업(예: 사용자 정의 애니메이션 또는 위치 지정)을 수행해야 하는 경우, addPostFrameCallback을 사용하면 레이아웃이 완료된 후 이러한 계산이 이루어집니다.\n\n```js\n@override\nWidget build(BuildContext context) {\n  WidgetsBinding.instance.addPostFrameCallback((_) {\n    final RenderBox box = context.findRenderObject() as RenderBox;\n    final position = box.localToGlobal(Offset.zero);\n  });\n  return Container(); // 여기에 위젯을 추가하세요\n}\n```\n\n<div class=\"content-ad\"></div>\n\n3. 상태 관리: 상태가 있는 위젯에서는 처음 렌더링 이후에만 특정 작업이나 상태 변경을 트리거하고 렌더링이나 상태 불일치 문제를 방지하는 것이 좋습니다.\n\n```js\n@override\nvoid initState() {\n  super.initState();\n  WidgetsBinding.instance.addPostFrameCallback((_) {\n    setState(() {\n      _initializeState();\n    });\n  });\n}\n```\n\n언급할만한 사항...\n\n➡️ addPostFrameCallback 내의 코드가 효율적이고 UI 반응성을 유지하기 위해 무겁지 않도록 확인하세요.\n\n<div class=\"content-ad\"></div>\n\n➡️ 다른 개발자들에게 명확히 목적을 전달하기 위해 코드에서 addPostFrameCallback의 사용을 문서화하세요. 일반적인 build-render 흐름을 변경하기 때문에 특히 중요합니다.\n\n➡️ addPostFrameCallback를 과용하거나 오용하는 것은 성능 문제를 야기할 수 있습니다. 특히 복잡한 로직이 콜백에서 실행될 때 그렇습니다.\n\n➡️ 콜백은 한 번만 실행됩니다. 반복 작업을 위해서는 개발자들이 콜백을 다시 등록해야 합니다.\n\n➡️ 콜백 내에서 상태 변경을 관리하는 것은 때로 코드가 더 어려워지고 조심스럽게 다루지 않으면 잠재적인 버그를 유발할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n잘 하셨습니다! 이 글을 읽어주셔서 감사합니다. 도움이 되셨기를 바랍니다.\n\n제 다른 글을 더 살펴보시고 앞으로의 업데이트 소식을 받아보기 위해 팔로우하시거나 👏 몇 개 주시면 감사하겠습니다!","ogImage":{"url":"/assets/img/2024-06-22-HowtoFlutterrunningfunctionsafterwidgetinitialization_0.png"},"coverImage":"/assets/img/2024-06-22-HowtoFlutterrunningfunctionsafterwidgetinitialization_0.png","tag":["Tech"],"readingTime":5},{"title":"iOS와 Android에서 QR 코드를 스캔하는 방법 Flutter 사용하기","description":"","date":"2024-06-22 15:41","slug":"2024-06-22-ScanningQRCodeinFlutteroniOSandAndroid","content":"\n## 플러터 앱에서 QR 코드 스캔 기능을 구현하는 방법을 배워보세요\n\n![QR 코드 스캔](/assets/img/2024-06-22-ScanningQRCodeinFlutteroniOSandAndroid_0.png)\n\n플러터는 구글의 오픈 소스 UI 툴킷으로, 시각적으로 매력적이고 고성능의 크로스 플랫폼 애플리케이션을 만들 수 있는 능력으로 개발자들 사이에서 엄청난 인기를 얻었습니다. 이 글에서는 플러터에서 QR 코드 스캐너를 구현하는 과정을 자세히 살펴보겠습니다. 이를 통해 앱 사용자들이 자신의 디바이스 카메라를 사용하여 QR 코드를 쉽게 스캔할 수 있게 됩니다.\n\n이 튜토리얼을 완료하면 애플리케이션에 QR 코드 스캔 기능을 통합하는 방법에 대해 확실한 이해를 가지게 될 것입니다.\n\n<div class=\"content-ad\"></div>\n\n시작해 봅시다.\n\n## 1. 프로젝트 설정\n\n먼저 아래 명령어를 사용하여 시작하는 Flutter 프로젝트를 생성해야 합니다. qr_code_scanner를 앱 이름으로 바꿔주세요.\n\n```js\nflutter create qr_code_scanner\n```\n\n<div class=\"content-ad\"></div>\n\n위 내용은 친절하고 쉬운 어조로 한국어로 번역하면 다음과 같습니다.\n\n당신을 위해 기본 카운터 앱을 만들어 드릴 거에요. 프로젝트 폴더 내에서 다음 명령어를 실행하여 mobile_scanner 플러그인을 프로젝트에 추가해 보세요.\n\n```js\nflutter pub add mobile_scanner\n```\n\n이제 작동하도록 이를 위해 일부 플랫폼 설정을 해야 합니다.\n\n## - Android\n\n<div class=\"content-ad\"></div>\n\n안녕하세요! 안드로이드 `app` 폴더의 build.gradle 파일로 이동해서 minSdkVersion을 21로 업데이트해주세요.\n\n```js\ndefaultConfig {\n    applicationId \"com.example.qr_code_scanner\"\n    minSdkVersion 21\n    targetSdkVersion flutter.targetSdkVersion\n    versionCode flutterVersionCode.toInteger()\n    versionName flutterVersionName\n}\n```\n\n## - iOS\n\nios`Runner` 폴더의 info.plist 파일로 이동해서 아래 두 가지 키를 추가해주세요.\n\n<div class=\"content-ad\"></div>\n\n```yaml\n<key>NSCameraUsageDescription</key>\n<string>QR 코드 스캐너는 QR 코드를 스캔하기 위해 카메라 액세스가 필요합니다</string>\n\n<key>NSPhotoLibraryUsageDescription</key>\n<string>QR 코드 스캐너는 사진 액세스가 필요합니다. 사진 라이브러리에서 QR 코드를 가져오기 위함입니다</string>\n```\n\n## 2. 코딩 시작하기\n\n이제 QR 코드 스캐너를 만들 준비가 되었습니다. 아래 코드를 추가해주세요\n\nmobile_scanner를 main.dart 파일에 import 해주세요\n\n<div class=\"content-ad\"></div>\n\n```js\nimport \"package:mobile_scanner/mobile_scanner.dart\";\n```\n\n```js\n// 스캐너 추가하기\nMobileScanner(\n  onDetect: (capture) {\n    final List<Barcode> barcodes = capture.barcodes;\n    for (final barcode in barcodes) {\n      print(data);\n    }\n  },\n)\n```\n\n전체 코드:\n\n```js\nimport 'package:flutter/material.dart';\nimport 'package:mobile_scanner/mobile_scanner.dart';\n\nvoid main() {\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'QR 코드 스캐너',\n      theme: ThemeData(\n        colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple),\n        useMaterial3: true,\n      ),\n      home: const MyHomePage(title: 'QR 코드 스캐너'),\n    );\n  }\n}\n\nclass MyHomePage extends StatefulWidget {\n  const MyHomePage({super.key});\n\n  @override\n  State<MyHomePage> createState() => _MyHomePageState();\n}\n\nclass _MyHomePageState extends State<MyHomePage> {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('QR 코드 스캐너')),\n      body: SizedBox(\n        height: 400,\n        child: MobileScanner(onDetect: (capture) {\n          final List<Barcode> barcodes = capture.barcodes;\n          for (final barcode in barcodes) {\n            print(barcode.rawValue ?? \"QR 코드에 데이터를 찾을 수 없음\");\n          }\n        }),\n      ),\n    );\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n그럼 이제 앱에 QR 코드 스캔 기능을 추가했군요.\n\n자세한 내용을 원하시면, 이 프로젝트에 대한 내 Github 저장소를 확인해보세요.\n\n이 글을 통해 얻은 지식으로 플러터 앱에 QR 코드 스캐너를 구현하는 데 잘 대비되셨습니다. 그래서 이제 프로젝트에 이 기능을 통합해보세요. 즐거운 코딩되세요!\n\n이 글을 읽어주셔서 감사합니다 ❤\n뭔가 잘못된 점이 있나요? 댓글로 알려주세요. 개선해 드릴게요.\n\n<div class=\"content-ad\"></div>\n\n만약 이 기사가 도움이 되었다면 👏 박수를 치세요!\n","ogImage":{"url":"/assets/img/2024-06-22-ScanningQRCodeinFlutteroniOSandAndroid_0.png"},"coverImage":"/assets/img/2024-06-22-ScanningQRCodeinFlutteroniOSandAndroid_0.png","tag":["Tech"],"readingTime":4}],"page":"5","totalPageCount":29,"totalPageGroupCount":2,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}