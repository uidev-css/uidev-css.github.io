{"pageProps":{"posts":[{"title":"뉴욕 타임스가 Wordle을 바꿨다 내가 증명하는 방법","description":"","date":"2024-06-30 18:49","slug":"2024-06-30-NewYorkTimesHasChangedWordleICanProveIt","content":"\n\n\n![2024-06-30-NewYorkTimesHasChangedWordleICanProveIt_0](/assets/img/2024-06-30-NewYorkTimesHasChangedWordleICanProveIt_0.png)\n\n안녕하세요! 저는 주로 웹 앱 개발을 하는 주간 소프트웨어 개발자입니다. Netflix와 같은 대기업부터 PBS NewsHour와 같은 비영리 단체, 그리고 스타트업까지 다양한 회사에서 일해봤어요. 웹에서 \"이걸 어떻게 만들었을까?\" 라는 질문에 대한 해답을 찾는 건 제가 즐기는 일 중 하나에요.\n\nWordle가 인기를 얻기 시작했을 때, 저도 열광적으로 참여했어요. 800일 이상 연속으로 게임을 즐겼죠 (참고로, 그 기간 동안 두 명의 아이가 태어났는데, 네, 출산실에서도 게임을 했어요). 그래서 먼저 한 일 중 하나는 원래 게임을 만든 저자가 어떻게 만들었는지 알아내는 것이었어요.\n\n뉴욕 타임스가 인수하기 전까지, 전체적으로 그냥 간단한 웹 앱이었죠. 제작자는 명확히 앱 스토어에 출시하지 않겠다고 밝히며 웹 기반 게임을 홍보하고 싶다고 말했어요. 점점 인기를 얻는 프로그레시브 웹 앱 (PWA)이 이렇게 많은 주목을 받는 것을 보는 걸 정말 좋아했어요.\n\n\n<div class=\"content-ad\"></div>\n\n온라인에서 모든 것이 가능했기 때문에 소스 코드를 쉽게 확인하고 \"저걸 어떻게 한 거지?\"라는 질문에 답할 수 있었어요!\n\n추신으로, 그 당시에는 코드가 미니파이드되지 않았기 때문에 JavaScript 개발자에게는 게임이 어떻게 구축되었는지 정확히 볼 수 있어서 특히 쉬웠어요. 게임이 개인 정보를 수집하지 않았던 당시에는 문제가 되지 않았죠.\n\n웹 기반 게임의 두 번째 장점은 크롬 익스텐션을 작성할 수 있다는 것이었어요. 놓친 경우 이전 날짜로 돌아가서 플레이할 수 있으면 멋질 것 같아서 그렇게 생각했죠. 제가 만든 익스텐션은 정확히 그것을 가능하게 했어요. 좌측 상단에 작은 입력란을 추가해놓았어요. 거기에 날짜를 입력하면, 과거로 돌아가서 그 단어를 플레이할 수 있어요!\n\n![이미지](/assets/img/2024-06-30-NewYorkTimesHasChangedWordleICanProveIt_1.png)\n\n<div class=\"content-ad\"></div>\n\n그 앱은 빠르게 유명해졌어요. 처음 몇 날 동안 100회 이상 설치되었죠. 더구나 몇 분들로부터 즐기셨다는 친근한 이메일도 받았어요.\n\n그 후... 모든 것이 변했어요.\n\n# 뉴욕 타임즈에 대해 이야기하기 전에\n\n무엇이 변했는지 설명하기 전에, 당시에 어떻게 단어가 선택되었는지 소개할게요.\n\n<div class=\"content-ad\"></div>\n\n클라이언트에서 모든 코드가 실행되었습니다(즉, 당신의 브라우저에서). 사이트를 열 때마다 두 개의 거대한 단어 배열이 로드되었습니다. 첫 번째(14,000단어 이상)는 \"허용 가능한 답변\"이었고, 즉 당신이 추측으로 입력할 수 있는 단어들이었습니다. 이것이 당신이 터무니없는 말을 입력하는 것을 막는 역할을 합니다.\n\n두 번째는 정렬된 답변 목록이었습니다. 원래 총 2,309개의 단어가 있었으며, 이는 약 6년 가량의 퍼즐을 의미합니다.\n\n페이지를 열 때, 스크립트는 현재 날짜를 가져와 게임 출시 이후 몇 일이 지났는지를 측정했습니다. 예를 들어, 게임이 출시된 지 정확히 1년이 된 날에는, 더 짧은 단어 목록에서 365번째 단어를 찾아 그것이 그 날의 정답이 되었습니다!\n\n내 Chrome 확장 프로그램을 통해 \"일 수\" 변수를 변경할 수 있게 했어요. 정말 간단하지요!\n\n<div class=\"content-ad\"></div>\n\n# 새 주인의 등장\n\n2022년 1월, 뉴욕 타임스가 언급되지 않은 금액으로 <Wordle>의 권리를 구매했습니다 (누군가가 \"700만 달러 미만\"이라고 말했습니다). 게임은 뉴욕 타임스로 이주하게 되었고, 핵심 게임 메커니즘은 변경되지 않을 것이라고 약속되었지만, 우리는 무언가가 변할 것이라는 것을 알고 있었습니다.\n\n가장 먼저 발생한 일은 내 Chrome 확장 프로그램이 종료되었습니다. NYT는 \"부가 기능\" 게임을 만드는 것을 좋아하지 않았습니다. 게다가 코드가 결국 크게 변경되어 내 확장 프로그램이 쓸모 없어졌습니다. 하나의 웹사이트에서만 작동하도록 설계된 확장 프로그램은 거의 쉬울 대응책이 없이 중단될 수 있습니다.\n\n뉴욕 타임스 버전의 소스 코드를 찾아보려고 노력했지만 해독하기가 어려웠습니다. 먼저 코드가 압축되어 있어서 \"words\"와 같은 일반 변수 이름이 \"w\"와 같은 것으로 단축되어 검색이 불가능했습니다.\n\n<div class=\"content-ad\"></div>\n\n그러나 퍼즐에서 사용된 실제 단어와 같은 요소들은 압축해서는 안 됩니다. 예를 들어 \"브라보\"와 같은 것을 검색할 수 있어야 합니다 (몇 일 전의 해답).\n\n안타깝게도, 이제 게임은 완전히 클라이언트에서 운영되지 않습니다. iOS와 Android용 네이티브 버전이 출시된 이후, NYT는 모든 것을 클라이언트 앱에서 돌릴 수 없게 되었습니다. 변경 사항이 필요한 경우 3개의 다른 코드베이스를 업데이트해야 합니다.\n\n(저는 비슷한 앱들과의 경험을 바탕으로 한 추측입니다. 개발자들과 직접 대화한 적은 없습니다)\n\n대신, 앱은 서버로 요청을 보내 그 날짜의 해답이 담긴 JSON 파일을 받습니다.\n\n<div class=\"content-ad\"></div>\n\n요기에서 확인할 수 있어요:\n[링크](https://www.nytimes.com/svc/wordle/v2/2024-06-03.json)\n\n이것이 고객이 2024년 6월 3일에 가져온 객체에요 (네, 만약 속이기를 원하신다면 미래 날짜를 입력할 수 있어요).\n\n그래서, 우리는 단어를 가져오기 위한 새로운 방법이 생겼지만, 게임은 여전히 기본적으로 같아요. 광고, 로그인 및 기타 NYT 관련 쓰레기만 제외하면요...\n\n하지만, 선택된 단어들이 바뀌었다는 사실이 밝혀졌어요.\n\n<div class=\"content-ad\"></div>\n\n# Brave New Wordle\n\n마스터 리스트가 더 이상 없어서 최신 코드를 가져와서 내 보관 코드와 비교할 수 없었습니다. 그러나 그동안의 퍼즐 목록을 살펴보고 내가 가지고 있던 원래 정답 목록과 비교할 수는 있었습니다.\n\n새로 발견한 단어들은 다음과 같습니다:\n1. PIOUS\n2. LASER\n3. KAZOO\n4. BALSA\n5. SNAFU\n6. GUANO\n\n그럼... 왜 이런 단어들일까요?\n\n<div class=\"content-ad\"></div>\n\n\n먼저 알아야 할 사실은 Wordle의 창시자가 영국인이라는 것입니다. “Snafu”는 미국 약어로, 상황 정상: 전부 엉망이라는 뜻입니다. 아마 뉴욕 타임즈는 그냥 게임을 미국식으로 변형하고 싶었을지도 모르겠네요?\n\n그런데 “Balsa”와 “Guano”는 어떻게 해야 할까요? 여기에 더하자면, 이 게임은 어느 한 사람이 자신의 부인을 위해 만든 것입니다. 아마 그저 배제할 단어에 대해 설며으로 결정한 것 같습니다. 이상하게도, 그 두 단어는 “수용 가능한 답변” 목록에 나타납니다. 다만, 유효한 \"답변\"으로 선택되지 않았을 뿐입니다.\n\n혹은 이러한 단어들이 추가된 이유가 다른 무슨 이유가 있을 수도 있습니다 (그리고 앞으로 만나게 될 다른 단어). 결국에는, 원래 2,309개의 단어 중 거의 절반에 다다랐습니다. NYT가 이 게임을 계속 유지하고 싶다면, 어떤 것을 생각해내야 할 것입니다. 아마도 6글자로???\n\n#또 다른 Chrome Extension을 만들까요?\n\n<div class=\"content-ad\"></div>\n\n아마도 그것은 안 될 것 같아요. 하루 솔루션 요청을 빼앗아 다른 날짜를 제시하는 것을 작성할 수는 있지만, 클라이언트 측 코드에서 신뢰성 있게 할당할 수 없습니다. 왜냐하면 최소화된 코드는 매 릴리스마다 변경될 수 있기 때문이죠.","ogImage":{"url":"/assets/img/2024-06-30-NewYorkTimesHasChangedWordleICanProveIt_0.png"},"coverImage":"/assets/img/2024-06-30-NewYorkTimesHasChangedWordleICanProveIt_0.png","tag":["Tech"],"readingTime":4},{"title":"Svelte 다른 프레임워크와 차별화된 매력적인 경험은","description":"","date":"2024-06-30 18:48","slug":"2024-06-30-SvelteDifferentandEngagingExperienceUnlikeOthers","content":"\n\n![이미지](/assets/img/2024-06-30-SvelteDifferentandEngagingExperienceUnlikeOthers_0.png)\n\n# 소개\n\n기술의 세계는 항상 혁신으로 넘쳐나지만, 웹 개발 분야에서 다양한 접근 방식과 해결책을 찾는 탐색은 결코 멈추지 않습니다. 이 여정에서 각 새로운 단계는 새로운 지평과 실용적인 해결책을 가져옵니다. 이 중 하나인 놀라운 발견은 바로 Svelte와의 만남입니다!\n\n본문에서는 Svelte를 소개하고 제 개인적인 경험을 살펴볼 예정입니다.\n\n<div class=\"content-ad\"></div>\n\n# 스벨트란 무엇인가요?\n\n스벨트는 무료이자 오픈 소스인 프런트엔드 컴포넌트 프레임워크이자 언어입니다.\n\n- HTML을 확장하여 자바스크립트 식을 마크업에 추가하고, 동작을 제어하고 입력에 반응하는 지시문, 조건, 반복 및 비동기 값을 사용하는 문법을 추가합니다.\n- CSS를 확장하여 스타일이 서로 겹쳐지지 않도록 스코핑 메커니즘을 추가합니다.\n- 자바스크립트를 확장하여 반응성을 언어의 기본 요소로 만듭니다.\n\n스벨트는 JavaScript의 구문을 수정하지 않으면서도 그것을 해킹합니다. 더욱이, TypeScript와 같은 기존 도구와의 상호 작용에 방해가 되지 않습니다. 예를 들어, 보통 변수를 할당할 때, 실제로는 상태를 정의하고 있는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n# 어떤 상황에서 사용할 수 있을까요?\n\n언제나 이 답변에 의지할 수 있다고 말해도 과언이 아닙니다. 이는 Svelte가 임베디드 기기에서도 성능 저하 없이 서비스를 제공할 수 있다는 점 때문입니다. 예를 들어, 브라질에서 사용되는 약 20만 대의 POS 장치가 Svelte 프레젠테이션에서 강조되며 언급될 정도입니다.\n\n요약하자면, 리소스를 적게 사용하면서 고효율 애플리케이션을 만들고자 한다면, Svelte이 최상의 선택이 됩니다.\n\n# 어디에 사용해야 할까요?\n\n<div class=\"content-ad\"></div>\n\n## 코드를 덜 작성하기\n\n더 적은 코드 라인을 작성하면 시간을 절약하고 버그를 줄이며 가독성을 높일 수 있습니다.\n\nSvelte는 컴파일러 지향적 접근 방식 덕분에 대부분의 프레임워크에 있는 불필요한 코드를 필요로하지 않습니다. Svelte는 가독성에 희생함 없이 짧은 코드를 목표로 합니다.\n\n![Svelte Image](/assets/img/2024-06-30-SvelteDifferentandEngagingExperienceUnlikeOthers_1.png)\n\n<div class=\"content-ad\"></div>\n\n더 많은 예시와 다른 프레임워크를 비교하고 싶다면, 이 사이트를 추천해 드릴게요: [https://component-party.dev/](https://component-party.dev/)\n\n## 가상 DOM이 없음\n\n가상 DOM은 여러 JavaScript 프레임워크에서 사용되는 기술로, 실제 DOM을 흉내내는 메모리 구조를 만들고 이 구조를 변경합니다. 렌더링 프로세스 중에는 실제 DOM과 가상 DOM 간의 차이를 계산하고 실제 DOM을 업데이트합니다. 이 방법은 웹 애플리케이션의 성능을 향상시키는 데 목적을 두고 있습니다.\n\nReact와 같은 프레임워크에 가상 DOM이 유용한 이유는 상태가 업데이트될 때마다 전체 컴포넌트를 다시 렌더링하고 실제 DOM에 직접 반영하는 것은 좋지 않기 때문입니다.\n\n<div class=\"content-ad\"></div>\n\n그러나 Svelte에서는 상태를 업데이트할 때 해당 상태에 의존하는 부분만 DOM에서 업데이트되기 때문에 이러한 상황이 적용되지 않습니다. 이 방법으로 가상 DOM이 필요하지 않고 더 효율적인 애플리케이션이 달성됩니다.\n\n## 학습 곡선이 꽤 낮습니다\n\n이미 HTML, CSS 및 JavaScript를 알고 있다면 Svelte는 꽤 직관적일 것입니다.\n\n```js\n<script>\n  let name = \"World\";\n</script>\n<h1>Hello {name}!</h1>\n<style>\nh1 {\n  color: red;\n}\n</style>\n```\n\n<div class=\"content-ad\"></div>\n\n위에 작성된 코드는 처음에는 HTML과 비슷해 보일 수 있지만, 실제로는 Svelte 코드입니다.\n\n# 왜 그리고 어디에서 사용했나요?\n\n트렌디올 광고팀은 풀스택 팀으로, 프론트엔드 프로젝트에는 React를 사용합니다. 그러나 React를 사용하여 높은 성능의 애플리케이션을 구축하는 것은 깊은 이해가 없는 경우 어려울 수 있습니다. 우리 팀은 풀스택이기 때문에 일부는 프론트엔드 개발을 선호하고, 다른 사람들은 백엔드 작업을 선호할 수 있습니다. 그럼에도 불구하고, 우리 모두가 모든 프로젝트에 기여합니다. 프론트엔드 개발에 익숙하지 않은 개발자들은 React의 가파른 학습 곡선으로 인해 매우 효율적인 코드를 작성하기 어려울 수 있습니다. 그래서 저희는 Svelte를 하나의 프로젝트에 사용해보기로 결정했습니다. Svelte는 학습 곡선이 낮고 더 빠른 애플리케이션을 만들 수 있는 잠재력을 갖고 있기 때문입니다.\n\n저희가 Svelte에서 마주한 몇 가지 문제에 대해 이야기하고 싶습니다. Svelte에는 오류 경계(error boundary)가 없어서 어떤 컴포넌트에서든 처리되지 않은 오류가 전체 페이지를 다운시킬 수 있습니다. 관련 이슈는 여기에서 확인할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nUnit Tests를 작성하는 것은 React에서처럼 쉽지 않습니다. 때로는 일부 구성 요소에 대해 테스트 목적으로 새로운 컴포넌트를 만들어야 할 수도 있고, 이는 실제로 Svelte를 인라인으로 작성할 수 없기 때문입니다. 이 문제를 해결하는 몇 가지 플러그인을 본 적이 있지만, 제대로 작동하지 않았습니다. 다행히 Svelte Society의 레시피 덕분에 여기서 큰 문제가 발생하지는 않았습니다.\n\n우리는 현재 브랜드 센터의 'Reklam Yönetimi' (광고 관리) 탭에서 Svelte를 사용하고 있습니다. 어떤 문제 없이 원활하게 작동합니다. Svelte에 기회를 주신 기술 리더 및 Trendyol의 문화에 감사드립니다. 그들의 도움으로 산업에서 Svelte를 한 단계 더 나아갔다고 생각합니다.\n\n<img src=\"/assets/img/2024-06-30-SvelteDifferentandEngagingExperienceUnlikeOthers_2.png\" />\n\n# 팀 피드백\n\n<div class=\"content-ad\"></div>\n\n우리는 Svelte에 관한 우리 팀원들의 경험과 피드백을 모았어요. 이 피드백은 긍정적 측면과 부정적 측면 두 가지 주요 항목 아래에서 수집했어요.\n\n## 긍정적 측면\n\n- 일부 팀원들은 네이티브 JavaScript를 작성하는 것처럼 코드를 작성하는 과정을 즐겼어요. 이는 자연스럽고 익숙한 경험을 만들어냈어요.\n- 낮은 학습 곡선으로 인해 Svelte를 배우고 사용하기 쉬웠어요. 우리 팀원들은 언어의 기초를 빠르게 마스터하고 프로젝트에 빠르게 적응했어요.\n- 코드 작성의 용이성과 코드베이스의 간결함으로 개발 과정이 가속화되었어요.\n- 우리 팀은 코드를 효율적으로 작성하기 위해 추가 작업을 해야하지 않아서 좋았어요, 예를 들어 useMemo와 같은 것들을 다룰 필요가 없었어요.\n- Svelte의 기본 기능들이 우리에게 추가 라이브러리가 필요하지 않고도 많은 작업을 수행할 수 있게 했어요.\n- 슬롯 구조와 이벤트 디스패치의 용이성은 구성 요소간의 커뮤니케이션과 재사용성을 증가시켰어요.\n\n## 부정적 측면\n\n<div class=\"content-ad\"></div>\n\n- Svelte의 생태계와 커뮤니티는 아직 상대적으로 작습니다. 이는 특히 제3자 라이브러리 및 도구에 대한 통합과 지원 부족으로 이어질 수 있습니다.\n- 큰 객체의 반응성에 문제가 있습니다. Store를 사용할 때 큰 객체를 사용하는 것은 도전적일 수 있습니다.\n- WebStorm 인텔리센스의 부재가 개발 경험에 부정적인 영향을 미칩니다.\n\n## 결론\n\n전반적으로, 우리 팀은 Svelte와 함께 일할 수 있어 기쁘게 생각했습니다. 특히 성능, 단순함 및 사용 편의성에 대한 매우 긍정적인 피드백을 받았습니다. 그러나 생태계의 성숙도 및 일부 개발 경험적인 도전에 대한 우려가 표명되었습니다. Svelte는 특정 유형의 프로젝트에 강력한 옵션일 수 있지만, 다른 프레임워크에서 제공하는 광범위한 생태계와 커뮤니티 지원이 더 매력적일 수도 있습니다.\n\n# 참고문헌\n\n<div class=\"content-ad\"></div>\n\n- Gist - Svelte에 대한 진실\n- 반응성에 대한 재고\n- 컴포넌트 파티\n- 레시피 - Svelte Society\n- 소개 - SvelteKit\n\n우리는 산업에서 가장 빛나는 두뇌들로 팀을 구축하고 있어요. 우리와 함께 일하고 싶으신가요? 우리가 오픈한 포지션에 대해 더 알아보려면 아래 페이지를 방문해 주세요.","ogImage":{"url":"/assets/img/2024-06-30-SvelteDifferentandEngagingExperienceUnlikeOthers_0.png"},"coverImage":"/assets/img/2024-06-30-SvelteDifferentandEngagingExperienceUnlikeOthers_0.png","tag":["Tech"],"readingTime":5},{"title":"Flutter 숨겨진 보물 탐험 잘 알려지지 않은 위젯 공개  Part 3","description":"","date":"2024-06-30 18:46","slug":"2024-06-30-ExploringHiddenTreasuresinFlutterLesser-KnownWidgetsUnveiledPart3","content":"\n플러터는 다양하고 시각적으로 멋진 애플리케이션을 개발할 수 있도록 개발자들에게 넓은 위젯 카탈로그로 유명합니다. 자주 사용되는 위젯들은 잘 알려져 있지만, 플러터는 잘 알려지지 않지만 매우 유용한 다양한 위젯들도 제공합니다. UI의 세련됨과 기능성을 향상시킬 수 있는 이런 숨겨진 보석들을 알아보겠습니다.\n\n![이미지](/assets/img/2024-06-30-ExploringHiddenTreasuresinFlutterLesser-KnownWidgetsUnveiledPart3_0.png)\n\n### 1. FadeInImage\n\nFadeInImage는 주 이미지가 로딩되는 동안 플레이스홀더 이미지를 표시할 수 있는 위젯입니다. 네트워크에서 이미지를 다룰 때 사용자 경험을 향상시키는 데 특히 유용합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nFadeInImage(\n  placeholder: AssetImage('assets/placeholder.png'),\n  image: NetworkImage('https://example.com/image.jpg'),\n)\n```\n\n## 2. GridPaper\n\nGridPaper은 레이아웃 디버깅을 위한 편리한 위젯입니다. 앱에 그리드를 겹쳐서 간격, 정렬 및 레이아웃 문제를 시각화하기 쉽게 만들어줍니다.\n\n```js\nGridPaper(\n  color: Colors.blueAccent,\n  divisions: 4,\n  interval: 100.0,\n  subdivisions: 2,\n)\n```\n\n<div class=\"content-ad\"></div>\n\n## 3. 히어로\n\n히어로는 위젯을 화면에서 다른 화면으로 부드럽게 전환하여 라우트 간에 애니메이션을 제공합니다. 시각적으로 매력적인 네비게이션 애니메이션을 만드는 데 이상적입니다.\n\n```js\nHero(\n  tag: 'hero-image',\n  child: Image.network('https://example.com/image.jpg'),\n)\n```\n\n## 4. KeepAlive\n\n<div class=\"content-ad\"></div>\n\nKeepAlive은 위젯이 화면에서 벗어나도 위젯 트리에 유지되도록 돕습니다. 이는 ListView 또는 PageView에서 위젯의 상태를 유지하는 데 특히 유용합니다.\n\n```js\nclass MyStatefulWidget extends StatefulWidget {\n  @override\n  _MyStatefulWidgetState createState() => _MyStatefulWidgetState();\n}\n\nclass _MyStatefulWidgetState extends State<MyStatefulWidget> with AutomaticKeepAliveClientMixin<MyStatefulWidget> {\n  @override\n  bool get wantKeepAlive => true;\n\n  @override\n  Widget build(BuildContext context) {\n    super.build(context);\n    return Container();\n  }\n}\n```\n\n## 5. ListBody\n\nListBody는 주어진 축을 따라 자식 위젯을 선형 배열로 정렬합니다. 간단한 리스트 레이아웃이 필요한 경우 Column 및 Row 대신 간단한 대안으로 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nListBody(\n  children: <Widget>[\n    Text('Item 1'),\n    Text('Item 2'),\n    Text('Item 3'),\n  ],\n)\n```\n\n## 6. MenuRegion\n\nMenuRegion은 앱에서 컨텍스트 메뉴를 정의하는 데 사용됩니다. 이 위젯은 데스크톱 애플리케이션에서 마우스 오른쪽 클릭 컨텍스트 메뉴가 흔한 경우에 유용합니다.\n\n```js\nMenuRegion(\n  child: Container(\n    color: Colors.blue,\n    width: 100,\n    height: 100,\n  ),\n)\n```\n\n<div class=\"content-ad\"></div>\n\n## 7. LookUpBoundary\n\nLookUpBoundary은 InheritedWidget 조회 범위를 제한하는 위젯입니다. 위젯 트리의 재구성 동작을 최적화하고 제어하는 데 유용합니다.\n\n```js\nLookUpBoundary(\n  child: MyInheritedWidget(\n    child: MyWidget(),\n  ),\n)\n```\n\n## 8. Listener\n\n<div class=\"content-ad\"></div>\n\n리스너는 터치, 마우스, 스타일러스 상호작용과 같은 포인터 이벤트를 감지합니다. 이 위젯은 사용자 정의 제스처와 상호작용을 구현하는 데 유용합니다.\n\n```js\nListener(\n  onPointerDown: (PointerDownEvent event) => print('Pointer down event'),\n  child: Container(\n    color: Colors.red,\n    width: 100,\n    height: 100,\n  ),\n)\n```\n\n## 9. 확대경\n\n확대경은 특정 영역에 확대 효과를 제공합니다. 이는 접근성을 향상시키고 특정 시나리오에서 사용자 경험을 향상하는 데 좋습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n확대기(\n  자식: Text('나를 확대해주세요!'),\n)\n```\n\n## 10. 메뉴 앵커\n\n메뉴 앵커는 특정 위치에 메뉴를 고정하는 데 사용됩니다. 사용자 정의 드롭다운 메뉴와 컨텍스트 메뉴를 만드는 데 유용합니다.\n\n```js\n메뉴 앵커(\n  menuChildren: <Widget>[\n    Text('메뉴 항목 1'),\n    Text('메뉴 항목 2'),\n  ],\n  자식: Text('메뉴 열기'),\n)\n```\n\n<div class=\"content-ad\"></div>\n\n## 11. MenuBar\n\nMenuBar은 데스크톱 애플리케이션에서 사용할 수 있는 전통적인 메뉴 모음입니다. 데스크톱 사용자에게 익숙한 탐색 경험을 제공합니다.\n\n```js\nMenuBar(\n  children: <Widget>[\n    Text('File'),\n    Text('Edit'),\n    Text('View'),\n  ],\n)\n```\n\n## 12. MouseRegion\n\n<div class=\"content-ad\"></div>\n\nMouseRegion은 위젯에 마우스가 진입하거나 나가거나 호버될 때를 감지합니다. 인터랙티브 데스크톱 애플리케이션을 만드는 데 필수적인 기능이에요!\n\n```js\nMouseRegion(\n  onEnter: (_) => print('마우스 진입'),\n  onExit: (_) => print('마우스 나감'),\n  child: Container(\n    color: Colors.green,\n    width: 100,\n    height: 100,\n  ),\n)\n```\n\n이 글이 유익했기를 바라요! 제공된 정보를 감사하게 여기신다면, 제게 커피 한 잔 사주는 옵션이 있답니다! 여러분의 도움이 큰 힘이 될 거에요!\n\n<img src=\"/assets/img/2024-06-30-ExploringHiddenTreasuresinFlutterLesser-KnownWidgetsUnveiledPart3_1.png\" />\n\n<div class=\"content-ad\"></div>\n\n# 함께해요\n\n이 글을 읽어 주셔서 감사합니다. 즐겁게 읽으셨다면, 더 많은 글을 살펴보고 앞으로 제 포스트를 지켜봐 주시면 감사하겠습니다.\n\n더 많은 IT 관련 콘텐츠에 관심이 있다면, Digital Dive Hub 웹사이트를 방문해 최신 블로그와 소식을 확인해 보세요.\n\n# Stackademic 🎓\n\n<div class=\"content-ad\"></div>\n\n끝까지 읽어 주셔서 감사합니다! 떠나시기 전에 다음을 확인해 주세요:\n\n- 작가를 박수로 응원하고 팔로우해 주세요! 👏\n- 저희를 팔로우해 주세요: X | LinkedIn | YouTube | Discord\n- 다른 플랫폼에서도 만나보세요: In Plain English | CoFeed | Differ\n- 더 많은 콘텐츠는 Stackademic.com에서 확인하세요.\n","ogImage":{"url":"/assets/img/2024-06-30-ExploringHiddenTreasuresinFlutterLesser-KnownWidgetsUnveiledPart3_0.png"},"coverImage":"/assets/img/2024-06-30-ExploringHiddenTreasuresinFlutterLesser-KnownWidgetsUnveiledPart3_0.png","tag":["Tech"],"readingTime":5},{"title":"모바일 개발 탐색 플랫폼, 아키텍처, 그리고 HNG 인턴십 경험기","description":"","date":"2024-06-30 18:45","slug":"2024-06-30-NavigatingMobileDevelopmentPlatformsArchitecturesandMyJourneywithHNGInternship","content":"\n\n# 소개\n\n![이미지](/assets/img/2024-06-30-NavigatingMobileDevelopmentPlatformsArchitecturesandMyJourneywithHNGInternship_0.png)\n\n모바일 개발은 계속적인 학습과 적응이 필요한 동적이고 빠르게 변화하는 분야입니다. HNG 인턴십과 함께하는 내 여정을 시작하면서, 특히 이 산업을 형성하는 플랫폼 및 일반적인 소프트웨어 아키텍처 패턴에 초점을 맞춰 모바일 개발 세계에 대한 인사이트를 공유하고자 합니다.\n\n# 섹션 1: 모바일 개발 플랫폼 이해하기\n\n<div class=\"content-ad\"></div>\n\n## iOS 개발:\n\n![이미지](/assets/img/2024-06-30-NavigatingMobileDevelopmentPlatformsArchitecturesandMyJourneywithHNGInternship_1.png)\n\n설명: 애플이 개발한 iOS는 iPhone 및 iPad 같은 기기를 작동시킵니다.\n\n사용된 프로그래밍 언어: 개발자들은 Swift 또는 Objective-C를 사용하여 Xcode IDE에서 애플리케이션을 만듭니다.\n\n<div class=\"content-ad\"></div>\n\n장점:\n- 뛰어난 성능과 보안.\n- 강력한 개발자 지원 및 방대한 문서.\n- 앱에 지출할 의사가 있는 수요가 많고 수익성 높은 시장 접근.\n\n단점:\n- 개발을 위해 Mac이 필요합니다.\n- 앱 스토어 승인 프로세스가 엄격하고 시간이 많이 소요될 수 있습니다.\n- 안드로이드에 비해 제한된 사용자 정의 기능이 있습니다.\n\n## ``안드로이드 개발:\n\n<img src=\"/assets/img/2024-06-30-NavigatingMobileDevelopmentPlatformsArchitecturesandMyJourneywithHNGInternship_2.png\" />\n\nDescription: Google이 개발한 안드로이드는 다양한 기기에서 사용되는 오픈 소스 플랫폼입니다.\n\n<div class=\"content-ad\"></div>\n\n프로그래밍 언어 사용: 주로 안드로이드 스튜디오에서 Java 또는 Kotlin을 사용하여 개발합니다.\n\n장점:\n- 다양한 기기 호환성과 대규모 사용자 베이스.\n- 높은 맞춤 및 유연성.\n- 다중 앱 스토어를 통한 쉬운 앱 배포.\n\n단점:\n- 기기 및 OS 버전 간의 단편화로 인한 도전.\n- 플랫폼의 개방적인 특성으로 인한 보안 문제.\n- 다양한 기기로 인한 테스트의 복잡성.\n\n## \"크로스 플랫폼 개발:\"\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-30-NavigatingMobileDevelopmentPlatformsArchitecturesandMyJourneywithHNGInternship_3.png)\n\nDescription: 이름에서 알 수 있듯이, 크로스 플랫폼 접근법은 단일 코드 베이스를 사용하여 다양한 모바일 플랫폼에서 유사하게 작동하는 앱을 개발할 수 있게 합니다.\n\n사용된 프로그래밍 언어: React Native, Flutter, Xamarin과 같은 크로스 플랫폼 프레임워크를 사용하여 iOS 및 Android용 앱을 개발할 수 있습니다.\n\n장점:\n- 여러 플랫폼 간에 코드를 공유하여 시간과 자원을 절약합니다.\n- 보다 쉬운 유지보수 및 업데이트가 가능합니다.\n- 더 적은 노력으로 보다 넓은 관객에게 접근할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n단점:\n- 성능이 원래 앱보다 최적화되지 않을 수 있습니다.\n- 플랫폼별 기능에 제한적인 액세스.\n- 프레임워크의 지원 및 커뮤니티에 의존.\n\n# 섹션 2: 모바일 개발에서 일반적인 소프트웨어 아키텍처 패턴\n\n## `모델-뷰-컨트롤러 (MVC):\n\n![이미지](/assets/img/2024-06-30-NavigatingMobileDevelopmentPlatformsArchitecturesandMyJourneywithHNGInternship_4.png)\n\n<div class=\"content-ad\"></div>\n\n안녕! 아래는 애플리케이션을 세 가지 상호연결된 구성 요소로 분리하는 설명이에요:\n- Model (데이터),\n- View (UI),\n- Controller (로직).\n\n장점:\n- 개발 및 유지 관리를 간편하게 해줘요.\n- 관심사 분리가 명확해져요.\n- 재사용 가능한 컴포넌트를 활용할 수 있어요.\n\n단점:\n- 복잡한 애플리케이션에서 대형 뷰 컨트롤러로 이어질 수 있어요.\n- 구성 요소 간의 강한 결합이 유연성을 방해할 수 있어요.\n\n## ``Model-View-ViewModel (MVVM):``\n\n<div class=\"content-ad\"></div>\n\n아래는 Markdown 형식으로 변환되었습니다:\n\n![image](/assets/img/2024-06-30-NavigatingMobileDevelopmentPlatformsArchitecturesandMyJourneywithHNGInternship_5.png)\n\n설명: 프레젠테이션 로직을 처리하는 ViewModel 레이어를 추가하여 관심사의 분리를 강화합니다.\n\n장점:\n- 향상된 테스트 가능성 및 유지 관리성.\n- MVC보다 더 나은 관심사의 분리.\n- 복잡한 UI를 관리하기가 더 쉬움.\n\n단점:\n- ViewModel 추가로 복잡성이 증가.\n- 초심자에게는 높은 학습 곡선.\n\n<div class=\"content-ad\"></div>\n\n## Clean Architecture:\n\n![Clean Architecture](/assets/img/2024-06-30-NavigatingMobileDevelopmentPlatformsArchitecturesandMyJourneywithHNGInternship_6.png)\n\nDescription: 관심사의 분리와 프레임워크의 독립성을 강조하여 코드를 레이어로 구성합니다(프레젠테이션, 도메인, 데이터).\n\n장점:\n-높은 테스트 용이성과 유지 보수성.\n-책임의 명확한 분리.\n-앱을 더 유연하게 만드는 프레임워크와의 독립성.\n\n<div class=\"content-ad\"></div>\n\n단점:\n- 더 가파른 학습 곡선 및 구현이 더 복잡합니다.\n- 간단한 애플리케이션에는 오버 엔지니어링으로 이어질 수 있습니다.\n\n# 섹션 3: HNG 인턴십과 함께 하는 나의 여정\n\nFlutter로 시작한 신진 모바일 개발자로서, HNG 인턴십과의 여정을 시작하게 되어 기쁩니다. 그들에 대해 많은 이야기를 듣고, 인턴십이 얼마나 도전적인지 알고 있지만, 나는 도전을 좋아합니다. 이 기회는 기술에 대한 나의 열정과 모바일 개발 지식을 더 깊이 알고 싶은 욕구와 완벽하게 부합합니다.\n\n이 인턴십을 통해 나는 다음을 목표로 합니다:\n\n<div class=\"content-ad\"></div>\n\n- 나의 스킬 향상: 실제 프로젝트를 통해 실무 경험을 쌓고 산업 전문가로부터 배우세요.\n- 네트워크 확장: 비슷한 목표를 갖고 있는 동료와 멘토들과 연결하여 경력에 대한 조언을 받고 그들의 재능 풀에서 최고의 재능으로 성장하세요.\n- 포트폴리오 구축: 나의 능력과 창의성을 보여주는 애플리케이션을 개발하세요.\n- 커뮤니티 기여: 내 학습 내용을 공유하고 다른 사람들의 개발 여정을 돕습니다.\n\nHNG 인턴십은 능숙한 모바일 개발자가 되기 위한 제 목표를 이루는 한 걸음입니다. 이러한 도전과 기회를 함께해 주기를 고대하고 있습니다.\n\n트위터에서 저와 연락하세요.","ogImage":{"url":"/assets/img/2024-06-30-NavigatingMobileDevelopmentPlatformsArchitecturesandMyJourneywithHNGInternship_0.png"},"coverImage":"/assets/img/2024-06-30-NavigatingMobileDevelopmentPlatformsArchitecturesandMyJourneywithHNGInternship_0.png","tag":["Tech"],"readingTime":4},{"title":"Golang에서 오류 처리를 마스터하는 방법 최고의 실천 방법과 팁","description":"","date":"2024-06-27 18:32","slug":"2024-06-27-MasteringErrorHandlinginGolangBestPracticesandTips","content":"\n\n고랭(Golang)에서 에러를 우아하게 처리하는 방법을 배우고, 코드 신뢰성을 높이기 위한 에러 처리에 대한 종합 가이드를 제공합니다.\n\n![이미지](/assets/img/2024-06-27-MasteringErrorHandlinginGolangBestPracticesandTips_0.png)\n\nGo 언어에서는 일반적으로 에러를 표현하는 데 사용되는 인터페이스 타입인 error 타입이 정의됩니다.\n\n```js\ntype error interface {\n    Error() string\n}\n```\n\n<div class=\"content-ad\"></div>\n\n에러 인터페이스에는 Error() 메서드라는 하나의 메서드만 있습니다. 이 메서드는 에러를 설명하는 문자열을 반환합니다. 이는 Error() 메서드를 구현하는 모든 타입을 에러 타입으로 사용할 수 있다는 것을 의미합니다.\n\n일반적으로 Go 프로그램의 함수들은 에러가 발생했을 때 에러 타입의 값을 반환합니다. 이를 통해 호출자가 에러 정보를 처리하거나 기록할 수 있습니다.\n\n에러를 어떻게 생성할까요?\n\nGo 언어의 디자이너들은 Go 개발자들이 에러 값을 생성하는 두 가지 편리한 방법을 제공했습니다: errors.New와 fmt.Errorf.\n\n<div class=\"content-ad\"></div>\n\n- errors.New() 함수는 오직 오류 메시지 문자열만 포함하므로 오류 값을 생성하는 가장 간단한 방법입니다. 이 방법은 간단한 오류 값을 생성하는 데 적합합니다.\n- 반면에 fmt.Errorf() 함수는 fmt.Printf() 함수와 유사한 형식화된 오류 메시지를 구성할 수 있도록 합니다. 이 방법은 더 복잡한 오류 메시지를 구축해야 할 때 유용합니다.\n\n이 두 가지 방법을 사용하여 아래 코드와 같이 error 인터페이스를 만족하는 오류 값을 손쉽게 구성할 수 있습니다:\n\n```js\nerr := errors.New(\"hello error\")\nerrWithCtx = fmt.Errorf(\"index %i is out of bounds\", i)\n```\n\n이 두 가지 방법은 실제로 동일한 error 인터페이스를 구현하는 동일하지만 알려지지 않은 유형의 인스턴스를 반환합니다.\n\n<div class=\"content-ad\"></div>\n\n이 비공개 타입은 errors.errorString이며, 그 정의는 다음과 같습니다:\n\n```js\n// $GOROOT/src/errors/errors.go\ntype errorString struct {\n    s string\n}\n\nfunc (e *errorString) Error() string {\n    return e.s\n}\n```\n\n대부분의 경우에 이 두 가지 메서드를 사용하여 생성된 오류 값이 우리의 요구 사항을 충족할 것입니다.\n\n그러나 이러한 메서드가 오류 값을 생성하는 데 편리하긴 하지만, 오류 처리기에 제공하는 오류 컨텍스트는 문자열 형태로 제공된 정보에 제한된다는 점을 알아야 합니다. 이 정보는 Error 메서드에서 반환하는 정보입니다.\n\n<div class=\"content-ad\"></div>\n\n에러 유형을 사용자 정의하는 방법\n\n일부 상황에서는 에러 핸들러가 적절한 에러 처리 경로를 선택하는 데 도움이 되도록 에러 값에서 더 많은 정보를 추출해야 할 수도 있습니다.\n\n명확히 이 두 가지 메서드만으로는 그러한 경우에 충분하지 않습니다.\n\n이러한 상황에서는 이러한 요구 사항을 충족시키기 위해 에러 유형을 사용자 정의할 수 있습니다. 다음은 예시입니다:\n\n<div class=\"content-ad\"></div>\n\n```go\npackage main\n\nimport \"fmt\"\n\n// 사용자 정의 오류 유형\ntype MyError struct {\n  ErrorCode    int\n  ErrorMessage string\n}\n\n// `error` 인터페이스의 `Error` 메서드 구현\nfunc (e MyError) Error() string {\n  return fmt.Sprintf(\"Error %d: %s\", e.ErrorCode, e.ErrorMessage)\n}\n\nfunc someFunction() error {\n  // 커스텀 오류 값 생성\n  err := MyError{\n    ErrorCode:    404,\n    ErrorMessage: \"Not Found\",\n  }\n  return err\n}\n\nfunc main() {\n  err := someFunction()\n  fmt.Println(\"에러:\", err)\n}\n```\n\n또 다른 예시를 살펴보겠습니다. 표준 라이브러리의 net 패키지에 정의된 추가 컨텍스트를 가진 오류 유형입니다:\n\n```go\n// $GOROOT/src/net/net.go\ntype OpError struct {\n    Op string\n    Net string\n    Source Addr\n    Addr Addr\n    Err error\n}\n```\n\n이러한 유형의 오류 값이 제공하는 추가 컨텍스트 정보(예: Op, Net, Source 등)를 기반으로 에러 처리 경로를 결정할 수 있게끔 에러 핸들러가 결정을 내릴 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n위의 표준 라이브러리에서 다음 코드 예시를 살펴보겠습니다:\n\n```js\n// $GOROOT/src/net/http/server.go\nfunc isCommonNetReadError(err error) bool {\n    if err == io.EOF {\n        return true\n    }\n    if neterr, ok := err.(net.Error); ok && neterr.Timeout() {\n        return true\n    }\n    if oe, ok := err.(*net.OpError); ok && oe.Op == \"read\" {\n        return true\n    }\n    return false\n}\n```\n\n위 코드에서는 타입 단언(Type Assertion)을 활용하여 err 변수의 동적 타입이 *net.OpError 또는 net.Error인지를 결정합니다.\n\nerr의 동적 타입이 *net.OpError인 경우, 타입 단언은 이 동적 타입의 값(oe에 저장)을 반환하고, 코드는 그 후 해당 Op 필드가 read인지 여부를 확인하여 CommonNetRead 유형의 에러인지 결정할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n오류 유형의 장점.\n\n# 1. 오류를 처리하는 표준화된 방법을 제공합니다.\n\n서로 다른 개발자, 다른 프로젝트 및 심지어 표준 라이브러리에서 코드를 사용할 때 오류 유형을 오류 인터페이스 변수의 형태로 일관되게 표현한다면 코드 가독성을 향상시키는 것뿐만 아니라 통일된 오류 처리 전략의 수립을 용이하게 합니다.\n\n# 2. 오류는 모두 값입니다.\n\n<div class=\"content-ad\"></div>\n\n우리가 만드는 오류들은 실제로 값들입니다. 이는 오류 인터페이스 유형의 변수에 할당되었을 때에도 ==와 !=와 같은 논리적 비교를 수행할 수 있음을 의미합니다. 정수 값들과 마찬가지로요.\n\n오류를 검사하는 경험은 함수 호출자에게 동일합니다.\n\n오류가 인터페이스 유형이기 때문에, 그의 기본 제로 값은 nil입니다.\n\n그러므로, 일반적으로 함수에 의해 반환된 오류를 nil과 비교하여 함수가 성공했는지 여부 또는 오류가 발생했는지를 확인합니다.\n\n<div class=\"content-ad\"></div>\n\n만약 반환된 오류가 nil이라면, 성공적으로 함수가 실행된 것이고, 그렇지 않다면 오류가 발생했음을 나타냅니다.\n\n이 규칙을 따르면 오류 처리가 일관적이고 직관적으로 이루어집니다.\n\n예를 들어, 다음과 같은 오류 확인 코드를 자주 볼 수 있습니다:\n\n```js\nfunc someFunction() error {\n    return errors.New(\"Errors\")\n}\n\nfunc main() {\n    err := someFunction()\n\n    if err != nil {\n        fmt.Println(\"실패, 오류:\", err)\n    } else {\n        fmt.Println(\"성공\")\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n# 3. 쉽게 확장할 수 있습니다.\n\n에러들은 에러 인터페이스 변수로 일관되게 표시됩니다. 사용자 정의 에러 타입을 만들어 우리의 에러 컨텍스트를 쉽게 확장할 수 있으며, 이는 Go 표준 라이브러리의 OpError 타입과 비슷합니다.\n\n에러 인터페이스는 에러 값을 제공하는 제공자와 에러 처리를 담당하는 코드 간의 계약 역할을 합니다.\n\n에러 인터페이스를 구현하는 사람은 에러 처리 코드에서 사용할 에러 컨텍스트를 제공하는 것이 책임입니다.\n\n<div class=\"content-ad\"></div>\n\n이는 특정 오류 컨텍스트를 오류 인터페이스 유형과 분리하여 Go의 구성 가능성 및 직교성을 따르는 설계 철학과 일치합니다.\n\nGo 오류 처리의 일반적인 관행.\n\n## 1. 투명한 오류 처리 전략.\n\n간단히 말해서, Go 언어에서의 오류 처리는 함수에 의해 반환된 오류 유형 변수에 의해 전달되는 오류 값 정보를 기반으로 의사 결정을 내리고 후속 코드 실행 경로를 선택하는 과정입니다.\n\n<div class=\"content-ad\"></div>\n\n이 방식을 통해 가장 간단한 오류 전략은 반환된 오류 값이 전달하는 구체적인 컨텍스트 정보를 완전히 무시하는 것입니다.\n\n대신, 오류가 발생할 때마다 하나의 오류 처리 실행 경로로 이어집니다. 예를 들어, 다음 코드를 참고해보세요:\n\n```js\nerr := doSomething()\nif err != nil {\n    ... ...\n    return err\n}\n```\n\n이것은 Go 언어에서 가장 흔한 오류 처리 전략으로, 오류 처리 시나리오의 80% 이상을 차지합니다. 이 전략에서는 오류 핸들러가 오류 값의 컨텍스트에 신경을 쓰지 않기 때문에, 오류 생성자 (예: 예시의 doSomething 함수)는 Go 표준 라이브러리에서 제공하는 두 가지 기본 오류 값 생성 방법을 직접 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nfunc doSomething(...) error {\n    ... ...\n    return errors.New(\"일부 오류가 발생했습니다\")\n}\n```\n\n이러한 방식으로 생성된 오류 값은 오류 처리기에게 투명한 컨텍스트 정보를 나타냅니다.\n\n오류 처리기가 오류 컨텍스트에 대해 인식할 필요가 없는 상황에서는 투명한 오류 처리 전략이 오류 처리기와 오류 값 생성자 간의 결합을 최소화합니다.\n\n오류 컨텍스트가 오류 처리에 무관한 경우, 이 접근 방식은 오류 처리와 오류 값 생성 사이의 상호 의존성을 줄이는 데 효과적입니다.\n\n\n<div class=\"content-ad\"></div>\n\n# 2. Sentinel 오류 처리 전략.\n\n오류 핸들러가 투명한 오류 값에만 의존하여 오류 처리 결정을 내릴 수없는 경우, 반환된 오류 값을 검사하려고 시도할 수 있습니다. 아래 코드와 같이 이를 통해 발생하는 안티패턴이 발생할 수 있습니다:\n\n```js\ndata, err := b.Peek(1)\nif err != nil {\n    switch err.Error() {\n    case \"bufio: negative count\":\n        // ... ...\n        return\n    case \"bufio: buffer full\":\n        // ... ...\n        return\n    case \"bufio: invalid use of UnreadByte\":\n        // ... ...\n        return\n    default:\n        // ... ...\n        return\n    }\n}\n```\n\n간단히 말해서, 이 안티패턴은 오류 핸들러가 오류 처리 결정을 내릴 때 \"투명한 오류 값\"이 제공하는 단일 컨텍스트 정보에 완전히 의존하는 경우를 나타냅니다.\n\n<div class=\"content-ad\"></div>\n\n하지만 이 \"안티-패턴\"은 상당한 암시적 결합을 야기합니다.\n\n즉, 오류 값 생성자에 의한 오류 설명 문자열의 미세한 변경조차도 오류 처리 동작에 변화를 일으킬 수 있습니다.\n\n또한, 문자열 비교를 통해 오류 값들을 조사하는 이 방식은 성능적으로 효율적이지 않습니다.\n\n그렇다면 해결책은 무엇일까요? Go 표준 라이브러리는 내보낸 \"특정값(sentinel)\" 오류 값의 정의를 통해 오류 핸들러들이 오류 값을 조사하고 오류 처리 결정을 내리는 데 도움을 주는 방식을 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n예를 들어, bufio 패키지에서 정의된 \"sentinel errors\"는 다음과 같습니다:\n\n```js\n// $GOROOT/src/bufio/bufio.go\nvar (\n    ErrInvalidUnreadByte = errors.New(\"bufio: invalid use of UnreadByte\")\n    ErrInvalidUnreadRune = errors.New(\"bufio: invalid use of UnreadRune\")\n    ErrBufferFull        = errors.New(\"bufio: buffer full\")\n    ErrNegativeCount     = errors.New(\"bufio: negative count\")\n)\n```\n\n다음 코드 조각은 이전에 언급된 sentinel errors를 활용하여 에러 처리 분기에서 결정을 내리는 예시입니다:\n\n```js\ndata, err := b.Peek(1)\nif err != nil {\n    switch err {\n    case bufio.ErrNegativeCount:\n        // ... ...\n        return\n    case bufio.ErrBufferFull:\n        // ... ...\n        return\n    case bufio.ErrInvalidUnreadByte:\n        // ... ...\n        return\n    default:\n        // ... ...\n        return\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n그러나 API 개발자의 경우, \"sentinel\" 오류 값 노출은 이러한 오류 값과 패키지의 공개 함수가 API의 일부가 되는 것을 의미합니다.\n\n한 번 릴리스되면, 개발자는 효과적으로 유지 관리해야 합니다. 또한, \"sentinel\" 오류 값은 이를 사용하는 오류 처리기에 종속성을 만듭니다.\n\nGo 1.13부터 표준 라이브러리 오류 패키지에서 Is 함수가 도입되어 오류 처리기가 오류 값으로 검사할 수 있습니다.\n\nIs 함수는 다음 코드에서 보여지는 것처럼 오류 변수를 \"sentinel\" 오류 값과 비교하는 것과 유사합니다:\n\n<div class=\"content-ad\"></div>\n\n```go\nif errors.Is(err, ErrOutOfBounds) {\n    // 뭔가를 수행\n}\n```\n\n차이점은 에러 변수가 래핑된 에러를 포함하는 경우, errors.Is 메서드는 래핑된 에러 내에서 에러 체인을 탐색하여 일치하는 에러를 찾을 때까지 모든 래핑된 에러와 비교합니다.\n\n다음은 Is 함수를 사용하는 예시입니다:\n\n```go\nvar ErrSentinel = errors.New(\"기본 신호 에러\")\n\nfunc main() {\n  err1 := fmt.Errorf(\"sentinel을 래핑: %w\", ErrSentinel)\n  err2 := fmt.Errorf(\"err1을 래핑: %w\", err1)\n  println(err2 == ErrSentinel) // false\n  if errors.Is(err2, ErrSentinel) {\n    println(\"err2는 ErrSentinel입니다.\")\n    return\n  }\n\n  println(\"err2는 ErrSentinel이 아닙니다.\")\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 예제에서는 fmt.Errorf 함수와 %w 동사를 사용하여 랩핑된 오류 변수 err1과 err2를 생성합니다.\n\nerr1은 \"sentinel\" 오류 값 ErrSentinel을 랩핑하고, err2는 err1을 랩핑하여 오류 체인을 생성합니다. 오류 체인의 맨 위에는 err2가 있고, 맨 아래에는 ErrSentinel이 있습니다.\n\n그런 다음 값 비교와 errors.Is 함수를 모두 사용하여 err2와 ErrSentinel 간의 관계를 결정합니다.\n\n코드를 실행할 때 다음과 같은 결과를 관찰할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nfalse\nerr2 is ErrSentinel\n```\n\n보시다시피 동등 연산자를 사용하여 err2와 ErrSentinel을 비교하면 서로 다릅니다.\n\n그러나 errors.Is 함수는 err2 안의 오류 체인을 탐색하여 가장 깊은 수준에서 랩핑된 \"sentinel\" 오류 값 ErrSentinel을 찾습니다.\n\nGo 1.13 이상 버전을 사용하는 경우, 특정 \"sentinel\" 오류 값으로 랩핑된 예상 오류 값인지 여부를 확인하기 위해 errors.Is 메서드를 사용하는 것이 좋습니다.\n\n<div class=\"content-ad\"></div>\n\n이 접근 방식은 특히 오류 래핑과 체인이 관련된 시나리오에서 더 견고하고 유연한 오류 처리를 제공합니다.\n\n## 3. 오류 값 유형 검사 전략\n\n이전에 살펴본 대로, Go 표준 라이브러리에서 제공하는 오류 값 구성 방법을 사용하여 구성된 \"sentinel\" 오류 값은 목표 값을 비교하는 기능 이상의 추가 오류 컨텍스트 정보를 제공하지 않습니다.\n\n오류 처리기가 오류 값에서 더 많은 \"오류 컨텍스트\" 정보를 필요로 하는 경우, 이전에 논의된 전략 및 오류 값 구성 방법이 충분하지 않을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이런 경우에는 추가 “에러 컨텍스트” 정보를 제공하기 위해 사용자 정의 에러 유형을 사용하여 에러 값을 구성해야 합니다.\n\n모든 에러 값이 에러 인터페이스 변수를 통해 균일하게 표시되기 때문에 기저 에러 유형이 전달하는 에러 컨텍스트 정보를 얻으려면 Go의 타입 어설션 또는 타입 스위치 메커니즘을 사용해야 합니다.\n\n에러 값을 검사하는 이 에러 처리 접근 방식은 “에러 값 타입 검사 전략”으로 참조할 수 있습니다.\n\n우리의 이해를 깊이 있게 하기 위해 표준 라이브러리의 예제를 살펴보겠습니다. json 패키지에서 UnmarshalTypeError라는 사용자 정의 에러 유형이 정의되어 있습니다:\n\n<div class=\"content-ad\"></div>\n\n에러 핸들러는 오류 값 유형 검사 전략을 사용하여 더 많은 오류 컨텍스트 정보를 얻을 수 있습니다. 아래는 이 전략을 활용하는 json 패키지의 메서드 구현 예시입니다:\n\n```js\r\n// $GOROOT/src/encoding/json/decode.go\nfunc (d *decodeState) addErrorContext(err error) error {\n    if d.errorContext.Struct != nil || len(d.errorContext.FieldStack) > 0 {\n        switch err := err.(type) {\n        case *UnmarshalTypeError:\n            err.Struct = d.errorContext.Struct.Name()\n            err.Field = strings.Join(d.errorContext.FieldStack, \".\")\n            return err\n        }\n    }\n    return err\n}\r\n```\n\n이 코드에서는 유형 스위치 문을 사용하여 err 변수가 나타내는 동적 유형 및 값을 결정하고, 일치하는 경우 분기에서 처리하기 위해 오류 컨텍스트 정보가 활용됩니다.\n\n<div class=\"content-ad\"></div>\n\n일반적으로 사용자 정의된 내보낸 오류 유형은 XXXError 형식으로 명명됩니다.\n\n\"sentinel\" 오류 처리 전략과 유사하게, 오류 값 유형 검사 전략은 사용자 정의 오류 유형을 오류 핸들러에 노출시켜, 해당 유형들이 API의 일부가 되도록 하며, 패키지의 공개 함수와 함께 사용될 수 있도록 합니다.\n\n배포된 후에는 개발자가 이러한 사용자 정의 오류 유형을 유지 관리해야 합니다. 게다가, 이러한 유형을 검사하고 사용하는 오류 핸들러에 대한 의존성을 만듭니다.\n\nGo 1.13부터 표준 라이브러리 errors 패키지는 오류 핸들러가 오류 값들을 검사할 수 있는 As 함수를 제공합니다.\n\n<div class=\"content-ad\"></div>\n\nAs 함수는 특정 사용자 정의 오류 유형인지를 결정하기 위해 타입 단언을 사용하는 것과 유사합니다. 아래 코드에서와 같이 err 변수가 특정 사용자 정의 오류 유형인지 확인합니다.\n\n```js\nvar customErr *CustomError\nif errors.As(err, &customErr) {\n    // Handle the error as a CustomError\n}\n```\n\nAs 함수의 차이점은 오류 변수에 래핑된 오류가 포함되어 있는 경우, errors.As 함수가 래핑된 오류 내의 오류 체인을 횡단하며, 체인 내의 모든 래핑된 오류와 일치하는 오류 유형을 찾을 때까지 비교한다는 것입니다. 이는 errors.Is의 동작과 유사합니다.\n\nAs 함수 사용 예시가 여기 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\ntype MyError struct {\n    e string\n}\n\nfunc (e *MyError) Error() string {\n    return e.e\n}\n\nfunc main() {\n    var err = &MyError{\"MyError error demo\"}\n    err1 := fmt.Errorf(\"wrap err: %w\", err)\n    err2 := fmt.Errorf(\"wrap err1: %w\", err1)\n    var e *MyError\n    if errors.As(err2, &e) {\n        println(\"MyError is on the chain of err2\")\n        println(e == err)                  \n        return                             \n    }                                      \n    println(\"MyError is not on the chain of err2\")\n} \n```\n\n결과.\n\n```js\nMyError is on the chain of err2\ntrue\n```\n\n마침내 출력된 결과처럼, errors.As 함수가 err2 내의 오류 체인을 성공적으로 탐지하여 가장 깊은 오류를 찾아내고, err2를 *MyError 유형과 일치시킵니다.\n\n<div class=\"content-ad\"></div>\n\n성공적인 일치가 발생하면, errors.As는 일치한 오류 값을 As 함수의 두 번째 매개변수에 저장합니다. 따라서 println(e == err)을 실행하면 true가 반환됩니다.\n\nGo 1.13 이상 버전을 사용 중이라면, 특정 사용자 정의 오류 유형의 인스턴스인지를 확인하기 위해 errors.As 메서드를 사용하는 것이 좋습니다.\n\n이 접근 방식은 사용자 정의 오류를 처리하는 더 유연하고 효율적인 방법을 제공하며, 특히 래핑된 오류와 함께 작업할 때 유용합니다.\n\n# 4. 오류 행동 특성 검사 전략.\n\n<div class=\"content-ad\"></div>\n\n이전에 우리가 논의한 세 가지 전략 중에서는 첫 번째 전략인 \"투명한 오류 처리 전략\"만이 오류 생성자와 오류 처리자 간의 결합을 효과적으로 줄입니다.\n\n두 번째와 세 번째 전략은 현실 세계의 코딩에서 실용적이지만, 여전히 오류 생성자와 오류 처리자 간의 결합을 어느 정도 도입합니다.\n\n그래서, \"투명한 오류 처리 전략\"을 제외하고는 오류 처리자와 오류 값 생성자 간의 결합을 줄일 다른 방법이 있을까요?\n\nGo 표준 라이브러리에서는 패키지 내에서 오류 유형을 분류하고 일반적인 오류 동작 특성을 추출하여 이러한 오류 동작 특성을 공개 인터페이스 유형으로 배치하는 다른 오류 처리 접근 방식을 찾을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 접근법은 \"오류 동작 특성 검사 전략\"으로 알려져 있습니다.\n\n예를 들어, 표준 라이브러리의 net 패키지는 모든 패키지 내의 일반적인 오류 동작 특성을 추상화하고 net.Error 인터페이스에 넣습니다. 다음 코드에서 확인할 수 있습니다:\n\n```js\n// $GOROOT/src/net/net.go\ntype Error interface {\n    error\n    Timeout() bool  \n    Temporary() bool\n}\n```\n\nnet.Error 인터페이스에는 오류 동작 특성을 확인하는 두 가지 메서드가 포함되어 있습니다: Timeout은 시간 초과 오류인지 확인하고 Temporary는 임시 오류인지 확인합니다.\n\n<div class=\"content-ad\"></div>\n\n에러 핸들러는 특정 에러의 동작 특성을 검사하고 이 정보를 기반으로 후속 에러 처리 분기에 대한 결정을 내리기 위해이 공개 인터페이스에 의존해야합니다.\n\n네트워크 패키지에서 가져온 다른 예제를 통해 에러 동작 특성 검사 전략을 사용하여 에러 처리를 더 향상시켜보겠습니다.\n\n```js\n// $GOROOT/src/net/http/server.go\nfunc (srv *Server) Serve(l net.Listener) error {\n    ... ...\n    for {\n        rw, e := l.Accept()\n        if e != nil {\n            select {\n            case <-srv.getDoneChan():\n                return ErrServerClosed\n            default:\n            }\n            if ne, ok := e.(net.Error); ok && ne.Temporary() {\n                ... ...\n                time.Sleep(tempDelay)\n                continue\n            }\n            return e\n        }\n        ...\n    }\n    ... ...\n}\n```\n\n위의 코드 스니펫에서 Accept 메서드는 실제로 net 패키지 내의 사용자 지정 에러 유형 인 *OpError 유형의 에러를 반환합니다. OpError는 일반 에러 특성 인터페이스인 net.Error를 구현합니다. 아래 코드에서 확인할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n// $GOROOT/src/net/net.go\ntype OpError struct {\n    ... ...\n    // Err is the error that occurred during the operation.\n    Err error\n}\n\ntype temporary interface {\n    Temporary() bool\n}\n\nfunc (e *OpError) Temporary() bool {\n  if ne, ok := e.Err.(*os.SyscallError); ok {\n      t, ok := ne.Err.(temporary)\n      return ok && t.Temporary()\n  }\n  t, ok := e.Err.(temporary)\n  return ok && t.Temporary()\n}\n```\n\n실제로 OpError 인스턴스는 오류 처리기에 의해 검사될 수 있으며 네트.Error 인터페이스에서 제공되는 메서드를 사용하여, 해당 동작이 Temporary나 Timeout과 같은 특성과 일치하는지 여부를 결정할 수 있습니다.\n\n이를 통해 오류 처리기는 네트워크 관련 작업의 맥락에서 해당 오류의 특정 동작에 기반하여 신중한 결정을 내릴 수 있게 됩니다.\n\n요약.\n\n<div class=\"content-ad\"></div>\n\nGo 언어에서 통합된 오류 유형은 오류 인터페이스이며, 오류 값이 할당될 수 있는 빠르게 구성되는 오류 값 구성 함수인 errors.New, fmt.Errorf 등을 포함하여 다양한 함수가 제공됩니다.\n\n또한 통합된 오류 유형을 오류 유형으로 사용하는 장점에 대해 논의했습니다.\n\n이 개념을 깊이 있게 이해하는 것이 중요합니다.\n\n- 투명한 오류 처리 전략: 오류 유형을 통합하고 추가 오류 컨텍스트를 제공하지 않음으로써 오류 처리를 간단하게 만들어 대부분의 경우에 적합합니다.\n- 징표 오류 처리 전략: 상징적인 오류 값 세트를 정의함으로써 오류 처리기가 값 비교를 통해 오류 처리 경로를 선택할 수 있게 합니다.\n- 오류 값 유형 검사 전략: 오류 유형을 사용자 정의하고 더 많은 오류 컨텍스트를 제공함으로써 추가 오류 컨텍스트가 필요하고 오류 유형을 검사하기 위해 타입 단언 또는 타입 스위치를 사용하는 시나리오에 적합합니다.\n- 오류 동작 특성 검사 전략: 공개 인터페이스를 통해 오류 동작 특성을 정의함으로써 오류 처리기가 특정 유형이 아닌 오류 특성을 검사할 수 있게 하며, 오류 동작 특성이 중요한 시나리오에 적합합니다.\n\n<div class=\"content-ad\"></div>\n\n각 전략마다 장점과 사용 사례가 있습니다. 적절한 전략을 선택하는 것은 유지 보수성, 결합도, 코드 복잡성 및 오류 컨텍스트 요구사항과 같은 프로그래밍에서의 특정 요구사항과 고려사항에 따라 달라집니다.\n\n이러한 전략을 이해함으로써 오류를 더 잘 다루고 관리할 수 있으며, 코드 신뢰성과 유지 관리성을 향상시킬 수 있습니다.\n\n이야기가 마음에 드시고 제 지원을 원하신다면 클랩(clap) 눌러주세요.\n\n여러분의 지원은 제게 매우 중요합니다. 감사합니다.","ogImage":{"url":"/assets/img/2024-06-27-MasteringErrorHandlinginGolangBestPracticesandTips_0.png"},"coverImage":"/assets/img/2024-06-27-MasteringErrorHandlinginGolangBestPracticesandTips_0.png","tag":["Tech"],"readingTime":15},{"title":"클릭을 부르는 8가지 효과적인 CTA 디자인 팁","description":"","date":"2024-06-27 18:30","slug":"2024-06-27-CalltoAction8onvincingCTADesignTips","content":"\n\n디지턈 솔루션의 전환율을 극대화하기 위해 CTA(호출 행동 요소)가 무엇인지 알아보세요. \n\n웹 개발에서 CTA란 사용자가 특정 동작을 취하도록 유도하는 웹 페이지의 요소를 의미합니다. 이는 버튼, 링크 또는 등록, 뉴스레터 구독, 파일 다운로드, 구매 등과 같이 웹사이트와 상호 작용하도록 방문자를 유도하는 인터페이스 요소일 수 있습니다. 적절한 CTA 디자인이 없으면 귀하는 대다수의 관객에게 무시당할 위험이 있습니다. 따라서 저희의 글에서는 사용자들의 흥미를 끄는 CTA를 만들고 의도한 목적을 달성하는 방법에 대해 안내하겠습니다. \n\n![CTA 디자인 팁](/assets/img/2024-06-27-CalltoAction8onvincingCTADesignTips_0.png)\n\n# 매력적인 CTA 만드는 방법\n\n<div class=\"content-ad\"></div>\n\n당신의 웹사이트 방문자들의 관심을 끌고 전환율을 높일 CTA(Call to Action)를 만들 수 있는 여덟 가지 팁을 살펴보도록 합시다.\n\n## 1. 관심과 동기 파악하기\n\n대상 군의 관심과 동기를 이해하는 것은 효과적인 CTA를 만드는 기초입니다. 사용자들에게 중요한 것, 해결하고 싶은 문제, 목표 등을 연구합니다. 이러한 측면을 파악하면 사용자들의 요구와 욕구에 직접 대응하는 CTA를 만들 수 있습니다.\n\n![Image](/assets/img/2024-06-27-CalltoAction8onvincingCTADesignTips_1.png)\n\n<div class=\"content-ad\"></div>\n\n## 2. 좋은 UX 우선순위 설정\n\n좋은 사용자 경험(UX)을 우선시함은 CTA가 직관적이고 쉽게 접근 가능해야 함을 의미합니다. 당신의 목표는 웹사이트와의 상호작용을 가능한 한 편리하고 즐겁게 만드는 것입니다. 사용자가 필요한 정보를 쉽게 찾고 원하는 조치를 취할 수 있도록 내비게이션을 고려해주세요.\n\n![CTA Design Tips](/assets/img/2024-06-27-CalltoAction8onvincingCTADesignTips_2.png)\n\n## 3. UI 디자인 최적화\n\n<div class=\"content-ad\"></div>\n\nUI 디자인을 최적화하는 것은 사용자의 CTA를 콘텐츠의 나머지 부분과 구분 지을 수 있게 하는 데 중요합니다. 대조적인 색상, 두드러진 글꼴 및 CTA 주변의 충분한 공간을 활용하여 사용자의 관심을 끌어야 합니다. 잘 디자인된 UI는 사용자가 제안된 작업을 빨리 발견하고 수행할 수 있도록 도와줍니다.\n\n![이미지](/assets/img/2024-06-27-CalltoAction8onvincingCTADesignTips_3.png)\n\n## 4. 전략적 콘텐츠 및 CTA 배치\n\n콘텐츠와 CTA의 전략적 배치는 그 효과를 결정합니다. CTA를 시인성 있고 논리적인 위치에 배치하는 것이 중요합니다. 페이지의 시작과 끝, 긴 텍스트 중간, 중요 정보 옆 등에 CTA를 배치하여 사용자가 의도한 경로를 따라가도록 도와주세요.\n\n<div class=\"content-ad\"></div>\n\n\n![Call to Action Design Tips - Image 1](/assets/img/2024-06-27-CalltoAction8onvincingCTADesignTips_4.png)\n\n## 5. Designing effective CTAs\n\nCreating effective CTAs involves balancing attractive design with functionality. The button or element should be visible, but not overly intrusive. Use clear and understandable forms that are easy to understand and do not leave the user in doubt about their purpose.\n\n![Call to Action Design Tips - Image 2](/assets/img/2024-06-27-CalltoAction8onvincingCTADesignTips_5.png)\n\n\n<div class=\"content-ad\"></div>\n\n## 6. 사용자의 목표 강조\n\n사용자의 목표에 집중하면 유용하고 관련성 있는 CTA를 작성할 수 있습니다. 제품이나 서비스가 사용자의 문제를 해결하거나 삶을 개선하는 방법에 초점을 맞추세요. 호출부는 제안된 단계를 완료함으로써 사용자가 정확히 어떤 결과를 얻게 될지 보여주어야 합니다.\n\n![CTA Design Tips 6](/assets/img/2024-06-27-CalltoAction8onvincingCTADesignTips_6.png)\n\n## 7. 매력적인 텍스트 작성\n\n<div class=\"content-ad\"></div>\n\nCTA 복사본 작성에는 예술이 필요합니다. 텍스트는 간결하고 명확하며 행동을 촉발해야 합니다. 강렬한 동사와 긴급성 또는 혜택을 전달하는 언어를 사용하세요. 예: \"지금 구매\", \"할인 받기\", \"자세히 알아보기\".\n\n![](/assets/img/2024-06-27-CalltoAction8onvincingCTADesignTips_7.png)\n\n## 8. 감정에 호소\n\n감정적 충격은 마케터의 강력한 도구입니다. 사용자의 감정에 호소하여 CTA를 실행하세요: 기회를 놓치지 않을까 두려워하는 마음, 혜택을 누리고 싶어하는 욕망, 새로운 것을 소유하며 느끼는 기쁨. 감정적으로 충전된 CTA는 전환율을 크게 증가시킬 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-27-CalltoAction8onvincingCTADesignTips_8.png\" />\n\n# 아직 일이 끝나지 않았어요\n\n위의 모든 팁을 사용하여 CTA를 생성했다면, 이것은 작업의 일부일 뿐이며 아직 해야 할 중요한 단계가 남아 있습니다. 즉, 호출하여야 할 작업이 그 목적을 제공하는지 확인하는 것입니다. 이를 위해 A/B 테스트를 수행해야 합니다. 이렇게 하면 버튼 디자인이나 배치 변경이 전환율에 어떻게 영향을 주는지 이해할 수 있습니다. 최대 효과를 얻을 때까지 이러한 속성을 실험해보세요. 왜냐하면 가장 작은 수정도 더 나은 사용자 참여를 제공할 수 있기 때문입니다.\n\n# 고급 UX/UI 도구로 작업을 간편하게 만들어보세요\n\n<div class=\"content-ad\"></div>\n\nCTA를 만드는 모든 단계를 가능한 한 간단하게 만들기 위해 Flowmapp의 편리한 도구를 사용할 수 있어요. Wireframe Creator를 사용하면 웹 사이트 구조를 세밀하게 설계하고 CTA가 어떻게 보일지 전체 그림을 볼 수 있어요. 게다가 노력을 들이지 않고 쉽게 변경할 수 있는 좋은 방법이에요.\n\n또한 Flowmapp의 User Flow 도구를 사용하여 웹 사이트 방문부터 CTA와 상호 작용할 때까지 변환 퍼널을 구축할 수 있어요. 동시에 방문자가 마주치는 장애물을 추적하고 제거하여 사용자가 최대한 빠르고 쉽게 목표 동작을 완료할 수 있도록 돕을 수 있어요.\n\nCTA는 일반적인 웹 사이트 방문자를 활발한 사용자나 고객으로 전환하는 데 중요한 역할을 해요. 명확하고 설득력 있는 CTA가 없으면 방문자는 사이트에서 길을 잃거나 무슨 조치를 취해야 하는지 알 수 없어요. 효과적인 CTA는 사용자를 안내하여 사이트를 직관적이고 집중할 수 있는 방향으로 이동하게 만들어요. CTA를 만드는 작업을 간소화하고 싶다면 Flowmapp의 완전히 무료 UX/UI 디자인 도구를 사용할 수 있어요.","ogImage":{"url":"/assets/img/2024-06-27-CalltoAction8onvincingCTADesignTips_0.png"},"coverImage":"/assets/img/2024-06-27-CalltoAction8onvincingCTADesignTips_0.png","tag":["Tech"],"readingTime":4},{"title":"Flutter 앱에서 메모리 사용 최적화 방법 파트 1","description":"","date":"2024-06-27 18:29","slug":"2024-06-27-OptimizingMemoryUsageinFlutterAppsPart-1","content":"\n<img src=\"/assets/img/2024-06-27-OptimizingMemoryUsageinFlutterAppsPart-1_0.png\" />\n\n안녕하세요 Medium 독자 여러분, 오늘은 플러터 애플리케이션의 메모리 최적화에 대해 이야기하려고 합니다. 메모리 사용을 최적화하면 부드럽고 반응성 있는 앱을 보장하여 사용자 경험을 향상시킵니다.\n\n# 프로파일링 기술 (Flutter DevTools)\n\nFlutter DevTools의 메모리 탭을 사용하여 플러터 앱이 메모리를 실시간으로 어떻게 사용하는지 분석하세요. 이를 통해 메모리 사용에 대한 자세한 정보를 얻을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n메모리 그래프를 확인하여 메모리 사용 방식을 파악하고 문제가 발생하는 영역을 찾아보세요. 너무 많은 메모리 사용이나 누수를 나타내는 패턴을 찾아보세요. 또한 메모리 사용량이 급증하는 부분을 확인하여 어플리케이션의 어떤 부분이 이러한 현상을 유발하는지 파악해보세요. 빈번한 메모리 사용량 변동이 있다면 메모리가 효율적으로 사용되고 있지 않을 수 있습니다.\n\n# 메모리 최적화 기술\n\n기본적으로 메모리 최적화 기술에는 2가지 방법이 있습니다.\n\n## 풀링 및 객체 재사용으로 할당량 줄이기\n\n<div class=\"content-ad\"></div>\n\n객체 풀링(Object Pooling): 반복적으로 새로운 객체를 만드는 대신에 객체를 재사용합니다. 이는 메모리 사용량을 크게 줄이고 가비지 수집 작업을 줄일 수 있습니다.\n\n기본적인 객체 풀링의 예시를 살펴봅시다.\n\n```js\n// 예시: Worker 객체를 사용한 객체 풀링\n\nclass Worker {\n  int id;\n  Worker(this.id);\n\n  void doWork() {\n    print('Worker $id is doing work');\n  }\n}\n\nclass ObjectPool<T> {\n  final List<T> _available = [];\n  final List<T> _inUse = [];\n  int _counter = 0;\n\n  T getObject() {\n    if (_available.isEmpty) {\n      _available.add(_createObject());\n    }\n    final obj = _available.removeLast();\n    _inUse.add(obj);\n    return obj;\n  }\n\n  void releaseObject(T obj) {\n    _inUse.remove(obj);\n    _available.add(obj);\n  }\n\n  T _createObject() {\n    // 고유 ID를 가진 Worker 객체 생성\n    _counter++;\n    return Worker(_counter) as T;\n  }\n}\n\nvoid main() {\n  final workerPool = ObjectPool<Worker>();\n\n  // 풀에서 Worker를 가져와서 작업을 수행합니다\n  Worker worker1 = workerPool.getObject();\n  worker1.doWork();\n\n  // 다른 Worker를 풀에서 가져와서 작업을 수행합니다\n  Worker worker2 = workerPool.getObject();\n  worker2.doWork();\n\n  // 첫 번째 Worker를 풀에 반환합니다\n  workerPool.releaseObject(worker1);\n\n  // 풀에서 다른 Worker를 가져옵니다 (이전에 반환된 Worker를 재사용해야 합니다)\n  Worker worker3 = workerPool.getObject();\n  worker3.doWork();\n\n  // 나머지 Worker들을 풀에 반환합니다\n  workerPool.releaseObject(worker2);\n  workerPool.releaseObject(worker3);\n}\n```\n\nWorker 클래스에는 Worker가 일을 하는 상황을 알리는 메시지를 간단히 출력하는 doWork 메소드가 있습니다. Object Pool 클래스에서는 Worker 객체의 재사용을 관리하여 메모리 할당과 가비지 수집을 최소화합니다.\n\n<div class=\"content-ad\"></div>\n\n- Object Pool 클래스에는 두 개의 리스트인 \\_available(재사용 가능한 객체)와 \\_inUse(현재 사용 중인 객체)가 포함되어 있습니다.\n- \\_counter는 새로 생성된 Worker 객체에 고유 ID를 할당하는 데 도움을 줍니다.\n- getObject() 메서드는 풀에서 객체를 가져옵니다. 리스트가 비어 있다면 새로운 객체를 생성하고 \\_available에서 가져온 객체를 \\_inUse로 이동합니다.\n\nRelease object는 객체를 \\_inUse에서 가져와 \\_available로 다시 반환합니다.\n\n\\_createObject 메서드는 고유 ID가 있는 새 Worker 객체를 생성하고, 각 Worker가 고유 ID를 받을 수 있도록 \\_counter를 증가시킵니다.\n\n이제 main 함수인 void main()으로 넘어가 봅시다.\n\n<div class=\"content-ad\"></div>\n\n우선 Worker 객체를 위한 ObjectPool을 생성합니다.\n\n```js\nvoid main() {\n  final workerPool = ObjectPool<Worker>();\n```\n\n풀에서 Worker를 가져와 작업을 수행합니다.\n\n```js\n// 풀에서 Worker를 가져와 작업을 수행합니다\nWorker worker1 = workerPool.getObject();\nworker1.doWork();\n```\n\n<div class=\"content-ad\"></div>\n\n위 코드에서 getObject 메서드는 기존 Worker를 재사용하거나 새로운 Worker를 생성한 후에 Worker의 doWork 메서드를 호출합니다.\n\n다음으로 풀에서 또 다른 Worker를 가져와 작업을 수행합니다.\n\n```js\n  // 풀에서 또 다른 Worker를 가져와 작업 수행\n  Worker worker2 = workerPool.getObject();\n  worker2.doWork();\n```\n\n첫 번째 Worker를 풀로 반납하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\n// 첫 번째 워커를 풀에 반환합니다\nworkerPool.releaseObject(worker1);\n```\n\n이제 풀에서 다른 워커를 가져옵니다. 여기서 워커는 다시 사용되어야 합니다 (이 경우 worker1).\n\n```js\n  // 풀에서 다른 워커를 가져옵니다 (반환된 워커를 재사용해야 함)\n  Worker worker3 = workerPool.getObject();\n  worker3.doWork();\n```\n\n나머지 워커들을 풀에 반납합니다\n\n<div class=\"content-ad\"></div>\n\n워커 객체가 모두 풀로 반환되도록 보장합니다.\n\n```js\n// 나머지 워커를 풀로 반환합니다\nworkerPool.releaseObject(worker2);\nworkerPool.releaseObject(worker3);\n}\n```\n\n# 요약 :\n\n- 객체 풀링은 객체를 반복적으로 생성하고 파괴하는 대신 재사용하는 디자인 패턴입니다.\n- 이점: 메모리 할당 오버헤드를 줄이고 가비지 컬렉션을 최소화합니다.\n\n<div class=\"content-ad\"></div>\n\n# 결론:\n\n이번에는 Dart에서 객체 풀링에 대해 논의했습니다. 이는 빈번한 생성과 소멸 대신 객체를 재사용하는 데 도움이 됩니다. 이 기사의 다음 부분에서 메모리를 더 최적화하는 방법을 더 알아볼 수 있습니다. Dart 패드에서 코드를 자유롭게 테스트해보세요.\n\n이 기사를 즐겁게 읽으셨길 바랍니다!\n\n만약 이 기사가 도움이 되었다면 👏를 눌러주세요.\n\n<div class=\"content-ad\"></div>\n\n안녕히 가세요!\n","ogImage":{"url":"/assets/img/2024-06-27-OptimizingMemoryUsageinFlutterAppsPart-1_0.png"},"coverImage":"/assets/img/2024-06-27-OptimizingMemoryUsageinFlutterAppsPart-1_0.png","tag":["Tech"],"readingTime":4},{"title":"Flutter 개발 초보자를 위한 Bare Bones Flutter 사용법","description":"","date":"2024-06-27 18:27","slug":"2024-06-27-JumpstartYourFlutterDevelopmentwithBareBonesFlutter","content":"\n\n<img src=\"/assets/img/2024-06-27-JumpstartYourFlutterDevelopmentwithBareBonesFlutter_0.png\" />\n\n휴대폰 앱 개발의 바쁜 세계에서는 효율성과 속도가 가장 중요합니다. 마음대로 확장 가능하고 유지보수 가능한 코드베이스를 지향하는 경우에는 Flutter 프로젝트를 처음부터 시작하는 데 시간이 많이 걸릴 수 있습니다. 이때 Bare Bones Flutter가 출동합니다. 바닥에서 뛰어오르는 번거로움 없이 시작하고자 하는 Flutter 개발자들을 위해 만들어진 종합적인 템플릿입니다.\n\n# Bare Bones Flutter란 무엇인가요?\n\nBare Bones Flutter는 Flutter 개발자를 위해 특별히 설계된 템플릿 프로젝트입니다. 안정성을 보장하고 개발 프로세스를 가속화하기 위한 견고한 기반을 제공하여 출발점으로서 역할합니다. 단일 또는 복잡한 다수의 기능을 가진 앱을 작성하는 경우, Bare Bones Flutter는 빠르게 시작할 수 있도록 필요한 도구와 구조를 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n# 왜 Bare Bones Flutter를 선택해야 하는가?\n\nBare Bones Flutter 템플릿은 앱의 아키텍처와 로직에 중점을 두고 있습니다. 사용자 인터페이스가 아닌 것이죠. 이것은 고의적인 선택입니다. 템플릿을 간단하게 유지하고 핵심 기능에 집중함으로써, 개발자가 프로젝트를 자신의 특정한 요구사항과 선호도에 쉽게 적응할 수 있도록 보장합니다. 이 유연성은 사용자 지정 UI 구성 요소나 추가 기능을 프로젝트에 업데이트하고자 하는 개발자에게 중요합니다. Bare Bones Flutter 템플릿은 간단하면서도 견고한 기반을 제공하여 필요에 따라 기능을 쉽게 추가하거나 제거할 수 있도록 합니다.\n\n# 주요 기능\n\n## 로컬라이제이션\n\n<div class=\"content-ad\"></div>\n\n글로벌 도달은 현대 애플리케이션의 중요한 측면입니다. Bare Bones Flutter는 다국어(EN, TR)를 지원하여 다양한 대상에 맞게 쉽게 제작할 수 있습니다. 템플릿에는 로컬라이제이션 파일이 포함되어 있어 앱이 전 세계 사용자와 효과적으로 소통할 수 있습니다. MakeFile을 사용하여 더 많은 언어를 쉽게 만들 수 있습니다:\n\n```js\nmake -f Makefile localization\n```\n\n## MVVM 아키텍처\n\n유지보수성은 소프트웨어 개발에서 중요한 고려 사항입니다. Bare Bones Flutter는 Model-View-ViewModel (MVVM) 아키텍처를 채택하여 코드베이스가 깔끔하고 조직적이 되도록 지원합니다. 이 아키텍처는 그래픽 사용자 인터페이스의 개발을 비즈니스 논리 또는 백엔드 논리(모델)와 분리하여 코드를 더 효과적이고 확장 가능하게 만듭니다.\n\n<div class=\"content-ad\"></div>\n\n## 인증 페이지\n\n사용자 인증은 대부분의 앱에서 핵심 기능입니다. 이 템플릿에는 미리 구축된 로그인 및 가입 페이지가 포함되어 있습니다. 텍스트 폼 필드에는 정규 표현식을 사용하여 유효성이 검증됩니다. 이 설정은 개발 시간을 절약할 뿐만 아니라 사용자 입력이 올바르게 서식이 지정되고 안전한지를 보장합니다.\n\n## 내비게이션\n\n원활한 사용자 경험을 위해서 효율적인 내비게이션은 필수적입니다. Bare Bones Flutter는 직관적인 내비게이션을 위해 go_router와 중첩 라우팅을 위해 shell_route를 활용합니다. 이 설정은 앱의 다른 부분 간 이동이 원할하고 직관적임을 보장합니다.\n\n<div class=\"content-ad\"></div>\n\n## Firebase 통합 (firebase-riverpod 브랜치)\n\nFirebase를 애플리케이션에 통합하려는 개발자를 위해, Bare Bones Flutter는 firebase-riverpod 브랜치라는 전용 브랜치를 제공합니다. 이 브랜치는 Firebase 통합을 추가하여 기능적으로 Sign In, Sign Out 및 Sign Up 기능을 갖춘 기본 템플릿을 바탕으로 구축됩니다. 또한 앱 상태를 깔끔하고 반응적으로 처리하기 위한 강력한 해결책인 상태 관리를 위해 Riverpod를 도입하고 있습니다.\n\n## 브랜치 개요\n\nBare Bones Flutter는 주로 두 가지 브랜치로 구성되어 있습니다:\n\n<div class=\"content-ad\"></div>\n\n## 메인\n\n이 템플릿에는 상태 관리나 ViewModel 없이 견고한 기반을 제공하는 주요 기능이 포함되어 있습니다. 사용자 정의 기능과 상태 관리 솔루션을 추가하고자 하는 개발자들에게 이상적입니다.\n\n## firebase-riverpod\n\n이 템플릿은 사용자 인증을 위해 Firebase를 통합하고 상태 관리를 위해 Riverpod를 통합하여 메인 템플릿을 확장합니다. 인증 및 상태 관리에 대한 사용 준비 완료 솔루션이 필요한 개발자들에게 완벽합니다.\n\n<div class=\"content-ad\"></div>\n\n# 일반 프로젝트 구조\n\n프로젝트의 디렉토리 레이아웃에 대한 간단한 개요입니다 (다음 웹사이트에서 생성됨: https://ascii-tree-generator.com/):\n\n```js\nlib/\n├─ core/\n│  ├─ constants/\n│  ├─ design_system/\n│  ├─ di/\n│  ├─ init/\n├─ data/\n│  ├─ di_repository/\n│  ├─ repository/\n├─ domain/\n│  ├─ di_usecase/\n│  ├─ model/\n│  ├─ usecase/\n├─ features/\n│  ├─ auth/\n│  ├─ dashboard/\n│  ├─ navigation/\n│  ├─ profile/\n│  ├─ search/\n├─ l10n/\n│  ├─ en.arb\n│  ├─ tr.arb\n├─ main.dart\n```\n\n## Core\n\n<div class=\"content-ad\"></div>\n\n코어 디렉토리에는 상수, 디자인 시스템, 의존성 주입(di) 및 초기화 코드와 같은 핵심 기능이 포함되어 있습니다.\n\n## 데이터\n\n데이터 레이어는 데이터 검색 및 저장을 처리하며, 리포지터리 구현 및 리포지터리를 위한 의존성 주입을 포함합니다.\n\n## 도메인\n\n<div class=\"content-ad\"></div>\n\n도메인 레이어는 모델과 사용 사례를 포함한 비즈니스 로직을 정의합니다. 핵심 로직을 다른 레이어로부터 분리하여 깔끔한 아키텍처를 유지합니다.\n\n## 기능\n\n앱의 각 기능은 해당 디렉토리로 구성되어 있어 인증, 네비게이션, 사용자 프로필과 같은 특정 기능을 쉽게 찾아보고 관리할 수 있습니다.\n\n## 지역화\n\n<div class=\"content-ad\"></div>\n\n로컬라이제이션 디렉터리에는 앱의 손쉬운 지역화 및 국제화를 가능하게 하는 다양한 언어용 .arb 파일이 포함되어 있습니다.\n\n## Makefile\n\n작업 관리를 간소화하기 위해 Bare Bones Flutter에는 Makefile이 포함되어 있습니다. 이 파일에는 로컬라이제이션 파일 생성 및 프로젝트 정리와 같은 일반적인 작업에 대한 명령이 포함되어 있습니다.\n\n![이미지](/assets/img/2024-06-27-JumpstartYourFlutterDevelopmentwithBareBonesFlutter_1.png)\n\n<div class=\"content-ad\"></div>\n\n이제 다 읽으셨습니다. 궁금한 점이 있으면 댓글로 질문해 주세요. 또한, 제 어플리케이션들을 여기서 한번 둘러보세요. 프로젝트 링크는 여기 있습니다. 이 튜토리얼 영상을 보는 것을 추천합니다.\n\n읽어 주셔서 감사합니다! 계속해서 찾아와주세요!","ogImage":{"url":"/assets/img/2024-06-27-JumpstartYourFlutterDevelopmentwithBareBonesFlutter_0.png"},"coverImage":"/assets/img/2024-06-27-JumpstartYourFlutterDevelopmentwithBareBonesFlutter_0.png","tag":["Tech"],"readingTime":4},{"title":"자바스크립트 실행 컨텍스트 심층 탐구","description":"","date":"2024-06-23 15:14","slug":"2024-06-23-In-DepthExplorationofJavaScriptExecutionContext","content":"\n\n자바스크립트 초심자든 전문가든, 면접이건 일상적인 개발 작업이건, 우리는 종종 다음과 같은 상황을 맞닥뜨립니다: 몇 줄의 코드가 주어졌을 때, 그들이 무엇을 출력하며 어떤 순서로 실행되는지 알아야 합니다. 🧑‍💻 자바스크립트는 싱글 스레드 언어이기 때문에 우리는 다음 결론을 내릴 수 있습니다:\n\n자바스크립트는 문장을 나타난 순서대로 실행합니다. 📜\n\n이 시점에서, \"나는 JS가 한 줄씩 실행된다는 것을 알아, 왜 강조하는 거지?\"라고 하실 수 있습니다. 🤔 우리는 JS가 한 줄씩 실행된다고 가정하기 때문에 이런 식으로 모든 JS가 동작한다고 가정합니다.\n\n```js\nlet a = '1';\nconsole.log(a);\n\nlet b = '2';\nconsole.log(b);\n```\n\n<div class=\"content-ad\"></div>\n\n하지만 실제로 JavaScript는 다음과 같이 실행됩니다:\n\n```js\nsetTimeout(function(){\n  console.log('Timer started')\n});\nnew Promise(function(resolve){\n  console.log('For loop is about to be executed');\n  for(var i = 0; i < 10000; i++){\n    i == 99 && resolve();\n  }\n}).then(function(){\n  console.log('Execute then function')\n});\nconsole.log('Code execution ends');\n```\n\nJavaScript가 문장을 순서대로 실행한다는 개념을 따라, 예상 출력을 자신 있게 적었습니다:\n\n1. 타이머 시작. ⏱️\n2. for 루프가 실행됩니다. 🔄\n3. then 함수를 실행합니다. ➡️\n4. 코드 실행 종료. 🛑\n\n<div class=\"content-ad\"></div>\n\n그러나 Chrome에서 확인했을 때 결과가 완전히 잘못되어 순간적으로 혼란스러웠어요. 😕 예상대로 줄 단위로 실행되어야 하는 것이 아니었나요? 🤨\n\n이 혼란을 해소하기 위해 JavaScript의 실행 메커니즘을 완전히 이해해야 합니다.\n\n# JavaScript에 대해\n\nJavaScript는 단일 스레드 언어입니다. 🧵 최신 HTML5에서 Web Workers가 소개되었지만, JavaScript의 단일 스레드 코어는 변하지 않았습니다. 따라서 JavaScript의 모든 \"다중 스레딩\"은 단일 스레드를 사용하여 모의되며, 모든 다중 스레딩은 속임수입니다!\n\n<div class=\"content-ad\"></div>\n\n# 자바스크립트 이벤트 루프\n\n자바스크립트는 한 번에 하나의 작업만 처리하기 때문에, 한 창만 있는 은행과 같아요; 고객들은 차례로 업무를 처리하기 위해 줄을 서야 합니다. 🏦 마찬가지로, 자바스크립트 작업들은 하나씩 실행되어야 해요. 만약 어떤 작업이 너무 오래 걸린다면, 다음 작업은 기다려야 해요.\n\n그래서 질문이 생깁니다: 우리가 뉴스를 보려고 하는데, 뉴스에 있는 고화질 사진들이 느리게 로드된다면, 사진이 완전히 표시될 때까지 웹 페이지가 멈춰 있어야 할까요?\n\n똑똑한 프로그래머들은 이 문제를 두 가지 범주로 작업을 나누어 해결합니다:\n\n<div class=\"content-ad\"></div>\n\n1. 동기 작업 🕒 \n2. 비동기 작업 ⏩\n\n웹사이트를 열 때, 렌더링 프로세스는 페이지 골격과 요소를 렌더링하는 등 많은 동기 작업으로 구성됩니다. 🖥️ 사진이나 음악 파일과 같이 많은 리소스를 사용하고 오랜 시간이 걸리는 작업들은 비동기 작업입니다.\n\n더 쉽게 이해하기 위해 마인드 맵을 사용하여 설명하겠습니다:\n\n![마인드 맵](/assets/img/2024-06-23-In-DepthExplorationofJavaScriptExecutionContext_0.png)\n\n<div class=\"content-ad\"></div>\n\n마음의 맵 콘텐츠를 설명하는 단어를 사용하면:\n\n1. 동기 작업과 비동기 작업은 서로 다른 실행 \"장소\"로 들어갑니다. 🕒⏩\n2. 동기 작업은 주 스레드로 들어가고, 비동기 작업은 이벤트 테이블에 들어가서 함수를 등록합니다. 🧵📋\n3. 지정된 작업이 완료되면, 이벤트 테이블은 이 함수를 이벤트 큐로 이동시킵니다. 📤\n4. 주 스레드의 작업이 실행되고 나면, 해당 함수는 이벤트 큐에서 읽혀 주 스레드에서 실행됩니다. 🔄\n5. 이 프로세스는 계속해서 반복되며, 이를 이벤트 루프라고 합니다. 🔁\n\n여러분은 아마 궁금해 할지도 모릅니다. 주 스레드 실행 스택이 비어있는지 어떻게 알 수 있을까요? 🤔 자바스크립트 엔진은 주 스레드 실행 스택이 비어있는지 계속 확인하는 모니터링 프로세스가 있습니다. 한 번 비어지면, 이벤트 큐로 이동하여 호출을 기다리는 함수가 있는지 확인할 것입니다.\n\n위 설명 이후에, 코드 한 줄이 더 직관적일지 모릅니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nlet data = [];\n$.ajax({\n  url: 'www.javascript.com',\n  data: data,\n  success: () => {\n    console.log('Send successful');\n  }\n})\nconsole.log('Code execution completed');\n```\n\n여기에 간단한 AJAX 요청 코드 예시가 있어요:\n\n1. AJAX가 이벤트 테이블에 들어가며 콜백 함수 success를 등록해. 📋\n2. console.log(`Code execution ended`)를 실행해. 🖨️\n3. AJAX 이벤트가 완료되고 콜백 함수 success가 이벤트 대기열에 들어갔어. 📤\n4. 메인 스레드가 이벤트 대기열에서 콜백 함수 success를 읽고 실행해. 🔄\n\n위의 텍스트와 코드를 통해 JavaScript의 실행 순서에 대해 간단히 이해했을 거라고 믿어.\n\n<div class=\"content-ad\"></div>\n\n🧑‍💻 다음으로, 고급 주제인 setTimeout을 공부해 봅시다.\n\n# setTimeout에 대한 사랑과 미움\n\n우리가 모두 알다시피, setTimeout에 대해 자세한 소개는 필요하지 않습니다. ⏳ 우리의 첫인상은 지연 후 비동기적으로 실행될 수 있다는 것입니다. 우리는 종종 3초 지연 실행을 구현하기 위해 사용합니다:\n\n```js\nsetTimeout(() => {\n  task();\n}, 3000);\nconsole.log('콘솔 실행');\n```\n\n<div class=\"content-ad\"></div>\n\n그러나 setTimeout을 계속 사용할수록 문제가 발생합니다. 때로는 코드에서 3초의 지연을 지정해도 함수가 5 또는 6초 이후에 실행되기도 합니다. 🤯 그 이유가 무엇일까요? 🤔\n\n예시를 살펴봅시다:\n\n```js\nsetTimeout(() => {\n    task();\n}, 3000)\nconsole.log('콘솔 실행');\n```\n\n이전 결론에 따르면, setTimeout은 비동기적이므로 동기 작업인 console.log이 먼저 실행되어야 합니다. 따라서 우리의 결론은 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n- 콘솔 실행\n- task()\n\n확인해보세요. 결과가 맞다면 지난 코드를 수정해봅시다:\n\n```js\nsetTimeout(() => {\n    task();\n}, 3000)\nsleep(10000000)\n```\n\n처음에는 비슷해 보이지만, 이 코드를 Chrome에서 실행하면 콘솔 실행 시간이 3초보다 훨씬 길다는 것을 알 수 있습니다. 왜 이제 시간이 오래 걸릴까요?\n\n<div class=\"content-ad\"></div>\n\n지금 선언해야 하는 것은 setTimeout을 재정의하는 것입니다. 위의 코드의 실행 프로세스를 논의해 봅시다:\n\n- task()가 이벤트 테이블에 등록되어 타이밍이 시작됩니다.\n- sleep 함수를 아주 천천히 실행하고 타이밍이 계속됩니다.\n- 3초 후에 타임아웃 이벤트가 완료됩니다. task()가 이벤트 큐에 입력됩니다. 그러나 sleep 함수는 아직 완료되지 않아서 대기해야 합니다.\n- 마지막으로 sleep 함수가 실행되고 task()가 마침내 이벤트 큐에서 메인 스레드로 이동되어 실행됩니다.\n\n위의 과정을 거친 후, setTimeout 함수는 지정된 시간이 지난 후 작업(이 경우 task())을 이벤트 큐에 추가함을 이해할 수 있습니다. 작업은 단일 스레드 환경에서 하나씩 실행되기 때문에, 이전 작업이 실행하는 데 너무 오래 걸리면 실행 시간이 3초를 크게 초과할 수 있습니다.\n\n우리는 종종 setTimeout(fn, 0)와 같은 코드를 볼 수 있습니다. \"0초 후 실행\"이란 무엇을 의미하는 걸까요? 즉시 실행될 수 있을까요?\n\n<div class=\"content-ad\"></div>\n\n답변은 아니요. setTimeout(fn, 0)은 주 스레드의 가장 빠른 유휴 시간에 실행할 작업을 지정하는 것을 의미합니다. 추가적인 초를 기다리지 않고 호출되며, 모든 동기 작업이 완료되고 스택이 비어있는 상태가 되었을 때 실행됩니다. 예를 들어:\n\n```js\n// 코드 1\nconsole.log('이 부분은 먼저 실행됩니다');\nsetTimeout(() => {\n  console.log('실행됨')\n}, 0);\n\n// 코드 2\nconsole.log('이 부분은 먼저 실행됩니다');\nsetTimeout(() => {\n  console.log('실행됨')\n}, 3000);\n```\n\n코드 1의 출력 결과는:\n\n- 이 부분은 먼저 실행됩니다\n- 실행됨\n\n<div class=\"content-ad\"></div>\n\n코드 2의 출력은:\n\n- 먼저 여기에서 실행\n- ... 3초 후\n- 실행됨\n\nsetTimeout에 대해 주목해야 할 점은 주 스레드가 유휴 상태라도 0밀리초까지 달성할 수 없다는 것입니다. HTML 표준에 따르면 최소 값은 4밀리초입니다. 관심 있는 학생들은 스스로 탐구해 볼 수 있습니다.\n\n# 쌍둥이 동생 setInterval\n\n<div class=\"content-ad\"></div>\n\nsetTimeout에 관해서 이야기할 때는, 그 둘둥이 형제 setInterval을 빠트릴 수 없어요. ⏳🔁 이 둘은 매우 비슷하지만, 후자는 루프에서 실행됩니다. 실행 순서 측면에서, setInterval로 등록된 함수는 각 지정된 간격마다 이벤트 큐에 넣을 거예요. 이전 작업이 너무 오래 걸린 경우에도 기다려야 해요. ⏱️\n\n유의할 점은 setInterval(fn, ms)의 경우, fn이 ms초마다 실행되는 것이 아니라, fn의 새 인스턴스가 ms초 간격으로 이벤트 큐에 들어간다는 것이에요. 📤 만약 setInterval의 콜백 함수 fn이 지연 시간 ms보다 오래 걸린다면, 명백한 시간 간격이 없을 거예요. 이 문장을 신중하게 생각해보세요.\n\n# Promises와 process.nextTick(callback)\n\n이제 전통적인 타이머를 살펴본 후에, Promise와 process.nextTick(callback)의 동작을 알아보겠어요.\n\n<div class=\"content-ad\"></div>\n\n이 글에서는 Promise의 정의와 기능을 자세히 다루지 않을 것입니다. process.nextTick(callback)은 Node.js에서 \"setTimeout\"와 유사하며, 콜백 함수를 다음 라운드의 이벤트 루프에서 호출합니다.\n\n이해를 돕기 위해 바로 요점에 들어가보겠습니다. 동기적 및 비동기적 작업의 일반적인 정의 외에도 작업에 대한 더 구체적인 정의가 있습니다:\n\n- 🕰️ Macro-task(매크로 작업): 전체 코드, setTimeout, setInterval을 포함합니다.\n- 🎯 Micro-task(마이크로 작업): Promise, process.nextTick을 포함합니다.\n\n다른 유형의 작업은 해당하는 이벤트 큐에 들어가게 됩니다. 예를 들어, setTimeout과 setInterval은 동일한 이벤트 큐에 들어갑니다.\n\n<div class=\"content-ad\"></div>\n\n이벤트 루프의 순서는 JavaScript 코드가 실행되는 순서를 결정합니다. 전체 코드(매크로태스크)를 입력한 후 첫 번째 루프를 시작합니다. 그런 다음 모든 마이크로태스크를 실행합니다. 다음으로, 매크로태스크에서 시작하여 태스크 큐가 완료될 때까지 다시 시작하고, 다시 모든 마이크로태스크를 실행합니다. 약간 복잡해 보일 수 있지만, 지금 이 기사에서 한 코드 스니펫을 사용하여 설명해보겠습니다:\n\n```js\nsetTimeout(function() {\n    console.log('setTimeout');\n})\n\nnew Promise(function(resolve) {\n    console.log('promise');\n}).then(function() {\n    console.log('then');\n})\n\nconsole.log('console');\n```\n\n- 🔄 이 코드는 매크로태스크로 주 스레드로 들어갑니다.\n- setTimeout을 만나면 해당 콜백 함수가 등록되어 매크로태스크 이벤트 큐로 전달됩니다.\n- 그 다음 Promise를 만나면 즉시 새 Promise가 실행되고 then 함수가 마이크로태스크 이벤트 큐로 전달됩니다.\n- console.log()을 만나면 즉시 실행됩니다.\n- 매크로태스크로 전체 코드를 실행한 후, 어떤 마이크로태스크가 있는지 살펴봅니다. 마이크로태스크 이벤트 큐에서 then을 찾아 실행합니다.\n- 첫 번째 이벤트 루프가 끝났습니다. 이제 매크로태스크 이벤트 큐에서 두 번째 라운드를 시작합니다. 이 큐에서 setTimeout에 해당하는 콜백 함수가 바로 실행됩니다.\n- ✅ 실행 완료.\n\n이벤트 루프, 매크로태스크 및 마이크로태스크 사이의 관계는 다음 그림에 나와 있습니다:\n\n<div class=\"content-ad\"></div>\n\n\n![Exploration of JavaScript ExecutionContext](/assets/img/2024-06-23-In-DepthExplorationofJavaScriptExecutionContext_1.png)\n\n# 요약\n\n🔄 JavaScript 비동기성: JavaScript는 단일 스레드 언어로 동작합니다. 비동기성을 달성하기 위한 새로운 프레임워크와 구문이 있지만, 기본적으로 동기적 방법을 사용합니다. 이 단일 스레드 특성을 이해하는 것이 중요합니다.\n\n🌀 이벤트 루프: 이벤트 루프는 JavaScript의 비동기 작업을 처리하고 실행 흐름을 관리하는 메커니즘입니다.\n\n\n<div class=\"content-ad\"></div>\n\n🖥️ JavaScript 실행과 실행 방법: JavaScript의 실행은 Node.js, 브라우저 및 기타 환경(예: Ringo)에서 다양하게 이뤄집니다. 반면 \"실행\"이라는 용어는 일반적으로 JavaScript 파싱 엔진의 일관된 동작을 나타냅니다.\n\n⏰ setImmediate: 마이크로태스크 및 매크로태스크와 함께, setImmediate는 비동기 작업의 한 유형입니다. 그들은 예약 및 실행 방법에 대해 일반적인 특성을 공유합니다.","ogImage":{"url":"/assets/img/2024-06-23-In-DepthExplorationofJavaScriptExecutionContext_0.png"},"coverImage":"/assets/img/2024-06-23-In-DepthExplorationofJavaScriptExecutionContext_0.png","tag":["Tech"],"readingTime":8},{"title":"버그 바운티에서 꼭 테스트해야 하는 404 Not Found 오류","description":"","date":"2024-06-23 15:13","slug":"2024-06-23-ALWAYStest404NotFoundinBugBounties","content":"\n\n안녕하세요 여러분, 오늘은 항상 \"/\" 디렉토리가 없는 웹 사이트를 테스트해야 하는 이유와 다른 많은 버그 바운티 헌터들이 놓치고 있는 것을 보여드리고 싶습니다.\n\n솔직히 말해서, 버그 바운티 헌팅은 피곤할 수 있습니다, 특히 풀타임으로 취약점 테스터/웹 개발자 등으로 일하고 있는 경우 더욱 그렇습니다. 주로 야간에만 테스트할 수 있으며 이는 유연성이 없는 상황을 만듭니다 - 취약점을 빨리 찾아야 합니다(우리는 모두 중복을 싫어합니다) 그리고 실력이 있어야 합니다.\n\n그러나 최근에 중요/높음 수준의 취약점을 찾기 위해 노력 중인 많은 헌터들이 아래와 같이 보이는 웹 사이트에 관심을 덜어 주는 것을 알아냈습니다:\n\n<img src=\"/assets/img/2024-06-23-ALWAYStest404NotFoundinBugBounties_0.png\" />\n\n<div class=\"content-ad\"></div>\n\n다음 속담이 딱 맞아요:\n\n많은 Hunter들은 그런 웹사이트(내용이 없는 것처럼 보이는)를 빨리 떠날 거에요. 그러나 / 디렉토리에 내용이 없다고 해서 전혀 내용이 없는 것은 아닙니다.\n\n## 예시 1:\n\n와일드카드 서브도메인 Scope (*.example.com)에서 버그 바운티 헌팅을 할 때, 서브도메인 열거를 위해 평소처럼 도구를 이용하다가 어느 순간 404 Not Found를 반환하는 서브도메인에 걸립니다. 익명화를 위해 예시 서브도메인으로 example1.example.com을 사용해봅시다.\n\n<div class=\"content-ad\"></div>\n\n그 웹 사이트를 식별한 후 - `단계 1은 컨텐츠 발견을 시작하는 것입니다. 저는 dirsearch 툴과 제 자체 워드리스트를 사용하여 이 작업을 수행합니다:\n\n[https://github.com/ViktorMares/ultimate_discovery](https://github.com/ViktorMares/ultimate_discovery)\n\n따라서, 다음 명령을 사용하여 컨텐츠 발견을 시작합니다:\n\n<div class=\"content-ad\"></div>\n\n그리고 결과는 다음과 같습니다:\n\n![이미지](/assets/img/2024-06-23-ALWAYStest404NotFoundinBugBounties_2.png)\n\n따라서 404 Not Found에서 몇 개의 정적 페이지를 볼 수 있습니다.\n\n우리는 하나씩 각 정적 페이지로 이동하여 소스 코드에서 다음 부분을 찾을 수 있습니다\n\n<div class=\"content-ad\"></div>\n\n\n![Image](/assets/img/2024-06-23-ALWAYStest404NotFoundinBugBounties_3.png)\n\nWith the AWS Access Key and Secret Key, we may gain access to S3 buckets and the AWS infrastructure.\n\nTo verify the validity of the AWS secrets, you can use the repository below:\n\nTry using the AWS Access Key and Secret Key values and run the tool.\n\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-23-ALWAYStest404NotFoundinBugBounties_4.png)\n\n위에서 볼 수 있듯이, AWS IAM 자격 증명을 발견했습니다. 사용자는 API에 액세스할 수도 있지만, 증명 목적으로 위 이미지만 표시했습니다.\n\n그래서 우리는 이 취약점을 상세하게 보고하고 다음과 같은 응답을 받았습니다:\n\n![이미지](/assets/img/2024-06-23-ALWAYStest404NotFoundinBugBounties_5.png)\n\n<div class=\"content-ad\"></div>\n\n# 예제 2:\n\n다시 한 번 서브도메인 (와일드카드 범위)을 찾기 시작하면 / 디렉토리 뒤에 아무 것도 없는 또 다른 웹 사이트 (example2.example.com)를 발견합니다.\n\n![image](/assets/img/2024-06-23-ALWAYStest404NotFoundinBugBounties_6.png)\n\n우리는 사용자 정의 워드리스트로 dirsearch 명령어를 실행하고 /sites 웹 페이지 - `https://example2.example.com/sites` 를 찾았으며 결과는 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n\n![Image](/assets/img/2024-06-23-ALWAYStest404NotFoundinBugBounties_7.png)\n\n이 HTML 내용을 보면 정적 사이트를 불러오기 위해 ?SiteID 매개변수를 사용할 수 있다는 것을 보여줍니다. 그러나 SiteID 매개변수는 Reflected Cross-Site Scripting에 취약합니다. 거기에는 매개변수의 길이가 제한되어 있어서 가능한 가장 짧은 XSS Payload를 사용해야 합니다. 즉, `svg/onload=alert()`\n\n![Image](/assets/img/2024-06-23-ALWAYStest404NotFoundinBugBounties_8.png)\n\n한번 더 발견을 보고하자, 폭발!\n\n\n<div class=\"content-ad\"></div>\n\n![image](/assets/img/2024-06-23-ALWAYStest404NotFoundinBugBounties_9.png)\n\n이 방법론이 흥미로웠으면 좋겠고, 당신은 어떤 웹사이트도 건드리지 않고 지나치지 않기를 바랍니다. 향후 업무와 버그 바운티에서 도움이 될 수 있기를 바랍니다!\n\n이야기를 읽어주셔서 감사합니다. 정말 즐거우셨다면, 제 프로젝트를 지원해주시려면 아래 링크를 통해 아피리에이트 매체 멤버십을 받아보시기 바랍니다: https://medium.com/@mares.viktor/membership\n\n행운을 빕니다!","ogImage":{"url":"/assets/img/2024-06-23-ALWAYStest404NotFoundinBugBounties_0.png"},"coverImage":"/assets/img/2024-06-23-ALWAYStest404NotFoundinBugBounties_0.png","tag":["Tech"],"readingTime":3}],"page":"2","totalPageCount":29,"totalPageGroupCount":2,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}