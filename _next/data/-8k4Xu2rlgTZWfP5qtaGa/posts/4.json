{"pageProps":{"posts":[{"title":"Flutter에서 간단한 BottomAppBar 만들기","description":"","date":"2024-06-21 22:49","slug":"2024-06-21-ASimpleBottomAppBarinFlutter","content":"\n\n현재 작업 중인 프로젝트에서 — 곧 공유할 예정이에요, BottomNavigationBar를 포함해야 했어요. 하지만 단순한 하단 네비게이션 바가 아니라, 약간은 멋지고 세련된 모습으로 구현하고 싶었어요.\n\n![BottomNavigationBar](/assets/img/2024-06-21-ASimpleBottomAppBarinFlutter_0.png)\n\nBottomNavigationBar는 하단에 작은 위젯들(아이콘 또는 레이블)을 나란히 표시할 수 있는 위젯이에요. 이를 통해 한 번에 하나의 항목을 선택하고 해당 페이지/UI로 빠르게 이동할 수 있어요. 하단 네비게이션 바에는 2~5개의 항목을 넣는 것이 권장되고요. 그 이상의 경우에는 네비게이션 드로어나 탭을 사용하는 것이 더 좋아요.\n\n구현\nFlutter에서 하단 네비게이션 바를 사용하려면 build 메서드가 Scaffold 위젯을 반환해야 해요.\n\n<div class=\"content-ad\"></div>\n\n```dart\nclass _MyHomePageState extends State<MyHomePage> {\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Bottom Navigation Bar'),\n        centerTitle: true,\n      ),\n      body: const Center(),\n    );\n  }\n}\n```\n\nScaffold 위젯에는 bottomNavigationBar 속성이 있으며, 이를 통해 BottomAppBar 위젯을 추가할 수 있습니다. 나는 내 탐색 바에 '노치'를 추가하고 싶었기 때문에 BottomAppBar를 사용하고 있습니다 — 그래서 \"조금 멋지고 멋있어 보이게\"하고 있는 것이죠.\n\nBottomAppBar에는 다음과 같은 속성들을 사용하고 싶었어요:\n\n- shape — 탐색 바에 노치를 추가하여 겹치는 FAB(Floating Action Button)에 공간을 만듦\n- notchMargin — 탐색 바 노치와 FAB 사이의 여백\n- clipBehavior — 설정 옵션에 따라 내용이 클리핑되는지 여부를 지정합니다\n\n\n<div class=\"content-ad\"></div>\n\n```js\nbottomNavigationBar: BottomAppBar(\n  shape: const CircularNotchedRectangle(),\n  notchMargin: 5.0,\n  clipBehavior: Clip.antiAlias,\n  child: SizedBox(\n    height: kBottomNavigationBarHeight,\n    child: Row(\n      mainAxisSize: MainAxisSize.max,\n      mainAxisAlignment: MainAxisAlignment.spaceAround,\n      children: <Widget>[\n        IconButton(\n          icon: const Icon(Icons.home),\n          onPressed: () {\n            setState(() {\n            });\n          },\n        ),\n        IconButton(\n          icon: const Icon(Icons.search),\n          onPressed: () {\n            setState(() {\n            });\n          },\n        ),\n        IconButton(\n          icon: const Icon(Icons.favorite_border_outlined),\n          onPressed: () {\n            setState(() {\n            });\n          },\n        ),\n        IconButton(\n          icon: const Icon(Icons.account_circle_outlined),\n          onPressed: () {\n            setState(() {\n            });\n          },\n        )\n      ],\n    ),\n  ),\n),\n```\n\n![스크린샷](/assets/img/2024-06-21-ASimpleBottomAppBarinFlutter_1.png)\n\n이제 BottomAppBar 속성을 사용하기 위해 FAB를 추가할 때 centerDocked 속성을 사용해야 합니다.\n\n```js\nfloatingActionButtonLocation: FloatingActionButtonLocation.centerDocked,\nfloatingActionButton: FloatingActionButton(\n  onPressed: () {},\n  child: const Icon(Icons.add),\n),\n```\n\n<div class=\"content-ad\"></div>\n\n\n![BottomAppBar](/assets/img/2024-06-21-ASimpleBottomAppBarinFlutter_2.png)\n\n그래서 우리는 이제 '다른' ​​디자인의 하단 네비게이션 바를 얻을 수 있게 되었습니다.\n\n그러나 구현이 간단해 보이더라도, 실제로 작동하게 만드는 데 꽤 고생했습니다. 먼저 BottomAppBar에는 currentIndex 속성이 없어서 어떤 아이콘이 선택되었는지 알아야 페이지를 이동할 수 없습니다. 또한 selectedItemColor와 unselectedItemColor 속성도 없어서 해당 화면으로 이동될 때 아이콘 색상을 전환할 수 없습니다.\n\n그래서 BottomAppBar의 자식으로 BottomNavigationBar를 사용해야 합니다. 또한 페이지 간 전환을 허용하기 위해 pageController를 사용할 것입니다.\n\n\n<div class=\"content-ad\"></div>\n\n```dart\nbottomNavigationBar: BottomAppBar(\n  shape: const CircularNotchedRectangle(),\n  notchMargin: 5.0,\n  clipBehavior: Clip.antiAlias,\n  child: SizedBox(\n    height: kBottomNavigationBarHeight,\n    child: BottomNavigationBar(\n      type: BottomNavigationBarType.fixed,\n      backgroundColor: Colors.green,\n      currentIndex: _selectedIndex,\n      selectedItemColor: Colors.white,\n      unselectedItemColor: Colors.black,\n      onTap: (index) {\n        setState(() {\n          _selectedIndex = index;\n          pageController.jumpToPage(index);\n        });\n      },\n      items: const [\n        BottomNavigationBarItem(\n          icon: Icon(Icons.home_outlined),\n          label: '',\n        ),\n        BottomNavigationBarItem(\n          icon: Icon(Icons.search),\n          label: '',\n        ),\n        BottomNavigationBarItem(\n          icon: Icon(Icons.favorite_border_outlined),\n          label: '',\n        ),\n        BottomNavigationBarItem(\n          icon: Icon(Icons.account_circle_outlined),\n          label: '',\n        ),\n      ],\n    ),\n  ),\n),\nbody: PageView(\n  controller: pageController,\n  children: const <Widget>[\n    Center(\n      child: Home(),\n    ),\n    Center(\n      child: Search(),\n    ),\n    Center(\n      child: Favourite(),\n    ),\n    Center(\n      child: Profile(),\n    ),\n  ],\n),\n```\n\n![Here is the full code:](https://miro.medium.com/v2/resize:fit:1200/1*1LiVHOIR0xdH2Kzg3FdygQ.gif)\n\nLet me know how I can improve on this implementation (e.g., the spacing of the icons next to the notch could be better when there are four navigation items. It looks okay when it’s just two items.)\n\n<div class=\"content-ad\"></div>\n\n읽어 주셔서 감사합니다 ❤","ogImage":{"url":"/assets/img/2024-06-21-ASimpleBottomAppBarinFlutter_0.png"},"coverImage":"/assets/img/2024-06-21-ASimpleBottomAppBarinFlutter_0.png","tag":["Tech"],"readingTime":5},{"title":"Flutter 알림 마스터하기 awesome_notification 패키지 가이드 Part-I 단계별 가이드","description":"","date":"2024-06-21 22:46","slug":"2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide","content":"\n\n- Flutter 앱에서 원활하고 강력하며 사용자 친화적인 알림 경험을 위해 awesome_notification의 모든 기능을 활용해보세요.\n\n![이미지](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_0.png)\n\nFlutter에서 push 알림의 힘을 활용하는 것은 사용자 참여도와 유지율 향상에 중요합니다. 이러한 동적 알림은 사용자에게 실시간 업데이트 및 맞춤화된 상호작용을 제공하여 더 입체적이고 빠른 앱 경험을 조성합니다. 시각적으로 매력적이고 기능이 풍부한 알림을 만들 수 있는 awesome_notifications은 Flutter 개발자들이 사용자를 매혹시키고 앱이 계속해서 주목받을 수 있도록 돕습니다. 오늘날의 경쟁적인 모바일 환경에서 성공을 위한 키패드인 push 알림으로 앱의 커뮤니케이션 전략을 높여보세요.\n\n이 튜토리얼을 위한 프로젝트 구조를 시작해봅시다. 이 이미지에서 기본 구조를 확인할 수 있습니다: -\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_1.png)\n\n홈 페이지와 제품 상세 페이지 두 개의 페이지를 만들었습니다.\n\nFlutter에서 멋진 푸시 알림의 세계로 여정을 시작하기 위해, 우리의 Flutter 앱이 사용자에게 멋진과 동적인 알림을 만드는 데 필요한 도구를 갖추도록 보장하는 필수 종속성을 pubspec.yaml 파일에 추가하는 것으로 시작해봅시다.\n\npubspec.yaml 파일을 열고 다음 라인을 추가해주세요:\n\n<div class=\"content-ad\"></div>\n\n아래 이미지는 Flutter에 최신 버전의 awesome_notifications 및 http 패키지를 가져와 통합하라고 알려줍니다.\n\nawesome_notifications 패키지는 매력적이고 기능이 풍부한 알림을 만들기 위한 해결책으로 사용되고, http 패키지는 알림 워크플로에 필요한 모든 HTTP 요청을 용이하게 처리할 것입니다.\n\n터미널에서 flutter pub get을 실행하여 이러한 종속성을 가져오고 설치하는 것을 기억하세요.\n\n기본 작업이 완료되었으므로, 이제 awesome_notifications 패키지가 제공하는 끝없는 가능성을 탐험할 준비가 되었습니다. 즉각적인 알림, 예약된 경고 및 더 많은 기능을 만들어보자!\n\n<div class=\"content-ad\"></div>\n\n우리의 플러터 프로젝트의 핵심은 main.dart 파일에 있습니다. 이 파일은 우리 멋진 알림 시스템의 초기화를 조정하는 진입점입니다. 즐거운 알림 경험을 위한 무척 중요한 코드 조각을 살펴보겠습니다.\n\nmain.dart에는 클래스 구성 메서드를 호출하고 라우트 생성기 클래스를 생성하여 material 앱 섹션에 할당하는 내용이 담겨 있습니다.\n\nmain.dart\n\n![이미지](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_3.png)\n\n<div class=\"content-ad\"></div>\n\nRouteGenerator.dart\n\n이 클래스에 뷰 파일을 추가하고 네비게이션에 연결하세요.\n\n<img src=\"/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_4.png\" />\n\n애플리케이션 알림 유틸리티 클래스의 중요한 부분은 이 클래스에 있습니다. 사용자에게 멋진 알림을 제공하기 위해 몇 가지 속성과 메서드를 만들었으니 알림 유틸리티를 시작해보겠습니다.\n\n<div class=\"content-ad\"></div>\n\nnotification configuration 코드를 시작하기 전에, 이미지를 통해 멋진 notification 패키지에 의해 제공되는 매개변수를 확인할 수 있고, 이러한 매개변수를 사용하여 push notification을 탐색해보세요. 첫 번째 이미지에서는 단순한 notification만 볼 수 있고, 다른 이미지에서는 사용자 지정 버튼이 있는 notification을 볼 수 있습니다.\n\n\n![First Image](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_5.png)\n\n![Second Image](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_6.png)\n\n\nNotification_utils.dart\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_7.png)\n\n이제 사용자에게 알림 권한을 확인합니다. 이미 권한이 허용되어 있으면 네 개의 상자를 보여주는 홈 화면 UI가 표시됩니다. 권한이 허용되었는지 아닌지 확인하는 코드를 추가했습니다. 매우 간단한 내용이니 이 코드를 따라해보세요:-\n\n![이미지](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_8.png)\n\n코드와 주요 기능을 사용한 멋진 알림 패키지를 확인해봅시다.\n\n\n<div class=\"content-ad\"></div>\n\n🚨 주요 기능:\n\n1️⃣ 즉시 알림: 몇 줄의 코드로 손쉽게 즉시 알림을 생성하고 표시할 수 있어요! ⚡️\n\n2️⃣ 예약 알림: 특정 시간에 전달될 알림을 예약해서 미리 계획하세요. 📅⏰\n\n3️⃣ JSON 데이터 알림: JSON 데이터를 활용하여 동적으로 알림을 사용자 정의해보세요. 🧩📤\n\n<div class=\"content-ad\"></div>\n\n4️⃣ 사용자 정의 버튼 알림: 사용자 상호작용을 더욱 향상시키기 위해 알림 내에 사용자 정의 버튼을 통합하세요. 🎛️📲\n\n- . 즉시 알림: 몇 줄의 코드로 쉽게 즉시 알림을 생성하고 표시할 수 있습니다! ⚡️\n\n![Screenshot](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_9.png)\n\n2). 예약 알림: 알림을 특정 시간에 전달할 수 있도록 예약함으로써 미리 계획하세요. 📅⏰, 이 코드에서는 이 메소드를 호출한 후 1분 후에 알림이 도착하도록 예약 설정을 합니다. 이 기능을 이용하여 사용자에게 정기적으로 업데이트를 알리는 리마인더 또는 전자상거래 프로젝트나 피트니스 앱에서 일정 시간에 사용자에게 알리기 위해 사용할 수 있습니다. 예약된 알림을 다룰 때에는 안드로이드 manifest 파일에서 권한을 몇 가지 추가할 수 있습니다. 아래 이미지에서 해당 권한을 확인할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지 1](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_10.png)\n\n![이미지 2](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_11.png)\n\n3). JSON 데이터 통지: JSON 데이터를 활용하여 알림을 동적으로 사용자 정의하세요. 🧩📤 메서드 호출 시 jsonData를 전달할 수 있습니다. 자세한 내용은 홈페이지에서 확인해주세요. 그러면 메서드가 어떻게 작동하는지 쉽게 이해하고 확인할 수 있습니다.\n\n![이미지 3](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_12.png)\n\n\n<div class=\"content-ad\"></div>\n\n4). 사용자 상호작용을 더욱 향상시키기 위해 맞춤 버튼을 알림에 포함하여 사용하세요. 🎛️📲\n\n지금부터 제가 최고로 선호하는 주요 기능은 더 나은 사용자 경험을 위한 것입니다. 이 멋진 알림이 도착했을 때 맞춤 버튼을 추가하여 필요에 따라 더 많은 사용자 경험을 제공할 수 있습니다. 사용자의 이동 부분에 대해 알아보시죠. 한 예를 통해 이해해보겠습니다. 전자 상거래 프로젝트를 작업 중이라고 가정해보세요. 두 개의 버튼 중 하나는 \"지금 구매\"이고 다른 하나는 \"장바구니에 추가\"입니다. 이 경우 사용자가 \"지금 구매\" 버튼을 클릭하면 사용자가 체크 아웃 화면 또는 페이지로 이동할 것이고, \"장바구니에 추가\"를 클릭하면 제품이 장바구니에 추가되고 사용자는 장바구니 화면으로 이동하게 됩니다. 이것이 기본 설명입니다. 이제 코드로 돌아가 봅시다. 여기 createCustomNotificationWithActionButtons() 메서드명이 있습니다.\n\n![이미지](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_13.png)\n\n이제 거의 모든 코드 작업을 마쳤습니다. 성공적으로 알림이 생성되거나 화면에 도착한 후 알림을 탭하면 사용자로 이동하게 만들어야 합니다. 그래서 이 코드를 추가했습니다. 위 코드를 따라해 주세요.\n\n<div class=\"content-ad\"></div>\n\nonActionRecivedMethod은 사용자를 새 페이지로 리디렉션하거나 유효한 컨텍스트를 사용해야 할 때에만 필요합니다. 병렬 격리본은 유효한 컨텍스트를 갖고 있지 않기 때문에, 실행을 주 격리본으로 리디렉션해야 합니다.\n\n\n![Image](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_14.png)\n\n\nonActionRecivdeImplementationMethod은 사용자를 탐색할 때 실행될 것이므로, 이 방법을 사용하면 사용자에게 특정 페이지의 뷰나 화면을 정의할 수 있습니다. 또한, 사용자가 커스텀 버튼을 클릭하는 동안 사용자를 탐색할 수도 있으므로, 커스텀 버튼과 함께 알림을 생성할 때 키와 레이블을 전달하면 됩니다. 키를 사용하여 버튼을 클릭했을 때 페이지를 리디렉션할 조건이나 구성을 설정할 수 있으므로, 이 코드를 추가합니다. 아래 코드를 확인할 수 있습니다.\n\n\n![Image](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_15.png)\n\n\n<div class=\"content-ad\"></div>\n\n이제 우리는 onActionRecivedMethod, onNotificationCreatedMethod, onNotificationDisplayedMethod, onDismissActionReceivedMethod과 같은 멋진 알림 패키지에서 제공하는 이벤트를 수신하는 리스너를 설정했습니다. 이 메서드들을 사용하여 알림의 생성, 표시 및 해제를 감지할 수 있습니다. initState()에서 Homeview에서 startListeningNotificationEvents 메서드를 호출합니다.\n\n![image](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_16.png)\n\n이제 알림에 대한 논리 부분을 생성하고 추가했습니다. 이제 UI 부분으로 이동하여 사용자 인터페이스에서 화면을 만들겠습니다. 홈 화면과 제품 세부 정보 화면을 추가했습니다. 홈 페이지에는 아래와 같이 4개의 상자가 있는 GridView를 만듭니다.\n\n![image](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_17.png)\n\n<div class=\"content-ad\"></div>\n\nHome_view.dart에 대한 설명입니다.\n\nBuild 메소드 내에서 제목을 구현하고, notificationType에 알림 유형 서브 위젯을 추가합니다. GridView.extent를 사용하여 4가지 상자를 만들고 각각의 탭 기능에는 Gesture Detector 위젯을 사용하며, 탭할 때 해당하는 알림 클래스 메소드를 호출합니다.\n\n![이미지](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_18.png)\n\n첫 번째 상자에서 사용자가 즉시 통지를 탭하면 즉시 로컬 통지가 전송되며, 기기에 통지가 표시되고, 동시에 리디렉션도 수행됩니다.\n\n<div class=\"content-ad\"></div>\n\n첫 번째 상자는 인스턴트 알림 생성을 통해 사용자가 상자를 탭할 때 utils 클래스의 createInstantNotification 메서드가 호출되고 알림이 전송됩니다.\n\n두 번째 상자는 일정된 알림을 가지고 있습니다. 이는 스케줄 알림 기능을 사용하여 트리거된 알림을 설정하는 것을 의미합니다. 이러한 기능은 전자 상거래 앱, 피트니스 앱, 리마인더 앱 등 다양한 애플리케이션에서 주로 볼 수 있습니다.\n\n따라서 상자 안에서 사용자가 탭하면 notification_utils 클래스의 createScheduleNotification 메서드를 호출합니다. 이 코드에서는 탭한 후 1분 동안의 시간이 경과한 후에 알림이 표시되며, 필요에 맞게 사용자 정의할 수 있습니다.\n\n![이미지](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_19.png)\n\n<div class=\"content-ad\"></div>\n\n세 번째 상자에는 JSON 객체로 알림을 생성하고 API나 JSON 응답에 따라 사용자 정의하거나 동적으로 만들 수 있습니다. 이를 위해 호출 jsonDataNotification 메소드가 호출될 때 매개변수를 JSON 객체 형식으로 전달할 수 있습니다.\n\n![이미지](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_20.png)\n\n마지막으로 가장 좋아하는 기능 중 하나는 사용자 정의 버튼 알림입니다.\n\n네 번째 상자에서 상자를 탭하면 알림 클래스에서 createCustomNotificationWithActionButtons가 호출되고 이 메서드에서 actionButtons를 추가하여 사용자에게 표시합니다. actionButton에서 위젯 목록을 제공하고 버튼에 대한 키와 레이블을 잊지 마세요. 키를 사용하여 버튼KeyInput을 식별하고 동작을 수행하고 레이블은 단순 표시 용도입니다.\n\n<div class=\"content-ad\"></div>\n\n\n![2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_21](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_21.png)\n\n이 화면의 제품 상세 페이지 UI는 단지 제품 데이터와 수량, 제품 크기, 그리고 제품 가격을 보여줍니다.\n\n![2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_22](/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_22.png)\n\n어서요, 기다리던 것이 끝났습니다. 리다이렉션을 통해 멋진 알림 패키지를 성공적으로 구현했습니다.\n\n\n<div class=\"content-ad\"></div>\n\n![image](https://miro.medium.com/v2/resize:fit:600/1*KBn0C6MmIzCdSEM_1xZrfQ.gif)\n\n플러터 개발의 복잡한 태피스트리 속에서 우리의 awesome_notifications 탐험은 혁신과 무한한 잠재력으로 가득한 여정이었습니다. 즉시 알림부터 예약된 통지 및 JSON 데이터의 동적 매력까지, 우리는 플러터 앱을 참여의 전도사로 변화시킬 수 있는 도구들을 발견했습니다.\n\n이 기사가 가이드 역할을 해 준 것으로서 부디 당신이 푸시 알림을 통해 몰입형 사용자 경험을 만들어가는 길을 밝혀 주었기를 바랍니다. 이 놀라운 논의를 마무리하면서 새롭게 얻은 지식이 얼마나 매료시키고 당신의 플러터 프로젝트가 디지털 환경에서 빛날 수 있는지 곰곰히 생각해 보시기 바랍니다.\n\nawesome_notifications 패키지 내부 동작을 더 깊이 파고들고 싶은 분들을 위해 GitHub의 포괄적인 코드베이스를 살펴보시기를 초대합니다:\n\n<div class=\"content-ad\"></div>\n\nGitHub 저장소\n\n저와 함께하시면 플러터 개발 세계에서 계속되는 토론, 통찰, 그리고 미래 탐구를 경험할 수 있습니다:\n\nLinkedIn 프로필\n\n이 여정에 투자해 주신 여러분께 감사드립니다. 여러분의 플러터 노력이 혁신적이고 원활한 기능성을 갖추며, 사용자들로부터 진정으로 중요한 알림을 받을 수 있기를 바라겠습니다.\n\n<div class=\"content-ad\"></div>\n\n플러터 우수성을 위한 이 여정에 참여해 주셔서 감사합니다. 다음 탐험 때까지 즐거운 코딩하세요! 알림이 항상 멋지고 효과적하기를 바라요! 🚀📲","ogImage":{"url":"/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_0.png"},"coverImage":"/assets/img/2024-06-21-MasteringFlutterNotificationsAGuidetoawesome_notificationPackagePart-IStepbyStepGuide_0.png","tag":["Tech"],"readingTime":10},{"title":"Dio 패키지를 사용하여 Flutter에서 REST API에 이미지 업로드하는 방법","description":"","date":"2024-06-21 22:44","slug":"2024-06-21-UploadimagestoRESTAPIwithFlutterusingDioPackage","content":"\n\n플러터 개발자들로부터 받은 엄청난 반응 뒤에 http 패키지를 사용하여 REST API에 이미지를 업로드하는 방법에 대한 이야기를 공유한 후, 많은 사람들이 dio 패키지를 사용하여 그렇게 하는 데 어려움을 겪는 것을 보았습니다. 초보자들은 일반적으로 사용할 수 있는 코드 스니펫을 찾을 수 있는 자세하고 쉽게 배울 수 있는 자료를 원합니다.   \n이 이야기에서는 flutter에서 이미지를 업로드하는 방법에 대해 dio 패키지를 사용하여 작성하겠습니다. 가능한 모든 측면에 대해 설명하기 위해 최선을 다하겠지만, 빠진 부분이 있다고 생각하거나 의겢가 있으면 의겢를 남겨주시고 학습 과정에서 도와주십시오.  \n\n우선 dio 패키지를 앱에 추가하는 방법부터 시작해봅시다.  \n\nDio는 다트를위한 강력한 HTTP 클라이언트로서 내 flutter 앱에서 서버에 연결하는 동안 응답의 직렬화 및 역직렬화와 같은 여러 측면에서 도움이 됩니다.   \n\n프로젝트 디렉토리 터미널에서 다음 명령을 실행합니다.\n\n<div class=\"content-ad\"></div>\n\n```dart\n $ dart pub add dio\n```\n\n기기 갤러리나 카메라에서 이미지를 가져 오기 위해 Image Picker 패키지를 사용했어요.\n\n프로젝트 디렉토리 터미널에서 다음 명령어를 실행해주세요:\n\n```dart\n$ flutter pub add image_picker\n```\n\n<div class=\"content-ad\"></div>\n\n여기 갤러리에서 이미지를 가져 오는 코드입니다.\n\n```js\nFuture<File> getImage() async {\n  final ImagePicker _picker = ImagePicker();\n  // 이미지 선택\n  final XFile? image = await _picker.pickImage(source: ImageSource.gallery);\n  // XFile을 파일로 변환\n  File file = File(image!.path);\n  // print(‘이미지 선택됨');\n  return file;\n}\n```\n\n이제 갤러리에서 이미지를 선택했습니다. 다음은 MultipartRequest를 수행 할 dart 파일에서 dio 패키지를 가져 오는 방법입니다.\n\n```js\nimport 'package:dio/dio.dart';\n```\n\n<div class=\"content-ad\"></div>\n\n그럼 REST API에 전송할 이미지를 포함하는 fromMap이라는 이름의 이름이 지정된 생성자를 사용하여 FormData 객체를 만들어보겠습니다.\n\n```js\nvar formData = FormData.fromMap({\n        'file': await MultipartFile.fromFile(empFace.path, filename: empCode),\n      });\n```\n\n여기서 'file' 키를 사용하여 파일을 Map에 포함했습니다. 이는 서버로 보낼 FormData 객체를 반환하며, 우리는 이 객체를 사용하여 서버로 전송할 것입니다. 카메라 이미지의 파일을 사용하여 MultipartFile을 생성하고, 이를 인터넷을 통해 전송할 수 있습니다.\n\n마지막으로 dio를 사용하여 REST API에 요청을 보내보세요:\n\n<div class=\"content-ad\"></div>\n\n```dart\n최종 응답 = await Dio().post(\n        '당신의 API URL',\n        data: formData,\n      );\n```\n\n우리는 formData를 post 메소드에 전달했고, 자동으로 contentType을 처리해줄 것입니다. 일반적으로 서버로 이미지를 보낼 때 form-data 헤더를 사용합니다.:\n\n```dart\nheaders: {\n    'Content-Type': 'multipart/form-data'\n  },\n```\n\ndio를 사용하면 헤더에서 content-type을 명시적으로 지정할 필요가 없습니다.  \n\n<div class=\"content-ad\"></div>\n\n여기에서 시나리오와 사용 사례를 더 잘 이해하기 위한 완전한 코드입니다:\n\n```js\nFuture<bool> registerEmployeeFace(\n      {required File empFace, required String empCode}) async {\n    final url =\n        '내 API URL';\n    try {\n      var formData = FormData.fromMap({\n        'file': await MultipartFile.fromFile(empFace.path, filename: empCode),\n      });\n      final response = await Dio().post(\n        url,\n        data: formData,\n      );\n      if (response.statusCode == 200) {\n        var map = response.data as Map;\n        print('success');\n        if (map['status'] == 'Successfully registered') {\n          return true;\n        } else {\n          return false;\n        }\n      } else {\n        // BotToast는 pub.dev에서 사용 가능한 토스트 패키지입니다.\n        BotToast.showText(text: '에러');\n        return false;\n      }\n    } on DioError catch (error) {\n      log(error.message);\n      throw YourException(error);\n    } catch (_) {\n      log(_.toString());\n      throw '문제가 발생했습니다';\n    }\n  }\n```\n\n초보자들도 이 요청을 쉽게 수행하고 복잡한 API를 빠르게 통합할 수 있기를 바랍니다. 더 많은 Github를 위해\n\n<div class=\"content-ad\"></div>\n\n만약 도움이 되었다면 좋아요 버튼을 눌러주시고 친구들과 공유해주세요.","ogImage":{"url":"/assets/img/2024-06-21-UploadimagestoRESTAPIwithFlutterusingDioPackage_0.png"},"coverImage":"/assets/img/2024-06-21-UploadimagestoRESTAPIwithFlutterusingDioPackage_0.png","tag":["Tech"],"readingTime":4},{"title":"Flutter에서 ElevatedButton 모양 커스터마이징 하는 방법","description":"","date":"2024-06-21 22:43","slug":"2024-06-21-HowtoCustomizetheShapeofanElevatedButtoninFlutter","content":"\n\n![이미지](/assets/img/2024-06-21-HowtoCustomizetheShapeofanElevatedButtoninFlutter_0.png)\n\nElevatedButtons의 모양을 shape 속성으로 사용자 정의하세요!\n\nElevatedButton 위젯은 작업을 실행하는 Material Design 버튼입니다. 발판 모양을 가지고 있으며 모양 속성을 포함한 다양한 속성으로 사용자 정의할 수 있습니다.\n\n기본 ElevatedButton 모양은 8.0의 테두리 반경을 가진 둥근 직사각형입니다. 그러나 ElevatedButton 위젯의 shape 속성을 설정하여 버튼의 모양을 사용자 정의할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n모양 속성은 다양한 형태로 설정할 수 있습니다. 예를 들어 다음과 같은 형태들이 있습니다:\n\n- RoundedRectangleBorder\n- BeveledRectangleBorder\n- CircleBorder\n- NotchedShape\n- ContinuousRectangleBorder\n\n예를 들어, 다음 코드는 둥근 테두리 반경이 5.0인 ElevatedButton을 생성합니다:\n\n```js\nElevatedButton.icon(\n  style: ElevatedButton.styleFrom(\n    shape: RoundedRectangleBorder(\n      borderRadius: BorderRadius.circular(5.0),\n    ),\n  ), \n  onPressed: () {},\n  icon: const Icon(Icons.filter_list),\n  label: const Text('Filter'),\n);\n```\n\n<div class=\"content-ad\"></div>\n\n더 알고 싶다면 irawnewton을 방문해보세요. Flutter에 관한 심층적인 기사와 안내서가 있습니다. Flutter 및 관련 기사에 대한 블로그를 계속 올릴 거에요.\n\n또한 버튼의 모양을 사용자 정의하려면 shape 속성을 사용할 수 있어요. 예를 들어, 다음 코드는 원형 테두리가 있는 ElevatedButton을 만듭니다:\n\n```js\nElevatedButton.icon(\n  style: ElevatedButton.styleFrom(\n    shape: StadiumBorder(),\n  ),\n  onPressed: () {},\n  icon: const Icon(Icons.filter_list),\n  label: const Text('Filter'),\n);\n```\n\nshape 속성을 사용하면 ElevatedButton의 외관을 사용자 정의하는 강력한 방법입니다. 사용 가능한 다양한 모양을 활용하여 특정한 요구사항과 스타일에 맞는 버튼을 만들 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n안녕하세요! ElevatedButton의 모양을 사용자 정의하는 몇 가지 팁을 제공합니다:\n\n- borderRadius 속성을 사용하여 버튼의 모퉁이 반경을 제어합니다.\n- side 속성을 사용하여 버튼의 테두리 색상 및 너비를 설정합니다.\n- elevation 속성을 사용하여 버튼의 그림자 높이를 설정합니다.\n- padding 속성을 사용하여 버튼 콘텐츠 주변의 패딩 양을 설정합니다.\n\nElevatedButton의 모양을 사용자 정의하는 자세한 내용은 다음 ElevatedButton 문서를 참조해주세요: [ElevatedButton 문서](https://api.flutter.dev/flutter/material/ElevatedButton-class.html).\n\n이 문서가 Flutter에서 ElevatedButtons의 모양을 사용자 정의하는 데 도움이 되기를 바랍니다.\n\n<div class=\"content-ad\"></div>\n\n질문이 있으시면 언제든지 댓글을 남겨주세요. 도와드릴 수 있어서 더할 나위 없이 기쁩니다.","ogImage":{"url":"/assets/img/2024-06-21-HowtoCustomizetheShapeofanElevatedButtoninFlutter_0.png"},"coverImage":"/assets/img/2024-06-21-HowtoCustomizetheShapeofanElevatedButtoninFlutter_0.png","tag":["Tech"],"readingTime":2},{"title":"Flutter에서 노치가 있는 하단 내비게이션 바 만드는 방법","description":"","date":"2024-06-21 22:41","slug":"2024-06-21-HowtocreateaNotchedBottomNavigationBarFlutter","content":"\n\n이 가이드는 하단 네비게이션 앱 바에 노치가 있는 플로팅 액션 버튼을 추가하는 방법을 보여줍니다. 하단 바의 노치가 있는 플로팅 액션 버튼은 앱의 사용자 인터페이스를 더욱 미려하게 만들어줍니다. 더 자세한 정보는 아래 코드를 참조해주세요:\n\n![Notched Floating Action Button](/assets/img/2024-06-21-HowtocreateaNotchedBottomNavigationBarFlutter_0.png)\n\n시작해 봅시다\n\n플로팅 액션 버튼이 있는 BottomAppBar는 아래 코드를 사용하여 앱에 추가할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nScaffold(\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {},\n        child: const Icon(Icons.add),\n      ),\n      bottomNavigationBar: BottomAppBar(\n        padding: const EdgeInsets.symmetric(horizontal: 10),\n        height: 60,\n        color: Colors.cyan.shade400,\n        notchMargin: 5,\n        child: Row(\n          mainAxisSize: MainAxisSize.max,\n          mainAxisAlignment: MainAxisAlignment.spaceBetween,\n          children: <Widget>[\n            IconButton(\n              icon: const Icon(\n                Icons.menu,\n                color: Colors.black,\n              ),\n              onPressed: () {},\n            ),\n            IconButton(\n              icon: const Icon(\n                Icons.search,\n                color: Colors.black,\n              ),\n              onPressed: () {},\n            ),\n            IconButton(\n              icon: const Icon(\n                Icons.print,\n                color: Colors.black,\n              ),\n              onPressed: () {},\n            ),\n            IconButton(\n              icon: const Icon(\n                Icons.people,\n                color: Colors.black,\n              ),\n              onPressed: () {},\n            ),\n          ],\n        ),\n      ),\n    );\n```\n\n아래는 코드의 출력이고 실행하면 앱에 사용 가능한 FloatingActionButton이 있는 BottomAppBar가 표시됩니다.\n\n<img src=\"/assets/img/2024-06-21-HowtocreateaNotchedBottomNavigationBarFlutter_1.png\" />\n\n시작하려면, Scaffold 위젯의 floatingActionButtonLocation 속성을 사용하여 FloatingActionButton 버튼의 위치를 조정하세요.\n아래에 표시된 centerDocked를 사용하여 중앙에 위치하도록 설정할 것입니다: \n\n<div class=\"content-ad\"></div>\n\n아래와 같이 `BottomAppBar`에 모양을 적용하세요.\n\n```js\nshape: const CircularNotchedRectangle()\n```\n\n<img src=\"/assets/img/2024-06-21-HowtocreateaNotchedBottomNavigationBarFlutter_2.png\" />\n\n<div class=\"content-ad\"></div>\n\n`extendBody: true`을 지정하면 스캐폴드의 본문이 하단 네비게이션 바의 노치를 통해 보이게 됩니다.\n\n```js\n extendBody: true,\n```\n\n<img src=\"/assets/img/2024-06-21-HowtocreateaNotchedBottomNavigationBarFlutter_3.png\" />\n\n그게 다에요. 🎉🎉\n\n<div class=\"content-ad\"></div>\n\n풀 코드:\n\n```dart\n return Scaffold(\n      extendBody: true,\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {},\n        child: const Icon(Icons.add),\n      ),\n      floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked,\n      bottomNavigationBar: BottomAppBar(\n        padding: const EdgeInsets.symmetric(horizontal: 10),\n        height: 60,\n        color: Colors.cyan.shade400,\n        shape: const CircularNotchedRectangle(),\n        notchMargin: 5,\n        child: Row(\n          mainAxisSize: MainAxisSize.max,\n          mainAxisAlignment: MainAxisAlignment.spaceBetween,\n          children: <Widget>[\n            IconButton(\n              icon: const Icon(\n                Icons.menu,\n                color: Colors.black,\n              ),\n              onPressed: () {},\n            ),\n            IconButton(\n              icon: const Icon(\n                Icons.search,\n                color: Colors.black,\n              ),\n              onPressed: () {},\n            ),\n            IconButton(\n              icon: const Icon(\n                Icons.print,\n                color: Colors.black,\n              ),\n              onPressed: () {},\n            ),\n            IconButton(\n              icon: const Icon(\n                Icons.people,\n                color: Colors.black,\n              ),\n              onPressed: () {},\n            ),\n          ],\n        ),\n      ),\n    );\n```\n\n감사합니다! :)","ogImage":{"url":"/assets/img/2024-06-21-HowtocreateaNotchedBottomNavigationBarFlutter_0.png"},"coverImage":"/assets/img/2024-06-21-HowtocreateaNotchedBottomNavigationBarFlutter_0.png","tag":["Tech"],"readingTime":4},{"title":"플러터에서 BloC 패턴으로 Fetch API 사용 방법","description":"","date":"2024-06-21 22:39","slug":"2024-06-21-FetchAPIWithBloCinFlutter","content":"\n\n이 문서에서는 블록 라이브러리를 사용하여 HTTP 요청을 수행하고 애플리케이션의 상태를 관리하는 방법을 살펴보겠습니다. 최종 애플리케이션은 다음과 같습니다:\n\n![애플리케이션 데모](https://miro.medium.com/v2/resize:fit:576/1*amzYfYKgiZ8zpehBTVcx4w.gif)\n\n앱이 처음 실행될 때, 서버에서 데이터를 가져올 때 로딩 표시기가 표시됩니다. 데이터를 가져온 후에는 목록에 표시됩니다.\n\n이를 위해 몇 가지 패키지를 사용하겠습니다:\n\n<div class=\"content-ad\"></div>\n\n```yaml\ndependencies:\n  flutter_bloc: ^8.1.1\n  http: ^0.13.5\n  equatable: ^2.0.5\n```\n\n이제 API를 사용하여 서버에서 데이터를 가져오는 메커니즘을 만들어 보겠습니다. http 작업을 수행하기 위해 lib 내부에 폴더를 생성하고 repo라는 이름으로 지정합니다. 이 repo 내부에 repositories.dart라는 새 파일을 생성합니다.\n\n```dart\nimport 'dart:convert';\n\nimport 'package:bloc_example/models/user_model.dart';\nimport 'package:http/http.dart';\n\nclass UserRepository {\n  String userUrl = 'https://reqres.in/api/users?page=2';\n\n  Future<List<UserModel>> getUsers() async {\n    Response response = await get(Uri.parse(userUrl));\n   \n    if (response.statusCode == 200) {\n      final List result = jsonDecode(response.body)['data'];\n      return result.map((e) => UserModel.fromJson(e)).toList();\n    } else {\n      throw Exception(response.reasonPhrase);\n    }\n  }\n}\n```\n\nhttp 요청을 수행하려면 http 패키지를 사용할 것입니다. 이제 json 내용을 살펴봅시다. 우리는 이 링크의 API를 사용하고 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n위의 링크에서 제공되는 JSON을 보면 모델이 어떻게 보일지에 대한 아이디어를 얻을 수 있습니다. 이 JSON에서는 데이터 태그의 속성을 갖게 될 것입니다. 여기서 우리는 firstname, lastname, email, 그리고 avatar에 초점을 맞출 것입니다.\n\n이제 모델 클래스를 만들어 봅시다.\n\n```js\nclass UserModel {\n  int? id;\n  String? email;\n  String? firstName;\n  String? lastName;\n  String? avatar;\n\n  UserModel({this.id, this.email, this.firstName, this.lastName, this.avatar});\n\n  UserModel.fromJson(Map<String, dynamic> json) {\n    id = json['id'];\n    email = json['email'];\n    firstName = json['first_name'];\n    lastName = json['last_name'];\n    avatar = json['avatar'];\n  }\n}\n```\n\n계속해서, 이제 우리의 블록이 어떻게 작동하는지에 대해 알아보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-21-FetchAPIWithBloCinFlutter_0.png\" />\n\n위의 그림을 보면\n\n- 먼저 UI가 있고 UI에서 블록으로 요청을 합니다.\n- 블록에는 이벤트와 상태 두 가지가 있습니다. 먼저 UI가 블록에 연결되면 이벤트를 생성하고 트리거합니다.\n- 이벤트는 최종적으로 엔드포인트를 통해 서버에 저장소를 호출합니다.\n- 서버에서 데이터를 가져와 블록에 다시 전달합니다. 데이터가 있으므로 상태를 트리거합니다.\n- 상태가 변경되었으므로 UI는 Bloc 패턴에서 알고 UI를 업데이트합니다.\n\n새 폴더 blocs를 만들고 app_states.dart라는 새 파일을 생성합니다.\n\n<div class=\"content-ad\"></div>\n\n\n```dart\nimport 'package:bloc_example/models/user_model.dart';\nimport 'package:equatable/equatable.dart';\nimport 'package:flutter/material.dart';\n\n@immutable\nabstract class UserState extends Equatable {}\n\nclass UserLoadingState extends UserState {\n  @override\n  List<Object?> get props => [];\n}\n\nclass UserLoadedState extends UserState {\n  final List<UserModel> users;\n  UserLoadedState(this.users);\n  @override\n  List<Object?> get props => [users];\n}\n\nclass UserErrorState extends UserState {\n  final String error;\n  UserErrorState(this.error);\n  @override\n  List<Object?> get props => [error];\n}\n```\n\nEquatable를 사용하면 값들을 비교할 수 있습니다. 두 변수가 동일한 값을 갖고 있다면 UI를 변경하거나 업데이트하지 않을 것입니다.\n\n먼저 상태를 생성하려면 equatable을 확장해야 하는 추상 클래스를 생성해야 합니다.\n\nBloc에서 x.obs를 통해 변수를 반응형으로 만들 수 있는 Getx와 달리 Bloc에서는 이와 같이 작동하지 않습니다. Bloc을 사용할 때는 모든 상태가 클래스임을 염두에 두어야 합니다.\n\n\n<div class=\"content-ad\"></div>\n\n이 프로젝트에서는 세 가지 상태가 있습니다.\n\n- 데이터를 불러올 때의 상태\n- 데이터를 불러왔을 때의 상태\n- 데이터를 가져오는 데 오류가 발생했을 때의 상태\n\n그리고 Equatable 내부에 get props라는 속성이 있습니다. 이를 재정의해야 합니다. UserState 클래스가 Equatable을 확장했으므로 UserLoadingState, UserLoadedState 및 UserErrorState 상태 클래스가 get props 속성에 액세스할 수 있게 됩니다. 이를 얻기 위해 재정의하고 해당 값을 설정해야 합니다.\n\n상태 이후, Flutter 블록에서는 각 상태마다 이벤트가 있습니다. 지금 app_events.dart라는 파일을 만들어야 합니다. 상태와 마찬가지로 이벤트를 위한 클래스를 생성해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport 'package:equatable/equatable.dart';\nimport 'package:flutter/material.dart';\n\n@immutable\nabstract class UserEvent extends Equatable {\n  const UserEvent();\n}\n\nclass LoadUserEvent extends UserEvent {\n  @override\n  List<Object?> get props => [];\n}\n```\n\n상태처럼 이벤트도 Equatable 클래스를 확장해야 합니다. 각 이벤트를 위한 전용 클래스를 만들어야 합니다. 이벤트 클래스는 기본 클래스를 확장해야 합니다. 여기서 기본 클래스는 UserEvent입니다. 그리고 이벤트는 LoadUserEvent입니다. 그리고 get props를 재정의해야 합니다.\n\n@immutable은 클래스의 속성을 변경하고 싶지 않다는 것을 나타냅니다.\n\n상태와 이벤트를 생성한 후에는 그들을 연결하는 방법을 찾아야 합니다.\n\n\n<div class=\"content-ad\"></div>\n\n그러려면 새 클래스를 만들고 방금 만든 상태와 이벤트를 삽입해야 해요. 이제 Bloc 라이브러리를 사용하여 이것들을 연결해 보죠.\n\nblocs 폴더 안에 app_blocs라는 새 파일을 만들어주세요.\n\n```dart\nimport 'package:bloc_example/blocs/app_events.dart';\nimport 'package:bloc_example/blocs/app_states.dart';\nimport 'package:bloc_example/repos/repositories.dart';\nimport 'package:flutter_bloc/flutter_bloc.dart';\n\nclass UserBloc extends Bloc<UserEvent, UserState> {\n  final UserRepository _userRepository;\n\n  UserBloc(this._userRepository) : super(UserLoadingState()) {\n    on<LoadUserEvent>((event, emit) async {\n      emit(UserLoadingState());\n      try {\n        final users = await _userRepository.getUsers();\n        emit(UserLoadedState(users));\n      } catch (e) {\n        emit(UserErrorState(e.toString()));\n      }\n    });\n  }\n}\n```\n\n여기엔 UserBloc이라는 클래스가 있습니다. 이 클래스는 Bloc을 확장합니다. 이 Bloc은 이벤트와 상태를 가져와야 합니다. 저희 경우에는 UserEvent와 UserState입니다. 이곳에서 사용하는 Bloc은 실제로 Bloc 라이브러리에서 제공됩니다.\n\n<div class=\"content-ad\"></div>\n\n이 UserBloc에는 리포지토리를 전달하는 생성자가 있어요. UI에서 이것을 호출할 거거든요. 이 클래스를 호출하는 동안 UserRepository를 전달합니다. Bloc을 사용했기 때문에 초기 상태를 슈퍼 생성자에 전달해야해요. 초기값을 호출한 후에는 on 메소드를 호출하게 됩니다.\n\n이제 on 메소드는 이벤트 유형을 가져와서 LoadUserEvent를 여기에 전달합니다. 이 이벤트를 사용하여 어떤 작업을 수행할 수 있어요. 이 이벤트가 호출되면 일부 상태를 방출하도록 지정합니다. 이 경우에는 UserLoadingState를 UI에서 변경 사항을 확인하려고 해요.\n\nBLoc에서 상태, 이벤트를 연결하여 상태를 트리거하고 작업할 수 있도록 하려면 lib 폴더에 homepage.dart라는 새 파일을 만들어요.\n\n```js\nclass HomePage extends StatelessWidget {\n  const HomePage({Key key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MultiBlocProvider(\n      providers: [\n        BlocProvider<UserBloc>(\n          create: (BuildContext context) => UserBloc(UserRepository()),\n        ),\n      ],\n      child: Scaffold(\n          appBar: AppBar(title: const Text('The BloC App')),\n          body: blocBody()),\n    );\n  }\n\nWidget blocBody() {\n    return BlocProvider(\n      create: (context) => UserBloc(\n        UserRepository(),\n      )..add(LoadUserEvent()),\n      child: BlocBuilder<UserBloc, UserState>(\n        builder: (context, state) {\n          if (state is UserLoadingState) {\n            return const Center(\n              child: CircularProgressIndicator(),\n            );\n          }\n           if (state is UserErrorState) {\n            return const Center(child:  Text(\"Error\"));\n          }\n          if (state is UserLoadedState) {\n            List<UserModel> userList = state.users;\n            return ListView.builder(\n                itemCount: userList.length,\n                itemBuilder: (_, index) {\n                  return Padding(\n                    padding:\n                        const EdgeInsets.symmetric(vertical: 4, horizontal: 8),\n                    child: Card(\n                        color: Theme.of(context).primaryColor,\n                        child: ListTile(\n                            title: Text(\n                              '${userList[index].firstName}  ${userList[index].lastName}',\n                              style: const TextStyle(color: Colors.white),\n                            ),\n\n                            subtitle: Text(\n                              '${userList[index].email}',\n                              style: const TextStyle(color: Colors.white),\n                            ),\n                            \n                            leading: CircleAvatar(\n                              backgroundImage: NetworkImage(\n                                  userList[index].avatar.toString()),\n                            ))),\n                  );\n                });\n          }\n\n          return Container();\n        },\n      ),\n    );\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n보시다시피 'MultiBlocProvider'가 제공되는 우리의 bloc 라이브러리에서 온 것을 확인할 수 있어요. 서버에서 데이터를로드하고 한 번만 로드하려고하기 때문에 빌드 방법에서 UserRepository를 주입합니다. bloc 형식의 MultiBlocProvider에서는 클래스에 여러 Bloc을 추가하여 전체 클래스에서 사용할 수 있습니다. 또한이 리포지토리를 배치할 위치에는 클래스가 있어야합니다. 우리의 경우에는 Scaffold입니다.\n\n그래서 MultiBlocProvider가 하는 일은 서버에서 데이터를 이동시키고 이를 만들어서 데이터와 상태를 모든 하위 요소에서 사용할 수 있게하는 것입니다.\n\nblocBody 내부에서 BlocProvider를 볼 수 있습니다. Getx에 익숙하다면 Get.put와 비슷합니다. BlocProvider 내부에서는 리포지토리와 함께 bloc 즉 UserBloc을 주입합니다. 위에서 이미 bloc을 주입했으므로 blocBody 내에서 이벤트에 액세스 할 수 있습니다.\n\n리포지토리와 함께 bloc을 주입 한 후에는 이벤트 즉 LoadUserEvent를 추가하고 이를 사용하여 UserBloc에서 UserLoadingState를 트리거하는 캐스캐이딩 연산자를 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n이제 빌더 내부의 상태를 확인할 수 있습니다. 세 가지 상태가 있으므로 각각을 확인하여 다른 작업을 수행하고 다른 UI를 반환합니다.\n\n다음과 같이 확인할 수 있습니다.\n\n- `UserLoadingState`일 때는 데이터를 불러오고 있다는 의미로 CircularProgressIndicator를 표시합니다.\n- `UserLoadedState`일 때는 데이터 목록을 반환합니다.\n- `UserErrorState`일 때는 오류 메시지를 반환합니다.\n\n이제 애플리케이션을 실행하면 bloc 라이브러리를 사용하여 데이터가 검색될 것입니다.\n\n<div class=\"content-ad\"></div>\n\n단점을 확인하려면 잘못된 종단점을 만들어 보실 수 있습니다.\n\n# 결론\n\n이 글에서 Bloc 및 Bloc 작업 메커니즘에 대해 설명했습니다. 필요에 맞게 코드를 조정하여 사용해 보세요. 새 페이지를 만들어 보는 것도 좋은 방법입니다. Bloc 아키텍처는 대규모 프로젝트에 매우 유용할 수 있습니다.\n\n이 블로그 게시물이 앞으로의 프로젝트에서 bloc 라이브러리와 아키텍처를 사용하는 데 충분한 중요한 정보를 제공해 줄 것을 바랍니다.\n\n<div class=\"content-ad\"></div>\n\n❤ ❤ 이 글 읽어주셔서 감사합니다 ❤ ❤\n\n만약 이 글을 좋아하셨다면 👏 두 번 치세요.\n\n또한, 업데이트되는 흥미로운 글과 프로젝트를 확인하려면 팔로우하세요.\n\n무엇인가 잘못된 점이 있다면? 댓글로 알려주세요. 개선해나가겠습니다.\n\n<div class=\"content-ad\"></div>\n\n# 함께 연결해요\n\n우리 친구가 되어요. 페이스북, 링크드인, 깃허브, 유튜브, BuyMeACoffee, 그리고 인스타그램에서 찾아요.\n\n방문하기: Flutter Junction\n\n기여하기: BuyMeACoffee\n\n<div class=\"content-ad\"></div>\n\n다음 링크에서 전체 코드를 확인하세요:","ogImage":{"url":"/assets/img/2024-06-21-FetchAPIWithBloCinFlutter_0.png"},"coverImage":"/assets/img/2024-06-21-FetchAPIWithBloCinFlutter_0.png","tag":["Tech"],"readingTime":10},{"title":"플러터에서 네이티브 코드와의 양방향 통신을 위한 메소드 채널 사용 방법","description":"","date":"2024-06-21 22:37","slug":"2024-06-21-MethodChannelinFlutterBridgingNativeCodeandFlutterwithTwo-WayCommunication","content":"\n\n플러터의 메소드 채널은 플러터와 플랫폼별 코드 간에 원활한 통신을 제공하는 강력한 메커니즘을 제공합니다. 이 블로그 포스트에서는 플러터에서 메소드 채널을 설정하고 네이티브 MainActivity.kt(Android) 및 AppDelegate.swift(iOS) 코드에서 데이터를 플러터 애플리케이션으로 반환하는 과정을 살펴보겠습니다. 함께 알아보겠습니다!\n\n플러터에서 메소드 채널 설정하기: 먼저, 플러터 프로젝트에 메소드 채널을 설정해 봅시다.\n\n- 의존성 추가: 플러터 프로젝트의 pubspec.yaml 파일에 flutter/services 패키지를 의존성으로 추가하세요:\n\n```js\ndependencies:\n  flutter:\n    sdk: flutter\n  flutter/services:\n    ^2.0.0\n```\n\n<div class=\"content-ad\"></div>\n\n- Method Channel 정의하기: 플러터 Dart 코드에서 Method Channel을 정의하세요:\n\n```js\nimport 'package:flutter/services.dart';\n\n// MethodChannel의 인스턴스 생성\nfinal MethodChannel platformChannel = MethodChannel('your_channel_name');\n```\n\nAndroid에서 Method Channel 통신 구현하기: 이제 Android 플랫폼에서 Method Channel 통신을 구현해 봅시다.\n\n- MainActivity.kt에서 메소드 호출 수신하기: MainActivity.kt 파일에서 onMethodCall 메소드를 오버라이드하여 Flutter로부터의 메소드 호출을 처리하고 데이터를 반환하세요:\n\n<div class=\"content-ad\"></div>\n\n```kotlin\nimport io.flutter.embedding.android.FlutterActivity\nimport io.flutter.embedding.engine.FlutterEngine\nimport io.flutter.plugin.common.MethodChannel\n\nclass MainActivity : FlutterActivity() {\n    private val CHANNEL = \"your_channel_name\"\n\n    override fun configureFlutterEngine(flutterEngine: FlutterEngine) {\n        super.configureFlutterEngine(flutterEngine)\n\n        // Set up the MethodChannel with the same name as defined in Dart\n        MethodChannel(flutterEngine.dartExecutor.binaryMessenger, CHANNEL).setMethodCallHandler { call, result ->\n            if (call.method == \"getDataFromNative\") {\n                // Perform platform-specific operations and obtain the result\n                val data = getDataFromNative()\n\n                // Send the result back to Flutter\n                result.success(data)\n            } else {\n                result.notImplemented()\n            }\n        }\n    }\n\n    private fun getDataFromNative(): String {\n        // Perform platform-specific operations to fetch the data\n        return \"Data from Native\"\n    }\n}\n```\n\niOS에서 Method Channel 통신 구현하기: 이제 iOS 플랫폼에서 메서드 채널 통신을 구현해봅시다.\n\n- AppDelegate.swift에서 메서드 호출 받기: AppDelegate.swift 파일에 아래 코드를 추가하여 Flutter에서의 메서드 호출을 처리하고 데이터를 반환합니다:\n\n```swift\nimport UIKit\nimport Flutter\n\n@UIApplicationMain\n@objc class AppDelegate: FlutterAppDelegate {\n    private let CHANNEL = \"your_channel_name\"\n\n    override func application(\n        _ application: UIApplication,\n        didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?\n    ) -> Bool {\n        // Set up the MethodChannel with the same name as defined in Dart\n        if let flutterViewController = window?.rootViewController as? FlutterViewController {\n            let methodChannel = FlutterMethodChannel(name: CHANNEL, binaryMessenger: flutterViewController.binaryMessenger)\n            methodChannel.setMethodCallHandler { [weak self] (call: FlutterMethodCall, result: FlutterResult) in\n                if call.method == \"getDataFromNative\" {\n                    // Perform platform-specific operations and obtain the result\n                    let data = self?.getDataFromNative()\n\n                    // Send the result back to Flutter\n                    result(data)\n                } else {\n                    result(FlutterMethodNotImplemented)\n                }\n            }\n        }\n\n        return super.application(application, didFinishLaunchingWithOptions: launchOptions)\n    }\n\n    private func getDataFromNative() -> String {\n        // Perform platform-specific operations to fetch the data\n        return \"Data from Native\"\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n플러터에서 네이티브로 데이터 전달 및 결과 반환하기: 이제 플러터에서 네이티브에 데이터를 전달하고 결과를 다시 플러터에서 받는 방법을 살펴봅시다.\n\n- 플러터에서 메소드 호출: 플러터 Dart 코드에서 플랫폼별 코드에서 메소드를 호출하고 결과를 처리하세요.\n\n```js\nvoid fetchDataFromNative() async {\n  try {\n    final String result = await platformChannel.invokeMethod('getDataFromNative');\n    print('Result from Native: $result');\n  } on PlatformException catch (e) {\n    print('Error: ${e.message}');\n  }\n}\n```\n\n결론: 축하합니다! 이제 플러터에서 메서드 채널을 성공적으로 설정했습니다. 이를 통해 플러터와 플랫폼별 코드 간의 양방향 통신이 가능해졌습니다. 이 블로그 포스트에서 안내된 단계와 코드 예제를 따라 하시면, 네이티브 기능을 쉽게 통합하고 네이티브 측에서 플러터 응용 프로그램으로 데이터를 반환할 수 있습니다. 실험하고 탐색하며, 메서드 채널의 강력한 기능을 활용하여 플러터 프로젝트의 무한한 가능성을 발견하세요. 즐거운 코딩되세요!","ogImage":{"url":"/assets/img/2024-06-21-MethodChannelinFlutterBridgingNativeCodeandFlutterwithTwo-WayCommunication_0.png"},"coverImage":"/assets/img/2024-06-21-MethodChannelinFlutterBridgingNativeCodeandFlutterwithTwo-WayCommunication_0.png","tag":["Tech"],"readingTime":5},{"title":"Flutter에서 백그라운드 서비스와 포어그라운드 서비스 사용 방법","description":"","date":"2024-06-21 22:36","slug":"2024-06-21-BackgroundandForegroundservicesinFlutter","content":"\n\n\n![그림](/assets/img/2024-06-21-BackgroundandForegroundservicesinFlutter_0.png)\n\n플러터의 백그라운드 및 포그라운드 서비스를 사용하면 앱이 활발히 실행되거나 활성화되어 있지 않을 때에도 백그라운드에서 작업을 수행할 수 있습니다. 이는 음악 재생, 인터넷에서 데이터 가져오기, 또는 사용자 경험을 방해하지 않고 장기간 실행되는 계산과 같은 작업을 포함합니다.\n\n패키지 추가: Flutter Background Service 문서 읽기를 클릭\n\n```js\n  flutter_background_service: 5.0.2\n  flutter_background_service_android: 6.1.0\n  flutter_background_service_ios: ^5.0.0\n``` \n\n\n<div class=\"content-ad\"></div>\n\n매니페스트에 다음 항목 추가해주세요.\n\n```js\n    <uses-permission android:name=\"android.permission.FOREGROUND_SERVICE\"/>\n    <uses-permission android:name=\"android.permission.FOREGROUND_SERVICE_LOCATION\"/>\n    <uses-permission android:name=\"android.permission.FOREGROUND_SERVICE_DATA_SYNC\"/>\n\n    <uses-permission android:name=\"android.permission.RECEIVE_BOOT_COMPLETED\"/>\n    <uses-permission android:name=\"android.permission.WAKE_LOCK\"/>\n```\n\n애플리케이션 태그 안에 다음을 추가해주세요.\n\n```js\n<service\n    android:name=\"id.flutter.flutter_background_service.BackgroundService\"\n    android:foregroundServiceType=\"location\"\n/>\n\n<service\n    android:enabled=\"true\"\n    android:exported=\"true\"\n    android:name=\".BackgroundService\"\n    android:stopWithTask=\"false\"\n/>\n\n<receiver\n    android:name=\".WatchdogReceiver\"\n    android:enabled=\"true\"\n    android:exported=\"true\"\n/>\n\n<receiver\n    android:name=\".BootReceiver\"\n    android:enabled=\"true\"\n    android:exported=\"true\">\n    <intent-filter>\n        <action android:name=\"android.intent.action.BOOT_COMPLETED\"/>\n        <action android:name=\"android.intent.action.QUICKBOOT_POWERON\"/>\n    </intent-filter>\n</receiver>\n```\n\n<div class=\"content-ad\"></div>\n\n다음은 main.dart에서 사용하세요:\n\n```js\nFuture<void> main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n  await initializeService();\n  runApp(const MyApp());\n}\n```\n\n```js\n/// Foreground 및 Background\nFuture<void> initializeService() async {\n  final service = FlutterBackgroundService();\n\n  await service.configure(\n    androidConfiguration: AndroidConfiguration(\n      onStart: onStart,\n      autoStart: false,\n      isForegroundMode: true,\n      // notificationChannelId: 'my_foreground',\n      // initialNotificationContent: 'running',\n      foregroundServiceNotificationId: 888,\n    ),\n    iosConfiguration: IosConfiguration(\n      autoStart: true,\n      onForeground: onStart,\n      onBackground: onIosBackground,\n    ),\n  );\n}\n```\n\nIOS용:\n\n<div class=\"content-ad\"></div>\n\n```dart\n@pragma('vm:entry-point')\nFuture<bool> onIosBackground(ServiceInstance service) async {\n  WidgetsFlutterBinding.ensureInitialized();\n  DartPluginRegistrant.ensureInitialized();\n  return true;\n}\n```\n\nAndroid용:\n\n```dart\n@pragma('vm:entry-point')\nvoid onStart(ServiceInstance service) async {\n  DartPluginRegistrant.ensureInitialized();\n  if (service is AndroidServiceInstance) {\n    service.on('setAsForeground').listen((event) {\n      service.setAsForegroundService();\n    });\n    service.on('setAsBackground').listen((event) {\n      service.setAsBackgroundService();\n    });\n  }\n  service.on('stopService').listen((event) {\n    service.stopSelf();\n  });\n\n  final FlutterLocalNotificationsPlugin flutterLocalNotificationsPlugin =\n      FlutterLocalNotificationsPlugin();\n\n  // // bring to foreground\n  Timer.periodic(const Duration(seconds: 1), (timer) async {\n    if (service is AndroidServiceInstance) {\n      if (await service.isForegroundService()) {\n        flutterLocalNotificationsPlugin.show(\n          0, 'This is foreground', '${DateTime.now()}',\n          const NotificationDetails(\n            android: AndroidNotificationDetails(\n              \"notificationChannelId\",\n              'MY FOREGROUND SERVICE',\n              icon: 'ic_bg_service_small',\n              ongoing: true,\n            ),\n          ),\n        );\n      }\n    }\n  });\n}\n```\n\n이 메서드는 어디서든 사용할 수 있습니다:\n\n\n<div class=\"content-ad\"></div>\n\n```js\r\nvoid backgroundService()async{\r\n  final service = FlutterBackgroundService();\r\n  var isRunning = await service.isRunning();\r\n  if (isRunning) {\r\n    Timer.periodic(const Duration(seconds: 1), (timer) async {\r\n      if (mounted) {\r\n        setState(() {\r\n          debugPrint(\"runningSanjay\");\r\n          CustomLoader.message(\"runningSanjay\");\r\n        });\r\n      }\r\n    });\r\n  } else {\r\n    service.startService();\r\n  }\r\n  setState(() {});\r\n}\r\n```\r\n\r\n전체 코드:\r\n\r\n```js\r\nimport 'dart:async';\r\nimport 'dart:convert';\r\nimport 'dart:io';\r\nimport 'dart:ui';\r\nimport 'package:flutter_background_service/flutter_background_service.dart';\r\nimport 'package:flutter_background_service_android/flutter_background_service_android.dart';\r\n\r\nFuture<void> main() async {\r\n  WidgetsFlutterBinding.ensureInitialized();\r\n  await initializeService(); \r\n  runApp(const MyApp());\r\n}\r\n\r\n/// Foreground and Background\r\nFuture<void> initializeService() async {\r\n  final service = FlutterBackgroundService();\r\n  await service.configure(\r\n    androidConfiguration: AndroidConfiguration(\r\n      onStart: onStart,\r\n      autoStart: false,\r\n      isForegroundMode: true,\r\n      // notificationChannelId: 'my_foreground',\r\n      // initialNotificationContent: 'running',\r\n      foregroundServiceNotificationId: 888,\r\n    ),\r\n    iosConfiguration: IosConfiguration(\r\n      autoStart: true,\r\n      onForeground: onStart,\r\n      onBackground: onIosBackground,\r\n    ),\r\n  );\r\n}\r\n\r\n@pragma('vm:entry-point')\r\nFuture<bool> onIosBackground(ServiceInstance service) async {\r\n  WidgetsFlutterBinding.ensureInitialized();\r\n  DartPluginRegistrant.ensureInitialized();\r\n  return true;\r\n}\r\n\r\n@pragma('vm:entry-point')\r\nvoid onStart(ServiceInstance service) async {\r\n  DartPluginRegistrant.ensureInitialized();\r\n  if (service is AndroidServiceInstance) {\r\n    service.on('setAsForeground').listen((event) {\r\n      service.setAsForegroundService();\r\n    });\r\n    service.on('setAsBackground').listen((event) {\r\n      service.setAsBackgroundService();\r\n    });\r\n  }\r\n  service.on('stopService').listen((event) {\r\n    service.stopSelf();\r\n  });\r\n\r\n  final FlutterLocalNotificationsPlugin flutterLocalNotificationsPlugin = \r\n  FlutterLocalNotificationsPlugin();\r\n  // bring to foreground\r\n  Timer.periodic(const Duration(seconds: 1), (timer) async {\r\n    if (service is AndroidServiceInstance) {\r\n      if (await service.isForegroundService()) {\r\n        CustomLoader.message(\"foreground\");\r\n        flutterLocalNotificationsPlugin.show(\r\n          0, 'COOL SERVICE', 'Awesome ${DateTime.now()}',\r\n          const NotificationDetails(\r\n            android: AndroidNotificationDetails(\r\n              \"notificationChannelId\",\r\n              'MY FOREGROUND SERVICE',\r\n              icon: 'ic_bg_service_small',\r\n              ongoing: true,\r\n            ),\r\n          ),\r\n        );\r\n      }\r\n    }\r\n  });\r\n}\r\n\r\nclass MyApp extends StatefulWidget {\r\n  const MyApp({Key key}) : super(key: key);\r\n  @override\r\n  State<MyApp> createState() => _MyAppState();\r\n}\r\n\r\nclass _MyAppState extends State<MyApp>{\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return MaterialApp(\r\n      debugShowCheckedModeBanner: false,\r\n      theme: ThemeData(\r\n          scaffoldBackgroundColor: Colors.white,\r\n          inputDecorationTheme: const InputDecorationTheme(\r\n            focusedBorder: UnderlineInputBorder(\r\n                borderSide: BorderSide(color: Colors.blue)\r\n            ),\r\n          )),\r\n      home:  Container(\r\n        color: Colors.white,\r\n        child:  Center(\r\n            child: Text(\"This is foreground service app\"),\r\n        ),\r\n      ),\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n<img src=\"/assets/img/2024-06-21-BackgroundandForegroundservicesinFlutter_1.png\" />\r\n\n\n<div class=\"content-ad\"></div>\n\n이 기사를 즐겁게 읽으셨기를 바랍니다! 제공된 정보를 감사히 여기신다면 'Buy Me A Coffee'로 저를 지원할 수 있습니다! 여러분의 제스처에 감사드립니다!","ogImage":{"url":"/assets/img/2024-06-21-BackgroundandForegroundservicesinFlutter_0.png"},"coverImage":"/assets/img/2024-06-21-BackgroundandForegroundservicesinFlutter_0.png","tag":["Tech"],"readingTime":8},{"title":"Flutter로 작성된 모바일 앱인지 확인하는 방법","description":"","date":"2024-06-21 22:34","slug":"2024-06-21-HowtoDetermineifaMobileAppisWritteninFlutter","content":"\n\n안녕하세요, Flutter 팬 여러분들! 오늘은 모바일 앱이 Flutter로 작성되었는지 확인하는 방법에 대해 이야기해보겠습니다. 이 지식은 경쟁 조사를 위해 개발자와 매니저들에게 유용하며, 자신이 좋아하는 앱의 내부를 더 알고 싶어하는 기술 애호가들에게도 도움이 될 수 있습니다. 그래서, 더 이상 말뿐인 소리는 그만하고 시작해봅시다.\n\n# 부드러운 인터페이스와 복잡한 애니메이션\n\n- 복잡성: 1\n- 정확성: 2\n\nFlutter는 부드럽고 아름다운 인터페이스를 만들어내는 능력으로 유명합니다. 만약 예상치 못한 아름다움과 부드러움을 발견한다면, 그것이 Flutter 앱일 수 있습니다. 그러나, 좋은 디자인과 애니메이션 부드러움은 다른 프레임워크로도 구현할 수 있기 때문에 이것은 단지 많은 조직 중 하나에 불과합니다. 반면, 앱이 끊기는 애니메이션과 오랜 응답 시간을 보인다면, 그 또한 Flutter 앱일 수 있습니다. 대부분, 개발자들이 이 앱에 큰 노력을 기울이지 않았거나, 클라이언트가 비용을 줄이기로 결정했을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 두 손가락 스크롤링 속도가 두 배 빨라졌어요\n\n- 복잡도: 1\n- 정확도: 3\n\nFlutter 앱에서는 네이티브 앱과 비교했을 때 두 손가락으로 스크롤링 하는 것이 두 배 빨라집니다. 게다가, 세 손가락 스크롤링은 세 배 빠릅니다. 그러나 Flutter 개발자들은 항상 개선해 나가는 중이며, 최근에 이 \"버그\"를 수정했기 때문에 이 방법은 이전만큼 신뢰할 수 없을 수도 있습니다.\n\n# 공식 Flutter 페이지에 피처된 앱들\n\n<div class=\"content-ad\"></div>\n\n- 복잡도: 1\n- 정확성: 5\n\n가장 신뢰할 수 있는 방법은 공식 플러터 페이지를 확인하는 것입니다. 그곳에는 플러터로 개발된 앱들의 모음을 볼 수 있습니다.\n\n![이미지](/assets/img/2024-06-21-HowtoDetermineifaMobileAppisWritteninFlutter_0.png)\n\n# 온라인 서비스 플러터헌트\n\n<div class=\"content-ad\"></div>\n\n- 복잡도: 1\n- 정확도: 4\n\nFlutterHunt은 Flutter로 개발된 앱에 대한 정보를 수집하는 온라인 데이터베이스입니다. 그런데 이 서비스의 제작자와 채팅할 수도 있어요.\n\n![이미지](/assets/img/2024-06-21-HowtoDetermineifaMobileAppisWritteninFlutter_1.png)\n\n# 플러터 상어 앱\n\n<div class=\"content-ad\"></div>\n\n- 복잡성: 1\n- 정확성: 4\n\n네, 다른 앱이 플러터를 사용하는지 여부를 결정하는 데 전용 앱이 있습니다! 기기에 설치된 앱을 분석하고 해당 앱이 플러터로 개발되었는지 식별합니다. 신기하게도, 플러터 Shark는 플러터로 작성되었습니까?\n\n![이미지](/assets/img/2024-06-21-HowtoDetermineifaMobileAppisWritteninFlutter_2.png)\n\n# 개발 속도 및 통합 코드베이스\n\n<div class=\"content-ad\"></div>\n\n- 복잡도: 3\n- 정확성: 2\n\n플러터를 사용하면 Android와 iOS용 앱을 생성하는 데 동일한 코드를 사용할 수 있어 개발 프로세스를 크게 가속화할 수 있습니다. 한 회사가 새로운 기능을 두 플랫폼에서 동시에 빠르게 출시한다면, 그들은 플러터를 사용하고 있을 수도 있습니다.\n\n# 개발자 메뉴에서 \"레이아웃 경계 표시\" 활성화하기\n\n- 복잡도: 4\n- 정확성: 4\n\n<div class=\"content-ad\"></div>\n\n이 방법은 강력한 중급 개발자를 대상으로 합니다. 안드로이드 개발자 설정에서 \"레이아웃 경계 표시\" 옵션을 활성화하여 인터페이스 요소의 경계를 볼 수 있습니다. 플러터 앱은 자체 렌더링 메커니즘이 있기 때문에 네이티브 앱과 달리 인터페이스 요소에는 경계가 없습니다.\n\n## 안드로이드 개발자 메뉴에서 \"레이아웃 경계 표시\"를 활성화하는 방법:\n\n단계 1: 개발자 모드 활성화\n\n- 안드로이드 기기의 설정을 엽니다.\n- 아래로 내려 \"휴대폰 정보\"를 찾습니다.\n- 빌드 번호를 찾습니다 (소프트웨어 정보 또는 휴대폰 정보 섹션에 있을 수 있습니다).\n- 빌드 번호를 7번 탭합니다. \"개발자가 되고 있습니다\"라는 메시지가 표시됩니다.\n\n<div class=\"content-ad\"></div>\n\n**단계 2: 레이아웃 바운드 보기 활성화**\n\n- 메인 설정 메뉴로 돌아갑니다.\n- 개발자 모드를 활성화한 후 나타난 \"개발자용\" 또는 \"개발자 옵션\" 항목으로 스크롤합니다.\n- \"개발자 옵션\"을 선택합니다.\n- \"디버깅\" 또는 \"시각화\" 섹션으로 스크롤합니다.\n- \"레이아웃 바운드 보기\" 또는 \"레이아웃 테두리 표시\" 옵션을 찾아 활성화합니다.\n\n# 디버깅 정보 및 개발자 도구\n\n- 복잡성: 5\n- 정확도: 5\n\n<div class=\"content-ad\"></div>\n\n진짜 고급 사용자를 위한 방법을 찾아왔어요. Flutter 앱은 작동 방식과 시스템과의 상호 작용에 따라 구별될 수 있는 특정 특성이 있어요. 디버깅 중에 접근할 수 있어요. Android Studio와 Visual Studio Code를 사용하면 애플리케이션의 라이프사이클, 시스템과의 상호 작용 및 기타 기술적 측면을 관찰할 수 있어요.\n\n## 다음은 방법이에요:\n\n- 기기를 컴퓨터에 연결하세요. 기기의 개발자 모드가 활성화되어 있고 USB 디버깅이 허용되어 있는지 확인하세요.\n- 즐겨 사용하는 코드 편집기를 열어주세요. Flutter와 Dart 플러그인이 설치된 Android Studio 또는 Visual Studio Code를 시작하세요.\n- ADB (Android Debug Bridge)를 시작하세요. 터미널이나 명령 프롬프트를 열고 adb devices 명령을 입력하여 기기가 연결되어 있는지 확인하세요.\n- 애플리케이션을 기기에서 시작하세요. 기기에서 원하는 Flutter 앱을 열어주세요.\n- Android Studio에서 Logcat을 엽니다. Android Studio에서는 화면 하단의 \"Logcat\" 탭을 선택하세요. Visual Studio Code에서는 통합 터미널을 사용하여 해당 명령을 실행하여 로그를 볼 수 있어요.\n- 로그 출력을 애플리케이션 식별자로 필터링하세요.\n- Flutter 및 Dart VM에 대한 언급을 찾아보세요. Flutter 앱을 시작하고 실행할 때, 로그에 Dart VM 또는 Flutter Engine과 관련된 메시지가 표시될 수 있어요.\n- 이 방법은 Flutter를 사용하여 개발된 앱을 확인하는 가장 신뢰할 수 있는 방법 중 하나에요.\n\n# APK 파일 분석\n\n<div class=\"content-ad\"></div>\n\n- 복잡성: 666\n- 정확도: 5\n\n이전 방법들이 만족스럽지 않다면, APK를 언패킹하여 애플리케이션을 심층적으로 탐색해볼 수 있습니다.\n\n## 단계별로:\n\n- 애플리케이션의 APK를 다운로드합니다. 다양한 온라인 서비스나 도구를 사용하여 Google Play Store에서 APK를 직접 다운로드할 수 있습니다.\n- APK를 \"언팩\"할 도구를 사용합니다. 이 작업에 대한 인기 있는 도구 중 하나는 APKTool이며, APK를 디컴파일하고 내용을 확인할 수 있는 다른 유사한 도구도 사용할 수 있습니다.\n- libflutter.so 및 kernel_blob.bin 파일을 찾습니다. 디컴파일된 APK를 열고 ./lib/ 및 ./assets/flutter_assets/ 디렉토리를 찾아봅니다.\n\n<div class=\"content-ad\"></div>\n\n## 왜 이것이 동작하는지:\n\n- libflutter.so는 안드로이드에서 Dart 코드를 로드하고 실행하는 데 사용되는 Flutter 전용 라이브러리입니다.\n- kernel_blob.bin은 애플리케이션의 컴파일된 Dart 코드를 포함하고 있습니다.\n\n이 방법은 좀 더 기술적인 지식이 필요하며, 진정한 엔지니어를 위한 것입니다.\n\n이 방법은 Alexandra Kovaleva가 제안했으며, 그녀에게 특별한 감사의 말씀을 전합니다.\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n그게 다야! 이 방법들이 플러터의 세계에 대해 더 많이 알게 해주고 당신에게 자극을 주어 여러분만의 프로젝트를 만들게 하는 데 도움이 되길 바랍니다.\n\n흥미롭고 유용하다면, 링크드인과 X(트위터)에서 저와 함께하세요.","ogImage":{"url":"/assets/img/2024-06-21-HowtoDetermineifaMobileAppisWritteninFlutter_0.png"},"coverImage":"/assets/img/2024-06-21-HowtoDetermineifaMobileAppisWritteninFlutter_0.png","tag":["Tech"],"readingTime":5},{"title":"Flutter로 코드 생성하기  source_gen과 build_runner 사용 방법","description":"","date":"2024-06-21 22:30","slug":"2024-06-21-CodeGenerationusingFluttersource_genbuild_runner","content":"\n\n![2024-06-21-CodeGenerationusingFluttersource_genbuild_runner_0.png](/assets/img/2024-06-21-CodeGenerationusingFluttersource_genbuild_runner_0.png)\n\n최근에는 전문적인 플러터 개발자로서 매일 개발 프로세스 중에 시간이 오래 걸리고 실수할 가능성이 있는 일상적인 반복 작업을 더 나은 방법과 안전한 방법으로 수행하고 싶었을 것입니다. 그러한 프로세스는 코드 생성입니다. 진보를 이루는 데 핵심은 효율성을 극대화하는 데 있습니다. 반복적인 작업은 지루하고 단조로운 성질 때문에 보편적으로 싫어하는데, 이러한 활동에서 사람들은 주목할 만큼 비효율적이며 종종 오류를 범합니다.\n\n코드 생성은 특정 입력 데이터나 규칙을 기반으로 자동으로 코드를 생성하는 기술입니다. Flutter에서 코드 생성은 JSON 데이터, 데이터베이스 및 웹 서비스와 같은 다양한 목적으로 사용됩니다. 코드 생성은 반복적인 작업을 자동화하고 필요한 수동 코딩량을 줄임으로써 코드 작성과 유지를 쉽게 할 수 있습니다.\n\n코드 생성기를 사용하는 많은 패키지들이 있습니다. json_serializable과 같은 패키지의 예시를 살펴보겠습니다. 이 패키지는 우리에게 fromJson, toJson과 같은 메서드를 생성하는 데 사용되는 일련의 주석을 제공하여, 해당 함수를 생성하려는 행에 주석을 넣기만 하면 이러한 메서드를 자동으로 생성합니다.\n\n<div class=\"content-ad\"></div>\n\n예시:\n\n\n| First Header  | Second Header |\n| ------------- | ------------- |\n| Content Cell  | Content Cell  |\n| Content Cell  | Content Cell  |\n\n\n<div class=\"content-ad\"></div>\n\n이 글에서는 사용자 정의 주석 및 생성기를 생성하여 주석이 달린 클래스에 대해 fromJson, toJson 및 copyWith 메서드를 생성하는 방법을 배우겠습니다.\n\n우리가 자체 코드 생성기를 만들기 위해 필요한 패키지는 무엇인가요?\n\n- source_gen | Dart 패키지 (pub.dev)\n- build_runner | Dart 패키지 (pub.dev)\n\n## source_gen\n\n<div class=\"content-ad\"></div>\n\nAPI는 낮은 수준의 빌드 또는 분석기 패키지와 상호 작용 없이 코드를 생성하는 데 도움이 되는 다양한 유틸리티를 제공합니다. 이는 여러분의 삶을 훨씬 쉽게 만들어 줄 것입니다.\n\nsource_gen 패키지는 build 패키지의 확장판입니다. Dart 소스 코드 생성을 더 쉽게 만드는 일련의 유틸리티가 포함되어 있습니다.\n\n## build_runner\n\n이 패키지를 사용하면 생성기를 실행할 수 있습니다. 이는 개발 단계에서만 사용되는 dev_dependency 영역에 있을 것이므로 개발 단계에서만 사용할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n우리는 다음 명령어를 실행하여 코드를 생성할 수 있어요:\n\n```dart\ndart run build_runner `command`\n```\n\n사용할 수 있는 명령어는 다음과 같아요:\n\n- build: 하나의 빌드를 실행하고 종료합니다.\n- watch: 파일 시스템을 감시하는 지속적인 빌드 서버를 실행하며 필요 시 다시 빌드합니다.\n- serve: watch와 동일하지만 개발 서버도 실행합니다.\n\n<div class=\"content-ad\"></div>\n\n# 예시\n\nGitHub에서 스타터 프로젝트를 다운로드하거나 수동으로 생성할 수 있습니다.\n\n스타터 프로젝트에는 세 개의 프로젝트가 포함되어 있습니다:\n\n- 예시: 이는 플러터 애플리케이션입니다. 이 애플리케이션은 생성기 코드를 테스트하는 데 사용됩니다.\n- 어노테이션: 이는 플러터 패키지입니다. 이는 어노테이션을 포함하고 있으며, 생성기는 이를 사용하여 처리할 클래스를 인식합니다.\n- 생성기: 이는 플러터 패키지입니다. 이 패키지에는 우리의 어노테이션에 의해 주석 처리된 코드를 방문하고 이를 위해 코드를 생성하는 코드 생성기가 포함되어 있습니다.\n\n<div class=\"content-ad\"></div>\n\n시작해보세요. Custom Gen이라는 디렉토리를 만들고 터미널에서 열어서 다음을 입력하세요:\n\ncode .\n\n그럼 VS Code가 열릴 거에요.\n\n## 예제 프로젝트\n\n<div class=\"content-ad\"></div>\n\nCtrl + Shift + p를 눌러 Flutter: New Project를 선택한 다음 Application을 선택하고 example로 이름을 지어주세요.\n\n## annotations 프로젝트\n\n터미널에서 Custom Gen 폴더를 열기 위해 이전과 같은 단계를 따라주세요.\n\nCtrl + Shift + p를 눌러 Flutter: New Project를 선택한 다음 Package를 선택하고 annotation으로 이름을 지어주세요.\n\n<div class=\"content-ad\"></div>\n\n## generators 프로젝트\n\n터미널에서 이미지와 같이 'Custom Gen' 폴더를 열기 위해 이전과 같은 단계를 수행합니다.\n\nCtr + Shift + p를 눌러 Flutter: New Project를 선택하고 Package를 선택한 후 generator라고 이름을 지정하세요.\n\n이제 이미지와 같이 세 개의 프로젝트가 생성됩니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-21-CodeGenerationusingFluttersource_genbuild_runner_1.png\" />\n\n# 주석 프로젝트\n\n주석이 무엇인가요?\n\nFlutter에서 주석은 Dart 코드에 포함하여 도구나 라이브러리에 추가 정보를 전달하는 특별한 표식이거나 지시문입니다. 주석은 build_runner 및 코드 생성기와 같은 도구에 대한 힌트로 작용하여 주석이 달린 코드와 관련된 특정 작업이나 동작을 나타냅니다.\n\n<div class=\"content-ad\"></div>\n\nannotations/lib에 src 폴더를 만들어서 생성자에 의해 사용될 주석 파일을 포함시킬 것입니다.\n\nannotations/lib/annotations.dart와 annotations/test/annotations_test.dart의 예제 코드를 제거할 것입니다.\n\nsrc 폴더에 acustom_annotation.dart 파일을 생성하여 주석을 작성할 것입니다. 이 주석은 CustomAnnotation으로 명명되었습니다.\n\n```dart\n// 우리의 주석\nclass CustomAnnotation {\n  const CustomAnnotation();\n}\n\n// 이 변수는 코드를 생성하기 위한 주석으로 사용될 것입니다.\nconst customAnnotation = CustomAnnotation();\n```\n\n<div class=\"content-ad\"></div>\n\nannotations.dart 파일에서 CustomAnnotation을 export할 것입니다:\n\n```js\nlibrary annotations;\n\nexport 'src/custom_annotation.dart';\n```\n\n다른 곳에서 이 주석 라이브러리를 사용하려면 각 파일을 개별적으로 호출하는 대신 annotations.dart를 import하기만 하면 됩니다.\n\n좋아요! 이제 당신은 당신의 어노테이션을 만들었습니다. 축하해요. 🎉🎉\n\n<div class=\"content-ad\"></div>\n\n# 제너레이터 프로젝트\n\n먼저 generators/generators.dart 파일과 generators/test/generators_test.dart 파일의 초기 코드를 제거하세요.\n\n그런 다음 generators/pubspec.yaml 파일에 몇 가지 종속성을 추가해야 합니다:\n\n```js\ndependencies:\n  flutter:\n    sdk: flutter\n  \n  build:\n  source_gen:\n\n  # Our annotation\n  annotations:\n    path: ../annotations/\n\ndev_dependencies:\n  flutter_test:\n    sdk: flutter\n\n  build_runner:\n  flutter_lints: ^2.0.0\n```\n\n<div class=\"content-ad\"></div>\n\n태그를 Markdown 형식으로 변경하고 다음 명령을 실행하세요: flutter pub get.\n\n- build: 이 패키지는 변수, 메소드 및 생성자와 같은 다양한 클래스 구성요소에 액세스하여 클래스를 검사하는 것을 가능하게 합니다.\n- source_gen: analyzer 또는 build와 같은 하위 수준 패키지 위에 있는 API입니다. source_gen을 사용하여 소스 코드를 생성할 필요는 없습니다. 또한 제너레이터에 유용할 수 있는 일련의 라이브러리 API를 노출합니다.\n- annotations: 이전에 작성된 annotation입니다.\n- build_runner: 주석이 달린 클래스에서 코드를 생성합니다.\n\nflutter pub get을 실행하는 중에 이와 같은 오류가 발생할 수 있습니다:\n\nPublishable packages can’t have ‘path’ dependencies.\nTry adding a publish_to: none entry to mark the package as not for publishing or remove the path dependency.\n\n<div class=\"content-ad\"></div>\n\n이 작업은 필요합니다. 왜냐하면 패키지를 Dart Dev에 업로드할 계획이라면 경로가 올바르지 않을 수 있습니다. 따라서 pubspec.yaml에서 이 예제가 실제 업로드된 패키지가 아닌 것을 명시해야 합니다. 다음 코드를 pubspec.yaml에 추가해주세요:\n\n```js\nname: generator\ndescription: A new Flutter package project.\nversion: 0.0.1\nhomepage:\npublish_to: none # <- 이 코드를 추가하여 이 패키지가 Dart Dev에 게시되지 않도록 설정\n```\n\n## build.yaml 구성하기\n\nbuild.yaml 파일은 build_runner에 의해 수행되는 코드 생성 프로세스의 설정과 구성을 지정하는 구성 파일입니다. 이 파일은 build_runner에 의해 호출되어 모든 생성기 구성을 읽기 전에 기능을 설정하며 Dart 빌드 시스템의 일부이며 Flutter 프로젝트에서 코드 생성 라이브러리를 사용할 때 생성기를 구성하는 용도로 사용됩니다. 생성된 파일의 확장자, 생성된 메서드, 생성기의 경로와 같은 설정을 지정하는 중요한 파일입니다.\n\n<div class=\"content-ad\"></div>\n\n지금, 제너레이터 패키지 루트에 build.yaml 파일을 만들어서 다음 코드를 입력해주세요:\n\n```js\ntargets:\n  $default:\n    builders:\n      generators|annotations: # generators|annotations: 주석이 달린 파일을 다룰 때 simple_generator 빌더를 사용한다는 것을 의미합니다.\n        enabled: true\n\nbuilders:\n  generators:\n    target: \":generators\" # 제너레이터 이름\n    import: \"package:generators/generators.dart\"\n    builder_factories: [\"generateJsonMethods\"] # 빌더 이름(BuilderOption)의 정의입니다.\n    build_extensions: { \".dart\": [\".g.dart\"] }\n    auto_apply: dependents\n    build_to: cache\n    applies_builders: [\"source_gen|combining_builder\"]\n```\n\n1- import: 제너레이터 경로를 결정합니다.\n\n2- builder_factories: 빌더 메서드의 이름을 나열합니다. 이 경우, \"generateJsonMethods\"라는 단일 팩토리를 포함하며 빌더를 반환합니다.\n\n<div class=\"content-ad\"></div>\n\n3- build_extensions: 빌더의 입력 및 출력 파일 확장자를 정의합니다. 이는 빌더가 .dart 파일을 처리하고 .g.part '(.g.part) 파일을 생성함을 나타냅니다. 이는 build.yaml 파일의 auto_apply 키에 기반하여 파일의 가시성을 제어합니다.\n\n4- auto_apply: 특정 빌더가 빌드 프로세스 중 자동으로 적용되어야 하는 시점을 지정하는 데 사용됩니다.\n\nauto_apply 옵션에는 여러 가지 가능한 값이 있습니다:\n\n- none: 빌더가 자동으로 적용되지 않습니다. 빌더를 명시적으로 builders 섹션에 지정하거나 build_runner 명령을 --build-filter 옵션과 함께 사용해야 합니다.\n- dependents: 빌더가 build.yaml 파일을 포함하는 패키지에 의존하는 패키지에 자동으로 적용됩니다. 이는 다른 패키지가 귀하의 패키지에 의존하는 경우 해당 빌더가 해당 의존 패키지에도 적용됨을 의미합니다.\n- all_packages: 의존성 여부에 관계없이 모든 패키지에 빌더가 자동으로 적용됩니다. 이 옵션은 드물며, 모든 패키지에 빌더가 필요하지 않은 경우 빌드 시간이 증가할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n5- build_to: 코드 생성에서 생성된 파일이 배치되어야 하는 디렉토리를 지정합니다.\n\n다음은 build_to에 대한 일반적인 값들입니다:\n\n- source: 이는 생성된 파일이 소스 파일과 동일한 디렉토리에 배치됨을 의미합니다. 소스 파일이 lib/src에 있으면 생성된 파일도 lib/src에 배치됩니다.\n- cache: 이는 생성된 파일이 빌드 캐시 디렉토리에 배치됨을 의미합니다. 빌드 캐시는 빌드 성능을 향상시키기 위해 build_runner가 관리하는 디렉토리입니다.\n\n# 생성기 생성\n\n<div class=\"content-ad\"></div>\n\n이제 build.yaml 파일을 구성한 후, 코드 생성을 위한 모든 파일 및 구현체를 생성할 것입니다.\n\n이 단계에서는 방문자(visitor) 클래스를 만들 것입니다; 이는 생성된 코드를 위해 생성자, 필드, 함수 등 모든 클래스 요소에 액세스하는 데 도움을 줍니다.\n\n## 모델 방문자\n\nlib/src 에 model_visitor.dart 파일을 만든 후, 다음 import 문을 사용할 것입니다:\n\n<div class=\"content-ad\"></div>\n\n\n```dart\nimport 'package:analyzer/dart/element/element.dart';\nimport 'package:analyzer/dart/element/visitor.dart';\n```\n\nThe first import comes from analyzer because both source_gen and build export it.\n\nCreate a ModelVisitor class and extend from SimpleElementVisitor:\n\n```dart\nclass ModelVisitor extends SimpleElementVisitor<void>{\n\n}\n```\n\n\n<div class=\"content-ad\"></div>\n\nSimpleElementVisitor에는 클래스를 검사하는 데 도움이 되는 여러 메서드가 포함되어 있습니다:\n\n- visitFieldElement 메서드.\n- visitConstructorElement 메서드.\n- visitFunctionElement 메서드.\n\nSimpleElementVisitor 클래스로 이동하여 클래스를 검사하는 데 유용한 모든 메서드를 살펴볼 수 있지만, 우리의 경우 visitConstructorElement 메서드를 사용하여 클래스 이름을 가져오고 visitFunctionElement 메서드를 사용하여 클래스의 모든 필드를 가져올 것입니다.\n\nmodel_visitor.dart 파일의 전체 코드:\n\n<div class=\"content-ad\"></div>\n\n```dart\nimport 'package:analyzer/dart/element/element.dart';\nimport 'package:analyzer/dart/element/visitor.dart';\n\n// 단계 1\nclass ModelVisitor extends SimpleElementVisitor<void> {\n// 단계 2\n  String className = '';\n  Map<String, dynamic> fields = {};\n\n// 단계 3\n  @override\n  void visitConstructorElement(ConstructorElement element) {\n    final String returnType = element.returnType.toString();\n// 단계 4\n    className = returnType.replaceAll(\"*\", \"\"); // ClassName* -> ClassName\n  }\n\n// 단계 5\n  @override\n  void visitFieldElement(FieldElement element) {\n    /*\n    {\n      name: String,\n      price: double\n    }\n     */\n\n// 단계 6\n    String elementType = element.type.toString().replaceAll(\"*\", \"\");\n    fields[element.name] = elementType;\n\n  }\n}\n```\n\n단계 1: SimpleElementVisitor 클래스를 상속받은 ModelVisitor 클래스로 확장함으로써 클래스 필드, 생성자 및 함수에 대한 다양한 유용한 메서드에 액세스할 수 있습니다.\n\n단계 2: className 변수를 정의하여 클래스 이름을 저장하고, fields 변수를 정의하여 모든 클래스 필드를 저장합니다.\n\n단계 3: 이 오버라이드된 메서드는 클래스 생성자를 방문하고 element.returnType을 통해 클래스 이름을 검색할 수 있도록 합니다.\n\n\n<div class=\"content-ad\"></div>\n\n단계 4: element.returnType은 원소 유형 뒤에 '*'을 반환하므로 이를 제거합니다.\n\n단계 5: 이 방법은 클래스의 각 필드에 대해 호출되며, 필드 이름과 필드 유형에 모두 액세스할 수 있습니다.\n\n또한 더 많은 속성에 액세스할 수 있습니다.\n\n단계 6: element.type은 원소 유형 뒤에 '*'을 반환하므로 이를 제거합니다.\n\n<div class=\"content-ad\"></div>\n\n## 생성기\n\nlib/src에 json_generator.dart라는 파일을 생성하세요:\n\n```dart\nimport 'package:annotations/annotations.dart';\nimport 'package:source_gen/source_gen.dart';\n\nclass JsonGenerator extends GeneratorForAnnotation<CustomAnnotation> {\n  // 이곳에 코드를 생성하는 메서드를 작성하세요!\n}\n```\n\n이 파일은 생성기의 진입점을 나타냅니다. dart run build_runner build 명령을 실행한 후, build_runner은 먼저 build.yaml 파일을 확인합니다. 이후 예제 파일을 모두 스캔하고, 어노테이션이 존재하면 이 클래스가 인지하고, 상기 생성기 클래스의 재정의된 기능을 실행하도록 합니다.\n\n<div class=\"content-ad\"></div>\n\ngenerateForAnnotatedElement을 오버라이드할 거에요. 이 메서드는 element를 인자로 받아요. 이 경우에는 클래스가 될 거예요. 이 간단한 예시에서는 다른 매개변수가 필요하지 않아요. 이 메서드는 생성된 코드를 나타내는 String 타입을 반환할 거에요.\n\n```js\nclass JsonGenerator extends GeneratorForAnnotation<CustomAnnotation> {\n  @override\n  String generateForAnnotatedElement(\n    Element element, // 이 경우에는 클래스를 나타냅니다.\n    ConstantReader annotation,\n    BuildStep buildStep,\n  ) {\n  }\n}\n```\n\n이 클래스가 생성기의 진입점이므로 ModelVisitor 클래스를 활용하여 주석이 달린 클래스의 모든 필드와 생성자를 가져올 거에요.\n\n```js\nclass JsonGenerator extends GeneratorForAnnotation<CustomAnnotation> {\n  @override\n  String generateForAnnotatedElement(\n    Element element,\n    ConstantReader annotation,\n    BuildStep buildStep,\n  ) {\n    final ModelVisitor visitor = ModelVisitor();\n    // 클래스의 필드와 생성자를 방문한 후, visitor의 className과 fields 변수에 값이 들어갈 거에요.\n    element.visitChildren(visitor);\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n클래스 이름과 필드를 가져온 후에는, `fromJson`, `toJson`, 그리고 `copyWith` 메서드를 생성하는 코드를 작성해봅시다.\n\n## fromJson 메서드\n\n- 생성된 메서드 예시:\n\n```js\n// From Json Method\nProduct _$ProductFromJson(Map<String, dynamic> json) => Product(\n      name: json['name'],\n      price: json['price'],\n    );\n```\n\n<div class=\"content-ad\"></div>\n\n- 위 예시를 생성하는 함수:\n\n```js\n// fromJSon 메소드를 생성하는 메서드\nString generateFromJsonMethod(ModelVisitor visitor) {\n  // 모델 방문자로부터 클래스 이름을 받아옴\n  String className = visitor.className;\n\n  // 생성된 클래스의 각 부분을 쓰기 위한 버퍼\n  final buffer = StringBuffer();\n\n  // --------------------fromJson 생성 코드 시작--------------------//\n  buffer.writeln('// From Json 메소드');\n  buffer.writeln(\n      '$className _\\$${className}FromJson(Map<String, dynamic> json) => ');\n  buffer.write('$className(');\n\n  for (int i = 0; i < visitor.fields.length; i++) {\n    String fieldName = visitor.fields.keys.elementAt(i);\n    String mapValue = \"json['$fieldName']\";\n\n    buffer.writeln(\n      \"${visitor.fields.keys.elementAt(i)}: $mapValue,\",\n    );\n  }\n  buffer.writeln(');');\n  buffer.toString();\n  return buffer.toString();\n  // --------------------fromJson 생성 코드 종료--------------------//\n}\n```\n\n## toJson 메소드\n\n- 생성된 메소드 예시:\n\n<div class=\"content-ad\"></div>\n\n```js\n// JSON으로 변환하는 메소드\nMap<String, dynamic> _$ProductToJson(Product instance) => <String, dynamic>{\n      'name': instance.name,\n      'price': instance.price,\n    };\n```\n\n- 위 예시를 생성하는 함수:\n\n```js\n// fromJSon 메소드를 생성하는 메소드\nString generateToJsonMethod(ModelVisitor visitor) {\n  // 모델 비지터에서 클래스 이름 가져오기\n  String className = visitor.className;\n\n  // 생성된 클래스 각 부분을 작성할 버퍼\n  final buffer = StringBuffer();\n\n  // --------------------toJson 생성 코드 시작--------------------//\n  buffer.writeln('// JSON으로 변환하는 메소드');\n  buffer.writeln(\n      'Map<String, dynamic> _\\$${className}ToJson($className instance) => ');\n  buffer.write('<String, dynamic>{');\n  for (int i = 0; i < visitor.fields.length; i++) {\n    String fieldName = visitor.fields.keys.elementAt(i);\n    buffer.writeln(\n      \"'$fieldName': instance.$fieldName,\",\n    );\n  }\n  buffer.writeln('};');\n  return buffer.toString();\n  // --------------------toJson 생성 코드 끝--------------------//\n}\n```\n\n## copyWith 메소드\n\n\n<div class=\"content-ad\"></div>\n\n- 생성된 메서드 예시:\n\n```js\n// Product 클래스에 'copyWith' 메서드를 제공하기 위한 확장\nextension $ProductExtension on Product {\n  Product copyWith({\n    String? name,\n    double? price,\n  }) {\n    return Product(\n      name: name ?? this.name,\n      price: price ?? this.price,\n    );\n  }\n```\n\n- 위 예제를 생성하는 함수:\n\n```js\n// fromJSon 메서드를 생성하는 함수\nString generateCopyWithMethod(ModelVisitor visitor) {\n  // 모델 방문자로부터 클래스 이름 가져오기\n  String className = visitor.className;\n\n  // 생성된 클래스 각 부분을 작성할 버퍼\n  final buffer = StringBuffer();\n\n  // --------------------copyWith 생성 코드 시작--------------------//\n  buffer.writeln(\n      \"// $className 클래스에 'copyWith' 메서드를 제공하기 위한 확장\");\n  buffer.writeln('extension \\$${className}Extension on $className {');\n  buffer.writeln('$className copyWith({');\n  for (int i = 0; i < visitor.fields.length; i++) {\n    String dataType =\n        visitor.fields.values.elementAt(i).toString().replaceAll(\"?\", \"\");\n    String fieldName = visitor.fields.keys.elementAt(i);\n    buffer.writeln(\n      '$dataType? $fieldName,',\n    );\n  }\n  buffer.writeln('}) {');\n  buffer.writeln('return $className(');\n  for (int i = 0; i < visitor.fields.length; i++) {\n    buffer.writeln(\n      \"${visitor.fields.keys.elementAt(i)}: ${visitor.fields.keys.elementAt(i)} ?? this.${visitor.fields.keys.elementAt(i)},\",\n    );\n  }\n  buffer.writeln(');');\n  buffer.writeln('}');\n  buffer.writeln('}');\n  buffer.toString();\n  return buffer.toString();\n  // --------------------copyWith 생성 코드 종료--------------------//\n}\n```  \n\n<div class=\"content-ad\"></div>\n\njson_generator.dart 파일의 전체 코드:\n\n```js\nimport 'package:analyzer/dart/element/element.dart';\nimport 'package:annotations/annotations.dart';\nimport 'package:build/build.dart';\nimport 'package:build/src/builder/build_step.dart';\nimport 'package:generators/src/model_visitor.dart';\nimport 'package:source_gen/source_gen.dart';\n\nclass JsonGenerator extends GeneratorForAnnotation<CustomAnnotation> {\n  @override\n  String generateForAnnotatedElement(\n    Element element,\n    ConstantReader annotation,\n    BuildStep buildStep,\n  ) {\n    final ModelVisitor visitor = ModelVisitor();\n    // 클래스 필드 및 생성자 방문\n    element.visitChildren(visitor);\n\n    // 생성된 클래스의 각 부분을 작성할 버퍼\n    final buffer = StringBuffer();\n\n    // fromJson\n    String generatedFromJSon = generateFromJsonMethod(visitor);\n    buffer.writeln(generatedFromJSon);\n\n    // toJson\n    String generatedToJSon = generateToJsonMethod(visitor);\n    buffer.writeln(generatedToJSon);\n\n    // copyWith\n    String generatedCopyWith = generateCopyWithMethod(visitor);\n    buffer.writeln(generatedCopyWith);\n\n    return buffer.toString();\n  }\n\n  // fromJSon 메서드 생성하는 메소드\n  String generateFromJsonMethod(ModelVisitor visitor) {\n    // 모델 방문자로부터 클래스 이름 가져오기\n    String className = visitor.className;\n\n    // 생성된 클래스의 각 부분을 작성할 버퍼\n    final buffer = StringBuffer();\n\n    // --------------------fromJson 생성 코드 시작--------------------//\n    buffer.writeln('// From Json Method');\n    buffer.writeln(\n        '$className _\\$${className}FromJson(Map<String, dynamic> json) => ');\n    buffer.write('$className(');\n\n    for (int i = 0; i < visitor.fields.length; i++) {\n      String fieldName = visitor.fields.keys.elementAt(i);\n      String mapValue = \"json['$fieldName']\";\n\n      buffer.writeln(\n        \"${visitor.fields.keys.elementAt(i)}: $mapValue,\",\n      );\n    }\n    buffer.writeln(');');\n    buffer.toString();\n    return buffer.toString();\n    // --------------------fromJson 생성 코드 끝--------------------//\n  }\n\n  // toJson 메서드 생성하는 메소드\n  String generateToJsonMethod(ModelVisitor visitor) {\n    // 모델 방문자로부터 클래스 이름 가져오기\n    String className = visitor.className;\n\n    // 생성된 클래스의 각 부분을 작성할 버퍼\n    final buffer = StringBuffer();\n\n    // --------------------toJson 생성 코드 시작--------------------//\n    buffer.writeln('// To Json Method');\n    buffer.writeln(\n        'Map<String, dynamic> _\\$${className}ToJson($className instance) => ');\n    buffer.write('<String, dynamic>{');\n    for (int i = 0; i < visitor.fields.length; i++) {\n      String fieldName = visitor.fields.keys.elementAt(i);\n      buffer.writeln(\n        \"'$fieldName': instance.$fieldName,\",\n      );\n    }\n    buffer.writeln('};');\n    return buffer.toString();\n    // --------------------toJson 생성 코드 끝--------------------//\n  }\n\n  // copyWith 메서드 생성하는 메소드\n  String generateCopyWithMethod(ModelVisitor visitor) {\n    // 모델 방문자로부터 클래스 이름 가져오기\n    String className = visitor.className;\n\n    // 생성된 클래스의 각 부분을 작성할 버퍼\n    final buffer = StringBuffer();\n\n    // --------------------copyWith 생성 코드 시작--------------------//\n    buffer.writeln(\n        \"// $className 클래스에 'copyWith' 메소드를 제공하는 확장\");\n    buffer.writeln('extension \\$${className}Extension on $className {');\n    buffer.writeln('$className copyWith({');\n    for (int i = 0; i < visitor.fields.length; i++) {\n      String dataType =\n          visitor.fields.values.elementAt(i).toString().replaceAll(\"?\", \"\");\n      String fieldName = visitor.fields.keys.elementAt(i);\n      buffer.writeln(\n        '$dataType? $fieldName,',\n      );\n    }\n    buffer.writeln('}) {');\n    buffer.writeln('return $className(');\n    for (int i = 0; i < visitor.fields.length; i++) {\n      buffer.writeln(\n        \"${visitor.fields.keys.elementAt(i)}: ${visitor.fields.keys.elementAt(i)} ?? this.${visitor.fields.keys.elementAt(i)},\",\n      );\n    }\n    buffer.writeln(');');\n    buffer.writeln('}');\n    buffer.writeln('}');\n    buffer.toString();\n    return buffer.toString();\n    // --------------------copyWith 생성 코드 끝--------------------//\n  }\n}\n```\n\n이미 귀하는 프로페셔널하고 훌륭한 개발자이십니다. 🎉🎉\n\n마지막 단계에서는 build.yaml 파일에서 builder_factories: [\"generateJsonMethods\"]를 볼 수 있습니다. 이는 최상위 수준 함수를 포함하고 있으며, build.yaml 파일을 확인한 후 build_runner가 호출하게 될 것이며, 그 다음에는 이전에 생성된 생성기(JsonGenerator)를 호출하게 될 것입니다.\n\n<div class=\"content-ad\"></div>\n\n위의 정의는 다음과 같이 되어야 합니다:\n\n```js\nBuilder 이름(BuilderOption) \n```\n\nlib/generators.dart 파일에서:\n\n```js\nlibrary generators;\n\nimport 'package:build/build.dart';\nimport 'package:generators/src/json_generator.dart';\nimport 'package:source_gen/source_gen.dart';\n\nBuilder generateJsonMethods(BuilderOptions options) {\n  // Step 1\n  return SharedPartBuilder(\n    [JsonGenerator()], // Step 2\n    'json_generator', // Step 3\n  );\n}\n```\n\n<div class=\"content-ad\"></div>\n\n**단계 1:** [Builder]는 파일의 일부로 생성된 콘텐츠를 생성하는데 사용됩니다. 생성된 파일은 partId로 접두사가 붙어 있어 여러 [SharedPartBuilder]가 충돌하지 않고 일부 파일을 생성할 수 있습니다.\n\n**단계 2:** 이것은 우리의 생성기 클래스입니다.\n\n**단계 3:** partId 매개변수가 있습니다. 각 .dart 입력에 대해 어떤 파일이 생성될지 나타냅니다. 이 확장자는 다른 [SharedPartBuilder]와 충돌하지 않도록 고유해야 합니다.\n\n좋아요! 이제 생성기를 만들었네요, 축하합니다. 🎉🎉\n\n<div class=\"content-ad\"></div>\n\n이제 사용자 정의 주석 및 빌더를 테스트해 봅시다.\n\n# 예제 프로젝트\n\npubspec.yaml 파일을 열어 주석 및 빌더 패키지의 종속성을 추가하세요.\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n\n  # 우리의 주석 패키지\n  annotations:\n    path: ../annotations/\n\ndev_dependencies:\n  flutter_test:\n    sdk: flutter\n\n  build_runner:\n  # 우리의 생성기 패키지\n  generators:\n    path: ../generators/\n```\n\n<div class=\"content-ad\"></div>\n\n위 명령어를 실행하십시오: flutter pub get.\n\nlib 폴더로 이동하여 새로운 클래스를 생성하십시오. 예를 들어 Product라는 이름의 클래스를 생성하십시오:\n\n```js\nimport 'package:annotations/annotations.dart';\n\n// 스텝 1\npart 'product.g.dart'; // 파일 이름과 동일해야 함\n\n// 스텝 2\n@customAnnotation\nclass Product{\n  final String name;\n  final double price;\n\n  const Product({required this.name, required this.price});\n\n  /// 생성된 [_$ProductFromJson] 함수를 `fromJson` 팩토리와 연결합니다.\n  factory Product.fromJson(Map<String, dynamic> json) => _$ProductFromJson(json);\n\n  /// 생성된 [_$ProductToJson] 함수를 `toJson` 메소드와 연결합니다.\n  Map<String, dynamic> toJson() => _$ProductToJson(this);\n}\n```\n\n스텝 1: 파일 상단에 part `파일이름.g.dart`라는 줄을 추가하여 이 파일이 생성된 코드의 일부임을 지정하십시오. part `파일이름.g.dart`의 파일 이름이 Dart 파일 이름과 일치하는지 확인하십시오.\n\n<div class=\"content-ad\"></div>\n\n스텝 2: 제품 클래스에 우리의 주석을 추가하세요.\n\n예제 프로젝트 터미널에서 다음 명령을 실행해보세요:\n\ndart run build_runner build\n\n예제 프로젝트 터미널에서 명령을 실행한 후 다음 출력이 표시됩니다:\n\n<div class=\"content-ad\"></div>\n\n\n![Code Generation using Flutter](/assets/img/2024-06-21-CodeGenerationusingFluttersource_genbuild_runner_2.png)\n\nOutput/Generated file:\n\n```js\n// GENERATED CODE - DO NOT MODIFY BY HAND\n\npart of 'product.dart';\n\n// **************************************************************************  \n// JsonGenerator  \n// **************************************************************************\n\n// From Json Method\nProduct _$ProductFromJson(Map<String, dynamic> json) => Product(\n    name: json['name'],\n    price: json['price'],\n);\n\n// To Json Method\nMap<String, dynamic> _$ProductToJson(Product instance) => <String, dynamic>{\n    'name': instance.name,\n    'price': instance.price,\n};\n\n// Extension for a Product class to provide 'copyWith' method\nextension $ProductExtension on Product {\n    Product copyWith({\n        String? name,\n        double? price,\n    }) {\n        return Product(\n            name: name ?? this.name,\n            price: price ?? this.price,\n        );\n    }\n}\n```\n\nNow you can build your annotation with more customization 🎉😎\n\n\n<div class=\"content-ad\"></div>\n\n위 글을 읽어주셔서 감사합니다. 도움이 되셨으면 좋겣습니다. 궁금한 점이 있으면 언제든지 연락주세요.\n\n소스 코드\n\n질문이 있으면 LinkedIn 계정을 통해 연락주세요.","ogImage":{"url":"/assets/img/2024-06-21-CodeGenerationusingFluttersource_genbuild_runner_0.png"},"coverImage":"/assets/img/2024-06-21-CodeGenerationusingFluttersource_genbuild_runner_0.png","tag":["Tech"],"readingTime":22}],"page":"4","totalPageCount":20,"totalPageGroupCount":1,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}