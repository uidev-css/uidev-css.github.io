{"pageProps":{"posts":[{"title":"라라벨 방식으로 다중 테넌시 구현하기","description":"","date":"2024-06-20 13:59","slug":"2024-06-20-Multi-tenancytheLaravelWay","content":"\n\n## 라라벨에서 멀티 테넌시하는 두 가지 방법.\n\n프레임워크를 사용할 때는 그 프레임워크가 의도한 대로 작업하고 싶어요. 기분이 좋아지는 느낌이죠? 문제가 생기면 프레임워크가 매우 우아한 방식으로 그 문제를 해결했을 가능성이 높습니다. 적어도 프레임워크가 좋다면요. 그리고 라라벨을 사용하면요, 최고 중의 최고를 사용하고 있어요. 그러니까 분명 멋진 분이시겠죠.\n\n그렇게 멋진 분(사람, 고양이, 어떻게든 자신을 정의하는 대로)이세요, 멋진 SaaS 아이디어를 가지고 앱을 만드려고 하시나 본가요? 그게 SaaS라면 사용자들이 필요합니다. 사용자가 필요하다면, 이들을 서로 구분해야겠죠. Jane이 Janet의 데이터를 보는 건 원하지 않으시겠죠? 물론 그렇지요. 아무도 그런 걸 보고 싶어하지 않습니다. 이게 멀티 테넌시라는 개념이 들어오는 곳입니다.\n\n여러분이 사용하는 멀티 테넌시는, 하나의 데이터베이스를 공유하는 여러 사용자가 있는 앱을 의미합니다. 특히 이번 서버리스 샤넌이 복잡한 시대에서 이는 다른 것을 의미할 수 있습니다. 그러나 우리의 목적에 맞게, 이는 단일 데이터베이스, 여러 사용자를 가리킵니다. 이는 작고 큰 SaaS 앱에서 일반적인 설정입니다. 복잡한 서버리스 설정을 관리하는 복잡성을 줄이지만, 일부 보안 문제를 도입할 수도 있습니다. 정확히 어떻게 Jane이 Janet을 감시하는 걸 막을 수 있을까요?\n\n<div class=\"content-ad\"></div>\n\n이 작업을 수행하는 여러 가지 방법이 있습니다. 고양이를 애정스럽게 쓰다듬는 여러 방법이 있어요. 실제로 멀티 테넌시를 재미있게 만들기 위해 Laravel의 마법을 활용하는 몇 가지 방법에 대해 이야기하려고 합니다 (이것이 Laravel이 재미있게 만드는 데 좋은 점입니다)! 이러한 접근 방법은 다음과 같습니다:\n\n- \"tenant\" 미들웨어 사용하기\n- 전역 쿼리 스코프 사용하기\n\n하지만 그에 앞서 스코프된 URL에 대해 이야기해야 합니다.\n\n# 스코프된 URL\n\n<div class=\"content-ad\"></div>\n\n알겠어요, scoped urls에 대해 알려드릴게요. 이는 Laravel의 라우팅 범주에 속하며, 이것을 깊게 다루진 않겠지만, 공식 문서는 정말 대단해요. 간단히 이야기해보면 라우트 매개변수에 대해요.\n\n라라벨은 라우트를 생성할 때 url의 일부를 매개변수화하는 것을 허용하며, 이는 매우 일반적으로 모델과 대응될 것입니다. 우리의 특정 케이스에서는 테넌트(팀)을 생각해보세요:\n\n```js\nRoute::get('/app/{tenant}', function(Tenant $tenant){\n  return \"안녕하세요 {$tenant.name}\"\n});\n```\n\n암시적 바인딩을 사용하면, Laravel이 테넌트 매개변수를 가져와 해당 테넌트 모델을 찾아서 이름을 표시할 겁니다. 이것만으로도 정말 멋져요. 그러나 아마도 사람들이 id를 사용하여 테넌트를 조회하는 것을 원하지 않을 것이므로, Laravel은 바인딩 키를 지정할 수 있게 해줘요:\n\n<div class=\"content-ad\"></div>\n\n```js\nRoute::get('app/{tenant:slug}', function(Tenant $tenant){...});\n```\n\n알겠어요. 이제 매개 변수화에 대해 이해했으니(그리고 실제 단어라는 것을 배웠으니) 범위 지정된 URL로 계속 진행해 봅시다. 단일 매개 변수를 사용하는 URL도 멋지지만, 두 개를 사용하는 URL은 더 멋집니다:\n\n```js\nRoute::get('app/{tenant:slug}/{project:slug}', function (\n  Tenant $tenant,\n  Project $project)\n{\n  return \"프로젝트 {$project->name}에 오신 것을 환영합니다.\"\n})\n```\n\n네, 암시적 바인딩을 사용하고 경로의 매개 변수 순서를 준수하여라면 Laravel은 사용자에게 보여줄 적합한 Tenant 및 Project를 가져올 것입니다. 그러나 이것이 전부가 아니에요! 우리가 바인딩 키(slug)를 지정했고, 특히 두 번째 매개 변수에 대한 특별한 설정을 한 것때문에 Laravel은 \"하위\" 매개 변수로 처리할 것이며, 테넌트의 직속 하위인 프로젝트만 반환할 것입니다. 따라서 \"Cats Inc.\"라는 이름의 회사에 \"Cat Food\"라는 프로젝트가 있는 경우, /app/cats-inc/cat-food는 우리에게 해당 프로젝트를 제공할 것이지만, /app/dogs-inc/cat-food는 그렇지 않을 것입니다(같은 이름을 가진 프로젝트를 가진 Dogs Inc.가 존재하는 경우를 제외합니다. 그러나 그럴 경우에도 여전히 각 팀에 맞는 올바른 프로젝트를 보고 있을 것입니다). 매개 변수를 계속해서 연결할 수 있고, 관계가 모델에서 정의되어 있고 타입 힌트를 적절히 지정한다면 Laravel은 모두 가져오는 방법을 알고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\nRoute::get('/app/{tenant:slug}/{project:slug}/{project-item:slug}/{item-comment:slug}...', function(\n  Tenant $tenant,\n  Project $project,\n  ProjectItem $projectItem,\n  ItemComment $itemComment\n))\n{\n  return $itemComment;\n}\n\n\n만약 고양이 주식회사의 고양이 프로젝트를 위한 슬라이드쇼 전달가능한 항목에 대한 아이템 코멘트가 존재한다면, 사용자는 그것을 볼 수 있어요. 정말 단순해요.\n\n코드 재사용을 피하기 위해 라우트 그룹화를 사용할 수 있어요:\n\n\nRoute::prefix('/app/{tenant:slug}')->group(function(){\n  Route::get('/{project:slug}', function(Tenant, Project)...);\n  Route::get('/{member:name}', function (Tenant, Member)...;\n})\n\n\n<div class=\"content-ad\"></div>\n\n이제 프로젝트를 테넌트에 범위로 지정하고 회원을 테넌트에 범위로 지정하는 라우트를 생성했어요. 그것도 한 번에 처리했답니다. 라라벨 진짜 멋지죠? 저는 그렇게 생각해요.\n\n# 테넌트 미들웨어\n\n좋아요, 여기 똑똑한 독자들(여러분)은 아마 여기서 실제로 보안 문제에 대한 언급이 없다는 것에 주목했을 겁니다. 맞아요, 테넌트에 속한 프로젝트만 보여줄 수 있고 프로젝트 이름과 테넌트 이름을 추측해서 알아야만 볼 수 있는데, 이것은 보안이라기보다는 조금은 난해한 것일 뿐이에요. 한 종류의 보안이긴 하지만 아주 좋은 건 아니에요. 아무 것도 잠겨 있지 않죠. 여기서 \"can\" 미들웨어와 모델 정책이 등장해요.\n\n모델 정책은 모델에 대한 액세스를 제어하는 방법입니다. 세부 내용에 대해 자세히 설명하지는 않겠지만, 기본적으로 특정 사용자가 특정 작업을 할 수 있는지를 결정하는 논리를 포함하는 함수를 정의하는 것입니다. 그래서 우리의 테넌트에 대해 특정 테넌트에 속한 사용자만 테넌트를 볼 수 있다면, 이렇게 할 수 있어요:\n\n<div class=\"content-ad\"></div>\n\n```js\n//App\\Policies\\TenantPolicy\n\nclass TenantPolicy\n{\n\n  public function view(User $user, Tenant $tenant): bool\n  {\n    return $user->tenant->id === $tenant->id;\n  }\n}\n```\n\n이는 사용자가 하나의 테넌트에만 속할 것으로 가정하고, 모델 간의 관계가 모델 클래스에 설정되어 있다고 가정합니다. 이는 전형적인 설정이며, 테넌트를 팀이나 회사와 같은 것으로 생각한다면 매우 이치에 맞는 설계입니다.\n\n이제 정책을 설정했으니, 라우트에서 \"can\" 미들웨어를 사용하여 호출할 수 있고, 접두사에 사용한 것과 동일한 그룹에 적용할 수 있습니다:\n\n```js\nRoute::middleware('can:view,tenant')->prefix('/app/{tenant:slug}')->group(function(){\n  Route::get('/{project:slug}', function(Tenant, Project)...);\n  Route::get('/{member:name}', function (Tenant, Member)...);\n});\n```\n\n<div class=\"content-ad\"></div>\n\n마법 같지 않나요? 우리는 Laravel에게 기본 \"can\" 미들웨어를 사용하도록 지시하는 것뿐인데요. 이 미들웨어는 모델에 대한 정책을 호출할 수 있는데, 우리는 \"view\" 메서드 호출과 매개 변수인 \"tenant\"를 제공합니다. Laravel은 테넌트 매개 변수를 자동으로 Tenant 클래스에 바인딩하고 테넌트 정책을 호출하도록 명명 규칙을 알고 있습니다. 정책은 전달된 URL의 테넌트가 사용자가 속한 것과 같은지 알려줄 것입니다. 맞다면 좋아요! 그렇지 않으면 사용자는 403 \"금지됨\" 오류를 받게 될 거예요.\n\n이 접근법을 사용하면 모든 하위 리소스의 보안에 신경쓰게 됩니다. 사용자가 현재 테넌트를 볼 수 없다면 오류가 발생합니다. 그리고 테넌트의 하위 항목이 아니라면 리소스를 찾을 수 없습니다. 와우, 우리 해냈어요!\n\n이 접근법의 강점은 그 간단함에 있습니다. 사실상 우리는 단일 장애 지점을 갖고 있는데, 이는 모델이나 미래 모델에 의존하지 않고 요청당 한 번만 확인하면 되기 때문에 좋은 방법입니다. 우리는 초기 필수 게이트인 테넌트 주변에 자원을 보호하기 위한 울타리를 세웠습니다. 테넌트에 속하니? 아니요? 그럼 슬라이드쇼에 대한 댓글을 볼 수 없네요. 여기서 벗어나 주세요, Jane! 그리고 간단함 때문에, 다른 모델들은 테넌트와의 관계를 이해할 필요가 없습니다. 오직 \"자연스러운\" 직계 하위 항목에 대해서만 이해하면 됩니다.\n\n이 접근법에는 몇 가지 단점이 있습니다. 코드 예제에서 주목하셨을 것이지만, 결과를 반환하는 모든 함수에서 테넌트를 typehint해야 합니다. 이렇게 하면 Laravel이 테넌트 매개 변수를 자동으로 테넌트 모델에 바인딩하는 방법을 알 수 있습니다. 우리 예제에서는 그렇게 나쁘지 않지만, 모델들의 컨트롤러를 사용하는 경우 URL을 따라 두 번째, 세 번째, 심지어 더 깊은 매개 변수까지 내려가야 하는 경우에는 번거로울 수 있습니다. 우리가 과장된 듯한 예를 들면, 깊게 중첩된 댓글을 위한 경로의 경우, 해당 댓글을 위한 컨트롤러에서 이렇게 인수 목록이 있는 함수가 있을 것입니다:\n\n<div class=\"content-ad\"></div>\n\n```js\npublic function show(\n  테넌트 $테넌트,\n  프로젝트 $프로젝트,\n  프로젝트항목 $프로젝트항목,\n  항목코멘트,\n  $항목코멘트\n){...}\n```\n\n좀 그렇네요. 항목 코멘트 컨트롤러는 이렇게 많은 매개변수에 신경 쓰지 않아도 됩니다. 또한, 종종 라우트에서 추가 매개변수를 사용하지 않습니다. 이런 부분은 여전히 \"라라벨스러운\" 느낌을 유지하면서 처리할 수 있습니다. 예를 들어, 라우트 파일에서 컨트롤러 메소드를 호출하기 전에, 그룹을위한 의존성을 타입힌트 할 수 있는 익명 함수를 사용한 다음 필요한 모델만 전달하여 컨트롤러 메소드를 반환합니다. 이 방법은 새로운 라우트를 추가하고 기존 라우트를 수정할 때 잘 작동합니다. 또한, 더 단순한 경우 기존 컨트롤러를 수정할 필요가 없기 때문에 기존 라우트 파일에 타입힌트 로직이 유지되고, 이것이 더 잘 맞는다고 생각합니다.\n\n다른 단점은 라우트가 복잡해질 수 있다는 것입니다. 이제 url에서 테넌트가 필요하기 때문에 추가적인 매개변수가 도입되었습니다. 즉, url 범위 체인을 따라 이동하기 시작하면 문제가 됩니다. 루트 도우미 함수를 호출하고 4개의 매개변수를 제공해야 하는 경우, 테넌트로 깊게 중첩된 모델로 올라가는 것은 재미있는 경험이 아닙니다. 이것은 라우트 스코핑을 사용하는 다중 테넌시의 고유한 문제는 아니지만 문제를 악화시킵니다. 이러한 접근 방식을 사용할 것이라면, 적절한 매개변수를 라우트 도우미 함수에 삽입하는 방법을 알고 있는 사용자 정의 라우트 도우미 서비스를 추천 드립니다.\n\n이러한 강점과 약점을 쉽게 이해하려면 단연코 목록을 만들어봅시다.\n\n\n<div class=\"content-ad\"></div>\n\nMulti-Tenancy with Tenant Middleware\n\n장점:\n\n- 코드 설정이 최소화됩니다.\n- 리소스에 대한 단일 진입 지점 (테넌트)\n- Laravel의 내장 기능을 사용하여 리소스에 대한 액세스 규칙을 쉽게 강제할 수 있습니다.\n\n단점:\n\n<div class=\"content-ad\"></div>\n\n- 컨트롤러나 라우트 함수에서 경로 매개변수를 힌트로 입력해야 하는 것은 귀찮고 효율적이지 않아요.\n- 여러 매개변수가 있는 복잡한 경로로 빠르게 복잡해지며, 이 방식은 처음부터 복잡함을 추가해요.\n\n이제 다음으로 다중 테넌시를 구현하는 또 다른 방법으로 넘어가 봐요.\n\n# 쿼리 스코프\n\nLaravel에서의 쿼리 스코프는 모델이 데이터베이스에서 검색되는 방식을 제어할 수 있게 해줘요. 모델 클래스에 설정된 글로벌 스코프는 해당 모델에 대한 모든 쿼리에 적용돼요. 쿼리 스코프를 생성하는 자세한 방법은 문서를 참고해 주세요. 하지만 테넌트에 맞는 간단한 스코프를 에뮬레이트해 볼게요:\n\n<div class=\"content-ad\"></div>\n\n```js\n// App/Models/Scopes\n\n클래스 TenantScope는 Scope를 구현합니다.\n{\n  public function apply(Builder $builder, Model $model): void\n  {\n    $tenantId = ...\n    $builder->where('tenant_id', '=', $tenantId);\n  }\n}\n```\n\n모델 클래스에 이를 적용하는 방법은 여러 가지가 있습니다. \"booted\" 메서드를 살펴보겠습니다.\n\n```js\nclass Project extends Model\n{\n    /**\n     * 모델의 \"booted\" 메서드입니다.\n     */\n    protected static function booted(): void\n    {\n        static::addGlobalScope(new TenantScope);\n    }\n}\n```\n\n이제 프로젝트가 쿼리될 때 마다 우리의 스코프가 쿼리에 추가됩니다. 멋지죠? 그런데 스코프에 원하는 테넌트 ID를 설정하지 않았다는 것을 알아차렸을 수도 있습니다. 스코프에서 적절한 ID에 어떻게 접근할까요? ID는 무엇이어야 할까요? 이전 솔루션에서는 라우트 메서드의 미들웨어에서 사용자를 제공했습니다. 여기에는 그것이 없지만 글로벌 \"auth\" 도우미를 통해 간단히 액세스할 수도 있습니다:\n\n\n<div class=\"content-ad\"></div>\n\n```js\n$tenantId = auth()->user()->tenant_id;\n```\n\n이제 프로젝트 쿼리가 실행될 때마다 사용자의 테넌트 ID로 쿼리가 제한됩니다. 사용자는 자신의 테넌트 ID와 일치하는 프로젝트만 볼 수 있습니다. 멋져요! 이 방법을 사용하면 실제로 더 이상 URL에 테넌트를 포함시킬 필요가 없습니다:\n\n```js\nRoute::get('/{project}', function(Project $project){...});\n```\n\n더 간단한 라우트가 되었기 때문에, 이 방법은 이전 방법에서 제기된 문제점에 대응합니다. 이전 솔루션과 같이 URL을 범위로 지정하면, 이는 여전히 부모 리소스가 소유하지 않은 자식 리소스에 액세스하는 것을 방지합니다. 멋지죠! 모델 정책 및 권한 부여 미들웨어가 필요 없어졌습니다.\n\n<div class=\"content-ad\"></div>\n\n아마도 모델 클래스에 scope를 직접 적용해야 한다는 점을 알아차렸을 것입니다. 우리가 사용하려는 모든 부모 모델에 대해 이것이 사실이며, 이는 번거로울 수 있습니다. 다행히도 스코핑 부착을 트레잇이나 별도의 클래스로 추출할 수 있습니다:\n\n```js\nnamespace App\\Models;\n\nclass TenantModel extends Model\n{\n    protected static function booted(): void\n    {\n        static::addGlobalScope(new TenantScope);\n    }\n}\n```\n\n테넌트에 대해 스코프가 지정된 클래스를 확장하고 싶은 모든 클래스를 TenantModel 클래스로 확장할 수 있습니다.\n\n이전과 마찬가지로 웹 친화적인 장단점 목록:\n\n<div class=\"content-ad\"></div>\n\n글로벌 쿼리 스코프\n\n장점\n\n- 사용자의 테넌트에 대한 모델 쿼리는 자동으로 스코프 지정됩니다\n- URL에 테넌트를 포함할 필요가 없습니다\n- 추가 미들웨어가 필요하지 않습니다\n\n단점\n\n<div class=\"content-ad\"></div>\n\n- 모델에 직접 scope를 추가해야 합니다.\n- 사용자가 테넌트 리소스를 볼 수 있는 경우와 볼 수 없는 경우가 덜 명확합니다.\n\n# 결론\n\n저는 이 두 가지 접근 방식을 모두 사용해봤고, 둘 다 라라벨의 매직을 효과적으로 활용하여 다중 테넌시를 구현하는 데 즐거웠어요! 선택할 때 상황을 고려하시기 바랍니다. 이미 URL에 테넌트를 포함하고 있다면 테넌트 미들웨어를 사용하여 범위가 지정된 URL로 보안 요구 사항을 충족시킬 수 있습니다. URL에 테넌트를 포함하고 싶지 않다면 전역 쿼리 스코핑을 고려해보세요.\n\n물론 두 가지를 혼합해서 사용해도 괜찮습니다. URL에 테넌트를 포함하고 여전히 자식 리소스에 범위를 지정하여 추가적인 예방 조치를 취하고 싶을 수도 있습니다. 모든 URL에 테넌트를 포함하고, 미들웨어 확인을 수행한 다음 매개변수를 “잊고” 나머지 리소스에 대해 전역 쿼리 스코핑을 사용할 수 있습니다. 여러분에게 가장 적합한 방법을 선택하고 멋진 웹 앱을 만들 수 있는 라라벨이 있다는 것에 감사드립니다!","ogImage":{"url":"/assets/img/2024-06-20-Multi-tenancytheLaravelWay_0.png"},"coverImage":"/assets/img/2024-06-20-Multi-tenancytheLaravelWay_0.png","tag":["Tech"],"readingTime":9},{"title":"React 프레임워크에서 모두 작동하는 React 컴포넌트를 만드는 방법","description":"","date":"2024-06-20 13:57","slug":"2024-06-20-HowToCreateReactComponentsThatRunOnEveryReactFramework","content":"\n\n## React 프레임워크와 호환되는 React 컴포넌트 구축하기 - Next.js, Gatsby, React Native 및 그 외!\n\nReact는 2023년 현재 180만 개 이상의 웹사이트에서 사용되고 있습니다. 이는 일반적인 React.js뿐만 아니라 Next.js, React Native 및 Gatsby와 같이 더 복잡한 프레임워크를 사용하는 것을 포함합니다.\n\n따라서 여러 프로젝트에서 이러한 프레임워크를 활용하는 조직의 구성원이라면, 모든 이 프레임워크에 걸쳐 사용할 수 있는 디자인 시스템이 필요할 것입니다. 서로 다른 프레임워크 간에 React 컴포넌트를 사용할 때 성능 또는 호환성 문제를 직면하고 싶지 않을 것입니다.\n\n이것이 바로 내 글이 자리잡는 곳입니다. 여러분에게 모든 React 프레임워크에 적합한 하나의 React 디자인 시스템을 유지하는 방법을 안내해 드릴 것입니다!\n\n<div class=\"content-ad\"></div>\n\n# 모든 프레임워크를 지원하는 React 컴포넌트 개발하기\n\n![이미지](/assets/img/2024-06-20-HowToCreateReactComponentsThatRunOnEveryReactFramework_0.png)\n\n만일 Bit에 대해서 잘 모르시겠다면, 그것은 컴포저블 소프트웨어를 빌드할 수 있는 차세대 빌드 시스템입니다. Bit를 사용하면 독립적인 환경에서 구성, 개발 및 컴포넌트를 빌드할 수 있어서 어떤 프로젝트에서든 어디에서든 사용할 수 있습니다!\n\n이로써 Bit는 모든 프레임워크에서 실행되는 컴포넌트를 빌드하는 완벽한 후보가 됩니다.\n\n<div class=\"content-ad\"></div>\n\n# 단계 01: 준비 사항\n\n우선 Bit을 설치해 봅시다. 다음 명령어를 실행하세요:\n\n```js\nnpx @teambit/bvm install\n```\n\n설치를 확인하려면 다음 명령어를 실행하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nbit --version\n```\n\nBit를 성공적으로 설치했다면, 아래와 같은 출력이 표시될 것입니다:\n\n![Bit Version Output](/assets/img/2024-06-20-HowToCreateReactComponentsThatRunOnEveryReactFramework_1.png)\n\n다음으로, Bit Cloud에 계정을 만들어야 합니다. Bit Cloud를 사용하면 원격 scope에 컴포넌트를 호스팅할 수 있어 다른 프로젝트가 구축 중인 컴포넌트 라이브러리를 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-20-HowToCreateReactComponentsThatRunOnEveryReactFramework_2.png\" />\n\nBit Cloud에 계정을 만든 후에 scope를 생성할 수 있습니다.\n\n<img src=\"/assets/img/2024-06-20-HowToCreateReactComponentsThatRunOnEveryReactFramework_3.png\" />\n\n이 글에서는 scope인 react-component-library를 만들었습니다. scope를 만든 후에는 라이브러리를 구축할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 단계 02: Bit 워크스페이스 설정하기\n\n라이브러리를 빌드하기 위해 개발자 머신에 워크스페이스를 생성해봅시다. 다음 명령어를 실행하세요:\n\n```js\nmkdir workspace && cd workspace && bit init\n```\n\n아래 출력 결과를 확인할 수 있어요:\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-20-HowToCreateReactComponentsThatRunOnEveryReactFramework_4.png\" />\n\n다음으로, IDE에서 워크스페이스를 열고 workspace.jsonc 파일을 다음과 같이 업데이트합니다:\n\n```js\n\"defaultScope\": <<BIT_USERNAME>>.<<SCOPE_NAME>>,\n```\n\n이 변경 사항을 워크스페이스 구성 파일에 적용하십시오. 이렇게 하면 정의한 스코프에서 생성된 모든 구성 요소가 호스팅됩니다. 이 글에서는 defaultScope를 다음과 같이 업데이트했습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n\"defaultScope\": dummyorg.react-component-library\n```\n\n이를 이전에 생성한 scope 및 Bit 사용자 이름으로 업데이트할 수 있습니다.\n\n다음으로 특별한 작업을 수행할 것입니다. \"환경\"을 만들어봅시다. 이 환경은 독립적인 개발을 가능하게 합니다. 현재 당신의 작업 공간은 어떤 프레임워크와도 묶여 있지 않습니다. 당신의 작업 공간에서는 Node.js, Angular, Vue.js, Stencil, React.js 및 더 많은 컴포넌트를 개발할 수 있습니다.\n\n그러니 React 환경을 만들어봅시다. 아래 명령어를 실행하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nbit create react-env envs/react-18 --aspect teambit.react/react-env\n```\n\n![이미지](/assets/img/2024-06-20-HowToCreateReactComponentsThatRunOnEveryReactFramework_5.png)\n\n환경을 만든 후에는 새로운 환경을 기반으로 하는 모든 컴포넌트를 생성할 수 있습니다.\n\n# 단계 03: 모든 프레임워크에서 사용할 수 있는 React 컴포넌트 작성하기\n\n\n<div class=\"content-ad\"></div>\n\n그 다음은 어떤 프레임워크에서도 작동하는 React 컴포넌트를 만들어 봅시다! 이를 보여주기 위해 Next.js 및 React 환경에서 실행할 수 있는 이미지 컴포넌트를 만들어 보겠습니다.\n\n이를 위해 패키지인 next/image를 사용하겠습니다. 우리는 이를 위해 컴포넌트에 Next.js 라이브러리 세트를 설치해야 합니다. 이 작업은 다음 명령어를 실행하여 수행할 수 있습니다:\n\n```js\nbit install next  --add-missing-deps  --type peer\n```\n\n이렇게 하면 해당 라이브러리가 워크스페이스 내에서 피어 종속성으로 설치됩니다. next 라이브러리를 사용하는 모든 컴포넌트가 자동으로 번들에 포함됩니다.\n\n<div class=\"content-ad\"></div>\n\n다음으로, React 컴포넌트를 생성해 보겠습니다:\n\n```js\nbit create react elements/image --env envs/react-18\n```\n\n이 명령은 \"image\"라는 컴포넌트를 생성하고 이전에 만든 새로운 환경을 사용합니다. 이제 React 컴포넌트가 있으니 컴포넌트를 확인해 봅시다. 그러려면 다음 명령을 사용하여 Bit 서버를 시작해 보겠습니다:\n\n```js\nbit start\n```\n\n<div class=\"content-ad\"></div>\n\n로컬호스트인 localhost:3000에 방문해서 컴포넌트를 확인해보세요:\n\n![이미지](/assets/img/2024-06-20-HowToCreateReactComponentsThatRunOnEveryReactFramework_6.png)\n\n이제 컴포넌트를 만들어봅시다. image.tsx 파일을 열고 다음 스니펫을 추가해보세요:\n\n```js\r\nimport React from 'react';\nimport NextImage from 'next/image';\r\n```\n\n<div class=\"content-ad\"></div>\n\n```js\nexport type ImageProps = {\n  isNextJs?: boolean\n  source: string\n  name: string\n};\nexport function Image({ isNextJs = false, source, name }: ImageProps) {\n  return (\n    <NextImage\n      src={source}\n      alt={name}\n      fill\n      unoptimized={!isNextJs}\n    />\n  );\n}\n```\n\n위와 같이, 우리는 Next.js의 Image 컴포넌트를 활용했고, 다른 프레임워크에 대한 렌더링 전략을 제어하기 위해 unoptimized prop을 활용했습니다.\n\n그 후에는 컴포넌트 미리보기를 생성하기 위해 구성을 만들 수 있습니다.\n\n```js\nimport React from 'react';\nimport { Image } from './image';\n```\n\n<div class=\"content-ad\"></div>\n\n```js\nexport const BasicImage = () => {\n  return (\n    <Image\n      name='샘플 이미지'\n      source='https://fujifilm-x.com/wp-content/uploads/2021/01/gfx100s_sample_04_thum-1.jpg'\n      isNextJs={false}\n    />\n  );\n}\n```\n\n그 다음으로 개발 서버로 돌아가면 아래와 같이 출력된 결과를 확인할 수 있습니다:\n\n<img src=\"/assets/img/2024-06-20-HowToCreateReactComponentsThatRunOnEveryReactFramework_7.png\" />\n\n그저 그런 것뿐이에요. 다음으로 해당 명령어를 사용하여 원격 범위로 공유할 수 있어요: \n\n\n<div class=\"content-ad\"></div>\n\n```js\nbit tag && bit export\n```\n\nBit의 Ripple CI에서 빌드를 시작하고 구성 요소를 공개 사용을 위해 빌드합니다. 빌드를 여기에서 확인할 수 있습니다:\n\n![빌드](/assets/img/2024-06-20-HowToCreateReactComponentsThatRunOnEveryReactFramework_8.png)\n\n이후에는 Bit 자체에서 사용할 수 있거나 NPM 패키지로도 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-20-HowToCreateReactComponentsThatRunOnEveryReactFramework_9.png\" />\n\n여기에서 컴포넌트를 확인할 수 있어요.\n\n# 단계 04: 어떤 프레임워크에서도 컴포넌트 사용하기\n\n그 다음, 이를 테스트해보기 위해 두 개의 앱을 만들어봐요:\n\n<div class=\"content-ad\"></div>\n\n- 리액트 앱\n- 넥스트.js 앱\n\n다행히도 Bit은 넥스트.js와 리액트 앱을 모두 지원합니다. 각각의 앱에 대한 App 구성 요소를 생성할 수 있습니다. 이를 위해 다음 명령어를 실행해주세요:\n\n```js\n// 리액트 앱 생성\nbit create react-app apps/my-app --aspect bitdev.react/react-env\n```\n\n```js\n// 넥스트.js 앱 생성\nbit create nextjs apps/my-nextjs-app --aspect frontend.nextjs/nextjs-env\n```\n\n<div class=\"content-ad\"></div>\n\n다음으로, Markdown 포맷으로 표 태그를 변경해보세요.\n\n\n| 작업 | 비고 |\n|------|------|\n| A    | B    |\n| C    | D    |\n\n\n<div class=\"content-ad\"></div>\n\n다음으로, Next.js 앱에서 page.tsx 파일을 열고 아래 코드를 업데이트하세요:\n\n```js\nimport { Image } from '@dummyorg/react-component-library.elements.image';\nimport React from 'react';\n```\n\n```js\nexport default function Home() {\n  return (\n    <Image\n      name='샘플 이미지'\n      source='https://fujifilm-x.com/wp-content/uploads/2021/01/gfx100s_sample_04_thum-1.jpg'\n      isNextJs={true}\n    />\n  )\n}\n```\n\n이후, 다음 명령어를 사용하여 앱을 실행하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nbit run my-nextjs-app\n```\n\n아래에 표시된 출력을 볼 수 있습니다:\n\n<img src=\"/assets/img/2024-06-20-HowToCreateReactComponentsThatRunOnEveryReactFramework_11.png\" />\n\n그게 다 입니다! 이제 여러분은 어떤 프레임워크에서도 실행할 수 있는 컴포넌트를 만들었습니다!\n\n<div class=\"content-ad\"></div>\n\n# 마무리\n\n쉬웠죠? Bit를 사용하면 어떤 프레임워크에서든 실행할 수 있는 컴포넌트를 만들 수 있어요! 뿐만 아니라 React로 끝나지 않아요. Bit를 사용하면 Node.js, Angular, Vue.js 등 다양한 프레임워크에서 컴포넌트를 만들고 공유할 수 있어요.\n\n예를 들어, 풀스택 개발을 고려 중이라면, Bit를 사용하여 엔티티와 유틸 함수를 프론트엔드와 백엔드 모두에서 쉽게 공유할 수 있어요.\n\n만약 이 내용이 마음에 드시면, 꼭 직접 이 데모를 실행해 보세요!\n\n<div class=\"content-ad\"></div>\n\n감사합니다! 계속 읽어주셔서 감사합니다!\n\n## 더 알아보기","ogImage":{"url":"/assets/img/2024-06-20-HowToCreateReactComponentsThatRunOnEveryReactFramework_0.png"},"coverImage":"/assets/img/2024-06-20-HowToCreateReactComponentsThatRunOnEveryReactFramework_0.png","tag":["Tech"],"readingTime":7},{"title":"2024년 원격 프론트엔드 소프트웨어 엔지니어링 역할을 얻으려는 중  파트 3 계획","description":"","date":"2024-06-20 13:55","slug":"2024-06-20-TryingtogetaRemoteFront-EndSoftwareEngineeringRolein2024Part3ThePlan","content":"\n\n![image](/assets/img/2024-06-20-TryingtogetaRemoteFront-EndSoftwareEngineeringRolein2024Part3ThePlan_0.png)\n\n# 개요\n\n원격 프런트엔드 소프트웨어 엔지니어링 역할을 확보하기 위한 목표를 달성하기 위해, 다양한 장애물을 극복할 기회를 높여야 합니다.\n\n이전 글에서는 목표와 능력을 명확히 하는 데 집중했습니다. 다음 단계는 자신을 위한 계획을 세우는 것입니다. 바로 지금의 위치에서 목표 지점까지 도달할 수 있는 지도를 만드는 것이죠.\n\n<div class=\"content-ad\"></div>\n\n이 계획을 구축하는 동안, 가장 큰 영향을 줄 것으로 생각되는 것에 중점을 두고 집중해야 해요. 이 계획에는 모든 것이 아래 목표 중 하나로 나를 이동시켜야 해요:\n\n- 실제 사람들에게 내 애플리케이션을 소개하기\n- 나에 대한 문서를 기반으로 그 사람들이 따라오도록 설득하기\n- 심층 면접, 최종 면접, 기술 면접에 대비하기\n\n이 과정이 시간이 소요될 것으로 예상돼요. 꾸준한 속도를 유지하는 것이 중요해요 — 끈기를 갖고 스트레스 받지 않고 노력하는 것이 중요해요. 저는 본업과 가족을 가지고 있어요. 서둘 필요가 없는 행운을 가졌지만, 여유 시간이 많지 않기 때문에 저에게 현실적인 목표를 설정해야 해요.\n\n# 계획\n\n<div class=\"content-ad\"></div>\n\n프론트엔드 엔지니어로서, 인터넷의 화면 표시 부분은 제 영역이자 주요 쇼케이스입니다. 원하는 원격 작업을 찾고 좋아하는 직무에 지원하려면 최대한 활용해야 합니다.\n\n비둘기처럼, 주목받을 만한 것들을 전시하여 주목을 끌어야 하고, 그때에는 관객을 매료시켜야 합니다.\n\n![링크](https://miro.medium.com/v2/resize:fit:1040/1*Nxcu5asoRbsMSG1hWPzKcA.gif)\n\n이 노래와 춤의 주요 요소는 다음과 같을 것입니다:\n\n<div class=\"content-ad\"></div>\n\n## 이력서 업데이트 및 개선\n\n내 이력서와 커버 레터를 사람들이 먼저 볼 수 있도록 하는 방법을 알아봐야 해. 한눈에 보기에, 내가 해야 할 것은 다음과 같다:\n\n- 사용하는 언어와 주요 키워드를 검토해야 해. 예를 들어, 지난 몇 년간 많은 CI/CD 작업을 참여했지만 내 현재 이력서에는 단 한 번도 언급되지 않았어. 또한 지원하는 직무와 일치하는 직책과 키워드를 사용하는 것 역시 중요해. 예를 들어, 프론트엔드 소프트웨어 엔지니어와 프론트엔드 엔지니어는 사실상 같은 직책이지만 자동 시스템은 이를 알지 못하고 정확한 직책 매칭이 없는 이력서를 제외할 수 있어.\n- 최신 작업물을 더 잘 소개해야 해. 내가 참여한 주요 제품이 온라인 상점에 나타나기 시작하고 있는데, 이를 어떻게든 보여주는 것이 좋을 거야.\n\n![이미지](/assets/img/2024-06-20-TryingtogetaRemoteFront-EndSoftwareEngineeringRolein2024Part3ThePlan_1.png)\n\n<div class=\"content-ad\"></div>\n\n## 더 나은 온라인 존재감 만들기\n\n온라인에서 좀 더 빛을 발하고 싶어요. 내 이름을 검색하면 내 개인 웹사이트와 LinkedIn 프로필이 먼저 나오는데, 이건 좋은 시작이지만 좀 더 해야 할 것 같아요.\n\n- LinkedIn 프로필을 확인하고 이 블로그를 연결해야 해요. 또한 네트워킹을 돕기 위해 더 활발히 활동해야 해요. 게시물에 참여하고, 관련 그룹에 가입하고, 산업 통찰을 공유하는 것이 도움이 될 거예요.\n- 내 GitHub 계정에 활동을 더 넣어야 해요. 이를 위해 작은 프로젝트를 만들 계획이고, 매주 최소 다섯 번 커밋을 푸시할 겁니다. 특히 React에서의 프런트엔드 개발 스킬을 강조하는 프로젝트를 전시해야 할 거예요.\n\n![이미지](/assets/img/2024-06-20-TryingtogetaRemoteFront-EndSoftwareEngineeringRolein2024Part3ThePlan_2.png)\n\n<div class=\"content-ad\"></div>\n\n- 내 웹사이트는 기본적이고 업데이트가 필요합니다. 사이트가 간단하고 정적이더라도 개선할 여지가 많다고 생각합니다. 최고의 작품을 강조하기 위해 포트폴리오 섹션을 추가하고 기술적인 통찰을 공유하기 위해 블로그를 포함할 것입니다.\n\n![2024-06-20-TryingtogetaRemoteFront-EndSoftwareEngineeringRolein2024Part3ThePlan_3.png](/assets/img/2024-06-20-TryingtogetaRemoteFront-EndSoftwareEngineeringRolein2024Part3ThePlan_3.png)\n\n- 블로깅은 온라인 활동을 늘리는 데 큰 도움이 될 것입니다. 하지만 다른 목표에 시간을 내기 위해 얼마나 많이 쓸지 전략적으로 고려해야 할 것입니다. 향후 게시물은 좀 더 기술적이고 집중된 내용일 것입니다. 이 블로그를 통해 나의 글쓰기 능력을 쇼케이스하려고 합니다.\n\n## 프로젝트 만들기\n\n<div class=\"content-ad\"></div>\n\n지난 몇 년 동안 개발한 제품들은 인터넷 상에서 사용 중이지만, 이들은 소매 웹사이트에 내장되어 있어 제 참여가 명백하지 않습니다.\n\n- GitHub에서 제 전용의 최근 프로젝트 몇 개를 가지고 있다면 온라인 활동 중심을 구축하는 데 도움이 될 것입니다. 좋은 git 관행을 준수하고 거의 매일 조금씩 프로젝트에 노력할 수 있다면, 제 기술을 예시로 보여주면서 GitHub 프로필을 소상하기 위해 노력할 수 있을 것입니다.\n- 지난 몇 년간 주로 Vue에서 작업했으므로 React 연습이 필요하며, React 관련 질문과 코드 도전에 자신감을 가질 필요가 있습니다. React의 최신 기능 중 일부를 활용하여 프로젝트를 개발하는 것이 좋은 시작점이 될 것입니다.\n- 이들 프로젝트를 사용하여 이력서로 제대로 전달하기 어려운 기술을 보여줄 수 있습니다. 예를 들어, 지속적 적용 및 배포와 관련된 여러 작업에 참여했는데, 통합 테스트를 작성하고, Jenkins 파이프라인을 설정하고, Groovy 파일을 수정하고, E2E 팀과 협업하여 파이프라인 오류를 해결하는 등의 작업을 했습니다. 파이프라인 작업은 유용한 기술이지만, 보여주기 어려운 기술이기도 합니다. 제 경험의 일부를 더 보여줄 수 있도록 GitHub 액션과 웹훅을 이용해 간단한 미니 파이프라인을 시작해보고 싶습니다.\n\n할 일이 좀 있지만, 이들 프로젝트를 작고 명확하게 유지해서 제 작업을 세상에 내놓을 수 있도록 하는 게 목표입니다.\n\n## 네트워크\n\n<div class=\"content-ad\"></div>\n\n저는 저의 성장 분야 중 하나로 관계 유지를 유지하는 것이 중요하다고 생각합니다. 가능한 취직 기회를 찾을 때 지금 보이는 대화를 시작하는 것은 솔직하지 않은 느낌이 들어요.\n\n그 아이디어에 불편함을 느끼며 그냥 앉아서 불편한 마음으로 머물러야 하는 것 같아요. 미래에 더 열심히 노력하면서 관계 유지에 노력해야 한다는 점을 스스로 상기시키도록 노력하고 있어요. 또한 아래 사항을 상기시키려고 노력하고 있어요:\n\n- 저는 정말 재능 있는 사람들과 함께 일해본 적이 있고, 그들이 어떻게 지내고 있는지 궁금해합니다.\n- 이 산업에서는 네트워킹이 기대되요. 전에 일했던 사람들 덕분에 지금 있는 역할을 얻을 수 있었어요.\n- 이와 비슷한 상황에서 사람들이 나에게 연락해온 경우, 그들과 이야기를 나누고 도와주는 데 즐거움을 느꼈어요.\n- 사람들은 답장하지 않을 수도 있고, 그들의 반응을 제어할 수 없다는 사실을 인정해야 해요.\n\n그냥 해야겠어요 — 내가 아는 사람들에게 연락하고 어떤 기회가 있는지 확인해 보세요. 매주 내 네트워크에서 두 명의 사람과 연결하려고 노력할 거예요. 이 글을 올린 후에도 LinkedIn에 일반적인 포스트를 할 거에요.\n\n<div class=\"content-ad\"></div>\n\n## 취업 지원 시작하기\n\n나는 정기적으로 이력서를 보내고 커버레터를 조정하는 습관을 들여야 해. 매 주 최소 두 건의 지원서를 보내는 것을 목표로 삼을 거야. 각 회사를 조사하고 그들의 요구사항과 일치하도록 지원서를 맞춤화할 거야.\n\n## 면접 준비\n\nJavaScript 기술적인 도전과 React 코드 도전을 꾸준히 연습해야 해. Codewars나 LeetCode와 같은 플랫폼을 활용하여 내 실력을 향상시킬 것이고, 최소 주당 2개의 코드 도전에 도전하려고 해. 또한 많은 온라인 목록에서 자주 나오는 기술 면접 질문이 있고 YouTube에는 연습용으로 삼을 수 있는 다양한 모의 면접 영상들이 있다. 그 외에도 다른 사람 앞에서 이야기할 수 있는 연습의 추가적인 부분을 얻기 위해 실제 모의 면접 기회를 찾아볼 거야.\n\n<div class=\"content-ad\"></div>\n\n면접 요청을 받게 되면, 기업별로 준비를 집중하고 일반적이거나 문화적인 면접 질문에 대한 연습을 합니다. 면접 하루 전이나 이틀 전에는 면접 조건을 모방하고 대답을 크게 음성으로 말해보는 연습도 해봅니다.\n\n## 계획 시각화\n\n로드맵에 설정된 이러한 목표는 대략 다음과 같이 보일 것입니다:\n\n![image](/assets/img/2024-06-20-TryingtogetaRemoteFront-EndSoftwareEngineeringRolein2024Part3ThePlan_4.png)\n\n<div class=\"content-ad\"></div>\n\n모든 계획과 마찬가지로, 시작하고 필요에 따라 조정할 거예요. 예를 들어, 온라인 프로젝트가 더 많아지면 신청서 작성과 면접 준비에 더 많은 시간을 할애할 수 있을 거예요. 하지만 처음에는 할당량을 작게 설정하는 게 좋아요. 이미 지난 두 주간 이러한 목표를 이루기 위해 노력하기 시작했는데, 이러한 이정표를 빠르게 달성하는 것이 격려되고 생산적이라는 느낌이 들어요.\n\n## 최종 생각\n\n이 모든 것을 적어내리는 것의 가치 중 하나는 머리 속에 떠다니는 아이디어를 실행 가능한 작업으로 전환한다는 점이에요. 이는 정신적 부담을 줄이고 따를 길을 제시해줘요. 계획이 세워지면 많은 시간을 그냥 내 앞에 있는 작업에 집중할 수 있어요.\n\n오케이. 계획 작성 완료했어요.\n\n<div class=\"content-ad\"></div>\n\n이것을 실행할 시간입니다.","ogImage":{"url":"/assets/img/2024-06-20-TryingtogetaRemoteFront-EndSoftwareEngineeringRolein2024Part3ThePlan_0.png"},"coverImage":"/assets/img/2024-06-20-TryingtogetaRemoteFront-EndSoftwareEngineeringRolein2024Part3ThePlan_0.png","tag":["Tech"],"readingTime":6},{"title":"비주얼 스튜디오 코드에서 Flutter 설정하기 단계별 가이드","description":"","date":"2024-06-20 13:54","slug":"2024-06-20-SettingUpFlutterinVisualStudioCodeAStep-by-StepGuide","content":"\n\n# 소개:\n\n플러터(Flutter)는 구글의 오픈소스 UI 툴킷으로, 크로스 플랫폼 앱 개발에 대한 인기 있는 선택지가 되었습니다. 플러터의 모든 기능을 활용하기 위해서는 코딩 프로세스를 최적화하는 개발 환경을 설정하는 것이 중요합니다. Visual Studio Code(VSCode)는 가벼우면서도 강력한 코드 편집기로 플러터와 완벽하게 통합되어 풍부한 기능의 애플리케이션을 구축하는 데 견고한 환경을 제공합니다. 본 문서에서는 Visual Studio Code에서 플러터를 설정하는 단계별 프로세스를 안내합니다.\n\n# 필수 조건:\n\n설정 프로세스에 들어가기 전에 시스템에 다음 필수 조건이 설치되어 있는지 확인하세요:\n\n<div class=\"content-ad\"></div>\n\n1. Flutter SDK:\n공식 Flutter 웹사이트 (https://flutter.dev/docs/get-started/install)에서 Flutter SDK를 다운로드하고 설치해주세요.\n\n2. Dart SDK:\nFlutter는 Dart 프로그래밍 언어에 의존합니다. Dart SDK를 Dart SDK 다운로드 페이지 (https://dart.dev/get-dart)에서 다운로드하고 설치해주세요.\n\n3. Visual Studio Code:\n아직 설치하지 않았다면, 공식 VSCode 웹사이트 (https://code.visualstudio.com/)에서 Visual Studio Code를 다운로드하고 설치해주세요.\n\n위 사항을 모두 설치한 후, 다음 단계를 따라 Visual Studio Code에서 Flutter를 설정해주세요:\n\n<div class=\"content-ad\"></div>\n\n단계 1: 플러터 익스텐션 설치하기\n\nVisual Studio Code를 열고, 창의 측면에 있는 활동 표시줄의 익스텐션 아이콘을 클릭하거나 단축키 `Ctrl+Shift+X`를 사용하여 익스텐션 뷰로 이동합니다.\n\n익스텐션 뷰 검색 창에서 \"Flutter\"를 검색합니다. Dart Code 팀에서 발행한 공식 플러터 익스텐션을 찾습니다. 설치 버튼을 클릭하여 익스텐션을 설치합니다.\n\n단계 2: Dart SDK 설치하기\n\n<div class=\"content-ad\"></div>\n\n비슷하게, 확장 프로그램 보기 검색 창에서 \"Dart\"를 검색하고 Dart 확장 프로그램을 설치하세요. 이 확장 프로그램은 Flutter가 구축된 Dart 프로그래밍 언어를 지원합니다.\n\n단계 3: Flutter SDK 경로 설정\n\nFlutter 확장 프로그램을 설치한 후에는 `Ctrl+Shift+P` (Windows/Linux) 또는 `Cmd+Shift+P` (Mac)를 눌러 명령 팔레트를 열고 `Flutter: Select Flutter SDK` 명령을 실행해주세요. Flutter SDK를 설치한 경로를 선택하세요.\n\n단계 4: 새로운 Flutter 프로젝트 만들기\n\n<div class=\"content-ad\"></div>\n\n이제 플러터 환경이 설정되었으니 새 플러터 프로젝트를 만들어 보세요. 명령 팔레트를 열고 (`Ctrl+Shift+P` 또는 `Cmd+Shift+P`) `Flutter: New Project` 명령을 실행하세요. 프로젝트 이름과 위치를 지정하는 프롬프트에 따라 진행하면 됩니다.\n\n단계 5: VSCode에서 프로젝트 열기\n\n새로 만든 플러터 프로젝트 폴더를 Visual Studio Code에서 열어보세요. “파일” > “폴더 열기”를 선택하고 플러터 프로젝트를 생성한 폴더를 선택하면 됩니다.\n\n단계 6: 플러터 앱 실행\n\n<div class=\"content-ad\"></div>\n\nVSCode에서 터미널을 열어주시고 (`보기` > `터미널 또는` `Ctrl+`` `) `cd` 명령어를 사용하여 프로젝트 폴더로 이동한 다음 다음 명령어를 실행해주세요:\n\n이 명령어는 연결된 에뮬레이터나 장치에서 Flutter 앱을 빌드하고 실행할 것입니다.\n\n# 결론:\n\nVisual Studio Code에서 Flutter를 설정하는 것은 개발 경험을 크게 향상시키는 간단한 프로세스입니다. Flutter 및 Dart 확장 기능을 사용하면 강력한 도구, 디버깅 기능, 그리고 크로스 플랫폼 응용 프로그램을 쉽게 작성할 수 있는 다채로운 기능에 액세스할 수 있습니다. 이 단계별 안내에 따라 Visual Studio Code에서 생산적인 Flutter 개발 환경을 구축했습니다. 즐거운 코딩되세요!","ogImage":{"url":"/assets/img/2024-06-20-SettingUpFlutterinVisualStudioCodeAStep-by-StepGuide_0.png"},"coverImage":"/assets/img/2024-06-20-SettingUpFlutterinVisualStudioCodeAStep-by-StepGuide_0.png","tag":["Tech"],"readingTime":3},{"title":"플러터에서 Firebase Cloud Messaging API HTTP V1를 사용하는 방법","description":"","date":"2024-06-20 13:52","slug":"2024-06-20-HowtouseFirebaseCloudMessagingAPIHTTPV1inFlutter","content":"\n\n만약 해당 이야기가 유용하다고 생각되면 왼쪽에 50개의 박수를 주세요.\n\n최근 Firebase Messages가 HTTP V1으로 이주되었습니다. Flutter 콘솔에서는 다음과 같이 보입니다.\n\n![image](/assets/img/2024-06-20-HowtouseFirebaseCloudMessagingAPIHTTPV1inFlutter_0.png)\n\n본 문서에서는 새 API로 이주하는 과정을 설명하겠습니다.\n\n<div class=\"content-ad\"></div>\n\n# 단계 1. 발신자 ID 수집하기\n\n`프로젝트 설정`에서` 클라우드 메시징`으로 이동하여 발신자 ID를 복사하고, 나중에 사용할 겁니다.\n\n페이지로 이동: [이 링크](https://console.firebase.google.com/u/0/project/PROJECT_NAME/settings/cloudmessaging)\n\n![이미지](/assets/img/2024-06-20-HowtouseFirebaseCloudMessagingAPIHTTPV1inFlutter_1.png)\n\n<div class=\"content-ad\"></div>\n\n# 단계 2. Firebase Messaging 클라이언트용 키 수집\n\n1. Firebase 콘솔에서 발신자 ID 옆의 `Manage Service Accounts` 버튼을 클릭합니다. 이 버튼을 클릭하면 https://console.cloud.google.com/iam-admin/serviceaccounts로 이동됩니다.\n\n페이지는 다음과 같이 보여야 합니다:\n\n![이미지](/assets/img/2024-06-20-HowtouseFirebaseCloudMessagingAPIHTTPV1inFlutter_2.png)\n\n<div class=\"content-ad\"></div>\n\n2. 어카운트를 클릭하고 'KEYS' 탭을 선택한 후 키를 추가하세요. 그러면 컴퓨터로 키가 담긴 JSON 파일이 다운로드됩니다.\n\n![이미지](/assets/img/2024-06-20-HowtouseFirebaseCloudMessagingAPIHTTPV1inFlutter_3.png)\n\n이를 리포지토리에 복사하여 붙여넣기하세요 (이 예시에서는 'data/your-key-from-cloud-console.json'에). pubspec.yaml에 에셋 경로를 추가하는 것을 잊지 마세요.\n\n# 단계 3. 구글 API Auth 라이브러리 설치\n\n<div class=\"content-ad\"></div>\n\n```js\nflutter pub add googleapis_auth\n```\n\n# 단계 4. 코드\n\n기존의 HTTP 요청은 다음과 같았습니다:\n\n```js\n// 더 이상 유효하지 않은 코드:\n\nhttp.post(\n  Uri.parse('https://fcm.googleapis.com/fcm/send'),\n  headers: {\n    'Content-Type': 'application/json',\n    'Authorization': 'key=$fcmServerToken',\n  },\n  body: body,\n)\n```\n\n<div class=\"content-ad\"></div>\n\n구글 API 인증 라이브러리를 사용해야 하는 새로운 유효한 코드입니다.\n\n```dart\nimport 'package:googleapis_auth/auth_io.dart' as auth;\nimport 'dart:convert';\nimport 'package:flutter/services.dart';\nimport 'dart:developer' as devtools show log;\n\nFuture<bool> sendPushMessage({\n  required String recipientToken,\n  required String title,\n  required String body,\n}) async {\n  final jsonCredentials = await rootBundle\n      .loadString('data/your-key-from-cloud-console.json');\n  final creds = auth.ServiceAccountCredentials.fromJson(jsonCredentials);\n  \n  final client = await auth.clientViaServiceAccount(\n    creds,\n    ['https://www.googleapis.com/auth/cloud-platform'],\n  );\n  \n  final notificationData = {\n    'message': {\n      'token': recipientToken,\n      'notification': {'title': title, 'body': body}\n    },\n  };\n  \n  const String senderId = '736705283357';\n  final response = await client.post(\n    Uri.parse('https://fcm.googleapis.com/v1/projects/$senderId/messages:send'),\n    headers: {\n      'content-type': 'application/json',\n    },\n    body: jsonEncode(notificationData),\n  );\n  \n  client.close();\n  if (response.statusCode == 200) {\n    return true; // Success!\n  }\n\n  devtools.log(\n      'Notification Sending Error Response status: ${response.statusCode}');\n  devtools.log('Notification Response body: ${response.body}');\n  return false;\n}\n```\n\n감사합니다! 이 스토리가 유용하다면 왼쪽에 50개의 박수를 남겨주세요.","ogImage":{"url":"/assets/img/2024-06-20-HowtouseFirebaseCloudMessagingAPIHTTPV1inFlutter_0.png"},"coverImage":"/assets/img/2024-06-20-HowtouseFirebaseCloudMessagingAPIHTTPV1inFlutter_0.png","tag":["Tech"],"readingTime":3},{"title":"플러터에서 빌드 변형 설정하기 포괄적인 안내","description":"","date":"2024-06-20 13:52","slug":"2024-06-20-SettingUpBuildVariantsinFlutterAComprehensiveGuide","content":"\n\n현대 앱 개발에서는 다양한 빌드 변형을 관리하는 것이 중요합니다. 플러터(Flutter)에서 빌드 변형은 개발, 스테이징 및 프로덕션과 같이 여러 버전의 앱을 구성할 수 있도록 해줍니다. 각각이 API 엔드포인트, 기능 플래그 및 기타 환경별 설정과 같은 고유의 구성을 가지고 있습니다. 이 안내서에서는 플러터 프로젝트에서 빌드 변형을 설정하는 방법을 안내해 드릴 예정입니다.\n\n# 단계 1: 구성 파일 만들기\n\n첫 번째 단계는 각 빌드 변형을 위한 별도의 구성 파일을 만드는 것입니다. 이러한 파일에는 환경별 설정이 포함됩니다.\n\n- 플러터 프로젝트의 루트에 config 디렉토리를 생성합니다.\n- 각 빌드 변형을 위해 config 디렉토리 내에 JSON 구성 파일을 추가합니다:\n\n<div class=\"content-ad\"></div>\n\n- config/development.json\n- config/staging.json\n- config/production.json\n\n각 구성 파일은 다음과 같을 수 있습니다:\n\n![이미지](/assets/img/2024-06-20-SettingUpBuildVariantsinFlutterAComprehensiveGuide_0.png)\n\n# 단계 2: 구성 로더 생성\n\n<div class=\"content-ad\"></div>\n\n다음으로, 빌드 변형에 따라 적절한 구성 파일을 로드할 클래스를 만들어보겠습니다.\n\n- lib/config_loader.dart라는 새 파일을 생성하세요:\n\n```dart\nimport 'dart:convert';\nimport 'package:flutter/services.dart';\n\nclass ConfigLoader {\n  final String environment;\n\n  ConfigLoader({required this.environment});\n\n  Future<Map<String, dynamic>> load() async {\n    final String configString = await rootBundle.loadString('config/$environment.json');\n    return json.decode(configString);\n  }\n}\n```\n\n2. lib/config.dart 파일을 생성하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nclass Config {\n  final String apiBaseUrl;\n  final bool debug;\n\n  Config({required this.apiBaseUrl, required this.debug});\n\n  factory Config.fromJson(Map<String, dynamic> json) {\n    return Config(\n      apiBaseUrl: json['apiBaseUrl'],\n      debug: json['debug'],\n    );\n  }\n}\n```\n\n![Setting up build variants in Flutter](/assets/img/2024-06-20-SettingUpBuildVariantsinFlutterAComprehensiveGuide_1.png)\n\n# 단계 3: 설정을 사용하도록 메인 파일 수정\n\n빌드 변형에 기반하여 구성 파일을 로드하도록 메인.dart 파일을 수정하세요.\n\n<div class=\"content-ad\"></div>\n\n- 구성을로드하도록 main.dart를 아래와 같이 편집하세요\n\n```js\nFuture<void> main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n  String envFile = \"development\";\n\n  const flavor = String.fromEnvironment('FLAVOR');\n\n  switch (flavor) {\n    case 'development':\n      envFile = \"development\";\n      break;\n    case 'staging':\n      envFile = \"staging\";\n      break;\n    case 'production':\n      envFile = \"release\";\n      break;\n  }\n\n  // 구성로드\n  final configLoader = ConfigLoader(environment: envFile); // 환경에 따라 변경\n  final config = await configLoader.load();\n\n  print(config.apiBaseUrl);\n  runApp(const MyApp());\n}\n```\n\n# 단계 4: build.gradle (Android)에서 빌드 변형 정의\n\nandroid/app/build.gradle 파일에 build variants를 정의하십시오. 이렇게하면 환경 변수를 Dart 코드로 전달할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n- 안드로이드 앱의 build.gradle 파일을 편집하세요:\n\n```js\nandroid {\n    ...\n\n    flavorDimensions \"env\"\n    productFlavors {\n        dev {\n            dimension \"env\"\n            buildConfigField \"String\", \"ENV\", \"\\\"development\\\"\"\n        }\n        staging {\n            dimension \"env\"\n            buildConfigField \"String\", \"ENV\", \"\\\"staging\\\"\"\n        }\n        prod {\n            dimension \"env\"\n            buildConfigField \"String\", \"ENV\", \"\\\"production\\\"\"\n        }\n    }\n}\n```\n\n# 단계 5: (iOS)에서 빌드 변형 정의하기\n\n## 설정 구성:\n\n<div class=\"content-ad\"></div>\n\n- 워크스페이스 파일 열기:\n\n프로젝트를 .xcodeproj 파일이 아닌 .xcworkspace 파일을 사용하여 열어야 합니다. 워크스페이스 파일에는 CocoaPods나 기타 도구로 관리되는 프로젝트와 종속성에 대한 참조가 포함되어 있습니다.\n\n2. 프로젝트 설정으로 이동:\n\n- Xcode에서 프로젝트 네비게이터(일반적으로 왼쪽에 위치)에서 프로젝트를 선택합니다.\n- 이렇게 하면 다양한 설정을 구성할 수 있는 프로젝트 편집기가 열립니다. \n\n<div class=\"content-ad\"></div>\n\n3. 환경 설정 관리:\n\n- 프로젝트 네비게이터 상단에 있는 프로젝트 이름을 클릭하여 프로젝트 설정에 액세스합니다.\n- 다른 빌드 설정을 구성하려는 대상을 선택합니다 (예: Runner).\n\n4. 환경 설정 추가 또는 편집:\n\n- 정보 탭을 클릭합니다.\n- Debug 및 Release와 같은 다양한 빌드 구성을 관리할 수 있는 환경 설정 섹션을 볼 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n+ 버튼을 클릭하고 \"Debug\"을 복제하거나 \"Release\"를 복사하여 사용자 정의 구성물을 추가할 수 있어요. 그리고 나서 그 구성물을 원하는 대로 (예: Debug-staging, Debug-production) 이름을 바꿔주세요.\n\n5. 빌드 설정 구성:\n\n- 새로 생성된 구성물을 선택합니다.\n- 필요에 따라 빌드 설정을 조정합니다. 일반적으로 API 엔드포인트, 환경 변수 또는 각 구성에 특정한 번들 식별자와 같은 설정이 포함됩니다.\n\n6. 변경 사항을 저장하세요.\n\n<div class=\"content-ad\"></div>\n\n- 변경을 저장하려면 파일 ` 저장 또는 Cmd + S를 클릭하세요.\n\n## 설정 체계:\n\n- 체계 수정:\n\n- Xcode에서 툴바에 있는 일반적으로 중지 버튼 옆의 체계 드롭다운을 클릭합니다.\n- 체계 수정...을 선택합니다.\n\n<div class=\"content-ad\"></div>\n\n### 2. 스킴 구성 관리:\n\n- 스킴 편집기에서 동작 목록을 볼 수 있습니다 (예: 실행, 테스트, 프로파일 등).\n- 각 동작에는 고유한 구성이 있습니다 (예: 실행 동작의 디버그).\n- 기존 구성 (예: 디버그)을 복제하여 새로운 구성 (예: 릴리스, 스테이징)을 만들 수 있습니다.\n\n### 3. 스킴별 빌드 구성 설정:\n\n- 각 동작 (예: 실행)에 대해 드롭다운에서 적절한 빌드 구성 (디버그, 릴리스 또는 사용자 정의 구성)을 선택하세요.\n\n<div class=\"content-ad\"></div>\n\n4. 실행 대상 구성하기:\n\n- 동일한 Scheme 편집기에서 앱이 실행될 대상을 구성할 수 있습니다 (예: 시뮬레이터 장치 유형, 연결된 장치).\n\n- Scheme 변경 사항 저장하기:\n\n- Scheme 변경 사항을 저장하려면 확인을 클릭하세요.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-20-SettingUpBuildVariantsinFlutterAComprehensiveGuide_2.png)\n\n# 단계 6. 다른 플레이버 실행/빌드하기\n\n명령줄을 사용하여 원하는 플레이버로 앱을 실행하세요. --flavor 플래그와 -t 플래그를 사용하여 빌드 플레이버와 대상 파일을 지정합니다.\n\n터미널에서 아래의 주석을 사용하세요\n\n\n<div class=\"content-ad\"></div>\n\n\nflutter run --flavor development -t lib/main.dart // 개발용\n\nflutter run --flavor staging -t lib/main.dart    // 스테이징용\n\nflutter run --flavor production -t lib/main.dart // 프로덕션 또는 릴리스용\n\n\nAndroid 빌드하려면 터미널에서 다음 주석을 사용하세요\n\n\nflutter build apk --flavor development -t lib/main.dart\n\nflutter build apk --flavor staging -t lib/main.dart\n\nflutter build apk --flavor production -t lib/main.dart\n\n\niOS 빌드하려면 터미널에서 다음 주석을 사용하세요\n\n\n<div class=\"content-ad\"></div>\n\n```js\nflutter build ios --flavor development -t lib/main.dart\n\nflutter build ios --flavor staging -t lib/main.dart\n\nflutter build ios --flavor production -t lib/main.dart\n```\n\n# 단계 6: 또한 안드로이드 스튜디오에서 실행 구성 설정을 설정할 수 있습니다\n\n- 실행/디버그 구성을 엽니다:\n\n- 안드로이드 스튜디오에서 Run ` Edit Configurations...`로 이동합니다.\n\n<div class=\"content-ad\"></div>\n\n2. 새로운 Flutter 구성 만들기:\n\n- 새 구성을 추가하려면 + 버튼을 클릭합니다.\n- 목록에서 Flutter를 선택합니다.\n\n3. 개발 플레이버 구성하기:\n\n- 구성 이름을 Flutter 개발과 같이 지정합니다.\n- 대상을 main.dart로 설정합니다.\n- 추가 실행 인수 필드에서 다트 정의로 플레이버를 추가합니다: --dart-define=FLAVOR=development.\n- 선택적으로 빌드 섹션 아래에서 개발을 빌드 플레이버 필드로 설정할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n4. 스테이징 플레이버 구성:\n\n- 다른 구성을 만들기 위해 위 단계를 반복합니다.\n- 이름을 플러터 스테이징으로 지정합니다.\n- 타겟을 main.dart로 설정합니다.\n- 추가 실행 인수 필드에 Dart Define으로 플레이버를 추가합니다: --dart-define=FLAVOR=staging.\n- 빌드 플레이버 필드를 스테이징으로 설정합니다.\n\n5. 프로덕션 플레이버 구성:\n\n- 다른 구성을 만들기 위해 단계를 반복합니다.\n- 이름을 플러터 프로덕션으로 지정합니다.\n- 타겟을 main.dart로 설정합니다.\n- 추가 실행 인수 필드에 Dart Define으로 플레이버를 추가합니다: --dart-define=FLAVOR=production.\n- 빌드 플레이버 필드를 프로덕션으로 설정합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-20-SettingUpBuildVariantsinFlutterAComprehensiveGuide_3.png)\n\n# 결론\n\n위의 단계를 따라가면, 플러터 앱에서 여러 빌드 변형을 효율적으로 관리하여 개발, 테스트 및 프로덕션을 위한 다른 환경을 유지하기 쉬워집니다. 이 설정을 통해 각 빌드 변형이 자체 구성 및 리소스를 가질 수 있도록하여 개발 및 배포 프로세스를 더 효율적으로 할 수 있습니다.\n\n의문이나 질문이 있으면 언제든지 연락해 주세요. LinkTree를 통해 저에게 연락할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n행복한 코딩하세요! :)","ogImage":{"url":"/assets/img/2024-06-20-SettingUpBuildVariantsinFlutterAComprehensiveGuide_0.png"},"coverImage":"/assets/img/2024-06-20-SettingUpBuildVariantsinFlutterAComprehensiveGuide_0.png","tag":["Tech"],"readingTime":7},{"title":"플러터 vs 코틀린 멀티플랫폼 크로스 플랫폼 개발의 미래","description":"","date":"2024-06-20 13:50","slug":"2024-06-20-FluttervsKotlinMultiplatformTheFutureofCross-PlatformDevelopment","content":"\n\n<img src=\"/assets/img/2024-06-20-FluttervsKotlinMultiplatformTheFutureofCross-PlatformDevelopment_0.png\" />\n\n모바일 앱 개발은 더 이상 어려운 일이 되어갑니다. 아름다운 인터페이스, 뛰어난 성능, 그리고 모든 플랫폼의 사용자에게 도달하는 능력을 원합니다. 그러나 안드로이드와 iOS용 네이티브 앱을 코딩하는 시간(또는 예산)이 있는 사람은 누구일까요? 여기 모바일, 웹, 그리고 데스크톱용 앱의 신들: Flutter와 Kotlin Multiplatform (KMP)이 나서 있습니다.\n\n# 왼쪽 구석, 관중들의 애호가: Flutter!\n\n날렵한 Dart 언어와 강력한 렌더링 엔진으로 Flutter는 단일 코드베이스로 모바일, 웹, 데스크톱용 매력적이고 네이티브한 느낌의 앱을 만들 수 있습니다. 앱 개발을 위한 레고 블록을 생각해보세요 — 재사용 가능한 위젯을 함께 조립하여 상상하는 모든 것을 만들어냅니다. Flutter는 초고속 개발 주기를 위한 핫 리로드 기능과 여러분을 돕기 위해 함께 해 줄 거대한 커뮤니티를 자랑합니다.\n\n<div class=\"content-ad\"></div>\n\n# 하지만, 도전자가 나타났어요! Kotlin Multiplatform이 무대에 등장했습니다!\n\n이 챔피언은 항상 인기 있는 Kotlin 언어를 활용하여 앱의 로직을 여러 플랫폼 간에 공유할 수 있게 해줍니다. KMP는 네이티브 성능과 UI에서 빛을 발하는데 — 안드로이드나 iOS에서도 각 플랫폼에 맞는 코드를 작성하여 앱이 훌륭하게 동작하도록 할 수 있습니다.\n\n## 그래서, 이 에픽 배틀에서 누가 이길까요?\n\n## 자세한 전투를 살펴보겠습니다!\n\n<div class=\"content-ad\"></div>\n\n라운드 1: 개발 속도\n\n플러터의 핫 리로드 및 단일 코드베이스는 빠른 개발을 위한 명확한 우승자입니다. 변경 사항이 즉시 반영되어 코딩 열풍을 유지할 수 있습니다.\n\n라운드 2: 네이티브 느낌과 성능\n\nKMP는 여기서 플러터를 제쳐두고 있습니다. 일부 네이티브 UI 개발을 허용함으로써 KMP는 각 플랫폼에서 앱이 진정으로 편안함을 느끼도록 보장합니다. 게다가 일부 경우에는 KMP가 성능을 조금 더 끌어올릴 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n라운드 3: 학습 곡선\n\n만약 Kotlin에 익숙하다면 KMP는 더 익숙할 수 있습니다. 그러나 Flutter의 Dart 언어는 비교적 쉽게 배울 수 있으며 다양한 자원들이 풍부하여 빠르게 습득할 수 있습니다.\n\n라운드 4: 커뮤니티와 지원\n\nFlutter와 KMP는 열정적인 커뮤니티를 보유하고 있지만, Flutter의 더 많은 사용자들로 인해 더 많은 자원과 튜토리얼을 쉽게 찾을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 강점과 약점을 확인해봅시다\n\n## Flutter의 강점\n\n- 단일 코드베이스: 한 번 작성하여 여러 플랫폼에서 실행할 수 있습니다. Flutter를 사용하면 Android, iOS, 웹 및 데스크톱 애플리케이션에 대해 단일 코드베이스를 사용할 수 있습니다.\n- 핫 리로드: 앱을 다시 시작하지 않고 실시간으로 변경 사항을 확인할 수 있어 개발 프로세스를 가속화합니다.\n- 풍부한 위젯 라이브러리: 맞춤 설정 가능한 다양한 위젯 컬렉션을 제공하여 복잡한 UI를 쉽게 작성할 수 있습니다.\n- 성능: Flutter의 성능은 컴파일된 성격과 효율적인 렌더링 엔진으로 인해 원시 앱에 근접합니다.\n\n## Flutter의 약점\n\n<div class=\"content-ad\"></div>\n\n- 앱 크기: 플러터 앱은 네이티브 앱에 비해 더 큰 파일 크기를 가질 수 있습니다.\n- 제한된 생태계: 성장하고 있지만, 플러터의 생태계는 여전히 더 확립된 프레임워크보다 작을 수 있습니다.\n- Dart 언어: Dart는 JavaScript 또는 Kotlin과 같은 언어보다 널리 사용되지 않아 처음 개발자들에게는 학습 곡선이 있을 수 있습니다.\n\n## 코틀린 멀티플랫폼의 장점\n\n- 공유 비즈니스 로직: 네이티브 UI를 유지하면서 여러 플랫폼 간에 비즈니스 로직을 공유할 수 있습니다.\n- 상호 운용성: 코틀린은 자바와 100% 상호 운용이 가능하여 기존 안드로이드 프로젝트와 쉽게 통합할 수 있습니다.\n- 네이티브 성능: 코틀린 멀티플랫폼을 통해 플랫폼별 UI가 가능하므로 성능이 네이티브 응용 프로그램과 동등합니다.\n- 성장하는 커뮤니티: 구글의 코틀린을 안드로이드 개발의 선호 언어로 지원하면서 코틀린 커뮤니티가 견고히 성장하고 있습니다.\n\n## 코틀린 멀티플랫폼의 약점\n\n<div class=\"content-ad\"></div>\n\n- 복잡성: 플랫폼별 코드와 공유 코드를 함께 관리하는 것은 복잡할 수 있으며 신중한 아키텍처가 필요합니다.\n- 툴 및 라이브러리 한정성: Kotlin Multiplatform을 위한 툴과 서드파티 라이브러리는 Flutter용 것만큼 성숙하지 않습니다.\n- 학습 곡선: 개발자들은 Kotlin과 해당 플랫폼 고유의 개발 환경에 익숙해져야 합니다.\n\n# 사용 사례\n\n## Flutter를 사용해야 하는 경우\n\n- 스타트업 및 MVPs: 최소한의 제품을 빠르게 개발하고 배포할 때\n- 통일된 UI: 여러 플랫폼에 걸쳐 일관된 UI가 필요할 때\n- 개발 효율성: 개발 속도와 효율성이 중요할 때\n\n<div class=\"content-ad\"></div>\n\n## Kotlin Multiplatform을 사용해야 하는 경우\n\n- 기존 프로젝트: 기존 안드로이드 프로젝트와 통합할 때.\n- 플랫폼별 UI: 플랫폼별 UI를 필요로하지만 비즈니스 로직을 공유하고 싶을 때.\n- 성능 중심 애플리케이션: 성능과 네이티브 통합이 중요한 경우.\n\n# 최종 결론: 비김!\n\nFlutter와 KMP는 모두 크로스 플랫폼 개발에 탁월한 선택지입니다. 여러분의 우선 순위를 고려해보세요: 빠른 개발과 통합된 코드베이스? Flutter를 선택하세요. 화려한 UI와 최고의 성능? KMP가 당신의 최고의 선택일 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n그렇죠! 두 가지를 시도해 보는 게 최선의 방법입니다. 조금 실험을 해보면, 어떤 도구가 빠르게 훌륭한 모바일 앱을 만드는 데 도움이 되는지 알아낼 거예요.\n\n# 자주 묻는 질문\n\n## 1. 어떤 프레임워크가 더 좋은 성능을 제공하나요: Flutter 또는 Kotlin Multiplatform?\n\n두 프레임워크 모두 우수한 성능을 제공하지만, 접근 방식이 다릅니다. Flutter는 컴파일된 성질과 효율적인 렌더링 엔진 덕분에 네이티브에 가까운 성능을 제공합니다. Kotlin Multiplatform은 플랫폼별 UI를 허용하기 때문에 UI가 해당 플랫폼의 네이티브 언어로 작성되어 성능이 네이티브 앱과 크게 차이나지 않을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 2. Dart을 배우기 어렵다고 생각하시나요? Kotlin과 비교하여\n\n이것은 당신의 배경에 달려 있어요. Dart는 상대적으로 쉽게 배울 수 있습니다, 특히 JavaScript 경험이 있는 경우에요. Kotlin 또한 간단하게 배우기 쉬운 편이며, 특히 Java 배경이 있는 경우에는 Java와 완전히 상호 운용 가능하기 때문에요.\n\n## 3. Flutter를 웹 개발에 사용할 수 있나요?\n\n네, Flutter는 웹 개발을 지원해요. 동일한 코드베이스를 사용하여 모바일 및 데스크톱 애플리케이션에 사용하는 것과 동일한 코드로 반응형 웹 애플리케이션을 만들 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n## 4. 코틀린 Multiplatform은 제작용으로 준비되어 있나요?\n\n코틀린 Multiplatform은 여전히 발전 중이지만 이미 많은 회사들이 제작 단계에서 사용하고 있습니다. 특히 각 플랫폼별 UI 코드를 유지하면서 비즈니스 로직을 공유하는 데 도움이 됩니다.\n\n## 5. 새로운 스타트업을 위해 어떤 프레임워크를 선택해야 하나요?\n\n새로운 스타트업이나 MVP의 경우, 플러터는 개발 주기가 빠르고 다중 플랫폼을 위한 단일 코드베이스, 그리고 다양한 위젯 라이브러리로 인해 종종 더 나은 선택입니다. 모든 플랫폼에서 일관된 UI로 빠르게 시장에 진입할 수 있도록 도와줍니다.","ogImage":{"url":"/assets/img/2024-06-20-FluttervsKotlinMultiplatformTheFutureofCross-PlatformDevelopment_0.png"},"coverImage":"/assets/img/2024-06-20-FluttervsKotlinMultiplatformTheFutureofCross-PlatformDevelopment_0.png","tag":["Tech"],"readingTime":5},{"title":"Flutter 앱을 테마화해보세요 ThemeData와 ColorScheme에 대한 안내","description":"","date":"2024-06-20 13:49","slug":"2024-06-20-ThemeYourFlutterAppAGuidetoThemeDataandColorScheme","content":"\n\n다음을 먼저 말씀드리기 전에 알아두어야 할 점이 있어요. 많은 기사들이 이 주제에 대해 매체와 다른 소스에서 제공되고 있기 때문에, 이 기사의 필요성이 무엇인지 궁금해졌죠?\n\n이 기사에서는 ThemeData 위젯의 주요 포인트와 저의 개발 경험 중 가장 많이 사용하는 매개변수에 초점을 맞추어, 각 매개변수가 어떻게 애플리케이션에 영향을 미치는지에 대해 간단한 설명을 제공할 예정이에요.\n\n궁금하신가요? 계속 읽어보세요 🤗.\n\n## ThemeData 사용의 주요 이점\n\n<div class=\"content-ad\"></div>\n\n- 일관된 외관 유지: 앱의 색상 팔레트, 글꼴, 모양 및 기타 시각 요소를 캡슐화하는 단일 ThemeData 객체를 정의하세요. 이 테마를 모든 화면에 일관되게 적용하여 통일된 및 인식할 수 있는 브랜드 아이덴티티를 유지하세요.\n- 다양한 테마를 생성하세요: 밝은 모드, 어플리케이션 섹션 또는 사용자 환경에 따라 여러 ThemeData 객체를 정의하세요.\n- 한 번 테마를 정의하고 모든 곳에서 사용하세요: 개별 위젯에 시각적 스타일을 수동으로 설정하는 대신 앱에서 적절한 ThemeData를 적용하세요. 이렇게 하면 코드 중복이 줄어들고 유지 관리가 간단해집니다.\n- 중앙 통제 및 업데이트: ThemeData 객체를 변경하면 해당 변경 사항이 자동으로 앱 전체에 퍼지므로 일관성이 유지되고 반복적인 편집이 줄어듭니다.\n- 접근성 있는 변형 만들기: 시각 장애가 있는 사용자를 위한 고대비 테마와 같은 특정 접근성 요구를 가진 사용자를 위한 별도의 ThemeData 객체를 구축하세요.\n\n그래서, ThemeData가 어떻게 도움이 되는지 알게 되었으니, 이것을 어떻게 앱에 구현하는지 알아볼까요? 저랑 함께 하세요 😊.\n\n다크 모드 및 라이트 모드를 위한 기본 테마를 구현하는 간단한 가이드가 여기 있습니다.\n\n## 전역 클래스 생성\n\n<div class=\"content-ad\"></div>\n\n먼저 애플리케이션 내에서 ThemeData를 관리하는 전역 클래스를 만드는 것이 첫 번째 단계입니다. 이 클래스에는 ColorSheme를 사용하여 다른 ThemeData 인스턴스를 만드는 메서드가 포함되어 있습니다.\n\n```dart\nclass GlobalThemData {\n  static ThemeData themeData(ColorScheme colorScheme, Color focusColor) {\n    return ThemeData(colorScheme: colorScheme, focusColor: focusColor);\n  }\n}\n```\n\nfocusColor : 이 색상은 TextFields 및 TextFormField와 같은 위젯에 사용되며 위젯이 기본 포커스를 갖고 있음을 나타냅니다.\n\n나중에 이 기사에서 ColorSheme에 대해 자세히 논의할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이제 GlobalThemeData 클래스에서 직접 액세스할 수 있는 추가적인 공용 변수를 만들 수 있습니다.\n\n- lightColorScheme: 라이트 테마용 ColorScheme을 보유합니다.\n- darkColorScheme: 다크 테마용 ColorScheme을 보유합니다.\n- lightThemeData: 라이트 테마용 ThemeData을 보유합니다.\n\n<div class=\"content-ad\"></div>\n\n`darkThemeData`: 다크 테마를 위한 ThemeData를 보유합니다.\n\n```js\nclass GlobalThemData {\n  static final Color _lightFocusColor = Colors.black.withOpacity(0.12);\n  static final Color _darkFocusColor = Colors.white.withOpacity(0.12);\r\n```\n\n```js\r\n  static ThemeData lightThemeData = themeData(lightColorScheme, _lightFocusColor);\n     \n  static ThemeData darkThemeData = themeData(darkColorScheme, _darkFocusColor);\n  static ThemeData themeData(ColorScheme colorScheme, Color focusColor) {\n    return ThemeData(colorScheme: colorScheme, focusColor: focusColor);\n  }\n  static const ColorScheme lightColorScheme = ColorScheme();\n  static const ColorScheme darkColorScheme = ColorScheme();\n}\r\n```\n\n제 코드를 함께 작성 중이라면 ColorSheme()에서 필수 매개변수 오류 경고를 받을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n다음 단계에서 이를 고칠 수 있어요.\n\n## ColorSheme\n\nColorSheme의 색상은 쌍으로 구성되어 있어요. 첫 번째는 색상 자체이고, 두 번째는 해당 색상에 사용할 수 있는 색상으로, 텍스트 및 다른 요소 등이 있어요.\n\n![ColorSheme](/assets/img/2024-06-20-ThemeYourFlutterAppAGuidetoThemeDataandColorScheme_0.png)\n\n<div class=\"content-ad\"></div>\n\n플러터 ThemData에 컬러 테마를 만들 때 필수 컬러 10가지입니다. 각 컬러의 값은 선택사항입니다.\n\n- primary: 애플리케이션에서 가장 많이 사용되는 색상입니다.\n\n- onPrimary: 텍스트, 아이콘 등 프라이머리 컬러 위에 색상이 적용되는 요소에 사용됩니다.\n\n- secondary: 프라이머리 컬러보다 눈에 띄지 않지만 필요한 요소(필터 칩, 토글 버튼, 배경 요소 등)에 대한 보조 색상을 정의합니다.\n\n<div class=\"content-ad\"></div>\n\nonSecondary: 이 색은 보조 색 위에 적용되는 요소의 색상을 지정하는 데 사용됩니다.\n\nerror: 이 색은 오류 메시지나 경고와 같이 문제를 나타내는 데 사용됩니다. 마치 문제를 나타내기 위해 깜박이는 빨간 불빛인 것처럼요.\n\nonError: 이 색상은 에러 색상 위에 잘 어울리는 텍스트 색으로, 쉽게 읽을 수 있도록 하기 위해 빨간 표지판에 표시되는 흰색 텍스트와 같은 색상이에요.\n\nbackground: 전체 애플리케이션의 주요 배경색입니다. 이는 모든 다른 UI 요소가 배치되는 캔버스로 생각할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n배경색 위에 있는 요소를 색칠하는 데 사용되는 색입니다.\n\n 표면 : 카드, 시트, 대화 상자 등과 같은 UI 요소의 기본 색상으로 사용됩니다.\n\n 표면 위에 있는 요소에 색칠하는 데 사용됩니다.\n\n그래서 우리는 lightColorScheme 및 darkColorScheme 변수를 다음과 같이 설정할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```dart\nstatic const ColorScheme lightColorScheme = ColorScheme(\n    primary: Color(0xFFB93C5D),\n    onPrimary: Colors.black,\n    secondary: Color(0xFFEFF3F3),\n    onSecondary: Color(0xFF322942),\n    error: Colors.redAccent,\n    onError: Colors.white,\n    background: Color(0xFFE6EBEB),\n    onBackground: Colors.white,\n    surface: Color(0xFFFAFBFB),\n    onSurface: Color(0xFF241E30),\n    brightness: Brightness.light,\n  );\n```\n\n```dart\nstatic const ColorScheme darkColorScheme = ColorScheme(\n    primary: Color(0xFFFF8383),\n    secondary: Color(0xFF4D1F7C),\n    background: Color(0xFF241E30),\n    surface: Color(0xFF1F1929),\n    onBackground: Color(0x0DFFFFFF),\n    error: Colors.redAccent,\n    onError: Colors.white,\n    onPrimary: Colors.white,\n    onSecondary: Colors.white,\n    onSurface: Colors.white,\n    brightness: Brightness.dark,\n  );\n```\n\n지금까지 우리는 밝은 테마(light)와 어두운 테마(dark)를 위한 ColorScheme을 설정했어요. 이제 이를 ThemeData에서 어떻게 사용하는지 알아볼게요.\n\n## ThemeData 생성\n\n<div class=\"content-ad\"></div>\n\n우리는 GlobalThemeData의 themeData 메서드를 수정하여 전달할 적절한 ColorScheme 값을 사용하여 ThemeData를 구성해야 합니다.\n\n```js\nstatic ThemeData themeData(ColorScheme colorScheme, Color focusColor) {\n    return ThemeData(\n        colorScheme: colorScheme,\n        canvasColor: colorScheme.background,\n        scaffoldBackgroundColor: colorScheme.background,\n        highlightColor: Colors.transparent,\n        focusColor: focusColor\n       );\n  }\n```\n\n- canvasColor: 전체 화면이나 앱 창의 배경색상을 나타내는 속성입니다. 다른 모든 UI 요소를 배치하는 기본 색상을 정의합니다.\n- scaffoldBackgroundColor: 이것은 특히 scaffold 자체의 배경색상을 정의합니다. 앱 바, 본문 콘텐츠 영역 및 하단 내비게이션 바 (있는 경우)을 포함합니다.\n- highlightColor: 이 속성은 사용자가 위젯을 누르고 누르고 있을 때 잠시 표시되는 색상을 정의합니다. 사용자에게 상호 작용이 등록되었음을 시각적으로 알려줍니다.\n- focusColor: 이 속성은 현재 포커스를 받은 요소를 시각적으로 나타내는 데 사용되는 색상을 정의합니다. 이것은 현재 키보드 입력을 받을 요소를 강조하는데 유용할 수 있습니다.\n\n이것들은 예시일 뿐이며, 살펴볼 다른 ThemeData 옵션이 더 많이 있습니다.\n\n<div class=\"content-ad\"></div>\n\n그래서 최종 GlobalThemeData 클래스는 이렇게 보일 것입니다.\n\n```js\nclass GlobalThemData {\n  static final Color _lightFocusColor = Colors.black.withOpacity(0.12);\n  static final Color _darkFocusColor = Colors.white.withOpacity(0.12);\n\n  static ThemeData lightThemeData =\n      themeData(lightColorScheme, _lightFocusColor);\n  static ThemeData darkThemeData = themeData(darkColorScheme, _darkFocusColor);\n  static ThemeData themeData(ColorScheme colorScheme, Color focusColor) {\n    return ThemeData(\n      colorScheme: colorScheme,\n      canvasColor: colorScheme.background,\n      scaffoldBackgroundColor: colorScheme.background,\n      highlightColor: Colors.transparent,\n      focusColor: focusColor\n    );\n  }\n  static const ColorScheme lightColorScheme = ColorScheme(\n    primary: Color(0xFFB93C5D),\n    onPrimary: Colors.black,\n    secondary: Color(0xFFEFF3F3),\n    onSecondary: Color(0xFF322942),\n    error: Colors.redAccent,\n    onError: Colors.white,\n    background: Color(0xFFE6EBEB),\n    onBackground: Colors.white,\n    surface: Color(0xFFFAFBFB),\n    onSurface: Color(0xFF241E30),\n    brightness: Brightness.light,\n  );\n  static const ColorScheme darkColorScheme = ColorScheme(\n    primary: Color(0xFFFF8383),\n    secondary: Color(0xFF4D1F7C),\n    background: Color(0xFF241E30),\n    surface: Color(0xFF1F1929),\n    onBackground: Color(0x0DFFFFFF),\n    error: Colors.redAccent,\n    onError: Colors.white,\n    onPrimary: Colors.white,\n    onSecondary: Colors.white,\n    onSurface: Colors.white,\n    brightness: Brightness.dark,\n  );\n}\n```\n\n예! 우리는 어플리케이션을 위한 아름다운 테마를 만들었어요. 그 다음 단계는 무엇일까요?\n\n<div class=\"content-ad\"></div>\n\n## ThemeData 설정\n\nMaterialApp에서 원하는 테마를 설정합니다.\n\n```dart\nclass MyApp extends StatelessWidget {\n  const MyApp({Key key}) : super(key: key);\n  \n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      debugShowCheckedModeBanner: false,\n      title: 'Flutter Demo',\n      themeMode: ThemeMode.light, // 또는 ThemeMode.dark\n      theme: GlobalThemData.lightThemeData,\n      darkTheme: GlobalThemData.darkThemeData,\n      home: const ShowCaseHome(),\n    );\n  }\n}\n```\n\n이렇게 하면 기본적인 라이트 테마가 앱에 적용됩니다. 다크 모드로 전환할 수도 있습니다. 동적으로 전환하기 위해 InheritedWidget 또는 Provider의 강력함을 탐험할 수 있습니다. 이 내용은 이 글의 범위를 벗어납니다. 필요하면 향후 글에서 자세히 논의할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n소중한 정보를 얻으셨길 바라요. 읽어 주셔서 감사합니다! 🤗","ogImage":{"url":"/assets/img/2024-06-20-ThemeYourFlutterAppAGuidetoThemeDataandColorScheme_0.png"},"coverImage":"/assets/img/2024-06-20-ThemeYourFlutterAppAGuidetoThemeDataandColorScheme_0.png","tag":["Tech"],"readingTime":8},{"title":"플러터Flutter에서 환경 변수 설정하기","description":"","date":"2024-06-20 13:48","slug":"2024-06-20-ConfiguringEnvironmentVariablesinFlutter","content":"\n\n우리 앱이 개발, 스테이징, 프로덕션 등 여러 환경을 지원해야 하는 경우가 많습니다.\n\n여러 라이브러리를 사용하여 특정 환경과 관련된 변수를 선언할 수 있습니다. 오늘은 Flutter가 이 기능을 네이티브로 제공하여 간단하고 효율적으로 만드는 방법에 대해 설명하려고 합니다.\n\n![이미지](/assets/img/2024-06-20-ConfiguringEnvironmentVariablesinFlutter_0.png)\n\n# 환경 변수 선언\n\n<div class=\"content-ad\"></div>\n\n## dart-define 사용하기\n\nFlutter는 flutter run 및 flutter build 명령에 대해 --dart-define 옵션을 사용하여 환경 변수를 정의하는 쉬운 방법을 제공합니다.\n\n예를 들어, 개발 환경에서 서버 URL을 선언하고 싶다면 다음과 같이 할 수 있습니다:\n\n```js\nflutter run --dart-define server_url=https://mywonderfulserver.development.com\n```\n\n<div class=\"content-ad\"></div>\n\n개발 API 키를 선언하고 싶을 때는 어떻게 하면 될까요? 단순히 다른 --dart-define를 추가하면 됩니다:\n\n```js\nflutter run --dart-define server_url=https://mywonderfulserver.development.com --dart-define api_key=mydevelopmentapikey\n```\n\n이 방법은 환경 변수가 몇 개 없을 때 잘 작동하지만, 변수가 많아질수록 가독성이 떨어질 수 있습니다. 변수의 수가 늘어날수록 관리하기 번거로워지고 변수를 빼먹거나 잘못 입력할 수 있는 실수가 발생할 수 있습니다.\n\n## dart-define-from-file 사용하기\n\n<div class=\"content-ad\"></div>\n\n만약 모든 변수를 파일에 넣고 그 파일을 사용할 수 있다면 어떨까요? --dart-define 방식의 가독성과 관리 용이성 문제를 해결하기 위해 Flutter는 --dart-define-from-file 옵션을 지원합니다.\n\n이를 통해 모든 변수를 파일에 넣고 해당 파일을 flutter run 또는 flutter build 명령에 선언할 수 있습니다.\n\n이전의 예제를 생각해보겠습니다. 개발 환경을 선언하는 server_url 및 api_key 두 변수가 있는 경우를 고려해 봅시다. 이를 직접 명령줄에 정의하는 대신 env/development.json이라는 JSON 파일을 만들 수 있습니다.\n\n```js\n{\n  \"server_url\": \"https://mywonderfulserver.development.com\",\n  \"api_key\": \"mydevelopmentapikey\"\n}\n```\n\n<div class=\"content-ad\"></div>\n\n그리고 파일을 전달해 주세요:\n\n```js\nflutter run --dart-define-from-file env/development.json\n```\n\n이 방법은 훨씬 확장 가능하고 가독성을 크게 향상시킵니다. 파일을 사용함으로써 환경 변수를 중앙 집중화하여 필요에 따라 쉽게 관리하고 업데이트할 수 있습니다.\n\n# 환경 변수 읽기\n\n<div class=\"content-ad\"></div>\n\n환경 변수를 선언하는 방법에 상관없이 코드에서 그 값을 읽는 방법은 일관되게 유지됩니다. 일반적으로 이러한 변수를 읽는 유일한 목적의 정적 상수 필드가 있는 클래스를 사용하여 이러한 변수를 읽는 것이 일반적입니다. 이렇게 하면 응용 프로그램 전체에서 쉽게 접근할 수 있습니다.\n\n다음은 그러한 클래스의 예시입니다:\n\n```js\nclass Environment {\n  const Environment._();\n\n  static const String serverUrl = String.fromEnvironment('server_url');\n  static const String apiKey = String.fromEnvironment('api_key');\n}\n```\n\n이 방법은 환경 변수를 처리하는 깔끔하고 조직적인 방법을 제공합니다. 또한 환경 파일에서 int 또는 bool 값도 동일한 방법으로 읽을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```dart\nstatic const int magicInt = int.fromEnvironment('magic_number');\nstatic const bool magicBool = bool.fromEnvironment('magic_bool');\n```\n\n`fromEnvironment` 팩토리는 키가 선언되지 않았을 때 오버라이드 가능한 기본값으로 설정됩니다.\n\n```dart\n// `defaultValue`가 지정되지 않은 경우, String.fromEnvironment는 \"\"를 기본값으로 사용합니다\nstatic const String stringValue = String.fromEnvironment('string_key', defaultValue: 'Hello');\n// int.fromEnvironment는 기본값으로 0을 사용합니다\nstatic const String intValue = int.fromEnvironment('int_key', defaultValue: 42);\n// bool.fromEnvironment는 기본값으로 false를 사용합니다\nstatic const String boolValue = int.fromEnvironment('bool_key', defaultValue: true);\n```\n\n# 결론\n\n\n<div class=\"content-ad\"></div>\n\n저는 처음부터 Flutter를 사용해왔는데요, 환경 설정 방법을 소개한 이후로 계속 사용해왔습니다. 이 방법 덕분에 많은 시간을 절약할 수 있고 앱을 다양한 환경에서 지원할 수 있어 매우 유연하게 유지할 수 있습니다. Flutter의 기본 환경 변수 처리 기능을 활용함으로써 개발 프로세스를 최적화하고 오류를 줄이며 더 깨끗한 코드를 유지할 수 있습니다.\n\n좋은 하루 보내세요!\n\n# 참고문헌","ogImage":{"url":"/assets/img/2024-06-20-ConfiguringEnvironmentVariablesinFlutter_0.png"},"coverImage":"/assets/img/2024-06-20-ConfiguringEnvironmentVariablesinFlutter_0.png","tag":["Tech"],"readingTime":4},{"title":"Flutter의 Clean Architecture 파트1 - 소개","description":"","date":"2024-06-20 13:46","slug":"2024-06-20-FlutterCleanArchitecturePart1Introduction","content":"\n\n\n![image](/assets/img/2024-06-20-FlutterCleanArchitecturePart1Introduction_0.png)\n\n소프트웨어 개발에서는 체계적이고 유지보수 가능한 코드베이스를 유지하는 것이 매우 중요합니다. 이때 Clean Architecture가 등장하여 코드베이스를 모듈식, 독립적이고 테스트 가능한 방식으로 구성하는 데 도움을 줍니다. 이 글에서는 Clean Architecture가 무엇인지, Flutter에서 어떻게 구현하는지, 그리고 프로젝트에 어떤 이점을 가져다 줄 수 있는지 살펴보겠습니다.\n\n커피를 마시고 준비하세요! 오랜 여정이 시작됩니다.\n\n## Flutter에서 Clean Architecture를 사용해야 하는 이유\n\n\n<div class=\"content-ad\"></div>\n\n클린 아키텍처는 모듈화, 유지보수 가능성, 테스트 가능성을 향상시켜 주는 소프트웨어 설계 철학입니다. 각 층으로 코드를 분리하여 애플리케이션을 구조화하며, 크고 복잡한 앱에 특히 유용합니다.\n\n## 장점\n\n- 모듈성과 독립성: 애플리케이션을 독립적인 부분으로 분할하고 각각을 별도로 관리 및 개발합니다.\n- 쉬운 테스트 가능성: 비즈니스 로직을 독립적으로 테스트하여 오류를 감지하기 쉽습니다.\n- 테스트 주도 개발 (TDD): TDD 원칙과 잘 부합합니다. 먼저 비즈니스 로직에 대한 테스트를 작성한 후 그 테스트를 통과할 코드를 구현할 수 있습니다.\n- 미래 확장성: 새로운 기능을 추가하거나 기존 기능을 수정하는 데 더 적은 노력이 필요합니다.\n- 재사용성: 비즈니스 로직을 다른 프로젝트나 플랫폼에서 재사용할 수 있습니다.\n- 관심사 분리: 비즈니스 로직과 사용자 인터페이스 (UI) 사이의 명확한 경계를 유지함으로써 팀 구성을 더 잘 조직화할 수 있습니다.\n- 유지보수 용이성: 층 간 의존성을 줄여 코드 유지보수를 단순화합니다.\n- 변경에 대한 유연성: 데이터 소스나 서비스를 변경하기 쉽게 합니다.\n- 좋은 문서화: 프로젝트 이해와 유지보수를 위해 구조와 작동원리를 명확히 정의합니다.\n\n클린 아키텍처는 데이터층, 도메인층, 프레젠테이션 층으로 구성되어 있습니다. 각 층은 구별된 책임과 제한된 의존성을 가지고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-20-FlutterCleanArchitecturePart1Introduction_1.png)\n\n코딩을 시작하기 전에 짧게 예제에 대해 설명하겠습니다:\n\nTMDB 플랫폼의 API를 사용하여 기본 영화 애플리케이션을 구축할 예정입니다. 이 응용 프로그램은 API에서 인기 있는 및 최상위 영화 목록을 검색하고 표시할 것입니다. 사용자는 배우 세부 정보를 포함한 영화 정보에 액세스할 수 있습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:600/1*opIWWgVq6ZlP_x5sdV0LDA.gif)\n\n\n<div class=\"content-ad\"></div>\n\n사용할 패키지 목록\n\n```js\ndependencies:\n  # 라우팅을 위해 => https://pub.dev/packages/auto_route\n  auto_route: ^7.8.3\n\n  # 이미지 캐싱을 위해 => https://pub.dev/packages/cached_network_image\n  cached_network_image: ^3.3.0\n\n  # 네트워크 요청을 위해 => https://pub.dev/packages/dio\n  dio: ^5.3.3\n\n  # 동등성을 위해 => https://pub.dev/packages/equatable\n  equatable: ^2.0.5\n\n  # 테마를 위해 => https://pub.dev/packages/flex_color_scheme\n  flex_color_scheme: ^7.3.1\n\n  flutter:\n    sdk: flutter\n\n  # 상태 관리를 위해 => https://pub.dev/packages/flutter_bloc\n  flutter_bloc: ^8.1.3\n\n  # 환경 변수를 위해 => https://pub.dev/packages/flutter_dotenv\n  flutter_dotenv: ^5.1.0\n\n  # 자산 코드 생성을 위해 => https://pub.dev/packages/flutter_gen\n  flutter_gen: ^5.4.0\n\n  # 유용한 훅을 위해 => https://pub.dev/packages/flutter_hooks\n  flutter_hooks: ^0.20.3\n\n  # 책임성을 위해 => https://pub.dev/packages/flutter_screenutil\n  flutter_screenutil: ^5.9.0\n\n  # SVG를 위해 => https://pub.dev/packages/flutter_svg\n  flutter_svg: ^2.0.9\n\n  # 함수형 프로그래밍을 위해 => https://pub.dev/packages/fpdart\n  fpdart: ^1.1.0\n\n  # 의존성 주입을 위해 => https://pub.dev/packages/get_it\n  get_it: ^7.6.4\n\n  # 테마 또는 로캘 관리를 위해 => https://pub.dev/packages/hydrated_bloc\n  hydrated_bloc: ^9.1.2\n\n  intl: ^0.19.0\n\n  # 로컬 데이터 소스를 위해\n  isar: ^3.1.0+1\n  isar_flutter_libs: ^3.1.0+1\n\n  # API 모델 생성을 위해 => https://pub.dev/packages/json_annotation\n  json_annotation: ^4.8.1\n\n  # 앱 데이터 디렉토리\n  path_provider: ^2.1.1\n\n  # 개발자를 위한 dio 인터셉터 => https://pub.dev/packages/pretty_dio_logger\n  pretty_dio_logger: ^1.3.1\n\n  # 반짝거림 효과를 위해 => https://pub.dev/packages/shimmer\n  shimmer: ^3.0.0\n\n  # URL 런처를 위해 => https://pub.dev/packages/url_launcher\n  url_launcher: ^6.2.2\n\ndev_dependencies:\n  # auto_route 생성기 => https://pub.dev/packages/auto_route_generator\n  auto_route_generator: ^7.3.1\n\n  # bloc 테스트를 위해 => https://pub.dev/packages/bloc_test\n  bloc_test: ^9.1.4\n\n  build_runner: ^2.4.6\n  flutter_gen_runner: ^5.4.0\n  flutter_lints: ^3.0.1\n  flutter_test:\n    sdk: flutter\n\n  # 로컬 데이터 소스\n  isar_generator: ^3.1.0+1\n\n  # API 모델 생성을 위해 => https://pub.dev/packages/json_serializable\n  json_serializable: ^6.7.1\n\n  # 테스트를 위해 => https://pub.dev/packages/mockito\n  mockito: ^5.4.4\n```\n\n## HTTP 요청\n\nflutter_dotenv 패키지를 사용하여 간단한 애플리케이션 상수 클래스를 만들어 봅시다.\n\n<div class=\"content-ad\"></div>\n\n```js\nclass AppConstants {\n  final baseUrl = '${dotenv.env['BASE_URL']}'; //* https://api.themoviedb.org/3\n  final apiToken = '${dotenv.env['API_TOKEN']}'; //* your TMDB token. (sign up here https://developer.themoviedb.org/docs)\n}\n```\n\nHTTP 요청을 위한 클래스를 만들어 봅시다. DioClient 클래스는 API 요청을 보내고 json 데이터를 반환할 것입니다. 여기서 주요 목적은 DioClient 클래스를 get, post, put, patch, delete 메서드로 제한하는 것입니다.\n\n저희 애플리케이션에서는 하나의 API만 사용할 것이므로, Dio를 사용하기 때문에 DioClient라고 이름 짓겠습니다. 애플리케이션이 여러 개의 API와 통신해야 하는 경우, HTTP 요청을 보내는 DioClient와 유사한 클래스가 필요합니다. 이것은 각 네트워크 클래스가 관련된 데이터 원본과 관련되어야 하기 때문입니다.\n\n예를 들어, 영화 데이터에 대해 TMDB API를 사용하고 배우에 대해 BlaBla API를 사용하는 경우, 명명 규칙에 유의해야 합니다. 네이밍의 예시로는 TmdbNetworkManager, BlaBlaClient, CatClient 등이 있을 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\nclass DioClient {\n  Dio _dio;\n\n  DioClient() {\n    _dio = Dio();\n    _dio\n      ..options.baseUrl = AppConstants.baseUrl\n      ..options.headers = {\n        HttpHeaders.contentTypeHeader: ContentType.json.mimeType,\n        HttpHeaders.authorizationHeader: 'Bearer ${AppConstants.apiToken}',\n      }\n      ..options.connectTimeout = const Duration(milliseconds: 15000)\n      ..options.receiveTimeout = const Duration(milliseconds: 15000)\n      ..options.responseType = ResponseType.json\n      ..interceptors.add(\n        PrettyDioLogger(\n          compact: false,\n          logPrint: (object) => log(object.toString(), name: 'TMDB API'),\n        ),\n      );\n  }\n\n  /// * GET\n  Future<Response> get(\n    String url, {\n    Map<String, dynamic>? queryParameters,\n    Options? options,\n    CancelToken? cancelToken,\n    ProgressCallback? onReceiveProgress,\n  }) async {\n    try {\n      final response = await _dio.get(\n        url,\n        queryParameters: queryParameters,\n        options: options,\n        cancelToken: cancelToken,\n        onReceiveProgress: onReceiveProgress,\n      );\n      return response;\n    } on DioException {\n      rethrow;\n    }\n  }\n\n  /// * POST\n  Future<Response> post(\n    String uri, {\n    data,\n    Map<String, dynamic>? queryParameters,\n    Options? options,\n    CancelToken? cancelToken,\n    ProgressCallback? onSendProgress,\n    ProgressCallback? onReceiveProgress,\n  }) async {\n    try {\n      final response = await _dio.post(\n        uri,\n        data: data,\n        queryParameters: queryParameters,\n        options: options,\n        cancelToken: cancelToken,\n        onSendProgress: onSendProgress,\n        onReceiveProgress: onReceiveProgress,\n      );\n      return response;\n    } on DioException {\n      rethrow;\n    }\n  }\n\n  /// * PUT\n  Future<Response> put(\n    String uri, {\n    data,\n    Map<String, dynamic>? queryParameters,\n    Options? options,\n    CancelToken? cancelToken,\n    ProgressCallback? onSendProgress,\n    ProgressCallback? onReceiveProgress,\n  }) async {\n    try {\n      final response = await _dio.put(\n        uri,\n        data: data,\n        queryParameters: queryParameters,\n        options: options,\n        cancelToken: cancelToken,\n        onSendProgress: onSendProgress,\n        onReceiveProgress: onReceiveProgress,\n      );\n      return response;\n    } on DioException {\n      rethrow;\n    }\n  }\n\n  /// * PATCH\n  Future<Response> patch(\n    String uri, {\n    data,\n    Map<String, dynamic>? queryParameters,\n    Options? options,\n    CancelToken? cancelToken,\n    ProgressCallback? onSendProgress,\n    ProgressCallback? onReceiveProgress,\n  }) async {\n    try {\n      final response = await _dio.patch(\n        uri,\n        data: data,\n        queryParameters: queryParameters,\n        options: options,\n        cancelToken: cancelToken,\n        onSendProgress: onSendProgress,\n        onReceiveProgress: onReceiveProgress,\n      );\n      return response;\n    } on DioException {\n      rethrow;\n    }\n  }\n\n  /// * DELETE\n  Future<dynamic> delete(\n    String uri, {\n    data,\n    Map<String, dynamic>? queryParameters,\n    Options? options,\n    CancelToken? cancelToken,\n    ProgressCallback? onSendProgress,\n    ProgressCallback? onReceiveProgress,\n  }) async {\n    try {\n      final response = await _dio.delete(\n        uri,\n        data: data,\n        queryParameters: queryParameters,\n        options: options,\n        cancelToken: cancelToken,\n      );\n      return response;\n    } on DioException {\n      rethrow;\n    }\n  }\n}\n```\n\n## 네트워크 오류 모델\n\n네트워크 오류 모델을 만들어봅시다. 이 모델은 나쁜 응답 오류가 발생할 때 생성되므로 API에서 오류 메시지를 표시할 수 있습니다.\n\nTMDB API의 오류 모델은 아래와 같습니다.\n\n<div class=\"content-ad\"></div>\n\n```json\n@JsonSerializable()\nclass NetworkErrorModel extends Equatable {\n  @JsonKey(name: 'status_code')\n  final int? statusCode;\n  @JsonKey(name: 'status_message')\n  final String? statusMessage;\n\n  const NetworkErrorModel({this.statusCode, this.statusMessage});\n\n  factory NetworkErrorModel.fromJson(Map<String, dynamic> json) {\n    return _$NetworkErrorModelFromJson(json);\n  }\n\n  Map<String, dynamic> toJson() => _$NetworkErrorModelToJson(this);\n\n  @override\n  List<Object?> get props => [statusCode, statusMessage];\n}\n```\n\n## 로컬 데이터베이스\n\n데이터베이스에 접근하는 클래스를 만들어 봅시다.\n\n```json\n/// 로컬 데이터베이스를 나타내는 클래스.\n///\n/// 이 클래스는 Isar 데이터베이스를 초기화하고 액세스하는 방법을 제공합니다.\nclass LocalDatabase {\n  late final Isar _isar;\n  bool _isInitialized = false;\n\n  /// 초기화된 Isar 데이터베이스 인스턴스를 반환합니다.\n  ///\n  /// 데이터베이스가 초기화되지 않은 경우 [IsarError]를 throw합니다.\n  Isar get db => _isInitialized ? _isar : throw IsarError('Isar가 초기화되지 않았습니다.');\n\n  /// Isar 데이터베이스를 초기화합니다.\n  ///\n  /// 데이터베이스가 이미 초기화된 경우 [IsarError]를 throw합니다.\n  Future<void> initialize() async {\n    if (_isInitialized) throw IsarError('Isar가 이미 초기화되었습니다.');\n\n    final directory = await getApplicationDocumentsDirectory();\n    _isar = await Isar.open([MovieDetailCollectionSchema], directory: directory.path);\n\n    _isInitialized = true;\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## 에러 처리\n\nDioException을 사용하여 네트워크 오류를 처리하는 클래스를 만들어 보겠습니다.\n\n```js\nclass NetworkException extends Equatable implements Exception {\n  late final String message;\n  late final int? statusCode;\n\n  NetworkException.fromDioError(DioException dioException) {\n    statusCode = dioException.response?.statusCode;\n\n    switch (dioException.type) {\n      case DioExceptionType.cancel:\n        message = 'API 서버로의 요청이 취소되었습니다';\n        break;\n\n      case DioExceptionType.connectionTimeout:\n        message = 'API 서버와의 연결 시간 초과';\n        break;\n\n      case DioExceptionType.receiveTimeout:\n        message = 'API 서버와의 연결 중 수신 시간 초과';\n        break;\n\n      case DioExceptionType.sendTimeout:\n        message = 'API 서버와의 연결 중 송신 시간 초과';\n        break;\n\n      case DioExceptionType.connectionError:\n        if (dioException.error.runtimeType == SocketException) {\n          message = '인터넷 연결을 확인해주세요';\n          break;\n        } else {\n          message = '예기치 않은 오류가 발생했습니다';\n          break;\n        }\n\n      case DioExceptionType.badCertificate:\n        message = '잘못된 인증서';\n        break;\n\n      case DioExceptionType.badResponse:\n        final model = NetworkErrorModel.fromJson(dioException.response?.data as Map<String, dynamic>);\n        message = model.statusMessage ?? '예기치 않은 오류가 발생했습니다';\n        break;\n\n      case DioExceptionType.unknown:\n        message = '예기치 않은 오류가 발생했습니다';\n        break;\n    }\n  }\n\n  @override\n  List<Object?> get props => [message, statusCode];\n}\n```\n\n그리고 IsarError를 사용하여 로컬 데이터베이스 오류를 처리하는 클래스를 만들어 보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nclass DatabaseException extends Equatable implements Exception {\n  late final String message;\n\n  DatabaseException.fromIsarError(IsarError isarError) : message = isarError.message;\n\n  @override\n  List<Object?> get props => [message];\n}\n```\n\n알겠어요! 여기까지입니다. 이 부분에서는 여기까지 언급할 거예요.\n\n이제 Clean Architecture에 대해 준비되었습니다.\n\n다음 파트\n","ogImage":{"url":"/assets/img/2024-06-20-FlutterCleanArchitecturePart1Introduction_0.png"},"coverImage":"/assets/img/2024-06-20-FlutterCleanArchitecturePart1Introduction_0.png","tag":["Tech"],"readingTime":12}],"page":"13","totalPageCount":20,"totalPageGroupCount":1,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}