{"pageProps":{"post":{"title":"Flutter  Firebase로 푸시 알림 구현하는 완벽 가이드","description":"","date":"2024-06-21 21:01","slug":"2024-06-21-FlutterFirebasePushNotificationsCompleteGuide","content":"\n\n<img src=\"/assets/img/2024-06-21-FlutterFirebasePushNotificationsCompleteGuide_0.png\" />\n\n# 푸시 알림이란 무엇인가요?\n\n푸시 알림은 모바일 앱이나 웹사이트에서 기기로 보내는 메시지로, 기기가 활발하게 사용되지 않는 경우에도 전송됩니다. 일반적으로 사용자에게 새로운 콘텐츠나 기능을 알리거나 관심이 있을 수 있는 내용을 상기시키기 위해 사용됩니다.\n\n# 모바일 앱 개발에서 푸시 알림의 장점은 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n- 사용자 참여 향상: 푸시 알림을 통해 사용자가 앱에 계속해서 참여하도록 유도할 수 있습니다. 사용자가 앱을 활발하게 사용하지 않을 때에도 이를 통해 전반적인 앱 사용량과 인기를 증가시킬 수 있습니다.\n- 유지율 증가: 푸시 알림을 통해 사용자에게 앱을 상기시킬 수 있어, 유지율을 높이고 앱을 제거하는 사용자 수를 줄일 수 있습니다.\n- 타겟팅 메시징: 푸시 알림은 사용자의 관심사나 행동을 기반으로 특정 사용자나 그룹을 대상으로 할 수 있습니다. 이를 통해 앱 개발자는 사용자에게 개인화되고 관련성 높은 메시지를 보낼 수 있어 알림의 효과를 높일 수 있습니다.\n- 수익 증대: 푸시 알림을 통해 인앱 구매나 기타 수익화 기회를 홍보할 수 있어, 앱 개발자의 수익을 향상시킬 수 있습니다.\n- 고객 서비스 향상: 푸시 알림을 통해 업데이트나 경고와 같은 시기적절하고 관련성 있는 정보를 제공할 수 있습니다. 이를 통해 전반적인 고객 경험과 앱에 대한 만족도를 향상시킬 수 있습니다.\n\n# Firebase Cloud Messaging (FCM)이란?\n\n![이미지](/assets/img/2024-06-21-FlutterFirebasePushNotificationsCompleteGuide_1.png)\n\nFirebase에 따르면, FCM은 무료로 메시지를 신뢰할 수 있게 전송할 수 있는 크로스 플랫폼 메시징 솔루션이라고 합니다.\n\n<div class=\"content-ad\"></div>\n\nFCM은 Android, iOS 및 웹 사용자에게 메시지와 알림을 보낼 수 있는 크로스 플랫폼 메시징 솔루션입니다. 구글은 FCM을 Firebase 스위트의 일부로 제공하여 모바일 앱 개발을 위한 도구 및 서비스를 제공합니다.\n\nFCM을 사용하면 사용자 관심사, 앱 사용 방식 및 위치에 따라 특정 기기 또는 기기 그룹에 메시지를 보낼 수 있습니다. 알림, 푸시 알림 및 데이터 페이로드를 포함한 다양한 유형의 메시지를 보낼 수 있습니다. FCM은 또한 메시지 예약, 기기 그룹 관리 및 분석과 같은 기능을 제공합니다.\n\nFCM은 기존 앱 인프라와 쉽게 통합되고 사용하기 쉽게 설계되었습니다. 간단한 API를 사용하며 Firebase Analytics와 같은 다른 Firebase 서비스와 통합하여 모바일 앱 개발을 위한 포괄적인 도구 세트를 제공합니다.\n\n# 플러터 앱에서 Firebase FCM을 통해 푸시 알림을 수신하는 방법 — 구현\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-21-FlutterFirebasePushNotificationsCompleteGuide_2.png)\n\n플러터와 FCM에서 3가지 디바이스 상태\n\n- Foreground(전경): 어플리케이션이 열려 있고 보여지며 사용 중일 때입니다.\n- Background(최소화): 사용자가 장치에서 \"홈\" 버튼을 누르거나 앱 전환기를 통해 다른 앱으로 전환하거나 다른 탭(웹)에서 앱을 열었을 때 보통 발생합니다.\n- Terminated(종료됨): 장치가 잠겨 있거나 어플리케이션이 실행되지 않을 때입니다. 사용자는 장치의 앱 전환기 UI를 통해 앱을 닫거나 탭(웹)을 닫아 어플리케이션을 종료할 수 있습니다.\n\n이 프로세스가 어떻게 작동하는지 보려면 이 동영상을 시청해보세요.\n\n\n<div class=\"content-ad\"></div>\n\n구현 단계\n\n- CMD에서\n\n- Node.js를 다운로드 및 설치하십시오. https://nodejs.org/en/\n- firebase 도구 설치: npm install -g firebase-tools (CMD)\n- \"firebase login\"을 실행하고 Google 계정을 선택하십시오 (CMD)\n\n2. 플러터 프로젝트 터미널에서\n\n<div class=\"content-ad\"></div>\n\n- 그런 다음 플러터 프로젝트를 열고 터미널에서 다음 명령을 실행하세요\n- dart pub global activate flutterfire_cli\n- flutterfire configure (만약 이 명령이 \"flutterfire가 인식되지 않습니다.\"와 같은 오류를 발생시킨다면, 시스템 환경 변수에 \"C:\\Users\\*사용자명*\\AppData\\Local\\Pub\\Cache\\bin\"을 새 항목으로 추가해야 합니다. 이제 오류 없이 명령을 실행할 수 있어야 합니다.) \n\n3. Firebase 콘솔에서\n\n- 새 Firebase 프로젝트를 생성하고 Firebase FCM(메시징/클라우드 메시징으로도 알려짐)를 활성화하세요.\n\n4. 그런 다음 플러터 프로젝트의 main.dart에 다음 종속성을 추가하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\n// 의존성\nimport 'package:firebase_core/firebase_core.dart';\nimport '/firebase_options.dart'; // 이 파일은 \"flutterfire config\" 명령어로 생성됩니다.\nimport 'package:firebase_messaging/firebase_messaging.dart';\n```\n\n5. 이제 main.dart에 다음 라인을 추가하여 Firebase Messaging을 초기화합니다.\n\n```js\n// 초기화\nWidgetsFlutterBinding.ensureInitialized();\n\nawait Firebase.initializeApp(\n  options: DefaultFirebaseOptions.currentPlatform,\n);\n\nFirebaseMessaging messaging = FirebaseMessaging.instance;\n\nNotificationSettings settings = await messaging.requestPermission(\n  alert: true,\n  announcement: false,\n  badge: true,\n  carPlay: false,\n  criticalAlert: false,\n  provisional: false,\n  sound: true,\n);\n\nprint('사용자가 허용한 권한: ${settings.authorizationStatus}');\n```\n\n6. 이제 main.dart에 다음 라인을 추가하여 \"백그라운드 메시지\"를 받습니다.\n\n\n<div class=\"content-ad\"></div>\n\n```dart\n// 백그라운드 메시지 수신\nFuture<void> _firebaseMessagingBackgroundHandler(RemoteMessage message) async {\n  await Firebase.initializeApp();\n  print(\"백그라운드 메시지 처리 중: ${message.messageId}\");\n}\n```\n\n```dart\n// 백그라운드 메시지 수신 대기\nWidgetsFlutterBinding.ensureInitialized();\nFirebaseMessaging.onBackgroundMessage(_firebaseMessagingBackgroundHandler);\n```\n\n7. 그런 다음 main.dart에 다음 줄을 추가하여 \"전경 메시지\"를 받습니다.\n\n```dart\n// 전경 메시지 수신\nFirebaseMessaging.onMessage.listen((RemoteMessage message) {\n  print('전경에서 메시지를 받았어요!');\n  print('메시지 데이터: ${message.data}');\n\n  if (message.notification != null) {\n    print('메시지에 알림도 포함되어 있어요: ${message.notification}');\n  }\n});\n```\n\n<div class=\"content-ad\"></div>\n\n# 중요\n\n- (공통):\n- 클라우드 메시징 패키지는 애플리케이션을 Firebase Cloud Messaging (FCM) 서비스에 연결합니다.\n- 메시지 페이로드를 무료로 디바이스로 직접 보낼 수 있습니다.\n- 각 메시지 페이로드는 최대 4KB까지 가능합니다.\n- (iOS 전용):\n- iOS 플랫폼에서 Firebase 메시징을 테스트하려면 실제 디바이스가 필요합니다.\n\n# 받을 수 있는 3가지 메시지 유형\n\n메시지 페이로드를 세 가지 유형 중 하나로 볼 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n- 알림 전용 메시지: 페이로드에는 사용자에게 표시되는 알림 속성이 포함되어 있습니다.\n- 데이터 전용 메시지: \"silent message\"로도 알려진 이 페이로드에는 데이터 속성 내에 사용자가 필요에 따라 사용할 수 있는 사용자 정의 키/값 쌍이 포함되어 있습니다. 이러한 메시지는 \"우선 순위가 낮음\"으로 간주됩니다(나중에 더 자세히 설명합니다).\n- 알림 및 데이터 메시지: 알림 및 데이터 속성을 모두 포함하는 페이로드입니다.\n\n# 상호 작용 처리\n\n알림은 사용자에게 보이는 신호이므로 사용자가 해당 신호에 상호 작용하는 것이 일반적입니다(눌러서). Android 및 iOS 모두의 기본 동작은 애플리케이션을 열도록 하는 것입니다. 애플리케이션이 종료된 경우 시작되고, 백그라운드 상태인 경우 화면으로 가져옵니다.\n\n알림의 내용에 따라 애플리케이션이 열릴 때 사용자 상호 작용을 처리하고 싶을 수 있습니다. 예를 들어, 알림을 통해 새로운 채팅 메시지가 전송되고 사용자가 그것을 누른 경우, 애플리케이션이 열릴 때 특정 대화를 열도록 하고 싶을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nfirebase-messaging 패키지는 이 상호작용을 다루는 두 가지 방법을 제공합니다:\n\n- getInitialMessage(): 애플리케이션이 종료된 상태에서 열리면 RemoteMessage가 포함된 Future가 반환됩니다. RemoteMessage를 사용하면 해당 메시지는 제거됩니다.\n- onMessageOpenedApp: 백그라운드 상태에서 애플리케이션이 열릴 때 RemoteMessage를 게시하는 Stream입니다.\n\n사용자에 대한 원활한 사용자 경험을 위해 두 시나리오를 모두 처리하는 것이 좋습니다. 아래의 코드 예시는 이를 어떻게 달성할 수 있는지 보여줍니다:\n\n```js\nclass Application extends StatefulWidget {\n  @override\n  State<StatefulWidget> createState() => _Application();\n}\n\nclass _Application extends State<Application> {\n  // 모든 메시지에 'type' 키를 포함하는 데이터 필드가 있다고 가정합니다.\n  Future<void> setupInteractedMessage() async {\n    // 애플리케이션이 종료된 상태에서 열린 이유가 된 메시지를 가져옵니다.\n    RemoteMessage? initialMessage =\n        await FirebaseMessaging.instance.getInitialMessage();\n\n    // 메시지가 'type'이 'chat'인 데이터 속성도 포함하고 있다면\n    // 채팅 화면으로 이동합니다.\n    if (initialMessage != null) {\n      _handleMessage(initialMessage);\n    }\n\n    // 애플리케이션이 백그라운드에 있을 때 상호작용을 다루기 위해 \n    // Stream 리스너를 통해 처리합니다.\n    FirebaseMessaging.onMessageOpenedApp.listen(_handleMessage);\n  }\n  \n  void _handleMessage(RemoteMessage message) {\n    if (message.data['type'] == 'chat') {\n      Navigator.pushNamed(context, '/chat', \n        arguments: ChatArguments(message),\n      );\n    }\n  }\n\n  @override\n  void initState() {\n    super.initState();\n\n    // initState()이 비동기일 수 없기 때문에 상호작용하는 메시지를 다루는 \n    // 코드를 비동기 함수에서 실행합니다.\n    setupInteractedMessage();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Text(\"...\");\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n# 특정 화면으로 이동하는 방법\n\n```js\nvoid _handleMessage(RemoteMessage message) {\n    // 메시지 객체 내용 확인\n    RemoteNotification? notification = message.notification;\n    //AndroidNotification? android = message.notification?.android;\n\n    print(\"notification: $notification\");\n    print(\"message data: ${message.data}\");\n\n    Get.toNamed(Routes.getNotificationDetailScreen(), arguments: [\n      {\"message\": message}\n    ]);\n}\n\n// 상호 작용 처리\nFirebaseMessaging.onMessageOpenedApp.listen(_handleMessage);\n```\n\n![이미지 1](/assets/img/2024-06-21-FlutterFirebasePushNotificationsCompleteGuide_3.png)\n\n![이미지 2](/assets/img/2024-06-21-FlutterFirebasePushNotificationsCompleteGuide_4.png)\n\n<div class=\"content-ad\"></div>\n\n## 참고 자료:\n\n- https://www.youtube.com/watch?v=3lsP1jZNqjE\n- https://stackoverflow.com/questions/70320263/the-term-flutterfire-is-not-recognized-as-the-name-of-a-cmdlet-function-scri\n- https://firebase.flutter.dev/docs/cli/\n- https://firebase.google.com/docs/cli#install-cli-windows\n- https://firebase.flutter.dev/docs/overview/\n- https://medium.com/@rysesoft/flutter-push-notification-with-fcm-6e7a95f5abb6\n- https://firebase.flutter.dev/docs/messaging/apple-integration/\n- https://www.youtube.com/watch?v=54vgoPgB8xE\n- https://pub.dev/packages/flutterfire_cli/install\n- https://pub.dev/packages/firebase_core/install\n- https://www.youtube.com/watch?v=2tjuUwNx6qk\n- https://firebase.flutter.dev/docs/messaging/usage/\n- https://medium.com/firebase-developers/flutter-fcm-how-to-navigate-to-a-particular-screen-after-tapping-on-push-notification-8cb5d5111ee6\n- https://pub.dev/packages/flutter_local_notifications\n- https://firebase.flutter.dev/docs/messaging/usage/\n- https://pub.dev/documentation/firebase_messaging_platform_interface/latest/firebase_messaging_platform_interface/RemoteMessage-class.html\n- https://firebase.google.com/docs/cloud-messaging/flutter/receive","ogImage":{"url":"/assets/img/2024-06-21-FlutterFirebasePushNotificationsCompleteGuide_0.png"},"coverImage":"/assets/img/2024-06-21-FlutterFirebasePushNotificationsCompleteGuide_0.png","tag":["Tech"],"readingTime":9},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<h1>푸시 알림이란 무엇인가요?</h1>\n<p>푸시 알림은 모바일 앱이나 웹사이트에서 기기로 보내는 메시지로, 기기가 활발하게 사용되지 않는 경우에도 전송됩니다. 일반적으로 사용자에게 새로운 콘텐츠나 기능을 알리거나 관심이 있을 수 있는 내용을 상기시키기 위해 사용됩니다.</p>\n<h1>모바일 앱 개발에서 푸시 알림의 장점은 무엇인가요?</h1>\n<ul>\n<li>사용자 참여 향상: 푸시 알림을 통해 사용자가 앱에 계속해서 참여하도록 유도할 수 있습니다. 사용자가 앱을 활발하게 사용하지 않을 때에도 이를 통해 전반적인 앱 사용량과 인기를 증가시킬 수 있습니다.</li>\n<li>유지율 증가: 푸시 알림을 통해 사용자에게 앱을 상기시킬 수 있어, 유지율을 높이고 앱을 제거하는 사용자 수를 줄일 수 있습니다.</li>\n<li>타겟팅 메시징: 푸시 알림은 사용자의 관심사나 행동을 기반으로 특정 사용자나 그룹을 대상으로 할 수 있습니다. 이를 통해 앱 개발자는 사용자에게 개인화되고 관련성 높은 메시지를 보낼 수 있어 알림의 효과를 높일 수 있습니다.</li>\n<li>수익 증대: 푸시 알림을 통해 인앱 구매나 기타 수익화 기회를 홍보할 수 있어, 앱 개발자의 수익을 향상시킬 수 있습니다.</li>\n<li>고객 서비스 향상: 푸시 알림을 통해 업데이트나 경고와 같은 시기적절하고 관련성 있는 정보를 제공할 수 있습니다. 이를 통해 전반적인 고객 경험과 앱에 대한 만족도를 향상시킬 수 있습니다.</li>\n</ul>\n<h1>Firebase Cloud Messaging (FCM)이란?</h1>\n<p><img src=\"/assets/img/2024-06-21-FlutterFirebasePushNotificationsCompleteGuide_1.png\" alt=\"이미지\"></p>\n<p>Firebase에 따르면, FCM은 무료로 메시지를 신뢰할 수 있게 전송할 수 있는 크로스 플랫폼 메시징 솔루션이라고 합니다.</p>\n<p>FCM은 Android, iOS 및 웹 사용자에게 메시지와 알림을 보낼 수 있는 크로스 플랫폼 메시징 솔루션입니다. 구글은 FCM을 Firebase 스위트의 일부로 제공하여 모바일 앱 개발을 위한 도구 및 서비스를 제공합니다.</p>\n<p>FCM을 사용하면 사용자 관심사, 앱 사용 방식 및 위치에 따라 특정 기기 또는 기기 그룹에 메시지를 보낼 수 있습니다. 알림, 푸시 알림 및 데이터 페이로드를 포함한 다양한 유형의 메시지를 보낼 수 있습니다. FCM은 또한 메시지 예약, 기기 그룹 관리 및 분석과 같은 기능을 제공합니다.</p>\n<p>FCM은 기존 앱 인프라와 쉽게 통합되고 사용하기 쉽게 설계되었습니다. 간단한 API를 사용하며 Firebase Analytics와 같은 다른 Firebase 서비스와 통합하여 모바일 앱 개발을 위한 포괄적인 도구 세트를 제공합니다.</p>\n<h1>플러터 앱에서 Firebase FCM을 통해 푸시 알림을 수신하는 방법 — 구현</h1>\n<p><img src=\"/assets/img/2024-06-21-FlutterFirebasePushNotificationsCompleteGuide_2.png\" alt=\"이미지\"></p>\n<p>플러터와 FCM에서 3가지 디바이스 상태</p>\n<ul>\n<li>Foreground(전경): 어플리케이션이 열려 있고 보여지며 사용 중일 때입니다.</li>\n<li>Background(최소화): 사용자가 장치에서 \"홈\" 버튼을 누르거나 앱 전환기를 통해 다른 앱으로 전환하거나 다른 탭(웹)에서 앱을 열었을 때 보통 발생합니다.</li>\n<li>Terminated(종료됨): 장치가 잠겨 있거나 어플리케이션이 실행되지 않을 때입니다. 사용자는 장치의 앱 전환기 UI를 통해 앱을 닫거나 탭(웹)을 닫아 어플리케이션을 종료할 수 있습니다.</li>\n</ul>\n<p>이 프로세스가 어떻게 작동하는지 보려면 이 동영상을 시청해보세요.</p>\n<p>구현 단계</p>\n<ul>\n<li>\n<p>CMD에서</p>\n</li>\n<li>\n<p>Node.js를 다운로드 및 설치하십시오. <a href=\"https://nodejs.org/en/\" rel=\"nofollow\" target=\"_blank\">https://nodejs.org/en/</a></p>\n</li>\n<li>\n<p>firebase 도구 설치: npm install -g firebase-tools (CMD)</p>\n</li>\n<li>\n<p>\"firebase login\"을 실행하고 Google 계정을 선택하십시오 (CMD)</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>플러터 프로젝트 터미널에서</li>\n</ol>\n<ul>\n<li>그런 다음 플러터 프로젝트를 열고 터미널에서 다음 명령을 실행하세요</li>\n<li>dart pub global activate flutterfire_cli</li>\n<li>flutterfire configure (만약 이 명령이 \"flutterfire가 인식되지 않습니다.\"와 같은 오류를 발생시킨다면, 시스템 환경 변수에 \"C:\\Users*사용자명*\\AppData\\Local\\Pub\\Cache\\bin\"을 새 항목으로 추가해야 합니다. 이제 오류 없이 명령을 실행할 수 있어야 합니다.)</li>\n</ul>\n<ol start=\"3\">\n<li>Firebase 콘솔에서</li>\n</ol>\n<ul>\n<li>새 Firebase 프로젝트를 생성하고 Firebase FCM(메시징/클라우드 메시징으로도 알려짐)를 활성화하세요.</li>\n</ul>\n<ol start=\"4\">\n<li>그런 다음 플러터 프로젝트의 main.dart에 다음 종속성을 추가하세요.</li>\n</ol>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 의존성</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'package:firebase_core/firebase_core.dart'</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'/firebase_options.dart'</span>; <span class=\"hljs-comment\">// 이 파일은 \"flutterfire config\" 명령어로 생성됩니다.</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'package:firebase_messaging/firebase_messaging.dart'</span>;\n</code></pre>\n<ol start=\"5\">\n<li>이제 main.dart에 다음 라인을 추가하여 Firebase Messaging을 초기화합니다.</li>\n</ol>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 초기화</span>\n<span class=\"hljs-title class_\">WidgetsFlutterBinding</span>.<span class=\"hljs-title function_\">ensureInitialized</span>();\n\n<span class=\"hljs-keyword\">await</span> <span class=\"hljs-title class_\">Firebase</span>.<span class=\"hljs-title function_\">initializeApp</span>(\n  <span class=\"hljs-attr\">options</span>: <span class=\"hljs-title class_\">DefaultFirebaseOptions</span>.<span class=\"hljs-property\">currentPlatform</span>,\n);\n\n<span class=\"hljs-title class_\">FirebaseMessaging</span> messaging = <span class=\"hljs-title class_\">FirebaseMessaging</span>.<span class=\"hljs-property\">instance</span>;\n\n<span class=\"hljs-title class_\">NotificationSettings</span> settings = <span class=\"hljs-keyword\">await</span> messaging.<span class=\"hljs-title function_\">requestPermission</span>(\n  <span class=\"hljs-attr\">alert</span>: <span class=\"hljs-literal\">true</span>,\n  <span class=\"hljs-attr\">announcement</span>: <span class=\"hljs-literal\">false</span>,\n  <span class=\"hljs-attr\">badge</span>: <span class=\"hljs-literal\">true</span>,\n  <span class=\"hljs-attr\">carPlay</span>: <span class=\"hljs-literal\">false</span>,\n  <span class=\"hljs-attr\">criticalAlert</span>: <span class=\"hljs-literal\">false</span>,\n  <span class=\"hljs-attr\">provisional</span>: <span class=\"hljs-literal\">false</span>,\n  <span class=\"hljs-attr\">sound</span>: <span class=\"hljs-literal\">true</span>,\n);\n\n<span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">'사용자가 허용한 권한: ${settings.authorizationStatus}'</span>);\n</code></pre>\n<ol start=\"6\">\n<li>이제 main.dart에 다음 라인을 추가하여 \"백그라운드 메시지\"를 받습니다.</li>\n</ol>\n<pre><code class=\"hljs language-dart\"><span class=\"hljs-comment\">// 백그라운드 메시지 수신</span>\nFuture&#x3C;<span class=\"hljs-keyword\">void</span>> _firebaseMessagingBackgroundHandler(RemoteMessage message) <span class=\"hljs-keyword\">async</span> {\n  <span class=\"hljs-keyword\">await</span> Firebase.initializeApp();\n  <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"백그라운드 메시지 처리 중: <span class=\"hljs-subst\">${message.messageId}</span>\"</span>);\n}\n</code></pre>\n<pre><code class=\"hljs language-dart\"><span class=\"hljs-comment\">// 백그라운드 메시지 수신 대기</span>\nWidgetsFlutterBinding.ensureInitialized();\nFirebaseMessaging.onBackgroundMessage(_firebaseMessagingBackgroundHandler);\n</code></pre>\n<ol start=\"7\">\n<li>그런 다음 main.dart에 다음 줄을 추가하여 \"전경 메시지\"를 받습니다.</li>\n</ol>\n<pre><code class=\"hljs language-dart\"><span class=\"hljs-comment\">// 전경 메시지 수신</span>\nFirebaseMessaging.onMessage.listen((RemoteMessage message) {\n  <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">'전경에서 메시지를 받았어요!'</span>);\n  <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">'메시지 데이터: <span class=\"hljs-subst\">${message.data}</span>'</span>);\n\n  <span class=\"hljs-keyword\">if</span> (message.notification != <span class=\"hljs-keyword\">null</span>) {\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">'메시지에 알림도 포함되어 있어요: <span class=\"hljs-subst\">${message.notification}</span>'</span>);\n  }\n});\n</code></pre>\n<h1>중요</h1>\n<ul>\n<li>(공통):</li>\n<li>클라우드 메시징 패키지는 애플리케이션을 Firebase Cloud Messaging (FCM) 서비스에 연결합니다.</li>\n<li>메시지 페이로드를 무료로 디바이스로 직접 보낼 수 있습니다.</li>\n<li>각 메시지 페이로드는 최대 4KB까지 가능합니다.</li>\n<li>(iOS 전용):</li>\n<li>iOS 플랫폼에서 Firebase 메시징을 테스트하려면 실제 디바이스가 필요합니다.</li>\n</ul>\n<h1>받을 수 있는 3가지 메시지 유형</h1>\n<p>메시지 페이로드를 세 가지 유형 중 하나로 볼 수 있습니다.</p>\n<ul>\n<li>알림 전용 메시지: 페이로드에는 사용자에게 표시되는 알림 속성이 포함되어 있습니다.</li>\n<li>데이터 전용 메시지: \"silent message\"로도 알려진 이 페이로드에는 데이터 속성 내에 사용자가 필요에 따라 사용할 수 있는 사용자 정의 키/값 쌍이 포함되어 있습니다. 이러한 메시지는 \"우선 순위가 낮음\"으로 간주됩니다(나중에 더 자세히 설명합니다).</li>\n<li>알림 및 데이터 메시지: 알림 및 데이터 속성을 모두 포함하는 페이로드입니다.</li>\n</ul>\n<h1>상호 작용 처리</h1>\n<p>알림은 사용자에게 보이는 신호이므로 사용자가 해당 신호에 상호 작용하는 것이 일반적입니다(눌러서). Android 및 iOS 모두의 기본 동작은 애플리케이션을 열도록 하는 것입니다. 애플리케이션이 종료된 경우 시작되고, 백그라운드 상태인 경우 화면으로 가져옵니다.</p>\n<p>알림의 내용에 따라 애플리케이션이 열릴 때 사용자 상호 작용을 처리하고 싶을 수 있습니다. 예를 들어, 알림을 통해 새로운 채팅 메시지가 전송되고 사용자가 그것을 누른 경우, 애플리케이션이 열릴 때 특정 대화를 열도록 하고 싶을 수 있습니다.</p>\n<p>firebase-messaging 패키지는 이 상호작용을 다루는 두 가지 방법을 제공합니다:</p>\n<ul>\n<li>getInitialMessage(): 애플리케이션이 종료된 상태에서 열리면 RemoteMessage가 포함된 Future가 반환됩니다. RemoteMessage를 사용하면 해당 메시지는 제거됩니다.</li>\n<li>onMessageOpenedApp: 백그라운드 상태에서 애플리케이션이 열릴 때 RemoteMessage를 게시하는 Stream입니다.</li>\n</ul>\n<p>사용자에 대한 원활한 사용자 경험을 위해 두 시나리오를 모두 처리하는 것이 좋습니다. 아래의 코드 예시는 이를 어떻게 달성할 수 있는지 보여줍니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Application</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">StatefulWidget</span> {\n  @override\n  <span class=\"hljs-title class_\">State</span>&#x3C;<span class=\"hljs-title class_\">StatefulWidget</span>> <span class=\"hljs-title function_\">createState</span>() => <span class=\"hljs-title function_\">_Application</span>();\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">_Application</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">State</span>&#x3C;<span class=\"hljs-title class_\">Application</span>> {\n  <span class=\"hljs-comment\">// 모든 메시지에 'type' 키를 포함하는 데이터 필드가 있다고 가정합니다.</span>\n  <span class=\"hljs-title class_\">Future</span>&#x3C;<span class=\"hljs-keyword\">void</span>> <span class=\"hljs-title function_\">setupInteractedMessage</span>() <span class=\"hljs-keyword\">async</span> {\n    <span class=\"hljs-comment\">// 애플리케이션이 종료된 상태에서 열린 이유가 된 메시지를 가져옵니다.</span>\n    <span class=\"hljs-title class_\">RemoteMessage</span>? initialMessage =\n        <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title class_\">FirebaseMessaging</span>.<span class=\"hljs-property\">instance</span>.<span class=\"hljs-title function_\">getInitialMessage</span>();\n\n    <span class=\"hljs-comment\">// 메시지가 'type'이 'chat'인 데이터 속성도 포함하고 있다면</span>\n    <span class=\"hljs-comment\">// 채팅 화면으로 이동합니다.</span>\n    <span class=\"hljs-keyword\">if</span> (initialMessage != <span class=\"hljs-literal\">null</span>) {\n      <span class=\"hljs-title function_\">_handleMessage</span>(initialMessage);\n    }\n\n    <span class=\"hljs-comment\">// 애플리케이션이 백그라운드에 있을 때 상호작용을 다루기 위해 </span>\n    <span class=\"hljs-comment\">// Stream 리스너를 통해 처리합니다.</span>\n    <span class=\"hljs-title class_\">FirebaseMessaging</span>.<span class=\"hljs-property\">onMessageOpenedApp</span>.<span class=\"hljs-title function_\">listen</span>(_handleMessage);\n  }\n  \n  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">_handleMessage</span>(<span class=\"hljs-params\">RemoteMessage message</span>) {\n    <span class=\"hljs-keyword\">if</span> (message.<span class=\"hljs-property\">data</span>[<span class=\"hljs-string\">'type'</span>] == <span class=\"hljs-string\">'chat'</span>) {\n      <span class=\"hljs-title class_\">Navigator</span>.<span class=\"hljs-title function_\">pushNamed</span>(context, <span class=\"hljs-string\">'/chat'</span>, \n        <span class=\"hljs-attr\">arguments</span>: <span class=\"hljs-title class_\">ChatArguments</span>(message),\n      );\n    }\n  }\n\n  @override\n  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">initState</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-variable language_\">super</span>.<span class=\"hljs-title function_\">initState</span>();\n\n    <span class=\"hljs-comment\">// initState()이 비동기일 수 없기 때문에 상호작용하는 메시지를 다루는 </span>\n    <span class=\"hljs-comment\">// 코드를 비동기 함수에서 실행합니다.</span>\n    <span class=\"hljs-title function_\">setupInteractedMessage</span>();\n  }\n\n  @override\n  <span class=\"hljs-title class_\">Widget</span> <span class=\"hljs-title function_\">build</span>(<span class=\"hljs-params\">BuildContext context</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Text</span>(<span class=\"hljs-string\">\"...\"</span>);\n  }\n}\n</code></pre>\n<h1>특정 화면으로 이동하는 방법</h1>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">_handleMessage</span>(<span class=\"hljs-params\">RemoteMessage message</span>) {\n    <span class=\"hljs-comment\">// 메시지 객체 내용 확인</span>\n    <span class=\"hljs-title class_\">RemoteNotification</span>? notification = message.<span class=\"hljs-property\">notification</span>;\n    <span class=\"hljs-comment\">//AndroidNotification? android = message.notification?.android;</span>\n\n    <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"notification: $notification\"</span>);\n    <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"message data: ${message.data}\"</span>);\n\n    <span class=\"hljs-title class_\">Get</span>.<span class=\"hljs-title function_\">toNamed</span>(<span class=\"hljs-title class_\">Routes</span>.<span class=\"hljs-title function_\">getNotificationDetailScreen</span>(), <span class=\"hljs-attr\">arguments</span>: [\n      {<span class=\"hljs-string\">\"message\"</span>: message}\n    ]);\n}\n\n<span class=\"hljs-comment\">// 상호 작용 처리</span>\n<span class=\"hljs-title class_\">FirebaseMessaging</span>.<span class=\"hljs-property\">onMessageOpenedApp</span>.<span class=\"hljs-title function_\">listen</span>(_handleMessage);\n</code></pre>\n<p><img src=\"/assets/img/2024-06-21-FlutterFirebasePushNotificationsCompleteGuide_3.png\" alt=\"이미지 1\"></p>\n<p><img src=\"/assets/img/2024-06-21-FlutterFirebasePushNotificationsCompleteGuide_4.png\" alt=\"이미지 2\"></p>\n<h2>참고 자료:</h2>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=3lsP1jZNqjE\" rel=\"nofollow\" target=\"_blank\">https://www.youtube.com/watch?v=3lsP1jZNqjE</a></li>\n<li><a href=\"https://stackoverflow.com/questions/70320263/the-term-flutterfire-is-not-recognized-as-the-name-of-a-cmdlet-function-scri\" rel=\"nofollow\" target=\"_blank\">https://stackoverflow.com/questions/70320263/the-term-flutterfire-is-not-recognized-as-the-name-of-a-cmdlet-function-scri</a></li>\n<li><a href=\"https://firebase.flutter.dev/docs/cli/\" rel=\"nofollow\" target=\"_blank\">https://firebase.flutter.dev/docs/cli/</a></li>\n<li><a href=\"https://firebase.google.com/docs/cli#install-cli-windows\" rel=\"nofollow\" target=\"_blank\">https://firebase.google.com/docs/cli#install-cli-windows</a></li>\n<li><a href=\"https://firebase.flutter.dev/docs/overview/\" rel=\"nofollow\" target=\"_blank\">https://firebase.flutter.dev/docs/overview/</a></li>\n<li><a href=\"https://medium.com/@rysesoft/flutter-push-notification-with-fcm-6e7a95f5abb6\" rel=\"nofollow\" target=\"_blank\">https://medium.com/@rysesoft/flutter-push-notification-with-fcm-6e7a95f5abb6</a></li>\n<li><a href=\"https://firebase.flutter.dev/docs/messaging/apple-integration/\" rel=\"nofollow\" target=\"_blank\">https://firebase.flutter.dev/docs/messaging/apple-integration/</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=54vgoPgB8xE\" rel=\"nofollow\" target=\"_blank\">https://www.youtube.com/watch?v=54vgoPgB8xE</a></li>\n<li><a href=\"https://pub.dev/packages/flutterfire_cli/install\" rel=\"nofollow\" target=\"_blank\">https://pub.dev/packages/flutterfire_cli/install</a></li>\n<li><a href=\"https://pub.dev/packages/firebase_core/install\" rel=\"nofollow\" target=\"_blank\">https://pub.dev/packages/firebase_core/install</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=2tjuUwNx6qk\" rel=\"nofollow\" target=\"_blank\">https://www.youtube.com/watch?v=2tjuUwNx6qk</a></li>\n<li><a href=\"https://firebase.flutter.dev/docs/messaging/usage/\" rel=\"nofollow\" target=\"_blank\">https://firebase.flutter.dev/docs/messaging/usage/</a></li>\n<li><a href=\"https://medium.com/firebase-developers/flutter-fcm-how-to-navigate-to-a-particular-screen-after-tapping-on-push-notification-8cb5d5111ee6\" rel=\"nofollow\" target=\"_blank\">https://medium.com/firebase-developers/flutter-fcm-how-to-navigate-to-a-particular-screen-after-tapping-on-push-notification-8cb5d5111ee6</a></li>\n<li><a href=\"https://pub.dev/packages/flutter_local_notifications\" rel=\"nofollow\" target=\"_blank\">https://pub.dev/packages/flutter_local_notifications</a></li>\n<li><a href=\"https://firebase.flutter.dev/docs/messaging/usage/\" rel=\"nofollow\" target=\"_blank\">https://firebase.flutter.dev/docs/messaging/usage/</a></li>\n<li><a href=\"https://pub.dev/documentation/firebase_messaging_platform_interface/latest/firebase_messaging_platform_interface/RemoteMessage-class.html\" rel=\"nofollow\" target=\"_blank\">https://pub.dev/documentation/firebase_messaging_platform_interface/latest/firebase_messaging_platform_interface/RemoteMessage-class.html</a></li>\n<li><a href=\"https://firebase.google.com/docs/cloud-messaging/flutter/receive\" rel=\"nofollow\" target=\"_blank\">https://firebase.google.com/docs/cloud-messaging/flutter/receive</a></li>\n</ul>\n</body>\n</html>\n"},"__N_SSG":true}