{"pageProps":{"post":{"title":"Flutter 애니메이션 종합 가이드","description":"","date":"2024-06-21 22:15","slug":"2024-06-21-FlutterAnimationsComprehensiveGuide","content":"\n\n이 기사에서는 플러터 애니메이션에 대해 자세히 설명하고 여러 예제와 함께 다루어보겠습니다. 이 기사를 끝까지 읽으면 다양한 복잡성을 갖는 애니메이션을 플러터 앱에 추가할 수 있을 것입니다. 또한 플러터에서 제공하는 다양한 접근 방법 중에서 여러분의 애니메이션 목표에 가장 적합한 것을 알게 될 것입니다. 그럼 바로 시작해 봅시다!\n\n![Flutter Animations](/assets/img/2024-06-21-FlutterAnimationsComprehensiveGuide_0.png)\n\n## 목차:\n\n- 소개\n- 암시적 애니메이션 - AnimatedFoo 위젯\n- 암시적 애니메이션 - TweenAnimationBuilder 위젯\n- 명시적 애니메이션 - FooTransition 위젯\n- AnimationController\n- 명시적 애니메이션 - AnimatedBuilder 위젯\n- 명시적 애니메이션 - AnimatedWidget 클래스\n- 올바른 애니메이션 접근 방법 선택하기\n- 서드파티 패키지를 사용한 애니메이션\n\n<div class=\"content-ad\"></div>\n\n## TL;DR\n\n이 튜토리얼에서 모든 애니메이션의 코드를 DartPad에서 볼 수 있어요. 코드를 손대면서 실험해보세요.\n\n최근에는 이 튜토리얼을 요약한 트위터 스레드도 올렸어요. 한 번 확인해보세요.\n\n# 소개\n\n<div class=\"content-ad\"></div>\n\n플러터 앱에서 애니메이션은 기본적으로 두 가지 유형으로 볼 수 있어요: 그리기 기반 애니메이션과 코드 기반 애니메이션이에요. 그리기 기반 애니메이션은 애니메이션된 그래픽, 벡터, 캐릭터 또는 \"그려진\" 모든 것을 말해요. 한편, 코드 기반 애니메이션은 위젯 레이아웃 및 스타일(리스트, 색상, 텍스트 등)에 중점을 두었어요. 이 글의 끝에는 그리기 기반 애니메이션에 대해 간략히 다뤄볼 거에요. 그러나 그들은 보통 3rd party 프레임워크/패키지를 사용하여 달성되므로, 우리는 코드 기반 애니메이션에보다 초점을 맞출 거예요. 코드 기반 애니메이션은 제한적이라는 의미가 아니라, 그 반대로 플러터 애니메이션을 통해 완전히 멋진, 창의적이고 매우 복잡한 애니메이션을 만들 수 있어요. 3rd party 패키지가 필요하지 않아요!\n\n플러터의 코드 기반 애니메이션에는 암시적 애니메이션 및 명시적 애니메이션이 두 가지 유형이 있어요. 이러한 유형 각각에서 준비된 위젯을 사용하거나 직접 위젯을 만들 수 있어요. 각 유형에 대해 몇 가지 예제와 함께 더 자세히 알아보겠어요.\n\n# 1. 암시적 애니메이션\n\n맨 위로 이동하기 👆🏼\n\n<div class=\"content-ad\"></div>\n\n가장 간단하고 사용하기 쉬운 애니메이션입니다. 값만 변경하면 애니메이션이 트리거되고, Flutter가 모든 것을 자동으로 처리해줍니다.\n\n## 1.1 준비된 위젯으로 암묵적 애니메이션\n\n이들은 AnimatedFoo 위젯이라고 불립니다. 여기서 Foo는 애니메이션 속성을 나타냅니다. 대부분은 이미 알고 사용하는 위젯의 애니메이션 버전입니다. 예를 들어 Container/AnimatedContainer, Padding/AnimatedPadding, Positioned/AnimatedPositioned 등이 있습니다.\n\n예를 들어, 다음 애니메이션을 확인해보세요:\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"https://miro.medium.com/v2/resize:fit:930/1*cjoraoQHodaUhNx7z2n1aA.gif\" />\n\n이 애니메이션은 AnimatedContainer, AnimatedPositioned 및 AnimatedDefaultTextStyle 위젯만을 사용하여 구현되었습니다. 지속 시간 값을 지정하고 변경 가능한 변수를 제공하면 끝입니다!\n\n```js\nAnimatedPositioned(\n  top: selectedItemIndex * itemHeight,\n  left: 0,\n  right: 0,\n  duration: const Duration(milliseconds: 200),\n  curve: Curves.easeInOut,\n  child: //...\n),\n//...\nAnimatedContainer(\n  duration: const Duration(milliseconds: 200),\n  curve: Curves.easeInOut,\n  decoration: BoxDecoration(\n    color: selectedItemIndex == i ? yellow : pink,\n    border: Border.all(\n      color: selectedItemIndex == i\n          ? Colors.white\n          : Colors.transparent,\n      width: 2,\n    ),\n  ),\n  child: AnimatedDefaultTextStyle(\n    duration: const Duration(milliseconds: 200),\n    style: TextStyle(\n      color: selectedItemIndex == i\n          ? Colors.black\n          : Colors.white,\n    ),\n    child: const Text('Featured!'),\n  ),\n),\n```\n\n그리고 간단히 각 목록 항목은 아래와 같은 onTap 메서드가 있는 InkWell 위젯으로 래핑되어 있습니다:\n\n\n<div class=\"content-ad\"></div>\n\n```js\nonTap: () => setState(() => selectedItemIndex = i),\n```\n\n이렇게 하면 애니메이션을 트리거할 수 있어요!\n\n여기 사용 가능한 AnimatedFoo 위젯 전체 목록이 있어요.\n\n따라서 우리는 AnimatedFoo 위젯을 투명도, 패딩, 정렬, 위치와 같은 속성용으로 가지고 있어요. 하지만 다른 속성을 애니메이션화하고 싶을 때 어떡하나요? 그럼 여전히 쉽고 빠르게 사용하고 싶어요.\n\n<div class=\"content-ad\"></div>\n\n## 1.2. TweenAnimationBuilder를 사용한 암시적 애니메이션\n\n화면 맨 위로 이동 👆🏼\n\nTweenAnimationBuilder를 사용하면 Tween 클래스를 사용하여 모든 위젯의 속성을 암시적으로 애니메이트할 수 있습니다. Tween 클래스의 이름은 \"Between\"에서 따왔습니다. 기본적으로 애니메이트해야 할 시작 및 끝 값을 제공합니다. 그리고 TweenAnimationBuilder 위젯의 빌더는 애니메이션 값으로 제공되며 이 값을 해당 빌더에서 반환하는 위젯의 어떤 속성에 적용할 수 있습니다.\n\n다음은 예시 애니메이션입니다:\n\n<div class=\"content-ad\"></div>\n\n아래는 해당 코드입니다:\n\n```js\nTweenAnimationBuilder(\n  duration: const Duration(milliseconds: 200),\n  tween: Tween<double>(begin: 0.01, end: _sliderValue),\n  child: Container(\n    decoration: BoxDecoration(\n      //...\n    ),\n    child: Slider(\n      value: _sliderValue,\n      min: 0.01,\n      onChanged: (value) {\n        setState(() => _sliderValue = value);\n      },\n    ),\n  ),\n  builder: (BuildContext context, double? value, Widget? child) {\n    return ClipRect(\n      child: BackdropFilter(\n        filter: ImageFilter.blur(\n          sigmaX: 40 * (value ?? 0.01),\n          sigmaY: 40 * (value ?? 0.01),\n        ),\n        child: child,\n      ),\n    );\n  },\n);\n```\n\n_sliderValue 변수는 0.01에서 1로 변경됩니다. 따라서 각 값의 변경마다 애니메이션이 트리거되며 BackdropFilter 위젯의 sigmaX 및 sigmaY 속성을 위한 새 값으로 다시 빌더 함수가 재구성됩니다. (0 값을 주면 BackdropFilter 위젯이 웹에서 오류를 발생시키기 때문에 0.01을 사용했습니다.)\n\n<div class=\"content-ad\"></div>\n\nTweenAnimationBuilder의 child 매개변수를 사용하여 더 나은 성능을 위해 빌더를 활용하고 있어요. 이 child는 애니메이션이 트리거될 때마다 다시 빌드하는 대신 한 번만 다시 빌드되어요.\n\n좋아요, 쉬운 내용은 끝났습니다. 이제 본격적인 내용을 시작해볼까요?\n\n# 2. 명시적 애니메이션\n\n맨 위로 돌아가기 👆🏼\n\n<div class=\"content-ad\"></div>\n\n암시적 애니메이션에서 AnimatedFoo 또는 TweenAnimationBuilder 위젯 내부의 값만 변경하면 애니메이션이 트리거되었던 것을 기억하시나요? 그러나 명시적 애니메이션은 \"명시적으로\" 애니메이트할 때까지 애니메이션을 트리거하지 않습니다. 애니메이션을 시작하고 어떻게 애니메이트할지 및 AnimationController를 사용하여 애니메이션을 \"제어\"하는 방법을 알려주어야 합니다.\n\n명시적 애니메이션 역시 암시적 애니메이션과 유사하게 사용하기 쉬운 위젯과 사용자 정의 수준이 추가된 위젯이 준비되어 있어 자유롭게 사용할 수 있습니다!\n\n그런데, AnimationController가 무엇인지 궁금하시죠? 이를 사용하는 명시적 애니메이션 위젯에 대해 알아보기 전에 먼저 AnimationController에 대해 학습해 보겠습니다.\n\n## AnimationController\n\n<div class=\"content-ad\"></div>\n\n위로 이동 👆🏼\n\n```js\nAnimationController({\n  double? value,\n  this.duration,\n  this.reverseDuration,\n  this.debugLabel,\n  this.lowerBound = 0.0,\n  this.upperBound = 1.0,\n  this.animationBehavior = AnimationBehavior.normal,\n  required TickerProvider vsync,\n})\n```\n\n이전에 언급했듯이 AnimationController를 사용하면 애니메이션을 \"제어\"할 수 있습니다. 그를 위해서는 vsync 값이 TickerProvider 유형이 필요합니다. Ticker는 기본적으로 Flutter의 프레임 렌더링을 추적하고 컨트롤러가 해당 티커를 따라가서 지정된 기간 내에 '애니메이션'할 수 있도록 허용하며, 기본적으로 0과 1인 lowerBound 및 upperBound 값 사이에서 선형으로 값들을 생성합니다.\n\n결과적으로, AnimationController를 사용하면 다음을 할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n- forward()을 호출하여 애니메이션을 앞으로 재생합니다.\n- reverse()를 호출하여 애니메이션을 역방향으로 재생합니다.\n- stop()을 호출하여 애니메이션을 멈춥니다.\n- repeat()을 호출하여 애니메이션을 가시 상태인 한 계속 반복합니다.\n- reset()을 호출하여 애니메이션을 lowerBound로 재설정합니다.\n- 값을 설정합니다.\n- isAnimating, isCompleted, isDismissed 등과 같이 애니메이션의 상태를 알아내기 위해 다양한 get 함수에 액세스합니다.\n\n자, 이 멋진 놈을 사용하여 실제 작업을 확인해 보겠습니다 🎬\n\n## 2.1. 준비된 위젯을 사용한 명시적 애니메이션\n\n맨 위로 이동 👆🏼\n\n<div class=\"content-ad\"></div>\n\n그들은 FooTransition 위젯이라고 불립니다. 이 때 Foo는 위젯의 애니메이션 속성입니다. 일부는 당신이 사용하는 일반 위젯의 애니메이션 가능한 위젯들입니다. 예를 들어, AlignTransition, PositionedTransition가 있습니다.\n\n이 애니메이션을 확인해보세요:\n\n![animation](https://miro.medium.com/v2/resize:fit:1400/1*GYCKdoQEUQeblnBoyoEHjQ.gif)\n\n이것은 AlignTransition 및 RotationTransition 위젯을 사용하여 달성되었습니다.\n\n<div class=\"content-ad\"></div>\n\n코드 분석:\n\n- 10번 줄 및 17번 줄: AnimationController를 초기화하고 정의합니다.\n- AnimationController의 vsync 값 (19번 줄)은 SingleTickerProviderStateMixin(9번 줄)에서 가져온 값입니다. 이 mixin은 우리에게 이야기한 TickerProvider를 제공합니다. 또한 위젯이 보이는 상태일 때만 애니메이션이 실행되도록 보장합니다.\n- 11번 줄 및 22번 줄: AlignTransition 위젯의 Animation을 초기화하고 정의합니다 (51번 줄). AlignmentGeometry 유형의 Tween을 사용하여 애니메이션을 정의합니다. 결국, 애니메이션은 Alignment.centerLeft에서 Alignment.centerRight로 애니메이션될 것임을 알려주고 Tween의 animate 메서드를 호출하여 이 애니메이션을 AnimationController와 연결한 후 AlignmentGeometry 유형의 Animation을 반환합니다. 이렇게 하면 AnimationController의 하한 및 상한이 아니라 Tween의 시작 및 종료 값 사이에서 애니메이션이 작동합니다.\n\n- 12번 줄 및 32번 줄: RotationTransition 위젯의 회전 속성(turns)의 애니메이션을 초기화하고 정의합니다 (53번 줄). 따라서 0부터 2까지의 시작 및 종료 값이 있으므로, 애니메이션이 끝나면 위젯은 두 번 회전할 것입니다.\n- 20번 줄: AnimationController에 반복을 호출하여 애니메이션이 계속되도록 만듭니다. 그리고 reverse를 true로 설정하면 애니메이션이 순방향으로 시작하여 반대로, 다시 순방향으로, ... 이렇게 반복됩니다.\n- 42번 줄: 위젯의 상태가 dispose되는 시점에 AnimationController를 폐기(dispose)합니다. 메모리 누수를 방지하기 위해 AnimationController를 dispose하는 것은 항상 중요합니다!\n\n하지만 걱정하지 마세요. 조금의 연습으로 매우 쉬워지고 익숙해질 것입니다!\n\n<div class=\"content-ad\"></div>\n\n가능한 모든 FooTransition 위젯 목록입니다:\n\n암시적 애니메이션에서 AnimatedFoo 위젯이 애니메이션 목적에 충분하지 않을 때 어떻게 했는지 기억하나요? AnimatedFoo 위젯으로 처리되지 않은 속성을 애니메이션화하기 위해 TweenAnimationBuilder를 사용했습니다. 비슷하게, 명시적 애니메이션에서는 AnimatedBuilder 위젯을 사용하여 어떤 위젯 속성을 애니메이션화할 수 있습니다. 또는 더 나아가서 직접 FooTransition을 만들기 위해 AnimatedWidget 클래스를 사용할 수도 있습니다!\n\n## 2.2 AnimatedBuilder 위젯을 사용한 명시적 애니메이션\n\n맨 위로 이동 👆🏼\n\n<div class=\"content-ad\"></div>\n\n다음 애니메이션을 확인해보세요:\n\n![Animation](https://miro.medium.com/v2/resize:fit:1400/1*whGvEQM5o0b4W0hZIkgu_A.gif)\n\nGradientTransition 위젯이 없죠? 그럼 어떻게 만들었을까요? AnimatedBuilder 위젯을 이용했어요! 여기에 코드가 있어요:\n\n우리는 AnimationController를 초기화하고 정의했고 이를 AnimatedBuilder 위젯의 애니메이션 값으로 사용했어요. 이제 AnimatedBuilder는 컨트롤러의 값이 변경될 때마다 \"다시 빌드(build)\"되고 빌더를 호출하여 업데이트된 _controller.value 값을 가진 새 위젯을 반환해요. 이로써 그라데이션이 애니메이션 되게 만들었어요.\n\n<div class=\"content-ad\"></div>\n\n물론, AnimationController의 lowerBound 및 upperBound 값 이외의 것을 원한다면, 자체 Animation을 만들고 AnimationController에 연결한 다음 AnimatedBuilder 위젯에 전달할 수 있습니다.\n\n```dart\n_animation = Tween<double>(begin: 0, end: 0.5).animate(_controller);\n//...\nAnimatedBuilder(\n  animation: _animation,\n  builder: (context, child) {\n     //... 값 사용하기: _animation.value\n  }\n)\n```\n\n또한 AnimatedBuilder 위젯의 child 매개변수를 사용하여 성능을 향상시킬 수 있습니다. 이렇게 하면 매번 애니메이션 값이 변경될 때마다 다시 구축되지 않습니다.\n\n아직 따라오고 있나요? 조금만 더 힘내세요! 거의 끝났습니다!\n\n<div class=\"content-ad\"></div>\n\n이제 한 걸음 더 나아가서 AnimatedWidget 클래스를 사용하여 우리만의 FooTransition 위젯을 만들어보겠습니다!\n\n## 2.3 AnimatedWidget 클래스를 사용한 명시적 애니메이션\n\n맨 위로 이동 👆🏼\n\n아주 비밀스러운 비밀을 하나 알려줄게요. 어떤 FooTransition 위젯의 소스 코드로 가 보세요, 무엇을 보게 될까요?\n\n<div class=\"content-ad\"></div>\n\n\n![Image 1](/assets/img/2024-06-21-FlutterAnimationsComprehensiveGuide_1.png)\n\n😱 It extends an AnimatedWidget class, and from what we see, the Animation type parameter (in this case turns) is passed as a listenable to the super class:\n\n![Image 2](/assets/img/2024-06-21-FlutterAnimationsComprehensiveGuide_2.png)\n\nAnd the AnimatedWidget is basically a StatefulWidget! So we can do the exact same!\n\n\n<div class=\"content-ad\"></div>\n\n우리만의 GradientTransition 위젯을 만들어봅시다:\n\n```js\nclass GradientTransition extends AnimatedWidget {\n  final Animation<double> stop;\n\n  const GradientTransition({\n    Key? key,\n    required this.stop,\n  }) : super(key: key, listenable: stop);\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      height: 100,\n      decoration: BoxDecoration(\n        gradient: LinearGradient(\n          colors: const [purple, pink, yellow],\n          stops: [0, stop.value, 1],\n        ),\n      ),\n    );\n  }\n}\n```\n\n그리고 사용하기 위해서는 AnimationController를 그대로 전달하면 됩니다:\n\n```js\nGradientTransition(stop: _controller),\n```  \n\n<div class=\"content-ad\"></div>\n\n그게 다야!\n\n여기까지 버텨내 왔다면, 매우 간단한 것부터 매우 복잡한 것까지 다양한 플러터 애니메이션을 만들기에 충분한 지식을 가지고 있습니다. 필요한 건 조금의 연습뿐이며, 하늘이 한계입니다!\n\n# 적절한 애니메이션 접근 방식 선택\n\n맨 위로 이동 👆🏼\n\n<div class=\"content-ad\"></div>\n\n하지만 잠시만 기다려봐요. 위에서 다룬 여러 방법 중에서 어떤 애니메이션을 선택해야 하는지 어떻게 알 수 있을까요? 플러터(Flutter) 팀의 멋진 분들이 도와주기 위해 비디오와 의사결정 트리를 만들었어요. 제가 최대한 요약해 드릴게요.\n\n## 1. 그림 기반 vs. 코드 기반\n\n첫 번째 선택은 그림 기반 및 코드 기반 애니메이션 사이에서 이루어질 거예요. 이를 위해 자신에게 물어보세요. 만약 당신의 애니메이션이 그림처럼 더 비스무런가요(그림 기반 사용, 3rd party 패키지 사용, 곧 설명할 거예요) 아니면 레이아웃, 위젯, 위젯 스타일, 색상, 테두리, 텍스트 등과 관련이 있는가요(코드 기반 사용, 위에서 설명한 것)?\n\n## 2. 암시적(Implicit) vs. 명시적(Explicit)\n\n<div class=\"content-ad\"></div>\n\n다음 선택은 암시적 및 명시적 애니메이션 중 하나가 될 것입니다. 선택을 하는 데 고려해야 할 여러 기준이 있습니다:\n\n- 무한히 반복되는 애니메이션\n- 연속되지 않는 애니메이션: 애니메이션이 시작 지점으로 돌아가지 않음\n- 여러 위젯이 함께 애니메이션화되는 경우\n\n만약 애니메이션이 위의 기준 중 하나라도 가지고 있다면, 명시적 애니메이션을 사용해야 합니다.\n\n## 3. 내장 위젯 대 사용자 정의 위젯\n\n<div class=\"content-ad\"></div>\n\n마지막 선택 사항은 내장 위젯(AnimatedFoo 및 FooTransition 위젯)과 사용자 지정 위젯(TweenAnimationBuilder 및 AnimatedBuilder/AnimatedWidget) 사이에서 합니다. 이것은 이 목록을 보고 원하는 속성을 애니메이션화하기 위해 이미 내장된 위젯이 있는지 여부를 고려하는 것만큼 간단합니다. 해당 내장 위젯을 사용하거나 (그렇지 않으면 직접 생성)\n\n# 3rd Party 패키지를 사용한 애니메이션\n\n하지만 앱에서 그림을 기반으로 한 애니메이션을 사용하고 싶다면 어떨까요? 여기서는 코딩이 절약되었네요 🫢, 또한 플러터는 여기에서도 놀라울 정도로 좋습니다! Rive 및 Lottie와 같은 훌륭한 패키지들이 있어서 3rd party 애니메이션을 원활하게 통합하고 앱에 추가할 수 있습니다. 제공되는 애니메이션을 그래픽 디자이너/모션 그래픽 디자이너와 함께 사용하거나 커뮤니티에서 만든 애니메이션을 다운로드/구매하여 빠르고 쉽게 앱에 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n3rd party 패키지를 사용하여 Flutter에서 애니메이션을 만드는 데 관한 전용 기사를 작성할 예정이에요. 지금 당장 유용한 링크 몇 개를 공유해 드릴게요:\n\n- 사용 준비가 된 멋진 애니메이션을 볼 수 있는 Rive 커뮤니티 쇼케이스\n- Rive Flutter 패키지\n- 무료 LottieFiles 애니메이션\n- LottieFiles Flutter 패키지\n\n여기까지가 제 글이에요! 이 기사를 읽어 주셔서 감사합니다. 이것이 Flutter 앱에 애니메이션을 추가하고 싶을 때 여러분의 정보원이 되었으면 좋겠어요. 그럼 여러분도 애니메이션을 넣을 때 즐겁게 시도해 보세요!\n\nhttps://twitter.com/FlutterComm","ogImage":{"url":"/assets/img/2024-06-21-FlutterAnimationsComprehensiveGuide_0.png"},"coverImage":"/assets/img/2024-06-21-FlutterAnimationsComprehensiveGuide_0.png","tag":["Tech"],"readingTime":12},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>이 기사에서는 플러터 애니메이션에 대해 자세히 설명하고 여러 예제와 함께 다루어보겠습니다. 이 기사를 끝까지 읽으면 다양한 복잡성을 갖는 애니메이션을 플러터 앱에 추가할 수 있을 것입니다. 또한 플러터에서 제공하는 다양한 접근 방법 중에서 여러분의 애니메이션 목표에 가장 적합한 것을 알게 될 것입니다. 그럼 바로 시작해 봅시다!</p>\n<p><img src=\"/assets/img/2024-06-21-FlutterAnimationsComprehensiveGuide_0.png\" alt=\"Flutter Animations\"></p>\n<h2>목차:</h2>\n<ul>\n<li>소개</li>\n<li>암시적 애니메이션 - AnimatedFoo 위젯</li>\n<li>암시적 애니메이션 - TweenAnimationBuilder 위젯</li>\n<li>명시적 애니메이션 - FooTransition 위젯</li>\n<li>AnimationController</li>\n<li>명시적 애니메이션 - AnimatedBuilder 위젯</li>\n<li>명시적 애니메이션 - AnimatedWidget 클래스</li>\n<li>올바른 애니메이션 접근 방법 선택하기</li>\n<li>서드파티 패키지를 사용한 애니메이션</li>\n</ul>\n<h2>TL;DR</h2>\n<p>이 튜토리얼에서 모든 애니메이션의 코드를 DartPad에서 볼 수 있어요. 코드를 손대면서 실험해보세요.</p>\n<p>최근에는 이 튜토리얼을 요약한 트위터 스레드도 올렸어요. 한 번 확인해보세요.</p>\n<h1>소개</h1>\n<p>플러터 앱에서 애니메이션은 기본적으로 두 가지 유형으로 볼 수 있어요: 그리기 기반 애니메이션과 코드 기반 애니메이션이에요. 그리기 기반 애니메이션은 애니메이션된 그래픽, 벡터, 캐릭터 또는 \"그려진\" 모든 것을 말해요. 한편, 코드 기반 애니메이션은 위젯 레이아웃 및 스타일(리스트, 색상, 텍스트 등)에 중점을 두었어요. 이 글의 끝에는 그리기 기반 애니메이션에 대해 간략히 다뤄볼 거에요. 그러나 그들은 보통 3rd party 프레임워크/패키지를 사용하여 달성되므로, 우리는 코드 기반 애니메이션에보다 초점을 맞출 거예요. 코드 기반 애니메이션은 제한적이라는 의미가 아니라, 그 반대로 플러터 애니메이션을 통해 완전히 멋진, 창의적이고 매우 복잡한 애니메이션을 만들 수 있어요. 3rd party 패키지가 필요하지 않아요!</p>\n<p>플러터의 코드 기반 애니메이션에는 암시적 애니메이션 및 명시적 애니메이션이 두 가지 유형이 있어요. 이러한 유형 각각에서 준비된 위젯을 사용하거나 직접 위젯을 만들 수 있어요. 각 유형에 대해 몇 가지 예제와 함께 더 자세히 알아보겠어요.</p>\n<h1>1. 암시적 애니메이션</h1>\n<p>맨 위로 이동하기 👆🏼</p>\n<p>가장 간단하고 사용하기 쉬운 애니메이션입니다. 값만 변경하면 애니메이션이 트리거되고, Flutter가 모든 것을 자동으로 처리해줍니다.</p>\n<h2>1.1 준비된 위젯으로 암묵적 애니메이션</h2>\n<p>이들은 AnimatedFoo 위젯이라고 불립니다. 여기서 Foo는 애니메이션 속성을 나타냅니다. 대부분은 이미 알고 사용하는 위젯의 애니메이션 버전입니다. 예를 들어 Container/AnimatedContainer, Padding/AnimatedPadding, Positioned/AnimatedPositioned 등이 있습니다.</p>\n<p>예를 들어, 다음 애니메이션을 확인해보세요:</p>\n<p>이 애니메이션은 AnimatedContainer, AnimatedPositioned 및 AnimatedDefaultTextStyle 위젯만을 사용하여 구현되었습니다. 지속 시간 값을 지정하고 변경 가능한 변수를 제공하면 끝입니다!</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">AnimatedPositioned</span>(\n  <span class=\"hljs-attr\">top</span>: selectedItemIndex * itemHeight,\n  <span class=\"hljs-attr\">left</span>: <span class=\"hljs-number\">0</span>,\n  <span class=\"hljs-attr\">right</span>: <span class=\"hljs-number\">0</span>,\n  <span class=\"hljs-attr\">duration</span>: <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Duration</span>(<span class=\"hljs-attr\">milliseconds</span>: <span class=\"hljs-number\">200</span>),\n  <span class=\"hljs-attr\">curve</span>: <span class=\"hljs-title class_\">Curves</span>.<span class=\"hljs-property\">easeInOut</span>,\n  <span class=\"hljs-attr\">child</span>: <span class=\"hljs-comment\">//...</span>\n),\n<span class=\"hljs-comment\">//...</span>\n<span class=\"hljs-title class_\">AnimatedContainer</span>(\n  <span class=\"hljs-attr\">duration</span>: <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Duration</span>(<span class=\"hljs-attr\">milliseconds</span>: <span class=\"hljs-number\">200</span>),\n  <span class=\"hljs-attr\">curve</span>: <span class=\"hljs-title class_\">Curves</span>.<span class=\"hljs-property\">easeInOut</span>,\n  <span class=\"hljs-attr\">decoration</span>: <span class=\"hljs-title class_\">BoxDecoration</span>(\n    <span class=\"hljs-attr\">color</span>: selectedItemIndex == i ? yellow : pink,\n    <span class=\"hljs-attr\">border</span>: <span class=\"hljs-title class_\">Border</span>.<span class=\"hljs-title function_\">all</span>(\n      <span class=\"hljs-attr\">color</span>: selectedItemIndex == i\n          ? <span class=\"hljs-title class_\">Colors</span>.<span class=\"hljs-property\">white</span>\n          : <span class=\"hljs-title class_\">Colors</span>.<span class=\"hljs-property\">transparent</span>,\n      <span class=\"hljs-attr\">width</span>: <span class=\"hljs-number\">2</span>,\n    ),\n  ),\n  <span class=\"hljs-attr\">child</span>: <span class=\"hljs-title class_\">AnimatedDefaultTextStyle</span>(\n    <span class=\"hljs-attr\">duration</span>: <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Duration</span>(<span class=\"hljs-attr\">milliseconds</span>: <span class=\"hljs-number\">200</span>),\n    <span class=\"hljs-attr\">style</span>: <span class=\"hljs-title class_\">TextStyle</span>(\n      <span class=\"hljs-attr\">color</span>: selectedItemIndex == i\n          ? <span class=\"hljs-title class_\">Colors</span>.<span class=\"hljs-property\">black</span>\n          : <span class=\"hljs-title class_\">Colors</span>.<span class=\"hljs-property\">white</span>,\n    ),\n    <span class=\"hljs-attr\">child</span>: <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Text</span>(<span class=\"hljs-string\">'Featured!'</span>),\n  ),\n),\n</code></pre>\n<p>그리고 간단히 각 목록 항목은 아래와 같은 onTap 메서드가 있는 InkWell 위젯으로 래핑되어 있습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-attr\">onTap</span>: <span class=\"hljs-function\">() =></span> <span class=\"hljs-title function_\">setState</span>(<span class=\"hljs-function\">() =></span> selectedItemIndex = i),\n</code></pre>\n<p>이렇게 하면 애니메이션을 트리거할 수 있어요!</p>\n<p>여기 사용 가능한 AnimatedFoo 위젯 전체 목록이 있어요.</p>\n<p>따라서 우리는 AnimatedFoo 위젯을 투명도, 패딩, 정렬, 위치와 같은 속성용으로 가지고 있어요. 하지만 다른 속성을 애니메이션화하고 싶을 때 어떡하나요? 그럼 여전히 쉽고 빠르게 사용하고 싶어요.</p>\n<h2>1.2. TweenAnimationBuilder를 사용한 암시적 애니메이션</h2>\n<p>화면 맨 위로 이동 👆🏼</p>\n<p>TweenAnimationBuilder를 사용하면 Tween 클래스를 사용하여 모든 위젯의 속성을 암시적으로 애니메이트할 수 있습니다. Tween 클래스의 이름은 \"Between\"에서 따왔습니다. 기본적으로 애니메이트해야 할 시작 및 끝 값을 제공합니다. 그리고 TweenAnimationBuilder 위젯의 빌더는 애니메이션 값으로 제공되며 이 값을 해당 빌더에서 반환하는 위젯의 어떤 속성에 적용할 수 있습니다.</p>\n<p>다음은 예시 애니메이션입니다:</p>\n<p>아래는 해당 코드입니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">TweenAnimationBuilder</span>(\n  <span class=\"hljs-attr\">duration</span>: <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Duration</span>(<span class=\"hljs-attr\">milliseconds</span>: <span class=\"hljs-number\">200</span>),\n  <span class=\"hljs-attr\">tween</span>: <span class=\"hljs-title class_\">Tween</span>&#x3C;double>(<span class=\"hljs-attr\">begin</span>: <span class=\"hljs-number\">0.01</span>, <span class=\"hljs-attr\">end</span>: _sliderValue),\n  <span class=\"hljs-attr\">child</span>: <span class=\"hljs-title class_\">Container</span>(\n    <span class=\"hljs-attr\">decoration</span>: <span class=\"hljs-title class_\">BoxDecoration</span>(\n      <span class=\"hljs-comment\">//...</span>\n    ),\n    <span class=\"hljs-attr\">child</span>: <span class=\"hljs-title class_\">Slider</span>(\n      <span class=\"hljs-attr\">value</span>: _sliderValue,\n      <span class=\"hljs-attr\">min</span>: <span class=\"hljs-number\">0.01</span>,\n      <span class=\"hljs-attr\">onChanged</span>: (value) {\n        <span class=\"hljs-title function_\">setState</span>(<span class=\"hljs-function\">() =></span> _sliderValue = value);\n      },\n    ),\n  ),\n  <span class=\"hljs-attr\">builder</span>: (<span class=\"hljs-title class_\">BuildContext</span> context, double? value, <span class=\"hljs-title class_\">Widget</span>? child) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">ClipRect</span>(\n      <span class=\"hljs-attr\">child</span>: <span class=\"hljs-title class_\">BackdropFilter</span>(\n        <span class=\"hljs-attr\">filter</span>: <span class=\"hljs-title class_\">ImageFilter</span>.<span class=\"hljs-title function_\">blur</span>(\n          <span class=\"hljs-attr\">sigmaX</span>: <span class=\"hljs-number\">40</span> * (value ?? <span class=\"hljs-number\">0.01</span>),\n          <span class=\"hljs-attr\">sigmaY</span>: <span class=\"hljs-number\">40</span> * (value ?? <span class=\"hljs-number\">0.01</span>),\n        ),\n        <span class=\"hljs-attr\">child</span>: child,\n      ),\n    );\n  },\n);\n</code></pre>\n<p>_sliderValue 변수는 0.01에서 1로 변경됩니다. 따라서 각 값의 변경마다 애니메이션이 트리거되며 BackdropFilter 위젯의 sigmaX 및 sigmaY 속성을 위한 새 값으로 다시 빌더 함수가 재구성됩니다. (0 값을 주면 BackdropFilter 위젯이 웹에서 오류를 발생시키기 때문에 0.01을 사용했습니다.)</p>\n<p>TweenAnimationBuilder의 child 매개변수를 사용하여 더 나은 성능을 위해 빌더를 활용하고 있어요. 이 child는 애니메이션이 트리거될 때마다 다시 빌드하는 대신 한 번만 다시 빌드되어요.</p>\n<p>좋아요, 쉬운 내용은 끝났습니다. 이제 본격적인 내용을 시작해볼까요?</p>\n<h1>2. 명시적 애니메이션</h1>\n<p>맨 위로 돌아가기 👆🏼</p>\n<p>암시적 애니메이션에서 AnimatedFoo 또는 TweenAnimationBuilder 위젯 내부의 값만 변경하면 애니메이션이 트리거되었던 것을 기억하시나요? 그러나 명시적 애니메이션은 \"명시적으로\" 애니메이트할 때까지 애니메이션을 트리거하지 않습니다. 애니메이션을 시작하고 어떻게 애니메이트할지 및 AnimationController를 사용하여 애니메이션을 \"제어\"하는 방법을 알려주어야 합니다.</p>\n<p>명시적 애니메이션 역시 암시적 애니메이션과 유사하게 사용하기 쉬운 위젯과 사용자 정의 수준이 추가된 위젯이 준비되어 있어 자유롭게 사용할 수 있습니다!</p>\n<p>그런데, AnimationController가 무엇인지 궁금하시죠? 이를 사용하는 명시적 애니메이션 위젯에 대해 알아보기 전에 먼저 AnimationController에 대해 학습해 보겠습니다.</p>\n<h2>AnimationController</h2>\n<p>위로 이동 👆🏼</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">AnimationController</span>({\n  double? value,\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">duration</span>,\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">reverseDuration</span>,\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">debugLabel</span>,\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">lowerBound</span> = <span class=\"hljs-number\">0.0</span>,\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">upperBound</span> = <span class=\"hljs-number\">1.0</span>,\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">animationBehavior</span> = <span class=\"hljs-title class_\">AnimationBehavior</span>.<span class=\"hljs-property\">normal</span>,\n  required <span class=\"hljs-title class_\">TickerProvider</span> vsync,\n})\n</code></pre>\n<p>이전에 언급했듯이 AnimationController를 사용하면 애니메이션을 \"제어\"할 수 있습니다. 그를 위해서는 vsync 값이 TickerProvider 유형이 필요합니다. Ticker는 기본적으로 Flutter의 프레임 렌더링을 추적하고 컨트롤러가 해당 티커를 따라가서 지정된 기간 내에 '애니메이션'할 수 있도록 허용하며, 기본적으로 0과 1인 lowerBound 및 upperBound 값 사이에서 선형으로 값들을 생성합니다.</p>\n<p>결과적으로, AnimationController를 사용하면 다음을 할 수 있습니다:</p>\n<ul>\n<li>forward()을 호출하여 애니메이션을 앞으로 재생합니다.</li>\n<li>reverse()를 호출하여 애니메이션을 역방향으로 재생합니다.</li>\n<li>stop()을 호출하여 애니메이션을 멈춥니다.</li>\n<li>repeat()을 호출하여 애니메이션을 가시 상태인 한 계속 반복합니다.</li>\n<li>reset()을 호출하여 애니메이션을 lowerBound로 재설정합니다.</li>\n<li>값을 설정합니다.</li>\n<li>isAnimating, isCompleted, isDismissed 등과 같이 애니메이션의 상태를 알아내기 위해 다양한 get 함수에 액세스합니다.</li>\n</ul>\n<p>자, 이 멋진 놈을 사용하여 실제 작업을 확인해 보겠습니다 🎬</p>\n<h2>2.1. 준비된 위젯을 사용한 명시적 애니메이션</h2>\n<p>맨 위로 이동 👆🏼</p>\n<p>그들은 FooTransition 위젯이라고 불립니다. 이 때 Foo는 위젯의 애니메이션 속성입니다. 일부는 당신이 사용하는 일반 위젯의 애니메이션 가능한 위젯들입니다. 예를 들어, AlignTransition, PositionedTransition가 있습니다.</p>\n<p>이 애니메이션을 확인해보세요:</p>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*GYCKdoQEUQeblnBoyoEHjQ.gif\" alt=\"animation\"></p>\n<p>이것은 AlignTransition 및 RotationTransition 위젯을 사용하여 달성되었습니다.</p>\n<p>코드 분석:</p>\n<ul>\n<li>\n<p>10번 줄 및 17번 줄: AnimationController를 초기화하고 정의합니다.</p>\n</li>\n<li>\n<p>AnimationController의 vsync 값 (19번 줄)은 SingleTickerProviderStateMixin(9번 줄)에서 가져온 값입니다. 이 mixin은 우리에게 이야기한 TickerProvider를 제공합니다. 또한 위젯이 보이는 상태일 때만 애니메이션이 실행되도록 보장합니다.</p>\n</li>\n<li>\n<p>11번 줄 및 22번 줄: AlignTransition 위젯의 Animation을 초기화하고 정의합니다 (51번 줄). AlignmentGeometry 유형의 Tween을 사용하여 애니메이션을 정의합니다. 결국, 애니메이션은 Alignment.centerLeft에서 Alignment.centerRight로 애니메이션될 것임을 알려주고 Tween의 animate 메서드를 호출하여 이 애니메이션을 AnimationController와 연결한 후 AlignmentGeometry 유형의 Animation을 반환합니다. 이렇게 하면 AnimationController의 하한 및 상한이 아니라 Tween의 시작 및 종료 값 사이에서 애니메이션이 작동합니다.</p>\n</li>\n<li>\n<p>12번 줄 및 32번 줄: RotationTransition 위젯의 회전 속성(turns)의 애니메이션을 초기화하고 정의합니다 (53번 줄). 따라서 0부터 2까지의 시작 및 종료 값이 있으므로, 애니메이션이 끝나면 위젯은 두 번 회전할 것입니다.</p>\n</li>\n<li>\n<p>20번 줄: AnimationController에 반복을 호출하여 애니메이션이 계속되도록 만듭니다. 그리고 reverse를 true로 설정하면 애니메이션이 순방향으로 시작하여 반대로, 다시 순방향으로, ... 이렇게 반복됩니다.</p>\n</li>\n<li>\n<p>42번 줄: 위젯의 상태가 dispose되는 시점에 AnimationController를 폐기(dispose)합니다. 메모리 누수를 방지하기 위해 AnimationController를 dispose하는 것은 항상 중요합니다!</p>\n</li>\n</ul>\n<p>하지만 걱정하지 마세요. 조금의 연습으로 매우 쉬워지고 익숙해질 것입니다!</p>\n<p>가능한 모든 FooTransition 위젯 목록입니다:</p>\n<p>암시적 애니메이션에서 AnimatedFoo 위젯이 애니메이션 목적에 충분하지 않을 때 어떻게 했는지 기억하나요? AnimatedFoo 위젯으로 처리되지 않은 속성을 애니메이션화하기 위해 TweenAnimationBuilder를 사용했습니다. 비슷하게, 명시적 애니메이션에서는 AnimatedBuilder 위젯을 사용하여 어떤 위젯 속성을 애니메이션화할 수 있습니다. 또는 더 나아가서 직접 FooTransition을 만들기 위해 AnimatedWidget 클래스를 사용할 수도 있습니다!</p>\n<h2>2.2 AnimatedBuilder 위젯을 사용한 명시적 애니메이션</h2>\n<p>맨 위로 이동 👆🏼</p>\n<p>다음 애니메이션을 확인해보세요:</p>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*whGvEQM5o0b4W0hZIkgu_A.gif\" alt=\"Animation\"></p>\n<p>GradientTransition 위젯이 없죠? 그럼 어떻게 만들었을까요? AnimatedBuilder 위젯을 이용했어요! 여기에 코드가 있어요:</p>\n<p>우리는 AnimationController를 초기화하고 정의했고 이를 AnimatedBuilder 위젯의 애니메이션 값으로 사용했어요. 이제 AnimatedBuilder는 컨트롤러의 값이 변경될 때마다 \"다시 빌드(build)\"되고 빌더를 호출하여 업데이트된 _controller.value 값을 가진 새 위젯을 반환해요. 이로써 그라데이션이 애니메이션 되게 만들었어요.</p>\n<p>물론, AnimationController의 lowerBound 및 upperBound 값 이외의 것을 원한다면, 자체 Animation을 만들고 AnimationController에 연결한 다음 AnimatedBuilder 위젯에 전달할 수 있습니다.</p>\n<pre><code class=\"hljs language-dart\">_animation = Tween&#x3C;<span class=\"hljs-built_in\">double</span>>(begin: <span class=\"hljs-number\">0</span>, end: <span class=\"hljs-number\">0.5</span>).animate(_controller);\n<span class=\"hljs-comment\">//...</span>\nAnimatedBuilder(\n  animation: _animation,\n  builder: (context, child) {\n     <span class=\"hljs-comment\">//... 값 사용하기: _animation.value</span>\n  }\n)\n</code></pre>\n<p>또한 AnimatedBuilder 위젯의 child 매개변수를 사용하여 성능을 향상시킬 수 있습니다. 이렇게 하면 매번 애니메이션 값이 변경될 때마다 다시 구축되지 않습니다.</p>\n<p>아직 따라오고 있나요? 조금만 더 힘내세요! 거의 끝났습니다!</p>\n<p>이제 한 걸음 더 나아가서 AnimatedWidget 클래스를 사용하여 우리만의 FooTransition 위젯을 만들어보겠습니다!</p>\n<h2>2.3 AnimatedWidget 클래스를 사용한 명시적 애니메이션</h2>\n<p>맨 위로 이동 👆🏼</p>\n<p>아주 비밀스러운 비밀을 하나 알려줄게요. 어떤 FooTransition 위젯의 소스 코드로 가 보세요, 무엇을 보게 될까요?</p>\n<p><img src=\"/assets/img/2024-06-21-FlutterAnimationsComprehensiveGuide_1.png\" alt=\"Image 1\"></p>\n<p>😱 It extends an AnimatedWidget class, and from what we see, the Animation type parameter (in this case turns) is passed as a listenable to the super class:</p>\n<p><img src=\"/assets/img/2024-06-21-FlutterAnimationsComprehensiveGuide_2.png\" alt=\"Image 2\"></p>\n<p>And the AnimatedWidget is basically a StatefulWidget! So we can do the exact same!</p>\n<p>우리만의 GradientTransition 위젯을 만들어봅시다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">GradientTransition</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">AnimatedWidget</span> {\n  final <span class=\"hljs-title class_\">Animation</span>&#x3C;double> stop;\n\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">GradientTransition</span>({\n    <span class=\"hljs-title class_\">Key</span>? key,\n    required <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">stop</span>,\n  }) : <span class=\"hljs-variable language_\">super</span>(<span class=\"hljs-attr\">key</span>: key, <span class=\"hljs-attr\">listenable</span>: stop);\n\n  @override\n  <span class=\"hljs-title class_\">Widget</span> <span class=\"hljs-title function_\">build</span>(<span class=\"hljs-params\">BuildContext context</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Container</span>(\n      <span class=\"hljs-attr\">height</span>: <span class=\"hljs-number\">100</span>,\n      <span class=\"hljs-attr\">decoration</span>: <span class=\"hljs-title class_\">BoxDecoration</span>(\n        <span class=\"hljs-attr\">gradient</span>: <span class=\"hljs-title class_\">LinearGradient</span>(\n          <span class=\"hljs-attr\">colors</span>: <span class=\"hljs-keyword\">const</span> [purple, pink, yellow],\n          <span class=\"hljs-attr\">stops</span>: [<span class=\"hljs-number\">0</span>, stop.<span class=\"hljs-property\">value</span>, <span class=\"hljs-number\">1</span>],\n        ),\n      ),\n    );\n  }\n}\n</code></pre>\n<p>그리고 사용하기 위해서는 AnimationController를 그대로 전달하면 됩니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">GradientTransition</span>(<span class=\"hljs-attr\">stop</span>: _controller),\n</code></pre>\n<p>그게 다야!</p>\n<p>여기까지 버텨내 왔다면, 매우 간단한 것부터 매우 복잡한 것까지 다양한 플러터 애니메이션을 만들기에 충분한 지식을 가지고 있습니다. 필요한 건 조금의 연습뿐이며, 하늘이 한계입니다!</p>\n<h1>적절한 애니메이션 접근 방식 선택</h1>\n<p>맨 위로 이동 👆🏼</p>\n<p>하지만 잠시만 기다려봐요. 위에서 다룬 여러 방법 중에서 어떤 애니메이션을 선택해야 하는지 어떻게 알 수 있을까요? 플러터(Flutter) 팀의 멋진 분들이 도와주기 위해 비디오와 의사결정 트리를 만들었어요. 제가 최대한 요약해 드릴게요.</p>\n<h2>1. 그림 기반 vs. 코드 기반</h2>\n<p>첫 번째 선택은 그림 기반 및 코드 기반 애니메이션 사이에서 이루어질 거예요. 이를 위해 자신에게 물어보세요. 만약 당신의 애니메이션이 그림처럼 더 비스무런가요(그림 기반 사용, 3rd party 패키지 사용, 곧 설명할 거예요) 아니면 레이아웃, 위젯, 위젯 스타일, 색상, 테두리, 텍스트 등과 관련이 있는가요(코드 기반 사용, 위에서 설명한 것)?</p>\n<h2>2. 암시적(Implicit) vs. 명시적(Explicit)</h2>\n<p>다음 선택은 암시적 및 명시적 애니메이션 중 하나가 될 것입니다. 선택을 하는 데 고려해야 할 여러 기준이 있습니다:</p>\n<ul>\n<li>무한히 반복되는 애니메이션</li>\n<li>연속되지 않는 애니메이션: 애니메이션이 시작 지점으로 돌아가지 않음</li>\n<li>여러 위젯이 함께 애니메이션화되는 경우</li>\n</ul>\n<p>만약 애니메이션이 위의 기준 중 하나라도 가지고 있다면, 명시적 애니메이션을 사용해야 합니다.</p>\n<h2>3. 내장 위젯 대 사용자 정의 위젯</h2>\n<p>마지막 선택 사항은 내장 위젯(AnimatedFoo 및 FooTransition 위젯)과 사용자 지정 위젯(TweenAnimationBuilder 및 AnimatedBuilder/AnimatedWidget) 사이에서 합니다. 이것은 이 목록을 보고 원하는 속성을 애니메이션화하기 위해 이미 내장된 위젯이 있는지 여부를 고려하는 것만큼 간단합니다. 해당 내장 위젯을 사용하거나 (그렇지 않으면 직접 생성)</p>\n<h1>3rd Party 패키지를 사용한 애니메이션</h1>\n<p>하지만 앱에서 그림을 기반으로 한 애니메이션을 사용하고 싶다면 어떨까요? 여기서는 코딩이 절약되었네요 🫢, 또한 플러터는 여기에서도 놀라울 정도로 좋습니다! Rive 및 Lottie와 같은 훌륭한 패키지들이 있어서 3rd party 애니메이션을 원활하게 통합하고 앱에 추가할 수 있습니다. 제공되는 애니메이션을 그래픽 디자이너/모션 그래픽 디자이너와 함께 사용하거나 커뮤니티에서 만든 애니메이션을 다운로드/구매하여 빠르고 쉽게 앱에 사용할 수 있습니다.</p>\n<p>3rd party 패키지를 사용하여 Flutter에서 애니메이션을 만드는 데 관한 전용 기사를 작성할 예정이에요. 지금 당장 유용한 링크 몇 개를 공유해 드릴게요:</p>\n<ul>\n<li>사용 준비가 된 멋진 애니메이션을 볼 수 있는 Rive 커뮤니티 쇼케이스</li>\n<li>Rive Flutter 패키지</li>\n<li>무료 LottieFiles 애니메이션</li>\n<li>LottieFiles Flutter 패키지</li>\n</ul>\n<p>여기까지가 제 글이에요! 이 기사를 읽어 주셔서 감사합니다. 이것이 Flutter 앱에 애니메이션을 추가하고 싶을 때 여러분의 정보원이 되었으면 좋겠어요. 그럼 여러분도 애니메이션을 넣을 때 즐겁게 시도해 보세요!</p>\n<p><a href=\"https://twitter.com/FlutterComm\" rel=\"nofollow\" target=\"_blank\">https://twitter.com/FlutterComm</a></p>\n</body>\n</html>\n"},"__N_SSG":true}