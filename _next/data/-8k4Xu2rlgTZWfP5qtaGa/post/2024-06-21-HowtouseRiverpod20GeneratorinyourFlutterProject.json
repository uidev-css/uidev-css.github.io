{"pageProps":{"post":{"title":"Flutter 프로젝트에서 Riverpod 20  Generator 사용법","description":"","date":"2024-06-21 20:19","slug":"2024-06-21-HowtouseRiverpod20GeneratorinyourFlutterProject","content":"\n\n<img src=\"/assets/img/2024-06-21-HowtouseRiverpod20GeneratorinyourFlutterProject_0.png\" />\n\nRiverpod은 플러터(Flutter)에서 상태 관리 및 반응형 데이터 캐싱의 새로운 표준입니다. 두 번째 버전인 Riverpod 2.0은 꽤 오랫동안 출시되었지만, 새로운 데이터 관리 방법과 컨셉을 이해하기 어려울 수 있습니다.\n\n# 우리가 배울 내용\n\n- Riverpod 2.0의 새로운 프로바이더로 기존 프로바이더를 업데이트하는 방법.\n- 앱 내에서 상태를 새로운 방식으로 관리하는 방법.\n- Riverpod 2.0에서 퓨처(futures)를 다루는 방법.\n- 프로바이더를 자동으로 생성하고 프로바이더 생성 프로세스를 간소화하는 방법.\n\n<div class=\"content-ad\"></div>\n\n시작하기 전에, Riverpod가 무엇을 할 수 있는지 알아보아야 합니다. Riverpod는 상태를 관리하기 위해 providers라는 것을 사용하며, 다음은 2.0 이전에 존재했던 providers입니다. 다양한 유형의 providers를 빠르게 살펴보겠습니다:\n\n- Provider: 이 provider는 값을 생성합니다. 반응적 상태나 메모리가 없기 때문에 대부분의 경우에 최적이 아니지만, 많은 정적 메소드를 가진 클래스나 접근하려는 종속성이 있는 경우 유용합니다.\n- ChangeNotifierProvider, StateNotifierProvider, StateProvider: 이들은 앱 내부에서 로컬 상태를 생성, 액세스 및 캐싱하는 데 도움을 줍니다. 모두 반응적인 변경을 지원합니다.\n- FutureProvider, StreamProvider: 이들은 앱 내에서 비동기 데이터를 캐싱하고 액세스하는 데 도움을 줍니다.\n\nRiverpod 2.0에서는 이러한 모든 providers를 대체하는 2개의 providers가 있습니다... 하나만 제외하고요.\n\n- NotifierProvider: 이는 변경 알림/동기 변경에 사용되며, ChangeNotifierProvider, StateNotifierProvider, StateProvider를 대체합니다.\n- AsyncNotifier: 이는 비동기 변경에 사용되며, FutureProvider를 대체합니다. 2024년 6월 19일 현재, StreamProvider를 대체할 대안이 없습니다.\n\n<div class=\"content-ad\"></div>\n\n이전에 언급한 대로, 생성기를 사용하여 우리의 프로바이더를 만들기도 할 겁니다. 생성기는 새로운 프로바이더 구문을 지원합니다 (StreamProviders를 제외하고). 또한 AutoDisposeProviders를 지원합니다. @riverpod 어노테이션을 사용하여 생성기에게 다음 함수를 프로바이더로 만들라고 알립니다.\n\n새로운 프로바이더에 대해 익숙해졌으니, 생성기를 사용하여 어떻게 앱에서 사용할 지 살펴봅시다.\n\n# 시작하기\n\n가장 중요한 것은 앱에 Riverpod 2.0 패키지를 설치하는 것입니다. pubspec.yaml 파일에 다음 줄을 추가하세요.\n\n<div class=\"content-ad\"></div>\n\n```yaml\n# pubspec.yaml\n\ndependencies:\n  flutter_riverpod: ^2.1.3\n  riverpod_annotation: ^1.1.1\ndev_dependencies:\n  build_runner:\n  riverpod_generator: ^1.1.1\n```\n\n# HelloWorld Provider 생성\n\n이제 가장 기본적인 provider 스타일을 만들고 사용하는 방법을 보여주는 다음 코드 조각을 살펴봅시다.\n\n```dart\n// main.dart\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:riverpod_annotation/riverpod_annotation.dart';\n// 생성기는 provider가 포함된 파일을 생성합니다. 전형적으로 \"<filename>.g.dart\" 구문을 따르도록 합니다.\n// 또한 import 문 이후에 코드를 작성하는 것이 좋습니다.\npart 'main.g.dart';\n\n// 단순히 메서드를 생성하고 \"@riverpod\"로 주석을 달아 provider를 만듭니다.\n// \"HelloWorldRef\" 객체를 생성하는 방법에 유의하세요.\n// 이 객체는 아직 존재하지 않지만 \"dart run build_runner watch\" 명령을 실행하면 생성됩니다.\n@riverpod\nString helloWorld(HelloWorldRef ref) {\n  return 'Hello world';\n}\n\n// provider를 사용하기 위해서는 동기식 provider를 사용하는 방식과 동일한 방식으로 사용합니다.\nvoid main() {\n  runApp(\n    // 앱의 모든 provider 상태는 ProviderScope 내에 저장됩니다.\n    // provider를 읽기 위해서는 이를 반드시 포함해야 합니다.\n    ProviderScope(\n      child: MyApp(),\n    ),\n  );\n}\n\n// Riverpod는 Stateless와 Stateful 위젯과 유사한 ConsumerWidget 및 ConsumerStatefulWidget 클래스 액세스를 제공합니다.\nclass MyApp extends ConsumerWidget {\n  // ConsumerWidget의 build 메서드가 WidgetRef 객체를 가져오는 방식에 유의하세요.\n  // WidgetRef는 provider를 읽는 데 사용됩니다.\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    // provider를 읽는 두 가지 방법이 있습니다.\n    // 값을 읽고 변경 사항을 감시하려면 ref.watch(...)를 사용하고,\n    // 함수를 호출하려면 ref.read(...)를 사용합니다.\n    final String val = ref.watch(helloWorldProvider);\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Hello World Example')),\n        body: Center(\n          child: Text(val),\n        ),\n      ),\n    );\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n- 제너레이터는 프로바이더가 포함된 파일을 생성합니다. 일반적으로 이 구문을 따르도록 하려면 `filename`.g.dart 형식을 따르길 원합니다. 그리고 import 문 이후에 이를 유지하는 것이 좋습니다. 이 부분은 파일이 서로 관련되어 있음을 Dart에게 알려주는 부분입니다.\n- 프로바이더를 만들기 위해서는 단순히 메서드를 만들고 이를 “@riverpod”으로 주석 처리하여 우리의 프로바이더를 생성합니다. \"HelloWorldRef\" 객체를 만든 방법에 주목해보세요. 아직 존재하지는 않지만 우리가 터미널에서 dart run build_runner watch 명령을 실행하면 생성될 것입니다. 따라서 해당 명령을 실행하고 `filename`.g.dart라는 파일을 생성하고 생성 중 발생한 오류를 해결하세요. 해당 파일은 다음과 같습니다:\n\n```js\n// GENERATED CODE - DO NOT MODIFY BY HAND\n\npart of 'main.dart';\n// **************************************************************************\n// RiverpodGenerator\n// **************************************************************************\n// ignore_for_file: avoid_private_typedef_functions, non_constant_identifier_names, subtype_of_sealed_class, invalid_use_of_internal_member, unused_element, constant_identifier_names, unnecessary_raw_strings, library_private_types_in_public_api\n/// Dart SDK에서 복사함\nclass _SystemHash {\n  _SystemHash._();\n  static int combine(int hash, int value) {\n    // ignore: parameter_assignments\n    hash = 0x1fffffff & (hash + value);\n    // ignore: parameter_assignments\n    hash = 0x1fffffff & (hash + ((0x0007ffff & hash) << 10));\n    return hash ^ (hash >> 6);\n  }\n  static int finish(int hash) {\n    // ignore: parameter_assignments\n    hash = 0x1fffffff & (hash + ((0x03ffffff & hash) << 3));\n    // ignore: parameter_assignments\n    hash = hash ^ (hash >> 11);\n    return 0x1fffffff & (hash + ((0x00003fff & hash) << 15));\n  }\n}\nString $helloWorldHash() => r'8bbe6cff2b7b1f4e1f7be3d1820da793259f7bfc';\n/// [helloWorld]도 참고하세요.\nfinal helloWorldProvider = AutoDisposeProvider<String>(\n  helloWorld,\n  name: r'helloWorldProvider',\n  debugGetCreateSourceHash:\n      const bool.fromEnvironment('dart.vm.product') ? null : $helloWorldHash,\n);\ntypedef HelloWorldRef = AutoDisposeProviderRef<String>;\n```\n\n- 생성된 프로바이더가 AutoDisposeProvider인 것을 주목하세요. 이는 상태가 없는 데이터와 유사하기 때문입니다.\n- 파일을 저장한 후, dart run build_runner watch가 실행 중인 한 모든 생성된 프로바이더가 다시 생성됩니다.\n\n# 위젯 트리 어디서든 프로바이더에 접근하기\n\n<div class=\"content-ad\"></div>\n\n이제 당신은 앱 내에서 제공 업체의 데이터를 어디서든 읽을 수 있는지 궁금해 할 수도 있습니다. 이를 제공 업체 소비하기라고하며, 이를 위해 ref.watch(…) 메서드를 호출하는 WidgetRef 개체를 사용해야합니다. 위젯의 특정 부분만 제공 업체에 액세스해야하는 경우 Consumer 클래스를 사용할 수 있습니다.\n\n다음은 Consumer 클래스를 사용한 예시입니다.\n\n```dart\n// main.dart\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:riverpod_annotation/riverpod_annotation.dart';\n\npart 'main.g.dart';\n\n@riverpod\nString helloWorld(HelloWorldRef ref) {\n  return 'Hello world';\n}\n\nvoid main() {\n  runApp(\n    ProviderScope(\n      child: MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: const Text('Hello World Example')),\n        body: Center(\n          child: Consumer(\n            builder: (context, ref, child) {\n              final String val = ref.watch(helloWorldProvider);\n              // Consumer has a return type of Widget.\n              // Almost like using a Builder widget, but Riverpodified :)\n              return Text(val);\n            },\n        ),\n      ),\n    );\n  }\n}\n```\n\n# 변수에 반응형 상태 추가하기\n\n<div class=\"content-ad\"></div>\n\n더 복잡한 제공자 예제를 살펴봅시다. 클래스를 사용하는 것과 같은 예제입니다. 이는 체크박스 부울 값이나 요소 목록과 같은 반응성 상태가 필요한 변수가 있는 경우 유용할 수 있습니다.\n\n다음 예제에서는 클래스를 사용하여 변수의 저장소로 사용하고 제공자로 변환하는 방법을 보여줍니다.\n\n```js\n@riverpod\nclass HelloWorld extends _$HelloWorld {\n  String build() {\n    return \"hello world\";\n  }\n\n  void toCamelCase() {\n      // 변수 상태를 사용하여 제공자의 현재 상태에 액세스하는 방법에 주목해주세요.\n      state = '${state[0].toUpperCase()}${state.substring(1).toLowerCase()}';\n  }\n}\n\nref.watch(helloWorldProvider); // hello world\nref.watch(helloWorldProvider.notifier).toCamelCase();\nref.watch(helloWorldProvider); // Hello World\n```\n\n이 예제에서는 우리의 클래스가 _$`클래스명`을 확장하고 제공자로 변환되어야 한다는 것을 riverpod에게 알려주기 위해 위에 riverpod 주석이 달렸습니다. 참고: 클래스로 만든 모든 제공자는 build() 메서드가 필요합니다. 이곳이 제공자의 초기 상태를 구성하는 곳입니다.\n\n<div class=\"content-ad\"></div>\n\n제공자를 사용하는 것은 이전에 언급한 예제들만큼 간단합니다: 단순히 ref.watch(`생성된 제공자 이름`)을 호출하면 앱이 변경 사항을 감시합니다. 그리고 클래스의 접근자 메서드를 사용하려면 ref.watch(`생성된 제공자 이름`.notifier).`메서드 이름`()을 호출해야 합니다. .notifier를 꼭 포함하도록 하세요.\n\n# 제공자의 현재 값 변경하기\n\n이제 제공자 내의 현재 값을 변경하려면 클래스 내에 생성자를 사용하고 약간 수정해야 합니다. 즐겨 사용하는 단어 목록을 살펴보겠습니다.\n\n```js\n@riverpod\nclass FavoriteWordsRepository extends _$FavoriteWordsRepository {\n  FavoriteWordsRepository(List<String> favoriteWords) {\n    words = favoriteWords;\n  }\n\n  List<String> words = [];\n\n  @override\n  List<String> build() {\n    return words;\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\nmain.g.dart 파일에서 FavoriteWordsRepository.new를 사용할 수 없다는 오류가 발생할 수 있습니다. 이 간단한 수정으로 해결할 수 있습니다:\n\n```js\nfinal favoriteWordsRepositoryProvider =\n    AutoDisposeAsyncNotifierProvider<FavoriteWordsRepository, List<String>>(\n  () => FavoriteWordsRepository([]), // FavoriteWordsRepository.new --> () => FavoriteWordsRepository([])\n```\n\n이것을 값으로 리스트를 초기화하는 것과 혼동하지 마세요. 이것은 단순히 시작점일 뿐이고 실제로 초기화된 리스트는 List`String` words = []; 입니다.\n\n그리고 위젯 코드 내에서 provider의 상태를 다음과 같이 업데이트할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nref.watch(favoriteWordsRepositoryProvider.notifier).words = ['Cars', 'Dogs', 'Flutter'];\n```\n\n# 비동기 공급자 생성\n\n지역 공급자 데이터 작업에 익숙해지면 futures를 다루는 방법도 알아봅시다! 아래 예시는 기본적인 future 공급자를 만드는 방법을 보여줍니다.\n\n```js\n@riverpod\nFuture<String> helloWorldFuture(HelloWorldFutureRef ref) async {\n  try {\n    await Future.delayed(const Duration(seconds: 3));\n    return 'Hello World';\n  } catch (e) {\n    // 이 함수는 오류를 발생시킬 수 없습니다.\n    // futures에 대한 Try/Catch 블록은 좋은 실천법입니다 :)\n    rethrow;\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n우리의 함수는 다시 HelloWorldFutureRef를 가져와야 합니다. 이것은 단일 공급자에서 여러 제공자를 사용하는 데에 사용됩니다. 다음은 dio: ^4.0.6을 사용하여 예제 API에 HTTP 요청을하는 예제입니다:\n\n```dart\n// dio_provider.dart\n\nimport 'package:dio/dio.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:riverpod_annotation/riverpod_annotation.dart';\npart 'dio_provider.g.dart';\n\n@riverpod\nDio dio(DioRef ref, {Map<String, dynamic>? headers, String? subDomain}) {\n  return Dio(BaseOptions(baseUrl: 'https://api.example.com', headers: headers));\n}\n```\n\n그리고 우리의 공급자에서 액세스하는 방법은 다음과 같습니다:\n\n```dart\n// greeting_service.dart\n\nimport 'dio_provider.dart';\n@riverpod\nFuture<String> getGreeting(GetGreetingRef ref, {required String name}) async {\n  try {\n    final response = await ref.watch(dioProvider()).get('/greeting');\n    final result = response.data;\n    final greeting = result + ', ' + name;\n    return greeting; // Hello there, Carlton\n  } catch (e) {\n    rethrow;\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n다른 공급자를 사용해 공급자를 `.family`로 만들어요.\n\n# build 메서드에 인수 전달하기\n\nRiverpod은 초기화할 때 build 메서드로 인수를 전달할 수 있게 해줘요. 이를 코드에서 어떻게 할 수 있는지 알아볼게요.\n\n```js\n@riverpod\nclass MyRepository extends _$MyRepository {\n  @override\n  // 여기에 위치 인수를 추가하세요. 이름 지정도 가능해요.\n  Future<String> build(String id, {bool value}) async {\n    final String result = await myFuture(id, value);\n    return anotherFutureThatReturnsAString(result);\n  }\n  // ...\n}\n```\n\n<div class=\"content-ad\"></div>\n\n# AsyncProvider를 사용하는 방법\n\nAsyncProvider를 사용하는 방법은 로컬 공급자를 사용하는 방법과 다르며 데이터와 상호 작용하는 방식이 변경됩니다. 주의 깊게 살펴보세요, 이것은 매우 중요합니다!\n\nUI에서 공급자를 사용하려면 .when() 구문을 사용해야 합니다. 이 구문에는 3가지 다른 상태가 포함되어 있습니다: 데이터(완료), 로딩, 오류. ConnectionState를 확인하고 해당 위젯을 반환하는 것의 번거로움을 제거하기 때문에 FutureBuilders를 이것으로 교체할 수 있습니다. 아래는 완전한 앱의 예시를 살펴봅시다:\n\n초기 앱 만들기\n\n<div class=\"content-ad\"></div>\n\n```dart\n// main.dart\n\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({Key? key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const ProviderScope(\n      child: MaterialApp(\n        home: MyHomePage(),\n      ),\n    );\n  }\n}\n```\n\nCreating foo class and provider\n\n```dart\n// foo.dart\n\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:riverpod_annotation/riverpod_annotation.dart';\n\npart 'foo.g.dart';\n\nclass Foo {\n  final int bar;\n  int? baz;\n\n  Foo(\n    this.bar, {\n    this.baz,\n  });\n}\n\n@riverpod\nclass FooController extends _$FooController {\n  FooController(this.foo);\n  Foo foo;\n\n  @override\n  FutureOr<Foo> build() async {\n    foo = await getFoo();\n    return foo;\n  }\n\n  Future<Foo> getFoo() async {\n    await Future.delayed(const Duration(seconds: 1));\n    return Foo(1);\n  }\n}\n```\n\nConsuming foo provider\n```dart\n```\n\n<div class=\"content-ad\"></div>\n\n```dart\n// home.dart\n\nclass MyHomePage extends StatelessWidget {\n  const MyHomePage({key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(),\n      body: Consumer(\n        builder: (context, ref, _) {\n          // Provider를 얻어와서 watch합니다\n          final fooAsync = ref.watch(fooControllerProvider);\n          // .when을 사용하여 Future로부터 UI를 렌더링합니다\n          return fooAsync.when(\n            data: (foo) => Text('bar: ${foo.bar}, baz: ${foo.baz}'),\n            loading: () => const CircularProgressIndicator(),\n            error: (err, stack) => Text(err.toString()),\n          );\n        },\n      ),\n    );\n  }\n}\n```\n\n이 예시에서는 Consumer 위젯을 사용하여 ref에 액세스하므로 ref.watch(fooControllerProvider)를 호출하여 AsyncData 유형을 반환할 수 있습니다. 그런 다음 .when(…) 함수가 제공하는 속성을 사용하여 UI를 매우 깨끗하고 관리하기 쉬운 형식으로 구성할 수 있습니다.\n\n이 작업은 생성된 파일에서 provider의 초기값을 설정해야 합니다.\n\n```dart\nfinal fooControllerProvider = AutoDisposeAsyncNotifierProvider<FooController, Foo>(\n  () => FooController(Foo(1)), // FooController.new --> FooController(Foo(1))\n  name: r'fooControllerProvider',\n  debugGetCreateSourceHash: const bool.fromEnvironment('dart.vm.product') ? null : $FooControllerHash,\n);\n```\n\n<div class=\"content-ad\"></div>\n\n# AsyncProvider의 현재 상태를 개체/가공 가능한 데이터처럼 가져오는 방법\n\n현재 방법은 API 데이터에 빠르게 액세스하는 데 유용하지만 문제가 발생합니다. 미래 Provider 내부의 데이터를 어떻게 가공 가능한 데이터처럼 액세스할 수 있을까요? API에서 사용자 데이터를 요청하고, 사용자 설정에서 사용자의 이름을 업데이트하고 싶다고 가정해 봅시다. 우리는 ref.watch(`YourFutureProvider`)가 User 클래스가 아닌 AsyncData 유형을 반환하기 때문에 이렇게 할 수 없습니다. 일부 데이터를 알고 싶을 때마다 GET 요청을 완료하고 싶지 않으며, 특히 첫 번째로로드되고 사용 가능한 경우입니다. 두 Provider를 만들어야할 것으로 생각할 수 있지만, 하나는 AsyncProvider이고, 하나는 NotifierProvider로 대화해야 한다면 그것은 비효율적입니다. 다행히도 이를 처리하는 방법이 있습니다.\n\n다음 코드는 AsyncProvider를 사용하고 로드된 데이터를 NotifierProvider처럼 사용하는 방법을 보여줍니다.\n\n```js\n// home.dart\n\nclass MyHomePage extends StatelessWidget {\n  const MyHomePage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(),\n      body: Consumer(\n        builder: (context, ref, _) {\n          // Foo Provider를 가져와 상태를 설정합니다.\n          // State Provider처럼 사용합니다.\n          ref.watch(fooControllerProvider.notifier).foo = Foo(3);\n          // UI에서 Foo 사용 (.requireValue는 변경 사항을 청취할 수 있도록 사용됨)\n          final foo = ref.watch(fooControllerProvider).requireValue;\n          // .when을 사용하여 미래에서 UI를 렌더링합니다.\n          return Text('bar: ${foo.bar}, baz: ${foo.baz}');\n        },\n      ),\n    );\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\nRiverpod는 플러터에서 상태 관리의 가장 추천되는 방법으로 나타났으며 완전히 반응적인 상태 프레임워크로 발전했습니다.\n\n나중에 Provider와 같은 다른 패키지는 더 이상 유지되지 않을 수 있으므로 Riverpod를 배우는 것이 중요합니다 (물론 먼 훗날입니다). 또한 Riverpod는 새로운 제너레이터 덕분에 상태를 효과적으로 관리할 수 있는 유연성과 제어성을 제공하여 build_runner를 사용해 강력하고 메모리를 고려한 프로바이더를 쉽게 만들 수 있습니다.\n\n이 글을 만드는 과정에서 도움이 된 멋진 자료를 제공해 준 다음 분들께 큰 박수를 보냅니다. 🎉\n\n<div class=\"content-ad\"></div>\n\n- CodeWithAndrea\n- Adnanjpg\n- rrouselgit\n\n이 글이 도움이 되셨기를 바랍니다. 만약 도움이 되었다면, 더 많은 튜토리얼, 경험, 그리고 안내서가 포함된 다른 글도 자유롭게 읽어보세요!\n\n하나님을 신뢰합니다 🙏🏾","ogImage":{"url":"/assets/img/2024-06-21-HowtouseRiverpod20GeneratorinyourFlutterProject_0.png"},"coverImage":"/assets/img/2024-06-21-HowtouseRiverpod20GeneratorinyourFlutterProject_0.png","tag":["Tech"],"readingTime":15},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>Riverpod은 플러터(Flutter)에서 상태 관리 및 반응형 데이터 캐싱의 새로운 표준입니다. 두 번째 버전인 Riverpod 2.0은 꽤 오랫동안 출시되었지만, 새로운 데이터 관리 방법과 컨셉을 이해하기 어려울 수 있습니다.</p>\n<h1>우리가 배울 내용</h1>\n<ul>\n<li>Riverpod 2.0의 새로운 프로바이더로 기존 프로바이더를 업데이트하는 방법.</li>\n<li>앱 내에서 상태를 새로운 방식으로 관리하는 방법.</li>\n<li>Riverpod 2.0에서 퓨처(futures)를 다루는 방법.</li>\n<li>프로바이더를 자동으로 생성하고 프로바이더 생성 프로세스를 간소화하는 방법.</li>\n</ul>\n<p>시작하기 전에, Riverpod가 무엇을 할 수 있는지 알아보아야 합니다. Riverpod는 상태를 관리하기 위해 providers라는 것을 사용하며, 다음은 2.0 이전에 존재했던 providers입니다. 다양한 유형의 providers를 빠르게 살펴보겠습니다:</p>\n<ul>\n<li>Provider: 이 provider는 값을 생성합니다. 반응적 상태나 메모리가 없기 때문에 대부분의 경우에 최적이 아니지만, 많은 정적 메소드를 가진 클래스나 접근하려는 종속성이 있는 경우 유용합니다.</li>\n<li>ChangeNotifierProvider, StateNotifierProvider, StateProvider: 이들은 앱 내부에서 로컬 상태를 생성, 액세스 및 캐싱하는 데 도움을 줍니다. 모두 반응적인 변경을 지원합니다.</li>\n<li>FutureProvider, StreamProvider: 이들은 앱 내에서 비동기 데이터를 캐싱하고 액세스하는 데 도움을 줍니다.</li>\n</ul>\n<p>Riverpod 2.0에서는 이러한 모든 providers를 대체하는 2개의 providers가 있습니다... 하나만 제외하고요.</p>\n<ul>\n<li>NotifierProvider: 이는 변경 알림/동기 변경에 사용되며, ChangeNotifierProvider, StateNotifierProvider, StateProvider를 대체합니다.</li>\n<li>AsyncNotifier: 이는 비동기 변경에 사용되며, FutureProvider를 대체합니다. 2024년 6월 19일 현재, StreamProvider를 대체할 대안이 없습니다.</li>\n</ul>\n<p>이전에 언급한 대로, 생성기를 사용하여 우리의 프로바이더를 만들기도 할 겁니다. 생성기는 새로운 프로바이더 구문을 지원합니다 (StreamProviders를 제외하고). 또한 AutoDisposeProviders를 지원합니다. @riverpod 어노테이션을 사용하여 생성기에게 다음 함수를 프로바이더로 만들라고 알립니다.</p>\n<p>새로운 프로바이더에 대해 익숙해졌으니, 생성기를 사용하여 어떻게 앱에서 사용할 지 살펴봅시다.</p>\n<h1>시작하기</h1>\n<p>가장 중요한 것은 앱에 Riverpod 2.0 패키지를 설치하는 것입니다. pubspec.yaml 파일에 다음 줄을 추가하세요.</p>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-comment\"># pubspec.yaml</span>\n\n<span class=\"hljs-attr\">dependencies:</span>\n  <span class=\"hljs-attr\">flutter_riverpod:</span> <span class=\"hljs-string\">^2.1.3</span>\n  <span class=\"hljs-attr\">riverpod_annotation:</span> <span class=\"hljs-string\">^1.1.1</span>\n<span class=\"hljs-attr\">dev_dependencies:</span>\n  <span class=\"hljs-attr\">build_runner:</span>\n  <span class=\"hljs-attr\">riverpod_generator:</span> <span class=\"hljs-string\">^1.1.1</span>\n</code></pre>\n<h1>HelloWorld Provider 생성</h1>\n<p>이제 가장 기본적인 provider 스타일을 만들고 사용하는 방법을 보여주는 다음 코드 조각을 살펴봅시다.</p>\n<pre><code class=\"hljs language-dart\"><span class=\"hljs-comment\">// main.dart</span>\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'package:flutter/material.dart'</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'package:flutter_riverpod/flutter_riverpod.dart'</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'package:riverpod_annotation/riverpod_annotation.dart'</span>;\n<span class=\"hljs-comment\">// 생성기는 provider가 포함된 파일을 생성합니다. 전형적으로 \"&#x3C;filename>.g.dart\" 구문을 따르도록 합니다.</span>\n<span class=\"hljs-comment\">// 또한 import 문 이후에 코드를 작성하는 것이 좋습니다.</span>\n<span class=\"hljs-keyword\">part</span> <span class=\"hljs-string\">'main.g.dart'</span>;\n\n<span class=\"hljs-comment\">// 단순히 메서드를 생성하고 \"@riverpod\"로 주석을 달아 provider를 만듭니다.</span>\n<span class=\"hljs-comment\">// \"HelloWorldRef\" 객체를 생성하는 방법에 유의하세요.</span>\n<span class=\"hljs-comment\">// 이 객체는 아직 존재하지 않지만 \"dart run build_runner watch\" 명령을 실행하면 생성됩니다.</span>\n<span class=\"hljs-meta\">@riverpod</span>\n<span class=\"hljs-built_in\">String</span> helloWorld(HelloWorldRef ref) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'Hello world'</span>;\n}\n\n<span class=\"hljs-comment\">// provider를 사용하기 위해서는 동기식 provider를 사용하는 방식과 동일한 방식으로 사용합니다.</span>\n<span class=\"hljs-keyword\">void</span> main() {\n  runApp(\n    <span class=\"hljs-comment\">// 앱의 모든 provider 상태는 ProviderScope 내에 저장됩니다.</span>\n    <span class=\"hljs-comment\">// provider를 읽기 위해서는 이를 반드시 포함해야 합니다.</span>\n    ProviderScope(\n      child: MyApp(),\n    ),\n  );\n}\n\n<span class=\"hljs-comment\">// Riverpod는 Stateless와 Stateful 위젯과 유사한 ConsumerWidget 및 ConsumerStatefulWidget 클래스 액세스를 제공합니다.</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyApp</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">ConsumerWidget</span> </span>{\n  <span class=\"hljs-comment\">// ConsumerWidget의 build 메서드가 WidgetRef 객체를 가져오는 방식에 유의하세요.</span>\n  <span class=\"hljs-comment\">// WidgetRef는 provider를 읽는 데 사용됩니다.</span>\n  <span class=\"hljs-meta\">@override</span>\n  Widget build(BuildContext context, WidgetRef ref) {\n    <span class=\"hljs-comment\">// provider를 읽는 두 가지 방법이 있습니다.</span>\n    <span class=\"hljs-comment\">// 값을 읽고 변경 사항을 감시하려면 ref.watch(...)를 사용하고,</span>\n    <span class=\"hljs-comment\">// 함수를 호출하려면 ref.read(...)를 사용합니다.</span>\n    <span class=\"hljs-keyword\">final</span> <span class=\"hljs-built_in\">String</span> val = ref.watch(helloWorldProvider);\n    <span class=\"hljs-keyword\">return</span> MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: <span class=\"hljs-keyword\">const</span> Text(<span class=\"hljs-string\">'Hello World Example'</span>)),\n        body: Center(\n          child: Text(val),\n        ),\n      ),\n    );\n  }\n}\n</code></pre>\n<ul>\n<li>제너레이터는 프로바이더가 포함된 파일을 생성합니다. 일반적으로 이 구문을 따르도록 하려면 <code>filename</code>.g.dart 형식을 따르길 원합니다. 그리고 import 문 이후에 이를 유지하는 것이 좋습니다. 이 부분은 파일이 서로 관련되어 있음을 Dart에게 알려주는 부분입니다.</li>\n<li>프로바이더를 만들기 위해서는 단순히 메서드를 만들고 이를 “@riverpod”으로 주석 처리하여 우리의 프로바이더를 생성합니다. \"HelloWorldRef\" 객체를 만든 방법에 주목해보세요. 아직 존재하지는 않지만 우리가 터미널에서 dart run build_runner watch 명령을 실행하면 생성될 것입니다. 따라서 해당 명령을 실행하고 <code>filename</code>.g.dart라는 파일을 생성하고 생성 중 발생한 오류를 해결하세요. 해당 파일은 다음과 같습니다:</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// GENERATED CODE - DO NOT MODIFY BY HAND</span>\n\npart <span class=\"hljs-keyword\">of</span> <span class=\"hljs-string\">'main.dart'</span>;\n<span class=\"hljs-comment\">// **************************************************************************</span>\n<span class=\"hljs-comment\">// RiverpodGenerator</span>\n<span class=\"hljs-comment\">// **************************************************************************</span>\n<span class=\"hljs-comment\">// ignore_for_file: avoid_private_typedef_functions, non_constant_identifier_names, subtype_of_sealed_class, invalid_use_of_internal_member, unused_element, constant_identifier_names, unnecessary_raw_strings, library_private_types_in_public_api</span>\n<span class=\"hljs-comment\">/// Dart SDK에서 복사함</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">_SystemHash</span> {\n  _SystemHash.<span class=\"hljs-title function_\">_</span>();\n  <span class=\"hljs-keyword\">static</span> int <span class=\"hljs-title function_\">combine</span>(<span class=\"hljs-params\">int hash, int value</span>) {\n    <span class=\"hljs-comment\">// ignore: parameter_assignments</span>\n    hash = <span class=\"hljs-number\">0x1fffffff</span> &#x26; (hash + value);\n    <span class=\"hljs-comment\">// ignore: parameter_assignments</span>\n    hash = <span class=\"hljs-number\">0x1fffffff</span> &#x26; (hash + ((<span class=\"hljs-number\">0x0007ffff</span> &#x26; hash) &#x3C;&#x3C; <span class=\"hljs-number\">10</span>));\n    <span class=\"hljs-keyword\">return</span> hash ^ (hash >> <span class=\"hljs-number\">6</span>);\n  }\n  <span class=\"hljs-keyword\">static</span> int <span class=\"hljs-title function_\">finish</span>(<span class=\"hljs-params\">int hash</span>) {\n    <span class=\"hljs-comment\">// ignore: parameter_assignments</span>\n    hash = <span class=\"hljs-number\">0x1fffffff</span> &#x26; (hash + ((<span class=\"hljs-number\">0x03ffffff</span> &#x26; hash) &#x3C;&#x3C; <span class=\"hljs-number\">3</span>));\n    <span class=\"hljs-comment\">// ignore: parameter_assignments</span>\n    hash = hash ^ (hash >> <span class=\"hljs-number\">11</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0x1fffffff</span> &#x26; (hash + ((<span class=\"hljs-number\">0x00003fff</span> &#x26; hash) &#x3C;&#x3C; <span class=\"hljs-number\">15</span>));\n  }\n}\n<span class=\"hljs-title class_\">String</span> $helloWorldHash() => r<span class=\"hljs-string\">'8bbe6cff2b7b1f4e1f7be3d1820da793259f7bfc'</span>;\n<span class=\"hljs-comment\">/// [helloWorld]도 참고하세요.</span>\nfinal helloWorldProvider = <span class=\"hljs-title class_\">AutoDisposeProvider</span>&#x3C;<span class=\"hljs-title class_\">String</span>>(\n  helloWorld,\n  <span class=\"hljs-attr\">name</span>: r<span class=\"hljs-string\">'helloWorldProvider'</span>,\n  <span class=\"hljs-attr\">debugGetCreateSourceHash</span>:\n      <span class=\"hljs-keyword\">const</span> bool.<span class=\"hljs-title function_\">fromEnvironment</span>(<span class=\"hljs-string\">'dart.vm.product'</span>) ? <span class=\"hljs-literal\">null</span> : $helloWorldHash,\n);\ntypedef <span class=\"hljs-title class_\">HelloWorldRef</span> = <span class=\"hljs-title class_\">AutoDisposeProviderRef</span>&#x3C;<span class=\"hljs-title class_\">String</span>>;\n</code></pre>\n<ul>\n<li>생성된 프로바이더가 AutoDisposeProvider인 것을 주목하세요. 이는 상태가 없는 데이터와 유사하기 때문입니다.</li>\n<li>파일을 저장한 후, dart run build_runner watch가 실행 중인 한 모든 생성된 프로바이더가 다시 생성됩니다.</li>\n</ul>\n<h1>위젯 트리 어디서든 프로바이더에 접근하기</h1>\n<p>이제 당신은 앱 내에서 제공 업체의 데이터를 어디서든 읽을 수 있는지 궁금해 할 수도 있습니다. 이를 제공 업체 소비하기라고하며, 이를 위해 ref.watch(…) 메서드를 호출하는 WidgetRef 개체를 사용해야합니다. 위젯의 특정 부분만 제공 업체에 액세스해야하는 경우 Consumer 클래스를 사용할 수 있습니다.</p>\n<p>다음은 Consumer 클래스를 사용한 예시입니다.</p>\n<pre><code class=\"hljs language-dart\"><span class=\"hljs-comment\">// main.dart</span>\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'package:flutter/material.dart'</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'package:flutter_riverpod/flutter_riverpod.dart'</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'package:riverpod_annotation/riverpod_annotation.dart'</span>;\n\n<span class=\"hljs-keyword\">part</span> <span class=\"hljs-string\">'main.g.dart'</span>;\n\n<span class=\"hljs-meta\">@riverpod</span>\n<span class=\"hljs-built_in\">String</span> helloWorld(HelloWorldRef ref) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'Hello world'</span>;\n}\n\n<span class=\"hljs-keyword\">void</span> main() {\n  runApp(\n    ProviderScope(\n      child: MyApp(),\n    ),\n  );\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyApp</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">StatelessWidget</span> </span>{\n  <span class=\"hljs-meta\">@override</span>\n  Widget build(BuildContext context, WidgetRef ref) {\n    <span class=\"hljs-keyword\">return</span> MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(title: <span class=\"hljs-keyword\">const</span> Text(<span class=\"hljs-string\">'Hello World Example'</span>)),\n        body: Center(\n          child: Consumer(\n            builder: (context, ref, child) {\n              <span class=\"hljs-keyword\">final</span> <span class=\"hljs-built_in\">String</span> val = ref.watch(helloWorldProvider);\n              <span class=\"hljs-comment\">// Consumer has a return type of Widget.</span>\n              <span class=\"hljs-comment\">// Almost like using a Builder widget, but Riverpodified :)</span>\n              <span class=\"hljs-keyword\">return</span> Text(val);\n            },\n        ),\n      ),\n    );\n  }\n}\n</code></pre>\n<h1>변수에 반응형 상태 추가하기</h1>\n<p>더 복잡한 제공자 예제를 살펴봅시다. 클래스를 사용하는 것과 같은 예제입니다. 이는 체크박스 부울 값이나 요소 목록과 같은 반응성 상태가 필요한 변수가 있는 경우 유용할 수 있습니다.</p>\n<p>다음 예제에서는 클래스를 사용하여 변수의 저장소로 사용하고 제공자로 변환하는 방법을 보여줍니다.</p>\n<pre><code class=\"hljs language-js\">@riverpod\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HelloWorld</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">_$HelloWorld</span> {\n  <span class=\"hljs-title class_\">String</span> <span class=\"hljs-title function_\">build</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"hello world\"</span>;\n  }\n\n  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">toCamelCase</span>(<span class=\"hljs-params\"></span>) {\n      <span class=\"hljs-comment\">// 변수 상태를 사용하여 제공자의 현재 상태에 액세스하는 방법에 주목해주세요.</span>\n      state = <span class=\"hljs-string\">'${state[0].toUpperCase()}${state.substring(1).toLowerCase()}'</span>;\n  }\n}\n\nref.<span class=\"hljs-title function_\">watch</span>(helloWorldProvider); <span class=\"hljs-comment\">// hello world</span>\nref.<span class=\"hljs-title function_\">watch</span>(helloWorldProvider.<span class=\"hljs-property\">notifier</span>).<span class=\"hljs-title function_\">toCamelCase</span>();\nref.<span class=\"hljs-title function_\">watch</span>(helloWorldProvider); <span class=\"hljs-comment\">// Hello World</span>\n</code></pre>\n<p>이 예제에서는 우리의 클래스가 _$<code>클래스명</code>을 확장하고 제공자로 변환되어야 한다는 것을 riverpod에게 알려주기 위해 위에 riverpod 주석이 달렸습니다. 참고: 클래스로 만든 모든 제공자는 build() 메서드가 필요합니다. 이곳이 제공자의 초기 상태를 구성하는 곳입니다.</p>\n<p>제공자를 사용하는 것은 이전에 언급한 예제들만큼 간단합니다: 단순히 ref.watch(<code>생성된 제공자 이름</code>)을 호출하면 앱이 변경 사항을 감시합니다. 그리고 클래스의 접근자 메서드를 사용하려면 ref.watch(<code>생성된 제공자 이름</code>.notifier).<code>메서드 이름</code>()을 호출해야 합니다. .notifier를 꼭 포함하도록 하세요.</p>\n<h1>제공자의 현재 값 변경하기</h1>\n<p>이제 제공자 내의 현재 값을 변경하려면 클래스 내에 생성자를 사용하고 약간 수정해야 합니다. 즐겨 사용하는 단어 목록을 살펴보겠습니다.</p>\n<pre><code class=\"hljs language-js\">@riverpod\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FavoriteWordsRepository</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">_$FavoriteWordsRepository</span> {\n  <span class=\"hljs-title class_\">FavoriteWordsRepository</span>(<span class=\"hljs-title class_\">List</span>&#x3C;<span class=\"hljs-title class_\">String</span>> favoriteWords) {\n    words = favoriteWords;\n  }\n\n  <span class=\"hljs-title class_\">List</span>&#x3C;<span class=\"hljs-title class_\">String</span>> words = [];\n\n  @override\n  <span class=\"hljs-title class_\">List</span>&#x3C;<span class=\"hljs-title class_\">String</span>> <span class=\"hljs-title function_\">build</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">return</span> words;\n  }\n}\n</code></pre>\n<p>main.g.dart 파일에서 FavoriteWordsRepository.new를 사용할 수 없다는 오류가 발생할 수 있습니다. 이 간단한 수정으로 해결할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\">final favoriteWordsRepositoryProvider =\n    <span class=\"hljs-title class_\">AutoDisposeAsyncNotifierProvider</span>&#x3C;<span class=\"hljs-title class_\">FavoriteWordsRepository</span>, <span class=\"hljs-title class_\">List</span>&#x3C;<span class=\"hljs-title class_\">String</span>>>(\n  <span class=\"hljs-function\">() =></span> <span class=\"hljs-title class_\">FavoriteWordsRepository</span>([]), <span class=\"hljs-comment\">// FavoriteWordsRepository.new --> () => FavoriteWordsRepository([])</span>\n</code></pre>\n<p>이것을 값으로 리스트를 초기화하는 것과 혼동하지 마세요. 이것은 단순히 시작점일 뿐이고 실제로 초기화된 리스트는 List<code>String</code> words = []; 입니다.</p>\n<p>그리고 위젯 코드 내에서 provider의 상태를 다음과 같이 업데이트할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\">ref.<span class=\"hljs-title function_\">watch</span>(favoriteWordsRepositoryProvider.<span class=\"hljs-property\">notifier</span>).<span class=\"hljs-property\">words</span> = [<span class=\"hljs-string\">'Cars'</span>, <span class=\"hljs-string\">'Dogs'</span>, <span class=\"hljs-string\">'Flutter'</span>];\n</code></pre>\n<h1>비동기 공급자 생성</h1>\n<p>지역 공급자 데이터 작업에 익숙해지면 futures를 다루는 방법도 알아봅시다! 아래 예시는 기본적인 future 공급자를 만드는 방법을 보여줍니다.</p>\n<pre><code class=\"hljs language-js\">@riverpod\n<span class=\"hljs-title class_\">Future</span>&#x3C;<span class=\"hljs-title class_\">String</span>> <span class=\"hljs-title function_\">helloWorldFuture</span>(<span class=\"hljs-title class_\">HelloWorldFutureRef</span> ref) <span class=\"hljs-keyword\">async</span> {\n  <span class=\"hljs-keyword\">try</span> {\n    <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title class_\">Future</span>.<span class=\"hljs-title function_\">delayed</span>(<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Duration</span>(<span class=\"hljs-attr\">seconds</span>: <span class=\"hljs-number\">3</span>));\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'Hello World'</span>;\n  } <span class=\"hljs-keyword\">catch</span> (e) {\n    <span class=\"hljs-comment\">// 이 함수는 오류를 발생시킬 수 없습니다.</span>\n    <span class=\"hljs-comment\">// futures에 대한 Try/Catch 블록은 좋은 실천법입니다 :)</span>\n    rethrow;\n  }\n}\n</code></pre>\n<p>우리의 함수는 다시 HelloWorldFutureRef를 가져와야 합니다. 이것은 단일 공급자에서 여러 제공자를 사용하는 데에 사용됩니다. 다음은 dio: ^4.0.6을 사용하여 예제 API에 HTTP 요청을하는 예제입니다:</p>\n<pre><code class=\"hljs language-dart\"><span class=\"hljs-comment\">// dio_provider.dart</span>\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'package:dio/dio.dart'</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'package:flutter_riverpod/flutter_riverpod.dart'</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'package:riverpod_annotation/riverpod_annotation.dart'</span>;\n<span class=\"hljs-keyword\">part</span> <span class=\"hljs-string\">'dio_provider.g.dart'</span>;\n\n<span class=\"hljs-meta\">@riverpod</span>\nDio dio(DioRef ref, {<span class=\"hljs-built_in\">Map</span>&#x3C;<span class=\"hljs-built_in\">String</span>, <span class=\"hljs-built_in\">dynamic</span>>? headers, <span class=\"hljs-built_in\">String?</span> subDomain}) {\n  <span class=\"hljs-keyword\">return</span> Dio(BaseOptions(baseUrl: <span class=\"hljs-string\">'https://api.example.com'</span>, headers: headers));\n}\n</code></pre>\n<p>그리고 우리의 공급자에서 액세스하는 방법은 다음과 같습니다:</p>\n<pre><code class=\"hljs language-dart\"><span class=\"hljs-comment\">// greeting_service.dart</span>\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'dio_provider.dart'</span>;\n<span class=\"hljs-meta\">@riverpod</span>\nFuture&#x3C;<span class=\"hljs-built_in\">String</span>> getGreeting(GetGreetingRef ref, {<span class=\"hljs-keyword\">required</span> <span class=\"hljs-built_in\">String</span> name}) <span class=\"hljs-keyword\">async</span> {\n  <span class=\"hljs-keyword\">try</span> {\n    <span class=\"hljs-keyword\">final</span> response = <span class=\"hljs-keyword\">await</span> ref.watch(dioProvider()).<span class=\"hljs-keyword\">get</span>(<span class=\"hljs-string\">'/greeting'</span>);\n    <span class=\"hljs-keyword\">final</span> result = response.data;\n    <span class=\"hljs-keyword\">final</span> greeting = result + <span class=\"hljs-string\">', '</span> + name;\n    <span class=\"hljs-keyword\">return</span> greeting; <span class=\"hljs-comment\">// Hello there, Carlton</span>\n  } <span class=\"hljs-keyword\">catch</span> (e) {\n    <span class=\"hljs-keyword\">rethrow</span>;\n  }\n}\n</code></pre>\n<p>다른 공급자를 사용해 공급자를 <code>.family</code>로 만들어요.</p>\n<h1>build 메서드에 인수 전달하기</h1>\n<p>Riverpod은 초기화할 때 build 메서드로 인수를 전달할 수 있게 해줘요. 이를 코드에서 어떻게 할 수 있는지 알아볼게요.</p>\n<pre><code class=\"hljs language-js\">@riverpod\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyRepository</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">_$MyRepository</span> {\n  @override\n  <span class=\"hljs-comment\">// 여기에 위치 인수를 추가하세요. 이름 지정도 가능해요.</span>\n  <span class=\"hljs-title class_\">Future</span>&#x3C;<span class=\"hljs-title class_\">String</span>> <span class=\"hljs-title function_\">build</span>(<span class=\"hljs-title class_\">String</span> id, {bool value}) <span class=\"hljs-keyword\">async</span> {\n    final <span class=\"hljs-title class_\">String</span> result = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">myFuture</span>(id, value);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">anotherFutureThatReturnsAString</span>(result);\n  }\n  <span class=\"hljs-comment\">// ...</span>\n}\n</code></pre>\n<h1>AsyncProvider를 사용하는 방법</h1>\n<p>AsyncProvider를 사용하는 방법은 로컬 공급자를 사용하는 방법과 다르며 데이터와 상호 작용하는 방식이 변경됩니다. 주의 깊게 살펴보세요, 이것은 매우 중요합니다!</p>\n<p>UI에서 공급자를 사용하려면 .when() 구문을 사용해야 합니다. 이 구문에는 3가지 다른 상태가 포함되어 있습니다: 데이터(완료), 로딩, 오류. ConnectionState를 확인하고 해당 위젯을 반환하는 것의 번거로움을 제거하기 때문에 FutureBuilders를 이것으로 교체할 수 있습니다. 아래는 완전한 앱의 예시를 살펴봅시다:</p>\n<p>초기 앱 만들기</p>\n<pre><code class=\"hljs language-dart\"><span class=\"hljs-comment\">// main.dart</span>\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'package:flutter/material.dart'</span>;\n\n<span class=\"hljs-keyword\">void</span> main() {\n  runApp(<span class=\"hljs-keyword\">const</span> MyApp());\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyApp</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">StatelessWidget</span> </span>{\n  <span class=\"hljs-keyword\">const</span> MyApp({Key? key});\n\n  <span class=\"hljs-meta\">@override</span>\n  Widget build(BuildContext context) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">const</span> ProviderScope(\n      child: MaterialApp(\n        home: MyHomePage(),\n      ),\n    );\n  }\n}\n</code></pre>\n<p>Creating foo class and provider</p>\n<pre><code class=\"hljs language-dart\"><span class=\"hljs-comment\">// foo.dart</span>\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'package:flutter_riverpod/flutter_riverpod.dart'</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'package:riverpod_annotation/riverpod_annotation.dart'</span>;\n\n<span class=\"hljs-keyword\">part</span> <span class=\"hljs-string\">'foo.g.dart'</span>;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Foo</span> </span>{\n  <span class=\"hljs-keyword\">final</span> <span class=\"hljs-built_in\">int</span> bar;\n  <span class=\"hljs-built_in\">int?</span> baz;\n\n  Foo(\n    <span class=\"hljs-keyword\">this</span>.bar, {\n    <span class=\"hljs-keyword\">this</span>.baz,\n  });\n}\n\n<span class=\"hljs-meta\">@riverpod</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FooController</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">_</span>$<span class=\"hljs-title\">FooController</span> </span>{\n  FooController(<span class=\"hljs-keyword\">this</span>.foo);\n  Foo foo;\n\n  <span class=\"hljs-meta\">@override</span>\n  FutureOr&#x3C;Foo> build() <span class=\"hljs-keyword\">async</span> {\n    foo = <span class=\"hljs-keyword\">await</span> getFoo();\n    <span class=\"hljs-keyword\">return</span> foo;\n  }\n\n  Future&#x3C;Foo> getFoo() <span class=\"hljs-keyword\">async</span> {\n    <span class=\"hljs-keyword\">await</span> Future.delayed(<span class=\"hljs-keyword\">const</span> <span class=\"hljs-built_in\">Duration</span>(seconds: <span class=\"hljs-number\">1</span>));\n    <span class=\"hljs-keyword\">return</span> Foo(<span class=\"hljs-number\">1</span>);\n  }\n}\n</code></pre>\n<p>Consuming foo provider</p>\n<pre><code class=\"hljs language-dart\"></code></pre>\n<pre><code class=\"hljs language-dart\"><span class=\"hljs-comment\">// home.dart</span>\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyHomePage</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">StatelessWidget</span> </span>{\n  <span class=\"hljs-keyword\">const</span> MyHomePage({key});\n\n  <span class=\"hljs-meta\">@override</span>\n  Widget build(BuildContext context) {\n    <span class=\"hljs-keyword\">return</span> Scaffold(\n      appBar: AppBar(),\n      body: Consumer(\n        builder: (context, ref, _) {\n          <span class=\"hljs-comment\">// Provider를 얻어와서 watch합니다</span>\n          <span class=\"hljs-keyword\">final</span> fooAsync = ref.watch(fooControllerProvider);\n          <span class=\"hljs-comment\">// .when을 사용하여 Future로부터 UI를 렌더링합니다</span>\n          <span class=\"hljs-keyword\">return</span> fooAsync.<span class=\"hljs-keyword\">when</span>(\n            data: (foo) => Text(<span class=\"hljs-string\">'bar: <span class=\"hljs-subst\">${foo.bar}</span>, baz: <span class=\"hljs-subst\">${foo.baz}</span>'</span>),\n            loading: () => <span class=\"hljs-keyword\">const</span> CircularProgressIndicator(),\n            error: (err, stack) => Text(err.toString()),\n          );\n        },\n      ),\n    );\n  }\n}\n</code></pre>\n<p>이 예시에서는 Consumer 위젯을 사용하여 ref에 액세스하므로 ref.watch(fooControllerProvider)를 호출하여 AsyncData 유형을 반환할 수 있습니다. 그런 다음 .when(…) 함수가 제공하는 속성을 사용하여 UI를 매우 깨끗하고 관리하기 쉬운 형식으로 구성할 수 있습니다.</p>\n<p>이 작업은 생성된 파일에서 provider의 초기값을 설정해야 합니다.</p>\n<pre><code class=\"hljs language-dart\"><span class=\"hljs-keyword\">final</span> fooControllerProvider = AutoDisposeAsyncNotifierProvider&#x3C;FooController, Foo>(\n  () => FooController(Foo(<span class=\"hljs-number\">1</span>)), <span class=\"hljs-comment\">// FooController.new --> FooController(Foo(1))</span>\n  name: <span class=\"hljs-string\">r'fooControllerProvider'</span>,\n  debugGetCreateSourceHash: <span class=\"hljs-keyword\">const</span> <span class=\"hljs-built_in\">bool</span>.fromEnvironment(<span class=\"hljs-string\">'dart.vm.product'</span>) ? <span class=\"hljs-keyword\">null</span> : $FooControllerHash,\n);\n</code></pre>\n<h1>AsyncProvider의 현재 상태를 개체/가공 가능한 데이터처럼 가져오는 방법</h1>\n<p>현재 방법은 API 데이터에 빠르게 액세스하는 데 유용하지만 문제가 발생합니다. 미래 Provider 내부의 데이터를 어떻게 가공 가능한 데이터처럼 액세스할 수 있을까요? API에서 사용자 데이터를 요청하고, 사용자 설정에서 사용자의 이름을 업데이트하고 싶다고 가정해 봅시다. 우리는 ref.watch(<code>YourFutureProvider</code>)가 User 클래스가 아닌 AsyncData 유형을 반환하기 때문에 이렇게 할 수 없습니다. 일부 데이터를 알고 싶을 때마다 GET 요청을 완료하고 싶지 않으며, 특히 첫 번째로로드되고 사용 가능한 경우입니다. 두 Provider를 만들어야할 것으로 생각할 수 있지만, 하나는 AsyncProvider이고, 하나는 NotifierProvider로 대화해야 한다면 그것은 비효율적입니다. 다행히도 이를 처리하는 방법이 있습니다.</p>\n<p>다음 코드는 AsyncProvider를 사용하고 로드된 데이터를 NotifierProvider처럼 사용하는 방법을 보여줍니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// home.dart</span>\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyHomePage</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">StatelessWidget</span> {\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">MyHomePage</span>({<span class=\"hljs-variable language_\">super</span>.<span class=\"hljs-property\">key</span>});\n\n  @override\n  <span class=\"hljs-title class_\">Widget</span> <span class=\"hljs-title function_\">build</span>(<span class=\"hljs-params\">BuildContext context</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Scaffold</span>(\n      <span class=\"hljs-attr\">appBar</span>: <span class=\"hljs-title class_\">AppBar</span>(),\n      <span class=\"hljs-attr\">body</span>: <span class=\"hljs-title class_\">Consumer</span>(\n        <span class=\"hljs-attr\">builder</span>: (context, ref, _) {\n          <span class=\"hljs-comment\">// Foo Provider를 가져와 상태를 설정합니다.</span>\n          <span class=\"hljs-comment\">// State Provider처럼 사용합니다.</span>\n          ref.<span class=\"hljs-title function_\">watch</span>(fooControllerProvider.<span class=\"hljs-property\">notifier</span>).<span class=\"hljs-property\">foo</span> = <span class=\"hljs-title class_\">Foo</span>(<span class=\"hljs-number\">3</span>);\n          <span class=\"hljs-comment\">// UI에서 Foo 사용 (.requireValue는 변경 사항을 청취할 수 있도록 사용됨)</span>\n          final foo = ref.<span class=\"hljs-title function_\">watch</span>(fooControllerProvider).<span class=\"hljs-property\">requireValue</span>;\n          <span class=\"hljs-comment\">// .when을 사용하여 미래에서 UI를 렌더링합니다.</span>\n          <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Text</span>(<span class=\"hljs-string\">'bar: ${foo.bar}, baz: ${foo.baz}'</span>);\n        },\n      ),\n    );\n  }\n}\n</code></pre>\n<h1>결론</h1>\n<p>Riverpod는 플러터에서 상태 관리의 가장 추천되는 방법으로 나타났으며 완전히 반응적인 상태 프레임워크로 발전했습니다.</p>\n<p>나중에 Provider와 같은 다른 패키지는 더 이상 유지되지 않을 수 있으므로 Riverpod를 배우는 것이 중요합니다 (물론 먼 훗날입니다). 또한 Riverpod는 새로운 제너레이터 덕분에 상태를 효과적으로 관리할 수 있는 유연성과 제어성을 제공하여 build_runner를 사용해 강력하고 메모리를 고려한 프로바이더를 쉽게 만들 수 있습니다.</p>\n<p>이 글을 만드는 과정에서 도움이 된 멋진 자료를 제공해 준 다음 분들께 큰 박수를 보냅니다. 🎉</p>\n<ul>\n<li>CodeWithAndrea</li>\n<li>Adnanjpg</li>\n<li>rrouselgit</li>\n</ul>\n<p>이 글이 도움이 되셨기를 바랍니다. 만약 도움이 되었다면, 더 많은 튜토리얼, 경험, 그리고 안내서가 포함된 다른 글도 자유롭게 읽어보세요!</p>\n<p>하나님을 신뢰합니다 🙏🏾</p>\n</body>\n</html>\n"},"__N_SSG":true}