{"pageProps":{"post":{"title":"Golang에서 오류 처리를 마스터하는 방법 최고의 실천 방법과 팁","description":"","date":"2024-06-27 18:32","slug":"2024-06-27-MasteringErrorHandlinginGolangBestPracticesandTips","content":"\n\n고랭(Golang)에서 에러를 우아하게 처리하는 방법을 배우고, 코드 신뢰성을 높이기 위한 에러 처리에 대한 종합 가이드를 제공합니다.\n\n![이미지](/assets/img/2024-06-27-MasteringErrorHandlinginGolangBestPracticesandTips_0.png)\n\nGo 언어에서는 일반적으로 에러를 표현하는 데 사용되는 인터페이스 타입인 error 타입이 정의됩니다.\n\n```js\ntype error interface {\n    Error() string\n}\n```\n\n<div class=\"content-ad\"></div>\n\n에러 인터페이스에는 Error() 메서드라는 하나의 메서드만 있습니다. 이 메서드는 에러를 설명하는 문자열을 반환합니다. 이는 Error() 메서드를 구현하는 모든 타입을 에러 타입으로 사용할 수 있다는 것을 의미합니다.\n\n일반적으로 Go 프로그램의 함수들은 에러가 발생했을 때 에러 타입의 값을 반환합니다. 이를 통해 호출자가 에러 정보를 처리하거나 기록할 수 있습니다.\n\n에러를 어떻게 생성할까요?\n\nGo 언어의 디자이너들은 Go 개발자들이 에러 값을 생성하는 두 가지 편리한 방법을 제공했습니다: errors.New와 fmt.Errorf.\n\n<div class=\"content-ad\"></div>\n\n- errors.New() 함수는 오직 오류 메시지 문자열만 포함하므로 오류 값을 생성하는 가장 간단한 방법입니다. 이 방법은 간단한 오류 값을 생성하는 데 적합합니다.\n- 반면에 fmt.Errorf() 함수는 fmt.Printf() 함수와 유사한 형식화된 오류 메시지를 구성할 수 있도록 합니다. 이 방법은 더 복잡한 오류 메시지를 구축해야 할 때 유용합니다.\n\n이 두 가지 방법을 사용하여 아래 코드와 같이 error 인터페이스를 만족하는 오류 값을 손쉽게 구성할 수 있습니다:\n\n```js\nerr := errors.New(\"hello error\")\nerrWithCtx = fmt.Errorf(\"index %i is out of bounds\", i)\n```\n\n이 두 가지 방법은 실제로 동일한 error 인터페이스를 구현하는 동일하지만 알려지지 않은 유형의 인스턴스를 반환합니다.\n\n<div class=\"content-ad\"></div>\n\n이 비공개 타입은 errors.errorString이며, 그 정의는 다음과 같습니다:\n\n```js\n// $GOROOT/src/errors/errors.go\ntype errorString struct {\n    s string\n}\n\nfunc (e *errorString) Error() string {\n    return e.s\n}\n```\n\n대부분의 경우에 이 두 가지 메서드를 사용하여 생성된 오류 값이 우리의 요구 사항을 충족할 것입니다.\n\n그러나 이러한 메서드가 오류 값을 생성하는 데 편리하긴 하지만, 오류 처리기에 제공하는 오류 컨텍스트는 문자열 형태로 제공된 정보에 제한된다는 점을 알아야 합니다. 이 정보는 Error 메서드에서 반환하는 정보입니다.\n\n<div class=\"content-ad\"></div>\n\n에러 유형을 사용자 정의하는 방법\n\n일부 상황에서는 에러 핸들러가 적절한 에러 처리 경로를 선택하는 데 도움이 되도록 에러 값에서 더 많은 정보를 추출해야 할 수도 있습니다.\n\n명확히 이 두 가지 메서드만으로는 그러한 경우에 충분하지 않습니다.\n\n이러한 상황에서는 이러한 요구 사항을 충족시키기 위해 에러 유형을 사용자 정의할 수 있습니다. 다음은 예시입니다:\n\n<div class=\"content-ad\"></div>\n\n```go\npackage main\n\nimport \"fmt\"\n\n// 사용자 정의 오류 유형\ntype MyError struct {\n  ErrorCode    int\n  ErrorMessage string\n}\n\n// `error` 인터페이스의 `Error` 메서드 구현\nfunc (e MyError) Error() string {\n  return fmt.Sprintf(\"Error %d: %s\", e.ErrorCode, e.ErrorMessage)\n}\n\nfunc someFunction() error {\n  // 커스텀 오류 값 생성\n  err := MyError{\n    ErrorCode:    404,\n    ErrorMessage: \"Not Found\",\n  }\n  return err\n}\n\nfunc main() {\n  err := someFunction()\n  fmt.Println(\"에러:\", err)\n}\n```\n\n또 다른 예시를 살펴보겠습니다. 표준 라이브러리의 net 패키지에 정의된 추가 컨텍스트를 가진 오류 유형입니다:\n\n```go\n// $GOROOT/src/net/net.go\ntype OpError struct {\n    Op string\n    Net string\n    Source Addr\n    Addr Addr\n    Err error\n}\n```\n\n이러한 유형의 오류 값이 제공하는 추가 컨텍스트 정보(예: Op, Net, Source 등)를 기반으로 에러 처리 경로를 결정할 수 있게끔 에러 핸들러가 결정을 내릴 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n위의 표준 라이브러리에서 다음 코드 예시를 살펴보겠습니다:\n\n```js\n// $GOROOT/src/net/http/server.go\nfunc isCommonNetReadError(err error) bool {\n    if err == io.EOF {\n        return true\n    }\n    if neterr, ok := err.(net.Error); ok && neterr.Timeout() {\n        return true\n    }\n    if oe, ok := err.(*net.OpError); ok && oe.Op == \"read\" {\n        return true\n    }\n    return false\n}\n```\n\n위 코드에서는 타입 단언(Type Assertion)을 활용하여 err 변수의 동적 타입이 *net.OpError 또는 net.Error인지를 결정합니다.\n\nerr의 동적 타입이 *net.OpError인 경우, 타입 단언은 이 동적 타입의 값(oe에 저장)을 반환하고, 코드는 그 후 해당 Op 필드가 read인지 여부를 확인하여 CommonNetRead 유형의 에러인지 결정할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n오류 유형의 장점.\n\n# 1. 오류를 처리하는 표준화된 방법을 제공합니다.\n\n서로 다른 개발자, 다른 프로젝트 및 심지어 표준 라이브러리에서 코드를 사용할 때 오류 유형을 오류 인터페이스 변수의 형태로 일관되게 표현한다면 코드 가독성을 향상시키는 것뿐만 아니라 통일된 오류 처리 전략의 수립을 용이하게 합니다.\n\n# 2. 오류는 모두 값입니다.\n\n<div class=\"content-ad\"></div>\n\n우리가 만드는 오류들은 실제로 값들입니다. 이는 오류 인터페이스 유형의 변수에 할당되었을 때에도 ==와 !=와 같은 논리적 비교를 수행할 수 있음을 의미합니다. 정수 값들과 마찬가지로요.\n\n오류를 검사하는 경험은 함수 호출자에게 동일합니다.\n\n오류가 인터페이스 유형이기 때문에, 그의 기본 제로 값은 nil입니다.\n\n그러므로, 일반적으로 함수에 의해 반환된 오류를 nil과 비교하여 함수가 성공했는지 여부 또는 오류가 발생했는지를 확인합니다.\n\n<div class=\"content-ad\"></div>\n\n만약 반환된 오류가 nil이라면, 성공적으로 함수가 실행된 것이고, 그렇지 않다면 오류가 발생했음을 나타냅니다.\n\n이 규칙을 따르면 오류 처리가 일관적이고 직관적으로 이루어집니다.\n\n예를 들어, 다음과 같은 오류 확인 코드를 자주 볼 수 있습니다:\n\n```js\nfunc someFunction() error {\n    return errors.New(\"Errors\")\n}\n\nfunc main() {\n    err := someFunction()\n\n    if err != nil {\n        fmt.Println(\"실패, 오류:\", err)\n    } else {\n        fmt.Println(\"성공\")\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n# 3. 쉽게 확장할 수 있습니다.\n\n에러들은 에러 인터페이스 변수로 일관되게 표시됩니다. 사용자 정의 에러 타입을 만들어 우리의 에러 컨텍스트를 쉽게 확장할 수 있으며, 이는 Go 표준 라이브러리의 OpError 타입과 비슷합니다.\n\n에러 인터페이스는 에러 값을 제공하는 제공자와 에러 처리를 담당하는 코드 간의 계약 역할을 합니다.\n\n에러 인터페이스를 구현하는 사람은 에러 처리 코드에서 사용할 에러 컨텍스트를 제공하는 것이 책임입니다.\n\n<div class=\"content-ad\"></div>\n\n이는 특정 오류 컨텍스트를 오류 인터페이스 유형과 분리하여 Go의 구성 가능성 및 직교성을 따르는 설계 철학과 일치합니다.\n\nGo 오류 처리의 일반적인 관행.\n\n## 1. 투명한 오류 처리 전략.\n\n간단히 말해서, Go 언어에서의 오류 처리는 함수에 의해 반환된 오류 유형 변수에 의해 전달되는 오류 값 정보를 기반으로 의사 결정을 내리고 후속 코드 실행 경로를 선택하는 과정입니다.\n\n<div class=\"content-ad\"></div>\n\n이 방식을 통해 가장 간단한 오류 전략은 반환된 오류 값이 전달하는 구체적인 컨텍스트 정보를 완전히 무시하는 것입니다.\n\n대신, 오류가 발생할 때마다 하나의 오류 처리 실행 경로로 이어집니다. 예를 들어, 다음 코드를 참고해보세요:\n\n```js\nerr := doSomething()\nif err != nil {\n    ... ...\n    return err\n}\n```\n\n이것은 Go 언어에서 가장 흔한 오류 처리 전략으로, 오류 처리 시나리오의 80% 이상을 차지합니다. 이 전략에서는 오류 핸들러가 오류 값의 컨텍스트에 신경을 쓰지 않기 때문에, 오류 생성자 (예: 예시의 doSomething 함수)는 Go 표준 라이브러리에서 제공하는 두 가지 기본 오류 값 생성 방법을 직접 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nfunc doSomething(...) error {\n    ... ...\n    return errors.New(\"일부 오류가 발생했습니다\")\n}\n```\n\n이러한 방식으로 생성된 오류 값은 오류 처리기에게 투명한 컨텍스트 정보를 나타냅니다.\n\n오류 처리기가 오류 컨텍스트에 대해 인식할 필요가 없는 상황에서는 투명한 오류 처리 전략이 오류 처리기와 오류 값 생성자 간의 결합을 최소화합니다.\n\n오류 컨텍스트가 오류 처리에 무관한 경우, 이 접근 방식은 오류 처리와 오류 값 생성 사이의 상호 의존성을 줄이는 데 효과적입니다.\n\n\n<div class=\"content-ad\"></div>\n\n# 2. Sentinel 오류 처리 전략.\n\n오류 핸들러가 투명한 오류 값에만 의존하여 오류 처리 결정을 내릴 수없는 경우, 반환된 오류 값을 검사하려고 시도할 수 있습니다. 아래 코드와 같이 이를 통해 발생하는 안티패턴이 발생할 수 있습니다:\n\n```js\ndata, err := b.Peek(1)\nif err != nil {\n    switch err.Error() {\n    case \"bufio: negative count\":\n        // ... ...\n        return\n    case \"bufio: buffer full\":\n        // ... ...\n        return\n    case \"bufio: invalid use of UnreadByte\":\n        // ... ...\n        return\n    default:\n        // ... ...\n        return\n    }\n}\n```\n\n간단히 말해서, 이 안티패턴은 오류 핸들러가 오류 처리 결정을 내릴 때 \"투명한 오류 값\"이 제공하는 단일 컨텍스트 정보에 완전히 의존하는 경우를 나타냅니다.\n\n<div class=\"content-ad\"></div>\n\n하지만 이 \"안티-패턴\"은 상당한 암시적 결합을 야기합니다.\n\n즉, 오류 값 생성자에 의한 오류 설명 문자열의 미세한 변경조차도 오류 처리 동작에 변화를 일으킬 수 있습니다.\n\n또한, 문자열 비교를 통해 오류 값들을 조사하는 이 방식은 성능적으로 효율적이지 않습니다.\n\n그렇다면 해결책은 무엇일까요? Go 표준 라이브러리는 내보낸 \"특정값(sentinel)\" 오류 값의 정의를 통해 오류 핸들러들이 오류 값을 조사하고 오류 처리 결정을 내리는 데 도움을 주는 방식을 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n예를 들어, bufio 패키지에서 정의된 \"sentinel errors\"는 다음과 같습니다:\n\n```js\n// $GOROOT/src/bufio/bufio.go\nvar (\n    ErrInvalidUnreadByte = errors.New(\"bufio: invalid use of UnreadByte\")\n    ErrInvalidUnreadRune = errors.New(\"bufio: invalid use of UnreadRune\")\n    ErrBufferFull        = errors.New(\"bufio: buffer full\")\n    ErrNegativeCount     = errors.New(\"bufio: negative count\")\n)\n```\n\n다음 코드 조각은 이전에 언급된 sentinel errors를 활용하여 에러 처리 분기에서 결정을 내리는 예시입니다:\n\n```js\ndata, err := b.Peek(1)\nif err != nil {\n    switch err {\n    case bufio.ErrNegativeCount:\n        // ... ...\n        return\n    case bufio.ErrBufferFull:\n        // ... ...\n        return\n    case bufio.ErrInvalidUnreadByte:\n        // ... ...\n        return\n    default:\n        // ... ...\n        return\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n그러나 API 개발자의 경우, \"sentinel\" 오류 값 노출은 이러한 오류 값과 패키지의 공개 함수가 API의 일부가 되는 것을 의미합니다.\n\n한 번 릴리스되면, 개발자는 효과적으로 유지 관리해야 합니다. 또한, \"sentinel\" 오류 값은 이를 사용하는 오류 처리기에 종속성을 만듭니다.\n\nGo 1.13부터 표준 라이브러리 오류 패키지에서 Is 함수가 도입되어 오류 처리기가 오류 값으로 검사할 수 있습니다.\n\nIs 함수는 다음 코드에서 보여지는 것처럼 오류 변수를 \"sentinel\" 오류 값과 비교하는 것과 유사합니다:\n\n<div class=\"content-ad\"></div>\n\n```go\nif errors.Is(err, ErrOutOfBounds) {\n    // 뭔가를 수행\n}\n```\n\n차이점은 에러 변수가 래핑된 에러를 포함하는 경우, errors.Is 메서드는 래핑된 에러 내에서 에러 체인을 탐색하여 일치하는 에러를 찾을 때까지 모든 래핑된 에러와 비교합니다.\n\n다음은 Is 함수를 사용하는 예시입니다:\n\n```go\nvar ErrSentinel = errors.New(\"기본 신호 에러\")\n\nfunc main() {\n  err1 := fmt.Errorf(\"sentinel을 래핑: %w\", ErrSentinel)\n  err2 := fmt.Errorf(\"err1을 래핑: %w\", err1)\n  println(err2 == ErrSentinel) // false\n  if errors.Is(err2, ErrSentinel) {\n    println(\"err2는 ErrSentinel입니다.\")\n    return\n  }\n\n  println(\"err2는 ErrSentinel이 아닙니다.\")\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 예제에서는 fmt.Errorf 함수와 %w 동사를 사용하여 랩핑된 오류 변수 err1과 err2를 생성합니다.\n\nerr1은 \"sentinel\" 오류 값 ErrSentinel을 랩핑하고, err2는 err1을 랩핑하여 오류 체인을 생성합니다. 오류 체인의 맨 위에는 err2가 있고, 맨 아래에는 ErrSentinel이 있습니다.\n\n그런 다음 값 비교와 errors.Is 함수를 모두 사용하여 err2와 ErrSentinel 간의 관계를 결정합니다.\n\n코드를 실행할 때 다음과 같은 결과를 관찰할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nfalse\nerr2 is ErrSentinel\n```\n\n보시다시피 동등 연산자를 사용하여 err2와 ErrSentinel을 비교하면 서로 다릅니다.\n\n그러나 errors.Is 함수는 err2 안의 오류 체인을 탐색하여 가장 깊은 수준에서 랩핑된 \"sentinel\" 오류 값 ErrSentinel을 찾습니다.\n\nGo 1.13 이상 버전을 사용하는 경우, 특정 \"sentinel\" 오류 값으로 랩핑된 예상 오류 값인지 여부를 확인하기 위해 errors.Is 메서드를 사용하는 것이 좋습니다.\n\n<div class=\"content-ad\"></div>\n\n이 접근 방식은 특히 오류 래핑과 체인이 관련된 시나리오에서 더 견고하고 유연한 오류 처리를 제공합니다.\n\n## 3. 오류 값 유형 검사 전략\n\n이전에 살펴본 대로, Go 표준 라이브러리에서 제공하는 오류 값 구성 방법을 사용하여 구성된 \"sentinel\" 오류 값은 목표 값을 비교하는 기능 이상의 추가 오류 컨텍스트 정보를 제공하지 않습니다.\n\n오류 처리기가 오류 값에서 더 많은 \"오류 컨텍스트\" 정보를 필요로 하는 경우, 이전에 논의된 전략 및 오류 값 구성 방법이 충분하지 않을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이런 경우에는 추가 “에러 컨텍스트” 정보를 제공하기 위해 사용자 정의 에러 유형을 사용하여 에러 값을 구성해야 합니다.\n\n모든 에러 값이 에러 인터페이스 변수를 통해 균일하게 표시되기 때문에 기저 에러 유형이 전달하는 에러 컨텍스트 정보를 얻으려면 Go의 타입 어설션 또는 타입 스위치 메커니즘을 사용해야 합니다.\n\n에러 값을 검사하는 이 에러 처리 접근 방식은 “에러 값 타입 검사 전략”으로 참조할 수 있습니다.\n\n우리의 이해를 깊이 있게 하기 위해 표준 라이브러리의 예제를 살펴보겠습니다. json 패키지에서 UnmarshalTypeError라는 사용자 정의 에러 유형이 정의되어 있습니다:\n\n<div class=\"content-ad\"></div>\n\n에러 핸들러는 오류 값 유형 검사 전략을 사용하여 더 많은 오류 컨텍스트 정보를 얻을 수 있습니다. 아래는 이 전략을 활용하는 json 패키지의 메서드 구현 예시입니다:\n\n```js\r\n// $GOROOT/src/encoding/json/decode.go\nfunc (d *decodeState) addErrorContext(err error) error {\n    if d.errorContext.Struct != nil || len(d.errorContext.FieldStack) > 0 {\n        switch err := err.(type) {\n        case *UnmarshalTypeError:\n            err.Struct = d.errorContext.Struct.Name()\n            err.Field = strings.Join(d.errorContext.FieldStack, \".\")\n            return err\n        }\n    }\n    return err\n}\r\n```\n\n이 코드에서는 유형 스위치 문을 사용하여 err 변수가 나타내는 동적 유형 및 값을 결정하고, 일치하는 경우 분기에서 처리하기 위해 오류 컨텍스트 정보가 활용됩니다.\n\n<div class=\"content-ad\"></div>\n\n일반적으로 사용자 정의된 내보낸 오류 유형은 XXXError 형식으로 명명됩니다.\n\n\"sentinel\" 오류 처리 전략과 유사하게, 오류 값 유형 검사 전략은 사용자 정의 오류 유형을 오류 핸들러에 노출시켜, 해당 유형들이 API의 일부가 되도록 하며, 패키지의 공개 함수와 함께 사용될 수 있도록 합니다.\n\n배포된 후에는 개발자가 이러한 사용자 정의 오류 유형을 유지 관리해야 합니다. 게다가, 이러한 유형을 검사하고 사용하는 오류 핸들러에 대한 의존성을 만듭니다.\n\nGo 1.13부터 표준 라이브러리 errors 패키지는 오류 핸들러가 오류 값들을 검사할 수 있는 As 함수를 제공합니다.\n\n<div class=\"content-ad\"></div>\n\nAs 함수는 특정 사용자 정의 오류 유형인지를 결정하기 위해 타입 단언을 사용하는 것과 유사합니다. 아래 코드에서와 같이 err 변수가 특정 사용자 정의 오류 유형인지 확인합니다.\n\n```js\nvar customErr *CustomError\nif errors.As(err, &customErr) {\n    // Handle the error as a CustomError\n}\n```\n\nAs 함수의 차이점은 오류 변수에 래핑된 오류가 포함되어 있는 경우, errors.As 함수가 래핑된 오류 내의 오류 체인을 횡단하며, 체인 내의 모든 래핑된 오류와 일치하는 오류 유형을 찾을 때까지 비교한다는 것입니다. 이는 errors.Is의 동작과 유사합니다.\n\nAs 함수 사용 예시가 여기 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\ntype MyError struct {\n    e string\n}\n\nfunc (e *MyError) Error() string {\n    return e.e\n}\n\nfunc main() {\n    var err = &MyError{\"MyError error demo\"}\n    err1 := fmt.Errorf(\"wrap err: %w\", err)\n    err2 := fmt.Errorf(\"wrap err1: %w\", err1)\n    var e *MyError\n    if errors.As(err2, &e) {\n        println(\"MyError is on the chain of err2\")\n        println(e == err)                  \n        return                             \n    }                                      \n    println(\"MyError is not on the chain of err2\")\n} \n```\n\n결과.\n\n```js\nMyError is on the chain of err2\ntrue\n```\n\n마침내 출력된 결과처럼, errors.As 함수가 err2 내의 오류 체인을 성공적으로 탐지하여 가장 깊은 오류를 찾아내고, err2를 *MyError 유형과 일치시킵니다.\n\n<div class=\"content-ad\"></div>\n\n성공적인 일치가 발생하면, errors.As는 일치한 오류 값을 As 함수의 두 번째 매개변수에 저장합니다. 따라서 println(e == err)을 실행하면 true가 반환됩니다.\n\nGo 1.13 이상 버전을 사용 중이라면, 특정 사용자 정의 오류 유형의 인스턴스인지를 확인하기 위해 errors.As 메서드를 사용하는 것이 좋습니다.\n\n이 접근 방식은 사용자 정의 오류를 처리하는 더 유연하고 효율적인 방법을 제공하며, 특히 래핑된 오류와 함께 작업할 때 유용합니다.\n\n# 4. 오류 행동 특성 검사 전략.\n\n<div class=\"content-ad\"></div>\n\n이전에 우리가 논의한 세 가지 전략 중에서는 첫 번째 전략인 \"투명한 오류 처리 전략\"만이 오류 생성자와 오류 처리자 간의 결합을 효과적으로 줄입니다.\n\n두 번째와 세 번째 전략은 현실 세계의 코딩에서 실용적이지만, 여전히 오류 생성자와 오류 처리자 간의 결합을 어느 정도 도입합니다.\n\n그래서, \"투명한 오류 처리 전략\"을 제외하고는 오류 처리자와 오류 값 생성자 간의 결합을 줄일 다른 방법이 있을까요?\n\nGo 표준 라이브러리에서는 패키지 내에서 오류 유형을 분류하고 일반적인 오류 동작 특성을 추출하여 이러한 오류 동작 특성을 공개 인터페이스 유형으로 배치하는 다른 오류 처리 접근 방식을 찾을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 접근법은 \"오류 동작 특성 검사 전략\"으로 알려져 있습니다.\n\n예를 들어, 표준 라이브러리의 net 패키지는 모든 패키지 내의 일반적인 오류 동작 특성을 추상화하고 net.Error 인터페이스에 넣습니다. 다음 코드에서 확인할 수 있습니다:\n\n```js\n// $GOROOT/src/net/net.go\ntype Error interface {\n    error\n    Timeout() bool  \n    Temporary() bool\n}\n```\n\nnet.Error 인터페이스에는 오류 동작 특성을 확인하는 두 가지 메서드가 포함되어 있습니다: Timeout은 시간 초과 오류인지 확인하고 Temporary는 임시 오류인지 확인합니다.\n\n<div class=\"content-ad\"></div>\n\n에러 핸들러는 특정 에러의 동작 특성을 검사하고 이 정보를 기반으로 후속 에러 처리 분기에 대한 결정을 내리기 위해이 공개 인터페이스에 의존해야합니다.\n\n네트워크 패키지에서 가져온 다른 예제를 통해 에러 동작 특성 검사 전략을 사용하여 에러 처리를 더 향상시켜보겠습니다.\n\n```js\n// $GOROOT/src/net/http/server.go\nfunc (srv *Server) Serve(l net.Listener) error {\n    ... ...\n    for {\n        rw, e := l.Accept()\n        if e != nil {\n            select {\n            case <-srv.getDoneChan():\n                return ErrServerClosed\n            default:\n            }\n            if ne, ok := e.(net.Error); ok && ne.Temporary() {\n                ... ...\n                time.Sleep(tempDelay)\n                continue\n            }\n            return e\n        }\n        ...\n    }\n    ... ...\n}\n```\n\n위의 코드 스니펫에서 Accept 메서드는 실제로 net 패키지 내의 사용자 지정 에러 유형 인 *OpError 유형의 에러를 반환합니다. OpError는 일반 에러 특성 인터페이스인 net.Error를 구현합니다. 아래 코드에서 확인할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n// $GOROOT/src/net/net.go\ntype OpError struct {\n    ... ...\n    // Err is the error that occurred during the operation.\n    Err error\n}\n\ntype temporary interface {\n    Temporary() bool\n}\n\nfunc (e *OpError) Temporary() bool {\n  if ne, ok := e.Err.(*os.SyscallError); ok {\n      t, ok := ne.Err.(temporary)\n      return ok && t.Temporary()\n  }\n  t, ok := e.Err.(temporary)\n  return ok && t.Temporary()\n}\n```\n\n실제로 OpError 인스턴스는 오류 처리기에 의해 검사될 수 있으며 네트.Error 인터페이스에서 제공되는 메서드를 사용하여, 해당 동작이 Temporary나 Timeout과 같은 특성과 일치하는지 여부를 결정할 수 있습니다.\n\n이를 통해 오류 처리기는 네트워크 관련 작업의 맥락에서 해당 오류의 특정 동작에 기반하여 신중한 결정을 내릴 수 있게 됩니다.\n\n요약.\n\n<div class=\"content-ad\"></div>\n\nGo 언어에서 통합된 오류 유형은 오류 인터페이스이며, 오류 값이 할당될 수 있는 빠르게 구성되는 오류 값 구성 함수인 errors.New, fmt.Errorf 등을 포함하여 다양한 함수가 제공됩니다.\n\n또한 통합된 오류 유형을 오류 유형으로 사용하는 장점에 대해 논의했습니다.\n\n이 개념을 깊이 있게 이해하는 것이 중요합니다.\n\n- 투명한 오류 처리 전략: 오류 유형을 통합하고 추가 오류 컨텍스트를 제공하지 않음으로써 오류 처리를 간단하게 만들어 대부분의 경우에 적합합니다.\n- 징표 오류 처리 전략: 상징적인 오류 값 세트를 정의함으로써 오류 처리기가 값 비교를 통해 오류 처리 경로를 선택할 수 있게 합니다.\n- 오류 값 유형 검사 전략: 오류 유형을 사용자 정의하고 더 많은 오류 컨텍스트를 제공함으로써 추가 오류 컨텍스트가 필요하고 오류 유형을 검사하기 위해 타입 단언 또는 타입 스위치를 사용하는 시나리오에 적합합니다.\n- 오류 동작 특성 검사 전략: 공개 인터페이스를 통해 오류 동작 특성을 정의함으로써 오류 처리기가 특정 유형이 아닌 오류 특성을 검사할 수 있게 하며, 오류 동작 특성이 중요한 시나리오에 적합합니다.\n\n<div class=\"content-ad\"></div>\n\n각 전략마다 장점과 사용 사례가 있습니다. 적절한 전략을 선택하는 것은 유지 보수성, 결합도, 코드 복잡성 및 오류 컨텍스트 요구사항과 같은 프로그래밍에서의 특정 요구사항과 고려사항에 따라 달라집니다.\n\n이러한 전략을 이해함으로써 오류를 더 잘 다루고 관리할 수 있으며, 코드 신뢰성과 유지 관리성을 향상시킬 수 있습니다.\n\n이야기가 마음에 드시고 제 지원을 원하신다면 클랩(clap) 눌러주세요.\n\n여러분의 지원은 제게 매우 중요합니다. 감사합니다.","ogImage":{"url":"/assets/img/2024-06-27-MasteringErrorHandlinginGolangBestPracticesandTips_0.png"},"coverImage":"/assets/img/2024-06-27-MasteringErrorHandlinginGolangBestPracticesandTips_0.png","tag":["Tech"],"readingTime":15},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>고랭(Golang)에서 에러를 우아하게 처리하는 방법을 배우고, 코드 신뢰성을 높이기 위한 에러 처리에 대한 종합 가이드를 제공합니다.</p>\n<p><img src=\"/assets/img/2024-06-27-MasteringErrorHandlinginGolangBestPracticesandTips_0.png\" alt=\"이미지\"></p>\n<p>Go 언어에서는 일반적으로 에러를 표현하는 데 사용되는 인터페이스 타입인 error 타입이 정의됩니다.</p>\n<pre><code class=\"hljs language-js\">type error interface {\n    <span class=\"hljs-title class_\">Error</span>() string\n}\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>에러 인터페이스에는 Error() 메서드라는 하나의 메서드만 있습니다. 이 메서드는 에러를 설명하는 문자열을 반환합니다. 이는 Error() 메서드를 구현하는 모든 타입을 에러 타입으로 사용할 수 있다는 것을 의미합니다.</p>\n<p>일반적으로 Go 프로그램의 함수들은 에러가 발생했을 때 에러 타입의 값을 반환합니다. 이를 통해 호출자가 에러 정보를 처리하거나 기록할 수 있습니다.</p>\n<p>에러를 어떻게 생성할까요?</p>\n<p>Go 언어의 디자이너들은 Go 개발자들이 에러 값을 생성하는 두 가지 편리한 방법을 제공했습니다: errors.New와 fmt.Errorf.</p>\n<div class=\"content-ad\"></div>\n<ul>\n<li>errors.New() 함수는 오직 오류 메시지 문자열만 포함하므로 오류 값을 생성하는 가장 간단한 방법입니다. 이 방법은 간단한 오류 값을 생성하는 데 적합합니다.</li>\n<li>반면에 fmt.Errorf() 함수는 fmt.Printf() 함수와 유사한 형식화된 오류 메시지를 구성할 수 있도록 합니다. 이 방법은 더 복잡한 오류 메시지를 구축해야 할 때 유용합니다.</li>\n</ul>\n<p>이 두 가지 방법을 사용하여 아래 코드와 같이 error 인터페이스를 만족하는 오류 값을 손쉽게 구성할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\">err := errors.<span class=\"hljs-title class_\">New</span>(<span class=\"hljs-string\">\"hello error\"</span>)\nerrWithCtx = fmt.<span class=\"hljs-title class_\">Errorf</span>(<span class=\"hljs-string\">\"index %i is out of bounds\"</span>, i)\n</code></pre>\n<p>이 두 가지 방법은 실제로 동일한 error 인터페이스를 구현하는 동일하지만 알려지지 않은 유형의 인스턴스를 반환합니다.</p>\n<div class=\"content-ad\"></div>\n<p>이 비공개 타입은 errors.errorString이며, 그 정의는 다음과 같습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// $GOROOT/src/errors/errors.go</span>\ntype errorString struct {\n    s string\n}\n\nfunc (e *errorString) <span class=\"hljs-title class_\">Error</span>() string {\n    <span class=\"hljs-keyword\">return</span> e.<span class=\"hljs-property\">s</span>\n}\n</code></pre>\n<p>대부분의 경우에 이 두 가지 메서드를 사용하여 생성된 오류 값이 우리의 요구 사항을 충족할 것입니다.</p>\n<p>그러나 이러한 메서드가 오류 값을 생성하는 데 편리하긴 하지만, 오류 처리기에 제공하는 오류 컨텍스트는 문자열 형태로 제공된 정보에 제한된다는 점을 알아야 합니다. 이 정보는 Error 메서드에서 반환하는 정보입니다.</p>\n<div class=\"content-ad\"></div>\n<p>에러 유형을 사용자 정의하는 방법</p>\n<p>일부 상황에서는 에러 핸들러가 적절한 에러 처리 경로를 선택하는 데 도움이 되도록 에러 값에서 더 많은 정보를 추출해야 할 수도 있습니다.</p>\n<p>명확히 이 두 가지 메서드만으로는 그러한 경우에 충분하지 않습니다.</p>\n<p>이러한 상황에서는 이러한 요구 사항을 충족시키기 위해 에러 유형을 사용자 정의할 수 있습니다. 다음은 예시입니다:</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">package</span> main\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">\"fmt\"</span>\n\n<span class=\"hljs-comment\">// 사용자 정의 오류 유형</span>\n<span class=\"hljs-keyword\">type</span> MyError <span class=\"hljs-keyword\">struct</span> {\n  ErrorCode    <span class=\"hljs-type\">int</span>\n  ErrorMessage <span class=\"hljs-type\">string</span>\n}\n\n<span class=\"hljs-comment\">// `error` 인터페이스의 `Error` 메서드 구현</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(e MyError)</span></span> Error() <span class=\"hljs-type\">string</span> {\n  <span class=\"hljs-keyword\">return</span> fmt.Sprintf(<span class=\"hljs-string\">\"Error %d: %s\"</span>, e.ErrorCode, e.ErrorMessage)\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">someFunction</span><span class=\"hljs-params\">()</span></span> <span class=\"hljs-type\">error</span> {\n  <span class=\"hljs-comment\">// 커스텀 오류 값 생성</span>\n  err := MyError{\n    ErrorCode:    <span class=\"hljs-number\">404</span>,\n    ErrorMessage: <span class=\"hljs-string\">\"Not Found\"</span>,\n  }\n  <span class=\"hljs-keyword\">return</span> err\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n  err := someFunction()\n  fmt.Println(<span class=\"hljs-string\">\"에러:\"</span>, err)\n}\n</code></pre>\n<p>또 다른 예시를 살펴보겠습니다. 표준 라이브러리의 net 패키지에 정의된 추가 컨텍스트를 가진 오류 유형입니다:</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-comment\">// $GOROOT/src/net/net.go</span>\n<span class=\"hljs-keyword\">type</span> OpError <span class=\"hljs-keyword\">struct</span> {\n    Op <span class=\"hljs-type\">string</span>\n    Net <span class=\"hljs-type\">string</span>\n    Source Addr\n    Addr Addr\n    Err <span class=\"hljs-type\">error</span>\n}\n</code></pre>\n<p>이러한 유형의 오류 값이 제공하는 추가 컨텍스트 정보(예: Op, Net, Source 등)를 기반으로 에러 처리 경로를 결정할 수 있게끔 에러 핸들러가 결정을 내릴 수 있습니다.</p>\n<div class=\"content-ad\"></div>\n<p>위의 표준 라이브러리에서 다음 코드 예시를 살펴보겠습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// $GOROOT/src/net/http/server.go</span>\nfunc <span class=\"hljs-title function_\">isCommonNetReadError</span>(err error) bool {\n    <span class=\"hljs-keyword\">if</span> err == io.<span class=\"hljs-property\">EOF</span> {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n    }\n    <span class=\"hljs-keyword\">if</span> neterr, ok := err.(net.<span class=\"hljs-property\">Error</span>); ok &#x26;&#x26; neterr.<span class=\"hljs-title class_\">Timeout</span>() {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n    }\n    <span class=\"hljs-keyword\">if</span> oe, ok := err.(*net.<span class=\"hljs-property\">OpError</span>); ok &#x26;&#x26; oe.<span class=\"hljs-property\">Op</span> == <span class=\"hljs-string\">\"read\"</span> {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n}\n</code></pre>\n<p>위 코드에서는 타입 단언(Type Assertion)을 활용하여 err 변수의 동적 타입이 *net.OpError 또는 net.Error인지를 결정합니다.</p>\n<p>err의 동적 타입이 *net.OpError인 경우, 타입 단언은 이 동적 타입의 값(oe에 저장)을 반환하고, 코드는 그 후 해당 Op 필드가 read인지 여부를 확인하여 CommonNetRead 유형의 에러인지 결정할 수 있습니다.</p>\n<div class=\"content-ad\"></div>\n<p>오류 유형의 장점.</p>\n<h1>1. 오류를 처리하는 표준화된 방법을 제공합니다.</h1>\n<p>서로 다른 개발자, 다른 프로젝트 및 심지어 표준 라이브러리에서 코드를 사용할 때 오류 유형을 오류 인터페이스 변수의 형태로 일관되게 표현한다면 코드 가독성을 향상시키는 것뿐만 아니라 통일된 오류 처리 전략의 수립을 용이하게 합니다.</p>\n<h1>2. 오류는 모두 값입니다.</h1>\n<div class=\"content-ad\"></div>\n<p>우리가 만드는 오류들은 실제로 값들입니다. 이는 오류 인터페이스 유형의 변수에 할당되었을 때에도 ==와 !=와 같은 논리적 비교를 수행할 수 있음을 의미합니다. 정수 값들과 마찬가지로요.</p>\n<p>오류를 검사하는 경험은 함수 호출자에게 동일합니다.</p>\n<p>오류가 인터페이스 유형이기 때문에, 그의 기본 제로 값은 nil입니다.</p>\n<p>그러므로, 일반적으로 함수에 의해 반환된 오류를 nil과 비교하여 함수가 성공했는지 여부 또는 오류가 발생했는지를 확인합니다.</p>\n<div class=\"content-ad\"></div>\n<p>만약 반환된 오류가 nil이라면, 성공적으로 함수가 실행된 것이고, 그렇지 않다면 오류가 발생했음을 나타냅니다.</p>\n<p>이 규칙을 따르면 오류 처리가 일관적이고 직관적으로 이루어집니다.</p>\n<p>예를 들어, 다음과 같은 오류 확인 코드를 자주 볼 수 있습니다:</p>\n<pre><code class=\"hljs language-js\">func <span class=\"hljs-title function_\">someFunction</span>() error {\n    <span class=\"hljs-keyword\">return</span> errors.<span class=\"hljs-title class_\">New</span>(<span class=\"hljs-string\">\"Errors\"</span>)\n}\n\nfunc <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"></span>) {\n    err := <span class=\"hljs-title function_\">someFunction</span>()\n\n    <span class=\"hljs-keyword\">if</span> err != nil {\n        fmt.<span class=\"hljs-title class_\">Println</span>(<span class=\"hljs-string\">\"실패, 오류:\"</span>, err)\n    } <span class=\"hljs-keyword\">else</span> {\n        fmt.<span class=\"hljs-title class_\">Println</span>(<span class=\"hljs-string\">\"성공\"</span>)\n    }\n}\n</code></pre>\n<div class=\"content-ad\"></div>\n<h1>3. 쉽게 확장할 수 있습니다.</h1>\n<p>에러들은 에러 인터페이스 변수로 일관되게 표시됩니다. 사용자 정의 에러 타입을 만들어 우리의 에러 컨텍스트를 쉽게 확장할 수 있으며, 이는 Go 표준 라이브러리의 OpError 타입과 비슷합니다.</p>\n<p>에러 인터페이스는 에러 값을 제공하는 제공자와 에러 처리를 담당하는 코드 간의 계약 역할을 합니다.</p>\n<p>에러 인터페이스를 구현하는 사람은 에러 처리 코드에서 사용할 에러 컨텍스트를 제공하는 것이 책임입니다.</p>\n<div class=\"content-ad\"></div>\n<p>이는 특정 오류 컨텍스트를 오류 인터페이스 유형과 분리하여 Go의 구성 가능성 및 직교성을 따르는 설계 철학과 일치합니다.</p>\n<p>Go 오류 처리의 일반적인 관행.</p>\n<h2>1. 투명한 오류 처리 전략.</h2>\n<p>간단히 말해서, Go 언어에서의 오류 처리는 함수에 의해 반환된 오류 유형 변수에 의해 전달되는 오류 값 정보를 기반으로 의사 결정을 내리고 후속 코드 실행 경로를 선택하는 과정입니다.</p>\n<div class=\"content-ad\"></div>\n<p>이 방식을 통해 가장 간단한 오류 전략은 반환된 오류 값이 전달하는 구체적인 컨텍스트 정보를 완전히 무시하는 것입니다.</p>\n<p>대신, 오류가 발생할 때마다 하나의 오류 처리 실행 경로로 이어집니다. 예를 들어, 다음 코드를 참고해보세요:</p>\n<pre><code class=\"hljs language-js\">err := <span class=\"hljs-title function_\">doSomething</span>()\n<span class=\"hljs-keyword\">if</span> err != nil {\n    ... ...\n    <span class=\"hljs-keyword\">return</span> err\n}\n</code></pre>\n<p>이것은 Go 언어에서 가장 흔한 오류 처리 전략으로, 오류 처리 시나리오의 80% 이상을 차지합니다. 이 전략에서는 오류 핸들러가 오류 값의 컨텍스트에 신경을 쓰지 않기 때문에, 오류 생성자 (예: 예시의 doSomething 함수)는 Go 표준 라이브러리에서 제공하는 두 가지 기본 오류 값 생성 방법을 직접 사용할 수 있습니다.</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\">func <span class=\"hljs-title function_\">doSomething</span>(...) error {\n    ... ...\n    <span class=\"hljs-keyword\">return</span> errors.<span class=\"hljs-title class_\">New</span>(<span class=\"hljs-string\">\"일부 오류가 발생했습니다\"</span>)\n}\n</code></pre>\n<p>이러한 방식으로 생성된 오류 값은 오류 처리기에게 투명한 컨텍스트 정보를 나타냅니다.</p>\n<p>오류 처리기가 오류 컨텍스트에 대해 인식할 필요가 없는 상황에서는 투명한 오류 처리 전략이 오류 처리기와 오류 값 생성자 간의 결합을 최소화합니다.</p>\n<p>오류 컨텍스트가 오류 처리에 무관한 경우, 이 접근 방식은 오류 처리와 오류 값 생성 사이의 상호 의존성을 줄이는 데 효과적입니다.</p>\n<div class=\"content-ad\"></div>\n<h1>2. Sentinel 오류 처리 전략.</h1>\n<p>오류 핸들러가 투명한 오류 값에만 의존하여 오류 처리 결정을 내릴 수없는 경우, 반환된 오류 값을 검사하려고 시도할 수 있습니다. 아래 코드와 같이 이를 통해 발생하는 안티패턴이 발생할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\">data, err := b.<span class=\"hljs-title class_\">Peek</span>(<span class=\"hljs-number\">1</span>)\n<span class=\"hljs-keyword\">if</span> err != nil {\n    <span class=\"hljs-keyword\">switch</span> err.<span class=\"hljs-title class_\">Error</span>() {\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"bufio: negative count\"</span>:\n        <span class=\"hljs-comment\">// ... ...</span>\n        <span class=\"hljs-keyword\">return</span>\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"bufio: buffer full\"</span>:\n        <span class=\"hljs-comment\">// ... ...</span>\n        <span class=\"hljs-keyword\">return</span>\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"bufio: invalid use of UnreadByte\"</span>:\n        <span class=\"hljs-comment\">// ... ...</span>\n        <span class=\"hljs-keyword\">return</span>\n    <span class=\"hljs-attr\">default</span>:\n        <span class=\"hljs-comment\">// ... ...</span>\n        <span class=\"hljs-keyword\">return</span>\n    }\n}\n</code></pre>\n<p>간단히 말해서, 이 안티패턴은 오류 핸들러가 오류 처리 결정을 내릴 때 \"투명한 오류 값\"이 제공하는 단일 컨텍스트 정보에 완전히 의존하는 경우를 나타냅니다.</p>\n<div class=\"content-ad\"></div>\n<p>하지만 이 \"안티-패턴\"은 상당한 암시적 결합을 야기합니다.</p>\n<p>즉, 오류 값 생성자에 의한 오류 설명 문자열의 미세한 변경조차도 오류 처리 동작에 변화를 일으킬 수 있습니다.</p>\n<p>또한, 문자열 비교를 통해 오류 값들을 조사하는 이 방식은 성능적으로 효율적이지 않습니다.</p>\n<p>그렇다면 해결책은 무엇일까요? Go 표준 라이브러리는 내보낸 \"특정값(sentinel)\" 오류 값의 정의를 통해 오류 핸들러들이 오류 값을 조사하고 오류 처리 결정을 내리는 데 도움을 주는 방식을 사용합니다.</p>\n<div class=\"content-ad\"></div>\n<p>예를 들어, bufio 패키지에서 정의된 \"sentinel errors\"는 다음과 같습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// $GOROOT/src/bufio/bufio.go</span>\n<span class=\"hljs-keyword\">var</span> (\n    <span class=\"hljs-title class_\">ErrInvalidUnreadByte</span> = errors.<span class=\"hljs-title class_\">New</span>(<span class=\"hljs-string\">\"bufio: invalid use of UnreadByte\"</span>)\n    <span class=\"hljs-title class_\">ErrInvalidUnreadRune</span> = errors.<span class=\"hljs-title class_\">New</span>(<span class=\"hljs-string\">\"bufio: invalid use of UnreadRune\"</span>)\n    <span class=\"hljs-title class_\">ErrBufferFull</span>        = errors.<span class=\"hljs-title class_\">New</span>(<span class=\"hljs-string\">\"bufio: buffer full\"</span>)\n    <span class=\"hljs-title class_\">ErrNegativeCount</span>     = errors.<span class=\"hljs-title class_\">New</span>(<span class=\"hljs-string\">\"bufio: negative count\"</span>)\n)\n</code></pre>\n<p>다음 코드 조각은 이전에 언급된 sentinel errors를 활용하여 에러 처리 분기에서 결정을 내리는 예시입니다:</p>\n<pre><code class=\"hljs language-js\">data, err := b.<span class=\"hljs-title class_\">Peek</span>(<span class=\"hljs-number\">1</span>)\n<span class=\"hljs-keyword\">if</span> err != nil {\n    <span class=\"hljs-keyword\">switch</span> err {\n    <span class=\"hljs-keyword\">case</span> bufio.<span class=\"hljs-property\">ErrNegativeCount</span>:\n        <span class=\"hljs-comment\">// ... ...</span>\n        <span class=\"hljs-keyword\">return</span>\n    <span class=\"hljs-keyword\">case</span> bufio.<span class=\"hljs-property\">ErrBufferFull</span>:\n        <span class=\"hljs-comment\">// ... ...</span>\n        <span class=\"hljs-keyword\">return</span>\n    <span class=\"hljs-keyword\">case</span> bufio.<span class=\"hljs-property\">ErrInvalidUnreadByte</span>:\n        <span class=\"hljs-comment\">// ... ...</span>\n        <span class=\"hljs-keyword\">return</span>\n    <span class=\"hljs-attr\">default</span>:\n        <span class=\"hljs-comment\">// ... ...</span>\n        <span class=\"hljs-keyword\">return</span>\n    }\n}\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>그러나 API 개발자의 경우, \"sentinel\" 오류 값 노출은 이러한 오류 값과 패키지의 공개 함수가 API의 일부가 되는 것을 의미합니다.</p>\n<p>한 번 릴리스되면, 개발자는 효과적으로 유지 관리해야 합니다. 또한, \"sentinel\" 오류 값은 이를 사용하는 오류 처리기에 종속성을 만듭니다.</p>\n<p>Go 1.13부터 표준 라이브러리 오류 패키지에서 Is 함수가 도입되어 오류 처리기가 오류 값으로 검사할 수 있습니다.</p>\n<p>Is 함수는 다음 코드에서 보여지는 것처럼 오류 변수를 \"sentinel\" 오류 값과 비교하는 것과 유사합니다:</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">if</span> errors.Is(err, ErrOutOfBounds) {\n    <span class=\"hljs-comment\">// 뭔가를 수행</span>\n}\n</code></pre>\n<p>차이점은 에러 변수가 래핑된 에러를 포함하는 경우, errors.Is 메서드는 래핑된 에러 내에서 에러 체인을 탐색하여 일치하는 에러를 찾을 때까지 모든 래핑된 에러와 비교합니다.</p>\n<p>다음은 Is 함수를 사용하는 예시입니다:</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">var</span> ErrSentinel = errors.New(<span class=\"hljs-string\">\"기본 신호 에러\"</span>)\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n  err1 := fmt.Errorf(<span class=\"hljs-string\">\"sentinel을 래핑: %w\"</span>, ErrSentinel)\n  err2 := fmt.Errorf(<span class=\"hljs-string\">\"err1을 래핑: %w\"</span>, err1)\n  <span class=\"hljs-built_in\">println</span>(err2 == ErrSentinel) <span class=\"hljs-comment\">// false</span>\n  <span class=\"hljs-keyword\">if</span> errors.Is(err2, ErrSentinel) {\n    <span class=\"hljs-built_in\">println</span>(<span class=\"hljs-string\">\"err2는 ErrSentinel입니다.\"</span>)\n    <span class=\"hljs-keyword\">return</span>\n  }\n\n  <span class=\"hljs-built_in\">println</span>(<span class=\"hljs-string\">\"err2는 ErrSentinel이 아닙니다.\"</span>)\n}\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>이 예제에서는 fmt.Errorf 함수와 %w 동사를 사용하여 랩핑된 오류 변수 err1과 err2를 생성합니다.</p>\n<p>err1은 \"sentinel\" 오류 값 ErrSentinel을 랩핑하고, err2는 err1을 랩핑하여 오류 체인을 생성합니다. 오류 체인의 맨 위에는 err2가 있고, 맨 아래에는 ErrSentinel이 있습니다.</p>\n<p>그런 다음 값 비교와 errors.Is 함수를 모두 사용하여 err2와 ErrSentinel 간의 관계를 결정합니다.</p>\n<p>코드를 실행할 때 다음과 같은 결과를 관찰할 수 있습니다:</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-literal\">false</span>\nerr2 is <span class=\"hljs-title class_\">ErrSentinel</span>\n</code></pre>\n<p>보시다시피 동등 연산자를 사용하여 err2와 ErrSentinel을 비교하면 서로 다릅니다.</p>\n<p>그러나 errors.Is 함수는 err2 안의 오류 체인을 탐색하여 가장 깊은 수준에서 랩핑된 \"sentinel\" 오류 값 ErrSentinel을 찾습니다.</p>\n<p>Go 1.13 이상 버전을 사용하는 경우, 특정 \"sentinel\" 오류 값으로 랩핑된 예상 오류 값인지 여부를 확인하기 위해 errors.Is 메서드를 사용하는 것이 좋습니다.</p>\n<div class=\"content-ad\"></div>\n<p>이 접근 방식은 특히 오류 래핑과 체인이 관련된 시나리오에서 더 견고하고 유연한 오류 처리를 제공합니다.</p>\n<h2>3. 오류 값 유형 검사 전략</h2>\n<p>이전에 살펴본 대로, Go 표준 라이브러리에서 제공하는 오류 값 구성 방법을 사용하여 구성된 \"sentinel\" 오류 값은 목표 값을 비교하는 기능 이상의 추가 오류 컨텍스트 정보를 제공하지 않습니다.</p>\n<p>오류 처리기가 오류 값에서 더 많은 \"오류 컨텍스트\" 정보를 필요로 하는 경우, 이전에 논의된 전략 및 오류 값 구성 방법이 충분하지 않을 수 있습니다.</p>\n<div class=\"content-ad\"></div>\n<p>이런 경우에는 추가 “에러 컨텍스트” 정보를 제공하기 위해 사용자 정의 에러 유형을 사용하여 에러 값을 구성해야 합니다.</p>\n<p>모든 에러 값이 에러 인터페이스 변수를 통해 균일하게 표시되기 때문에 기저 에러 유형이 전달하는 에러 컨텍스트 정보를 얻으려면 Go의 타입 어설션 또는 타입 스위치 메커니즘을 사용해야 합니다.</p>\n<p>에러 값을 검사하는 이 에러 처리 접근 방식은 “에러 값 타입 검사 전략”으로 참조할 수 있습니다.</p>\n<p>우리의 이해를 깊이 있게 하기 위해 표준 라이브러리의 예제를 살펴보겠습니다. json 패키지에서 UnmarshalTypeError라는 사용자 정의 에러 유형이 정의되어 있습니다:</p>\n<div class=\"content-ad\"></div>\n<p>에러 핸들러는 오류 값 유형 검사 전략을 사용하여 더 많은 오류 컨텍스트 정보를 얻을 수 있습니다. 아래는 이 전략을 활용하는 json 패키지의 메서드 구현 예시입니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// $GOROOT/src/encoding/json/decode.go</span>\nfunc (d *decodeState) <span class=\"hljs-title function_\">addErrorContext</span>(err error) error {\n    <span class=\"hljs-keyword\">if</span> d.<span class=\"hljs-property\">errorContext</span>.<span class=\"hljs-property\">Struct</span> != nil || <span class=\"hljs-title function_\">len</span>(d.<span class=\"hljs-property\">errorContext</span>.<span class=\"hljs-property\">FieldStack</span>) > <span class=\"hljs-number\">0</span> {\n        <span class=\"hljs-keyword\">switch</span> err := err.(type) {\n        <span class=\"hljs-keyword\">case</span> *<span class=\"hljs-title class_\">UnmarshalTypeError</span>:\n            err.<span class=\"hljs-property\">Struct</span> = d.<span class=\"hljs-property\">errorContext</span>.<span class=\"hljs-property\">Struct</span>.<span class=\"hljs-title class_\">Name</span>()\n            err.<span class=\"hljs-property\">Field</span> = strings.<span class=\"hljs-title class_\">Join</span>(d.<span class=\"hljs-property\">errorContext</span>.<span class=\"hljs-property\">FieldStack</span>, <span class=\"hljs-string\">\".\"</span>)\n            <span class=\"hljs-keyword\">return</span> err\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> err\n}\n</code></pre>\n<p>이 코드에서는 유형 스위치 문을 사용하여 err 변수가 나타내는 동적 유형 및 값을 결정하고, 일치하는 경우 분기에서 처리하기 위해 오류 컨텍스트 정보가 활용됩니다.</p>\n<div class=\"content-ad\"></div>\n<p>일반적으로 사용자 정의된 내보낸 오류 유형은 XXXError 형식으로 명명됩니다.</p>\n<p>\"sentinel\" 오류 처리 전략과 유사하게, 오류 값 유형 검사 전략은 사용자 정의 오류 유형을 오류 핸들러에 노출시켜, 해당 유형들이 API의 일부가 되도록 하며, 패키지의 공개 함수와 함께 사용될 수 있도록 합니다.</p>\n<p>배포된 후에는 개발자가 이러한 사용자 정의 오류 유형을 유지 관리해야 합니다. 게다가, 이러한 유형을 검사하고 사용하는 오류 핸들러에 대한 의존성을 만듭니다.</p>\n<p>Go 1.13부터 표준 라이브러리 errors 패키지는 오류 핸들러가 오류 값들을 검사할 수 있는 As 함수를 제공합니다.</p>\n<div class=\"content-ad\"></div>\n<p>As 함수는 특정 사용자 정의 오류 유형인지를 결정하기 위해 타입 단언을 사용하는 것과 유사합니다. 아래 코드에서와 같이 err 변수가 특정 사용자 정의 오류 유형인지 확인합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> customErr *<span class=\"hljs-title class_\">CustomError</span>\n<span class=\"hljs-keyword\">if</span> errors.<span class=\"hljs-title class_\">As</span>(err, &#x26;customErr) {\n    <span class=\"hljs-comment\">// Handle the error as a CustomError</span>\n}\n</code></pre>\n<p>As 함수의 차이점은 오류 변수에 래핑된 오류가 포함되어 있는 경우, errors.As 함수가 래핑된 오류 내의 오류 체인을 횡단하며, 체인 내의 모든 래핑된 오류와 일치하는 오류 유형을 찾을 때까지 비교한다는 것입니다. 이는 errors.Is의 동작과 유사합니다.</p>\n<p>As 함수 사용 예시가 여기 있습니다:</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\">type <span class=\"hljs-title class_\">MyError</span> struct {\n    e string\n}\n\nfunc (e *<span class=\"hljs-title class_\">MyError</span>) <span class=\"hljs-title class_\">Error</span>() string {\n    <span class=\"hljs-keyword\">return</span> e.<span class=\"hljs-property\">e</span>\n}\n\nfunc <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">var</span> err = &#x26;<span class=\"hljs-title class_\">MyError</span>{<span class=\"hljs-string\">\"MyError error demo\"</span>}\n    err1 := fmt.<span class=\"hljs-title class_\">Errorf</span>(<span class=\"hljs-string\">\"wrap err: %w\"</span>, err)\n    err2 := fmt.<span class=\"hljs-title class_\">Errorf</span>(<span class=\"hljs-string\">\"wrap err1: %w\"</span>, err1)\n    <span class=\"hljs-keyword\">var</span> e *<span class=\"hljs-title class_\">MyError</span>\n    <span class=\"hljs-keyword\">if</span> errors.<span class=\"hljs-title class_\">As</span>(err2, &#x26;e) {\n        <span class=\"hljs-title function_\">println</span>(<span class=\"hljs-string\">\"MyError is on the chain of err2\"</span>)\n        <span class=\"hljs-title function_\">println</span>(e == err)                  \n        <span class=\"hljs-keyword\">return</span>                             \n    }                                      \n    <span class=\"hljs-title function_\">println</span>(<span class=\"hljs-string\">\"MyError is not on the chain of err2\"</span>)\n} \n</code></pre>\n<p>결과.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">MyError</span> is on the chain <span class=\"hljs-keyword\">of</span> err2\n<span class=\"hljs-literal\">true</span>\n</code></pre>\n<p>마침내 출력된 결과처럼, errors.As 함수가 err2 내의 오류 체인을 성공적으로 탐지하여 가장 깊은 오류를 찾아내고, err2를 *MyError 유형과 일치시킵니다.</p>\n<div class=\"content-ad\"></div>\n<p>성공적인 일치가 발생하면, errors.As는 일치한 오류 값을 As 함수의 두 번째 매개변수에 저장합니다. 따라서 println(e == err)을 실행하면 true가 반환됩니다.</p>\n<p>Go 1.13 이상 버전을 사용 중이라면, 특정 사용자 정의 오류 유형의 인스턴스인지를 확인하기 위해 errors.As 메서드를 사용하는 것이 좋습니다.</p>\n<p>이 접근 방식은 사용자 정의 오류를 처리하는 더 유연하고 효율적인 방법을 제공하며, 특히 래핑된 오류와 함께 작업할 때 유용합니다.</p>\n<h1>4. 오류 행동 특성 검사 전략.</h1>\n<div class=\"content-ad\"></div>\n<p>이전에 우리가 논의한 세 가지 전략 중에서는 첫 번째 전략인 \"투명한 오류 처리 전략\"만이 오류 생성자와 오류 처리자 간의 결합을 효과적으로 줄입니다.</p>\n<p>두 번째와 세 번째 전략은 현실 세계의 코딩에서 실용적이지만, 여전히 오류 생성자와 오류 처리자 간의 결합을 어느 정도 도입합니다.</p>\n<p>그래서, \"투명한 오류 처리 전략\"을 제외하고는 오류 처리자와 오류 값 생성자 간의 결합을 줄일 다른 방법이 있을까요?</p>\n<p>Go 표준 라이브러리에서는 패키지 내에서 오류 유형을 분류하고 일반적인 오류 동작 특성을 추출하여 이러한 오류 동작 특성을 공개 인터페이스 유형으로 배치하는 다른 오류 처리 접근 방식을 찾을 수 있습니다.</p>\n<div class=\"content-ad\"></div>\n<p>이 접근법은 \"오류 동작 특성 검사 전략\"으로 알려져 있습니다.</p>\n<p>예를 들어, 표준 라이브러리의 net 패키지는 모든 패키지 내의 일반적인 오류 동작 특성을 추상화하고 net.Error 인터페이스에 넣습니다. 다음 코드에서 확인할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// $GOROOT/src/net/net.go</span>\ntype <span class=\"hljs-title class_\">Error</span> interface {\n    error\n    <span class=\"hljs-title class_\">Timeout</span>() bool  \n    <span class=\"hljs-title class_\">Temporary</span>() bool\n}\n</code></pre>\n<p>net.Error 인터페이스에는 오류 동작 특성을 확인하는 두 가지 메서드가 포함되어 있습니다: Timeout은 시간 초과 오류인지 확인하고 Temporary는 임시 오류인지 확인합니다.</p>\n<div class=\"content-ad\"></div>\n<p>에러 핸들러는 특정 에러의 동작 특성을 검사하고 이 정보를 기반으로 후속 에러 처리 분기에 대한 결정을 내리기 위해이 공개 인터페이스에 의존해야합니다.</p>\n<p>네트워크 패키지에서 가져온 다른 예제를 통해 에러 동작 특성 검사 전략을 사용하여 에러 처리를 더 향상시켜보겠습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// $GOROOT/src/net/http/server.go</span>\nfunc (srv *<span class=\"hljs-title class_\">Server</span>) <span class=\"hljs-title class_\">Serve</span>(l net.<span class=\"hljs-property\">Listener</span>) error {\n    ... ...\n    <span class=\"hljs-keyword\">for</span> {\n        rw, e := l.<span class=\"hljs-title class_\">Accept</span>()\n        <span class=\"hljs-keyword\">if</span> e != nil {\n            select {\n            <span class=\"hljs-keyword\">case</span> <span class=\"xml\">&#x3C;-srv.getDoneChan():\n                return ErrServerClosed\n            default:\n            }\n            if ne, ok := e.(net.Error); ok &#x26;&#x26; ne.Temporary() {\n                ... ...\n                time.Sleep(tempDelay)\n                continue\n            }\n            return e\n        }\n        ...\n    }\n    ... ...\n}\n</span></code></pre>\n<p>위의 코드 스니펫에서 Accept 메서드는 실제로 net 패키지 내의 사용자 지정 에러 유형 인 *OpError 유형의 에러를 반환합니다. OpError는 일반 에러 특성 인터페이스인 net.Error를 구현합니다. 아래 코드에서 확인할 수 있습니다:</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// $GOROOT/src/net/net.go</span>\ntype <span class=\"hljs-title class_\">OpError</span> struct {\n    ... ...\n    <span class=\"hljs-comment\">// Err is the error that occurred during the operation.</span>\n    <span class=\"hljs-title class_\">Err</span> error\n}\n\ntype temporary interface {\n    <span class=\"hljs-title class_\">Temporary</span>() bool\n}\n\nfunc (e *<span class=\"hljs-title class_\">OpError</span>) <span class=\"hljs-title class_\">Temporary</span>() bool {\n  <span class=\"hljs-keyword\">if</span> ne, ok := e.<span class=\"hljs-property\">Err</span>.(*os.<span class=\"hljs-property\">SyscallError</span>); ok {\n      t, ok := ne.<span class=\"hljs-property\">Err</span>.(temporary)\n      <span class=\"hljs-keyword\">return</span> ok &#x26;&#x26; t.<span class=\"hljs-title class_\">Temporary</span>()\n  }\n  t, ok := e.<span class=\"hljs-property\">Err</span>.(temporary)\n  <span class=\"hljs-keyword\">return</span> ok &#x26;&#x26; t.<span class=\"hljs-title class_\">Temporary</span>()\n}\n</code></pre>\n<p>실제로 OpError 인스턴스는 오류 처리기에 의해 검사될 수 있으며 네트.Error 인터페이스에서 제공되는 메서드를 사용하여, 해당 동작이 Temporary나 Timeout과 같은 특성과 일치하는지 여부를 결정할 수 있습니다.</p>\n<p>이를 통해 오류 처리기는 네트워크 관련 작업의 맥락에서 해당 오류의 특정 동작에 기반하여 신중한 결정을 내릴 수 있게 됩니다.</p>\n<p>요약.</p>\n<div class=\"content-ad\"></div>\n<p>Go 언어에서 통합된 오류 유형은 오류 인터페이스이며, 오류 값이 할당될 수 있는 빠르게 구성되는 오류 값 구성 함수인 errors.New, fmt.Errorf 등을 포함하여 다양한 함수가 제공됩니다.</p>\n<p>또한 통합된 오류 유형을 오류 유형으로 사용하는 장점에 대해 논의했습니다.</p>\n<p>이 개념을 깊이 있게 이해하는 것이 중요합니다.</p>\n<ul>\n<li>투명한 오류 처리 전략: 오류 유형을 통합하고 추가 오류 컨텍스트를 제공하지 않음으로써 오류 처리를 간단하게 만들어 대부분의 경우에 적합합니다.</li>\n<li>징표 오류 처리 전략: 상징적인 오류 값 세트를 정의함으로써 오류 처리기가 값 비교를 통해 오류 처리 경로를 선택할 수 있게 합니다.</li>\n<li>오류 값 유형 검사 전략: 오류 유형을 사용자 정의하고 더 많은 오류 컨텍스트를 제공함으로써 추가 오류 컨텍스트가 필요하고 오류 유형을 검사하기 위해 타입 단언 또는 타입 스위치를 사용하는 시나리오에 적합합니다.</li>\n<li>오류 동작 특성 검사 전략: 공개 인터페이스를 통해 오류 동작 특성을 정의함으로써 오류 처리기가 특정 유형이 아닌 오류 특성을 검사할 수 있게 하며, 오류 동작 특성이 중요한 시나리오에 적합합니다.</li>\n</ul>\n<div class=\"content-ad\"></div>\n<p>각 전략마다 장점과 사용 사례가 있습니다. 적절한 전략을 선택하는 것은 유지 보수성, 결합도, 코드 복잡성 및 오류 컨텍스트 요구사항과 같은 프로그래밍에서의 특정 요구사항과 고려사항에 따라 달라집니다.</p>\n<p>이러한 전략을 이해함으로써 오류를 더 잘 다루고 관리할 수 있으며, 코드 신뢰성과 유지 관리성을 향상시킬 수 있습니다.</p>\n<p>이야기가 마음에 드시고 제 지원을 원하신다면 클랩(clap) 눌러주세요.</p>\n<p>여러분의 지원은 제게 매우 중요합니다. 감사합니다.</p>\n</body>\n</html>\n"},"__N_SSG":true}