{"pageProps":{"post":{"title":"2024년 Flutter에서 GraphQL 사용법 쿼리, 뮤테이션, 서브스크립션 구현 완벽 가이드","description":"","date":"2024-06-21 22:20","slug":"2024-06-21-GraphQLinFlutterAComprehensiveGuidetoQueryMutationandSubscriptionImplementations","content":"\n\n![이미지](/assets/img/2024-06-21-GraphQLinFlutterAComprehensiveGuidetoQueryMutationandSubscriptionImplementations_0.png)\n\n이 기사는 플러터(Flutter)에서 GraphQL을 마스터하는 데 필수적인 가이드입니다! 기본 개념 이해부터 쿼리(query), 뮤테이션(mutation), 구독(subscription)의 핵심 개념까지 모두 다룹니다. 뿐만 아니라 Flutter 앱에 GraphQL을 원활하게 통합하는 방법을 단계별 지침과 코드 샘플을 제공하면서 안내해드립니다.\n\n# GraphQL이란?\n\nGraphQL을 주문하듯이 생각해보세요. 일반 레스토랑(전통적인 API와 같은)에서는 특정 토핑이 올라간 고정된 피자를 주문합니다. 원하는 거랑 다르면 완전히 새로운 피자를 주문해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n지금은 GraphQL을 사용하면 피자에 원하는 대로 말하는 것과 같아요 — 크러스트, 소스, 토핑 종류를 정확하게 말하는 것과 같아요. 당신을 위해 특별히 만들어진 피자를 받게 되는거죠. 딱 필요한 만큼만요. 데이터에 대한 맞춤 주문처럼 생각해보세요 — 필요한 것을 요청하면 정확히 그것을 받게 되어 매우 효율적이고 요구 사항에 맞게 제작됩니다.\n\n그 외에도, GraphQL은 데이터와 상호 작용하는 방법을 간소화하여 세 가지 주요 작업을 제공합니다: 쿼리, 뮤테이션, 그리고 구독.\n\n- 쿼리: GraphQL에서 쿼리는 특정 데이터를 요청하는 것입니다. 서버에서 정보를 요청하는 것과 같이 특정 데이터와 그 구조를 명시합니다. 당신이 원하는 토핑과 크러스트 유형을 주문하는 것과 같은 거죠.\n- 뮤테이션: GraphQL에서 뮤테이션은 데이터 수정을 다루는 작업들입니다. 새 데이터 추가, 기존 레코드 업데이트, 혹은 정보 삭제와 같은 작업을 할 수 있습니다. 피자 비유에서는 셰프에게 선호에 따라 토핑을 추가하거나 제거하도록 지시하는 것과 같아요.\n- 구독: 구독은 GraphQL에서 실시간 업데이트를 가능하도록 합니다. 클라이언트(당신)와 서버(셰프) 사이에 지속적인 연결을 설정하여 서버가 가능한 즉시 새 정보를 클라이언트에게 푸시할 수 있게 합니다. 피자 준비 과정을 알려주는 셰프와 같이 데이터 변경 사항에 대한 실시간 알림을 받는 것과 같아요.\n\n그래서, GraphQL은 주문을 맞춤 제작하는 것 이상이에요; 당신이 요구하는 대로 데이터를 조회, 수정하고 최신 상태를 유지할 수 있도록 효율적이고 요구 사항에 정확히 맞게 제작된 방법을 제공하는겁니다.\n\n<div class=\"content-ad\"></div>\n\n# 플러터에서 GraphQL 구현하기\n\n먼저, 다음 패키지를 pubspec.yaml 파일에 추가하고 flutter pub get을 실행하세요:\n\n```js\n  graphql_flutter: latest\n  graphql: latest\n```\n\n이제 다음과 같이 GraphQL 클라이언트를 생성하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\n  final HttpLink _httpLink = HttpLink(\n    \"<YOUR-BASE-URL>\",\n    defaultHeaders: {\n      'Authorization': 'Bearer <YOUR_PERSONAL_ACCESS_TOKEN>',\n      'AuthorizationSource': 'API',\n    },\n  );\n\n\n  final ValueNotifier<GraphQLClient> client = ValueNotifier(GraphQLClient(\n    link: _httpLink,\n    cache: GraphQLCache(),\n  ));\n```\n\n앱을 GraphQL 위젯을 사용하기위한 GraphQLProvider 상속 위젯으로 감싸세요:\n\n```js\n  Widget build(BuildContext context) {\n    return GraphQLProvider(\n      client: client,\n      child: MaterialApp(\n        title: 'App',\n        home: HomeScreen(),\n      ),\n    );\n  }\n```\n\n그럼 GraphQL API를 소비해봅시다.\n\n<div class=\"content-ad\"></div>\n\n# 쿼리\n\n먼저 쿼리 문서를 정의해보겠습니다.\n\n```js\nfinal getUserQuery = gql(r'''\n    query getUser($id: ID) {\n      user(id: $id) {\n        id\n        first_name\n        last_name\n      }\n    }\n''');\n```\n\n쿼리 정의:\n\n<div class=\"content-ad\"></div>\n\n- query getUser($id: ID): 이 줄은 getUser라는 GraphQL 쿼리의 정의를 시작합니다. $id는 쿼리에 전달할 수 있는 ID 유형의 변수입니다.\n\n쿼리 본문:\n\n- ' user(id: $id) ' ... ' ': 쿼리의 본문은 우리가 원하는 데이터를 지정합니다. 이 경우 주어진 id를 가진 사용자에 대한 정보를 요청하고 있습니다. 요청된 세 가지 필드는 id, first_name 및 last_name입니다.\n\n변수 사용:\n\n<div class=\"content-ad\"></div>\n\n- 쿼리 내에서 $id 변수는 요청을 매개변수화하는 데 사용됩니다. 이는 쿼리가 실행될 때 특정 ID로 동적으로 채워지는 자리 표시자입니다.\n\n## 쿼리 위젯\n\n이제 이 문서를 사용하여 GraphQL API에 요청을 보냅니다.\n\n```js\nQuery(\n  options: QueryOptions(\n    document: getUserQuery,\n    variables: const {\n      \"id\": \"1\",\n    },\n  ),\n  builder: (\n    QueryResult result, {\n    Future<QueryResult> Function(FetchMoreOptions)? fetchMore,\n    Future<QueryResult?> Function()? refetch,\n  }) {\n    if (result.hasException) {\n      return const Text(\"에러\");\n    }\n    if (result.isLoading) {\n      return const CircularProgressIndicator();\n    }\n    final user = result.data?[\"user\"];\n    return ListTile(\n      title: Text(user[\"first_name\"]),\n      subtitle: Text(user[\"last_name\"]),\n    );\n  },\n)\n```\n\n<div class=\"content-ad\"></div>\n\n쿼리 위젯:\n\n- 이 문구는 graphql_flutter 패키지에서 제공하는 Query 위젯의 일부분입니다. Query 위젯은 GraphQL 쿼리를 실행하는 데 사용됩니다.\n\n쿼리의 옵션:\n\n- 옵션 매개변수는 GraphQL 쿼리 실행에 필요한 세부 정보를 제공하는 데 사용됩니다.\n- 문서: getUserQuery: 실행할 GraphQL 쿼리는 getUserQuery 변수를 사용하여 지정됩니다. 이 변수는 코드의 이전 부분에서 정의된 쿼리입니다.\n- 변수: const '\"id\": \"1\"': 이는 쿼리에 필요한 변수를 제공합니다. 이 경우 \"id\" 변수를 \"1\"로 설정하고 있습니다.\n\n<div class=\"content-ad\"></div>\n\nBuilder 함수:\n\n- builder는 GraphQL 쿼리의 결과로 호출되는 콜백 함수입니다.\n- QueryResult result: GraphQL 쿼리 실행의 결과를 보유합니다.\n- 빌더 안에서:\n- result.hasException을 사용하여 예외를 확인합니다. 예외가 발생하면 \"Error\"를 표시하는 Text 위젯을 반환합니다.\n- result.isLoading을 사용하여 쿼리가 여전히 로딩 중인지 확인합니다. true인 경우 CircularProgressIndicator를 반환합니다.\n- 쿼리가 성공하고 로딩 중이 아닌 경우, 결과에서 사용자 데이터를 추출하고 ListTile에 표시합니다. ListTile에는 사용자의 성과 이름이 각각 제목과 부제목으로 나타납니다.\n\n## 쿼리 메소드\n\n응답을 그릴 때 더 많은 제어를 위해 GraphQL 클라이언트의 query 메소드를 사용하여 GraphQL API를 소비하는 다른 방법이 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n# Mutation\n\n이제 먼저 변이 문서를 정의해 봅시다.\n\n```js\n final updateUserMutation = gql(r'''\n    mutation updateUser($id: ID, $first_name: String, $last_name: String) {\n    updateUser(\n    input: {id: $id, first_name: $first_name, last_name: $last_name,}\n      ) {\n    user {\n      id\n      first_name\n      last_name\n    }\n    messages {\n      field\n      message\n    }\n  }\n}\n''');\n```\n\n<div class=\"content-ad\"></div>\n\n이제 문서를 사용하여 GraphQL 클라이언트 객체를 사용하여 사용자 데이터를 업데이트해 봅시다.\n\n```js\nfinal result = await client.mutate(\n        MutationOptions(\n          document: updateUserMutation,\n          variables: {\n            \"id\": \"1\",\n            \"first_name\": \"John\",\n            \"last_name\": \"Doe\"\n          },\n        ),\n```\n\nGraphQL Mutation 실행:\n\n- client.mutate: 이것은 GraphQL 클라이언트에서 mutate 메소드를 호출하는 것입니다. 클라이언트 객체는 GraphQL 클라이언트의 인스턴스입니다.\n\n<div class=\"content-ad\"></div>\n\n돌변에 대한 옵션:\n\n- 돌변 옵션은 GraphQL 돌변 실행에 대한 세부 정보를 제공하는 데 사용됩니다.\n- 변수: '\"id\": \"1\", \"first_name\": \"John\", \"last_name\": \"Doe\"': 이는 돌변에 필요한 변수를 제공합니다. 사용자의 id와 함께 업데이트할 새로운 이름 및 성 값을 포함합니다.\n\n결과 처리:\n\n- 돌변 작업의 결과는 결과 변수에 저장됩니다.\n- 결과의 실제 구조는 사용되는 GraphQL 클라이언트에 따라 다르지만 일반적으로 돌변에 의해 반환된 데이터, 오류 및 추가 메타데이터와 같은 정보를 포함합니다.\n\n<div class=\"content-ad\"></div>\n\n# 구독\n\n먼저 웹소켓을 위한 graphQL 클라이언트를 만들겠습니다.\n\n```js\nfinal WebSocketLink websocketLink = WebSocketLink(\n    url: '<YOUR-GRAPHQL-SUBSCRIPTION-ENDPOINT>',\n    config: SocketClientConfig(\n    autoReconnect: true,\n    inactivityTimeout: Duration(seconds: 30),\n  ),\n);\n\nwebsocketClient = GraphQLClient(\n  link: websocketLink,\n  cache: GraphQLCache(),\n);\n```\n\n웹소켓 링크 설정:\n\n<div class=\"content-ad\"></div>\n\n- WebSocketLink은 GraphQL 구독용 WebSocket 전송의 구현체입니다. 지정된 GraphQL 서버 엔드포인트로 WebSocket 연결을 설정합니다.\n- URL: `YOUR-GRAPHQL-SUBSCRIPTION-ENDPOINT`: 실제 웹소켓 엔드포인트로 대체합니다. 이는 GraphQL 서버에서 제공하는 실제 웹소켓 엔드포인트로 구독을 처리합니다. 이 URL은 일반적으로 ws:// 또는 wss://로 시작합니다.\n- config: SocketClientConfig(...): WebSocket 연결에 대한 구성 옵션을 제공합니다.\n- autoReconnect: true: 연결이 끊긴 경우 자동 재연결을 활성화합니다.\n- inactivityTimeout: Duration(seconds: 30): 활동이 없거나 해당 시간 내에 통신이 발생하지 않을 경우 웹소켓 연결을 닫기 위한 타임아웃 기간을 설정합니다.\n\nGraphQLClient 설정:\n\n- GraphQLClient는 구독을 위한 통신 링크로 WebSocketLink를 사용하여 인스턴스화됩니다. 또한 캐싱을 위해 GraphQLCache를 사용합니다.\n- link: websocketLink: GraphQL 클라이언트의 통신 링크로 WebSocketLink를 지정합니다. 이는 구독이 WebSocket 연결을 통해 처리되도록 합니다.\n- cache: GraphQLCache(): GraphQL 클라이언트의 로컬 상태 및 쿼리 결과를 저장하고 관리하기 위한 캐시를 초기화합니다.\n\n이제 GraphQL 구독 문서를 작성해 봅시다.\n\n<div class=\"content-ad\"></div>\n\n```javascript\n  static final userUpdatedMutation = gql(r'''\nsubscription userUpdatedSubscription($id: String) {\n        userUpdatedSubscription(id: $id) {\n            ...UserFragment\n        }\n    }\n    fragment UserFragment on User {\n        id\n        first_name\n        last_name\n    }\n    ''');\n```\n\nGraphQL Subscription:\n\n- userUpdatedMutation은 사용자가 업데이트될 때 업데이트를 청취하는 GraphQL 구독(subscription)입니다. 사용자관련 정보를 관심 있는 사용자로 지정하기 위해 String 타입의 $id 매개변수를 가져옵니다.\n- subscription userUpdatedSubscription($id: String): id 변수를 허용하는 userUpdatedSubscription이라는 이름의 구독을 선언합니다.\n- userUpdatedSubscription(id: $id): 이 구독은 지정된 id를 가진 사용자에 대한 업데이트에 관심이 있다는 것을 나타냅니다.\n- ' ...UserFragment ': 이 구독에는 fragment spread, ...UserFragment가 포함되어 있어서 UserFragment에서 지정된 필드를 수신하려는 것을 나타냅니다.\n\nGraphQL Fragment:\n\n<div class=\"content-ad\"></div>\n\n- GraphQL 프래그먼트 (UserFragment)는 여러 쿼리, 뮤테이션 또는 구독에서 사용할 수 있는 재사용 가능한 필드 세트를 정의합니다.\n- UserFragment on User ' ... '의 프래그먼트는 User 유형에서 UserFragment라는 이름의 프래그먼트를 선언합니다.\n- 이 프래그먼트에는 id, first_name, last_name과 같은 필드가 포함되어 있습니다. ...UserFragment 스프레드를 포함하는 모든 작업은 이러한 필드를 자동으로 포함합니다.\n- 프래그먼트는 필드 정의의 중복을 피하고 코드 재사용성을 촉진하는 데 도움이 됩니다. 여러 작업이 공통 필드를 공유할 때 특히 유용합니다.\n\n이제 이 구독을 들어보겠습니다\n\n```js\nvoid _subscribe() async {\n  final subscription = await websocketClient.subscribe(\n    SubscriptionOptions(\n      document: userUpdatedMutation,\n    ),\n  );\n\n  subscription.listen((result) {\n    final userData = result.data?['user'];\n    print('이름: ${userData[\"first_name\"]}');\n    print('성: ${userData[\"last_name\"]}');\n    // 실시간 업데이트 처리, 예를 들어 UI 업데이트\n  });\n}\n```\n\nSubscription Widget도 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nbody: Subscription(\n        options: SubscriptionOptions(\n        document: userUpdatedMutation,\n        ),\n        builder: (result) {\n          final user = result.data?[\"user\"];\n          return ListTile(\n            title: Text(user[\"first_name\"]),\n            subtitle: Text(user[\"last_name\"]),\n          );\n        },\n      ),\n```\n\n# 결론\n\n이 가이드를 통해 플러터에서 GraphQL 구현에 대한 포괄적인 이해를 제공했습니다. 쿼리, 뮤테이션 및 구독의 기본 사항부터 실제 통합 단계에 이르기까지의 내용이 담겨 있습니다. 실시간 업데이트를 통한 GraphQL 구독에 중점을 두고 뮤테이션 작업을 시연함으로써, 개발자들은 이제 플러터 프로젝트에 GraphQL을 원활하게 통합할 수 있습니다. 이 포괄적인 리소스는 모든 수준의 개발자가 데이터 검색을 최적화하고 앱의 효율성을 향상시키며, 플러터에서 GraphQL의 강력함을 통해 동적 사용자 경험을 제공할 수 있는 기술을 제공합니다.","ogImage":{"url":"/assets/img/2024-06-21-GraphQLinFlutterAComprehensiveGuidetoQueryMutationandSubscriptionImplementations_0.png"},"coverImage":"/assets/img/2024-06-21-GraphQLinFlutterAComprehensiveGuidetoQueryMutationandSubscriptionImplementations_0.png","tag":["Tech"],"readingTime":9},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-06-21-GraphQLinFlutterAComprehensiveGuidetoQueryMutationandSubscriptionImplementations_0.png\" alt=\"이미지\"></p>\n<p>이 기사는 플러터(Flutter)에서 GraphQL을 마스터하는 데 필수적인 가이드입니다! 기본 개념 이해부터 쿼리(query), 뮤테이션(mutation), 구독(subscription)의 핵심 개념까지 모두 다룹니다. 뿐만 아니라 Flutter 앱에 GraphQL을 원활하게 통합하는 방법을 단계별 지침과 코드 샘플을 제공하면서 안내해드립니다.</p>\n<h1>GraphQL이란?</h1>\n<p>GraphQL을 주문하듯이 생각해보세요. 일반 레스토랑(전통적인 API와 같은)에서는 특정 토핑이 올라간 고정된 피자를 주문합니다. 원하는 거랑 다르면 완전히 새로운 피자를 주문해야 합니다.</p>\n<div class=\"content-ad\"></div>\n<p>지금은 GraphQL을 사용하면 피자에 원하는 대로 말하는 것과 같아요 — 크러스트, 소스, 토핑 종류를 정확하게 말하는 것과 같아요. 당신을 위해 특별히 만들어진 피자를 받게 되는거죠. 딱 필요한 만큼만요. 데이터에 대한 맞춤 주문처럼 생각해보세요 — 필요한 것을 요청하면 정확히 그것을 받게 되어 매우 효율적이고 요구 사항에 맞게 제작됩니다.</p>\n<p>그 외에도, GraphQL은 데이터와 상호 작용하는 방법을 간소화하여 세 가지 주요 작업을 제공합니다: 쿼리, 뮤테이션, 그리고 구독.</p>\n<ul>\n<li>쿼리: GraphQL에서 쿼리는 특정 데이터를 요청하는 것입니다. 서버에서 정보를 요청하는 것과 같이 특정 데이터와 그 구조를 명시합니다. 당신이 원하는 토핑과 크러스트 유형을 주문하는 것과 같은 거죠.</li>\n<li>뮤테이션: GraphQL에서 뮤테이션은 데이터 수정을 다루는 작업들입니다. 새 데이터 추가, 기존 레코드 업데이트, 혹은 정보 삭제와 같은 작업을 할 수 있습니다. 피자 비유에서는 셰프에게 선호에 따라 토핑을 추가하거나 제거하도록 지시하는 것과 같아요.</li>\n<li>구독: 구독은 GraphQL에서 실시간 업데이트를 가능하도록 합니다. 클라이언트(당신)와 서버(셰프) 사이에 지속적인 연결을 설정하여 서버가 가능한 즉시 새 정보를 클라이언트에게 푸시할 수 있게 합니다. 피자 준비 과정을 알려주는 셰프와 같이 데이터 변경 사항에 대한 실시간 알림을 받는 것과 같아요.</li>\n</ul>\n<p>그래서, GraphQL은 주문을 맞춤 제작하는 것 이상이에요; 당신이 요구하는 대로 데이터를 조회, 수정하고 최신 상태를 유지할 수 있도록 효율적이고 요구 사항에 정확히 맞게 제작된 방법을 제공하는겁니다.</p>\n<div class=\"content-ad\"></div>\n<h1>플러터에서 GraphQL 구현하기</h1>\n<p>먼저, 다음 패키지를 pubspec.yaml 파일에 추가하고 flutter pub get을 실행하세요:</p>\n<pre><code class=\"hljs language-js\">  <span class=\"hljs-attr\">graphql_flutter</span>: latest\n  <span class=\"hljs-attr\">graphql</span>: latest\n</code></pre>\n<p>이제 다음과 같이 GraphQL 클라이언트를 생성하세요:</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\">  final <span class=\"hljs-title class_\">HttpLink</span> _httpLink = <span class=\"hljs-title class_\">HttpLink</span>(\n    <span class=\"hljs-string\">\"&#x3C;YOUR-BASE-URL>\"</span>,\n    <span class=\"hljs-attr\">defaultHeaders</span>: {\n      <span class=\"hljs-string\">'Authorization'</span>: <span class=\"hljs-string\">'Bearer &#x3C;YOUR_PERSONAL_ACCESS_TOKEN>'</span>,\n      <span class=\"hljs-string\">'AuthorizationSource'</span>: <span class=\"hljs-string\">'API'</span>,\n    },\n  );\n\n\n  final <span class=\"hljs-title class_\">ValueNotifier</span>&#x3C;<span class=\"hljs-title class_\">GraphQLClient</span>> client = <span class=\"hljs-title class_\">ValueNotifier</span>(<span class=\"hljs-title class_\">GraphQLClient</span>(\n    <span class=\"hljs-attr\">link</span>: _httpLink,\n    <span class=\"hljs-attr\">cache</span>: <span class=\"hljs-title class_\">GraphQLCache</span>(),\n  ));\n</code></pre>\n<p>앱을 GraphQL 위젯을 사용하기위한 GraphQLProvider 상속 위젯으로 감싸세요:</p>\n<pre><code class=\"hljs language-js\">  <span class=\"hljs-title class_\">Widget</span> <span class=\"hljs-title function_\">build</span>(<span class=\"hljs-params\">BuildContext context</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">GraphQLProvider</span>(\n      <span class=\"hljs-attr\">client</span>: client,\n      <span class=\"hljs-attr\">child</span>: <span class=\"hljs-title class_\">MaterialApp</span>(\n        <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">'App'</span>,\n        <span class=\"hljs-attr\">home</span>: <span class=\"hljs-title class_\">HomeScreen</span>(),\n      ),\n    );\n  }\n</code></pre>\n<p>그럼 GraphQL API를 소비해봅시다.</p>\n<div class=\"content-ad\"></div>\n<h1>쿼리</h1>\n<p>먼저 쿼리 문서를 정의해보겠습니다.</p>\n<pre><code class=\"hljs language-js\">final getUserQuery = <span class=\"hljs-title function_\">gql</span>(r<span class=\"hljs-string\">''</span><span class=\"hljs-string\">'\n    query getUser($id: ID) {\n      user(id: $id) {\n        id\n        first_name\n        last_name\n      }\n    }\n'</span><span class=\"hljs-string\">''</span>);\n</code></pre>\n<p>쿼리 정의:</p>\n<div class=\"content-ad\"></div>\n<ul>\n<li>query getUser($id: ID): 이 줄은 getUser라는 GraphQL 쿼리의 정의를 시작합니다. $id는 쿼리에 전달할 수 있는 ID 유형의 변수입니다.</li>\n</ul>\n<p>쿼리 본문:</p>\n<ul>\n<li>' user(id: $id) ' ... ' ': 쿼리의 본문은 우리가 원하는 데이터를 지정합니다. 이 경우 주어진 id를 가진 사용자에 대한 정보를 요청하고 있습니다. 요청된 세 가지 필드는 id, first_name 및 last_name입니다.</li>\n</ul>\n<p>변수 사용:</p>\n<div class=\"content-ad\"></div>\n<ul>\n<li>쿼리 내에서 $id 변수는 요청을 매개변수화하는 데 사용됩니다. 이는 쿼리가 실행될 때 특정 ID로 동적으로 채워지는 자리 표시자입니다.</li>\n</ul>\n<h2>쿼리 위젯</h2>\n<p>이제 이 문서를 사용하여 GraphQL API에 요청을 보냅니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">Query</span>(\n  <span class=\"hljs-attr\">options</span>: <span class=\"hljs-title class_\">QueryOptions</span>(\n    <span class=\"hljs-attr\">document</span>: getUserQuery,\n    <span class=\"hljs-attr\">variables</span>: <span class=\"hljs-keyword\">const</span> {\n      <span class=\"hljs-string\">\"id\"</span>: <span class=\"hljs-string\">\"1\"</span>,\n    },\n  ),\n  <span class=\"hljs-attr\">builder</span>: (\n    <span class=\"hljs-title class_\">QueryResult</span> result, {\n    <span class=\"hljs-title class_\">Future</span>&#x3C;<span class=\"hljs-title class_\">QueryResult</span>> <span class=\"hljs-title class_\">Function</span>(<span class=\"hljs-title class_\">FetchMoreOptions</span>)? fetchMore,\n    <span class=\"hljs-title class_\">Future</span>&#x3C;<span class=\"hljs-title class_\">QueryResult</span>?> <span class=\"hljs-title class_\">Function</span>()? refetch,\n  }) {\n    <span class=\"hljs-keyword\">if</span> (result.<span class=\"hljs-property\">hasException</span>) {\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Text</span>(<span class=\"hljs-string\">\"에러\"</span>);\n    }\n    <span class=\"hljs-keyword\">if</span> (result.<span class=\"hljs-property\">isLoading</span>) {\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">CircularProgressIndicator</span>();\n    }\n    final user = result.<span class=\"hljs-property\">data</span>?[<span class=\"hljs-string\">\"user\"</span>];\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">ListTile</span>(\n      <span class=\"hljs-attr\">title</span>: <span class=\"hljs-title class_\">Text</span>(user[<span class=\"hljs-string\">\"first_name\"</span>]),\n      <span class=\"hljs-attr\">subtitle</span>: <span class=\"hljs-title class_\">Text</span>(user[<span class=\"hljs-string\">\"last_name\"</span>]),\n    );\n  },\n)\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>쿼리 위젯:</p>\n<ul>\n<li>이 문구는 graphql_flutter 패키지에서 제공하는 Query 위젯의 일부분입니다. Query 위젯은 GraphQL 쿼리를 실행하는 데 사용됩니다.</li>\n</ul>\n<p>쿼리의 옵션:</p>\n<ul>\n<li>옵션 매개변수는 GraphQL 쿼리 실행에 필요한 세부 정보를 제공하는 데 사용됩니다.</li>\n<li>문서: getUserQuery: 실행할 GraphQL 쿼리는 getUserQuery 변수를 사용하여 지정됩니다. 이 변수는 코드의 이전 부분에서 정의된 쿼리입니다.</li>\n<li>변수: const '\"id\": \"1\"': 이는 쿼리에 필요한 변수를 제공합니다. 이 경우 \"id\" 변수를 \"1\"로 설정하고 있습니다.</li>\n</ul>\n<div class=\"content-ad\"></div>\n<p>Builder 함수:</p>\n<ul>\n<li>builder는 GraphQL 쿼리의 결과로 호출되는 콜백 함수입니다.</li>\n<li>QueryResult result: GraphQL 쿼리 실행의 결과를 보유합니다.</li>\n<li>빌더 안에서:</li>\n<li>result.hasException을 사용하여 예외를 확인합니다. 예외가 발생하면 \"Error\"를 표시하는 Text 위젯을 반환합니다.</li>\n<li>result.isLoading을 사용하여 쿼리가 여전히 로딩 중인지 확인합니다. true인 경우 CircularProgressIndicator를 반환합니다.</li>\n<li>쿼리가 성공하고 로딩 중이 아닌 경우, 결과에서 사용자 데이터를 추출하고 ListTile에 표시합니다. ListTile에는 사용자의 성과 이름이 각각 제목과 부제목으로 나타납니다.</li>\n</ul>\n<h2>쿼리 메소드</h2>\n<p>응답을 그릴 때 더 많은 제어를 위해 GraphQL 클라이언트의 query 메소드를 사용하여 GraphQL API를 소비하는 다른 방법이 있습니다.</p>\n<div class=\"content-ad\"></div>\n<h1>Mutation</h1>\n<p>이제 먼저 변이 문서를 정의해 봅시다.</p>\n<pre><code class=\"hljs language-js\"> final updateUserMutation = <span class=\"hljs-title function_\">gql</span>(r<span class=\"hljs-string\">''</span><span class=\"hljs-string\">'\n    mutation updateUser($id: ID, $first_name: String, $last_name: String) {\n    updateUser(\n    input: {id: $id, first_name: $first_name, last_name: $last_name,}\n      ) {\n    user {\n      id\n      first_name\n      last_name\n    }\n    messages {\n      field\n      message\n    }\n  }\n}\n'</span><span class=\"hljs-string\">''</span>);\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>이제 문서를 사용하여 GraphQL 클라이언트 객체를 사용하여 사용자 데이터를 업데이트해 봅시다.</p>\n<pre><code class=\"hljs language-js\">final result = <span class=\"hljs-keyword\">await</span> client.<span class=\"hljs-title function_\">mutate</span>(\n        <span class=\"hljs-title class_\">MutationOptions</span>(\n          <span class=\"hljs-attr\">document</span>: updateUserMutation,\n          <span class=\"hljs-attr\">variables</span>: {\n            <span class=\"hljs-string\">\"id\"</span>: <span class=\"hljs-string\">\"1\"</span>,\n            <span class=\"hljs-string\">\"first_name\"</span>: <span class=\"hljs-string\">\"John\"</span>,\n            <span class=\"hljs-string\">\"last_name\"</span>: <span class=\"hljs-string\">\"Doe\"</span>\n          },\n        ),\n</code></pre>\n<p>GraphQL Mutation 실행:</p>\n<ul>\n<li>client.mutate: 이것은 GraphQL 클라이언트에서 mutate 메소드를 호출하는 것입니다. 클라이언트 객체는 GraphQL 클라이언트의 인스턴스입니다.</li>\n</ul>\n<div class=\"content-ad\"></div>\n<p>돌변에 대한 옵션:</p>\n<ul>\n<li>돌변 옵션은 GraphQL 돌변 실행에 대한 세부 정보를 제공하는 데 사용됩니다.</li>\n<li>변수: '\"id\": \"1\", \"first_name\": \"John\", \"last_name\": \"Doe\"': 이는 돌변에 필요한 변수를 제공합니다. 사용자의 id와 함께 업데이트할 새로운 이름 및 성 값을 포함합니다.</li>\n</ul>\n<p>결과 처리:</p>\n<ul>\n<li>돌변 작업의 결과는 결과 변수에 저장됩니다.</li>\n<li>결과의 실제 구조는 사용되는 GraphQL 클라이언트에 따라 다르지만 일반적으로 돌변에 의해 반환된 데이터, 오류 및 추가 메타데이터와 같은 정보를 포함합니다.</li>\n</ul>\n<div class=\"content-ad\"></div>\n<h1>구독</h1>\n<p>먼저 웹소켓을 위한 graphQL 클라이언트를 만들겠습니다.</p>\n<pre><code class=\"hljs language-js\">final <span class=\"hljs-title class_\">WebSocketLink</span> websocketLink = <span class=\"hljs-title class_\">WebSocketLink</span>(\n    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">'&#x3C;YOUR-GRAPHQL-SUBSCRIPTION-ENDPOINT>'</span>,\n    <span class=\"hljs-attr\">config</span>: <span class=\"hljs-title class_\">SocketClientConfig</span>(\n    <span class=\"hljs-attr\">autoReconnect</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">inactivityTimeout</span>: <span class=\"hljs-title class_\">Duration</span>(<span class=\"hljs-attr\">seconds</span>: <span class=\"hljs-number\">30</span>),\n  ),\n);\n\nwebsocketClient = <span class=\"hljs-title class_\">GraphQLClient</span>(\n  <span class=\"hljs-attr\">link</span>: websocketLink,\n  <span class=\"hljs-attr\">cache</span>: <span class=\"hljs-title class_\">GraphQLCache</span>(),\n);\n</code></pre>\n<p>웹소켓 링크 설정:</p>\n<div class=\"content-ad\"></div>\n<ul>\n<li>WebSocketLink은 GraphQL 구독용 WebSocket 전송의 구현체입니다. 지정된 GraphQL 서버 엔드포인트로 WebSocket 연결을 설정합니다.</li>\n<li>URL: <code>YOUR-GRAPHQL-SUBSCRIPTION-ENDPOINT</code>: 실제 웹소켓 엔드포인트로 대체합니다. 이는 GraphQL 서버에서 제공하는 실제 웹소켓 엔드포인트로 구독을 처리합니다. 이 URL은 일반적으로 ws:// 또는 wss://로 시작합니다.</li>\n<li>config: SocketClientConfig(...): WebSocket 연결에 대한 구성 옵션을 제공합니다.</li>\n<li>autoReconnect: true: 연결이 끊긴 경우 자동 재연결을 활성화합니다.</li>\n<li>inactivityTimeout: Duration(seconds: 30): 활동이 없거나 해당 시간 내에 통신이 발생하지 않을 경우 웹소켓 연결을 닫기 위한 타임아웃 기간을 설정합니다.</li>\n</ul>\n<p>GraphQLClient 설정:</p>\n<ul>\n<li>GraphQLClient는 구독을 위한 통신 링크로 WebSocketLink를 사용하여 인스턴스화됩니다. 또한 캐싱을 위해 GraphQLCache를 사용합니다.</li>\n<li>link: websocketLink: GraphQL 클라이언트의 통신 링크로 WebSocketLink를 지정합니다. 이는 구독이 WebSocket 연결을 통해 처리되도록 합니다.</li>\n<li>cache: GraphQLCache(): GraphQL 클라이언트의 로컬 상태 및 쿼리 결과를 저장하고 관리하기 위한 캐시를 초기화합니다.</li>\n</ul>\n<p>이제 GraphQL 구독 문서를 작성해 봅시다.</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-javascript\">  <span class=\"hljs-keyword\">static</span> final userUpdatedMutation = <span class=\"hljs-title function_\">gql</span>(r<span class=\"hljs-string\">''</span><span class=\"hljs-string\">'\nsubscription userUpdatedSubscription($id: String) {\n        userUpdatedSubscription(id: $id) {\n            ...UserFragment\n        }\n    }\n    fragment UserFragment on User {\n        id\n        first_name\n        last_name\n    }\n    '</span><span class=\"hljs-string\">''</span>);\n</code></pre>\n<p>GraphQL Subscription:</p>\n<ul>\n<li>userUpdatedMutation은 사용자가 업데이트될 때 업데이트를 청취하는 GraphQL 구독(subscription)입니다. 사용자관련 정보를 관심 있는 사용자로 지정하기 위해 String 타입의 $id 매개변수를 가져옵니다.</li>\n<li>subscription userUpdatedSubscription($id: String): id 변수를 허용하는 userUpdatedSubscription이라는 이름의 구독을 선언합니다.</li>\n<li>userUpdatedSubscription(id: $id): 이 구독은 지정된 id를 가진 사용자에 대한 업데이트에 관심이 있다는 것을 나타냅니다.</li>\n<li>' ...UserFragment ': 이 구독에는 fragment spread, ...UserFragment가 포함되어 있어서 UserFragment에서 지정된 필드를 수신하려는 것을 나타냅니다.</li>\n</ul>\n<p>GraphQL Fragment:</p>\n<div class=\"content-ad\"></div>\n<ul>\n<li>GraphQL 프래그먼트 (UserFragment)는 여러 쿼리, 뮤테이션 또는 구독에서 사용할 수 있는 재사용 가능한 필드 세트를 정의합니다.</li>\n<li>UserFragment on User ' ... '의 프래그먼트는 User 유형에서 UserFragment라는 이름의 프래그먼트를 선언합니다.</li>\n<li>이 프래그먼트에는 id, first_name, last_name과 같은 필드가 포함되어 있습니다. ...UserFragment 스프레드를 포함하는 모든 작업은 이러한 필드를 자동으로 포함합니다.</li>\n<li>프래그먼트는 필드 정의의 중복을 피하고 코드 재사용성을 촉진하는 데 도움이 됩니다. 여러 작업이 공통 필드를 공유할 때 특히 유용합니다.</li>\n</ul>\n<p>이제 이 구독을 들어보겠습니다</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">_subscribe</span>() <span class=\"hljs-keyword\">async</span> {\n  final subscription = <span class=\"hljs-keyword\">await</span> websocketClient.<span class=\"hljs-title function_\">subscribe</span>(\n    <span class=\"hljs-title class_\">SubscriptionOptions</span>(\n      <span class=\"hljs-attr\">document</span>: userUpdatedMutation,\n    ),\n  );\n\n  subscription.<span class=\"hljs-title function_\">listen</span>((result) {\n    final userData = result.<span class=\"hljs-property\">data</span>?[<span class=\"hljs-string\">'user'</span>];\n    <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">'이름: ${userData[\"first_name\"]}'</span>);\n    <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">'성: ${userData[\"last_name\"]}'</span>);\n    <span class=\"hljs-comment\">// 실시간 업데이트 처리, 예를 들어 UI 업데이트</span>\n  });\n}\n</code></pre>\n<p>Subscription Widget도 사용할 수 있습니다.</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-attr\">body</span>: <span class=\"hljs-title class_\">Subscription</span>(\n        <span class=\"hljs-attr\">options</span>: <span class=\"hljs-title class_\">SubscriptionOptions</span>(\n        <span class=\"hljs-attr\">document</span>: userUpdatedMutation,\n        ),\n        <span class=\"hljs-attr\">builder</span>: (result) {\n          final user = result.<span class=\"hljs-property\">data</span>?[<span class=\"hljs-string\">\"user\"</span>];\n          <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">ListTile</span>(\n            <span class=\"hljs-attr\">title</span>: <span class=\"hljs-title class_\">Text</span>(user[<span class=\"hljs-string\">\"first_name\"</span>]),\n            <span class=\"hljs-attr\">subtitle</span>: <span class=\"hljs-title class_\">Text</span>(user[<span class=\"hljs-string\">\"last_name\"</span>]),\n          );\n        },\n      ),\n</code></pre>\n<h1>결론</h1>\n<p>이 가이드를 통해 플러터에서 GraphQL 구현에 대한 포괄적인 이해를 제공했습니다. 쿼리, 뮤테이션 및 구독의 기본 사항부터 실제 통합 단계에 이르기까지의 내용이 담겨 있습니다. 실시간 업데이트를 통한 GraphQL 구독에 중점을 두고 뮤테이션 작업을 시연함으로써, 개발자들은 이제 플러터 프로젝트에 GraphQL을 원활하게 통합할 수 있습니다. 이 포괄적인 리소스는 모든 수준의 개발자가 데이터 검색을 최적화하고 앱의 효율성을 향상시키며, 플러터에서 GraphQL의 강력함을 통해 동적 사용자 경험을 제공할 수 있는 기술을 제공합니다.</p>\n</body>\n</html>\n"},"__N_SSG":true}