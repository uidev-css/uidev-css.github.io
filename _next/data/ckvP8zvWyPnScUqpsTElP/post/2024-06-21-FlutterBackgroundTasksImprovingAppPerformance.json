{"pageProps":{"post":{"title":"Flutter 백그라운드 작업 앱 성능 향상 방법","description":"","date":"2024-06-21 23:32","slug":"2024-06-21-FlutterBackgroundTasksImprovingAppPerformance","content":"\n요즘의 빠르게 변화하는 디지턈 세계에서 사용자들은 모바일 어플리케이션이 효율적이고 반응성이 있기를 원합니다. 개발자들은 이러한 요구를 충족시키기 위해 어플리케이션의 성능을 향상시키기 위한 다양한 전략을 사용해야 합니다. 그 중 하나는 백그라운드 작업을 실행하는 것인데, 이를 통해 Flutter 어플리케이션이 사용자 경험을 방해하지 않으면서 고통스러운 작업을 처리할 수 있습니다. 이 블로그 글에서 Flutter의 백그라운드 작업과 중요성을 살펴보고, 구현하는 방법을 보여줄 코딩 예제를 제공해보겠습니다.\n\n## 백그라운드 작업이 중요한 이유\n\n사용자 경험이 원활하고 끊김없이 유지되려면 백그라운드 프로세스가 필수적입니다. 이를 통해 프로그래머들은 동기화, 데이터 수집, 처리와 같이 자원 집약적인 작업을 주 UI 스레드를 방해하지 않고 백그라운드에서 처리할 수 있습니다. 이러한 작업들은 백그라운드 프로세스로 이동되어 어플리케이션이 반응적으로 유지되고 사용자들에게 원활한 경험을 제공합니다.\n\n## Flutter 백그라운드 작업 구현\n\n<div class=\"content-ad\"></div>\n\n플러터는 배경 작업을 효과적으로 수행하기 위한 다양한 도구와 모듈을 제공합니다. 자주 사용되는 두 가지 방법을 살펴봅시다:\n\nIsolate를 기반으로 하는 배경 작업:\n\n메인 UI 스레드와 병렬로 작동하는 경량 별도 실행 스레드인 아이솔레이트는 배경 작업을 메인 스레드에 간섭하지 않고 수행할 수 있도록 합니다. 다음은 아이솔레이트가 배경 작업에 사용되는 예시입니다:\n\n```js\nimport 'dart:async';\nimport 'dart:isolate';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatefulWidget {\n  @override\n  _MyAppState createState() => _MyAppState();\n}\n\nclass _MyAppState extends State<MyApp> {\n  ReceivePort _port = ReceivePort();\n\n  @override\n  void initState() {\n    super.initState();\n    _startBackgroundTask();\n  }\n\n  void _startBackgroundTask() async {\n    await Isolate.spawn(_backgroundTask, _port.sendPort);\n    _port.listen((message) {\n      // 배경 작업 완료 처리\n      print('배경 작업 완료: $message');\n    });\n  }\n\n  static void _backgroundTask(SendPort sendPort) {\n    // 시간이 많이 소요되는 작업 수행\n    // ...\n\n    // 결과를 메인 UI 아이솔레이트로 전송\n    sendPort.send('작업 성공적으로 완료!');\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text('플러터의 배경 작업'),\n        ),\n        body: Center(\n          child: Text('배경 작업 실행 중...'),\n        ),\n      ),\n    );\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n플러터의 배경 작업 가져오기:\n\n앱이 닫혀 있거나 사용 중이 아닌 경우에도, 개발자는 플러터 배경 작업 가져오기 플러그인을 사용하여 주기적인 배경 작업을 계획할 수 있습니다. 이는 데이터 동기화나 앱 컨텐츠 업데이트와 같은 상황에서 유용합니다. 플러터 배경 작업 가져오기 패키지를 사용하는 예제는 다음과 같습니다:\n\n```js\nimport 'package:flutter/material.dart';\nimport 'package:flutter_background_fetch/flutter_background_fetch.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text('플러터에서 배경 작업 실행'),\n        ),\n        body: Center(\n          child: Text('배경 작업 실행 중...'),\n        ),\n      ),\n    );\n  }\n}\n\nvoid backgroundFetchHeadlessTask(String taskId) async {\n  // 여기에서 시간이 오래 걸리는 작업을 수행합니다\n  // ...\n\n  FlutterBackgroundFetch.finish(taskId);\n}\n\nvoid initBackgroundFetch() {\n  FlutterBackgroundFetch.configure(\n    minimumFetchInterval: 15,\n    stopOnTerminate: false,\n    startOnBoot: true,\n    enableHeadless: true,\n    requiresBatteryNotLow: false,\n    requiresCharging: false,\n    requiresStorageNotLow: false,\n    requiresDeviceIdle: false,\n    requiredNetworkType: NetworkType.NONE,\n  );\n  FlutterBackgroundFetch.registerHeadlessTask(backgroundFetchHeadlessTask);\n}\n```\n\n플랫폼 채널:\n\n<div class=\"content-ad\"></div>\n\n플랫폼 채널을 통해 Flutter는 네이티브 플랫폼 코드와 통신할 수 있습니다. 코틀린 또는 스위프트로 플랫폼별 코드를 작성하면 백그라운드 작업을 수행할 수 있는 플랫폼 채널을 사용할 수 있습니다. 필요한 작업은 그런 다음 네이티브 코드에서 백그라운드에서 수행될 수 있고, Flutter 앱에서 결과를 얻을 수 있습니다. 이 접근 방식으로 유연성과 플랫폼별 API에 접근할 수 있습니다.\n\n배경 작업을 실행하여 플랫폼별 코드를 사용하여 기기의 현재 위치를 획득하는 활동을 실행하려고 상상해보세요. 이렇게 플랫폼 채널이 사용되는 방법을 설명하기 위한 것입니다.\n\nFlutter 앱에서 플랫폼별 코드를 실행하는 메서드를 만들어보세요:\n\n```js\nimport 'package:flutter/services.dart';\n\nFuture<String> getCurrentLocation() async {\n  const platform = MethodChannel('your_channel_name');\n  try {\n    final String result = await platform.invokeMethod('getCurrentLocation');\n    return result;\n  } catch (e) {\n    return 'Failed to get location: $e';\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n플랫폼별 언어로 위치 검색 기능을 구현해보세요:\n\n```js\nclass MainActivity : FlutterActivity() {\n    private val CHANNEL = \"your_channel_name\"\n\n    override fun configureFlutterEngine(flutterEngine: FlutterEngine) {\n        super.configureFlutterEngine(flutterEngine)\n        MethodChannel(flutterEngine.dartExecutor.binaryMessenger, CHANNEL).setMethodCallHandler { call, result ->\n            if (call.method == \"getCurrentLocation\") {\n                // 백그라운드에서 위치를 검색합니다\n                val location = getLocation()\n                result.success(location)\n            } else {\n                result.notImplemented()\n            }\n        }\n    }\n\n    private fun getLocation(): String {\n        // 안드로이드 특화 API를 사용하여 위치를 가져옵니다\n        // ...\n        return \"위도: 20.5937, 경도: 78.9629\"\n    }\n}\n```\n\n```js\nimport UIKit\nimport Flutter\n\n@UIApplicationMain\n@objc class AppDelegate: FlutterAppDelegate {\n    let CHANNEL = \"your_channel_name\"\n\n    override func application(\n        _ application: UIApplication,\n        didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?\n    ) -> Bool {\n        let controller = window?.rootViewController as! FlutterViewController\n        let channel = FlutterMethodChannel(name: CHANNEL, binaryMessenger: controller.binaryMessenger)\n        channel.setMethodCallHandler { [weak self] call, result in\n            if call.method == \"getCurrentLocation\" {\n                // 백그라운드에서 위치를 검색합니다\n                let location = self?.getLocation() ?? \"\"\n                result(location)\n            } else {\n                result(FlutterMethodNotImplemented)\n            }\n        }\n\n        GeneratedPluginRegistrant.register(with: self)\n        return super.application(application, didFinishLaunchingWithOptions: launchOptions)\n    }\n\n    private func getLocation() -> String {\n        // iOS 특화 API를 사용하여 위치를 가져옵니다\n        // ...\n        return \"위도: 123.456, 경도: 78.901\"\n    }\n}\n```\n\nWorkManager(안드로이드) 및 BackgroundFetch(iOS)에서 사용하세요.\n\n<div class=\"content-ad\"></div>\n\n주어진 플랫폼에서 백그라운드 작업을 보다 효과적으로 처리하기 위해 WorkManager(안드로이드)와 BackgroundFetch(iOS)와 같은 플랫폼별 라이브러리를 사용할 수 있습니다. 이러한 라이브러리에는 작업 스케줄링, 반복 및 네트워크 의존 프로세스 관리, 그리고 작업이 완료되었을 때 Flutter 앱에 콜백을 제공하는 기능이 포함되어 있습니다.\n\n만약 이 방법을 보여주기 위해 서버에서 데이터를 정기적으로 다운로드하는 백그라운드 활동을 예약하려고 한다면 다음과 같이 할 수 있습니다.\n\nWorkManager를 사용하기 위해 android/app/build.gradle 파일에 필요한 종속성을 추가하세요:\n\n```js\ndependencies {\n    def work_version = \"2.6.0\"\n\n    implementation \"androidx.work:work-runtime:$work_version\"\n}\n```\n\n<div class=\"content-ad\"></div>\n\n워커 클래스를 만들어 백그라운드 작업을 설명해 보겠습니다:\n\n```js\n// 플러터 측\nimport 'package:flutter_background_fetch/flutter_background_fetch.dart';\n\nvoid initBackgroundFetch() {\n  FlutterBackgroundFetch.configure(\n    minimumFetchInterval: 15,\n    stopOnTerminate: false,\n    startOnBoot: true,\n    enableHeadless: true,\n    requiresBatteryNotLow: false,\n    requiresCharging: false,\n    requiresStorageNotLow: false,\n    requiresDeviceIdle: false,\n    requiredNetworkType: NetworkType.NONE,\n  );\n  FlutterBackgroundFetch.registerHeadlessTask(backgroundFetchHeadlessTask);\n}\n\nvoid backgroundFetchHeadlessTask(String taskId) async {\n  // 여기서 시간이 많이 소요되는 작업(예: 데이터 가져오기)을 수행합니다\n  // ...\n\n  FlutterBackgroundFetch.finish(taskId);\n}\n```\n\nBackgroundFetch를 사용하려면 pubspec.yaml 파일에 다음 종속성을 추가하세요:\n\n```js\ndependencies:\n  background_fetch: ^0.9.0\n```\n\n<div class=\"content-ad\"></div>\n\n다음 백그라운드 작업을 구현해보세요:\n\n```js\n// 플러터 측\nimport 'package:flutter/material.dart';\nimport 'package:background_fetch/background_fetch.dart';\n\nvoid main() {\n  runApp(MyApp());\n  initBackgroundFetch();\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text('Flutter에서 백그라운드 작업'),\n        ),\n        body: Center(\n          child: Text('백그라운드 작업 실행 중...'),\n        ),\n      ),\n    );\n  }\n}\n\nvoid initBackgroundFetch() {\n  BackgroundFetch.configure(\n    BackgroundFetchConfig(\n      minimumFetchInterval: 15,\n      stopOnTerminate: false,\n      startOnBoot: true,\n      enableHeadless: true,\n    ),\n    (String taskId) async {\n      // 여기서 시간이 많이 소요되는 작업(예: 데이터 가져오기) 수행하기\n      // ...\n\n      BackgroundFetch.finish(taskId);\n    },\n  );\n}\n```\n\n## 타이머:\n\n항상 번거로운 백그라운드 작업을 실행할 필요는 없을 수 있습니다. 대신 플러터 프로그램에 내장된 타이머를 활용할 수도 있습니다. Dart 프로그래밍 언어에는 백그라운드 작업을 계획하고 수행할 수 있는 Timer 클래스가 함께 제공되며, 플랫폼별 추가 기능이 필요하지 않은 프로젝트에 적합합니다.\n\n<div class=\"content-ad\"></div>\n\n이 예시를 위해, 플러터 앱에서 매 시간마다 공지를 표시하고 싶다고 가정해 봅시다.\n\n```js\nimport 'dart:async';\nimport 'package:flutter/material.dart';\nimport 'package:flutter_local_notifications/flutter_local_notifications.dart';\n\nvoid main() {\n  runApp(MyApp());\n  scheduleNotifications();\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text('플러터에서 백그라운드 작업하기'),\n        ),\n        body: Center(\n          child: Text('백그라운드 작업 실행 중...'),\n        ),\n      ),\n    );\n  }\n}\n\nvoid scheduleNotifications() {\n  Timer.periodic(Duration(hours: 1), (Timer timer) {\n    showNotification();\n  });\n}\n\nvoid showNotification() {\n  FlutterLocalNotificationsPlugin flutterLocalNotificationsPlugin =\n      FlutterLocalNotificationsPlugin();\n  // 플러그인 설정 초기화\n  // ...\n\n  flutterLocalNotificationsPlugin.show(\n    0,\n    '매 시간 알림',\n    '매 시간 트리거되는 알림입니다.',\n    NotificationDetails(\n      android: AndroidNotificationDetails(\n        '채널 ID',\n        '채널 이름',\n        '채널 설명',\n      ),\n      iOS: IOSNotificationDetails(),\n    ),\n  );\n}\n```\n\n## Firebase Cloud Messaging (FCM):\n\nFirebase Cloud Messaging (FCM)은 서버 이벤트에 의해 유발된 경보를 보내거나 활동을 수행하는 백그라운드 활동에 도움이 될 수 있습니다. 플러터 앱이 열리지 않거나 사용되지 않아도 FCM을 통해 서버에서 메시지를 전송할 수 있습니다. 이 신호에 응답하고 필요한 백그라운드 작업을 수행할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 예제를 기준으로 FCM 알림을 수신할 때마다 백그라운드 프로세스를 실행하려고 한다고 가정해 봅시다.\n\n```js\nimport 'package:flutter/material.dart';\nimport 'package:firebase_messaging/firebase_messaging.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text('Flutter에서 백그라운드 작업'),\n        ),\n        body: Center(\n          child: Text('백그라운드 작업 실행 중...'),\n        ),\n      ),\n    );\n  }\n}\n\nvoid initFirebaseMessaging() {\n  FirebaseMessaging messaging = FirebaseMessaging.instance;\n  messaging.configure(\n    onMessage: (message) {\n      // 메시지를 수신할 때 백그라운드 작업 수행\n      // ...\n      return;\n    },\n    onResume: (message) {\n      // 앱이 백그라운드에서 다시 활성화될 때 백그라운드 작업 수행\n      // ...\n      return;\n    },\n    onLaunch: (message) {\n      // 앱이 종료된 상태에서 다시 실행될 때 백그라운드 작업 수행\n      // ...\n      return;\n    },\n  );\n}\n```\n\n## 결론:\n\nFlutter 애플리케이션의 효율성을 향상시키는 중요한 구성 요소 중 하나는 백그라운드 활동입니다. 시간이 오래 걸리는 작업을 백그라운드에서 실행함으로써 원활한 사용자 경험을 제공하고 UI가 느려지는 것을 방지할 수 있습니다. 이 블로그 글에서는 아이솔레이트와 Flutter Background Fetch 패키지의 사용법을 살펴보았습니다. 이러한 전략을 Flutter 애플리케이션에 구현하여 앱의 속도를 향상시키고 우수한 사용자 경험을 제공할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n앱 기능과 효율성을 균형 있게 유지하기 위해 백그라운드 작업을 구현할 때 장치 자원, 배터리 수명 및 네트워크 이용량과 같은 요소를 고려하는 것이 중요합니다.\n\n## 코딩 즐기세요!!!…\n","ogImage":{"url":"/assets/img/2024-06-21-FlutterBackgroundTasksImprovingAppPerformance_0.png"},"coverImage":"/assets/img/2024-06-21-FlutterBackgroundTasksImprovingAppPerformance_0.png","tag":["Tech"],"readingTime":11},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>요즘의 빠르게 변화하는 디지턈 세계에서 사용자들은 모바일 어플리케이션이 효율적이고 반응성이 있기를 원합니다. 개발자들은 이러한 요구를 충족시키기 위해 어플리케이션의 성능을 향상시키기 위한 다양한 전략을 사용해야 합니다. 그 중 하나는 백그라운드 작업을 실행하는 것인데, 이를 통해 Flutter 어플리케이션이 사용자 경험을 방해하지 않으면서 고통스러운 작업을 처리할 수 있습니다. 이 블로그 글에서 Flutter의 백그라운드 작업과 중요성을 살펴보고, 구현하는 방법을 보여줄 코딩 예제를 제공해보겠습니다.</p>\n<h2>백그라운드 작업이 중요한 이유</h2>\n<p>사용자 경험이 원활하고 끊김없이 유지되려면 백그라운드 프로세스가 필수적입니다. 이를 통해 프로그래머들은 동기화, 데이터 수집, 처리와 같이 자원 집약적인 작업을 주 UI 스레드를 방해하지 않고 백그라운드에서 처리할 수 있습니다. 이러한 작업들은 백그라운드 프로세스로 이동되어 어플리케이션이 반응적으로 유지되고 사용자들에게 원활한 경험을 제공합니다.</p>\n<h2>Flutter 백그라운드 작업 구현</h2>\n<div class=\"content-ad\"></div>\n<p>플러터는 배경 작업을 효과적으로 수행하기 위한 다양한 도구와 모듈을 제공합니다. 자주 사용되는 두 가지 방법을 살펴봅시다:</p>\n<p>Isolate를 기반으로 하는 배경 작업:</p>\n<p>메인 UI 스레드와 병렬로 작동하는 경량 별도 실행 스레드인 아이솔레이트는 배경 작업을 메인 스레드에 간섭하지 않고 수행할 수 있도록 합니다. 다음은 아이솔레이트가 배경 작업에 사용되는 예시입니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'dart:async'</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'dart:isolate'</span>;\n\n<span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-title function_\">runApp</span>(<span class=\"hljs-title class_\">MyApp</span>());\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyApp</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">StatefulWidget</span> {\n  @override\n  _MyAppState <span class=\"hljs-title function_\">createState</span>() => <span class=\"hljs-title function_\">_MyAppState</span>();\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">_MyAppState</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">State</span>&#x3C;<span class=\"hljs-title class_\">MyApp</span>> {\n  <span class=\"hljs-title class_\">ReceivePort</span> _port = <span class=\"hljs-title class_\">ReceivePort</span>();\n\n  @override\n  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">initState</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-variable language_\">super</span>.<span class=\"hljs-title function_\">initState</span>();\n    <span class=\"hljs-title function_\">_startBackgroundTask</span>();\n  }\n\n  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">_startBackgroundTask</span>() <span class=\"hljs-keyword\">async</span> {\n    <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title class_\">Isolate</span>.<span class=\"hljs-title function_\">spawn</span>(_backgroundTask, _port.<span class=\"hljs-property\">sendPort</span>);\n    _port.<span class=\"hljs-title function_\">listen</span>((message) {\n      <span class=\"hljs-comment\">// 배경 작업 완료 처리</span>\n      <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">'배경 작업 완료: $message'</span>);\n    });\n  }\n\n  <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">_backgroundTask</span>(<span class=\"hljs-params\">SendPort sendPort</span>) {\n    <span class=\"hljs-comment\">// 시간이 많이 소요되는 작업 수행</span>\n    <span class=\"hljs-comment\">// ...</span>\n\n    <span class=\"hljs-comment\">// 결과를 메인 UI 아이솔레이트로 전송</span>\n    sendPort.<span class=\"hljs-title function_\">send</span>(<span class=\"hljs-string\">'작업 성공적으로 완료!'</span>);\n  }\n\n  @override\n  <span class=\"hljs-title class_\">Widget</span> <span class=\"hljs-title function_\">build</span>(<span class=\"hljs-params\">BuildContext context</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">MaterialApp</span>(\n      <span class=\"hljs-attr\">home</span>: <span class=\"hljs-title class_\">Scaffold</span>(\n        <span class=\"hljs-attr\">appBar</span>: <span class=\"hljs-title class_\">AppBar</span>(\n          <span class=\"hljs-attr\">title</span>: <span class=\"hljs-title class_\">Text</span>(<span class=\"hljs-string\">'플러터의 배경 작업'</span>),\n        ),\n        <span class=\"hljs-attr\">body</span>: <span class=\"hljs-title class_\">Center</span>(\n          <span class=\"hljs-attr\">child</span>: <span class=\"hljs-title class_\">Text</span>(<span class=\"hljs-string\">'배경 작업 실행 중...'</span>),\n        ),\n      ),\n    );\n  }\n}\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>플러터의 배경 작업 가져오기:</p>\n<p>앱이 닫혀 있거나 사용 중이 아닌 경우에도, 개발자는 플러터 배경 작업 가져오기 플러그인을 사용하여 주기적인 배경 작업을 계획할 수 있습니다. 이는 데이터 동기화나 앱 컨텐츠 업데이트와 같은 상황에서 유용합니다. 플러터 배경 작업 가져오기 패키지를 사용하는 예제는 다음과 같습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'package:flutter/material.dart'</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'package:flutter_background_fetch/flutter_background_fetch.dart'</span>;\n\n<span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-title function_\">runApp</span>(<span class=\"hljs-title class_\">MyApp</span>());\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyApp</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">StatelessWidget</span> {\n  @override\n  <span class=\"hljs-title class_\">Widget</span> <span class=\"hljs-title function_\">build</span>(<span class=\"hljs-params\">BuildContext context</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">MaterialApp</span>(\n      <span class=\"hljs-attr\">home</span>: <span class=\"hljs-title class_\">Scaffold</span>(\n        <span class=\"hljs-attr\">appBar</span>: <span class=\"hljs-title class_\">AppBar</span>(\n          <span class=\"hljs-attr\">title</span>: <span class=\"hljs-title class_\">Text</span>(<span class=\"hljs-string\">'플러터에서 배경 작업 실행'</span>),\n        ),\n        <span class=\"hljs-attr\">body</span>: <span class=\"hljs-title class_\">Center</span>(\n          <span class=\"hljs-attr\">child</span>: <span class=\"hljs-title class_\">Text</span>(<span class=\"hljs-string\">'배경 작업 실행 중...'</span>),\n        ),\n      ),\n    );\n  }\n}\n\n<span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">backgroundFetchHeadlessTask</span>(<span class=\"hljs-title class_\">String</span> taskId) <span class=\"hljs-keyword\">async</span> {\n  <span class=\"hljs-comment\">// 여기에서 시간이 오래 걸리는 작업을 수행합니다</span>\n  <span class=\"hljs-comment\">// ...</span>\n\n  <span class=\"hljs-title class_\">FlutterBackgroundFetch</span>.<span class=\"hljs-title function_\">finish</span>(taskId);\n}\n\n<span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">initBackgroundFetch</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-title class_\">FlutterBackgroundFetch</span>.<span class=\"hljs-title function_\">configure</span>(\n    <span class=\"hljs-attr\">minimumFetchInterval</span>: <span class=\"hljs-number\">15</span>,\n    <span class=\"hljs-attr\">stopOnTerminate</span>: <span class=\"hljs-literal\">false</span>,\n    <span class=\"hljs-attr\">startOnBoot</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">enableHeadless</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">requiresBatteryNotLow</span>: <span class=\"hljs-literal\">false</span>,\n    <span class=\"hljs-attr\">requiresCharging</span>: <span class=\"hljs-literal\">false</span>,\n    <span class=\"hljs-attr\">requiresStorageNotLow</span>: <span class=\"hljs-literal\">false</span>,\n    <span class=\"hljs-attr\">requiresDeviceIdle</span>: <span class=\"hljs-literal\">false</span>,\n    <span class=\"hljs-attr\">requiredNetworkType</span>: <span class=\"hljs-title class_\">NetworkType</span>.<span class=\"hljs-property\">NONE</span>,\n  );\n  <span class=\"hljs-title class_\">FlutterBackgroundFetch</span>.<span class=\"hljs-title function_\">registerHeadlessTask</span>(backgroundFetchHeadlessTask);\n}\n</code></pre>\n<p>플랫폼 채널:</p>\n<div class=\"content-ad\"></div>\n<p>플랫폼 채널을 통해 Flutter는 네이티브 플랫폼 코드와 통신할 수 있습니다. 코틀린 또는 스위프트로 플랫폼별 코드를 작성하면 백그라운드 작업을 수행할 수 있는 플랫폼 채널을 사용할 수 있습니다. 필요한 작업은 그런 다음 네이티브 코드에서 백그라운드에서 수행될 수 있고, Flutter 앱에서 결과를 얻을 수 있습니다. 이 접근 방식으로 유연성과 플랫폼별 API에 접근할 수 있습니다.</p>\n<p>배경 작업을 실행하여 플랫폼별 코드를 사용하여 기기의 현재 위치를 획득하는 활동을 실행하려고 상상해보세요. 이렇게 플랫폼 채널이 사용되는 방법을 설명하기 위한 것입니다.</p>\n<p>Flutter 앱에서 플랫폼별 코드를 실행하는 메서드를 만들어보세요:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'package:flutter/services.dart'</span>;\n\n<span class=\"hljs-title class_\">Future</span>&#x3C;<span class=\"hljs-title class_\">String</span>> <span class=\"hljs-title function_\">getCurrentLocation</span>() <span class=\"hljs-keyword\">async</span> {\n  <span class=\"hljs-keyword\">const</span> platform = <span class=\"hljs-title class_\">MethodChannel</span>(<span class=\"hljs-string\">'your_channel_name'</span>);\n  <span class=\"hljs-keyword\">try</span> {\n    final <span class=\"hljs-title class_\">String</span> result = <span class=\"hljs-keyword\">await</span> platform.<span class=\"hljs-title function_\">invokeMethod</span>(<span class=\"hljs-string\">'getCurrentLocation'</span>);\n    <span class=\"hljs-keyword\">return</span> result;\n  } <span class=\"hljs-keyword\">catch</span> (e) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'Failed to get location: $e'</span>;\n  }\n}\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>플랫폼별 언어로 위치 검색 기능을 구현해보세요:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MainActivity</span> : <span class=\"hljs-title class_\">FlutterActivity</span>() {\n    private val <span class=\"hljs-variable constant_\">CHANNEL</span> = <span class=\"hljs-string\">\"your_channel_name\"</span>\n\n    override fun <span class=\"hljs-title function_\">configureFlutterEngine</span>(<span class=\"hljs-params\">flutterEngine: FlutterEngine</span>) {\n        <span class=\"hljs-variable language_\">super</span>.<span class=\"hljs-title function_\">configureFlutterEngine</span>(flutterEngine)\n        <span class=\"hljs-title class_\">MethodChannel</span>(flutterEngine.<span class=\"hljs-property\">dartExecutor</span>.<span class=\"hljs-property\">binaryMessenger</span>, <span class=\"hljs-variable constant_\">CHANNEL</span>).<span class=\"hljs-property\">setMethodCallHandler</span> { call, result ->\n            <span class=\"hljs-keyword\">if</span> (call.<span class=\"hljs-property\">method</span> == <span class=\"hljs-string\">\"getCurrentLocation\"</span>) {\n                <span class=\"hljs-comment\">// 백그라운드에서 위치를 검색합니다</span>\n                val location = <span class=\"hljs-title function_\">getLocation</span>()\n                result.<span class=\"hljs-title function_\">success</span>(location)\n            } <span class=\"hljs-keyword\">else</span> {\n                result.<span class=\"hljs-title function_\">notImplemented</span>()\n            }\n        }\n    }\n\n    private fun <span class=\"hljs-title function_\">getLocation</span>(): <span class=\"hljs-title class_\">String</span> {\n        <span class=\"hljs-comment\">// 안드로이드 특화 API를 사용하여 위치를 가져옵니다</span>\n        <span class=\"hljs-comment\">// ...</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"위도: 20.5937, 경도: 78.9629\"</span>\n    }\n}\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">UIKit</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Flutter</span>\n\n@<span class=\"hljs-title class_\">UIApplicationMain</span>\n@objc <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AppDelegate</span>: <span class=\"hljs-title class_\">FlutterAppDelegate</span> {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable constant_\">CHANNEL</span> = <span class=\"hljs-string\">\"your_channel_name\"</span>\n\n    override func <span class=\"hljs-title function_\">application</span>(\n        _ <span class=\"hljs-attr\">application</span>: <span class=\"hljs-title class_\">UIApplication</span>,\n        didFinishLaunchingWithOptions <span class=\"hljs-attr\">launchOptions</span>: [<span class=\"hljs-title class_\">UIApplication</span>.<span class=\"hljs-property\">LaunchOptionsKey</span>: <span class=\"hljs-title class_\">Any</span>]?\n    ) -> <span class=\"hljs-title class_\">Bool</span> {\n        <span class=\"hljs-keyword\">let</span> controller = <span class=\"hljs-variable language_\">window</span>?.<span class=\"hljs-property\">rootViewController</span> <span class=\"hljs-keyword\">as</span>! <span class=\"hljs-title class_\">FlutterViewController</span>\n        <span class=\"hljs-keyword\">let</span> channel = <span class=\"hljs-title class_\">FlutterMethodChannel</span>(<span class=\"hljs-attr\">name</span>: <span class=\"hljs-variable constant_\">CHANNEL</span>, <span class=\"hljs-attr\">binaryMessenger</span>: controller.<span class=\"hljs-property\">binaryMessenger</span>)\n        channel.<span class=\"hljs-property\">setMethodCallHandler</span> { [weak self] call, result <span class=\"hljs-keyword\">in</span>\n            <span class=\"hljs-keyword\">if</span> call.<span class=\"hljs-property\">method</span> == <span class=\"hljs-string\">\"getCurrentLocation\"</span> {\n                <span class=\"hljs-comment\">// 백그라운드에서 위치를 검색합니다</span>\n                <span class=\"hljs-keyword\">let</span> location = self?.<span class=\"hljs-title function_\">getLocation</span>() ?? <span class=\"hljs-string\">\"\"</span>\n                <span class=\"hljs-title function_\">result</span>(location)\n            } <span class=\"hljs-keyword\">else</span> {\n                <span class=\"hljs-title function_\">result</span>(<span class=\"hljs-title class_\">FlutterMethodNotImplemented</span>)\n            }\n        }\n\n        <span class=\"hljs-title class_\">GeneratedPluginRegistrant</span>.<span class=\"hljs-title function_\">register</span>(<span class=\"hljs-attr\">with</span>: self)\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">super</span>.<span class=\"hljs-title function_\">application</span>(application, <span class=\"hljs-attr\">didFinishLaunchingWithOptions</span>: launchOptions)\n    }\n\n    private func <span class=\"hljs-title function_\">getLocation</span>() -> <span class=\"hljs-title class_\">String</span> {\n        <span class=\"hljs-comment\">// iOS 특화 API를 사용하여 위치를 가져옵니다</span>\n        <span class=\"hljs-comment\">// ...</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"위도: 123.456, 경도: 78.901\"</span>\n    }\n}\n</code></pre>\n<p>WorkManager(안드로이드) 및 BackgroundFetch(iOS)에서 사용하세요.</p>\n<div class=\"content-ad\"></div>\n<p>주어진 플랫폼에서 백그라운드 작업을 보다 효과적으로 처리하기 위해 WorkManager(안드로이드)와 BackgroundFetch(iOS)와 같은 플랫폼별 라이브러리를 사용할 수 있습니다. 이러한 라이브러리에는 작업 스케줄링, 반복 및 네트워크 의존 프로세스 관리, 그리고 작업이 완료되었을 때 Flutter 앱에 콜백을 제공하는 기능이 포함되어 있습니다.</p>\n<p>만약 이 방법을 보여주기 위해 서버에서 데이터를 정기적으로 다운로드하는 백그라운드 활동을 예약하려고 한다면 다음과 같이 할 수 있습니다.</p>\n<p>WorkManager를 사용하기 위해 android/app/build.gradle 파일에 필요한 종속성을 추가하세요:</p>\n<pre><code class=\"hljs language-js\">dependencies {\n    def work_version = <span class=\"hljs-string\">\"2.6.0\"</span>\n\n    implementation <span class=\"hljs-string\">\"androidx.work:work-runtime:$work_version\"</span>\n}\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>워커 클래스를 만들어 백그라운드 작업을 설명해 보겠습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 플러터 측</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'package:flutter_background_fetch/flutter_background_fetch.dart'</span>;\n\n<span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">initBackgroundFetch</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-title class_\">FlutterBackgroundFetch</span>.<span class=\"hljs-title function_\">configure</span>(\n    <span class=\"hljs-attr\">minimumFetchInterval</span>: <span class=\"hljs-number\">15</span>,\n    <span class=\"hljs-attr\">stopOnTerminate</span>: <span class=\"hljs-literal\">false</span>,\n    <span class=\"hljs-attr\">startOnBoot</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">enableHeadless</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">requiresBatteryNotLow</span>: <span class=\"hljs-literal\">false</span>,\n    <span class=\"hljs-attr\">requiresCharging</span>: <span class=\"hljs-literal\">false</span>,\n    <span class=\"hljs-attr\">requiresStorageNotLow</span>: <span class=\"hljs-literal\">false</span>,\n    <span class=\"hljs-attr\">requiresDeviceIdle</span>: <span class=\"hljs-literal\">false</span>,\n    <span class=\"hljs-attr\">requiredNetworkType</span>: <span class=\"hljs-title class_\">NetworkType</span>.<span class=\"hljs-property\">NONE</span>,\n  );\n  <span class=\"hljs-title class_\">FlutterBackgroundFetch</span>.<span class=\"hljs-title function_\">registerHeadlessTask</span>(backgroundFetchHeadlessTask);\n}\n\n<span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">backgroundFetchHeadlessTask</span>(<span class=\"hljs-title class_\">String</span> taskId) <span class=\"hljs-keyword\">async</span> {\n  <span class=\"hljs-comment\">// 여기서 시간이 많이 소요되는 작업(예: 데이터 가져오기)을 수행합니다</span>\n  <span class=\"hljs-comment\">// ...</span>\n\n  <span class=\"hljs-title class_\">FlutterBackgroundFetch</span>.<span class=\"hljs-title function_\">finish</span>(taskId);\n}\n</code></pre>\n<p>BackgroundFetch를 사용하려면 pubspec.yaml 파일에 다음 종속성을 추가하세요:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-attr\">dependencies</span>:\n  <span class=\"hljs-attr\">background_fetch</span>: ^<span class=\"hljs-number\">0.9</span><span class=\"hljs-number\">.0</span>\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>다음 백그라운드 작업을 구현해보세요:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 플러터 측</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'package:flutter/material.dart'</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'package:background_fetch/background_fetch.dart'</span>;\n\n<span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-title function_\">runApp</span>(<span class=\"hljs-title class_\">MyApp</span>());\n  <span class=\"hljs-title function_\">initBackgroundFetch</span>();\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyApp</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">StatelessWidget</span> {\n  @override\n  <span class=\"hljs-title class_\">Widget</span> <span class=\"hljs-title function_\">build</span>(<span class=\"hljs-params\">BuildContext context</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">MaterialApp</span>(\n      <span class=\"hljs-attr\">home</span>: <span class=\"hljs-title class_\">Scaffold</span>(\n        <span class=\"hljs-attr\">appBar</span>: <span class=\"hljs-title class_\">AppBar</span>(\n          <span class=\"hljs-attr\">title</span>: <span class=\"hljs-title class_\">Text</span>(<span class=\"hljs-string\">'Flutter에서 백그라운드 작업'</span>),\n        ),\n        <span class=\"hljs-attr\">body</span>: <span class=\"hljs-title class_\">Center</span>(\n          <span class=\"hljs-attr\">child</span>: <span class=\"hljs-title class_\">Text</span>(<span class=\"hljs-string\">'백그라운드 작업 실행 중...'</span>),\n        ),\n      ),\n    );\n  }\n}\n\n<span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">initBackgroundFetch</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-title class_\">BackgroundFetch</span>.<span class=\"hljs-title function_\">configure</span>(\n    <span class=\"hljs-title class_\">BackgroundFetchConfig</span>(\n      <span class=\"hljs-attr\">minimumFetchInterval</span>: <span class=\"hljs-number\">15</span>,\n      <span class=\"hljs-attr\">stopOnTerminate</span>: <span class=\"hljs-literal\">false</span>,\n      <span class=\"hljs-attr\">startOnBoot</span>: <span class=\"hljs-literal\">true</span>,\n      <span class=\"hljs-attr\">enableHeadless</span>: <span class=\"hljs-literal\">true</span>,\n    ),\n    (<span class=\"hljs-title class_\">String</span> taskId) <span class=\"hljs-keyword\">async</span> {\n      <span class=\"hljs-comment\">// 여기서 시간이 많이 소요되는 작업(예: 데이터 가져오기) 수행하기</span>\n      <span class=\"hljs-comment\">// ...</span>\n\n      <span class=\"hljs-title class_\">BackgroundFetch</span>.<span class=\"hljs-title function_\">finish</span>(taskId);\n    },\n  );\n}\n</code></pre>\n<h2>타이머:</h2>\n<p>항상 번거로운 백그라운드 작업을 실행할 필요는 없을 수 있습니다. 대신 플러터 프로그램에 내장된 타이머를 활용할 수도 있습니다. Dart 프로그래밍 언어에는 백그라운드 작업을 계획하고 수행할 수 있는 Timer 클래스가 함께 제공되며, 플랫폼별 추가 기능이 필요하지 않은 프로젝트에 적합합니다.</p>\n<div class=\"content-ad\"></div>\n<p>이 예시를 위해, 플러터 앱에서 매 시간마다 공지를 표시하고 싶다고 가정해 봅시다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'dart:async'</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'package:flutter/material.dart'</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'package:flutter_local_notifications/flutter_local_notifications.dart'</span>;\n\n<span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-title function_\">runApp</span>(<span class=\"hljs-title class_\">MyApp</span>());\n  <span class=\"hljs-title function_\">scheduleNotifications</span>();\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyApp</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">StatelessWidget</span> {\n  @override\n  <span class=\"hljs-title class_\">Widget</span> <span class=\"hljs-title function_\">build</span>(<span class=\"hljs-params\">BuildContext context</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">MaterialApp</span>(\n      <span class=\"hljs-attr\">home</span>: <span class=\"hljs-title class_\">Scaffold</span>(\n        <span class=\"hljs-attr\">appBar</span>: <span class=\"hljs-title class_\">AppBar</span>(\n          <span class=\"hljs-attr\">title</span>: <span class=\"hljs-title class_\">Text</span>(<span class=\"hljs-string\">'플러터에서 백그라운드 작업하기'</span>),\n        ),\n        <span class=\"hljs-attr\">body</span>: <span class=\"hljs-title class_\">Center</span>(\n          <span class=\"hljs-attr\">child</span>: <span class=\"hljs-title class_\">Text</span>(<span class=\"hljs-string\">'백그라운드 작업 실행 중...'</span>),\n        ),\n      ),\n    );\n  }\n}\n\n<span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">scheduleNotifications</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-title class_\">Timer</span>.<span class=\"hljs-title function_\">periodic</span>(<span class=\"hljs-title class_\">Duration</span>(<span class=\"hljs-attr\">hours</span>: <span class=\"hljs-number\">1</span>), (<span class=\"hljs-title class_\">Timer</span> timer) {\n    <span class=\"hljs-title function_\">showNotification</span>();\n  });\n}\n\n<span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">showNotification</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-title class_\">FlutterLocalNotificationsPlugin</span> flutterLocalNotificationsPlugin =\n      <span class=\"hljs-title class_\">FlutterLocalNotificationsPlugin</span>();\n  <span class=\"hljs-comment\">// 플러그인 설정 초기화</span>\n  <span class=\"hljs-comment\">// ...</span>\n\n  flutterLocalNotificationsPlugin.<span class=\"hljs-title function_\">show</span>(\n    <span class=\"hljs-number\">0</span>,\n    <span class=\"hljs-string\">'매 시간 알림'</span>,\n    <span class=\"hljs-string\">'매 시간 트리거되는 알림입니다.'</span>,\n    <span class=\"hljs-title class_\">NotificationDetails</span>(\n      <span class=\"hljs-attr\">android</span>: <span class=\"hljs-title class_\">AndroidNotificationDetails</span>(\n        <span class=\"hljs-string\">'채널 ID'</span>,\n        <span class=\"hljs-string\">'채널 이름'</span>,\n        <span class=\"hljs-string\">'채널 설명'</span>,\n      ),\n      <span class=\"hljs-attr\">iOS</span>: <span class=\"hljs-title class_\">IOSNotificationDetails</span>(),\n    ),\n  );\n}\n</code></pre>\n<h2>Firebase Cloud Messaging (FCM):</h2>\n<p>Firebase Cloud Messaging (FCM)은 서버 이벤트에 의해 유발된 경보를 보내거나 활동을 수행하는 백그라운드 활동에 도움이 될 수 있습니다. 플러터 앱이 열리지 않거나 사용되지 않아도 FCM을 통해 서버에서 메시지를 전송할 수 있습니다. 이 신호에 응답하고 필요한 백그라운드 작업을 수행할 수 있습니다.</p>\n<div class=\"content-ad\"></div>\n<p>이 예제를 기준으로 FCM 알림을 수신할 때마다 백그라운드 프로세스를 실행하려고 한다고 가정해 봅시다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'package:flutter/material.dart'</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'package:firebase_messaging/firebase_messaging.dart'</span>;\n\n<span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-title function_\">runApp</span>(<span class=\"hljs-title class_\">MyApp</span>());\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyApp</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">StatelessWidget</span> {\n  @override\n  <span class=\"hljs-title class_\">Widget</span> <span class=\"hljs-title function_\">build</span>(<span class=\"hljs-params\">BuildContext context</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">MaterialApp</span>(\n      <span class=\"hljs-attr\">home</span>: <span class=\"hljs-title class_\">Scaffold</span>(\n        <span class=\"hljs-attr\">appBar</span>: <span class=\"hljs-title class_\">AppBar</span>(\n          <span class=\"hljs-attr\">title</span>: <span class=\"hljs-title class_\">Text</span>(<span class=\"hljs-string\">'Flutter에서 백그라운드 작업'</span>),\n        ),\n        <span class=\"hljs-attr\">body</span>: <span class=\"hljs-title class_\">Center</span>(\n          <span class=\"hljs-attr\">child</span>: <span class=\"hljs-title class_\">Text</span>(<span class=\"hljs-string\">'백그라운드 작업 실행 중...'</span>),\n        ),\n      ),\n    );\n  }\n}\n\n<span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">initFirebaseMessaging</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-title class_\">FirebaseMessaging</span> messaging = <span class=\"hljs-title class_\">FirebaseMessaging</span>.<span class=\"hljs-property\">instance</span>;\n  messaging.<span class=\"hljs-title function_\">configure</span>(\n    <span class=\"hljs-attr\">onMessage</span>: (message) {\n      <span class=\"hljs-comment\">// 메시지를 수신할 때 백그라운드 작업 수행</span>\n      <span class=\"hljs-comment\">// ...</span>\n      <span class=\"hljs-keyword\">return</span>;\n    },\n    <span class=\"hljs-attr\">onResume</span>: (message) {\n      <span class=\"hljs-comment\">// 앱이 백그라운드에서 다시 활성화될 때 백그라운드 작업 수행</span>\n      <span class=\"hljs-comment\">// ...</span>\n      <span class=\"hljs-keyword\">return</span>;\n    },\n    <span class=\"hljs-attr\">onLaunch</span>: (message) {\n      <span class=\"hljs-comment\">// 앱이 종료된 상태에서 다시 실행될 때 백그라운드 작업 수행</span>\n      <span class=\"hljs-comment\">// ...</span>\n      <span class=\"hljs-keyword\">return</span>;\n    },\n  );\n}\n</code></pre>\n<h2>결론:</h2>\n<p>Flutter 애플리케이션의 효율성을 향상시키는 중요한 구성 요소 중 하나는 백그라운드 활동입니다. 시간이 오래 걸리는 작업을 백그라운드에서 실행함으로써 원활한 사용자 경험을 제공하고 UI가 느려지는 것을 방지할 수 있습니다. 이 블로그 글에서는 아이솔레이트와 Flutter Background Fetch 패키지의 사용법을 살펴보았습니다. 이러한 전략을 Flutter 애플리케이션에 구현하여 앱의 속도를 향상시키고 우수한 사용자 경험을 제공할 수 있습니다.</p>\n<div class=\"content-ad\"></div>\n<p>앱 기능과 효율성을 균형 있게 유지하기 위해 백그라운드 작업을 구현할 때 장치 자원, 배터리 수명 및 네트워크 이용량과 같은 요소를 고려하는 것이 중요합니다.</p>\n<h2>코딩 즐기세요!!!…</h2>\n</body>\n</html>\n"},"__N_SSG":true}