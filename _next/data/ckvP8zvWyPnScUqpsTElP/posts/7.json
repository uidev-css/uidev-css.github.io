{"pageProps":{"posts":[{"title":"NET C에서 SOLID 원칙 이해하기 코드 예시와 함께하는 실용 가이드","description":"","date":"2024-06-22 04:25","slug":"2024-06-22-UnderstandingSOLIDPrinciplesinNETCAPracticalGuidewithCodeExamples","content":"\n\nSOLID 원칙은 개발자가 쉽게 확장 가능한 코드를 작성하고 일반적인 코딩 오류를 피할 수 있게 도와줍니다.\n\n이 원칙들은 Robert C. Martin에 의해 소개되었으며 객체 지향 프로그래밍의 기본 요소가 되었습니다.\n\n.NET 개발에서 SOLID 원칙을 준수하면 코드가 더 모듈식, 유연하고 유지보수하기 쉬워질 수 있습니다. 이 글에서는 C#에서 실제 코딩 예제와 함께 각 SOLID 원칙을 자세히 살펴볼 것입니다.\n\n다음은 다섯 가지 SOLID 디자인 원칙입니다:\n\n<div class=\"content-ad\"></div>\n\n\n![Image](/assets/img/2024-06-22-UnderstandingSOLIDPrinciplesinNETCAPracticalGuidewithCodeExamples_0.png)\n\n# 1. 단일 책임 원칙 (SRP)\n\nSRP는 클래스가 변경되어야 하는 이유가 하나만 있어야 한다는 것을 말합니다. 즉, 하나의 책임만을 가져야 합니다. 이는 모듈화를 촉진하고 코드를 이해하고 유지보수하기 쉽게 만듭니다.\n\n주요 아이디어: 클래스는 한 가지 일만을 해야 하며, 그 일을 잘 수행해야 합니다.\n\n\n<div class=\"content-ad\"></div>\n\n실시간 예시: 레스토랑을 운영하거나 음식을 배달하는 것에만 전념하는 요리사를 생각해보세요.\n\nC#에서의 실용적인 코딩 예시:\n\nSRP를 적용하기 전:\n\n```js\npublic class Report\n{\n    public void GenerateReport() { }\n    public void SaveToFile() { }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 시나리오에서 Report 클래스는 리포트를 생성하고 파일로 저장하는 두 가지 책임을 갖고 있습니다. 이는 SRP를 위반합니다.\n\nSRP 적용 후:\n\n```js\npublic class Report\n{\n    public void GenerateReport() { }\n}\n\npublic class ReportSaver\n{\n    public void SaveToFile() { }\n}\n```\n\n이제 Report 클래스는 리포트 생성에만 책임이 있고, ReportSaver 클래스는 리포트 저장에 책임이 있습니다. 각 클래스는 단일 책임을 갖습니다.\n\n<div class=\"content-ad\"></div>\n\n해석: SRP에 따르면, 한 클래스는 하나의 책임을 가져야합니다. 이 문제를 해결하기 위해 보고서 기능을 저장하기 위해 다른 클래스를 작성해야 합니다. 이 때 Report 클래스를 수정해도 ReportSaver 클래스에는 영향을 미치지 않습니다.\n\n## 2. 개방/폐쇄 원칙 (OCP)\n\n개방/폐쇄 원칙은 클래스가 확장에 대해 열려 있어야 하지만 수정에 대해서는 닫혀 있어야 한다고 제안합니다. 이것은 기존 코드를 변경하지 않고 새로운 기능을 추가할 수 있다는 것을 의미합니다.\n\n주요 아이디어: 한 번 클래스를 작성하면 수정하는 것은 닫혀 있고, 확장하는 것은 열려 있어야 합니다.\n\n<div class=\"content-ad\"></div>\n\n실시간 예시: 당신의 스마트폰 - 기능을 추가하려면 열지 않고도 앱을 다운로드하여 능력을 확장할 수 있습니다.\n\nC#에서의 실용적인 코딩 예시:\n\nOCP 신청 전:\n\n```js\npublic class Rectangle\n{\n    public double Width { get; set; }\n    public double Height { get; set; }\n}\n\npublic class AreaCalculator\n{\n    public double CalculateArea(Rectangle rectangle)\n    {\n        return rectangle.Width * rectangle.Height;\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n새로운 도형을 추가할 때 이 디자인은 문제가 될 수 있습니다. 각 새로운 도형에 대해 AreaCalculator를 수정하면 OCP를 위반하게 됩니다.\n\nOCP를 적용한 후:\n\n```js\npublic interface IShape\n{\n    double CalculateArea();\n}\n\npublic class Rectangle : IShape\n{\n    // 구현\n}\n\npublic class Circle : IShape\n{\n    // 구현\n}\n```\n\n인터페이스(IShape)를 도입하여 기존 코드를 수정하지 않고도 새로운 도형(예: Circle)을 추가할 수 있습니다. OCP를 준수하는 방법입니다.\n\n<div class=\"content-ad\"></div>\n\nOCP에 따르면 클래스는 확장에 열려 있지만 수정에 대해 닫혀 있어야 합니다. 새로운 모양을 도입할 때는 그냥 인터페이스 IShape를 구현하면 됩니다. 그러면 IShape은 확장이 가능하지만 추가 수정은 불가능해집니다.\n\n## 3. 리스코프 치환 원칙 (LSP)\n\n리스코프 치환 원칙은 슈퍼클래스의 객체를 하위 클래스의 객체로 대체할 수 있어야 하며 프로그램의 정확성에 영향을 미치지 않아야 한다는 원칙입니다.\n\n주요 아이디어: 부모 클래스를 사용하는 곳에 하위 클래스를 사용할 수 있어야 합니다.\n\n<div class=\"content-ad\"></div>\n\n실시간 예시: 여러 브랜드의 TV에 모두 작동하는 원격 제어기를 가지고 있습니다.\n\nC#에서의 실용적인 코딩 예시:\n\nLSP를 적용하기 전:\n\n```csharp\npublic class Bird\n{\n    public virtual void Fly() { /* 구현 */ }\n}\n\npublic class Penguin : Bird\n{\n    public override void Fly()\n    {\n        throw new NotImplementedException(\"펭귄은 날지 못해요!\");\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n여기서 펭귄 클래스는 Fly 메서드에 예외를 발생시켜 LSP를 위반합니다.\n\nLSP를 적용한 후:\n\n```js\npublic interface IFlyable\n{\n    void Fly();\n}\n\npublic class Bird : IFlyable\n{\n    public void Fly()\n    {\n        // Bird에 특화된 구현\n    }\n}\n\npublic class Penguin : IFlyable\n{\n    public void Fly()\n    {\n        // 펭귄에 특화된 구현\n        throw new NotImplementedException(\"펭귄은 날지 못해요!\");\n    }\n}\n```\n\nIFlyable 인터페이스를 도입함으로써, Bird와 Penguin은 릴스코프 치환 원칙을 준수하게 되었습니다.\n\n<div class=\"content-ad\"></div>\n\n설명: LSP에 따르면 파생 클래스는 기본 클래스의 유형 정의와 동작을 깨뜨리지 않아야 합니다. 이는 기본 클래스의 객체를 파생 클래스의 객체로 교체해도 응용 프로그램이 깨지지 않아야 함을 의미합니다. 이는 파생 클래스의 객체가 기본 클래스의 객체와 동일한 방식으로 동작해야 한다는 것을 필요로 합니다.\n\n# 4. Interface Segregation Principle (ISP)\n\n인터페이스 분리 원칙은 클래스가 사용하지 않는 인터페이스를 강제로 구현하도록 해서는 안 된다고 말합니다. 이 원칙은 작고 특정 클라이언트용 인터페이스를 생성하는 것을 권장합니다.\n\n주요 아이디어: 클래스는 사용하지 않는 인터페이스를 구현하도록 강제되어서는 안 됩니다.\n\n<div class=\"content-ad\"></div>\n\n실시간 예시: 음악 스트리밍 서비스에 가입하여 좋아하는 장르만 선택하는 상황을 상상해보세요.\n\nC#에서의 실제 코딩 예시:\n\nISP 신청 전:\n\n```js\npublic interface IWorker\n{\n    void Work();\n    void Eat();\n}\n\npublic class Manager : IWorker\n{\n    // 구현\n}\n\npublic class Robot : IWorker\n{\n    // 구현\n}\n```\n\n<div class=\"content-ad\"></div>\n\n로봇 클래스는 ISP를 위반하지 않도록 먹는 방법을 구현해야 합니다.\n\nISP를 적용한 후:\n\n```js\npublic interface IWorkable\n{\n    void Work();\n}\n\npublic interface IEatable\n{\n    void Eat();\n}\n\npublic class Manager : IWorkable, IEatable\n{\n    // 구현\n}\n\npublic class Robot : IWorkable\n{\n    // 구현\n}\n```\n\nIWorkable 인터페이스를 IWorkable 및 IEatable 같은 작은 인터페이스로 분할하여, 각 클래스가 필요한 부분만 구현할 수 있도록 하여 ISP를 준수할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n설명: LSP에 따르면, 어떤 클라이언트도 해당 클라이언트와 관련이 없는 인터페이스를 강제로 사용해서는 안 됩니다. 다시 말해, 클라이언트는 사용하지 않는 메소드에 의존하도록 강요되어서는 안 됩니다.\n\n# 5. 의존 역전 원칙 (DIP)\n\n의존 역전 원칙은 고수준 모듈이 저수준 모듈에 의존하지 않아야 하며, 두 모듈 모두 추상화에 의존해야 한다는 것을 제안합니다. 또한, 추상화는 세부사항에 의존해서는 안 되며, 세부사항은 추상화에 의존해야 합니다.\n\n주요 아이디어: 고수준 모듈은 저수준 모듈에 의존해서는 안 되며, 두 모듈 모두 추상화에 의존해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n실시간 예제: 레고 타워 만들기 - 브릭(고수준 및 저수준 모듈)은 작은 브릭(추상화)을 통해 연결됩니다.\n\nC#에서의 실용적인 코딩 예제:\n\nDIP를 적용하기 전:\n\n```js\npublic class LightBulb\n{\n    public void TurnOn() { /* 구현 */ }\n    public void TurnOff() { /* 구현 */ }\n}\n\npublic class Switch\n{\n    private LightBulb bulb;\n\n    public Switch(LightBulb bulb)\n    {\n        this.bulb = bulb;\n    }\n\n    public void Toggle()\n    {\n        if (bulb.IsOn)\n            bulb.TurnOff();\n        else\n            bulb.TurnOn();\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n스위치 클래스는 이제 추상화에 의존하도록 변경되어 DIP(Dependency Inversion Principle)를 준수합니다.\n\n<div class=\"content-ad\"></div>\n\n해석: DIP에 따르면 어플리케이션이 점점 커져갈 때 서로 강하게 결합된 코드를 작성하는 것은 유지보수하기 어려운 악몡이 될 수 있습니다. 한 클래스가 다른 클래스에 의존할 경우, 의존하는 클래스가 변경되면 해당 클래스도 수정해야 합니다. 항상 느슨하게 결합된 클래스를 작성하려고 노력해야 합니다.\n\n결론\n\n.NET 개발자들은 이러한 SOLID 원칙을 이해하고 적용함으로써 더 강력하고 유연하며 유지보수가 쉬운 소프트웨어를 만들 수 있습니다. 이러한 원칙이 함께 작동하여 서로 보완하며 객체지향 프로그래밍의 전체적인 설계 철학에 기여한다는 점을 명심하는 것이 중요합니다.\n\n저자: Jeslur Rahman","ogImage":{"url":"/assets/img/2024-06-22-UnderstandingSOLIDPrinciplesinNETCAPracticalGuidewithCodeExamples_0.png"},"coverImage":"/assets/img/2024-06-22-UnderstandingSOLIDPrinciplesinNETCAPracticalGuidewithCodeExamples_0.png","tag":["Tech"],"readingTime":6},{"title":"온디맨드 ISR로 새로운 콘텐츠 빠르게 제공하는 방법","description":"","date":"2024-06-22 04:23","slug":"2024-06-22-DeliverNewContentFasterOnDemandISR","content":"\n\n\n![img](/assets/img/2024-06-22-DeliverNewContentFasterOnDemandISR_0.png)\n\nNext.js 버전 12.2.0에는 HTML을 정적으로 렌더링하는 새로운 기능인 On-Demand Incremental Static Regeneration이 소개되었습니다. 이 기능은 자주 변경되는 데이터 풀을 가진 기업에게 중요하며, 특히 사용자 브라우저에 최소한의 오래된 데이터가 남도록 필요로 하는 중요한 콘텐츠를 가진 기업에게 필수적입니다. 이 글에서는 정적 생성의 여러 형태를 탐구하고, 각 형태가 지난번 것의 효율성이나 성능 측면에서 어떻게 발전되어 가다가 od-ISR에 도달하는지 살펴볼 것입니다.\n\n# 정적 사이트 생성\n\n정적 사이트 생성(Static Site Generation, SSG)은 많은 사용 사례에 대해 클라이언트 사이드 렌더링(CSR)과 서버 사이드 렌더링(SSR)에 유용한 대안입니다. 클라이언트 사이드 렌더링은 클라이언트(사용자 브라우저)가 JavaScript를 HTML과 CSS로 렌더링하여 사용자에게 페이지를 제공하는 것에 의존합니다. 현재의 웹 개발 환경에서 CSR은 일반적으로 대량의 번들화된 JavaScript를 프론트엔드로 보내는 단일 페이지 응용 프로그램(Single Page Application, SPA)으로 이어집니다. 이로 인해 페이지를 렌더링하기 위해 필요한 HTML과 CSS를 브라우저에게 위임함으로써 성능이 좋지 않은 사이트를 만들 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\nSSR의 경우에는 서버가 더 많은 작업을 처리합니다. 각 페이지 이동은 서버에 요청을 일으키고, 서버는 관련 페이지와 JSON 데이터를 작성하여 응답합니다. 서버는 일반적으로 브라우저보다 강력하며, 페이지를 렌더링하는 데 필요한 내부 회사 데이터와 함께 동일한 위치에 배치될 수 있어 이 콘텐츠를 수집하기 위한 빠른 서버 측 HTTP 요청을 가능케합니다. 일반적으로 CSR은 렌더링 후 반응성이 중요한 매우 동적이고 대화형 응용 프로그램에 적합하며, SSR은 초기 페이지 로드를 더 빠르게 만드는 데 유리합니다. CSR은 캐싱된 에셋 및 콘텐츠 또는 CDN 또는 CDN이있는 CMS(예 : Sanity)에 데이터를 가져와 사용자에게 제공하여 페이지를 렌더링합니다.\n\n많은 현대적인 프레임워크는 일부 루트가 구성 파일에 따라 SSR을 통해 렌더링되고 다른 루트가 CSR을 통해 렌더링되는 하이브리드 렌더링 형태를 지원합니다. 예를 들어, Nuxt는 Nuxt 구성 파일에서 지정된 대로 다양한 루트를 대상으로 렌더링 할 수 있습니다.\n\n![image](/assets/img/2024-06-22-DeliverNewContentFasterOnDemandISR_1.png)\n\n정적 사이트 생성(SSG)은 CSR 및 SSR과는 완전히 다른 방식입니다. SSG는 모든 웹 페이지가 빌드 시간에 생성되어 서버에 저장되는 아키텍처입니다. 일반적으로 이에는 일종의 템플릿 기능이 포함됩니다. 블로그를 예로 들어보겠습니다. 모든 블로그 페이지가 동일한 형식으로 표시되는 경우를 생각해보세요. 정적 사이트 생성기는 일반적인 블로그 글 페이지에 대한 HTML 템플릿을 저장하고, 구조화된 데이터 형식 (예: JSON)을 사용하여 각 별도의 블로그 페이지를 위한 HTML 템플릿을 배포할 정보를 저장합니다. 클라이언트가 요청을 하면 저장된 사전에 생성된 HTML, CSS, 클라이언트 측 JavaScript (예를 들어 사용자 상호 작용에서의 HTTP 요청 제작용) 및 데이터가 즉시 사용자의 브라우저로 전송됩니다. 페이지를 브라우저에서 빌드하는 작업은 필요하지 않습니다. 이로 인해 초기 페이지 로드가 빠릅니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-22-DeliverNewContentFasterOnDemandISR_2.png)\n\n위 다이어그램은 SSG를 통해 렌더링된 블로그 사이트 아키텍처의 단순한 예제를 보여줍니다. 빌드 시기에 (1) Next는 콘텐츠 관리 시스템 (CMS)에 서버 측 호출을 수행하여 (2) 데이터를 받아 (3) 블로그 게시물을 정적으로 생성합니다. 또한 Next는 추가로 하나 이상의 API (4)를 호출하여 이 콘텐츠를 생성하거나 추가 데이터를 받을 수 있습니다 (5). 클라이언트가 요청을 보낼 때 (6), 미리 빌드된 페이지가 응답으로 제공되며, 클라이언트 측 JavaScript, HTML, CSS 및 관련 데이터 (7)가 포함됩니다. SSG는 사이트에서 상호 작용을 금지하지 않으며, 각 페이지와 함께 전송되는 클라이언트 측 JavaScript에 의해 하나 이상의 API 또는 서비스 (예: Stripe)로 추가 CRUD 요청이 수행될 수 있습니다 (8, 9). 정적 사이트 생성기에 의해 생성된 페이지는 엔드 유저에게 가능한 한 가까운 위치에 있는 CDN에 캐시될 수도 있습니다 (여기서는 생략). 요청-응답 주기에서 증가된 거리가 가장 큰 성능 억제 요인 중 하나이므로, 이를 통해 페이지 로드 시간을 더욱 줄일 수 있습니다.\n\n정적 사이트 생성은 매우 뛰어난 로드 시간 성능을 제공합니다. 그러나 큰 단점이 하나 있습니다. 순수 SSG를 통해 렌더링된 사이트에서 하나의 페이지를 변경하면 서버에 저장된 모든 페이지를 완전히 다시 빌드해야 합니다. 이것이 순수 SSG의 가장 큰 병목 현상입니다. 밤 늦은 글쓰기 세션 중에 블로그 게시물 하나에서 철자를 잘못 입력한 경우를 상상해보세요. 사이트에 게시물이 얼마나 많이 있는지에 따라, 그것은 치명적인 실수일 수 있습니다.\n\n# stale-while-revalidate 및 증분 정적 재생\n\n\n<div class=\"content-ad\"></div>\n\n순수 SSG의 명백한 단점은 자주 변경되는 콘텐츠에 대해 아키텍처를 쓸모없게 만든다는 것입니다. SSG로 돌아가서, 모든 페이지가 생성되고 서버에 저장될 때 (다시 말해 캐시되어 있을 때), 개발자가 이 내부 캐시를 무효화하여 페이지를 다시 만드는 것을 막는 것은 무엇인가요? 여기에서 나타나는 것이 바로 SWR(지속-중재 확율)입니다. HTTP Cache-Control 헤더에 설정된이 값은 동반하는 max-age 값에 따라 캐시된 응답의 유효성을 결정합니다. SWR이 있는 Cache-Control HTTP 헤더는 다음과 같이 설정할 수 있습니다:\n\n```js\nCache-Control: max-age=604800, stale-while-revalidate=86400\n```\n\n이 헤더는 받는 서버, CDN 또는 클라이언트에게 콘텐츠를 재검증하기 전에 7일 동안 HTTP 응답을 캐시하도록 지시합니다. 일곱 일이 지나면 캐시된 응답은 더 이상 유효하지 않습니다. 이때 특정 URL의 특정 서버, CDN 또는 브라우저에 대한 요청이 발생하면, 즉시 스테일 콘텐츠가 응답으로 제공되고 백그라운드에서 내용을 다시 확인하고 캐시를 새로 고침하기 위해 원본 서버에 새 요청이 이루어집니다.\n\n여기에서 몇 가지 네이밍 컨벤션 혼란이 발생합니다. SWR을 렌더링 모드로 부르고 CDN의 존재 여부에 따라 Incremental Static Regeneration (ISR)와 의미론적으로 구분하여 네이밍을 혼동할 수 있습니다. CDN이 없는 경우 SWR은 렌더링 아키텍처이고 CDN이 있는 경우 ISR이 아키텍처이므로 (Nuxt 3 참조).\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-22-DeliverNewContentFasterOnDemandISR_3.png)\n\nSWR의 아이디어를 렌더링 모드와 분리하는 것이 현실적입니다. 이는 Cache-Control 헤더에 설정된 값을 의미하며, 해당 응답의 캐시 동작을 제어할 수 있습니다 (서버, CDN 또는 클라이언트가 stale-while-revalidate을 Cache-Control 값으로 수락할 수 있다면). Cache-Control 헤더의 must-revalidate 값과 마찬가지로 일반적입니다.\n\n![이미지](/assets/img/2024-06-22-DeliverNewContentFasterOnDemandISR_4.png)\n\n그러나 증분 정적 재생성은 SWR 헤더를 사용하여 정적으로 생성된 콘텐츠를 저장하고 다시 유효성을 검사하는 서버 또는 CDN에서 SWR 헤더를 활용한 아키텍처로 취급할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-22-DeliverNewContentFasterOnDemandISR_5.png)\n\n위 다이어그램은 ISR 기반 아키텍처가 어떻게 보일 수 있는지 간단히 보여줍니다. 이를 현대적인 뉴스 사이트로 생각해보면 지친 기자들이 악화되는 정치적 기후에 대응하고, AI가 생성한 실수에 대처하고, 독자들의 트위터에서의 소란한 피드백에 대응하며 자주 변경되는 컨텐츠를 가질 것입니다. 여기서 Next 서버는 모든 페이지를 빌드 시간에 생성합니다(1), CMS(2) 또는 API(4)로 서버 콜을 통해 관련 데이터(3, 5)를 수신합니다. 이러한 페이지는 TTL(Time-To-Live) 값(12)으로 생성되며, 이 경우 60초입니다. 이는 Cache Control 값을 나타내는 max-age 와 동일합니다. 만약 클라이언트가 이와 같은 뉴스 기사에 대한 요청을 할 경우, 우리 아키텍처에서 요청은 먼저 CDN(8)에 도달합니다. TTL이 만료되지 않았고 60초 창 안에 있다면, CDN는 즉시 페이지를 제공(9)하고 추가 조치가 필요하지 않습니다.\n\n![이미지](/assets/img/2024-06-22-DeliverNewContentFasterOnDemandISR_6.png)\n\n만약 60초의 TTL이 지났다면, CDN는 페이지를 사용자에게 제공하는데 문제가 없습니다. 사용자는 CDN 캐시에서 즉시 정적으로 생성된 페이지를 받습니다(9). CDN는 이로써 끝나지 않으며, 서버에 신선하게 생성된 페이지를 요청합니다(6). 이 시점에서 서버는 CMS 또는 API에서 데이터를 다시 가져오도록 서버쪽에서 스크램블하여 이 특정 페이지(2, 4)를 재검증하며 해당 데이터를 받아 다시 해당 페이지를 생성합니다(3, 5). 그런 다음, 해당 페이지를 CDN에 다시 캐시하기 위해 보냅니다(7). 이러한 방식으로 생성된 사이트는 사용자가 HTTPS 요청을 통해 클라이언트 측 JavaScript(10, 11)를 사용하여 하나 이상의 API 또는 서비스에 대한 CRUD 작업을 시작하는 등 추가 상호작용을 제한하지 않습니다.\n\n\n<div class=\"content-ad\"></div>\n\nISR보다 SSG의 혜택은 즉각적으로 나타납니다. 이제 한 가지 오타를 고치거나 기사 일부를 철회하거나 불운한 제목을 수정하기 위해 전체 사이트를 다시 빌드할 필요가 없습니다. 이로 인해 많은 비용이 드는 전체 사이트 재구축을 피할 수 있습니다. 콘텐츠가 한 페이지에서만 변경된다면, 왜 모든 페이지를 재구축해야 할 때와 같은 시간과 컴퓨팅 비용을 낭비해야 할까요? 또한 사용자 상호 작용을 통해 페이지를 다시 생성함으로써 불필요한 재구축을 최소화합니다. 드물게 방문하는 페이지는 상호 작용이 있을 때에만 다시 빌드됩니다.\n\n그러나 이 아키텍처에는 단점도 있습니다. ISR의 경우 실시간 데이터 업데이트는 여전히 진정한 기능이 아닙니다. 예를 들어 기자가 7일 TTL이 설정된 뉴스 기사를 게시했다고 가정해봅시다. 모든 QA 확인을 통과하고 게시된 후에 기사 제목에 철자 오류가 있다는 것을 깨닳기 전에 사용자들에게 즉각적으로 알려져 조롱하는 트위터 게시물에 응답을 받습니다. 만약 창조자가 게시물을 편집하고 그냥 기다린다면, 기사가 새롭게 업데이트되기까지 전체 7일이 걸릴 수 있습니다. 캐시는 수동으로 무효화되어야 할 것입니다. 또한 서버가 페이지를 재생성하는 데 시간이 걸립니다. 그동안 모든 사용자는 CDN이나 서버가 답변으로 반환하는 제목 오타가 있는 낡은 콘텐츠를 받게 됩니다. 게다가 위에서 언급한 드물게 방문하는 페이지가 오랜 기간 동안 재구축되지 않으면 문제가 발생할 수 있습니다. 한 달 동안 방문하지 않은 페이지가 있다고 생각해보세요. 질문이 생깁니다 — 너무 오래된 것은 과연 얼마나 오래 된 것인가요?\n\n# 온디맨드 증분 정적 재생성\n\n![Deliver New Content Faster On-Demand ISR](/assets/img/2024-06-22-DeliverNewContentFasterOnDemandISR_7.png)\n\n<div class=\"content-ad\"></div>\n\nOn-Demand Incremental Static Regeneration (od-ISR, 동료 엔지니어가 만든 비표준 약어)은 위에 나열된 많은 질문에 대해 다룹니다. TTL에 기반한 캐시 무효화 대신, 실시간 데이터 변경을 다루지 못하는 시간 기반 지표가 아닌 동적으로 만들어낼 수 있습니다. 정적 콘텐츠의 이 온디맨드 재구성 유형은 중요한 데이터를 가진 웹사이트에 필수적입니다.\n\n전형적인 예로 전자 상거래 사이트를 들 수 있습니다. 하루 종일 잘리지 않는 상품 데이터의 대부분은 변경되지 않지만, 뒷면에서는 제품 매니저가 여러 가지 이유로 다양한 제품 풀에서 설명, 제목 및 카테고리를 편집할 수 있습니다. 그들은 당신(개발자)이 이러한 변경 사항을 빠르게 인식하는 사이트를 만들도록 요구합니다, 특히 위험 요인이 높은 상황에서.\n\n시카고 기반의 휴일 전자 상거래 사이트이며 여러 공급 업체의 제품을 제공합니다. 구운 과자, 의상, 크리스마스 트리 등 신선하게 수확한 지역 유기농 코벗 홀리 홀리 리스를 판매합니다. 비즈니스는 번창하고 분당 수십 명의 고객이 사이트에서 제품을 둘러보고 아름다운 홀리 홀리 리스를 신속하게 구매합니다. 휴일 정신이 가득한 상황입니다. 그러나 홀리 홀리 리스에 신선하게 꽃을 포함하는 지역 공급 업체 중 한 명이 실제로는 홀리 홀리 리스에 약속한 제품을 보내지 않을 것이라고 알려주기 위해 당신에게 전화를 걸어옵니다.\n\n그는 매우 사과하며 전액 환불을 약속하지만 여전히 문제가 발생합니다. 그 홀리 홀리 리스는 여전히 당신의 사이트에 있으며, 시카고 사용자들에게 지역 무기화로 유기농 신선한 꽃이 들어가 있습니다. 이미 여러 사용자의 장바구니에 들어가 있습니다(하지만 이 부분은 고객 서비스에 넘기죠). 지금 이 혼란을 막아야 합니다. 새로운 지역 공급 업체를 발견했습니다. 꽃을 사용하지만 유기농 제품은 아니며 홀리만 유기농입니다. od-ISR이 이 문제를 어떻게 완화하는지 알아봅시다.\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-22-DeliverNewContentFasterOnDemandISR_8.png)\n\nod-ISR에서, Next는 모든 페이지를 빌드 시간에 생성합니다 (1). CMS 및/또는 API로부터 데이터를 전달받아 이러한 페이지를 작성하는 이전 화살표는 생략했지만, 이러한 호출은 여전히 빌드 시간에 발생합니다. 우리의 매혹적인 이야기를 계속해 봅시다. 어느 날 밤, 서둘러 콘텐츠 제작자나 제품 관리자가 올해 가장 바쁜 판매일 전에 네 시간 전에 전화를 받고 성수기 활동(편집, 설명, 이미지 및 기타 데이터)를 즉시 CMS에서 수정해야 한다는 전화를 받는 상황이 벌어집니다. 홀리 리스 태그를. 가까이 있는 하인드만 충실한 콘텐츠 제작자는 그런 일을 합니다 (2). CMS는 데이터 풀의 변경 사항에 대해 특정 조치를 실행하는 웹훅으로 구성되어 있습니다. 이 경우, 인증을 위해 숨은 토큰을 전달하기 위해 Next 웹 서버에 요청을 보냅니다 (3). 이것은 대신 내부 회사 서버나 기계를 사용하여 수행할 수 있으며, 여기서는 API라고 부르고 클라이언트 측 상호 작용을 위해 무균형적으로 재사용할 수 있게 했습니다 (4). Next는 즉시 데이터 변경에 영향을 받는 지정된 페이지 또는 페이지를 재구축합니다 (5). 이제 새 홀리 리스 페이지를 얻었습니다.\n\n![이미지](/assets/img/2024-06-22-DeliverNewContentFasterOnDemandISR_9.png)\n\n그런데, CDN이 잘못된 정보를 표시하는 홀리 리스가 있는 냅을 즉시 제공 대신, 그 구식이라고 하는 위험 콘텐트를 제공해버릴 때 어떻게 해야 할까요? 이 아키텍처에서 가장 어려운 부분입니다. 많은 CDN은 캐시의 일부 또는 전체를 무효화하거나 지우는 기능을 제공하므로, CDN이 즉시 구식 페이지를 제공하는 대신 오리진 서버로 반환하도록 강제합니다 (12). 때로는 이 기능이 GUI에 기반하거나 콘솔을 통해 수행되기도 하며 때로는 API를 통해 프로그래밍적으로 제공됩니다. 일반적으로 질문하는 CDN에 특정하며, 특정 CDN을 사용하는 개발자들은 임시방편을 활용하고 있습니다. 위의 개발팀이 CDN을 무효화하는 방법을 갖고 있다고 가정합시다, 이는 이 문서의 범위를 벗어난 것입니다. 클라이언트가 CDN에 요청을 보내면 (8), 오리진 서버로 돌아가 (6) 신선한 페이지를 응답하고 (7) 사용자에게 반환되며 (9) 다시 한번 CDN에 캐시됩니다 (표시되지 않음). 다시 말해, 이러한 유형의 아키텍처는 클라이언트 측 JavaScript에서 한 개 이상의 API나 서비스로 추가 CRUD 요청을 만드는 것을 배척하지 않습니다 (10, 11).\n\n<div class=\"content-ad\"></div>\n\n여기서 우리는 stale-while-revalidate ISR 콘텐츠 생성의 시간 기반 지표에서 상당한 개선을 볼 수 있습니다. 여기서 콘텐츠는 요청에 따라 업데이트됩니다. 사용자가 방문하지 않아도 페이지가 ‘너무 오래된’ 상태가 되지 않을 것입니다. 대신 콘텐츠 생성자와 제품 관리자가 CMS나 데이터베이스를 업데이트하면 해당 콘텐츠는 요청을 받은 후 Next에 의해 다시 생성됩니다. 이는 웹훅이나 간단한 HTTP 요청을 통해 매개될 수 있으며 (Next의 경우) 비밀 토큰의 포함으로 인증됩니다. 페이지 재생성은 더 이상 사용자 상호작용을 통해 이루어지지 않습니다.\n\n이 재생성은 여전히 즉각적이지 않다는 점을 강조해야 합니다. 심지어 한 페이지의 재생성에도 시간이 걸릴 수 있습니다. 하나의 제품을 변경하는 것은 웹사이트 구조에 따라 여러 페이지의 재생성이 필요할 수 있습니다. Next는 요청을 받고 페이지를 재구성하고 CDN을 무효화할 수 있으며, 이 작업이 GUI를 통해 수동으로 이루어지지 않을 경우입니다. 그 동안 사용자는 여전히 오래된 콘텐츠를 받게 될 것입니다. 실제로, 적절하게 설계된 애플리케이션에서 이러한 변경 사항은 캐시된 콘텐츠가 만료되기를 기다릴 수 없는 빈번한 데이터 변경을 필요로 하는 동적 웹사이트의 요구를 충족시키기에 충분히 빠를 것으로 예상됩니다.\n\n우리 탐험이 시작될 때로 돌아가보면, 다양한 사용 사례에 대해 다른 렌더링 방법 대비 od-ISR이 상당한 개선임이 명백합니다. 대규모 전자상거래 사이트는 CSR만 있는 아키텍처에서 느린 로딩 속도를 겪을 것입니다. 서버에 추가된 계산 성능이 있더라도, 하나의 페이지가 여러 API 및 CMS로부터 데이터를 요구할 가능성이 높아 여전히 SSR 기반 아키텍처로 인해 더 긴 로드 시간이 필요할 수 있습니다.\n\n게다가 제품이 자주 변경되지 않는 페이지에서는, 동일한 페이지를 사용자 요청마다 서버에서 반복해서 다시 렌더링하는 비효율성이 이 사이트에 이상적이지 않습니다. SSG는 사이트에 작은 변경 사항을 위해 전체 재구성이 필요하며, 수천 개 제품을 보유한 비즈니스는 단일 페이지나 심지어 한 줄의 변경에 대해 엄청난 재생성 시간을 겪게 될 것입니다. od-ISR은 자주 변하는 내용을 필요로 하는 사이트에 이상적이지만 변경 사항을 최대한 빨리 반영해야 하는 사이트에는 적합하지 않습니다. od-ISR은 온디맨드 변경의 이점과 정적으로 생성된 콘텐츠에 대상 페이지 재생성을 결합하여, 높은 리스크, 동적이고 빈번하게 변경되는 데이터를 보유한 비즈니스에 완벽하게 적합합니다.\n\n<div class=\"content-ad\"></div>\n\n지금 시점에서 Next는 온디맨드 증분 정적 재생성을 제공합니다. Vue 기반의 Nuxt는 ISR을 제공하지만 Next와 같이 온디맨드 페이지 재구성은 아직 제공하지 않습니다. 그러나 수많은 Github 이슈 티켓과 응답에 따르면 해당 기능은 준비 중에 있습니다! Next에서 od-ISR에 대해 더 알고 싶다면 여기에서 문서를 확인해보세요.\n\n# Stackademic\n\n끝까지 읽어주셔서 감사합니다. 그 전에:\n\n- 작가를 추천하고 팔로우해주시는 걸 고려해주세요! 👏\n- 트위터(X), 링크드인, YouTube에서 우리를 팔로우해주세요.\n- Stackademic.com을 방문하여 전 세계에서 무료 프로그래밍 교육을 민주화하는 방법에 대해 더 많이 알아보세요.","ogImage":{"url":"/assets/img/2024-06-22-DeliverNewContentFasterOnDemandISR_0.png"},"coverImage":"/assets/img/2024-06-22-DeliverNewContentFasterOnDemandISR_0.png","tag":["Tech"],"readingTime":11},{"title":"최고의 미니멀리스트 UI 디자인 아이디어  vol 165","description":"","date":"2024-06-22 04:21","slug":"2024-06-22-UIDesignIdeasHigh-qualityMinimalistvol165","content":"\n\n## 고품질이고 미니멀한 UI/UX 디자인을 살펴보세요. 섬세하고 프리미엄한 빌드로 눈에 띄는 디자인들입니다. 이 작품들은 최고의 사용자 경험 디자인 에이전시에서 나온 것으로, 미니멀리즘에 초점을 맞추고 있습니다.\n\n## 오루클 아이덴티티\n\n👨‍🎨 줄리아 드미트리에브나\n👥 기엑스 아트\n\n## 나이키 AF1 웹사이트 컨셉\n\n<div class=\"content-ad\"></div>\n\n👨‍🎨 마리우스 미트코\n\n## 스킬젯 UI-UX\n\n👨‍🎨 파힘 샤리아르\n\n[이미지](/assets/img/2024-06-22-UIDesignIdeasHigh-qualityMinimalistvol165_0.png)\n\n<div class=\"content-ad\"></div>\n\n이 그림에서 소개된 인터페이스는 심플하면서도 고품질의 UX 디자인을 자랑합니다.\n\n생동감 넘치는 녹색 강조와 어두운 컬러 팔레트의 사용은 활성 강좌와 사용자 진행 상황 등 핵심 기능에 효과적으로 관심을 끌어줍니다.\n\n나침반은 잘 구성된 모듈과 명확하고 간결한 텍스트로 간결하게 유지되어, 사용자를 압도하지 않으면서 직관적인 사용자 경험을 촉진합니다. 이 디자인은 미적 매력과 실용적 사용성 사이의 균형을 이룹니다.\n\n## Vision Pro Duolingo — 공간 디자인 월의 4번째 날\n\n<div class=\"content-ad\"></div>\n\n👨‍🎨 안드레아스 크루새킨-리보스카\n\n이 교육 앱 인터페이스는 간결함과 기능성을 조화롭게 결합하여 미니멀리스트 UX 디자인 원칙을 보여줍니다.\n\n깔끔한 레이아웃, 어조가 점잖은 색 구성 및 직관적인 아이코노그래피는 빠른 학습과 사용자 유지에 도움이 됩니다.\n\n현저하게 식별하기 쉬운 이미지와 간결한 텍스트가 사용자의 집중이 분산되지 않도록 보장하여 전체 사용자 참여도와 효과를 향상시킵니다.\n\n<div class=\"content-ad\"></div>\n\n## Roomeet Virtual Workspace\n\n👨‍🎨 Brolis  \n👥 Odama  \n\n![Image](https://miro.medium.com/v2/resize:fit:1400/1*OZFee7rd_ns8gVQhy7hBCA.gif)\n\nThis virtual office application combines high-quality visuals with minimalist UX principles effectively.\n\n<div class=\"content-ad\"></div>\n\n이는 가상 공간을 구성하고 시각화하기 위해 3D 퍼스펙티브를 활용하여 공간 인식을 향상시키고 혼잡함 없이 시각적으로 표현합니다.\n\n간소화된 내비게이션 요소와 명확하고 집중된 아바타를 통해 사용자가 쉽게 상호 작용하고 레이아웃 복잡성보다는 커뮤니케이션에 집중할 수 있도록 지원하여 깔끔하고 매력적인 사용자 경험을 제공합니다.\n\n## 제품 페이지 전자상거래\n\n👨‍🎨 Anton Shmatko\n\n<div class=\"content-ad\"></div>\n\n\n![Mobile app design](https://miro.medium.com/v2/resize:fit:1400/1*-x1OZFSA7_GO-48ocKz0EA.gif)\n\nThis mobile app design for a product catalog demonstrates a high-quality, minimalist approach by employing a dark theme with high contrast text and vibrant product images, which enhance readability and visual appeal.\n\nInterface layout is clean, with essential information like price and ratings immediately visible, fostering an efficient browsing experience.\n\nSegmented control for product categories at the top provides an easy filter method, streamlining user interaction and access to desired products.\n\n\n<div class=\"content-ad\"></div>\n\n## 은행\n\n👨‍🎨 Slava Kornilov\n👥 Geex Arts\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*3X4yU0hAAgB7wdwtkena_w.gif)\n\n이 예산 관리 앱의 디자인은 고품질이며 미니멀한 UX를 보여주며 선명한 색상 사용과 깔끔한 타이포그래피로 중요한 숫자와 통찰이 효과적으로 돋보이도록합니다.\n\n<div class=\"content-ad\"></div>\n\n과도하게 큰 원을 사용한 그래픽 디스플레이는 시선을 사로 잡아 복잡한 데이터를 손쉽게 이해하기 쉬운 형식으로 단순화합니다.\n\n전반적으로, 이 인터페이스는 사용자를 압도하지 않으면서 중요한 정보를 우선적으로 표시하여 재무 관리에 유용하고 사용자 친화적인 환경을 조성합니다.\n\n## 메뉴 상호작용\n\n👨‍🎨 Filip Legierski\n👥 Riotters\n\n<div class=\"content-ad\"></div>\n\n\n![img](https://miro.medium.com/v2/resize:fit:1400/1*N6w2jPdVy9FH8E6Pgp6KmQ.gif)\n\n이 앱의 메뉴 디자인은 어두운 테마와 대비 있는 버튼 색상을 활용하여 미니멀한 사용자 경험 원칙을 대변합니다. 이로써 사용자가 주요 액션에 집중할 수 있습니다.\n\n레이아웃은 깔끔하고 간단하여 시각적 혼란 없이 명확히 옵션을 구분하여 탐색의 용이성을 촉진합니다.\n\n넉넉한 간격과 큰 타이포그래피의 활용은 접근성과 상호 작용의 편의성을 보장하여 뛰어난 사용자 경험을 제공합니다.\n\n\n<div class=\"content-ad\"></div>\n\n## 부동산 웹사이트 모바일 페이지\n\n👨‍🎨 Farzan Faruk\n👥 Rylic Studio\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*FMNgPUJLTTljoD138zTqqw.gif)\n\n“Hoomie” 앱의 디자인은 밝고 매력적인 색 구성을 활용하여 고객 지원 및 부동산 검색과 같은 주요 기능을 효과적으로 강조하여 즉시 접근할 수 있도록 합니다.\n\n<div class=\"content-ad\"></div>\n\n레이아웃은 사용자 친화적이며 큰 명확한 타이포그래피와 생생한 관련 이미지를 활용하여 직관적인 탐색 경험을 보장합니다.\n\n각 화면은 사용자가 압도당하지 않으면서 사용자 참여를 촉진하도록 신중하게 구조화되어 있습니다. 또한 주요 기능과 사용 편의성에 중점을 두어 미니멀한 UX 디자인 원칙과 잘 조화를 이룹니다.\n\n## Out of Dark — 고객 여정\n\n👨‍🎨 Martin Strba\n👥 Outloud\n\n<div class=\"content-ad\"></div>\n\n## Banksad — 금융 모바일 앱 UI 키트\n\n👨‍🎨 Caraka UI 키트  \n👥 Caraka  \n\n![Bankasd](/assets/img/2024-06-22-UIDesignIdeasHigh-qualityMinimalistvol165_1.png)  \n\n“Banksad” 금융 앱 UI 키트는 심플하고 깔끔한 디자인을 자랑하며, 여백을 효과적으로 활용하고 키포인트인 최근 거래 내역 및 계좌 잔액을 강조하기 위해 몽드톤 팔레트와 전략적으로 사용된 컬러 하이라이트를 적용했습니다.\n\n<div class=\"content-ad\"></div>\n\n디자인 시스템이 일관되고 계층이 정리되며 사용자 경로가 명확히 정의되어 있어 사용자 경험이 원활합니다. 네비게이션과 사용자 정의 옵션의 편리함으로부터 명백히 확인할 수 있습니다.\n\n이 UI 키트는 명확성과 사용자 친화적 인터페이스에 중점을 둔 현대적인 디자인 원칙을 보여줍니다.\n\n## 비전 프로 박물관 - 공간 디자인 달의 5 번째 날\n\n👨‍🎨 안드레아스 크루자킨 리보스카\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-22-UIDesignIdeasHigh-qualityMinimalistvol165_2.png)\n\n이 앱 디자인은 증강 현실을 효과적으로 활용하여 박물관 환경에서 시선을 끄는 뷰잉 경험을 향상시키며, 반 고흐의 \"해바라기\"를 인터랙티브하고 정보적인 오버레이로 강조합니다.\n\n깔끔한 선, 절제된 색상 팔레트, 직선적인 타이포그래피와 같은 미니멀리즘 디자인 요소의 사용은 사용자가 산물과 관련 디테일에 집중할 수 있도록 하여 산물을 즐기고 방해되지 않도록 합니다.\n\n이 접근 방식은 미술 작품의 시각적 중요성을 존중할 뿐 아니라, 인터페이스가 사용자 친화적이고 교육적인 것을 보장하여 방문자 참여와 학습을 증진합니다.\n\n\n<div class=\"content-ad\"></div>\n\n## 벤토 그리드\n\n👨‍🎨 Levi Wilson\n👥 QClay\n\n![Image](https://miro.medium.com/v2/resize:fit:1400/1*-EFO3D0xuGmi2KfNgHKwpw.gif)\n\n제품 기능을 소개하는 이 슬라이드 프레젠테이션은 명확한 미니멀한 디자인을 보여주며 일관된 색상 구성으로 가독성을 높이고 중요 요소에 집중할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n번호가 매겨진 섹션과 명확한 시각 자료는 서로 다른 제품 특징을 쉽게 이해하고 비교할 수 있도록 돕습니다.\n\n이 방식은 복잡한 정보를 효율적으로 전달하여 사용자들이 제시된 AI 기술의 능력과 장점을 빠르게 이해할 수 있도록 합니다.\n\n## 혁신적인 UI로 미래의 우유 배송을 경험해보세요\n\n👨‍🎨 aPurple\n\n<div class=\"content-ad\"></div>\n\n\n![RouteMilk](https://miro.medium.com/v2/resize:fit:1400/1*q9FM_RX5I5MpWQdfKYB_LQ.gif)\n\n\"RouteMilk\" 앱의 인터페이스는 고품질이며 심플한 UX 디자인을 보여주며 부드럽고 중립적인 색상 팔레트를 강조하여 접근성과 탐색의 용이성을 강조합니다.\n\n제품 카테고리, 상세 설명, 명확한 가격과 같은 주요 요소들은 잘 조직되어 사용자 친화적인 쇼핑 경험을 보장합니다.\n\n시각적 요소들은 깔끔하고 매력적이며, 기능성을 희생하지 않고 앱의 미적인 요소를 강화합니다. 이 디자인은 심플함과 쇼핑 앱의 포괄적인 요구 사항 사이에 스마트하게 균형을 맞춥니다.\n","ogImage":{"url":"/assets/img/2024-06-22-UIDesignIdeasHigh-qualityMinimalistvol165_0.png"},"coverImage":"/assets/img/2024-06-22-UIDesignIdeasHigh-qualityMinimalistvol165_0.png","tag":["Tech"],"readingTime":6},{"title":"고성능 JSON 파싱 라이브러리 분석 - Go 언어를 위한 비교 분석","description":"","date":"2024-06-22 04:18","slug":"2024-06-22-Analyzevarioushigh-performanceJSONparsinglibrariesinGo","content":"\n\n![image](/assets/img/2024-06-22-Analyzevarioushigh-performanceJSONparsinglibrariesinGo_0.png)\n\n`fastjson`, `gjson`, `jsonparser`의 성능, 장단점을 비교해보세요.\n\n이 기사는 Go의 표준 라이브러리가 JSON을 파싱하는 방식을 분석하고, 인기 있는 JSON 파싱 라이브러리, 그 특징들을 탐구하여 다양한 시나리오에서 개발을 더 잘 지원할 수 있는 방법에 대해 알아봅니다.\n\n나는 JSON 라이브러리의 성능 문제를 조사하려고 한 계획은 없었습니다. 그러나 최근에 프로젝트를 pprof로 분석해보니 아래의 flame 그래프에서 비즈니스 로직 처리 시 성능 소비량의 절반 이상이 JSON 파싱 중에 발생했다는 것을 알게 되었습니다. 그래서 이 기사가 만들어졌습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-22-Analyzevarioushigh-performanceJSONparsinglibrariesinGo_1.png)\n\n이 기사는 Go의 표준 라이브러리가 JSON을 구문 분석하는 방식을 분석하고, 인기있는 JSON 구문 분석 라이브러리, 그 특징, 그리고 다양한 시나리오에서 개발을 더 잘 돕는 방법을 탐색합니다.\n\n주로 다음 라이브러리들의 분석을 소개합니다 (2024년 6월 13일):\n\n![이미지](/assets/img/2024-06-22-Analyzevarioushigh-performanceJSONparsinglibrariesinGo_2.png)\n\n\n<div class=\"content-ad\"></div>\n\n## JSON Unmarshal\n\n```go\nfunc Unmarshal(data []byte, v interface{})\n```\n\n\"공식 JSON 구문 분석 라이브러리는 두 개의 매개변수가 필요합니다: 직렬화할 객체와이 객체의 유형입니다. 실제 JSON 구문 분석을 수행하기 전에 reflect.ValueOf를 호출하여 매개변수 v의 리플렉션 객체를 가져옵니다. 그런 다음 들어오는 데이터 객체의 처음에 있는 비어 있지 않은 문자열을 기반으로 구문 분석 방법이 결정됩니다.\"\n\n```go\nfunc (d *decodeState) value(v reflect.Value) error {\n    switch d.opcode {\n    default:\n        panic(phasePanicMsg)\n    // 배열\n    case scanBeginArray:\n        ...\n    // 구조체 또는 맵\n    case scanBeginObject:\n        ...\n    // int, string, float 등을 포함하는 리터럴\n    case scanBeginLiteral:\n        ...\n    }\n    return nil\n}\n```\n\n<div class=\"content-ad\"></div>\n\n파싱된 객체가 [,으로 시작하면 배열 객체이고 scanBeginArray 분기로 들어가게 됩니다. '로 시작하면 객체가 구조체 또는 맵이라는 것을 나타내며 scanBeginObject 분기로 들어가고 이와 같은 방식입니다.\n\n## 하위 요약\n\nUnmarshal의 소스 코드를 살펴보면 많은 양의 반사가 필드 값을 얻기 위해 사용되는 것을 볼 수 있습니다. JSON이 중첩되어 있다면 값 얻기 위해 반복적인 반사가 필요합니다. 따라서 성능은 매우 저조할 것으로 생각됩니다.\n\n하지만 성능이 높은 가치를 가지고 있지 않다면 직접 사용하는 것이 좋은 선택입니다. 완전한 기능성을 갖추고 있으며 공식 팀이 지속적으로 반복 및 최적화하고 있습니다. 미래 버전에서 성능도 질적인 발전을 이룰 수도 있습니다. Go 구조체로 직접 JSON 객체를 변환할 수 있는 유일한 방법일 것입니다.\n\n<div class=\"content-ad\"></div>\n\n# fastjson\n\n이 라이브러리의 특징은 이름이 시사하는 대로 빠르다는 것입니다. 소개 페이지에는 다음과 같이 언급되어 있습니다:\n\n사용 방법도 간단합니다. 아래와 같이 사용할 수 있습니다:\n\n```js\nfunc main() {\n     var p fastjson.Parser\n     v, _ := p.Parse(`{\n                 \"str\": \"bar\",\n                 \"int\": 123,\n                 \"float\": 1.23,\n                 \"bool\": true,\n                 \"arr\": [1, \"foo\", {}]\n         }`)\n     fmt.Printf(\"foo=%s\\n\", v.GetStringBytes(\"str\"))\n     fmt.Printf(\"int=%d\\n\", v.GetInt(\"int\"))\n     fmt.Printf(\"float=%f\\n\", v.GetFloat64(\"float\"))\n     fmt.Printf(\"bool=%v\\n\", v.GetBool(\"bool\"))\n     fmt.Printf(\"arr.1=%s\\n\", v.GetStringBytes(\"arr\", \"1\"))\n }\n // 출력:\n // foo=bar\n // int=123\n // float=1.230000\n // bool=true\n // arr.1=foo\n```\n\n<div class=\"content-ad\"></div>\n\nfastjson을 사용하려면 먼저 JSON 문자열을 구문 분석하기 위해 Parser parser에 전달한 다음 Parse 메서드로 반환된 객체를 통해 검색해야 합니다. 중첩된 객체인 경우 Get 메서드에 매개변수를 전달할 때 해당 부모-자식 키를 직접 전달할 수 있습니다.\n\n## 분석\n\nfastjson의 설계는 표준 라이브러리 Unmarshal과 다르게 JSON 구문 분석을 Parse와 Get으로 나누는 특징이 있습니다.\n\nParse는 JSON 문자열을 구조체로 구문 분석하고 반환하는 역할을 합니다. 그런 다음 반환된 구조체에서 데이터를 검색합니다. Parse 프로세스는 락이 없으므로 동시에 Parse를 호출하려면 ParserPool을 사용해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n**fastjson**은 JSON을 가장 위에서부터 아래로 트래버스하여 구문 분석된 데이터를 Value 구조에 저장합니다:\n\n```js\ntype Value struct { o Object a []*Value s string t Type }\n```\n\n이 구조는 다음과 같습니다:\n\n- o Object: 구문 분석된 구조가 객체임을 나타냅니다.\n- a []*Value: 구문 분석된 구조가 배열임을 나타냅니다.\n- s string: 구문 분석된 구조가 객체나 배열이 아닌 경우, 다른 유형의 값은 문자열로 이 필드에 저장됩니다.\n- t Type: 이 구조의 유형을 나타내며, TypeObject, TypeArray, TypeString, TypeNumber 등이 될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```go\ntype Object struct { kvs []kv keysUnescaped bool } type kv struct { k string v *Value }\n```\n\n이 구조는 객체의 재귀 구조를 저장합니다. 위 예시의 JSON 문자열을 구문 분석한 후, 결과물은 다음과 같이 보입니다:\n\n![구조 이미지](/assets/img/2024-06-22-Analyzevarioushigh-performanceJSONparsinglibrariesinGo_3.png)\n\n## 코드\n\n<div class=\"content-ad\"></div>\n\n구현 측면에서 반사 코드의 부재로 인해 전체 구문 분석 프로세스가 매우 깔끔해졌어요. 구문 분석의 중심 부분을 직접 살펴보죠:\n\n```js\nfunc parseValue(s string, c *cache, depth int) (*Value, string, error) {\n     if len(s) == 0 {\n         return nil, s, fmt.Errorf(\"빈 문자열을 구문 분석할 수 없습니다\")\n     }\n     depth++\n     // json 문자열의 최대 깊이는 MaxDepth를 초과할 수 없습니다\n     if depth > MaxDepth {\n         return nil, s, fmt.Errorf(\"중첩 된 JSON에 대한 너무 큰 깊이; %d를 초과합니다\", MaxDepth)\n     }\n     // 객체 구문 분석\n     if s[0] == '{' {\n         v, tail, err := parseObject(s[1:], c, depth)\n         if err != nil {\n             return nil, tail, fmt.Errorf(\"객체를 구문 분석할 수 없음: %s\", err)\n         }\n         return v, tail, nil\n     }\n     // 배열 구문 분석\n     if s[0] == '[' {\n         ...\n     }\n     // 문자열 구문 분석\n     if s[0] == '\"' {\n         ...\n     } \n     ...\n     return v, tail, nil\n }\n```\n\nparseValue 함수는 문자열의 첫 번째 비어 있지 않은 문자를 기반으로 구문 분석할 유형을 결정할 거에요. 여기서 객체 유형이 분석에 사용됩니다:\n\n```js\nfunc parseObject(s string, c *cache, depth int) (*Value, string, error) {\n     ...\n     o := c.getValue()\n     o.t = TypeObject\n     o.o.reset()\n     for {\n         var err error\n         // Object 구조 내에서 kv 객체 가져오기\n         kv := o.o.getKV()\n         ... \n         // 키 값 구문 분석\n \n         kv.k, s, err = parseRawKey(s[1:])\n         ... \n         // 재귀적 값 구문 분석\n         kv.v, s, err = parseValue(s, c, depth)\n         ...\n         // 만났을 때, 계속 구문 분석\n         if s[0] == ',' {\n             s = s[1:]\n             continue\n         }\n         // 구문 분석 완료\n         if s[0] == '}' {\n             return o, s[1:], nil\n         }\n         return nil, s, fmt.Errorf(\"객체 값 후 ','가 누락되었습니다\")\n     }\n }\n```\n\n<div class=\"content-ad\"></div>\n\nparseObject 함수도 간단합니다. 루프에서 키 값을 가져와서 순환적으로 parseValue 함수를 호출하여 위에서 아래로 값을 구문 분석하고 '를 마주할 때까지 JSON 객체들을 하나씩 구문 분석합니다.\n\n## 하위 요약\n\n위의 분석을 통해 fastjson은 구현이 훨씬 간단하고 표준 라이브러리보다 성능이 더 높다는 것을 알 수 있습니다. JSON 트리를 구문 분석하는 Parse를 사용한 후에는 여러 번 재사용할 수 있어 반복 구문 분석이 필요 없어지고 성능이 향상됩니다.\n\n그러나 그 기능은 매우 기본적이며 JSON을 구조체로 또는 JSON을 맵으로 변환하는 공통 작업이 부족합니다. JSON에서 값을 간단히 검색하려면이 라이브러리를 사용하는 것이 매우 편리합니다. 하지만 JSON 값을 구조체로 변환하려면 각 값을 수동으로 설정해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n# GJSON\n\n제 테스트 결과, GJSON의 성능은 fastjson만큼 극단적이진 않지만, 기능적으로는 매우 완전하며 성능도 꽤 괜찮습니다. 이제 GJSON의 기능을 간단히 소개하겠습니다.\n\nGJSON의 사용법은 fastjson과 유사하며, 매우 간단합니다. JSON 문자열과 필요한 값을 매개변수로 전달하기만 하면 됩니다.\n\n```js\njson := `{\"name\":{\"first\":\"li\",\"last\":\"dj\"},\"age\":18}`\nlastName := gjson.Get(json, \"name.last\")\n```\n\n<div class=\"content-ad\"></div>\n\n이 함수 외에도 간단한 퍼지 매칭을 수행할 수 있습니다. *와 ?와 같은 와일드카드 문자를 지원합니다. *는 모든 문자와 매치되고 ?는 한 문자와 매치됩니다. 예시는 다음과 같습니다:\n\n```js\njson := `{\n     \"name\":{\"first\":\"Tom\", \"last\": \"Anderson\"},\n     \"age\": 37,\n     \"children\": [\"Sara\", \"Alex\", \"Jack\"]\n }`\n fmt.Println(\"세 번째 자식*:\", gjson.Get(json, \"child*.2\"))\n fmt.Println(\"첫 번째 c?ild:\", gjson.Get(json, \"c?ildren.0\"))\n```\n\n- child*.2: 먼저, child*는 children과 매치되며, .2는 세 번째 요소를 읽습니다;\n- c?ildren.0: c?ildren은 children과 매치되며, .0은 첫 번째 요소를 읽습니다;\n\n퍼지 매칭뿐만 아니라 수정자 작업도 지원합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\njson := `{\n     \"name\":{\"first\":\"Tom\", \"last\": \"Anderson\"},\n     \"age\": 37,\n     \"children\": [\"Sara\", \"Alex\", \"Jack\"]\n }`\n fmt.Println(\"세 번째 자녀*:\", gjson.Get(json, \"children|@reverse\"))\n```\n\nchildren|@reverse 먼저 배열 \"children\"를 읽은 다음 수정자 \"@reverse\"를 사용하여 뒤집어서 출력합니다.\n\n```js\nnestedJSON := `{\"nested\": [\"one\", \"two\", [\"three\", \"four\"]]}` fmt.Println(gjson.Get(nestedJSON, \"nested|@flatten\"))\n```\n\n@flatten은 내장된 배열을 외부 배열로 평탄화하고 다음을 반환합니다:\n\n<div class=\"content-ad\"></div>\n\n```json\n[\"one,\" \"two,\" \"three,\" \"four\"]\n```\n\n다른 흥미로운 기능도 있으니 공식 문서에서 확인해보세요.\n\n## 분석\n\ngjson의 Get 메서드 매개변수는 JSON 문자열과 경로(Path)를 포함하며, 해당 JSON 값을 가져올 수 있는 일치 경로를 나타냅니다.\n\n<div class=\"content-ad\"></div>\n\ngjson에서는 파싱을 여러 가지 파싱 시나리오의 정의를 충족해야 하기 때문에 두 부분으로 나뉘어집니다. JSON 문자열을 탐색하기 전에 경로를 파싱해야 합니다.\n\n파싱 프로세스 중 일치하는 값을 만날 경우 해당 값이 직접 반환되며 뒷 부분을 계속해서 탐색할 필요가 없습니다. 여러 값이 일치하는 경우 JSON 문자열 전체가 항상 탐색됩니다. JSON 문자열에서 일치하는 경로를 만나지 못할 경우 전체 JSON 문자열을 탐색해야 합니다.\n\n파싱 과정에서 파싱 내용이 fastjson과 같이 구조에 저장되지 않습니다. 따라서 GetMany를 호출하여 여러 값을 반환할 때 JSON 문자열을 반복적으로 탐색해야 하기 때문에 효율이 비교적 낮아집니다.\n\n![이미지](/assets/img/2024-06-22-Analyzevarioushigh-performanceJSONparsinglibrariesinGo_4.png)\n\n<div class=\"content-ad\"></div>\n\n@flatten 함수는 JSON을 유효성 검사하지 않는다는 사실을 알아두는 것이 중요합니다. 이는 입력 문자열이 유효한 JSON이 아니더라도 구문 분석된다는 의미입니다. 따라서 사용자들은 잠재적인 문제를 피하기 위해 입력이 유효한 JSON인지 다시 한번 확인해야 합니다.\n\n## 코드\n\n```js\nfunc Get(json, path string) Result {\n     // 패스를 분석합니다\n     if len(path) > 1 {\n         ...\n     }\n     var i int\n     var c = &parseContext{json: json}\n     if len(path) >= 2 && path[0] == '.' && path[1] == '.' {\n         c.lines = true\n         parseArray(c, 0, path[2:])\n     } else {\n         // 다양한 객체에 따라 구문 분석하고 여기서 '{' 또는 '['이 발견될 때까지 루프\n         for ; i < len(c.json); i++ {\n             if c.json[i] == '{' {\n                 i++\n \n                 parseObject(c, i, path)\n                 break\n             }\n             if c.json[i] == '[' {\n                 i++\n                 parseArray(c, i, path)\n                 break\n             }\n         }\n     }\n     if c.piped {\n         res := c.value.Get(c.pipe)\n         res.Index = 0\n         return res\n     }\n     fillIndex(json, c)\n     return c.value\n }\n```\n\nGet 메서드에서 다양한 경로를 구문 분석하는 데 사용된 긴 코드 문자열을 볼 수 있습니다. 그런 다음 '‘나 ‘[‘를 찾을 때까지 for 루프가 JSON을 계속 탐색한 후 해당하는 논리 처리를 수행합니다.\n\n<div class=\"content-ad\"></div>\n\n```go\nfunc parseObject(c *parseContext, i int, path string) (int, bool) {\n     var pmatch, kesc, vesc, ok, hit bool\n     var key, val string\n     rp := parseObjectPath(path)\n     if !rp.more && rp.piped {\n         c.pipe = rp.pipe\n         c.piped = true\n     }\n     // 두 개의 for 루프를 중첩하여 키 값을 찾습니다.\n     for i < len(c.json) {\n         for ; i < len(c.json); i++ {\n             if c.json[i] == '\"' {\n                 i++\n                 var s = i\n                 for ; i < len(c.json); i++ {\n                     if c.json[i] > '\\\\' {\n                         continue\n                     }\n                     // 키 값을 찾고 parse_key_string_done으로 이동합니다.\n                     if c.json[i] == '\"' {\n                         i, key, kesc, ok = i+1, c.json[s:i], false, true\n                         goto parse_key_string_done\n                     }\n                     ...\n                 }\n                 key, kesc, ok = c.json[s:], false, false\n                 // break\n              parse_key_string_done:\n                     break\n                 }\n                 if c.json[i] == '}' {\n                     return i + 1, false\n                 }\n             }\n             if !ok {\n                 return i, false\n             }\n             // 퍼지 매치인지 확인합니다.\n             if rp.wild {\n                 if kesc {\n                     pmatch = match.Match(unescape(key), rp.part)\n                 } else {\n                     pmatch = match.Match(key, rp.part)\n                 }\n             } else {\n                 if kesc {\n                     pmatch = rp.part == unescape(key)\n                 } else {\n                     pmatch = rp.part == key\n                 }\n             }\n             // 값을 파싱합니다.\n             hit = pmatch && !rp.more\n             for ; i < len(c.json); i++ {\n                 switch c.json[i] {\n                 default:\n                     continue\n                 case '\"':\n                     i++\n                     i, val, vesc, ok = parseString(c.json, i)\n                     if !ok {\n                         return i, false\n                     }\n                     if hit {\n                         if vesc {\n                             c.value.Str = unescape(val[1 : len(val)-1])\n                         } else {\n                             c.value.Str = val[1 : len(val)-1]\n                         }\n                         c.value.Raw = val\n                         c.value.Type = String\n                         return i, true\n                     }\n                 case '{':\n                     if pmatch && !hit {\n                         i, hit = parseObject(c, i+1, rp.path)\n                         if hit {\n                             return i, true\n                         }\n                     } else {\n                         i, val = parseSquash(c.json, i)\n                         if hit {\n                             c.value.Raw = val\n                             c.value.Type = JSON\n                             return i, true\n                         }\n                     }\n                 ...\n                 break\n             }\n         }\n     }\n     return i, false\n}\n```\n\n`parseObject` 코드를 검토할 때 JSON 파싱이나 문자열 탐색 방법을 가르치는 것이 아니라 나쁜 경우의 시나리오를 설명하는 것이 목적이었습니다. 중첩된 for 루프와 연이어 나오는 if 문들은 압도적일 수 있고, 직장에서 만난 동료의 코드를 떠올릴 수도 있습니다.\n\n## 하위 요약\n\n장점:\n\n<div class=\"content-ad\"></div>\n\n- 성능: jsonparser는 표준 라이브러리와 비교하여 상대적으로 우수한 성능을 보여줍니다.\n- 유연성: 다양한 검색 방법과 사용자 정의 반환 값 옵션을 제공하여 매우 편리합니다.\n\n단점:\n\n- JSON 유효성 검사 미지원: JSON 입력의 정확성을 확인하지 않습니다.\n- 코드 구조가 지저분하고 읽기 어렵다. 유지보수가 어려울 수 있습니다.\n\n## 참고문서\n\n<div class=\"content-ad\"></div>\n\nJSON 값을 가져오기 위해 JSON을 파싱할 때, 지정된 키에 따라 GetMany 함수가 JSON 문자열을 여러 번 횡단합니다. JSON을 맵으로 변환하면 횡단 횟수를 줄일 수 있습니다.\n\n## 결론\n\njsonparser는 주목할 만한 성능과 유연성을 가지고 있지만, JSON 유효성 검사 부족과 복잡하고 읽기 어려운 코드 구조는 상당한 단점으로 나타납니다. JSON을 파싱하고 값을 자주 가져와야 하는 경우, 성능과 코드 유지 관리성 사이의 균형을 고려해야 합니다.\n\n# jsonparser\n\n<div class=\"content-ad\"></div>\n\n## 분석\n\njsonparser는 입력 JSON 바이트 슬라이스도 처리하며 여러 키를 전달하여 값을 빠르게 찾아내고 반환할 수 있습니다.\n\nGJSON과 유사하게, jsonparser는 fastjson이 하는 것처럼 파싱된 JSON 문자열을 데이터 구조에 캐시하지 않습니다. 하지만 다수의 값을 파싱해야 하는 경우 EachKey 함수를 사용하여 JSON 문자열을 한 번에 여러 값으로 파싱할 수 있습니다.\n\n일치하는 값을 찾으면 jsonparser는 추가적인 탐색 없이 즉시 반환합니다. 다수의 일치하는 값이 있을 경우 전체 JSON 문자열을 탐색합니다. JSON 문자열에서 경로가 일치하는 값이 없다면 여전히 전체 문자열을 탐색합니다.\n\n<div class=\"content-ad\"></div>\n\njsonparser는 재귀 사용을 줄이고 호출 스택의 깊이를 낮추며 성능을 향상시키기 위해 JSON 탐색 중에 루프를 사용합니다.\n\nArrayEach, ObjectEach 및 EachKey 함수는 사용자 정의 함수를 전달하여 특정 요구 사항을 충족시키는 기능을 제공하여 jsonparser의 유틸리티를 크게 향상시킵니다.\n\njsonparser의 코드는 간단하고 명확하여 분석하기 쉽습니다. 관심 있는 사람은 직접 검토할 수 있습니다.\n\n## 하위 요약\n\n<div class=\"content-ad\"></div>\n\njsonparser의 뛰어난 성능은 다음과 같은 이유가 있습니다:\n\n- 재귀를 최소화하기 위해 for 루프를 사용합니다.\n- 표준 라이브러리와는 달리 반영(reflection)을 사용하지 않습니다.\n- 해당 키 값이 발견되면 즉시 종료하여 추가 재귀를 피합니다.\n- 전달된 JSON 문자열에서 작업하며 새로운 공간을 할당하지 않아 메모리 할당을 줄입니다.\n\n또한 API 디자인이 편리합니다. ArrayEach, ObjectEach, EachKey와 같은 함수는 사용자 정의 함수를 전달할 수 있어 실제 비즈니스 개발에서 많은 문제를 해결할 수 있습니다.\n\n하지만 jsonparser에는 중요한 단점이 있습니다: JSON을 유효성 검사하지 않습니다. 입력이 유효한 JSON이 아닌 경우 jsonparser는 감지하지 못합니다.\n\n<div class=\"content-ad\"></div>\n\n# 성능 비교\n\n## 작은 JSON 문자열 구문 분석\n\n약 190바이트 정도의 간단한 JSON 문자열을 구문 분석하는 것\n\n![이미지](/assets/img/2024-06-22-Analyzevarioushigh-performanceJSONparsinglibrariesinGo_5.png)\n\n<div class=\"content-ad\"></div>\n\n## JSON 문자열 구문 분석하기\n\n중간 정도 복잡성의 JSON 문자열을 구문 분석하려면, 대략 2.3KB 크기를 가질 것입니다.\n\n![이미지](/assets/img/2024-06-22-Analyzevarioushigh-performanceJSONparsinglibrariesinGo_6.png)\n\n## 큰 JSON 문자열 구문 분석하기\n\n<div class=\"content-ad\"></div>\n\nJSON 문자열을 파싱하려면, 대략 2.2MB의 크기가 있어요.\n\n![이미지](/assets/img/2024-06-22-Analyzevarioushigh-performanceJSONparsinglibrariesinGo_7.png)\n\n# 요약\n\n이 비교를 통해 여러 고성능 JSON 파싱 라이브러리를 분석했어요. 이 라이브러리들은 몇 가지 공통 특징을 공유하고 있어요:\n\n<div class=\"content-ad\"></div>\n\n- 리플렉션 사용을 피합니다.\n- JSON을 순차적으로 바이트 단위로 탐색하여 파싱합니다.\n- 입력 JSON 문자열을 직접 파싱하여 메모리 할당을 최소화합니다.\n- 성능을 위해 어느 정도의 호환성을 희생합니다.\n\n이런 점들을 고려해도, 각 라이브러리는 독특한 기능을 제공합니다. fastjson API는 가장 간단한 사용 방법을 제공하며, GJSON은 퍼지 검색 기능과 높은 사용자 정의 가능성을 제공합니다. jsonparser는 고성능 파싱 중에 콜백 함수 삽입을 지원하여 사용 편의성을 제공합니다.\n\n나의 사용 사례는 미리 정의된 필드와 가끔한 사용자 정의 작업이 포함된 HTTP 응답 JSON 문자열에서 특정 필드를 단순히 파싱하는 것이므로, jsonparser가 가장 적합한 도구입니다.\n\n그러므로 성능에 관심이 있다면 비즈니스 요구 사항을 기반으로 JSON 파서를 선택하는 것을 고려해보세요.\n\n<div class=\"content-ad\"></div>\n\n# 참고 자료\n\n- https://github.com/buger/jsonparser\n- https://github.com/tidwall/gjson\n- https://github.com/valyala/fastjson\n- https://github.com/json-iterator/go\n- https://github.com/mailru/easyjson\n- https://github.com/Jeffail/gabs\n- https://github.com/bitly/go-simplejson\n\n![이미지](/assets/img/2024-06-22-Analyzevarioushigh-performanceJSONparsinglibrariesinGo_8.png)\n\n## 👋 만약 이 정보가 도움이 되었다면, 아래 👏 버튼을 몇 번 눌러서 저자를 지원해주세요 👇\n\n<div class=\"content-ad\"></div>\n\n## 🚀 FAUN 개발자 커뮤니티에 참여하고 매주 비슷한 이야기를 이메일로 받아보세요","ogImage":{"url":"/assets/img/2024-06-22-Analyzevarioushigh-performanceJSONparsinglibrariesinGo_0.png"},"coverImage":"/assets/img/2024-06-22-Analyzevarioushigh-performanceJSONparsinglibrariesinGo_0.png","tag":["Tech"],"readingTime":16},{"title":"Julia로 프록시 서버 구축하는 방법","description":"","date":"2024-06-22 04:15","slug":"2024-06-22-BuildingAProxyServerInJulia","content":"\n\n올해에 서버 및 웹사이트를 배포하는 데 중요한 계획이 있어요. 1년 반 동안 데이터 과학 관점에서 웹 개발을 위해 타깃으로 삼는 줄리아 모듈 시리즈를 개발해 왔어요. 이러한 모듈들이 결합되어 상호 연결된 서버 시스템을 형성하고 이를 올해 초에 배포할 계획입니다. Chifi, Toolips, Olive와 관련해서는 2024년이 될 것입니다. 이 웹 시스템을 용이하게 지원하기 위해 만들어 놓은 생태계 개요를 확인하고 싶다면, chifi README가 좋은 시작점이에요:\n\nLaboratory의 배포를 용이하게 하기 위해, 서버 시스템이 인터넷과 통신할 필요가 있어요. 컴퓨터가 인터넷을 통해 다른 컴퓨터에 연결하는 데 필요한 여러 단계가 있고, 이 모든 단계에 대해 제 프로젝트를 직접 개발할 계획입니다.\n\n# 인터넷 서버\n\n인터넷은 표준화된 프로토콜 세트로, 컴퓨터가 다른 포트에 정렬된 다양한 헤더와 프로토콜을 사용하여 통신할 수 있게 합니다. 웹 기반 TCP 연결의 라우팅을 용이하게 하기 위해 사용되는 서로 다른 유형의 서버가 몇 가지 있어요. 표준 네트워킹 설정에 따라, 사용자를 URL 창에서 웹 페이지로 이동시키기 위한 과정 모두에 주소할 수 있는 다음 서버들이 일부입니다:\n\n<div class=\"content-ad\"></div>\n\n- 최상위 도메인(TLD) 이름 서버\n- 동적 호스트 컨트롤 프로토콜(DHCP) 서버\n- (도메인) 이름 서버(DNS)\n- 웹 서버(HTTP 서버)\n\n이 네 가지 서버 유형 중 두 가지는 서버를 인터넷에 연결하는 데 필요합니다. 이것들은 DHCP 서버와 웹 서버입니다. DHCP 서버는 집 네트워크에서 인터넷으로의 인터페이스이며, 이 서버는 연결된 각 클라이언트에 대해 외부 주소를 할당합니다. 이 주소는 네트워크 주소라고 합니다. 네트워크 주소는 두 가지 주소 유형 중 하나이며, 이는 인터넷 프로토콜에서 귀하의 서버를 다른 모든 서버와 명명하는 데 사용됩니다. 이러한 주소 유형은 각각 인터넷 프로토콜 버전 4와 인터넷 프로토콜 버전 6 (IPv4; IPv6)입니다.\n\nDHCP 서버는 넓은 인터넷, 로컬 네트워크 연결 및 귀하의 기기 간의 중개자 역할을 합니다. 이 서버는 귀하의 기기를 가져오고, 로컬 영역 네트워크(LAN)와 상호 작용하는 주소를 할당하며, 웹과 상호 작용하는 또 다른 주소를 할당합니다. 후자는 외부 또는 공용 IP 주소라고 하며, 전자는 로컬 IP 주소입니다.\n\n![image](/assets/img/2024-06-22-BuildingAProxyServerInJulia_0.png)\n\n<div class=\"content-ad\"></div>\n\n라우터는 DHCP 서버를 호스팅하기 위해 설계된 작은 기계입니다. 대부분의 경우, 라우터는 DHCP와 함께 웹 서버도 호스팅하며, 이를 통해 DHCP 서버를 구성할 수 있습니다. 이 웹 서버는 대중적으로 Default Gateway로 알려져 있으며, DHCP가 할당된 IP 주소의 라우터에 위치합니다.\n\n웹 브라우저에 Default Gateway를 입력하여 이 서버의 웹 인터페이스에 방문할 수 있습니다. 이 Default Gateway는 DHCP 서버를 실행 중인 라우터의 로컬 IP이며, DHCP 서버는 서버 측에서 포트 67을 사용합니다. 이 인터페이스를 통해 DHCP 서버를 구성할 수 있으며, 인터넷으로 다시 전달되는 포트를 포워딩할 수 있습니다. 네트워크의 Default Gateway에 액세스하려면 다음 명령어를 사용하실 수 있습니다.\n\n- Linux — ip route\n- Windows — ipconfig\n- OSx — netstat -nr\n\nURL은 프로토콜(http/https), 서브도메인, 도메인 이름, 최상위 도메인(TLD), 대상 또는 경로 및 매개변수 네 가지 부분으로 구성되어 있습니다. 서브도메인과 매개변수는 이 퍼즐의 선택적인 부분이므로, 이에 대해 집중해 보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n- 도메인 (name.tld)\n- 타겟\n- 아규먼트\n\n타겟과 아규먼트는 저희 웹 서버에서 처리되지만, 도메인은 DNS 서버에서 처리됩니다. 웹 브라우저에 URL을 입력하고 브라우저를 탐색할 때, 웹 브라우저는 TLD 네임 서버에 핑을 보냅니다. TLD 서버는 TLD 앞에 입력된 이름과 관련된 DNS에 대한 정보를 반환합니다. 이후 사용자는 TLD 서버에서 반환된 DNS 서버로 이동합니다. 그런 다음 DNS 서버는 그러한 이름을 로컬 IP로 라우팅합니다. 마지막으로 DNS 서버가 이 주소의 서버의 IP 및 포트를 반환한 후, 웹 브라우저는 해당 주소로 서브도메인 및 도메인 이름을 사용하여 이동합니다. 이름 서버에 대해 더 알고 싶다면, 저는 실제로 그 중 하나를 작성 중이고, 해당 프로젝트에 대해 작성한 두 부분을 여기에서 읽을 수 있습니다:\n\n위에서 언급된 서버들은 웹 서버를 호스팅하는 데 필수적이지만, 웹 개발에서 모두 다른 중요한 사용 사례를 가진 이러한 유형의 연결을 용이하게 하는 다양한 선택적 옵션이 있습니다. 더 고급 서버 인프라를 만드는 데 큰 도움이 되는 서버의 한 예로 프록시 서버라는 것이 있습니다.\n\n## 프록시 서버란 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n\"프록시\" 라는 단어는 다른 개체를 대표하는 것을 의미합니다. 예를 들어, 프록시 투표는 다른 사람이 내가 되는 척하여 투표한 투표를 나타냅니다. 컴퓨팅에서, 프록시 애플리케이션은 애플리케이션을 실행하는 데 사용되는 애플리케이션으로, 이상적으로는 해당 애플리케이션을 협박하게 합니다. 이 비유에서 투표는 우리의 애플리케이션이고, 프록시는 프록시 서버입니다. 왜 프록시 서버가 필요한지 이해하기 위해서는 우리의 애플리케이션을 고려하는 것이 타당합니다.\n\n우리의 도메인은 서버를 우리 IP로 연결할 것입니다 — 여기서 IP는 단순히 도메인이 연결된 기계를 가리킵니다. 각 포트에는 하나의 서버만 실행될 수 있다는 점을 염두에 두십시오. 웹 서버의 경우 포트는 항상 80이므로, 우리는 https://IP:80 에 하나의 서버만 배포할 수 있습니다. 이는 하나의 애플리케이션을 실행하려면 괜찮지만, 여러 애플리케이션을 실행하려면 새로운 IP — 전혀 새로운 컴퓨터가 필요하다는 것을 의미합니다. 물론 가상 IP 옵션도 있지만, 이 경우에서 가장 좋은 옵션은 다른 방법을 사용하는 것입니다.\n\n프록시 서버는 이 문제에 대한 인터넷의 표준적인 해결책입니다. 프록시 서버는 대상 이름에 대해 여러 서버 주소를 등록하고 요청 시에 해당 서버로 프록시 패스를 수행합니다. 현재 사용되는 대부분의 표준 프록시 서버는 SSL 및 부하 분산 기능과 결합되어 있습니다. 널리 사용되는 프록시 서버의 예로는 NGINX가 있습니다.\n\n## 부하 분산기란 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n서버가 종종 거대한 기계일 때 이유가 있습니다. 이론적으로 무한대의 클라이언트 목록을 제공하기 위해서는 많은 처리 능력이 필요합니다. 로드 밸런서가 없는 서버 시스템은 특정 도메인이나 IP를 요청하는 모든 클라이언트를 특정 서버로 보냅니다. 로드 밸런서가있는 서버 시스템은 들어오는 사용자를 여러 서버로 분산합니다. 이는 유용하며 프록시 서버의 사용 사례에 인접하기 때문에 로드 밸런싱은 프록시 서버 위에 쉽게 구현할 수 있습니다.\n\n# ChiProxy.jl\n\n오늘은 이 두 가지 개념을 결합하여 프록시 서버를 만들고, 최종적으로 SSL, 로드 밸런싱 및 더 많은 기능을 추가할 의도로 확장 가능한 프록시 라우팅 플랫폼에 프록시 서버를 만들겠습니다. 이 프로젝트는 ChiProxy 라고 부르겠습니다.\n\n![image](/assets/img/2024-06-22-BuildingAProxyServerInJulia_1.png)\n\n<div class=\"content-ad\"></div>\n\n# 프록시 서버 구축\n\n프록시 서버는 놀라울 정도로 유용하고 흥미로운 기능을 가지고 있지만, 복잡한 것은 아닙니다. 다행히도 나의 신경 쓸 부분은 없으며, 간단한 프록시 서버에서 데이터 전송 시 검토해야 할 헤더나 RST는 없습니다. 프록시 서버에서 우리가 정말로 해야 할 일은 들어오는 연결을 저장된 서버 주소(및 포트)로 보내는 것뿐입니다. 이를 어떻게 할지에 대한 몇 가지 아이디어가 있습니다. 특히 줄리아 타입 시스템 및 Toolips 하에서 어떻게 할지에 대한 아이디어가 있습니다. 이 단계로 진입하기 전에, 내 웹 개발 프레임워크의 발전에서 다음 중요 단계를 소개하고 싶습니다.\n\n![프록시 서버 구축](/assets/img/2024-06-22-BuildingAProxyServerInJulia_2.png)\n\n이 프로젝트에서는 새롭고 개선된 Toolips의 중대 버전을 사용할 것입니다! 이 중대 한 릴리스는 Toolips의 기본 컨셉을 달성했던 0.2와는 달리 0.3에서 컨셉을 아주 잘 달성했습니다. 시작 프로젝트도 이를 잘 반영한 것으로 생각됩니다. 그래서 새로운 앱인 ChiProxy를 생성해 보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n\n```js\nusing Toolips\nToolips.new_app(\"ChiProxy\")\n```\n\n이제 기본 프로젝트를 살펴보겠습니다.\n\n```js\nmodule ChiProxy\nusing Toolips\n\n# routes\nmain = route(\"/\") do c::Connection\n    write!(c, \"hello world!\")\nend\n\n# 404\nerr_404 = Toolips.default_404\n\nexport main, err_404\nend\n```\n\n이것을 예전 Toolips와 비교해 보면...\n\n\n<div class=\"content-ad\"></div>\n\n```js\r\nmodule ProgressTest\nusing Toolips\nusing ToolipsSession\nusing ToolipsCoolProgress\n# 새로운 Toolips 프로젝트에 오신 것을 환영합니다!\n\"\"\"\nhome(c::Connection) -> _\n--------------------\nhome 함수는 기본적으로 서버 내에서 라우트로 제공됩니다. 이를 변경하려면 아래의 start 메서드를 확인하십시오.\n\"\"\"\nfunction home(c::Connection)\n    prog = ToolipsCoolProgress.circular_progress(\"test\")\n    on(c, prog, \"click\") do cm::ComponentModifier\n        update_progress!(cm, prog, 50)\n    end\n    write!(c, p(\"helloworld\", text = \"hello world!\"))\n    write!(c, prog)\nend\n\nfourofour = route(\"404\") do c\n    write!(c, p(\"404message\", text = \"404, not found!\"))\nend\n\nroutes = [route(\"/\", home), fourofour]\nextensions = Vector{ServerExtension}([Logger(), Files(), Session(), ])\n\n\"\"\"\nstart(IP::String, PORT::Integer, ) -> ::ToolipsServer\n--------------------\nstart 함수는 WebServer를 시작합니다.\n\"\"\"\nfunction start(IP::String = \"127.0.0.1\", PORT::Integer = 8000)\n     ws = WebServer(IP, PORT, routes = routes, extensions = extensions)\n     ws.start(); ws\nend\n\n\nend # - module\r\n```\n\n이 버전은 이해하기 훨씬 쉽고, 훨씬 간결하며 — 확장부터 라우팅까지 모두 완전히 자동으로 처리됩니다. 이번 릴리스에 대한 자세한 정보가 포함된 개요를 곧 공개할 예정입니다.\n\n이 문제에 대한 내 접근 방식은 AbstractRoute 디스패치 아래에 여러 디스패치를 사용하는 것입니다. Toolips 0.3은 모듈 내에 정의된 모든 AbstractRoute을 찾아내기 때문에, 간단히 새로운 라우트 유형을 만들어서 라우트의 기능을 변경할 수 있습니다. 우리 프로젝트에서는 추상 타입 AbstractProxyRoute로 시작할 것입니다. 새로운 프로젝트로 아직 라우트를 생성하지 않을 것이며, 대신 서버 레코드를 간단하게 만들어 프록시 서버가 인식할 수 있도록 하는 기본적인 타입 시스템을 만들 것입니다.\n\n```js\r\nabstract type AbstractProxyRoute <: Toolips.AbstractRoute end\r\n```\n\n<div class=\"content-ad\"></div>\n\n## 프록시 라우트\n\n이 새로운 추상 타입을 기억하며, ProxyRoute를 상상해봅니다 — ProxyRoute에는 어떤 데이터가 필요할까요? AbstractRoute의 일관성을 확인하기 위해 ?를 사용할 수 있습니다:\n\n```js\nhelp?> Toolips.AbstractRoute\n```\n\n그래서 필요한 두 가지 일관성은 경로(path)와 route!로의 디스패치입니다. 구조를 시작해봅시다.\n\n<div class=\"content-ad\"></div>\n\n```js\nmodule ChiProxy\nusing Toolips\n\nabstract type AbstractProxyRoute <: Toolips.AbstractRoute end\n\nmutable struct ProxyRoute <: AbstractProxyRoute\n    path::String\nend\n\n# routes\nmain = route(\"/\") do c::Connection\n    write!(c, \"hello world!\")\nend\n\n# 404\nerr_404 = Toolips.default_404\n\nstart(IP::String = \"127.0.0.1\", PORT::Integer = 8000) = start!(ChiProxy, IP, PORT)\nend\n```\n\n자, 우리가 일관된 구조를 가진 라우팅을 가지게 되었으니, route!를 가져와 확장할 것입니다. route! 함수를 확장함으로써 우리는 두 가지를 할 수 있게 됩니다:\n\n- 새로운 라우터 생성.\n- 단일 라우트 기능 변경.\n\n```js\nimport Toolips: route!\n```\n\n<div class=\"content-ad\"></div>\n\n라우터 기능을 변경하려면 경로로 이동하며, 경로는 두 번 호출됩니다 - 벡터에서 한 번 호출되고, 그런 다음 다시 경로로 호출됩니다. 이에 대한 코드를 아래에서 확인하세요:\n\n```js\nmodule ChiProxy\nusing Toolips\nimport Toolips: route!\n\nabstract type AbstractProxyRoute <: Toolips.AbstractRoute end\n\nmutable struct ProxyRoute <: AbstractProxyRoute\n    path::String\nend\n\nfunction route!(c::Toolips.AbstractConnection, pr::AbstractProxyRoute)\n    write!(c, \"</br>수정된 `ProxyRoute` 페이지\")\nend\n\nfunction route!(c::Connection, vec::Vector{<:AbstractProxyRoute})\n    write!(c, Components.DOCTYPE())\n    write!(c, \"`Connection` 라우터를 수정합니다.\")\n    route!(c, pr)\nend\n```\n\n우리의 벡터는 라우트에 해당하는 높은 추상 유형으로 유지되어야 하므로 이를 기억해 주세요 - Vector'Union'... 으로 경로를 설정할 수 있습니다. 일반적으로 Julia 타입 추상화를 사용하며, AbstractRoute s의 벡터가 어떠한 특정 배열 차원인지에 따라 진행할 수 있습니다.\n\n라우트는 내보낸 경우에만 경로 설정됩니다. ProxyRoute 를 구성하고 내보내므로 이를 빠르게 테스트할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n```js\ntest = ProxyRoute(\"/\")\n```\n\n```js\nmodule ChiProxy\nusing Toolips\nimport Toolips: route!\n\nabstract type AbstractProxyRoute <: Toolips.AbstractRoute end\n\nmutable struct ProxyRoute <: AbstractProxyRoute\n    path::String\nend\n\nfunction route!(c::Toolips.AbstractConnection, pr::AbstractProxyRoute)\n    write!(c, \"</br>our modified `ProxyRoute` page\")\nend\n\nfunction route!(c::Connection, vec::Vector{<:AbstractProxyRoute})\n    write!(c, Components.DOCTYPE())\n    write!(c, \"our modified `Connection` router.\")\n            # indexing our routes with our `Connection's` route\n    route!(c, vec[get_route(c)])\nend\nmain = route(\"/\") do c::Connection\n    write!(c, \"$(c.routes)\")\nend\n\ntest = ProxyRoute(\"/\")\n# 404\nerr_404 = Toolips.default_404\n\nexport test\nend\n```\n\n이제 서버를 시작하여 라우터에 대한 메시지 하나와 Route에 대한 메시지 하나를 작성해야합니다.\n\n```js\ninclude(\"dev.jl\")\n``` \n\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-22-BuildingAProxyServerInJulia_3.png)\n\n여기서 필요한 마지막 것은 호스트입니다. 이는 get_host를 통해 얻을 수 있습니다.\n\n```js\nfunction route!(c::Toolips.AbstractConnection, pr::AbstractProxyRoute)\n    system = Toolips.get_client_system(c)\n    mobile = \"not mobile\"\n    if system[2]\n        mobile = \"mobile\"\n    end\n    write!(c, \"</br>our modified 'ProxyRoute' page<h3>host:</h3>\")\n    write!(c, get_host(c))\nend\n```\n\n![image](/assets/img/2024-06-22-BuildingAProxyServerInJulia_4.png)\n\n\n<div class=\"content-ad\"></div>\n\n이제 라우팅 시스템이 설정되었고 호스트 이름을 가지고 있으니, 기본 프록시 시스템을 확장할 수 있는 ProxyRoute의 필드를 확장할 것입니다. 이 경우에 경로가 호스트 이름이 될 것입니다. 여기서 이름의 트래픽을 리디렉트할 IP와 포트를 가져올 것입니다.\n\n```js\nabstract type AbstractProxyRoute <: Toolips.AbstractRoute end\n\nmutable struct ProxyRoute <: AbstractProxyRoute\n    path::String\n    ip::String\n    port::Int64\nend\n```\n\n새로운 필드인 ip와 port를 가지고 하위 함수를 만들어 이 유형을 쉽게 만들 것입니다.\n\n```js\nfunction proxy_route(path::String, ip::IP4)\n    ProxyRoute(path, ip.ip, ip.port)\nend\n```\n\n<div class=\"content-ad\"></div>\n\n이제 새로운 고수준 구문을 사용하여 ProxyRoute를 만들어 봅시다.\n\n```js\n테스트 = proxy_route(\"127.0.0.1:8000\", \"127.0.0.1\":8000)\n```\n\n## 기본 테스트\n\n프록시 라우터의 기본 사항을 작성했으니, 모든 데이터를 보여주고 프록시 서버가 무엇을 하는지 보여줄 기본 레이아웃을 만들어 봅시다. 다음 예제에서는 라우트된 호스트를 출력한 다음 그 호스트를 실행할 서버를 선택합니다. 여기서 기대하는 바는 127.0.0.1이 두 번 나열되는 것을 볼 수 있어야 합니다.\n\n<div class=\"content-ad\"></div>\n\n```kotlin\nfun route!(c::Toolips.AbstractConnection, pr::AbstractProxyRoute)\n    write!(c, \"<h3>선택된 서버:</h3>$(pr.path)\")\nend\n\nfun route!(c::Connection, vec::Vector{<:AbstractProxyRoute})\n    write!(c, Components.DOCTYPE())\n    write!(c, \"저희 수정된 `Connection` 라우터입니다.\")\n    write!(c, \"<h3>호스트</h3>$(get_host(c))\")\n    route!(c, vec[get_host(c)])\nend\n```\n\n![Build Proxy Server](/assets/img/2024-06-22-BuildingAProxyServerInJulia_5.png)\n\n이제 할 일은 dev.jl에서 서버 포트를 80으로 변경하는 것입니다. 이 포트는 2000 미만이므로 방화벽 구성을 위해 조치해야 합니다. Windows나 OSX에서는 이를 어떻게 해야 할지 잘 모르겠습니다. Ubuntu에서는 Ubuntu Firewall인 ufw를 사용하면 됩니다.\n\n```bash\nufw allow 80\n```\n\n<div class=\"content-ad\"></div>\n\n저는 firewalld와 Fedora 38을 사용하고 있습니다. 다른 여러 배포판들도 firewalld를 사용하기 때문에, 만약 리눅스를 사용 중이라면 이 방법이 도움이 될 수도 있습니다.\n\n```js\nfirewall-cmd --zone=public --add-port=80/tcp\n```\n\n또 다른 방법으로는 방화벽 서비스를 구성할 수도 있습니다. 이 부분에 대해서는 설명을 드리지 않겠습니다. 추가로, 방화벽을 조정하지 않고 해결할 수 있는 빠른 방법은 sudo를 사용하는 것입니다. 이를 통해 root의 Bash 프로필이 사용되므로 root의 Julia 패키지를 사용하게 됩니다. 이는 이상적이지는 않지만 테스트 목적으로는 문제 없을 수도 있습니다. 포트를 포워딩하지 않는 비공개 네트워크에 연결돼 있다면 잘 동작할 것입니다.\n\n```js\nsudo julia -L dev.jl\n```\n\n<div class=\"content-ad\"></div>\n\n이제 서버가 80 포트에서 호스팅되고 있으므로 호스트 이름을 서버의 IP 주소로 변경하려고 합니다.\n\n```js\ntest = proxy_route(\"127.0.0.1\", \"127.0.0.1\":8000)\n```\n\n```js\nfunction route!(c::Toolips.AbstractConnection, pr::AbstractProxyRoute)\n    write!(c, \"<h3>선택된 서버:</h3>$(pr.ip):$(pr.port)\")\nend\n```\n\n이제 이 서버를 사용하려면 127.0.0.1에서 접속해야 합니다 — 웹 서버가 80 포트에 있으므로 포트를 사용할 필요가 없습니다. 우리의 ProxyRoute는 그런 다음 80 포트에서 8000 포트로 우리를 리디렉션해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-22-BuildingAProxyServerInJulia_6.png)\n\n프록시 라우팅을 마무리하려면 Toolips.proxy_pass!를 사용하여 연결을 리디렉션해야 합니다. 서버가 활성화되지 않았으면 터미널에 오류가 발생할 수 있습니다.\n\n```js\nfunction route!(c::Toolips.AbstractConnection, pr::AbstractProxyRoute)\n    proxy_pass!(c, \"http://$(pr.ip):$(pr.port)\")\nend\n```\n\n이것을 기억하면 다른 포트(8000)에서 호스팅된 또 다른 서버를 만들어야 합니다. 이 서버는 이 프록시 패스에 응답할 것입니다.\n\n\n<div class=\"content-ad\"></div>\n\n\n```js\nmodule TestServer\nusing Toolips\nmain = route(\"/\") do c::Connection\n    write!(c, \"</br>this is 127.0.0.1 responding\")\nend\n\nexport main\nend\n```\n\n\n이 TestServer를 시작하려면 dev.jl을 업데이트해야 합니다. 일관성을 위해 두 파일을 살펴보겠습니다:\n\n- dev.jl\n\n```js\nusing Pkg; Pkg.activate(\".\")\nusing ChiProxy\nusing ChiProxy: TestServer\n\nChiProxy.start!(\"127.0.0.1\":80)\n\nTestServer.start!(\"127.0.0.1\":8000)\n```\n\n\n<div class=\"content-ad\"></div>\n\n- ChiProxy.jl\n\n```js\nmodule ChiProxy\nusing Toolips\nimport Toolips: route!\n\nabstract type AbstractProxyRoute <: Toolips.AbstractRoute end\n\nmutable struct ProxyRoute <: AbstractProxyRoute\n    path::String\n    ip::String\n    port::Int64\nend\n\nfunction proxy_route(path::String, ip::IP4)\n    ProxyRoute(path, ip.ip, ip.port)\nend\n\nfunction route!(c::Toolips.AbstractConnection, pr::AbstractProxyRoute)\n    Toolips.proxy_pass!(c, \"http://$(pr.ip):$(pr.port)\")\nend\n\nfunction route!(c::Connection, vec::Vector{<:AbstractProxyRoute})\n    write!(c, Components.DOCTYPE())\n    write!(c, \"our modified `Connection` router.\")\n    write!(c, \"<h3>host</h3>$(get_host(c))\")\n    route!(c, vec[get_host(c)])\nend\n\nmain = route(\"/\") do c::Connection\n    write!(c, \"$(c.routes)\")\nend\n\ntest = proxy_route(\"127.0.0.1\", \"127.0.0.1\":8000)\n# 404\nerr_404 = Toolips.default_404\n#== Test server\n==#\nmodule TestServer\nusing Toolips\n\nmain = route(\"/\") do c::Connection\n    write!(c, \"</br>this is 127.0.0.1 responding\")\nend\n\nexport main\nend\n#==\n==#\n\nexport test\nend\n```\n\n이제 다시 포트 80에서 시도해 봅시다.\n\n이제 8000번 포트의 서버가 80번 포트의 서버를 통해 응답했습니다. 다음 단계는 ProxyRoute 라우터에서 모든 쓰기를 제거하는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nmodule ChiProxy\nusing Toolips\nimport Toolips: route!\n\nabstract type AbstractProxyRoute <: Toolips.AbstractRoute end\n\nmutable struct ProxyRoute <: AbstractProxyRoute\n    path::String\n    ip::String\n    port::Int64\nend\n\nfunction proxy_route(path::String, ip::IP4)\n    ProxyRoute(path, ip.ip, ip.port)\nend\n\nfunction route!(c::Toolips.AbstractConnection, pr::AbstractProxyRoute)\n    Toolips.proxy_pass!(c, \"http://$(pr.ip):$(pr.port)\")\nend\n\nfunction route!(c::Connection, vec::Vector{<:AbstractProxyRoute})\n    route!(c, vec[get_host(c)])\nend\n\nmain = route(\"/\") do c::Connection\n    write!(c, \"$(c.routes)\")\nend\n\ntest = proxy_route(\"127.0.0.1\", \"127.0.0.1\":8000)\n# 404\nerr_404 = Toolips.default_404\n\nmodule TestServer\nusing Toolips\nmain = route(\"/\") do c::Connection\n    write!(c, \"</br>this is 127.0.0.1 responding\")\nend\n\nexport main\nend\n\nexport test\nend\n```\n\n## 결론\n\n이번 1월 초에 일들이 서두를 겪고 있습니다. 이 프록시 서버는 제가 개발할 긴 여정 중 단 한 걸음에 불과하며, DNS 서버와 함께 많은 웹 인프라를 구축하기 위한 준비를 세우고 있습니다. 물론 여전히 해야 할 일이 많습니다. 현재 우리의 프록시 서버에는 SSL도 없고 로드 밸런싱도 없으며, 여러 디스패치를 중심으로 한 이 구현에 대한 더 복잡한 계획도 있습니다.\n\n중요한 것은 Toolips의 이 전 릴리스 버전을 사용하고 있다는 점입니다. Toolips의 메인 실행 버전이 될 때까지 많은 일이 필요합니다. 이 릴리스는 전체 생태계를 파괴합니다. 다행히도, 실제로는 생각보다 더 부담스럽지 않고 이 새로운 Toolips 버전은 상당히 멋질 것입니다! 오늘 사용된 구문에서 유추하신 대로, 몇 가지 함수를 간단히 작성함으로써 Toolips용 사용자 정의 라우터를 만들 수 있습니다. Toolips가 개선된 유일한 측면이 아닙니다.\n\n<div class=\"content-ad\"></div>\n\n모두 읽어 주셔서 감사합니다. 제 웹 사이트는 곧 준비될 것이며 곧 돌아와서 로드 밸런싱 및 \"소스\"를 추가하는 이 프록시 서버의 두 번째 부분을 진행할 계획입니다. 그 후에는 파일 형식에서 프록시 설정을 불러와 완성된 프록시 서버를 갖게 될 것입니다. 다시 한 번 읽어 주셔서 감사합니다. 즐거운 하루 되세요.","ogImage":{"url":"/assets/img/2024-06-22-BuildingAProxyServerInJulia_0.png"},"coverImage":"/assets/img/2024-06-22-BuildingAProxyServerInJulia_0.png","tag":["Tech"],"readingTime":16},{"title":"GetX로 API 통합하기 Flutter를 이용한 쉬운 방법","description":"","date":"2024-06-22 04:13","slug":"2024-06-22-APIIntegrationusingGetXinflutter","content":"\n![APIIntegrationusingGetXinflutter](/assets/img/2024-06-22-APIIntegrationusingGetXinflutter_0.png)\n\n플러터에서 API 통합은 앱과 외부 서비스 간의 데이터 통신을 활성화하여 동적이고 실시간이며 확장 가능한 기능을 제공하고 서로 다른 플랫폼 간에 일관된 경험을 제공하는 데 중요합니다.\n\nAPI 통합은 플러터 애플리케이션이 외부 서비스와 상호 작용하고 데이터를 검색하고 다양한 기능을 수행할 수 있도록 가능하게 합니다. 다음은 플러터 개발에서 API 통합이 중요하게 간주되는 몇 가지 이유입니다:\n\n- 데이터 검색: 대부분의 애플리케이션은 데이터베이스, 서버 또는 제3자 서비스와 같은 외부 소스에서 데이터를 필요로합니다. API 통합을 통해 플러터 앱이 이러한 데이터를 동적으로 가져와 표시하므로 사용자가 항상 최신 정보에 액세스할 수 있습니다.\n- 실시간 업데이트: API를 사용하면 클라이언트(플러터 앱)와 서버 간의 실시간 통신이 가능해집니다. 이는 메시징 앱, 협업 도구 또는 실시간 데이터 피드와 같은 실시간 업데이트가 필요한 애플리케이션에 중요합니다.\n- 오프라인 지원: API는 장치에 로컬로 정보를 캐싱하여 오프라인 데이터 액세스를 지원할 수 있도록 설계될 수 있습니다. 이는 일시적이거나 인터넷 연결이 없는 환경에서 기능해야 하는 애플리케이션에 중요합니다.\n- 보안: API는 종종 인증 메커니즘을 통합하여 특정 데이터에만 인가된 사용자만이 액세스하거나 특정 작업을 수행할 수 있도록합니다. 이는 응용프로그램 및 데이터의 보안 유지에 도움이 됩니다.\n\n<div class=\"content-ad\"></div>\n\n## Android Studio에 JsonToDart 플러그인 설치하기\n\n플러그인: [JsonToDart](https://plugins.jetbrains.com/plugin/12562-jsontodart-json-to-dart-)\n\n## HTTP 패키지 추가하기\n\nHTTP 요청을 하기 위해 pubspec.yaml 파일에 http 패키지를 추가하고 flutter pub get을 실행하세요.\n\n<div class=\"content-ad\"></div>\n\n## Getx 패키지 추가하기\n\nGetX는 플러터를 위한 가벼우면서 강력한 솔루션입니다. 높은 성능의 상태 관리, 지능적인 의존성 주입, 빠르고 실용적인 라우트 관리를 결합하고 있습니다. GetX를 사용하려면 flutter pub add get 명령어를 실행하세요.\n\n## main.dart 파일에 GetMaterialApp 추가하기\n\n```js\nimport 'package:flutter/material.dart';\nimport 'package:get/get.dart'; // Get 패키지 가져오기\nimport 'UserListScreens.dart'; // 화면 파일 import하기\n\nvoid main() {\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({Key key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return GetMaterialApp(\n      debugShowCheckedModeBanner: false,\n      title: 'Flutter Demo',\n      theme: ThemeData(\n        colorScheme: ColorScheme.fromSwatch(primary: Colors.deepPurple), // 주요 색상 deepPurple로 설정\n        useMaterial3: false,\n      ),\n      home: const UserListScreen(), // 처음 화면으로 UserListScreen 표시\n    );\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## APIConstant 클래스 생성\n\n```js\nimport 'dart:io';\n\nclass APIConstant {\n\n  static const url = 'https://reqres.in/api/users?page=2';\n\n  static Map<String, String> authHeader = {\n    HttpHeaders.contentTypeHeader: 'application/json; charset=UTF-8'\n  };\n\n}\n```\n\n## UserModels 클래스 생성\n\n```js\nclass UserModels {\n  UserModels({\n    num? page,\n    num? perPage,\n    num? total,\n    num? totalPages,\n    List<Data>? data,\n    Support? support,\n  }) {\n    _page = page;\n    _perPage = perPage;\n    _total = total;\n    _totalPages = totalPages;\n    _data = data;\n    _support = support;\n  }\n\n  UserModels.fromJson(dynamic json) {\n    _page = json['page'];\n    _perPage = json['per_page'];\n    _total = json['total'];\n    _totalPages = json['total_pages'];\n    if (json['data'] != null) {\n      _data = [];\n      json['data'].forEach((v) {\n        _data?.add(Data.fromJson(v));\n      });\n    }\n    _support = json['support'] != null ? Support.fromJson(json['support']) : null;\n  }\n\n  num? _page;\n  num? _perPage;\n  num? _total;\n  num? _totalPages;\n  List<Data>? _data;\n  Support? _support;\n\n  UserModels copyWith({\n    num? page,\n    num? perPage,\n    num? total,\n    num? totalPages,\n    List<Data>? data,\n    Support? support,\n  }) => UserModels(\n    page: page ?? _page,\n    perPage: perPage ?? _perPage,\n    total: total ?? _total,\n    totalPages: totalPages ?? _totalPages,\n    data: data ?? _data,\n    support: support ?? _support,\n  );\n\n  num? get page => _page;\n  num? get perPage => _perPage;\n  num? get total => _total;\n  num? get totalPages => _totalPages;\n  List<Data>? get data => _data;\n  Support? get support => _support;\n\n  Map<String, dynamic> toJson() {\n    final map = <String, dynamic>{};\n    map['page'] = _page;\n    map['per_page'] = _perPage;\n    map['total'] = _total;\n    map['total_pages'] = _totalPages;\n    if (_data != null) {\n      map['data'] = _data?.map((v) => v.toJson()).toList();\n    }\n    if (_support != null) {\n      map['support'] = _support?.toJson();\n    }\n    return map;\n  }\n\n}\n\nclass Support {\n  Support({\n    String? url,\n    String? text,\n  }) {\n    _url = url;\n    _text = text;\n  }\n\n  Support.fromJson(dynamic json) {\n    _url = json['url'];\n    _text = json['text'];\n  }\n\n  String? _url;\n  String? _text;\n\n  Support copyWith({\n    String? url,\n    String? text,\n  }) => Support(\n    url: url ?? _url,\n    text: text ?? _text,\n  );\n\n  String? get url => _url;\n  String? get text => _text;\n\n  Map<String, dynamic> toJson() {\n    final map = <String, dynamic>{};\n    map['url'] = _url;\n    map['text'] = _text;\n    return map;\n  }\n\n}\n\nclass Data {\n  Data({\n    num? id,\n    String? email,\n    String? firstName,\n    String? lastName,\n    String? avatar,\n  }) {\n    _id = id;\n    _email = email;\n    _firstName = firstName;\n    _lastName = lastName;\n    _avatar = avatar;\n  }\n\n  Data.fromJson(dynamic json) {\n    _id = json['id'];\n    _email = json['email'];\n    _firstName = json['first_name'];\n    _lastName = json['last_name'];\n    _avatar = json['avatar'];\n  }\n\n  num? _id;\n  String? _email;\n  String? _firstName;\n  String? _lastName;\n  String? _avatar;\n\n  Data copyWith({\n    num? id,\n    String? email,\n    String? firstName,\n    String? lastName,\n    String? avatar,\n  }) => Data(\n    id: id ?? _id,\n    email: email ?? _email,\n    firstName: firstName ?? _firstName,\n    lastName: lastName ?? _lastName,\n    avatar: avatar ?? _avatar,\n  );\n\n  num? get id => _id;\n  String? get email => _email;\n  String? get firstName => _firstName;\n  String? get lastName => _lastName;\n  String? get avatar => _avatar;\n\n  Map<String, dynamic> toJson() {\n    final map = <String, dynamic>{};\n    map['id'] = _id;\n    map['email'] = _email;\n    map['first_name'] = _firstName;\n    map['last_name'] = _lastName;\n    map['avatar'] = _avatar;\n    return map;\n  }\n\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## UserListController 클래스 생성 및 GetxController를 상속받도록 클래스 확장\n\n```js\nimport 'dart:async';\nimport 'dart:convert';\nimport 'dart:io';\nimport 'package:flutter/cupertino.dart';\nimport 'package:http/http.dart' as http;\nimport 'package:get/get.dart';\nimport 'package:post_project/Models/UserModels.dart';\nimport '../APIConstant.dart';\n\nclass UserListController extends GetxController implements GetxService {\n\n  var isLoading = true.obs;\n  var getUserList = <Data>[].obs;\n\n  @override\n  void onInit() {\n    super.onInit();\n    userList();\n  }\n\n  Future<dynamic> userList() async {\n    try {\n      final response = await http.get(\n        Uri.parse(APIConstant.url),\n        headers: APIConstant.authHeader,\n      );\n      debugPrint(\"UserList\");\n      debugPrint(response.body);\n      const utf8Decoder = Utf8Decoder(allowMalformed: true);\n      final decodedBytes = utf8Decoder.convert(response.bodyBytes);\n      Map<String, dynamic> responseBody = json.decode(decodedBytes);\n      if (response.statusCode == 200) {\n        isLoading.value = false;\n        UserModels model = UserModels.fromJson(responseBody);\n        getUserList.value = model.data!;\n      }\n    } on TimeoutException catch (e) {\n      isLoading.value = false;\n      debugPrint(e.toString());\n    } on SocketException catch (e) {\n      isLoading.value = false;\n      debugPrint(e.toString());\n    } on Error catch (e) {\n      isLoading.value = false;\n      debugPrint(e.toString());\n    } catch (e) {\n      debugPrint(e.toString());\n    }\n    return null;\n  }\n\n}\n```\n\n## listView를 위한 UserItems 위젯 작성\n\n```js\nimport 'package:flutter/material.dart';\nimport 'package:post_project/Models/UserModels.dart';\n\nclass UserItems extends StatelessWidget {\n\n  final Data data;\n  const UserItems({Key key, required this.data});\n\n  @override\n  Widget build(BuildContext context) {\n    return Padding(\n      padding: const EdgeInsets.all(8.0),\n      child: Container(\n        decoration: BoxDecoration(border: Border.all(color: Colors.black)),\n        child: Row(\n          children: [\n            SizedBox(\n              height: 100,\n              width: 70,\n              child: Image.network(\n                data.avatar.toString(),\n                fit: BoxFit.cover,\n              ),\n            ),\n            Padding(\n              padding: const EdgeInsets.all(15.0),\n              child: Column(\n                crossAxisAlignment: CrossAxisAlignment.start,\n                children: [\n                  Text(\n                    \"${data.firstName} ${data.lastName}\",\n                    style: const TextStyle(\n                        fontSize: 20, fontWeight: FontWeight.w600),\n                  ),\n                  const SizedBox(height: 5),\n                  Text(data.email.toString()),\n                ],\n              ),\n            )\n          ],\n        ),\n      ),\n    );\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## 이렇게 GetxController를 호출하세요\n\n```js\nfinal userListController = Get.put(UserListController(), permanent: true);\n```\n\n## UserListScreen 클래스를 생성하세요\n\n전체 코드:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\nimport 'package:get/get.dart';\nimport 'package:post_project/Controller/UserListController.dart';\nimport 'package:post_project/UserItems.dart';\n\nclass UserListScreen extends StatefulWidget {\n  const UserListScreen({super.key});\n\n  @override\n  State<UserListScreen> createState() => _UserListScreenState();\n}\n\nclass _UserListScreenState extends State<UserListScreen> {\n\n  final userListController = Get.put(UserListController(),permanent: true);\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        systemOverlayStyle: const SystemUiOverlayStyle(\n          statusBarColor: Colors.green,\n          statusBarIconBrightness: Brightness.dark, // For Android (dark icons)\n          statusBarBrightness: Brightness.light, // For iOS (dark icons)\n        ),\n        titleSpacing: 5,\n        centerTitle: false,\n        elevation: 0,\n        automaticallyImplyLeading: false,\n        backgroundColor: Colors.green,\n        title: const Text(\"User List\",\n            style: TextStyle(\n                fontSize: 18,\n                color: Colors.white,\n                fontWeight: FontWeight.w600)),\n      ),\n      body: Column(\n        children: [\n          Expanded(\n            child: Obx(() {\n              return userListController.getUserList.isEmpty\n                  ? const Center(\n                      child: Text(\"data\"),\n                    )\n                  : ListView.builder(\n                      shrinkWrap: true,\n                      itemCount: userListController.getUserList.length,\n                      itemBuilder: (BuildContext context, int index) {\n                        return UserItems(\n                            data: userListController.getUserList[index]);\n                      });\n            }),\n          )\n        ],\n      ),\n    );\n  }\n}\n```\n\n## 스크린샷:\n\n<img src=\"/assets/img/2024-06-22-APIIntegrationusingGetXinflutter_1.png\" />\n\n## 소스 코드:\n\n<div class=\"content-ad\"></div>\n\nGitHub 링크: [https://github.com/sanjaysharmajw/UserList](https://github.com/sanjaysharmajw/UserList)\n\n## 저와 소통해요:\n\n- LinkedIn: [https://www.linkedin.com/in/sanjaydeveloper/](https://www.linkedin.com/in/sanjaydeveloper/)\n- Instagram: [https://www.instagram.com/sanjayjw/](https://www.instagram.com/sanjayjw/)\n\n![이미지](/assets/img/2024-06-22-APIIntegrationusingGetXinflutter_2.png)\n\n<div class=\"content-ad\"></div>\n\n이 기사를 즐겨 보셨기를 바라요! 제공된 정보를 감사하게 생각하신다면, 'Buy Me A Coffee'로 저를 지원할 수 있어요! 여러분의 작은 선행에 감사하겠습니다!\n","ogImage":{"url":"/assets/img/2024-06-22-APIIntegrationusingGetXinflutter_0.png"},"coverImage":"/assets/img/2024-06-22-APIIntegrationusingGetXinflutter_0.png","tag":["Tech"],"readingTime":12},{"title":"강력한 저코드 Flutter IDE, Blup 소개하기","description":"","date":"2024-06-22 04:12","slug":"2024-06-22-IntroductiontoBlupAPowerfulLow-CodeFlutterIDE","content":"\n\n![블로그 시리즈](/assets/img/2024-06-22-IntroductiontoBlupAPowerfulLow-CodeFlutterIDE_0.png)\n\n# 소개\n\nBlup에 관한 우리의 블로그 시리즈에 오신 것을 환영합니다. Blup는 혁신적인 Low-Code Flutter IDE로 앱 개발 방식을 혁신하고 있습니다. 이 시리즈에서는 Blup의 기능, 장점, 그리고 이 강력한 도구를 사용하여 첫 번째 Flutter 앱을 만드는 방법에 대해 안내해 드리겠습니다.\n\n## Blup 개요\n\n<div class=\"content-ad\"></div>\n\nBlup은 플러터 앱 개발을 보다 간편하고 빠르게 만들 수 있도록 설계된 시각적 개발 환경입니다. 직관적인 드래그 앤 드롭 인터페이스를 통해 Blup을 사용하면 깊은 코딩 지식이 없어도 복잡한 애플리케이션을 만들 수 있습니다. Blup을 활용하여 개발자들은 창의성과 기능성에 집중할 수 있어 아이디어를 현실로 구현하는 데 필요한 시간과 노력을 줄일 수 있습니다.\n\n## 플러터 개발을 위해 Blup을 선택하는 이유\n\nBlup은 사용자 친화적인 디자인, 강력한 기능 및 기존 프로젝트와 원활하게 통합할 수 있는 능력으로 플러터 개발의 최상위 선택지로 자리매깁니다. 경험 많은 개발자든 앱 개발 초보든, Blup은 작업 흐름과 생산성을 향상시킬 도구와 자원을 제공합니다.\n\n# Blup이란 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\nBlup은 Flutter를 위해 특별히 설계된 로우코드 개발 환경입니다. Flutter는 구글이 제공하는 인기 있는 오픈소스 UI 소프트웨어 개발 키트입니다. Blup을 사용하면 시각적 드래그 앤 드롭 인터페이스와 미리 제공된 구성 요소 및 템플릿을 활용하여 최소한의 코딩 노력으로 크로스 플랫폼 모바일 애플리케이션을 만들 수 있습니다.\n\nBlup의 주요 기능:\n\n- 드래그 앤 드롭 인터페이스: UI 요소를 시각적으로 정렬하여 디자인 프로세스를 간소화합니다.\n- 미리 제공된 구성 요소 및 템플릿: 개발을 가속화하기 위해 다양한 사용 준비된 구성 요소를 제공합니다.\n- 실시간 협업: 여러 사용자가 동시에 동일한 프로젝트에 작업할 수 있도록 팀워크를 촉진합니다.\n- 기존 Flutter 프로젝트 통합: 현재의 Flutter 프로젝트와 원활하게 통합되어 처음부터 다시 시작하지 않고 발전시킵니다.\n- 코드 생성 및 사용자 정의: 시각적 디자인을 기반으로 자동으로 코드를 생성하고, 더 나은 특정 요구 사항을 충족시키기 위해 사용자 정의할 수 있습니다.\n\n다른 로우코드 플랫폼과 비교했을 때, Blup은 Flutter에 특별히 초점을 맞추어 Flutter 개발자들을 위한 최적화된 환경을 제공하여 눈에 띕니다. 이러한 초점은 플랫폼이 항상 최신의 Flutter 기능과 모베스트 프랙티스로 유지됨을 보장합니다.\n\n<div class=\"content-ad\"></div>\n\n# 다른 Low-Code 플랫폼과 비교\n\n![이미지](/assets/img/2024-06-22-IntroductiontoBlupAPowerfulLow-CodeFlutterIDE_1.png)\n\nBlup은 일반적인 Low-Code 도구와 다르게 Google이 개발한 인기 있는 오픈 소스 UI 소프트웨어 개발 키트인 Flutter에 중점을 두고 있어요. 일반적인 Low-Code 도구와 달리 Blup은 Flutter에 최적화되어 있어 Flutter 앱 개발에 더 관련성 있고 효율적인 기능을 제공해요.\n\n## Blup를 사용하는 이유\n\n<div class=\"content-ad\"></div>\n\n- 속도와 효율성: Blup은 많은 코딩 작업을 자동화하여 애플리케이션을 개발하고 배포하는 데 필요한 시간을 크게 단축합니다.\n- 접근성: Blup은 비개발자들에게 애플리케이션 개발을 접근 가능하게 하여 진입 장벽을 낮추고 더 많은 사람들이 기능적이고 시각적으로 매력적인 앱을 만들 수 있도록 합니다.\n- 유연성: 기존 프로젝트와 통합하고 코드를 사용자 정의할 수 있는 기능으로 Blup은 간편함과 유연성을 제공하여 다양한 사용자 요구를 충족합니다.\n\n# Blup의 주요 기능\n\n![Blup 소개 이미지](/assets/img/2024-06-22-IntroductiontoBlupAPowerfulLow-CodeFlutterIDE_2.png)\n\n기존 플러터 프로젝트와 통합\n\n<div class=\"content-ad\"></div>\n\nBlup은 플러터 앱 개발을 더 빠르고 쉽고 효율적으로 만들기 위해 설계된 다양한 기능으로 가득합니다. Blup을 개발자들이 최상의 선택으로 만드는 이유를 자세히 살펴보겠습니다:\n\n## 드래그 앤 드롭 인터페이스\n\n드래그 앤 드롭 인터페이스는 Blup의 핵심 요소로, 사용자가 복잡한 사용자 인터페이스를 방대한 코드를 작성하지 않고도 만들 수 있습니다. 구성 요소 라이브러리에서 요소를 간단히 드래그하여 디자인 캔버스에 놓아 원하는 위치에 정확히 배치할 수 있습니다.\n\n## 사전 제작된 구성 요소와 템플릿\n\n<div class=\"content-ad\"></div>\n\nBlup는 기본 UI 요소인 버튼과 텍스트 필드부터 내비게이션 서랍과 데이터 테이블과 같은 복잡한 구조물까지 다양한 미리 만들어진 구성 요소 및 템플릿 라이브러리를 제공합니다. 이러한 템플릿은 완전히 사용자 정의할 수 있어 프로젝트의 요구에 맞게 조정할 수 있습니다.\n\n## 실시간 협업 도구\n\nBlup는 실시간 협업을 지원하여 팀에게 최적의 선택지가 됩니다. 여러 개발자가 동시에 동일한 프로젝트에 작업할 수 있으며 서로의 변경 사항을 실시간으로 볼 수 있습니다. 이 기능은 생산성을 크게 향상시키며 모든 팀원이 동일한 페이지에 있는지 확인합니다.\n\n## 기존 Flutter 프로젝트 통합\n\n<div class=\"content-ad\"></div>\n\nBlup의 뛰어난 기능 중 하나는 기존 Flutter 프로젝트와 완벽하게 통합할 수 있는 능력입니다. 이는 Blup의 도구로 현재 프로젝트를 새로 시작하지 않고도 향상시킬 수 있음을 의미합니다. 시간과 노력을 절약할 수 있습니다.\n\n## 코드 생성 및 사용자 정의 옵션\n\nBlup은 시각적 디자인을 기반으로 청결하고 유지보수가 쉬운 코드를 자동으로 생성합니다. 이 코드는 추가적으로 사용자 정의할 수 있어서 로우코드 개발의 속도와 전통적 코딩의 유연성을 모두 누릴 수 있습니다.\n\n# Blup이 게임 체인저인 이유\n\n<div class=\"content-ad\"></div>\n\n블럽은 플러터 개발자에게 반드시 가져야 할 도구로서 여러 혁신적인 혜택을 제공합니다:\n\n## 앱 개발 속도 및 효율성\n\nBlup은 UI 디자인 과정을 간단하게 만들고 다양한 미리 제작된 구성 요소를 제공함으로써 앱을 구축하는 데 필요한 시간을 크게 단축시킵니다. 개발자들은 반복적인 코딩 작업에 시간을 허비하는 대신 기능과 사용자 경험에 더 집중할 수 있습니다.\n\n## 비 개발자를 위한 진입 장벽 낮추기\n\n<div class=\"content-ad\"></div>\n\nBlup의 직관적인 인터페이스는 개발자가 아닌 사람들에게 접근하기 쉽게 만들어 디자이너, 프로젝트 매니저 및 다른 이해 관계자들이 앱 개발 프로세스에 직접 참여할 수 있습니다. 이 앱 개발의 민주화는 혁신과 협업을 위한 새로운 가능성을 열어줍니다.\n\n## 사례 연구 또는 성공 스토리\n\nBlup은 이미 수많은 성공 이야기로 그 가치를 입증했습니다. 예를 들어, 작은 스타트업이 Blup을 활용하여 MVP(Minimum Viable Product)를 단 몇 주 만에 개발해 출시 기간을 크게 단축하고 빠르게 사용자 피드백을 수집하고 제품을 개선할 수 있었습니다.\n\n또 다른 예로는 대규모 기업이 내부 앱 개발 프로세스를 간소화하기 위해 Blup을 도입하여 생산성이 40% 향상되고 개발 비용이 30% 감소한 사례가 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\nBlup은 고급 기능과 사용 편의성을 결합한 강력한 로우코드 IDE를 제공하여 Flutter 앱 개발을 혁신할 준비가 되어 있습니다. 생산성을 높이고 싶은 베테랑 개발자이든 앱 개발에 빠져들고 싶은 초보자이든 Blup은 성공을 거두기 위해 필요한 도구와 유연성을 제공합니다.\n\n저희 시리즈의 다음 부분을 기대해주시기 바랍니다. Blup의 인터페이스를 탐험하는 방법과 설정 프로세스를 안내해 드릴 것입니다. Blup을 사용하면 아름답고 기능적인 Flutter 앱을 만드는 것이 이제보다 쉬워집니다.","ogImage":{"url":"/assets/img/2024-06-22-IntroductiontoBlupAPowerfulLow-CodeFlutterIDE_0.png"},"coverImage":"/assets/img/2024-06-22-IntroductiontoBlupAPowerfulLow-CodeFlutterIDE_0.png","tag":["Tech"],"readingTime":5},{"title":"Flutter에서 Go Router를 사용해 타입-안전 내비게이션 구현하는 방법","description":"","date":"2024-06-22 04:10","slug":"2024-06-22-HowtoImplementType-SafeNavigationwithGoRouterinFlutter","content":"\n## Flutter에서 안전한 탐색: Go Router 및 Go Router Builder와 함께하는 가이드\n\n<img src=\"/assets/img/2024-06-22-HowtoImplementType-SafeNavigationwithGoRouterinFlutter_0.png\" />\n\n# 배경\n\n타입 안전한 네비게이션을 사용하면 탐색 로직이 일관되고 유지보수가 용이해지며 디버깅 및 향후 코드 수정이 상당히 간단해집니다.\n\n<div class=\"content-ad\"></div>\n\n이 기술은 웹용 Flutter 앱을 구축할 때 특히 유용합니다. URL을 원활하게 관리하고 부드러운 네비게이션 경험을 보장해줍니다.\n\n이 블로그에서는 go_router 및 go_router_builder 패키지를 사용하여 Flutter에서 유형 안전한 네비게이션을 구현하는 방법을 살펴볼 것입니다.\n\n종료까지, 유형 안전한 라우트 설정, 코드 생성 및 Flutter 애플리케이션에서 네비게이션을 관리하는 방법에 대해 포괄적으로 이해하게 될 것입니다.\n\n# 소개\n\n<div class=\"content-ad\"></div>\n\n타입 안전한 네비게이션을 사용하면 네비게이션 로직이 일관되고 오류가 없음을 보장합니다.\n\n매개변수를 잘못 구문 분석하거나 경로 이름과 매개변수에 오타를 쓰는 위험을 제거하여 코드를 유지 관리하기 쉽고 디버깅하기 쉬운 상태로 유지할 수 있습니다.\n\n웹을 대상으로 하는 플러터 앱을 개발할 때 타입 안전한 네비게이션을 사용하여 URL을 쉽게 관리할 수 있습니다.\n\n이 블로그를 통해 최종적으로 얻을 것은 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n마크다운 형식으로 테이블 태그를 변경해주세요.\n\n<div class=\"content-ad\"></div>\n\n우리는 우리가 반복적으로 하는 것이다. 훌륭함은 행위가 아니라 습관이다. Justly를 시도해보고 오늘부터 당신의 습관을 만들어보세요!\n\n# 시작해봅시다\n\n전체를 5단계로 나눠서 더 잘 이해할 수 있도록 설명해 드리겠습니다.\n\n## 단계 1: 의존성 추가\n\n<div class=\"content-ad\"></div>\n\n프로젝트의 pubspec.yaml 파일에 종속성을 추가해주세요.\n\n```yaml\ndependencies:\n  # Router API 기반의 내비게이션을 활용하기 위해 필요합니다.\n  go_router: <최신 버전>\n\ndev_dependencies:\n  # go_router와 함께 타입 안전한 경로를 생성하기 위한 도구입니다.\n  go_router_builder: <최신 버전>\n  # go_router_builder의 코드 생성을 실행하는 도구입니다.\n  build_runner: <최신 버전>\n```\n\n## 단계 2: 경로 정의\n\n이제 각 화면에 대한 클래스를 만들어 GoRouteData로 확장하고, 최상위 경로에 @TypedGoRoute() 주석을 추가해주세요.\n\n<div class=\"content-ad\"></div>\n\n모든 클래스를 하나의 파일에 작성하여 코드 생성을 보다 쉽게 할 수 있도록 해 보세요.\n\n```js\n@TypedGoRoute<HomeRoute>(\n  path: '/',\n  routes: [\n    TypedGoRoute<ItemDetailsRoute>(path: 'items/:id')\n  ],\n)\nclass HomeRoute extends GoRouteData {\n  @override\n  Widget build(BuildContext context, GoRouterState state)\n    => const HomeScreen();\n}\n\nclass ItemDetailsRoute extends GoRouteData {\n  final String id;\n  const ItemDetailsRoute({required this.id});\n\n  @override\n  Widget build(BuildContext context, GoRouterState state) =>\n      ItemDetailsScreen(id: id);\n}\n\n@TypedGoRoute<SignInRoute>(\n  path: '/sign-in',\n  routes: [\n    TypedGoRoute<VerifyOtpRoute>(path: \"verify\"),\n  ],\n)\nclass SignInRoute extends GoRouteData {\n  @override\n  Widget build(BuildContext context, GoRouterState state) =>\n      const SignInScreen();\n}\n\nclass VerifyOtpRoute extends GoRouteData {\n  final String $extra;\n\n  const VerifyOtpRoute({required this.$extra});\n\n  @override\n  Widget build(BuildContext context, GoRouterState state) =>\n     VerifyOtpScreen(verificationId: $extra);\n}\n```\n\n이 코드에서는 각 화면에 대한 클래스를 GoRouteData를 확장하고 TypedGoRoute로 주석 처리하여 생성했습니다. 또 다른 화면으로 데이터를 전달하기도 했습니다.\n\n자세히 살펴보겠습니다.\n\n<div class=\"content-ad\"></div>\n\nGoRouteData: GoRouteData은 화면이나 페이지를 반환하거나 사용자를 다른 페이지로 리디렉션하는 메서드를 오버라이드할 수 있는 추상 클래스입니다. 이 메서드들 중 하나를 반드시 사용해야 합니다.\n\n```js\nclass HomeRoute extends GoRouteData {\n\n  // 이렇게 parentNavigationKey를 정의할 수 있습니다. (선택 사항)\n  static final GlobalKey<NavigatorState> $parentNavigatorKey = rootNavigatorKey;\n\n  @override\n  Widget build(BuildContext context, GoRouterState state) {\n    // 여기서 반환된 위젯은 사용자가 이 경로로 이동할 때 표시됩니다.\n    return const HomeScreen();\n}\n\n  @override\n  Page<void> buildPage(BuildContext context, GoRouterState state) {\n    // 여기서 반환된 Page는 사용자가 이 경로로 이동할 때 표시됩니다.\n    // 여기서 CustomTransitionPage를 반환하여 페이지 전환을 설정할 수도 있습니다.\n    return const CupertinoPage(child: HomeScreen());\n  }\n\n  @override\n  String? redirect(BuildContext context, GoRouterState state){\n      // 여기서 이 경로로 이동할 때 사용자를 리디렉션해야 할 위치나 경로를 지정할 수 있습니다.\n      return \"/login\";\n      // 리디렉션을 막으려면 null을 반환하세요.\n  }\n}\n```\n\nTypedGoRoute: TypedGoRoute 어노테이션은 경로 트리를 정의하는 데 사용됩니다. 맨 위 수준 경로 클래스마다 TypedGoRoute를 사용하여 경로 목록을 생성해야 합니다.\n\n```js\n@TypedGoRoute<TopLevelRoute>(\n  path: '/top-level-route-path',\n  routes: [\n    // 여기에 서브 루트 어노테이션을 이렇게 정의할 수 있습니다.\n    TypedGoRoute<SubRoute>(\n        path: 'sub-route-path'\n        routes: []\n        name: 'sub route'\n    )\n  ],\n  name: 'top level route' // 선택 사항\n)\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n@TypedGoRoute<MyRouteGeneric>()\n```\n\n이제 쿼리 매개변수, 경로 매개변수 및 라우트에서 추가 매개변수를 어떻게 사용할 수 있는지 알아봅시다.\n\n경로 매개변수:\n\n- 경로 매개변수는 : 기호를 사용하여 라우트 경로 내에 정의됩니다 (예: /products/:id).\n- URL 구조의 특정 부분을 나타냅니다.\n\n<div class=\"content-ad\"></div>\n\n쿼리 매개변수:\n\n- URL 뒤에 ? 기호를 붙여 데이터를 추가합니다 (예: /products?category=electronics).\n- 요청을 수정하는 선택적인 필터와 같은 데이터에 사용됩니다.\n\n추가: 경로나 쿼리 매개변수로 캡처되지 않는 경로로 데이터를 전달하는 방법, 추가 개체를 전달할 수 있습니다.\n\n```js\n@TypedGoRoute<ProductDetailsRoute>(path: '/details/:id')\nclass ProductDetailsRoute extends GoRouteData {\n  // path에 정의된 변수 이름이 경로 매개변수로 사용됩니다.\n  final String id;\n\n  // path에 정의되지 않은 변수 이름은 쿼리 매개변수로 사용됩니다.\n  final String code;\n\n  // 추가 데이터를 사용하려면 변수 이름을 $extra로 설정해야 합니다.\n  final String $extra;\n\n  const ProductDetailsRoute({required this.id, required this.code, required this.$extra});\n\n  @override\n  Widget build(BuildContext context, GoRouterState state) =>\n      ProductDetails(pathParameterId: id, queryParameterCode:code, extraData: $extra);\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## 단계 3: 코드 생성\n\n루트를 정의한 후에는 루트 목록과 확장을 생성해야 합니다. 이를 위해 build_runner를 사용해야 합니다.\n현재 파일에 생성된 파일 파트를 추가해 보겠습니다.\n\n```js\npart 'routes.g.dart'; //part '<current-file>.g.dart';\n```\n\n이제 build_runner 명령어를 실행해 봅시다.\n\n<div class=\"content-ad\"></div>\n\n```js\ndart run build_runner build --delete-conflicting-outputs\n```\n\n현재 파일 디렉토리에 routes.g.dart 파일이 생성됩니다.\n\n## 단계 4: GoRouter 초기화\n\n이제 $appRoutes를 routes에 전달할 수 있으며, 생성된 location getter를 사용하여 정확한 경로 위치를 가져올 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n최종 라우터는 GoRouter(\n  initialLocation: HomeRoute().location, // location getter is generated.\n  //$appRoutes is generated\n  routes: $appRoutes,\n  redirect: (context, state) { // Optional\n    // 여기서 경로 위치를 반환하여 리디렉션이 가능합니다.\n    // 또한 사용자가 검색 URL을 통해 화면으로 이동하는 것을 방지할 수도 있습니다.\n    // 리디렉트를 방지하려면 null을 반환합니다.\n  }\n  errorBuilder: (context, e) => ErrorScreen(e), // Optional\n  navigatorKey: rootNavigationKey, //Optional\n);\n```\n\n## 단계 5: 다른 화면으로 이동\n\n이제 라우트를 설정했으니, 다른 화면으로 이동하는 네비게이션 방법을 살펴봅시다.\n\n## Go:\n\n<div class=\"content-ad\"></div>\n\n현재 화면 스택을 주어진 경로 대상으로 교체해주세요.\n\n```js\nawait Screen2Route(id: id).go(context);\n```\n\n![이미지](https://miro.medium.com/v2/resize:fit:1000/1*ZO9gaACCAYOszpSV1_gbKQ.gif)\n\n## 푸시:\n\n<div class=\"content-ad\"></div>\n\n페이지 스택에 위치를 푸시하세요.\n\n```js\nawait Screen2Route(id: id).push(context);\n\n// push 과정에서 값 반환도 가능합니다\nfinal result = await Screen2Route(id: id).push(context);\n```\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1000/1*_xSN1WMXDp7Oc92CBl6HMA.gif\" />\n\n## Push Replacement:\n\n<div class=\"content-ad\"></div>\n\n가장 위에 있는 페이지 스택을 해당 URL 위치로 대체합니다.\n\n```js\nawait Screen2Route(id: id).pushReplacement(context);\n```\n\n![이미지](https://miro.medium.com/v2/resize:fit:1000/1*GNaChKuABcE4PejKUFFe9A.gif)\n\n## 대체:\n\n<div class=\"content-ad\"></div>\n\n가장 상단의 스택 페이지를 주어진 페이지로 교체하지만, 동일한 페이지로 취급합니다.\n\n```js\nawait Screen2Route(id: id).replace(context);\n```\n\n![이미지](https://miro.medium.com/v2/resize:fit:1000/1*_S9SyTnfBPEFAUMNloXz1g.gif)\n\n이제 네비게이션 구현을 마쳤습니다. 👏\n\n<div class=\"content-ad\"></div>\n\n![image](https://miro.medium.com/v2/resize:fit:1000/0*QwBEMwvqVkuL2OUM.gif)\n\nNow, let’s take a look at how we can implement a shell route with type-safe navigation using go_router and go_router_builder.\n\n## Related Articles\n\nWe're grateful to have you on this journey with us!\n\n<div class=\"content-ad\"></div>\n\n만약 읽은 내용이 마음에 드신다면, 아래에 👏 👏👏를 꼭 눌러주시기 바랍니다. 작가로서 이것은 정말 소중한 일이에요!\n\n아래 댓글 섹션에서 의견을 공유해주세요. 여러분의 의견은 콘텐츠를 더욱 풍부하고 가치 있는 것으로 만들어주며, 더 많은 유익한 기사를 작성할 동기를 얻게 해줍니다.\n\n흥미로운 기사 업데이트를 받으시려면 Canopas를 팔로우해주세요!\n","ogImage":{"url":"/assets/img/2024-06-22-HowtoImplementType-SafeNavigationwithGoRouterinFlutter_0.png"},"coverImage":"/assets/img/2024-06-22-HowtoImplementType-SafeNavigationwithGoRouterinFlutter_0.png","tag":["Tech"],"readingTime":8},{"title":"Retrofit과 Flutter로 프로처럼 개발하는 방법","description":"","date":"2024-06-22 04:08","slug":"2024-06-22-RetrofitandFlutterlikeaPRO","content":"\n![이미지](/assets/img/2024-06-22-RetrofitandFlutterlikeaPRO_0.png)\n\n데이터 처리 및 API 통합은 저희 모바일 개발자들에게 친숙한 주제입니다.\n\nFlutter로 이를 처리하는 몇 가지 방법이 있습니다. 이 기사에서는 REST API를 처리하는 데 가장 효과적이라고 생각하는 방법을 보여드립니다. 이 멋진 기사를 보신 후에는 다른 것을 사용하지 않게 될 것입니다!\n\n우리는 훌륭한 Retrofit 패키지에 대해 알아볼 것입니다. 이 패키지는 Dio 패키지의 유형 변환을 수행하며 (JSON을 Dart 객체로 변환하는 고통스러운 작업을 source_gen을 사용해 코드를 생성함으로써) 번거로움을 줄여줍니다. 시작해 봅시다.\n\n<div class=\"content-ad\"></div>\n\n- 개요\n- 설치\n- Retrofit 구성 방법\n- 사용 방법\n- 모든 호출에 토큰 추가하는 방법\n- freezed와 Retrofit 사용 방법\n- 응답 캐시하는 방법\n- 트래픽 로깅하는 방법\n- 편리한 팁\n\n# 개요\n\n4년 전에 Flutter를 개발하기 시작했을 때 처음 검색했던 것은 REST API를 올바르게 처리하는 방법이었습니다.\n\n안드로이드 개발자로서, Square의 Retrofit이 인터페이스와 주석을 사용하여 HTTP 요청을 설명하는 방법을 좋아했습니다. 다행히 누군가가 이 아이디어를 가져와 Flutter 세계에 구현했습니다.\n\n<div class=\"content-ad\"></div>\n\n플러터 버전에서도 REST 작업을 설명하는 인터페이스(추상 클래스)를 사용하며 대화 형식을 자동으로 만들어줍니다.\n\n안드로이드 버전은 기본 호출자로 OkHttp를 사용했습니다. 플러터의 경우 Dio를 사용하며, 이는 Dio를 사용하기 매우 쉽고 훌륭한 기능이 많이 포함되어 있어 기쁜 소식입니다. 또한 Retrofit과 함께 사용할 수 있는 애드온 몇 가지가 있어 REST에 추가적인 기능을 더해줄 수 있습니다. 예를 들어:\n\n- dio_cookie_manager - Dio용 쿠키 매니저\n- dio_http2_adapter - HTTP/2.0을 지원하는 Dio HttpClientAdapter\n\n<div class=\"content-ad\"></div>\n\n# dio_smart_retry\n\nDio를 위한 유연한 재시도 라이브러리\n\n# dio_cache_interceptor\n\n여러 저장소를 존줍하여 HTTP 지시문을 준수하는 (또는 그렇지 않은) Dio HTTP 캐시 인터셉터\n\n# dio_http_cache\n\n안드로이드의 Rxcache와 같은 Dio를 위한 간단한 캐시 라이브러리\n\n# pretty_dio_logger\n\n네트워크 호출을 읽기 쉬운 형식으로 로그하는 Dio 인터셉터, 예쁜 Dio 로거\n\n<div class=\"content-ad\"></div>\n\n# 설치\n\npubspec.yaml 파일에 아래 내용을 dependencies 아래에 추가해주세요:\n\n```js\nretrofit: check_latest_ver (^3.0.1+1 현재 버전)\n```\n\n그리고 dev_dependencies에는 아래 세 가지를 추가해주세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nretrofit_generator: 최신 버전 확인\nbuild_runner: 최신 버전 확인\njson_serializable: 최신 버전 확인\n```\n\n이제 flutter pub을 실행하고 명령어를 받은 후, Flutter 신에게 기도합니다. 종종 종속성으로 인해 약간 골을 주는 경우가 있습니다. 일시적인 해결책은 버전을 아무 값으로 설정하는 것입니다.\n\n다음으로, 주요 추상 클래스, Dio 설정을 만들고, get_it을 사용하여 나중에 리포지토리에서 액세스할 수 있는 레이지 싱글톤을 만들겠습니다.\n\n# 추상 클래스 만들기\n\n<div class=\"content-ad\"></div>\n\n- 파일을 생성하세요. 이름을 rest_client.dart로 지정할게요.\n- Retrofit은 코드를 생성하기 때문에, 파일 상단에 .g 파일을 part로 지정해야 합니다. 우리의 경우에는 rest.client.g.dart가 될 거예요.\n- 추상 클래스를 생성하고 @RestApi() 어노테이션을 사용하세요. 이렇게 하면 제너레이터가 retrofit 인터페이스(추상 클래스)임을 알 수 있어요.\n- Dio와 옵션으로 베이스 URL을 받는 팩토리 생성자를 만드세요.\n\n![이미지](/assets/img/2024-06-22-RetrofitandFlutterlikeaPRO_1.png)\n\n# Dio 설정\n\n이전에 언급했듯이, Retrofit은 Dio를 완전히 의존하므로, 이를 생성해보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n- dio_client.dart이라는 파일을 만드세요.\n- baseUrl 문자열을 인수로 받아 Dio 클라이언트를 반환하는 함수를 생성하세요.\n- baseUrl과 Interceptor(이에 대해서 나중에 논의할 것입니다.)와 같은 최소한의 \\*BaseOptions로 Dio 인스턴스를 만드세요.\n\nBaseOptions: Dio 인스턴스의 표준 구성입니다. 이 기사에서 다루지는 않겠지만, 연결 제한 시간, 수신 제한 시간, 전송 제한 시간, 쿼리 매개변수, 헤더 등과 같은 다양한 구성 요소가 포함되어 있습니다.\n\n![img](/assets/img/2024-06-22-RetrofitandFlutterlikeaPRO_2.png)\n\n# get_it으로 Dio 및 Retrofit 클래스 연결하기\n\n<div class=\"content-ad\"></div>\n\n의존성 주입을 선택할 때 항상 get_it을 사용했었어요. 이것은 사용하기 쉽고 컨텍스트가 필요하지 않아요. 마지막 단계는 Dio와 Retrofit을 연결하는 것이에요. 이건 한 줄의 코드만 필요해요. get_it에 관한 글이 있으니, 더 깊이 파고들고 싶다면 꼭 읽어보세요. 로케이터 설정에 해당 종속성을 추가하세요:\n\n![이미지](/assets/img/2024-06-22-RetrofitandFlutterlikeaPRO_3.png)\n\n이 두 줄의 코드는 게으른 싱글톤(처음 호출될 때만 만들어지는)을 생성할 거에요. RetrofitClient 인스턴스에서는 Dio 클라이언트와 함께 원격 구성을 전달했어요.\n\n주의 - 원격 구성은 변수로 변경하거나 Firebase와 같은 원격 서비스로 변경하여 env 기본 URL을 구성할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n드디어 Retrofit을 사용할 준비가 되었습니다! 사용 방법을 살펴봅시다.\n\n## 사용 방법\n\n먼저, 지원되는 HTTP 메소드와 그 추가 방법에 대해 이해해야 합니다. Retrofit은 다음을 지원합니다:\n\n- @GET() — GET 요청을 사용하여 리소스 표현/정보만 검색하고 수정하지 않습니다. 이는 리소스의 상태를 변경하지 않기 때문에 안전한 메소드로 알려져 있습니다.\n\n<div class=\"content-ad\"></div>\n\n@ PATCH() - PUT 요청을 보면 리소스 엔티티를 수정합니다. 좀 더 정확히 말하면 PATCH 방법은 기존 리소스를 부분적으로 업데이트하는 올바른 선택입니다. 전체 리소스를 교체하는 경우에만 PUT을 사용해야 합니다.\n\n@ PUT() - 기본적으로 PUT API를 사용하여 기존 리소스를 업데이트합니다 (리소스가 존재하지 않는 경우 API가 새 리소스를 생성할지 여부를 결정할 수 있음).\n\n@ DELETE() - 이름 그대로 DELETE API는 요청 URI로 식별된 리소스를 삭제합니다.\n\n실제 세계의 예시를 살펴보겠습니다. JSONPlaceholder 웹사이트를 사용하여 예시용 JSON을 생성하겠습니다. 간단한 GET 요청부터 시작해봅시다.\n\n<div class=\"content-ad\"></div>\n\n해당 엔드포인트를 사용할 거예요.\n\nhttps://jsonplaceholder.typicode.com/posts\n\n우선 Retrofit을 위한 기본 URL을 정의해야 해요. 이 부분이죠: https://jsonplaceholder.typicode.com/\n\n- 기본 URL 정의하기 — 나에게는 모든 원격 주소를 담은 (remote_config) dart 파일이 있는게 의미가 있어요. 그래서 Dio 클라이언트를 빌드하는 get_it 파일에 정의해요 (마지막 사진에서 어떻게 할 지 보여 줄 거예요).\n- 웹이나 Swager에서 JSON 응답을 받거나 백엔드 팀에게 요청해요. Retrofit이 변환할 수 있는 Freezed 파일을 만들어보죠. 가장 쉬운 방법은 JSON 요청을 붙여넣고 타깃 언어를 Dart로 선택해서 excellent web tool인 quicktype을 사용하는 거예요. 그리고 패널에서 다음을 켜주세요:\n\n<div class=\"content-ad\"></div>\n\n클래스에 인코더 및 디코더를 추가하고 @freezed 호환성을 갖도록 클래스 정의를 생성해보세요.\n\n<img src=\"/assets/img/2024-06-22-RetrofitandFlutterlikeaPRO_4.png\" />\n\n그 후, freezed 결과를 복사하여 새로운 모델 파일, 예를 들어 post_model.dart를 만들고 오른쪽 코드를 붙여넣은 다음 다음 명령을 실행해보세요. (NOTICE: quickly에서 필드들을 선택적으로하거나 필수로하지 않았는데, freezed는 그것을 허용하지 않으므로 각 부분에 ?를 추가하여 선택적으로 만듭니다.)\n\nflutter pub run build_runner build --delete-conflicting-outputs\n\n<div class=\"content-ad\"></div>\n\n이 는 대화 내용이 포함된 .g 파일과 copyWith, toString 및 해시와 같은 다른 유용한 정보가 들어 있는 .freezed 파일을 생성합니다 (Freezed에 대해 자세히 알고 싶다면 이 문서를 확인해보세요)\n\n다음에 get 호출을 추가하기 전에 API에서 수신한 데이터를 변환하기 위해 retrofit이 필요로하는 응답 클래스를 만드는 부분이 있습니다.\n\n이제 Retrofit을 위한 GET 호출을 추가해 보겠습니다.\n\n![그림](/assets/img/2024-06-22-RetrofitandFlutterlikeaPRO_5.png)\n\n<div class=\"content-ad\"></div>\n\nbuild_runner를 다시 실행하여 Retrofit이 중요한 작업을 대신 처리하도록 하세요. 이제 API를 사용할 준비가 되었어요. 멋져요. (클린 아키텍처를 사용하는 경우, 모델 레이어의 리포지토리에서 Retrofit 추상 클래스를 호출하고 나중에 FutureBuilder와 함께 위젯에서 호출하지 않고 Usecase로 전달하는 것이 좋습니다.)\n\n좋아요, 가장 간단한 호출을 다루었어요. 조금 흥미롭게 만들어 볼까요? 이제 특정 카테고리, 스포츠라는 카테고리의 게시물을 가져와야 한다고 가정해봅시다. 따라서 String 유형의 쿼리를 전달해야합니다. 문제없어요:\n\n![image](/assets/img/2024-06-22-RetrofitandFlutterlikeaPRO_6.png)\n\n동일한 카테고리 키('category')로 몇 가지 카테고리 ID를 전달해야하는 경우는 어떨까요? String 대신 String 목록으로 교체하면 됩니다. 이렇게 하세요.\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-22-RetrofitandFlutterlikeaPRO_7.png)\n\n현재 백엔드 개발자가 호출 경로에서 카테고리 ID를 지정해야 한다고 결정했습니다. 따라서 다음과 같이 될 것입니다: post/'id'.\n\n![이미지](/assets/img/2024-06-22-RetrofitandFlutterlikeaPRO_8.png)\n\n좋아요, 그럼 데이터와 함께 새로운 포스트를 보내는 것은 어떤가요? 예를 들어, 제목과 내용이 있는 POST라고 할 때요. 쉽죠, 새로운 요청을 위한 새로운 freezed 파일을 만들어보세요.\n\n<div class=\"content-ad\"></div>\n\n```js\n@freeze\nabstract class PostModelRequest with _$PostModelRequest {\n  const factory PostModelRequest({\n    String? title,\n    String? content,\n  }) = _PostModelRequest;\n  factory PostModelRequest.fromJson(Map<String, dynamic> json) =>\n      _$PostModelRequestFromJson(json);\n}\n```\n\n그리고 PostModelRequest를 body에 보내는 Post 메서드를 추가해주세요.\n\n![image](/assets/img/2024-06-22-RetrofitandFlutterlikeaPRO_9.png)\n\n같은 방법으로 retrofit 클라이언트에 @PUT, @PATCH, @DELETE 메서드를 추가할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nMarkdown 형식으로 변경해 보겠습니다.\n\nRetrofit은 인코딩된 폼 데이터를 사용하여 업로드도 지원합니다.\n\n![image1](/assets/img/2024-06-22-RetrofitandFlutterlikeaPRO_10.png)\n\n예를 들어, 무거운 파일을 업로드하다 중단하고 싶을 때는 다음과 같이 할 수 있습니다.\n\n![image2](/assets/img/2024-06-22-RetrofitandFlutterlikeaPRO_11.png)\n\n<div class=\"content-ad\"></div>\n\n만약 특정 호출을 위해 사용자 정의 헤더가 필요하다면, 이 훌륭한 도구를 통해 가능합니다. (보통 이러한 헤더는 전역적이며 레트로핏 클라이언트를 생성할 때 Dio 클라이언트에서 정의됩니다)\n\n![이미지](/assets/img/2024-06-22-RetrofitandFlutterlikeaPRO_12.png)\n\n사용자 정의 헤더는 다음과 같이 동적으로 전달될 수도 있습니다.\n\n![이미지](/assets/img/2024-06-22-RetrofitandFlutterlikeaPRO_13.png)\n\n<div class=\"content-ad\"></div>\n\n개발자님 안녕하세요. 업로드된 진행 상황을 얻어 업로드하는 것도 요청하셨지만, 이겪는 것은 선택 사항입니다. 네, 물론, 단지:\n\n<img src=\"/assets/img/2024-06-22-RetrofitandFlutterlikeaPRO_14.png\" />\n\n# 모든 호출에 토큰 추가하는 방법\n\n회사에서 엄격한 곳이어서 호출을 액세스 토큰으로 안전하게 보호하길 원합니다. 물론, 당신이 원하는 마지막 것은 각 호출에 수동으로 이러한 토큰을 추가하는 것입니다. 절대 안돼요! 우리에게는 인터셉터가 있어서 다행입니다. 인터셉터는 당신이 만든 모든 호출을 듣는 훌륭한 도구입니다. 이들에는 onRequest, onError 및 onResponse와 같은 세 가지 콜백이 있습니다. 우리의 작은 예에서 백엔드는 우리의 토큰을 파이어베이스에서 원합니다. 그래서 token_interceptor.dart라는 새 파일을 만들고 나중에 Dio 클라이언트에 추가합시다.\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-22-RetrofitandFlutterlikeaPRO_15.png)\n\n우리는 모든 요청을 듣고, IdToken이 있으면 헤더로 추가합니다.\n\n또한 오류가 발생하면 간단히 처리하는 방법이 있습니다. 실제 세계에서는 토큰이 만료되어 새로 고칠 필요가 있는 상황을 처리할 수도 있습니다. 요청에 무언가를 하고 싶다면 언제든지 onResponse를 재정의할 수 있습니다.\n\n# 응답을 캐시하는 방법\n\n<div class=\"content-ad\"></div>\n\nDio에는 더 많은 기능을 추가할 수있는 애드온이 많이 있어요. 그 중 하나는 Hive나 objectbox와 같은 데이터베이스를 구현하지 않고도 응답을 캐시하는 데 도움을 줍니다. pub.dev에 가서 dio_http_cache를 검색해보세요.\n\n설치는 쉬워요:\n\n첫 번째 단계:\n\n```js\ndio.interceptors.add(DioCacheManager(CacheConfig(baseUrl: RemoteConfig.baseUrl)).interceptor);\n```\n\n<div class=\"content-ad\"></div>\n\n두 번째 단계에서는 요청이 저장될 최대 연령을 설정할 수 있습니다:\n\n```js\nDio().get(\n  RemoteConfig.baseUrl,\n  options: buildCacheOptions(Duration(days: 7)),\n);\n```\n\n# 트래픽 로깅하는 방법\n\n트래픽을 로깅하지 않으면 우리의 API 문제를 이해하고 디버깅하는 데 너무 많은 시간이 걸려요. 그래서 좋은 로거가 항상 필요하죠. 다시 pub.dev에 가서 pretty_dio_logger을 검색하세요. 이를 인터셉터 목록에 추가하면 트래픽을 마음껏 볼 수 있습니다. (네트워크 도구를 사용할 수 있지만 때때로 그거 제대로 작동 안 해요. 그리고 이 방법은 AK-47처럼 신뢰할 수 있어요.)\n\n<div class=\"content-ad\"></div>\n\n```js\ndio.interceptors.add(PrettyDioLogger(\n        requestHeader: true,\n        requestBody: true,\n        responseBody: true,\n        responseHeader: false,\n        error: true,\n        compact: true,\n        maxWidth: 90));\n```\n\n애드온 목록이 굉장히 방대하고, 이 기사는 길어지고 있습니다. Dio에 있는 다른 애드온을 확인하시기를 권장합니다 (위에 나열되어 있음).\n\n다음 기사는 오류를 전문가처럼 처리하는 방법에 대해 다룰 예정입니다. 이 내용이 도움이 되었기를 바랍니다. Flutter 서비스가 필요하신 경우 언제든지 연락해 주세요. Flutter 개발 전문 회사인 BlueBirdCoders에서는 4년 이상의 경험을 가지고 있으며, 아래 링크에서 우리 멋진 커뮤니티에 참여하실 수 있습니다:\n\nhttps://www.facebook.com/groups/flutteril/\n\n<div class=\"content-ad\"></div>\n\n만나서 반가워요! 함께 즐거운 시간 보내요! 🤘🏽\n","ogImage":{"url":"/assets/img/2024-06-22-RetrofitandFlutterlikeaPRO_0.png"},"coverImage":"/assets/img/2024-06-22-RetrofitandFlutterlikeaPRO_0.png","tag":["Tech"],"readingTime":10},{"title":"Flutter 모든 위치의 전체 주소를 가져오는 방법","description":"","date":"2024-06-22 04:06","slug":"2024-06-22-FlutterGetcompleteaddressofanylocation","content":"\n<img src=\"/assets/img/2024-06-22-FlutterGetcompleteaddressofanylocation_0.png\" />\n\n어떤 위치든 위도와 경도를 사용하여 완전한 주소(우편 번호 포함)를 쉽게 얻을 수 있습니다.\n\n예를 들어:\n\n이렇게 하는 법을 알아보겠습니다 ......\n\n<div class=\"content-ad\"></div>\n\n🌞 먼저 아래 종속성을 pubspec.yaml 파일에 추가해주세요\n\n```js\ngeocoding: ^2.1.1\n```\n\n🌞 그 후에 .dart 파일에서 종속성을 import해주세요\n\n```js\nimport \"package:geocoding/geocoding.dart\";\n```\n\n<div class=\"content-ad\"></div>\n\n🌞 이제 Lat, Long을 입력으로 받아 주소를 문자열로 반환하는 getPlacemark라는 간단한 함수를 만들어 보겠습니다.\n\n함수를 비동기로 정의하고, 전체 내용을 try-catch로 감싸서 예외를 처리할 겁니다.\n\n🌞 그래서 try 블록 안에서 placemarkFromCoordinates 작업을 사용하여 위도와 경도를 전달하여 플레이스마크를 가져올 것입니다. 다음과 같이:\n\n```js\nList<Placemark> placemarks = await placemarkFromCoordinates(lat, long);\n```\n\n<div class=\"content-ad\"></div>\n\n이 장소 표시는 위치의 모든 세부 정보를 포함하고 있어요.\n\n그들을 추출하고 정리하기 위해 장소 표시를 반전하고 마지막 인덱스에 액세스할 수 있어요:\n\n```js\nString address = \"\";\naddress += '${placemarks.reversed.last.subLocality ?? ''}';\n```\n\n위와 같이 주소에 액세스하고 문자열에 추가할 수 있어요. 이때 널 체크를 수행하여, 위도와 경도에 어떠한 값도 포함되지 않을 경우 (즉, 널 값 반환) 대비가 되도록 해요.\n\n<div class=\"content-ad\"></div>\n\n🌞 이제 Lat Long의 거리 주소를 얻는 방법은 다음 코드를 사용할 수 있습니다. 주소의 부분에 액세스하고 정리하여 정리된 거리 주소를 얻는 코드를 포함하고 있습니다:\n\n```js\nString address = \"\";\n\n// 거리 주소 문자열 가져오기\nvar streets = placemarks.reversed\n    .map((placemark) => placemark.street)\n    .where((street) => street != null);\n\n// 불필요한 부분 필터링\nstreets = streets.where((street) =>\n    street!.toLowerCase() !=\n    placemarks.reversed.last.locality!\n        .toLowerCase()); // 도시 이름 제거\nstreets =\n    streets.where((street) => !street!.contains('+')); // 코드 제거\n\naddress += streets.join(', ');\n```\n\n이 부분은 거리 주소를 가져와 도시 이름 등을 제거하여, 도시 이름에 개별적으로 액세스할 수 있도록 구체적으로 만듭니다.\n\n🌞 아래 제공된 완전한 코드를 살펴보세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport 'package:geocoding/geocoding.dart';\n\nFuture<String> getPlacemarks(double lat, double long) async {\n  try {\n    List<Placemark> placemarks = await placemarkFromCoordinates(lat, long);\n\n    var address = '';\n\n    if (placemarks.isNotEmpty) {\n\n      // Address components without null values are concatenated\n      var streets = placemarks.reversed\n          .map((placemark) => placemark.street)\n          .where((street) => street != null);\n\n      // Unwanted parts are filtered out\n      streets = streets.where((street) =>\n          street!.toLowerCase() !=\n          placemarks.reversed.last.locality!\n              .toLowerCase()); // Remove city names\n      streets =\n          streets.where((street) => !street!.contains('+')); // Remove street codes\n\n      address += streets.join(', ');\n\n      address += ', ${placemarks.reversed.last.subLocality ?? ''}';\n      address += ', ${placemarks.reversed.last.locality ?? ''}';\n      address += ', ${placemarks.reversed.last.subAdministrativeArea ?? ''}';\n      address += ', ${placemarks.reversed.last.administrativeArea ?? ''}';\n      address += ', ${placemarks.reversed.last.postalCode ?? ''}';\n      address += ', ${placemarks.reversed.last.country ?? ''}';\n    }\n\n    print(\"Your Address for ($lat, $long) is: $address\");\n\n    return address;\n  } catch (e) {\n    print(\"Error getting placemarks: $e\");\n    return \"No Address\";\n  }\n}\n```\n\n🧑🏿‍💻 Follow for more such blogs ☺️….\n","ogImage":{"url":"/assets/img/2024-06-22-FlutterGetcompleteaddressofanylocation_0.png"},"coverImage":"/assets/img/2024-06-22-FlutterGetcompleteaddressofanylocation_0.png","tag":["Tech"],"readingTime":4}],"page":"7","totalPageCount":28,"totalPageGroupCount":2,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}