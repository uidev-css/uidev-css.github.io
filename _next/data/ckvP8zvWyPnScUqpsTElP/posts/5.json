{"pageProps":{"posts":[{"title":"Flutter 상태 관리 BLoC와 Provider 비교 어떤 걸 선택해야 할까","description":"","date":"2024-06-22 15:47","slug":"2024-06-22-FlutterStateManagementBLoCVSProvider","content":"\n세부 비교\n\n![flutter-state-management](/assets/img/2024-06-22-FlutterStateManagementBLoCVSProvider_0.png)\n\n상태 관리는 모든 애플리케이션을 구축하는 중요한 측면이며 특히 모바일 앱에서 중요합니다. 플러터(Flutter)에서 상태 관리는 앱에서 변경될 수 있는 데이터를 관리하고 해당 데이터를 사용자 인터페이스에 반영하는 과정입니다.\n\n플러터에서 상태 관리에는 여러 패턴이 있지만, 가장 인기 있는 두 가지는 BLoC (Business Logic Component)와 Provider입니다. 이 두 패턴은 모두 플러터 앱의 상태를 관리하기 쉽게 만들어 주지만 각각 다른 방식으로 작동하며 다른 사용 사례에 적합합니다.\n\n<div class=\"content-ad\"></div>\n\nBLoC(Business Logic Component)은 애플리케이션의 비즈니스 로직을 사용자 인터페이스에서 분리하는 디자인 패턴입니다. 이는 UI와 BLoC 간에 데이터를 전달하는 데 스트림을 사용하며, 애플리케이션의 상태를 관리하기 위해 Provider 패키지와 함께 사용할 수 있습니다.\n\n반면에 Provider는 애플리케이션의 상태를 관리하기 위한 패키지입니다. InheritedWidget을 사용하여 상태를 위젯 트리 아래로 전파합니다. BLoC를 사용하는 더 단순하고 가벼운 대안이지만, 덜 강력하고 유연하지 않습니다.\n\n이 블로그 포스트에서는 이 두 상태 관리 패턴을 자세히 살펴보고, Flutter 앱에서 언제 사용해야 하는지, 어떻게 작동하는지, 또한 BLoC와 Provider를 상세히 비교하고 각 패턴의 장점과 단점을 논의할 것입니다.\n\nBLoC(Business Logic Component) 패턴은 애플리케이션의 비즈니스 로직을 사용자 인터페이스에서 분리하는 방법입니다. UI와 BLoC 간에 데이터를 전달하기 위해 스트림을 사용하여 Flutter 앱의 상태를 쉽게 관리할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nBLoC 패턴의 기본 구성 요소는 BLoC 자체입니다. 이는 비즈니스 로직을 처리하는 역할을 담당합니다. BLoC는 이벤트 스트림(예: 사용자 입력)을 가져와서 상태 스트림을 업데이트하는 데 사용합니다. 그런 다음 UI는 상태 스트림을 청취하고 그에 따라 업데이트할 수 있습니다.\n\n다음은 카운터를 증가하는 간단한 BLoC 예제입니다:\n\n```js\nclass CounterBloc {\n  final _counterController = StreamController<int>();\n  Stream<int> get counter => _counterController.stream;\n  void increment() {\n    _counterController.sink.add(_counterController.value + 1);\n  }\n  void dispose() {\n    _counterController.close();\n  }\n}\n```\n\n이 예제에서 CounterBloc 클래스에는 비공개 \\_counterController StreamController와 공개 counter 스트림이 있습니다. increment 메서드는 이벤트를 가져와 스트림의 현재 값에 1을 추가하고, dispose는 더 이상 필요하지 않을 때 스트림을 닫는 데 사용됩니다.\n\n<div class=\"content-ad\"></div>\n\nBLoC 사용의 장점은 다음과 같습니다:\n\n- 코드 구성: BLoC는 비즈니스 로직과 UI 로직을 분리하여 유지 관리, 테스트, 가독성을 높입니다.\n- 확장성: BLoC의 모듈식 접근 방식은 앱을 성장시킬 때 확장하기 쉽게 만듭니다.\n\n다음은 위의 BLoC를 플러터 위젯 트리에 구현하는 예시입니다:\n\n```js\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return BlocProvider<CounterBloc>(\n      create: (context) => CounterBloc(),\n      child: MaterialApp(\n        home: CounterPage(),\n      ),\n    );\n  }\n}\n\nclass CounterPage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    final bloc = BlocProvider.of<CounterBloc>(context);\n\n    return Scaffold(\n      body: Center(\n        child: StreamBuilder<int>(\n          stream: bloc.counter,\n          initialData: 0,\n          builder: (context, snapshot) {\n            return Text('${snapshot.data}');\n          },\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          bloc.increment();\n        },\n        child: Icon(Icons.add),\n      ),\n    );\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\nBLoC을 사용하는 한 가지 단점은 설정 및 사용이 더 복잡할 수 있고 구현하는 데 더 많은 시간과 노력이 필요할 수 있다는 것입니다. 또한 몇 가지 경우에는 단순한 경우에 스트림 컨트롤러 및 스트림 빌더의 필요가 하나의 Provider가 더 적합한 경우도 있을 수 있습니다.\n\nProvider 패턴은 Flutter 애플리케이션의 상태를 관리하기 위한 패키지입니다. InheritedWidget을 사용하여 상태를 위젯 트리 아래로 전파하여 앱 전체에서 상태에 쉽게 액세스하고 업데이트할 수 있도록 돕습니다.\n\nProvider에서 앱 상태를 보유하는 ChangeNotifier와 ChangeNotifier를 보유하는 ChangeNotifierProvider가 있습니다. ChangeNotifierProvider는 ChangeNotifier의 인스턴스를 취하고 위젯 트리 안에 있는 위젯에 노출합니다.\n\n다음은 Provider를 사용한 간단한 Counter 앱 예시입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nclass CounterModel with ChangeNotifier {\n  int _count = 0;\n\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n```\n\n이 예시에서 CounterModel 클래스는 카운터를 나타내는 int 값이 있는 ChangeNotifier이며, 카운터를 업데이트하는 increment 메서드와 UI에 변경 사항을 알리기 위해 notifyListeners()를 호출하는 기능을 가지고 있습니다.\n\n위의 CounterModel을 Flutter 위젯 트리에 구현하는 예시는 아래와 같습니다.\n\n```js\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return ChangeNotifierProvider(\n      create: (_) => CounterModel(),\n      child: MaterialApp(\n        home: CounterPage(),\n      ),\n    );\n  }\n}\n\nclass CounterPage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    final counter = Provider.of<CounterModel>(context);\n\n    return Scaffold(\n      body: Center(\n        child: Text('${counter.count}'),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          counter.increment();\n        },\n        child: Icon(Icons.add),\n      ),\n    );\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\nProvider를 사용하는 장점 중 하나는 사용하기 쉽고 간단하다는 것입니다. 특히 작고 간단한 앱에 사용하기에 매우 간편합니다.\n\n하지만, Provider는 BLoC에 비해 강력하고 유연성이 부족하며, 더 크고 복잡한 앱의 상태를 관리하기 어려울 수 있습니다. 또한 코드 구성을 위한 구체적인 구조를 제공하지 않아 애플리케이션이 성장함에 따라 더 복잡하고 이해하기 어려운 코드로 이어질 수 있습니다.\n\n이 섹션에서는 BLoC (비즈니스 로직 컴포넌트)와 Provider를 아키텍처, 코드 구성, 사용 편의성, 확장성 및 디버깅/테스트 측면에서 비교할 것입니다.\n\n- BLoC는 응용 프로그램의 비즈니스 로직을 사용자 인터페이스에서 분리하는 더 복잡하고 강력한 패턴입니다. UI와 BLoC 간에 데이터를 통신하는 데 스트림을 사용하며, Provider 패키지와 함께 사용할 수 있습니다. 반면에 Provider는 InheritedWidget을 사용하여 상태를 위젯 트리 아래로 전파하는 더 간단하고 가벼운 패턴입니다.\n\n<div class=\"content-ad\"></div>\n\n- BLoC은 비즈니스 로직과 UI 로직을 분리하여 상태를 관리하는 더 모듈화되고 조직적인 방식을 따릅니다. 이로 인해 코드가 유지보수 가능하고 테스트 가능하며 가독성이 높아집니다. Provider는 간단한 해결책이지만 애플리케이션이 커짐에 따라 더 복잡하고 이해하기 어려운 코드로 이어질 수 있습니다. Provider는 특정 구조를 제공하지 않기 때문입니다.\n\n- Provider는 일반적으로 설정하고 사용하기 쉽다고 여겨지며 특히 작고 간단한 앱에 적합합니다. 반면에 BLoC은 설정하고 사용하기에 더 복잡할 수 있으며 구현하는 데 더 많은 시간과 노력을 필요로 할 수 있습니다.\n\n- BLoC은 더 크고 복잡한 앱에 더 적합하며, 상태를 관리하는 더 조직화되고 모듈화된 방식을 허용하여 앱이 성장할수록 더 쉽게 확장할 수 있습니다. 반면에 Provider는 작거나 간단한 앱에 더 적합하며 큰 앱의 복잡성을 쉽게 처리하지 못할 수 있습니다.\n\n- BLoC 아키텍처는 버그를 감지하고 코드를 테스트하고 다른 부분에 영향을 주지 않고 변경하는 것이 쉽습니다. Provider는 BLoC만큼 디버깅과 테스트하기에 적합하지 않으며 독립성과 모듈성의 수준을 제공하지 않기 때문입니다.\n\n<div class=\"content-ad\"></div>\n\n이 문서에서는 플러터 앱용 두 가지 인기있는 상태 관리 패턴인 BLoC (Business Logic Component)과 Provider에 대해 논의했습니다. 이 두 패턴은 플러터 앱의 상태를 더 쉽게 관리할 수 있도록 설계되었지만, 접근 방식이 다르며 다른 사용 사례에 적합합니다.\n\nBLoC는 애플리케이션의 비즈니스 로직을 사용자 인터페이스와 분리하는 강력하고 유연한 패턴입니다. 이는 UI와 BLoC 간에 데이터를 통신하는 데 스트림을 사용하며, 대규모 및 복잡한 앱에 적합합니다. 반면 Provider는 더 간단하고 가벼운 패턴으로, InheritedWidget을 사용하여 상태를 위젯 트리 아래로 전파합니다. 이는 더 작거나 간단한 앱에 적합합니다.\n\n이 글의 주요 요점은 다음과 같습니다:\n\n- BLoC는 대규모 및 복잡한 앱에 적합한 강력하고 유연한 패턴입니다.\n- Provider는 더 작거나 더 간단한 앱에 적합한 더 간단하고 가벼운 패턴입니다.\n- BLoC와 Provider는 플러터 앱의 상태를 관리하는 데 유용하며, 다른 사용 사례에 적합합니다.\n- 상태 관리 패턴을 선택할 때 앱의 특정 요구 사항을 고려하는 것이 중요합니다. 이는 앱의 크기와 복잡성뿐만 아니라 그로 인해 달성하려는 목표도 포함해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n만약 당신의 앱이 작고 간단하며 비즈니스 로직과 UI 로직을 분리할 필요가 없다면, Provider가 좋은 선택일 것입니다. 만약 당신의 앱이 더 복잡하거나 비즈니스 로직과 UI 로직을 분리하고 싶다면, BLoC가 더 나은 선택일 것입니다. 그러나 결국, 당신의 앱의 구체적인 요구사항을 평가하고 사용 사례에 가장 잘 맞는 상태 관리 패턴을 선택하는 것이 항상 더 나은 방법입니다.\n\n이 블로그 게시물 작성 시 다음 소스가 사용되었습니다:\n\n- Flutter 상태 관리 문서: https://flutter.dev/docs/development/data-and-backend/state-mgmt\n- BLoC 패턴: https://www.didierboelens.com/2018/08/reactive-programming---streams---bloc/\n- Provider 패키지: https://pub.dev/packages/provider\n\nFlutter에서 상태 관리에 대해 더 자세히 알고 싶은 독자들을 위해 다음 리소스들이 유용할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n- **Provider 패키지에 대한 Flutter 문서**: [여기](https://pub.dev/packages/provider#-readme-tab)\n- **BLoC 패턴에 대한 Flutter 문서**: [여기](https://flutter.dev/docs/development/data-and-backend/state-mgmt/options#bloc--rx)\n- **Flutter에서의 고급 상태 관리**: [여기](https://www.youtube.com/watch?v=RS36gBEp8OI&t=898s)\n\n그 외 다양한 Flutter 상태 관리 옵션과 패키지가 있다는 점도 알아두면 좋아요. 필요에 따라 몇 가지 다른 옵션들을 탐색해보실 수도 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-22-FlutterStateManagementBLoCVSProvider_0.png"},"coverImage":"/assets/img/2024-06-22-FlutterStateManagementBLoCVSProvider_0.png","tag":["Tech"],"readingTime":8},{"title":"Flutter 레이아웃 치트 시트 완벽 가이드","description":"","date":"2024-06-22 15:45","slug":"2024-06-22-FlutterLayoutCheatSheet","content":"\n플러터를 위한 간단한 레이아웃 샘플이 필요하신가요?\n제가 마련한 플러터 레이아웃 코드 조각을 소개합니다. 시각적 예시를 풍부하고 간결하게 제시할 거에요.\n아직은 작업 중이라 샘플 목록은 계속 늘어날 거예요. 플러터 위젯의 활용에 더 초점을 맞출 거라 구성요소를 보여주는 것보다는 (플러터 갤러리가 그런 부분에 뛰어나거든요!)\n플러터 레이아웃에 문제가 있거나 다른 사람들과 코드 조각을 공유하고 싶다면 말씀해주세요!\n\n이 기사는 다음 언어로도 제공됩니다:\n\n- Eddy에 의해 포르투갈어\n\n애니메이션에 관한 유사한 기사가 궁금하시다면, Flutter Animations Cheat Sheet를 확인해보세요.\n\n<div class=\"content-ad\"></div>\n\n# 목차\n\n- 행 및 열\n- 내재 너비 및 내재 높이\n- 쌓기\n- 확장\n- 제약 상자\n- 정렬\n- 컨테이너\n  - 장식: BoxDecoration\n    - 이미지: DecorationImage\n    - 테두리: Border\n    - 경계 반지름: BorderRadius\n    - 모양: BoxShape\n    - 그림자: BoxShadow 목록\n    - 그라데이션: RadialGradient\n    - 배경 혼합 모드: BlendMode\n- 재료\n  - 모양: BeveledRectangleBorder\n- 슬리버\n  - SliverFillRemaining\n- SizedBox\n- 안전 영역\n\n# 행 및 열\n\n## 주축 정렬\n\n<div class=\"content-ad\"></div>\n\n```js\nRow /*또는 Column*/(\n  mainAxisAlignment: MainAxisAlignment.start,\n  children: <Widget>[\n    Icon(Icons.star, size: 50),\n    Icon(Icons.star, size: 50),\n    Icon(Icons.star, size: 50),\n  ],\n),\n```\n\n```js\nRow /*또는 Column*/(\n  mainAxisAlignment: MainAxisAlignment.center,\n  children: <Widget>[\n    Icon(Icons.star, size: 50),\n    Icon(Icons.star, size: 50),\n    Icon(Icons.star, size: 50),\n  ],\n),\n```\n\n```js\nRow /*또는 Column*/(\n  mainAxisAlignment: MainAxisAlignment.end,\n  children: <Widget>[\n    Icon(Icons.star, size: 50),\n    Icon(Icons.star, size: 50),\n    Icon(Icons.star, size: 50),\n  ],\n),\n```\n\n```js\nRow /*또는 Column*/(\n  mainAxisAlignment: MainAxisAlignment.spaceBetween,\n  children: <Widget>[\n    Icon(Icons.star, size: 50),\n    Icon(Icons.star, size: 50),\n    Icon(Icons.star, size: 50),\n  ],\n),\n```\n\n<div class=\"content-ad\"></div>\n\n표태그를 다음과 같이 Markdown 형식으로 변경하십시오.\n\n```js\nRow /*or Column*/(\n  mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n  children: <Widget>[\n    Icon(Icons.star, size: 50),\n    Icon(Icons.star, size: 50),\n    Icon(Icons.star, size: 50),\n  ],\n),\n```\n\n```js\nRow /*or Column*/(\n  mainAxisAlignment: MainAxisAlignment.spaceAround,\n  children: <Widget>[\n    Icon(Icons.star, size: 50),\n    Icon(Icons.star, size: 50),\n    Icon(Icons.star, size: 50),\n  ],\n),\n```\n\n<img src=\"/assets/img/2024-06-22-FlutterLayoutCheatSheet_0.png\" />\n\n다른 텍스트의 기준선을 정렬해야 한다면 CrossAxisAlignment.baseline을 사용해야 합니다.\n\n<div class=\"content-ad\"></div>\n\nRow(\ncrossAxisAlignment: CrossAxisAlignment.baseline,\ntextBaseline: TextBaseline.alphabetic,\nchildren: <Widget>[\nText(\n'Baseline',\nstyle: Theme.of(context).textTheme.display3,\n),\nText(\n'Baseline',\nstyle: Theme.of(context).textTheme.body1,\n),\n],\n),\n\n## CrossAxisAlignment\n\nRow /_or Column_/(\ncrossAxisAlignment: CrossAxisAlignment.start,\nchildren: <Widget>[\nIcon(Icons.star, size: 50),\nIcon(Icons.star, size: 200),\nIcon(Icons.star, size: 50),\n],\n),\n\nRow /_or Column_/(\ncrossAxisAlignment: CrossAxisAlignment.center,\nchildren: <Widget>[\nIcon(Icons.star, size: 50),\nIcon(Icons.star, size: 200),\nIcon(Icons.star, size: 50),\n],\n),\n\n<div class=\"content-ad\"></div>\n\n```js\nRow /*또는 Column*/(\n  crossAxisAlignment: CrossAxisAlignment.end,\n  children: <Widget>[\n    Icon(Icons.star, size: 50),\n    Icon(Icons.star, size: 200),\n    Icon(Icons.star, size: 50),\n  ],\n),\n```\n\n```js\nRow /*또는 Column*/(\n  crossAxisAlignment: CrossAxisAlignment.stretch,\n  children: <Widget>[\n    Icon(Icons.star, size: 50),\n    Icon(Icons.star, size: 200),\n    Icon(Icons.star, size: 50),\n  ],\n),\n```\n\n## MainAxisSize\n\n```js\nRow /*또는 Column*/(\n  mainAxisSize: MainAxisSize.max,\n  children: <Widget>[\n    Icon(Icons.star, size: 50),\n    Icon(Icons.star, size: 50),\n    Icon(Icons.star, size: 50),\n  ],\n),\n```\n\n<div class=\"content-ad\"></div>\n\nRow /_or Column_/(\nmainAxisSize: MainAxisSize.min,\nchildren: <Widget>[\nIcon(Icons.star, size: 50),\nIcon(Icons.star, size: 50),\nIcon(Icons.star, size: 50),\n],\n),\n\n# IntrinsicWidth and IntrinsicHeight\n\nWant all the widgets inside Row or Column to be as tall/wide as the tallest/widest widget? Search no more!\n\nIn case you have this kind of layout:\n\n<div class=\"content-ad\"></div>\n\n```js\n위젯 build(BuildContext context) {\n  return Scaffold(\n    appBar: AppBar(title: Text('IntrinsicWidth')),\n    body: Center(\n      child: Column(\n        children: <Widget>[\n          RaisedButton(\n            onPressed: () {},\n            child: Text('Short'),\n          ),\n          RaisedButton(\n            onPressed: () {},\n            child: Text('A bit Longer'),\n          ),\n          RaisedButton(\n            onPressed: () {},\n            child: Text('The Longest text button'),\n          ),\n        ],\n      ),\n    ),\n  );\n}\n```\n\n만약 모든 버튼을 가장 넓은 것처럼 넓게 만들고 싶다면 IntrinsicWidth를 사용하세요:\n\n<img src=\"/assets/img/2024-06-22-FlutterLayoutCheatSheet_2.png\" />\n\n<div class=\"content-ad\"></div>\n\n```js\n위젯 build(BuildContext context) {\n  return Scaffold(\n    appBar: AppBar(title: Text('IntrinsicWidth')),\n    body: Center(\n      child: IntrinsicWidth(\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.stretch,\n          children: <Widget>[\n            RaisedButton(\n              onPressed: () {},\n              child: Text('Short'),\n            ),\n            RaisedButton(\n              onPressed: () {},\n              child: Text('A bit Longer'),\n            ),\n            RaisedButton(\n              onPressed: () {},\n              child: Text('The Longest text button'),\n            ),\n          ],\n        ),\n      ),\n    ),\n  );\n}\n\n비슷한 문제가 있지만 위젯을 가장 큰 높이에 맞추고 싶다면 IntrinsicHeight와 Row 위젯의 조합을 사용하면 됩니다.\n\n# Stack\n\n위젯을 서로 겹쳐 놓을 때 사용합니다.\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n@override\nWidget build(BuildContext context) {\n  Widget main = Scaffold(\n    appBar: AppBar(title: Text('Stack')),\n  );\n\n  return Stack(\n    fit: StackFit.expand,\n    children: <Widget>[\n      main,\n      Banner(\n        message: \"Top Start\",\n        location: BannerLocation.topStart,\n      ),\n      Banner(\n        message: \"Top End\",\n        location: BannerLocation.topEnd,\n      ),\n      Banner(\n        message: \"Bottom Start\",\n        location: BannerLocation.bottomStart,\n      ),\n      Banner(\n        message: \"Bottom End\",\n        location: BannerLocation.bottomEnd,\n      ),\n    ],\n  );\n}\n```\n\n자체 위젯을 사용하려면 Positioned 위젯에 배치하셔야 합니다.\n\n<img src=\"/assets/img/2024-06-22-FlutterLayoutCheatSheet_4.png\" />\n\n<div class=\"content-ad\"></div>\n\n```js\n위젯 build(BuildContext context) {\n  return Scaffold(\n    appBar: AppBar(title: Text('Stack')),\n    body: Stack(\n      fit: StackFit.expand,\n      children: <Widget>[\n        Material(color: Colors.yellowAccent),\n        Positioned(\n          top: 0,\n          left: 0,\n          child: Icon(Icons.star, size: 50),\n        ),\n        Positioned(\n          top: 340,\n          left: 250,\n          child: Icon(Icons.call, size: 50),\n        ),\n      ],\n    ),\n  );\n}\n```\n\n만약 상하값을 추측하기 싫다면 LayoutBuilder를 사용하여 값을 가져올 수 있어요\n\n![이미지](/assets/img/2024-06-22-FlutterLayoutCheatSheet_5.png)\n\n```js\nWidget build(BuildContext context) {\n  const iconSize = 50;\n  return Scaffold(\n    appBar: AppBar(title: Text('Stack with LayoutBuilder')),\n    body: LayoutBuilder(\n      builder: (context, constraints) =>\n        Stack(\n          fit: StackFit.expand,\n          children: <Widget>[\n            Material(color: Colors.yellowAccent),\n            Positioned(\n              top: 0,\n              child: Icon(Icons.star, size: iconSize),\n            ),\n            Positioned(\n              top: constraints.maxHeight - iconSize,\n              left: constraints.maxWidth - iconSize,\n              child: Icon(Icons.call, size: iconSize),\n            ),\n          ],\n        ),\n    ),\n  );\n}\n```\n\n<div class=\"content-ad\"></div>\n\n# 확장된\n\n확장된은 Flexbox 레이아웃과 함께 작동하며 여러 항목 간의 공간을 효율적으로 분배하는 데 좋습니다.\n\n![이미지](/assets/img/2024-06-22-FlutterLayoutCheatSheet_6.png)\n\n```js\nRow(\n  children: <Widget>[\n    Expanded(\n      child: Container(\n        decoration: const BoxDecoration(color: Colors.red),\n      ),\n      flex: 3,\n    ),\n    Expanded(\n      child: Container(\n        decoration: const BoxDecoration(color: Colors.green),\n      ),\n      flex: 2,\n    ),\n    Expanded(\n      child: Container(\n        decoration: const BoxDecoration(color: Colors.blue),\n      ),\n      flex: 1,\n    ),\n  ],\n),\n```\n\n<div class=\"content-ad\"></div>\n\n# ConstrainedBox\n\n기본적으로 대부분의 위젯은 가능한 한 적은 공간을 사용합니다:\n\n![ConstrainedBox Example](/assets/img/2024-06-22-FlutterLayoutCheatSheet_7.png)\n\n```js\nCard(child: const Text('Hello World!'), color: Colors.yellow)\n```\n\n<div class=\"content-ad\"></div>\n\nConstrainedBox 위젯을 사용하면 원하는 대로 남은 공간을 활용할 수 있어요.\n\n![ConstrainedBox Example](/assets/img/2024-06-22-FlutterLayoutCheatSheet_8.png)\n\n```js\nConstrainedBox(\n  constraints: BoxConstraints.expand(),\n  child: const Card(\n    child: const Text('Hello World!'),\n    color: Colors.yellow,\n  ),\n),\n```\n\nBoxConstraints를 사용하면 위젯이 차지할 수 있는 공간의 양을 지정할 수 있어요. 높이와 너비의 최소 및 최대 값을 지정해요.\n\n<div class=\"content-ad\"></div>\n\n다음은 BoxConstraints.expand을 사용할 때의 동작입니다:\n\n![image](/assets/img/2024-06-22-FlutterLayoutCheatSheet_9.png)\n\n```js\nConstrainedBox(\n  constraints: BoxConstraints.expand(height: 300),\n  child: const Card(\n    child: const Text('Hello World!'),\n    color: Colors.yellow,\n  ),\n),\n```\n\n이것은 다음과 동일합니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nConstrainedBox(\n  constraints: BoxConstraints(\n    minWidth: double.infinity,\n    maxWidth: double.infinity,\n    minHeight: 300,\n    maxHeight: 300,\n  ),\n  child: const Card(\n    child: const Text('Hello World!'),\n    color: Colors.yellow,\n  ),\n),\n```\n\n# Align\n\n때때로 위젯을 적절한 크기로 설정하는 데 어려움을 겪을 때가 있습니다. 예를 들어, 원치 않는 스트레칭이 계속 발생하는 경우가 있습니다:\n\n<img src=\"/assets/img/2024-06-22-FlutterLayoutCheatSheet_10.png\" />\n\n<div class=\"content-ad\"></div>\n\n위와 같은 상황이 발생하는 예시는 Column에 CrossAxisAlignment.stretch를 가진 경우이며, 버튼만 늘어지지 않도록 원할 때 발생합니다:\n\n![image](/assets/img/2024-06-22-FlutterLayoutCheatSheet_11.png)\n\n```js\nWidget build(BuildContext context) {\n  return Scaffold(\n    appBar: AppBar(title: Text('Align: without Align')),\n    body: Column(\n      crossAxisAlignment: CrossAxisAlignment.stretch,\n      children: <Widget>[\n        Align(\n          child: RaisedButton(\n            onPressed: () {},\n            child: const Text('Button'),\n          ),\n        ),\n      ],\n    ),\n  );\n}\n```\n\n위젯이 설정한 제약을 수용하지 않을 때는 첫 번째로 Align으로 감싸 보세요.\n\n<div class=\"content-ad\"></div>\n\n# 컨테이너\n\n가장 많이 사용되는 위젯 중 하나입니다! 그리고 그 이유가 있어요:\n\n## 레이아웃 도구로서의 컨테이너\n\n컨테이너의 높이와 너비를 지정하지 않으면, 자식 요소의 크기에 맞추게 됩니다\n\n<div class=\"content-ad\"></div>\n\n![Flutter Layout Cheat Sheet](/assets/img/2024-06-22-FlutterLayoutCheatSheet_12.png)\n\n```js\nWidget build(BuildContext context) {\n  return Scaffold(\n    appBar: AppBar(title: Text('Container as a layout')),\n    body: Container(\n      color: Colors.yellowAccent,\n      child: Text(\"Hi\"),\n    ),\n  );\n}\n```\n\nIf you want to stretch the Container to match its parent, use `double.infinity` for the `height` and `width` properties\n\n![Flutter Layout Cheat Sheet](/assets/img/2024-06-22-FlutterLayoutCheatSheet_13.png)\n\n<div class=\"content-ad\"></div>\n\n```js\n위젯 build(BuildContext context) {\n    return Scaffold(\n        appBar: AppBar(title: Text('Container를 레이아웃으로 사용하기')),\n        body: Container(\n            height: double.infinity,\n            width: double.infinity,\n            color: Colors.yellowAccent,\n            child: Text(\"안녕하세요\"),\n        ),\n    );\n}\n```\n\n## Decoration으로 Container 스타일링\n\nContainer의 배경에 영향을 주기 위해 color 속성을 사용할 수 있습니다. 그러나 decoration 및 foregroundDecoration을 사용할 수도 있습니다. (이 두 속성을 사용하면 Container의 전체적인 모양을 완전히 바꿀 수 있지만 이후에 다른 스타일에 대해 이야기할 것입니다. 그것은 꽤 큰 주제이기 때문에!)\ndecoration은 항상 자식 위에 배치되지만, foregroundDecoration은 자식 위에 배치됩니다.\n\n<img src=\"/assets/img/2024-06-22-FlutterLayoutCheatSheet_14.png\" />\n\n<div class=\"content-ad\"></div>\n\n```js\n위젯 빌드(BuildContext context) {\n  return Scaffold(\n    appBar: AppBar(title: Text('Container.decoration')),\n    body: Container(\n      height: double.infinity,\n      width: double.infinity,\n      decoration: BoxDecoration(color: Colors.yellowAccent),\n      child: Text(\"안녕하세요\"),\n    ),\n  );\n}\n```\n\n![이미지](/assets/img/2024-06-22-FlutterLayoutCheatSheet_15.png)\n\n```js\n위젯 빌드(BuildContext context) {\n  return Scaffold(\n    appBar: AppBar(title: Text('Container.foregroundDecoration')),\n    body: Container(\n      height: double.infinity,\n      width: double.infinity,\n      decoration: BoxDecoration(color: Colors.yellowAccent),\n      foregroundDecoration: BoxDecoration(\n        color: Colors.red.withOpacity(0.5),\n      ),\n      child: Text(\"안녕하세요\"),\n    ),\n  );\n}\n```\n\n## Transform으로서의 Container\n\n<div class=\"content-ad\"></div>\n\n만약 레이아웃을 변경하기 위해 Transform 위젯을 사용하고 싶지 않다면, Container에서 직접 transform 속성을 사용할 수 있습니다.\n\n![이미지](/assets/img/2024-06-22-FlutterLayoutCheatSheet_16.png)\n\n```js\nWidget build(BuildContext context) {\n  return Scaffold(\n    appBar: AppBar(title: Text('Container.transform')),\n    body: Container(\n      height: 300,\n      width: 300,\n      transform: Matrix4.rotationZ(pi / 4),\n      decoration: BoxDecoration(color: Colors.yellowAccent),\n      child: Text(\n        \"안녕\",\n        textAlign: TextAlign.center,\n      ),\n    ),\n  );\n}\n```\n\n# BoxDecoration\n\n<div class=\"content-ad\"></div>\n\n일반적으로 장식은 컨테이너 위젯에 사용되어 컨테이너가 어떻게 보이는지를 변경합니다.\n\n### 이미지: DecorationImage\n\n배경으로 이미지를 넣습니다:\n\n![image](/assets/img/2024-06-22-FlutterLayoutCheatSheet_17.png)\n\n<div class=\"content-ad\"></div>\n\n```js\nScaffold(\n  appBar: AppBar(title: Text('image: DecorationImage')),\n  body: Center(\n    child: Container(\n      height: 200,\n      width: 200,\n      decoration: BoxDecoration(\n        color: Colors.yellow,\n        image: DecorationImage(\n          fit: BoxFit.fitWidth,\n          image: NetworkImage(\n            'https://flutter.io/images/catalog-widget-placeholder.png',\n          ),\n        ),\n      ),\n    ),\n  ),\n);\n```\n\n## border: Border\n\nContainer의 테두리가 어떻게 보일지를 지정합니다.\n\n![image](/assets/img/2024-06-22-FlutterLayoutCheatSheet_18.png)\n\n<div class=\"content-ad\"></div>\n\n```js\nScaffold(\n  appBar: AppBar(title: Text('border: Border')),\n  body: Center(\n    child: Container(\n      height: 200,\n      width: 200,\n      decoration: BoxDecoration(\n        color: Colors.yellow,\n        border: Border.all(color: Colors.black, width: 3),\n      ),\n    ),\n  ),\n);\n```\n\n## borderRadius: BorderRadius\n\n모서리를 둥글게 만듭니다.\n\ndecoration의 모양이 BoxShape.circle인 경우 borderRadius는 작동하지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nScaffold(\n  appBar: AppBar(title: Text('borderRadius: BorderRadius')),\n  body: Center(\n    child: Container(\n      height: 200,\n      width: 200,\n      decoration: BoxDecoration(\n        color: Colors.yellow,\n        border: Border.all(color: Colors.black, width: 3),\n        borderRadius: BorderRadius.all(Radius.circular(18)),\n      ),\n    ),\n  ),\n);\n```\n\n## shape: BoxShape\n\n박스의 장식은 사각형/정사각형 또는 타원/원이 될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n다른 모양을 사용하려면 BoxDecoration 대신 ShapeDecoration을 사용할 수 있습니다.\n\n![ShapeDecoration](/assets/img/2024-06-22-FlutterLayoutCheatSheet_20.png)\n\n```js\nScaffold(\n  appBar: AppBar(title: Text('shape: BoxShape')),\n  body: Center(\n    child: Container(\n      height: 200,\n      width: 200,\n      decoration: ShapeDecoration(\n        color: Colors.yellow,\n        shape: BoxShape.circle,\n      ),\n    ),\n  ),\n);\n```\n\n## boxShadow: List`BoxShadow`\n\n<div class=\"content-ad\"></div>\n\n아래는 Container에 그림자를 추가한 코드입니다.\n\n이 매개변수는 여러 가지 그림자를 지정하고 병합할 수 있으므로 목록 형태로 제공됩니다.\n\n![그림자 추가](/assets/img/2024-06-22-FlutterLayoutCheatSheet_21.png)\n\n```js\nScaffold(\n  appBar: AppBar(title: Text('boxShadow: List<BoxShadow>')),\n  body: Center(\n    child: Container(\n      height: 200,\n      width: 200,\n      decoration: BoxDecoration(\n        color: Colors.yellow,\n        boxShadow: const [\n          BoxShadow(blurRadius: 10),\n        ],\n      ),\n    ),\n  ),\n);\n```\n\n<div class=\"content-ad\"></div>\n\n## 그라데이션\n\n그라데이션에는 선형 그라데이션(LinearGradient), 원형 그라데이션(RadialGradient) 및 스윕 그라데이션(SweepGradient) 세 가지 유형이 있습니다.\n\n![Gradient](/assets/img/2024-06-22-FlutterLayoutCheatSheet_22.png)\n\n```js\nScaffold(\n  appBar: AppBar(title: Text('gradient: LinearGradient')),\n  body: Center(\n    child: Container(\n      height: 200,\n      width: 200,\n      decoration: BoxDecoration(\n        gradient: LinearGradient(\n          colors: const [\n            Colors.red,\n            Colors.blue,\n          ],\n        ),\n      ),\n    ),\n  ),\n);\n```\n\n<div class=\"content-ad\"></div>\n\n![Flutter Layout Cheat Sheet 23](/assets/img/2024-06-22-FlutterLayoutCheatSheet_23.png)\n\n```js\nScaffold(\n  appBar: AppBar(title: Text('gradient: RadialGradient')),\n  body: Center(\n    child: Container(\n      height: 200,\n      width: 200,\n      decoration: BoxDecoration(\n        gradient: RadialGradient(\n          colors: const [Colors.yellow, Colors.blue],\n          stops: const [0.4, 1.0],\n        ),\n      ),\n    ),\n  ),\n);\n```\n\n![Flutter Layout Cheat Sheet 24](/assets/img/2024-06-22-FlutterLayoutCheatSheet_24.png)\n\n```js\nScaffold(\n  appBar: AppBar(title: Text('gradient: SweepGradient')),\n  body: Center(\n    child: Container(\n      height: 200,\n      width: 200,\n      decoration: BoxDecoration(\n        gradient: SweepGradient(\n          colors: const [\n            Colors.blue,\n            Colors.green,\n            Colors.yellow,\n            Colors.red,\n            Colors.blue,\n          ],\n          stops: const [0.0, 0.25, 0.5, 0.75, 1.0],\n        ),\n      ),\n    ),\n  ),\n);\n```\n\n<div class=\"content-ad\"></div>\n\n## backgroundBlendMode\n\n`backgroundBlendMode`은 BoxDecoration의 가장 복잡한 속성입니다.\n이 속성은 BoxDecoration의 색상/그라데이션을 섞고, BoxDecoration이 위에 있는 것과 혼합하는 역할을 합니다.\n\n`backgroundBlendMode`를 사용하면 `BlendMode` 열거형에서 지정된 다양한 알고리즘을 사용할 수 있습니다.\n\n먼저, `backgroundBlendMode`를 사용하여 Container의 자식 위에 그려지는 `foregroundDecoration`을 BoxDecoration으로 설정해 봅시다. (반면 decoration은 자식 뒤에 그려집니다)\n\n<div class=\"content-ad\"></div>\n\n```js\nScaffold(\n  appBar: AppBar(title: Text('backgroundBlendMode')),\n  body: Center(\n    child: Container(\n      height: 200,\n      width: 200,\n      foregroundDecoration: BoxDecoration(\n        backgroundBlendMode: BlendMode.exclusion,\n        gradient: LinearGradient(\n          colors: const [\n            Colors.red,\n            Colors.blue,\n          ],\n        ),\n      ),\n      child: Image.network(\n        'https://flutter.io/images/catalog-widget-placeholder.png',\n      ),\n    ),\n  ),\n);\n```\n\n`backgroundBlendMode`은 해당 Container에만 영향을 미치는 것이 아닙니다.\n\n`backgroundBlendMode`은 Container에서 상위 위젯 트리에 올라가 있는 모든 색상을 변경합니다.\n아래 코드는 이미지를 그리는 부모 Container와 `backgroundBlendMode`를 사용하는 자식 Container가 있지만, 이전과 동일한 효과를 얻을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nScaffold(\n  appBar: AppBar(title: Text('backgroundBlendMode')),\n  body: Center(\n    child: Container(\n      decoration: BoxDecoration(\n        image: DecorationImage(\n          image: NetworkImage(\n            'https://flutter.io/images/catalog-widget-placeholder.png',\n          ),\n        ),\n      ),\n      child: Container(\n        height: 200,\n        width: 200,\n        foregroundDecoration: BoxDecoration(\n          backgroundBlendMode: BlendMode.exclusion,\n          gradient: LinearGradient(\n            colors: const [\n              Colors.red,\n              Colors.blue,\n            ],\n          ),\n        ),\n      ),\n    ),\n  ),\n);\n```\n\n# Material\n\nBorder with cut corners\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-22-FlutterLayoutCheatSheet_27.png\" />\n\n```js\nScaffold(\n  appBar: AppBar(title: Text('shape: BeveledRectangleBorder')),\n  body: Center(\n    child: Material(\n      shape: const BeveledRectangleBorder(\n        borderRadius: BorderRadius.all(Radius.circular(20)),\n        side: BorderSide(color: Colors.black, width: 4),\n      ),\n      color: Colors.yellow,\n      child: Container(\n        height: 200,\n        width: 200,\n      ),\n    ),\n  ),\n);\n```\n\n# Slivers\n\n# SliverFillRemaining\n\n<div class=\"content-ad\"></div>\n\n이 위젯은 콘텐츠를 중앙 정렬하고 싶을 때 공간이 충분하지 않은 경우에 교체할 수 없습니다. 대화형 예제 있어요!\n\n![FlutterLayoutCheatSheet_28](/assets/img/2024-06-22-FlutterLayoutCheatSheet_28.png)\n\n```js\nScaffold(\n  appBar: AppBar(title: Text('SliverFillRemaining')),\n  body: CustomScrollView(\n    slivers: [\n      SliverFillRemaining(\n        hasScrollBody: false,\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: const [\n            FlutterLogo(size: 200),\n            Text(\n              '로고와 함께 중앙 정렬되어야 하는 가장 긴 텍스트입니다',\n              textAlign: TextAlign.center,\n            ),\n          ],\n        ),\n      ),\n    ],\n  ),\n);\n```\n\n중앙 정렬된 콘텐츠에 공간이 충분하지 않은 경우 SliverFillRemaining이 스크롤 가능해집니다.\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-22-FlutterLayoutCheatSheet_29.png)\n\n만약 SliverFillRemaining이 없었다면 컨텐츠가 이렇게 오버플로될 것입니다:\n\n![이미지](/assets/img/2024-06-22-FlutterLayoutCheatSheet_30.png)\n\n## 남은 공간 채우기\n\n<div class=\"content-ad\"></div>\n\n내용을 가운데 정렬하는 데 유용한 SliverFillRemaining은 뷰포트의 여유 공간을 채웁니다. 이 위젯을 사용하려면 CustomScrollView에 배치되어야하며 마지막 슬리버여야합니다.\n\n![이미지](/assets/img/2024-06-22-FlutterLayoutCheatSheet_31.png)\n\n공간이 충분하지 않은 경우 위젯은 스크롤 가능해집니다.\n\n![이미지](/assets/img/2024-06-22-FlutterLayoutCheatSheet_32.png)\n\n<div class=\"content-ad\"></div>\n\n```js\nScaffold(\n  appBar: AppBar(title: Text('SliverFillRemaining')),\n  body: CustomScrollView(\n    slivers: [\n      SliverList(\n        delegate: SliverChildListDelegate(const [\n          ListTile(title: Text('First item')),\n          ListTile(title: Text('Second item')),\n          ListTile(title: Text('Third item')),\n          ListTile(title: Text('Fourth item')),\n        ]),\n      ),\n      SliverFillRemaining(\n        hasScrollBody: false,\n        child: Container(\n          color: Colors.yellowAccent,\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: const [\n              FlutterLogo(size: 200),\n              Text(\n                'This is some longest text that should be centered'\n                'together with the logo',\n                textAlign: TextAlign.center,\n              ),\n            ],\n          ),\n        ),\n      ),\n    ],\n  ),\n);\n```\n\n## SizedBox\n\n가장 간단하지만 가장 유용한 위젯 중 하나입니다\n\n### ConstrainedBox로서의 SizedBox\n\n<div class=\"content-ad\"></div>\n\nSizedBox는 ConstrainedBox와 비슷한 방식으로 작동할 수 있어요.\n\n![image](/assets/img/2024-06-22-FlutterLayoutCheatSheet_33.png)\n\n```js\nSizedBox.expand(\n  child: Card(\n    child: Text('Hello World!'),\n    color: Colors.yellowAccent,\n  ),\n),\n```\n\n## SizedBox를 패딩으로 사용하기\n\n<div class=\"content-ad\"></div>\n\n여백이나 여백을 추가해야 할 때는 Padding 또는 Container 위젯을 선택할 수 있습니다. 그러나 이러한 방식은 Sizedbox를 추가하는 것보다 더 길고 가독성이 떨어질 수 있습니다.\n\n![FlutterLayoutCheatSheet_34](/assets/img/2024-06-22-FlutterLayoutCheatSheet_34.png)\n\n```js\nColumn(\n  children: <Widget>[\n    Icon(Icons.star, size: 50),\n    const SizedBox(height: 100),\n    Icon(Icons.star, size: 50),\n    Icon(Icons.star, size: 50),\n  ],\n),\n```\n\n## SizedBox를 사용한 보이지 않는 객체\n\n<div class=\"content-ad\"></div>\n\n많은 시간에 따라 위젯을 숨기거나 표시하고 싶을 때가 많습니다.\n\n```js\nWidget build(BuildContext context) {\n  bool isVisible = ...\n  return Scaffold(\n    appBar: AppBar(\n      title: Text('isVisible = $isVisible'),\n    ),\n    body: isVisible\n      ? Icon(Icons.star, size: 150)\n      : const SizedBox(),\n  );\n}\n```\n\nSizedBox에는 const 생성자가 있으므로 const SizedBox()를 사용하는 것이 정말 저렴합니다\\*\\*.\n\n\\*\\*보다 저렴한 해결책은 Opacity 위젯을 사용하고 투명도 값을 0.0으로 변경하는 것입니다. 이 해결책의 단점은 주어진 위젯이 보이지 않을 뿐 아직 공간을 차지할 것이라는 점입니다.\n\n<div class=\"content-ad\"></div>\n\n# SafeArea\n\n다양한 플랫폼에서 안드로이드의 상태 바(Status Bar)나 아이폰 X의 노치(Notch)와 같은 특별한 영역이 있습니다.\n\n이러한 영역 아래에는 그리기를 피할 필요가 있습니다.\n\n이 문제의 해결책은 SafeArea 위젯입니다 (SafeArea를 사용한 예시).\n\n```js\nWidget build(BuildContext context) {\n  return Material(\n    color: Colors.blue,\n    child: SafeArea(\n      child: SizedBox.expand(\n        child: Card(color: Colors.yellowAccent),\n      ),\n    ),\n  );\n}\n```\n\n<div class=\"content-ad\"></div>\n\n중요한 질문이 있으시면 놓치지 않으려면 트위터에서 저에게 개인 메시지를 보내주세요!\n","ogImage":{"url":"/assets/img/2024-06-22-FlutterLayoutCheatSheet_0.png"},"coverImage":"/assets/img/2024-06-22-FlutterLayoutCheatSheet_0.png","tag":["Tech"],"readingTime":24},{"title":"Flutter 위젯 초기화 후 함수 실행하는 방법","description":"","date":"2024-06-22 15:42","slug":"2024-06-22-HowtoFlutterrunningfunctionsafterwidgetinitialization","content":"\n\n이 글에서는 WidgetsBinding.instance.addPostFrameCallback 메서드를 자세히 검토하고 싶습니다.\n\n![image](/assets/img/2024-06-22-HowtoFlutterrunningfunctionsafterwidgetinitialization_0.png)\n\n예를 들어 서버에서 가져온 데이터로 데이터 그리드를 표시하거나 UI가 렌더링된 후에 대화 상자를 표시하려고 합니다. 이를 어떻게 구현할까요?\n\n아마 이미 이해하신 것처럼 WidgetsBinding.instance.addPostFrameCallback 메서드를 사용할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n## WidgetsBinding.instance.addPostFrameCallback은 무엇인가요?\n\nWidgetsBinding.instance.addPostFrameCallback은 플러터(Flutter)에서 개발자가 현재 프레임이 그려진 후에 콜백을 실행할 수 있도록 하는 메서드입니다. 이는 이 콜백 내의 코드가 플러터 프레임워크가 빌드 및 레이아웃 단계를 완료하고 화면에 프레임이 렌더링된 후에 실행된다는 것을 의미합니다.\n\n다음은 사용 방법의 기본 예시입니다:\n\n```js\nWidgetsBinding.instance.addPostFrameCallback((_) {\n  ...\n});\n```\n\n<div class=\"content-ad\"></div>\n\nUnderscore _ 는 콜백의 매개변수로 사용되며, 이는 프레임의 지속 시간을 의미합니다.\n\n하지만 한 걸음 물러나서 \"프레임\"에 대해 이야기해 봅시다. 프레임이라는 개념은 프레임워크가 사용자 인터페이스를 렌더링하는 방식에 중요합니다.\n\n## 프레임이란?\n\nFlutter는 UI를 초당 60프레임(fps) 또는 120Hz 업데이트를 지원하는 장치에서는 초당 120프레임으로 렌더링되도록 설계되었습니다. 각 렌더링을 프레임이라고 합니다. 즉, 대략 16ms마다 UI가 업데이트되어 애니메이션 또는 UI의 다른 변경 사항이 반영됩니다. 16ms보다 오랜 시간이 걸리는 프레임은 디스플레이 장치에서 간섭(부드럽지 않은 모션)을 일으킵니다.\n\n<div class=\"content-ad\"></div>\n\n성능 문제가 발생할 수 있습니다. 프레임을 구축, 레이아웃, 페인트하거나 합성하는 데 필요한 작업 시간이 이 시간 예산을 초과하면 프레임이 삭제되고 눈에 띄는 지연이 발생할 수 있습니다.\n\n새 프레임을 레이아웃하고 페인트할 때 엔진은 자동으로 handleDrawFrame을 호출하며, 이는 drawFrame을 호출하고(빌드 및 렌더 파이프라인을 활성화하여 프레임을 생성)합니다.\n\n각 프레임은 다음 단계로 구성됩니다:\n\n- 빌드 단계:\n\n<div class=\"content-ad\"></div>\n\n- 빌드 단계에서는 Flutter가 위젯 트리를 구성합니다. 트리의 각 위젯은 현재 상태를 기반으로 새 위젯 인스턴스를 생성하기 위해 빌드 메서드를 호출합니다.\n이 단계는 위젯 트리의 다른 부분에 대해 여러 번 발생할 수 있지만, 최종적으로 하나의 프레임으로 렌더링됩니다.\n\n2. 레이아웃 단계:\n\n- 레이아웃 단계에서는 Flutter가 각 위젯의 크기와 위치를 계산합니다. 이 단계는 각 위젯이 화면에 어떻게 배치되어야 하는지 결정하는 데 중요합니다.\n위젯은 제약 조건을 트리로 내려보내고, 각 위젯은 이러한 제약 조건을 기반으로 자체 크기를 조정합니다.\n\n3. 페인트 단계:\n\n<div class=\"content-ad\"></div>\n\n- 페인트 단계에서 Flutter는 각 위젯을 캔버스로 렌더링합니다. 이 단계는 텍스트, 이미지 및 모양을 포함한 위젯의 시각적 표현을 그리는 과정입니다.\n페인팅 프로세스는 매우 최적화되어 있어 Flutter가 복잡한 UI를 효율적으로 렌더링할 수 있습니다.\n\n4. 합성 단계:\n\n- 합성 단계는 그려진 레이어를 최종 이미지로 결합하여 화면에 표시합니다.\n이 단계를 통해 Flutter는 클리핑, 변형 및 투명도와 같은 시각적 효과를 별도의 레이어를 병합하여 효율적으로 처리할 수 있습니다.\n\n## WidgetsBinding.instance.addPostFrameCallback 및 프레임\n\n<div class=\"content-ad\"></div>\n\nWidgetsBinding.instance.addPostFrameCallback은 현재 프레임이 렌더링된 후에 실행될 콜백을 예약하는 메서드입니다.\n\n프레임 렌더링 프로세스에 대해 이해하는 것이 매우 중요합니다:\n\n- 프레임 이후: addPostFrameCallback로 등록된 콜백은 현재 프레임의 빌드, 레이아웃, 페인트 및 합성 단계가 모두 완료된 후에 실행됩니다. 이는 콜백이 실행되기 전에 UI가 완전히 업데이트되었음을 보장합니다.\n- 일회성 실행: 이 콜백은 한 번만 실행되며 프레임이 렌더링된 직후 즉시 실행됩니다. 반복 작업을 위해서는 콜백을 다시 등록해야 합니다.\n\n## addPostFrameCallback 메서드의 사용 사례.\n\n<div class=\"content-ad\"></div>\n\n- 일회성 초기화 논리: 위젯 트리가 빌드된 후 한 번 실행해야 하는 코드에 주로 사용됩니다.\n\n```js\n@override\nvoid initState() {\n  super.initState();\n  WidgetsBinding.instance.addPostFrameCallback((_) {\n    // 여기서 후프레임 초기화를 수행합니다.\n    _showDialog();\n  });\n}\n```\n\n2. 레이아웃 계산: 위젯의 크기와 위치에 의존하는 작업(예: 사용자 정의 애니메이션 또는 위치 지정)을 수행해야 하는 경우, addPostFrameCallback을 사용하면 레이아웃이 완료된 후 이러한 계산이 이루어집니다.\n\n```js\n@override\nWidget build(BuildContext context) {\n  WidgetsBinding.instance.addPostFrameCallback((_) {\n    final RenderBox box = context.findRenderObject() as RenderBox;\n    final position = box.localToGlobal(Offset.zero);\n  });\n  return Container(); // 여기에 위젯을 추가하세요\n}\n```\n\n<div class=\"content-ad\"></div>\n\n3. 상태 관리: 상태가 있는 위젯에서는 처음 렌더링 이후에만 특정 작업이나 상태 변경을 트리거하고 렌더링이나 상태 불일치 문제를 방지하는 것이 좋습니다.\n\n```js\n@override\nvoid initState() {\n  super.initState();\n  WidgetsBinding.instance.addPostFrameCallback((_) {\n    setState(() {\n      _initializeState();\n    });\n  });\n}\n```\n\n언급할만한 사항...\n\n➡️ addPostFrameCallback 내의 코드가 효율적이고 UI 반응성을 유지하기 위해 무겁지 않도록 확인하세요.\n\n<div class=\"content-ad\"></div>\n\n➡️ 다른 개발자들에게 명확히 목적을 전달하기 위해 코드에서 addPostFrameCallback의 사용을 문서화하세요. 일반적인 build-render 흐름을 변경하기 때문에 특히 중요합니다.\n\n➡️ addPostFrameCallback를 과용하거나 오용하는 것은 성능 문제를 야기할 수 있습니다. 특히 복잡한 로직이 콜백에서 실행될 때 그렇습니다.\n\n➡️ 콜백은 한 번만 실행됩니다. 반복 작업을 위해서는 개발자들이 콜백을 다시 등록해야 합니다.\n\n➡️ 콜백 내에서 상태 변경을 관리하는 것은 때로 코드가 더 어려워지고 조심스럽게 다루지 않으면 잠재적인 버그를 유발할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n잘 하셨습니다! 이 글을 읽어주셔서 감사합니다. 도움이 되셨기를 바랍니다.\n\n제 다른 글을 더 살펴보시고 앞으로의 업데이트 소식을 받아보기 위해 팔로우하시거나 👏 몇 개 주시면 감사하겠습니다!","ogImage":{"url":"/assets/img/2024-06-22-HowtoFlutterrunningfunctionsafterwidgetinitialization_0.png"},"coverImage":"/assets/img/2024-06-22-HowtoFlutterrunningfunctionsafterwidgetinitialization_0.png","tag":["Tech"],"readingTime":5},{"title":"iOS와 Android에서 QR 코드를 스캔하는 방법 Flutter 사용하기","description":"","date":"2024-06-22 15:41","slug":"2024-06-22-ScanningQRCodeinFlutteroniOSandAndroid","content":"\n## 플러터 앱에서 QR 코드 스캔 기능을 구현하는 방법을 배워보세요\n\n![QR 코드 스캔](/assets/img/2024-06-22-ScanningQRCodeinFlutteroniOSandAndroid_0.png)\n\n플러터는 구글의 오픈 소스 UI 툴킷으로, 시각적으로 매력적이고 고성능의 크로스 플랫폼 애플리케이션을 만들 수 있는 능력으로 개발자들 사이에서 엄청난 인기를 얻었습니다. 이 글에서는 플러터에서 QR 코드 스캐너를 구현하는 과정을 자세히 살펴보겠습니다. 이를 통해 앱 사용자들이 자신의 디바이스 카메라를 사용하여 QR 코드를 쉽게 스캔할 수 있게 됩니다.\n\n이 튜토리얼을 완료하면 애플리케이션에 QR 코드 스캔 기능을 통합하는 방법에 대해 확실한 이해를 가지게 될 것입니다.\n\n<div class=\"content-ad\"></div>\n\n시작해 봅시다.\n\n## 1. 프로젝트 설정\n\n먼저 아래 명령어를 사용하여 시작하는 Flutter 프로젝트를 생성해야 합니다. qr_code_scanner를 앱 이름으로 바꿔주세요.\n\n```js\nflutter create qr_code_scanner\n```\n\n<div class=\"content-ad\"></div>\n\n위 내용은 친절하고 쉬운 어조로 한국어로 번역하면 다음과 같습니다.\n\n당신을 위해 기본 카운터 앱을 만들어 드릴 거에요. 프로젝트 폴더 내에서 다음 명령어를 실행하여 mobile_scanner 플러그인을 프로젝트에 추가해 보세요.\n\n```js\nflutter pub add mobile_scanner\n```\n\n이제 작동하도록 이를 위해 일부 플랫폼 설정을 해야 합니다.\n\n## - Android\n\n<div class=\"content-ad\"></div>\n\n안녕하세요! 안드로이드 `app` 폴더의 build.gradle 파일로 이동해서 minSdkVersion을 21로 업데이트해주세요.\n\n```js\ndefaultConfig {\n    applicationId \"com.example.qr_code_scanner\"\n    minSdkVersion 21\n    targetSdkVersion flutter.targetSdkVersion\n    versionCode flutterVersionCode.toInteger()\n    versionName flutterVersionName\n}\n```\n\n## - iOS\n\nios`Runner` 폴더의 info.plist 파일로 이동해서 아래 두 가지 키를 추가해주세요.\n\n<div class=\"content-ad\"></div>\n\n```yaml\n<key>NSCameraUsageDescription</key>\n<string>QR 코드 스캐너는 QR 코드를 스캔하기 위해 카메라 액세스가 필요합니다</string>\n\n<key>NSPhotoLibraryUsageDescription</key>\n<string>QR 코드 스캐너는 사진 액세스가 필요합니다. 사진 라이브러리에서 QR 코드를 가져오기 위함입니다</string>\n```\n\n## 2. 코딩 시작하기\n\n이제 QR 코드 스캐너를 만들 준비가 되었습니다. 아래 코드를 추가해주세요\n\nmobile_scanner를 main.dart 파일에 import 해주세요\n\n<div class=\"content-ad\"></div>\n\n```js\nimport \"package:mobile_scanner/mobile_scanner.dart\";\n```\n\n```js\n// 스캐너 추가하기\nMobileScanner(\n  onDetect: (capture) {\n    final List<Barcode> barcodes = capture.barcodes;\n    for (final barcode in barcodes) {\n      print(data);\n    }\n  },\n)\n```\n\n전체 코드:\n\n```js\nimport 'package:flutter/material.dart';\nimport 'package:mobile_scanner/mobile_scanner.dart';\n\nvoid main() {\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'QR 코드 스캐너',\n      theme: ThemeData(\n        colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple),\n        useMaterial3: true,\n      ),\n      home: const MyHomePage(title: 'QR 코드 스캐너'),\n    );\n  }\n}\n\nclass MyHomePage extends StatefulWidget {\n  const MyHomePage({super.key});\n\n  @override\n  State<MyHomePage> createState() => _MyHomePageState();\n}\n\nclass _MyHomePageState extends State<MyHomePage> {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('QR 코드 스캐너')),\n      body: SizedBox(\n        height: 400,\n        child: MobileScanner(onDetect: (capture) {\n          final List<Barcode> barcodes = capture.barcodes;\n          for (final barcode in barcodes) {\n            print(barcode.rawValue ?? \"QR 코드에 데이터를 찾을 수 없음\");\n          }\n        }),\n      ),\n    );\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n그럼 이제 앱에 QR 코드 스캔 기능을 추가했군요.\n\n자세한 내용을 원하시면, 이 프로젝트에 대한 내 Github 저장소를 확인해보세요.\n\n이 글을 통해 얻은 지식으로 플러터 앱에 QR 코드 스캐너를 구현하는 데 잘 대비되셨습니다. 그래서 이제 프로젝트에 이 기능을 통합해보세요. 즐거운 코딩되세요!\n\n이 글을 읽어주셔서 감사합니다 ❤\n뭔가 잘못된 점이 있나요? 댓글로 알려주세요. 개선해 드릴게요.\n\n<div class=\"content-ad\"></div>\n\n만약 이 기사가 도움이 되었다면 👏 박수를 치세요!\n","ogImage":{"url":"/assets/img/2024-06-22-ScanningQRCodeinFlutteroniOSandAndroid_0.png"},"coverImage":"/assets/img/2024-06-22-ScanningQRCodeinFlutteroniOSandAndroid_0.png","tag":["Tech"],"readingTime":4},{"title":"Flutter에서 날짜와 시간 다루기  전문가 되는 팁과 트릭","description":"","date":"2024-06-22 15:40","slug":"2024-06-22-DateandTimeinFlutterGettingMasterTipsandTricks","content":"\n<img src=\"/assets/img/2024-06-22-DateandTimeinFlutterGettingMasterTipsandTricks_0.png\" />\n\n개발자로서, 우리는 종종 강력하고 사용자 친화적인 플러터 애플리케이션을 구축하는 데 중요한 날짜와 시간 조작이 필요한 시나리오에 직면합니다. 날짜를 표시 형식에 맞게 형식화하거나 시간 차이를 계산하거나 시간대를 통합하는 것 모두 날짜와 시간 조작을 숙달하는 데 중요합니다. 이 기사에서는 플러터에서 날짜와 시간 작업의 세계로 뛰어들어, 여러분에게 필요한 지식과 실용적인 팁을 제공하여 날짜와 시간을 효과적으로 처리할 수 있도록 돕겠습니다. DateTime 클래스 이해부터 타임스탬프 저장을 위해 Firebase를 활용하는 방법까지, 이 포괄적인 안내서는 여러분이 앱의 기능을 강화하고 매끄러운 사용자 경험을 제공할 수 있도록 도와줄 것입니다.\n\n<img src=\"/assets/img/2024-06-22-DateandTimeinFlutterGettingMasterTipsandTricks_1.png\" />\n\n- 플러터에서 날짜와 시간 객체 이해\n- 날짜와 시간 형식 지정\n- 시간 차이와 기간 계산\n- 시간대 작업\n- 고급 날짜 및 시간 작업\n- 효율적인 날짜 및 시간 조작 기술\n- 날짜와 시간 저장을 위해 Firebase 통합\n- 날짜와 시간 조작을 위한 최선의 방법\n\n<div class=\"content-ad\"></div>\n\n## 플러터에서의 날짜 및 시간 개념 이해\n\n플러터에서는 DateTime 클래스를 사용하여 날짜와 시간을 나타냅니다. 이 클래스는 날짜와 시간 값을 조작하고 처리하기 위한 다양한 속성과 메소드를 제공합니다. 이해해야 할 중요한 개념은 다음과 같습니다:\n\n```js\nDateTime now = DateTime.now();\nint year = now.year;\nint month = now.month;\nint day = now.day;\nint hour = now.hour;\nint minute = now.minute;\nint second = now.second;\n```\n\n## 날짜와 시간 형식 지정\n\n<div class=\"content-ad\"></div>\n\nintl: Flutter에서는 국제화 및 로컬라이제이션을 위해 일반적으로 intl 패키지를 사용하지만, 고급 날짜 및 시간 포맷팅을 위한 DateFormat 클래스도 제공됩니다. 다양한 형식 패턴을 제공하여 다른 지역 설정에 따라 날짜와 시간을 표시할 수 있습니다.\n\n날짜 및 시간 객체 포맷팅:\n\n```js\nimport 'package:intl/intl.dart';\n\nDateTime now = DateTime.now();\nString formattedDate = DateFormat('MMMM dd, yyyy').format(now);\nprint(formattedDate);  // 예시 출력: \"7월 03, 2023\"\nint month = now.month; // 월이 정수 값으로 표시되는 것을 전제로\nprint(month); // 결과: 7\nString monthName = DateFormat('MMMM').format(DateTime(currentYear, month));\nprint(monthName); // 결과: \"7월\"\n```\n\n로케일 지정하여 날짜 및 시간 객체 포맷팅하기:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport 'package:intl/intl.dart';\n\nDateTime now = DateTime.now();\nint currentYear = DateTime.now().year;\nString formattedDate = DateFormat('d MMMM yyyy', 'fr_FR').format(now);\nprint(formattedDate);  // Example output: \"3 juillet 2023\"\n```\n\n여기서는 DateFormat의 두 번째 인수로 로캘 `fr_FR`을 전달하여 프랑스어로 날짜를 형식화합니다. 이렇게 하면 결과로 나오는 형식화된 날짜 문자열이 프랑스 로캘 규칙을 따릅니다.\n\n이 원활한 코드 예제들은 Flutter에서 intl 패키지를 사용하여 DateTime 객체를 형식화하는 방법을 보여줍니다. 다양한 형식 패턴과 로캘을 지정하여 Flutter 애플리케이션에서 로컬화된 및 사용자 정의된 날짜 및 시간 표현을 생성할 수 있습니다.\n\n## 시간 차이와 기간 계산하기\n\n<div class=\"content-ad\"></div>\n\n플러터에서는 두 개의 DateTime 객체 간의 차이를 계산하고 Duration 클래스를 사용하여 기간을 다룰 수 있습니다. 다음은 중요한 개념과 부드러운 코드 예제입니다:\n\n```js\nDateTime firstDate = DateTime(2023, 7, 1);\nDateTime secondDate = DateTime(2023, 7, 5);\n\nDuration difference = secondDate.difference(firstDate);\nprint(difference.inDays); // 출력: 4\n```\n\n이 예제에서는 서로 다른 날짜를 나타내는 두 DateTime 객체인 firstDate와 secondDate가 있습니다. 두 번째 날짜에 difference 메서드를 호출하고 첫 번째 날짜를 인수로 전달하여 두 날짜 간의 차이를 나타내는 Duration 객체를 얻습니다. 이 경우, 차이는 4일입니다.\n\n기간을 다루는 방법:\n\n<div class=\"content-ad\"></div>\n\n```js\nDuration duration = Duration(hours: 2, minutes: 30, seconds: 45);\n\nprint(duration.inHours);   // 출력: 2\nprint(duration.inMinutes); // 출력: 150\nprint(duration.inSeconds); // 출력: 9045\n\n// Duration을 문자열로 포맷팅:\nDuration duration = Duration(hours: 2, minutes: 30);\n\nString formattedDuration = '${duration.inHours}시간 ${duration.inMinutes.remainder(60)}분';\nprint(formattedDuration); // 출력: \"2시간 30분\"\n```\n\n여기서는 \"X시간 Y분\" 형식의 문자열 표현으로 기간을 포맷팅합니다 (예: \"2시간 30분\"). inHours 및 inMinutes 속성을 결합하고 나머지 메서드를 사용하여 시간을 뺀 후 남은 분을 가져와서 원하는 포맷팅된 기간 문자열을 만듭니다.\n\n이 원활한 코드 예제는 DateTime 객체 사이의 시간 차이를 계산하고 Flutter에서 기간을 사용하는 방법을 보여줍니다. 날짜 간 차이를 결정하거나 디스플레이를 위해 기간을 포맷하는 경우 Duration 클래스는 Flutter 애플리케이션 내에서 시간과 관련된 작업을 처리하는 데 필요한 도구를 제공합니다.\n\n## 타임존 사용하기\n\n<div class=\"content-ad\"></div>\n\n플러터에서는 intl 패키지와 DateTime 클래스를 사용하여 시간대를 처리할 수 있어요. 여기 몇 가지 주요 개념과 부드러운 코드 예시가 있습니다.\n\n특정 시간대로 DateTime 변환하기:\n\n```js\nimport 'package:intl/intl.dart';\nimport 'package:timezone/timezone.dart' as tz;\n\nDateTime dateTime = DateTime.now();\nString timezone = 'America/New_York';\n\ntz.TZDateTime convertedDateTime =\n    tz.TZDateTime.from(dateTime, tz.getLocation(timezone));\n\nprint(convertedDateTime); // 출력: 2023-07-03 09:30:00.000 EDT\n```\n\n다른 시간대에서 DateTime 표시하기:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport 'package:intl/intl.dart';\nimport 'package:timezone/timezone.dart' as tz;\n\nDateTime dateTime = DateTime.now();\nString timezone = 'Asia/Tokyo';\n\ntz.TZDateTime convertedDateTime =\n    tz.TZDateTime.from(dateTime, tz.getLocation(timezone));\n\nString formattedDateTime = DateFormat('yyyy-MM-dd HH:mm').format(convertedDateTime);\n\nprint(formattedDateTime); // 출력: 2023-07-04 01:30\n```\n\n이 부드러운 코드 예제들은 플러터에서 시간대를 다루는 방법을 보여줍니다. 형식 지정에는 intl 패키지를 사용하고 시간대 처리에는 timezone 패키지를 활용하여 Flutter 애플리케이션에서 다른 시간대의 DateTime 객체를 정확하게 변환하고 표시할 수 있습니다.\n\n## 고급 날짜 및 시간 연산\n\n<div class=\"content-ad\"></div>\n\n```js\nDateTime now = DateTime.now();\nDateTime newDateTime = now.add(Duration(days: 7, hours: 3));\n\nprint(newDateTime); // 출력: 2023-07-10 12:30:00.000\n```\n\n특정 구성 요소 추출:\n\n```js\nDateTime now = DateTime.now();\nint year = now.year;\nint month = now.month;\nint day = now.day;\nint hour = now.hour;\nint minute = now.minute;\nint second = now.second;\n\nprint('$year-$month-$day $hour:$minute:$second'); // 예시 출력: \"2023-7-3 10:15:30\"\n```\n\n윤년 확인:\n\n<div class=\"content-ad\"></div>\n\n```js\nint year = 2024;\nbool isLeapYear = DateTime(year).isLeapYear;\n\nprint(isLeapYear); // Output: true\n```\n\n## 효율적인 날짜 및 시간 조작 기술\n\n비교를 위해 UTC 사용:\n\n```js\nDateTime now = DateTime.now();\nDateTime futureDate = now.add(Duration(days: 7));\n\nbool isFuture = futureDate.isAfter(now);\nprint(isFuture); // Output: true\n```\n\n<div class=\"content-ad\"></div>\n\n중복으로 파싱하고 형식을 변경하지 마십시오:\n\n```js\nString formattedDate = '2023-07-03';\nDateTime parsedDate = DateTime.parse(formattedDate);\n\nString reFormattedDate = parsedDate.toIso8601String();\nprint(reFormattedDate); // 출력: 2023-07-03T00:00:00.000\n```\n\n캐시된 인스턴스 활용하기:\n\n```js\nDateTime now = DateTime.now();\nDateTime cachedNow = now;\n\n// 캐시된 인스턴스를 사용하여 여러 작업 수행\nDateTime futureDate = cachedNow.add(Duration(days: 7));\nbool isFuture = futureDate.isAfter(cachedNow);\n\nprint(isFuture); // 출력: true\n```\n\n<div class=\"content-ad\"></div>\n\n## Firebase를 사용하여 날짜와 시간 저장하기\n\nFirebase는 Firestore와 같은 실시간 데이터베이스를 제공하는 인기 있는 백엔드 플랫폼입니다. Flutter 애플리케이션에서 다른 데이터와 함께 날짜와 시간을 저장하기 위해 Firebase Firestore를 활용할 수 있습니다. Firebase를 사용하여 날짜와 시간을 저장하는 방법은 다음과 같습니다:\n\nFirestore에 날짜와 시간 저장하기:\n\n```js\nimport 'package:cloud_firestore/cloud_firestore.dart';\n\nFirebaseFirestore firestore = FirebaseFirestore.instance;\n\nvoid saveDateTime() {\n  DateTime now = DateTime.now();\n\n  firestore.collection('your_collection').add({\n    'timestamp': now,\n  });\n}\n```\n\n<div class=\"content-ad\"></div>\n\n파이어스토어로부터 날짜와 시간 얻기:\n\n```js\nimport 'package:cloud_firestore/cloud_firestore.dart';\n\nFirebaseFirestore firestore = FirebaseFirestore.instance;\n\nvoid retrieveDateTime() async {\n  DocumentSnapshot documentSnapshot = await firestore\n      .collection('your_collection')\n      .doc('your_document_id')\n      .get();\n\n  DateTime timestamp = documentSnapshot['timestamp'].toDate();\n\n  print(timestamp); // 출력: 2023-07-03 10:30:45.000\n}\n```\n\n플러터 앱에 Firebase Firestore를 통합하면 다른 데이터와 함께 날짜와 시간을 저장하고 검색할 수 있습니다. 이를 통해 Firebase의 실시간 능력을 활용한 효율적이고 원활한 데이터 관리가 가능해집니다.\n\n## 날짜와 시간 조작을 위한 모범 사례\n\n<div class=\"content-ad\"></div>\n\nFlutter에서 날짜와 시간을 다룰 때는 코드 가독성, 유지 보수성 및 정확성을 보장하기 위해 최상의 사례를 따르는 것이 중요합니다. 다음은 주요 사례와 부드러운 코드 예제입니다:\n\n기술적인 변수 이름 사용하기:\n\n```js\nDateTime currentDate = DateTime.now();\nint selectedYear = 2023;\nint selectedMonth = 7;\nint selectedDay = 3;\n```\n\ncurrentDate, selectedYear, selectedMonth 및 selectedDay와 같은 기술적 변수 이름은 코드의 가독성과 이해를 높입니다. 이러한 이름은 명확한 문맥을 제공하며 각 변수의 목적을 이해하기 쉽게 만듭니다.\n\n<div class=\"content-ad\"></div>\n\n에지 케이스 다루기:\n\n```js\nDateTime date = DateTime(2023, 2, 30);\n\nif (date.month == DateTime.february && date.day > 28) {\n  // 잘못된 날짜 처리\n}\n```\n\n2월 30일과 같은 유효하지 않은 날짜와 같은 예외 사례에 주의하십시오. 해당 사례를 처리하면 예기치 않은 동작이나 오류를 방지할 수 있습니다. 이 예에서는 월이 2월인지(DateTime.february) 확인하고 날짜가 28을 초과하는지 검사하여 유효하지 않은 날짜 시나리오에 대응합니다.\n\n시간대 변환을 고려해 보세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nDateTime utcDateTime = DateTime.now().toUtc();\nDateTime localDateTime = utcDateTime.toLocal();\n```\n\n시간대를 다룰 때는 UTC (협정 세계 표준시)와 지역 시간 간의 변환에 주의해야 합니다. DateTime 객체를 UTC로 변환하려면 toUtc() 메서드를 사용하고, 다시 지역 시간대로 변환하려면 toLocal()을 사용하세요.\n\n따라오느라 감사합니다. 아래 댓글에 생각을 자유롭게 남겨주세요.\n\n트위터에서 저를 팔로우해주세요.\n\n<div class=\"content-ad\"></div>\n\n만나서 반가워요!\n","ogImage":{"url":"/assets/img/2024-06-22-DateandTimeinFlutterGettingMasterTipsandTricks_0.png"},"coverImage":"/assets/img/2024-06-22-DateandTimeinFlutterGettingMasterTipsandTricks_0.png","tag":["Tech"],"readingTime":9},{"title":"Dart에서 콜백 함수 구현하는 방법","description":"","date":"2024-06-22 15:39","slug":"2024-06-22-HowtoimplementCallbackFunctioninDart","content":"\n\n<img src=\"/assets/img/2024-06-22-HowtoimplementCallbackFunctioninDart_0.png\" />\n\n다트를 사용하여 Callback을 사용할 수 있습니다.\n\nCallback은 다른 함수나 메서드에 인수로 전달된 함수입니다. 이를 통해 수신 함수가 콜백 함수를 실행할 수 있습니다.\n\n콜백에 대해 설명하려면 이 예시를 사용할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n**단계 1:** success와 인수로 다른 함수를 갖는 request 함수를 생성합니다. success 함수는 인수를 전달 받지 않습니다. success 함수는 request 함수 내에서 실행됩니다.\n\n```js\nrequest(Function success){\n  success();\n}\n```\n\n**단계 2:** 호출되었을 때 \"success\"를 출력하는 또 다른 함수를 생성합니다.\n\n```js\nprintMessage(){\n  print('Success'); //Success\n}\n```\n\n<div class=\"content-ad\"></div>\n\nStep 3: 이 코드 조각에서는 우리의 코드를 실행할 Function Main을 생성할 것입니다.\n\n```js\nvoid main() {\n   \n}\n```\n\n만약 Function request를 호출한다면 함수에 인수로 전달해야 합니다. 하지만 이 함수를 이름으로 호출할 때는 괄호( )를 사용할 필요가 없습니다.\n\n```js\nvoid main() {\n  request(printMessage); \n}\n```\n\n<div class=\"content-ad\"></div>\n\n여기 완성된 코드입니다:\n\n js\nvoid main() {\n  request(printMessage); \n}\n\nrequest(Function() success){\n    success();\n}\n    \nprintMessage(){\n   print('Success'); //Success \n}\n\n\nCallback을 사용하는 다른 옵션은 익명 함수를 사용하는 것입니다.\n\n이 스니펫에서는 익명 함수를 인수로 사용하여 함수 요청에 전달합니다. 함수 요청을 호출할 때 함수의 구조를 직접 작성할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nvoid main(){\n  request((){\n    print('Success'); // Success \n }); \n}\n```\n\nCallback를 사용하는 또 다른 방법을 설명해 드리겠습니다.\n\n단계 1: 인수로 다른 함수를 가지는 request 함수를 변경할 것입니다. 이 함수는 success라는 이름의 함수를 인수로 사용하며 String 타입을 반환하고 String 타입의 인수를 받습니다.\n\n단계 2: success 함수에 인수를 추가하기 위해 request 함수에서 success 함수로 이동하여 인수를 전달할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n  request( String Function(String text) success){\n      print(success ('Hello world'));\n}\n```\n\nStep 3: \"request\" 함수를 호출할 때 함수의 구조를 인수로 전달하고 받을 인수에 동작을 할당합니다.\n\n코드를 실행하면 \"Hello World Success\"가 출력됩니다.\n\n```js\nvoid main(){\n  request((text){\n     return '$text Success'; \n }); \n} // Hello World Success\n```\n\n<div class=\"content-ad\"></div>\n\n여기 완전한 코드입니다:\n\n```js\nvoid main(){\n \n request((text){ \n    return '$text 성공';\n   }); \n  } //Hello World 성공\n     \n request(String Function(String text) success){\n    print(success('Hello World'));\n}\n```\n\n이 글이 유용했기를 바랍니다. 귀하의 프로그램 코딩에 활용하실 수 있기를 기대합니다.\n\n<img src=\"/assets/img/2024-06-22-HowtoimplementCallbackFunctioninDart_1.png\" />","ogImage":{"url":"/assets/img/2024-06-22-HowtoimplementCallbackFunctioninDart_0.png"},"coverImage":"/assets/img/2024-06-22-HowtoimplementCallbackFunctioninDart_0.png","tag":["Tech"],"readingTime":3},{"title":"Flutter에서 환경 변수 사용하는 방법","description":"","date":"2024-06-22 15:38","slug":"2024-06-22-HowtouseenvironmentvariablesinFlutter","content":"\n\n플러터는 크로스 플랫폼 기능, 성능 및 다양한 위젯 라이브러리로 모바일 앱을 구축하기 위해 인기가 있습니다. 플러터 개발자로서, API 키, 데이터베이스 URL 및 환경별 변수와 같은 다양한 구성 설정이 필요한 프로젝트에 자주 참여합니다. 이러한 설정을 적절하게 관리하는 것은 여러 가지 이유로 중요합니다:\n\n1. 보안: API 키 및 데이터베이스 URL과 같이 민감한 정보는 보호되어야 합니다. 개발 및 프로덕션용으로 다른 설정을 사용하면 민감한 데이터가 안전하지 않은 환경에서 노출되지 않도록 보호할 수 있습니다.\n\n2. 일관성: 다른 환경은 서로 다른 요구 사항과 제약 사항을 가지고 있습니다. 환경별 설정을 관리하면 개발, 스테이징 및 프로덕션 환경에서 앱이 일관되게 동작하도록 보장하여 예기치 않은 문제의 위험을 줄일 수 있습니다.\n\n3. 효율성: 적절한 구성 관리는 개발 프로세스를 간소화합니다. 개발자는 설정을 수동으로 변경하지 않고 환경 간에 쉽게 전환할 수 있어 생산성을 향상시키고 오류 가능성을 줄일 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n4. 확장성: 프로젝트가 커짐에 따라 여러 환경을 관리하는 것은 더 복잡해집니다. 구조화된 설정 관리 접근 방식은 코드베이스의 확장성과 유지보수성을 향상시킬 수 있습니다.\n\n5. 규정 준수: 특정 프로젝트에는 개발, 테스트 및 제품용으로 별도의 환경을 사용해야 하는 규정 준수 요구사항이 있을 수 있습니다. 서로 다른 설정을 관리하여 앱이 이러한 규정을 준수할 수 있도록합니다.\n\n다양한 환경에 대한 설정을 효과적으로 관리함으로써 플러터 개발자는 애플리케이션의 보안, 일관성, 효율성, 확장성 및 규정 준수를 향상시킬 수 있어 더 견고하고 신뢰할 수 있는 최종 제품을 얻을 수 있습니다.\n\n# 시작해봅시다 :)\n\n<div class=\"content-ad\"></div>\n\n컴파일 시간 변수를 사용하면 환경 변수를 컴파일 시간에만 정의할 수 있습니다. 이는 변수가 flutter run 또는 flutter build 명령을 실행하는 동안 설정된다는 것을 의미합니다. 따라서 이러한 명령은 CI 환경에서 컴파일/빌드 프로세스에 통합될 수 있습니다. Dart와 Flutter 생태계에서는 컴파일 시간 환경 변수 선언의 개념이 잘 확립되어 있습니다.\n\n만약 초기부터 Flutter Web에서 작업을 해오셨다면, --dart-define 인수는 주로 다음과 같이 사용되어 Flutter Web에서 Skia를 활성화하는 데 사용되었습니다 --dart-define=FLUTTER_WEB_USE_SKIA=true\n\n예를 들어 다음과 같은 인수를 사용하여 Flutter 애플리케이션을 시작할 때:\n\n```js\nflutter run --dart-define=APP_NAME=\"Flutter Environment Variables\"\n```\n\n<div class=\"content-ad\"></div>\n\n다음으로, Dart 코드에서 이러한 값을 간단히 사용할 수 있어요:\n\n```js\nabstract class EnvConfig {\n  static String appName = const String.fromEnvironment(\n    'APP_NAME',\n    defaultValue: 'Flutter Demo',\n  );\n}\n\n/// 모든 컴파일 타임 변수는 String.fromEnvironment, bool.fromEnvironment 및 \n/// int.fromEnvironment 생성자를 사용하여 상수로 사용할 수 있어요.\n```\n\nAPP_NAME에 대한 기본값으로 Flutter Demo를 사용했다는 점을 알 수 있어요. 값이 전달되지 않으면 기본값이 사용될 거예요.\n\n실제로 동작하는 것을 보자.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-22-HowtouseenvironmentvariablesinFlutter_0.png)\n\n플러터 환경 변수가 전달된 인수에서 기본값 대신 렌더링된 것을 알 수 있습니다.\n\n비슷한 방식으로 여러 변수를 전달해야 하는 경우 --dart-define 플래그를 계속 사용할 수 있습니다. 그러나 여러 변수를 필요로 하는 프로젝트의 경우 이러한 설정을 구성 파일을 통해 효율적으로 관리하는 것이 좋습니다.\n\n프로젝트의 루트 디렉토리에 .env 파일을 생성할 수 있습니다. .env는 키-값 쌍 형식의 간단한 환경 파일입니다.\n\n\n<div class=\"content-ad\"></div>\n\n아래는 Flutter가 상수 전역 풀에 정의하는 환경별 변수를 담은 파일입니다.\n\n이 변수들에 접근하려면 이전에는 flutter_dotenv를 추가하고 다음과 같이 변수에 액세스해야 했습니다.\n\n```js\nimport 'package:flutter_dotenv/flutter_dotenv.dart';\n```\n\n<div class=\"content-ad\"></div>\n\n```js\nFuture main() async {\n  //...\n  await dotenv.load(fileName: \".env\");\n  //...runapp\n  final appName = dotenv.env['APP_NAME'];\n  //...\n}\n```\n\n간단히! 당신의 Dart 코드는 이렇게 보일 것입니다.\n\n```js\nabstract class EnvConfig {\n  static String appName = const String.fromEnvironment(\n    'APP_NAME',\n    defaultValue: 'Flutter Demo',\n  );\n  static String appEnvironment = const String.fromEnvironment(\n    'APP_ENVIRONMENT',\n    defaultValue: 'development',\n  );\n}\n```\n\n--dart-define-from-file을 사용하면 다양한 설정을 관리하는 과정을 간소화할 수 있습니다. --dart-define 플래그로 각 변수를 개별적으로 전달하는 대신, 개발자는 필요한 모든 설정이 포함된 단일 .env 파일을 유지할 수 있습니다. 이 접근 방식은 환경 변수의 가독성과 구성을 향상시키며, 구성을 관리하고 업데이트하는 작업을 쉽게 만듭니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nflutter run --dart-define-from-file=.env\n```\n\n실제로 실행해보겠습니다!\n\nJSON 파일에서도 다음 형식의 key-value 쌍을 사용할 수 있습니다:\n\n```js\nflutter run --dart-define-from-file=env.json\n```\n\n<div class=\"content-ad\"></div>\n\n마크다운 형식으로 변경하면 다음과 같습니다.\n\n\n![이미지1](/assets/img/2024-06-22-HowtouseenvironmentvariablesinFlutter_2.png)\n\n이와 같이 여러 개의 .env 파일을 정의하여 아래와 같이 다양한 환경을 지원할 수 있습니다:\n\n![이미지2](/assets/img/2024-06-22-HowtouseenvironmentvariablesinFlutter_3.png)\n\n이제 dev.env 파일을 사용할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\nflutter run --dart-define-from-file=dev.env\n```\n\n그리고 prod.env 파일은 다음과 같이 작성하실 수 있어요.\n\n```js\nflutter run --dart-define-from-file=prod.env\n```\n\n걱정 마세요! 매번 앱을 실행할 때마다 --dart-define-from-file 인자를 지정할 필요는 없어요. IDE에서 이를 설정할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\nIntelliJ/Android Studio에서는 실행/디버그 구성을 업데이트해 주세요.\n\n![이미지](/assets/img/2024-06-22-HowtouseenvironmentvariablesinFlutter_4.png)\n\nVS Code에서는 launch.json을 편집해 주세요.\n\n![이미지](/assets/img/2024-06-22-HowtouseenvironmentvariablesinFlutter_5.png)\n\n<div class=\"content-ad\"></div>\n\n그거야! :) 여기 소스 코드예요\n\n마지막으로, 환경 변수를 플러터에서 사용하면 설정을 안전하고 효율적으로 관리할 수 있어요.","ogImage":{"url":"/assets/img/2024-06-22-HowtouseenvironmentvariablesinFlutter_0.png"},"coverImage":"/assets/img/2024-06-22-HowtouseenvironmentvariablesinFlutter_0.png","tag":["Tech"],"readingTime":5},{"title":"Flutter로 MRZ ID 스캐너 만드는 방법","description":"","date":"2024-06-22 15:37","slug":"2024-06-22-HowtocreateanMRZIDSCANNERwithFLUTTER","content":"\n\n<img src=\"/assets/img/2024-06-22-HowtocreateanMRZIDSCANNERwithFLUTTER_0.png\" />\n\n기계 판독 영역(Machine-Readable Zone, MRZ)은 여권 및 신분증과 같은 다양한 신분증에서 사용되는 중요한 구성 요소로, 기계가 빠르고 정확하게 읽을 수 있는 형식으로 필수 정보를 인코딩합니다. MRZ에는 전화증 번호, 이름, 국적, 출생일 및 만료일과 같은 세부 정보가 포함된 고정 구조의 두 개 또는 세 개의 텍스트 라인이 일반적으로 포함됩니다.\n\n본 프로젝트에서는 Flutter를 사용하여 MRZ 탐지 도구를 개발하여 효율적이고 신뢰할 수 있는 인식을 달성하기 위해 여러 고급 도구와 라이브러리를 활용했습니다. 이 구현의 핵심 구성 요소는 ML Kit의 텍스트 인식 API인데, 정규 표현식을 사용하여 MRZ 정보를 탐지하고 읽는 데 활용됩니다. 또한 메모리 및 성능을 효율적으로 관리하기 위해 Isolate Spawn을 활용하여 응용 프로그램이 집중적인 처리 작업 중에도 반응성이 유지되도록 보장했습니다. 마지막으로, Flutter 앱 내에서 고품질 카메라 기능을 용이하게 하는 Camera Awesome 패키지가 통합되었습니다.\n\n이러한 강력한 도구를 결합하여, 응용 프로그램은 정확하게 MRZ 데이터를 탐지하고 처리하여, 신분증을 스캔하고 확인해야 하는 사용자들에게 원활한 경험을 제공할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n- 앱 만들기\n\n![이미지](/assets/img/2024-06-22-HowtocreateanMRZIDSCANNERwithFLUTTER_1.png)\n\n2. 종속 항목 추가\n\n이러한 종속 항목은 이 프로젝트에서만 필요합니다.\n\n<div class=\"content-ad\"></div>\n\n- camerawesome | Flutter package (pub.dev)\n- google_mlkit_text_recognition | Flutter package (pub.dev)\n- google_mlkit_commons | Flutter package (pub.dev)\n\n3. 앱 구성하기\n\n이 애플리케이션을 빌드하려면 특별한 요구 사항이 필요하지 않습니다. 그냥 각 패키지가 요청하는 대로 구현하면 됩니다 (제 경우에는 GITHUB가 통합되어 있습니다).\n이 경우에는 podfile 구성과 최소 버전을 확인해야 합니다\n\n![이미지](/assets/img/2024-06-22-HowtocreateanMRZIDSCANNERwithFLUTTER_2.png)\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-22-HowtocreateanMRZIDSCANNERwithFLUTTER_3.png\" />\n\nhttps://pub.dev/packages/google_mlkit_text_recognition#requirements에 가보세요. (google_ml_kit_commons도 유사한 요구 사항이 있습니다.)\n\nFlutter 패키지인 camerawesome (pub.dev)\n\n4. 시작하세요!\n\n<div class=\"content-ad\"></div>\n\n먼저, 이 프로젝트에 Camera Awesome를 구현합니다.\n\n그런 다음 카메라에 오버레이를 추가해야 합니다. 우리가 문서를 더 잘 보기 위해서는 화면 전체를 차지할 필요가 없으니, 가운데 부분에만 필요합니다.\n\n그리고 나서 google_ml_kit_text_recognition을 사용하여 MRZ 코드를 인식하는 알고리즘을 구현할 것입니다.\n\n마지막으로, 텍스트 처리 과정을 인식하는 클래스를 생성하고, 해당 클래스에는 2개의 메서드가 있습니다:\n\n<div class=\"content-ad\"></div>\n\nA. firstDetectingProcess: MRZ 코드의 첫 번째 일치 검색\n\nB. photoTextProcess: 여기서 MRZ 정보를 가져옵니다. 이 경우에는 콜롬비아 DNI에 필요하기 때문에 필요한 경우에 구현할 수 있습니다.\n\n이것을 귀하의 응용 프로그램에 구현하려면 고립된 스폰을 사용하는 것을 권장합니다. 이렇게 하면 전화의 자원을 효율적으로 활용할 수 있습니다.\n마지막으로, 고립체를 구현하려면 코드가 다음과 같아야 합니다.\n\n코드를 실행하고 결과를 확인하세요:\n\n<div class=\"content-ad\"></div>\n\n`<img src=\"/assets/img/2024-06-22-HowtocreateanMRZIDSCANNERwithFLUTTER_4.png\" />`\n\n이 글을 읽어주셔서 정말 감사합니다. 제가 이 포스트와 제 자신을 더 개선할 수 있는 방법에 대한 피드백을 정말 감사히 받겠습니다!","ogImage":{"url":"/assets/img/2024-06-22-HowtocreateanMRZIDSCANNERwithFLUTTER_0.png"},"coverImage":"/assets/img/2024-06-22-HowtocreateanMRZIDSCANNERwithFLUTTER_0.png","tag":["Tech"],"readingTime":3},{"title":"2024년 플러터 개발자 로드맵","description":"","date":"2024-06-22 05:59","slug":"2024-06-22-The2024FlutterDeveloperRoadMap","content":"\n\n## 플러터 개발자가 되기 위한 완벽한 안내서와 리소스 링크\n\n![이미지](/assets/img/2024-06-22-The2024FlutterDeveloperRoadMap_0.png)\n\n안녕하세요 여러분, Flutter를 배우고 싶으시다면, 크로스플랫폼 모바일 애플리케이션 개발을 위한 인기 있는 프레임워크 중 하나인 Flutter에 대해 배우고 싶으시다면, 제가 올바른 장소에 오신 것을 환영합니다.\n\n이전에 제가 최고의 Flutter 강의를 공유했었고, 이번 글에서는 완벽한 Flutter 로드맵을 공유하려 합니다. 제를 알고 계시다면, 저는 로드맵을 좋아하는 팬이라고요. 지금까지 Java 개발자 로드맵, Python 개발자 로드맵, 웹 개발자 로드맵, iOS 개발자 로드맵, 그리고 DevOps 엔지니어 로드맵을 공유해왔었는데, 여러분들이 많이 좋아해주셨었습니다.\n\n<div class=\"content-ad\"></div>\n\n지금은 Flutter에 대해 깊이 있는 학습을 진행할 것입니다. 모바일, 웹 및 데스크톱용으로 아름답고 네이티브로 컴파일된 애플리케이션을 구축하기 위한 Google의 UI 툴킷인 Flutter는 크로스 플랫폼 앱 개발을 혁신적으로 변화시켰습니다.\n\n그 간편함, 성능 및 넓은 범위의 미리 만들어진 위젯을 통해 Flutter는 개발자들 사이에서 인기 있는 선택지가 되었습니다.\n\n하지만, 시간이 없다면 Udemy의 'Learn Flutter and Dart to Build iOS and Android Apps' 코스에 가입하는 것을 제안합니다. 2024년에 Flutter와 Dart를 배우기 위한 최고의 온라인 코스 중 하나입니다.\n\n![이미지](/assets/img/2024-06-22-The2024FlutterDeveloperRoadMap_1.png)\n\n<div class=\"content-ad\"></div>\n\n# 2024 플러터 개발자 로드맵\n\n이제 저는 GitHub에서 발견한 이 플러터 개발자 로드맵에 대해 이야기해 보겠습니다. 초보자든 경험 많은 개발자든, 명확한 로드맵을 갖는 것은 뛰어난 플러터 개발자가 되기 위해 필요한 기술과 기술들을 안내받을 수 있도록 도와줄 것입니다.\n\n이 글에서는 플러터 개발자 로드맵을 살펴보며, 플러터를 마스터하고 놀라운 애플리케이션을 만드는 데 도움이 되는 포괄적인 가이드로 역할할 것입니다.\n\n![이미지](/assets/img/2024-06-22-The2024FlutterDeveloperRoadMap_2.png)\n\n<div class=\"content-ad\"></div>\n\n이미지 크레딧 — https://github.com/olexale/flutter_roadmap\n\n## 1. Dart 프로그래밍 언어\n\nFlutter에 뛰어들기 전에 Dart 프로그래밍 언어에 대한 탄탄한 이해가 중요합니다. Dart는 Flutter가 기반으로 하는 언어이며 Dart를 숙달하는 것은 효율적이고 표현력 있는 코드를 작성할 수 있게 해줍니다.\n\nDart의 구문, 데이터 유형, 제어 흐름, 함수 및 객체지향 프로그래밍 원칙을 배우는 것으로 시작하세요. 비동기 프로그래밍과 Dart 패키지 생태계와 같은 기능을 습득하여 Flutter 개발에 중요한 역할을 하는 것에 익숙해지세요.\n\n<div class=\"content-ad\"></div>\n\nDart를 배우고 싶다면 Udemy의 Dart와 Flutter: 완전한 개발자 가이드 강좌를 추천해요. Dart 프로그래밍 언어를 시작하는 데 좋은 강좌입니다.\n\n![image](/assets/img/2024-06-22-The2024FlutterDeveloperRoadMap_3.png)\n\n## 2. Flutter 기초\n\nDart에 대한 이해를 쌓았다면, 이제 Flutter의 기초를 파해치는 것이 시간입니다. 먼저 Flutter의 아키텍처, 위젯 및 레이아웃 시스템에 대한 훌륭한 소개를 제공하는 공식 Flutter 문서부터 시작해보세요.\n\n<div class=\"content-ad\"></div>\n\n위젯 트리, 상태 관리, 사용자 입력 처리 및 애니메이션 작업에 대해 배워보세요. 작은 Flutter 애플리케이션을 만들고 다양한 UI 구성 요소를 탐험하여 실전 경험을 쌓을 수 있습니다.\n\n만약 Flutter 프레임워크를 시작하는 데 도움이 필요하다면, 이전 강의를 듣는 것이나 Udemy에서 Maximillian Schwarzmuller의 'Flutter & Dart — The Complete Guide [2024 Edition]' 강의를 수강하는 것을 제안합니다. 이 강좌는 Flutter를 사용하여 멋진 앱을 만드는 방법을 가르쳐줄 것입니다. 제가 좋아하는 강사 중 한 명입니다.\n\n![이미지](/assets/img/2024-06-22-The2024FlutterDeveloperRoadMap_4.png)\n\n## 3. Flutter 레이아웃 및 스타일링\n\n<div class=\"content-ad\"></div>\n\n훌륭하고 반응형 사용자 인터페이스를 만드는 방법을 이해하는 것은 모든 플러터 개발자에게 중요합니다. 유연하고 적응 가능한 레이아웃을 만들기 위해 Row, Column 및 Stack과 같은 플러터의 레이아웃 위젯에 대해 배워보세요.\n\n테마, 글꼴, 색상을 활용한 스타일링 옵션 탐색하고 위젯을 사용자 정의하는 방법 알아보세요. 플러터 위젯 구성에 익숙해지고 Flutter Inspector를 사용하여 레이아웃을 효과적으로 검사하고 디버깅해 보세요.\n\n## 4. 상태 관리\n\n플러터 애플리케이션이 복잡해짐에 따라 상태 관리는 중요해집니다. setState, Provider, Riverpod, BLoC(Business Logic Component), MobX, Redux와 같은 다양한 상태 관리 접근 방법을 플러터에서 탐색해 보세요.\n\n<div class=\"content-ad\"></div>\n\n각 접근 방식의 장단점을 이해하고, 귀하의 애플리케이션 요구에 가장 적합한 것을 선택하십시오.\n\n상태 관리를 숙달함으로써 귀하의 애플리케이션이 확장 가능하고 유지보수가 용이하며 성능이 우수하게 유지될 것입니다.\n\nFlutter 애플리케이션에서 상태 관리에 대해 더 배우고 싶다면, Udemy의 Angela Yu가 제공하는 The Complete Flutter Development Bootcamp with Dart 코스도 확인해보세요. 이 코스도 Flutter 개발자들에게 좋은 자원이 될 것입니다.\n\n![이미지](/assets/img/2024-06-22-The2024FlutterDeveloperRoadMap_5.png)\n\n<div class=\"content-ad\"></div>\n\n## 5. 플러터 패키지와 라이브러리\n\n플러터는 기능을 확장하는 다양한 패키지와 라이브러리가 있는 활기찬 생태계를 갖고 있습니다.\n\nAPI 요청을 만들기 위한 http와 데이터를 로컬에 저장하기 위한 shared_preferences, Firebase 서비스를 통합하기 위한 firebase_core 등 인기 있는 패키지들을 알아보세요.\n\n플러터 커뮤니티를 주기적으로 확인하여 새로운 패키지를 발견하고 앱 개발 프로세스를 향상시키는 데 활용하세요.\n\n<div class=\"content-ad\"></div>\n\n## 6. Flutter 네비게이션 및 라우팅\n\n플러터 애플리케이션 내에서의 네비게이션 구축은 사용자 경험을 원할하게 만드는 데 필수적입니다.\n\n플러터의 네비게이션 및 라우팅 시스템에 대해 알아보세요. 화면 간 데이터 전달, 네비게이션 드로어 및 하단 네비게이션 바 구현 방법을 포함합니다.\n\n중첩된 네비게이션 및 딥링킹에 대한 라우팅 처리 방법을 이해하고, 앱의 가용성을 향상시키기 위해 필요한 자원이 있다면 Udemy의 플러터 중급 강의인 'Complete Flutter Guide 2024: Build Android, iOS and Web apps'을 추천합니다.여러분께 좋은 자원이 될 것입니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-22-The2024FlutterDeveloperRoadMap_6.png)\n\n## 7. 플러터 애니메이션과 제스처\n\n애니메이션은 플러터 애플리케이션에 생명을 불어넣고 즐거운 사용자 경험을 제공합니다.\n\n플러터의 애니메이션 프레임워크를 탐험하고 암시적 애니메이션, 명시적 애니메이션, 그리고 히어로 애니메이션에 대해 알아보세요.\n\n\n<div class=\"content-ad\"></div>\n\n앱에 상호 작용성을 추가하는 방법을 이해하세요. 탭, 스와이프, 길게 누름과 같은 제스처 작업 방법을 익히세요.\n\nFlutter 애니메이션과 제스처를 마스터하면 애플리케이션이 시각적으로 매력적이고 매력적으로 보일 수 있습니다.\n\n## 8. Flutter 테스팅과 디버깅\n\nFlutter 애플리케이션의 품질과 신뢰성을 보장하기 위해 테스팅과 디버깅은 필수적입니다. 앱 구성 요소의 동작을 확인하기 위해 단위 테스트와 위젯 테스트를 작성하는 방법을 배우세요.\n\n<div class=\"content-ad\"></div>\n\n플러터 인스펙터와 Dart DevTools와 같은 플러터의 디버깅 도구를 사용하여 문제를 신속하게 식별하고 해결하는 방법을 이해하세요.\n\n로컬리제이션 호스트와 레지스트리 설정에 맞는 요약을 출력하도록 스크립트를 구성하고 사용자에게 피드백을 제공하세요. \n\n## 5. 다국어 번역ि\n\n<div class=\"content-ad\"></div>\n\n플러터를 사용하면 플랫폼별 기능과 통합을 활용할 수 있어요. 플러터 플러그인을 사용하여 센서, 카메라, 위치, 그리고 저장소와 같은 기기 기능에 액세스하는 방법을 살펴보세요.\n\n네이티브 코드와 통합하며 네이티브 라이브러리를 사용하는 플랫폼 채널에 대해 배워보세요.\n\n플랫폼별 기능을 이해하면 강력하고 기능이 풍부한 애플리케이션을 만들 수 있어요.\n\n## 10. 플러터 성능 최적화\n\n<div class=\"content-ad\"></div>\n\n플러터 애플리케이션의 성능을 최적화하는 것은 원활한 사용자 경험을 제공하는 데 중요합니다.\n\n위젯 재구성을 줄이고, 레이지 로딩을 통해 성능 최적화 기술을 알아보고, 플러터의 프로파일러를 활용하여 성능 병목 현상을 식별하는 방법을 배워보세요.\n\n네트워크 요청 최적화, 이미지 캐싱 처리, 앱 시작 시간 개선 방법을 이해하세요.\n\n플러터 성능 최적화를 마스터하면 애플리케이션이 빠르고 효율적일 것입니다. 자료가 필요하다면 Flutter Bootcamp: Zero to Mastery에 좋은 강의가 몇 개 있습니다. 플러터 프레임워크에 대해 더 잘 이해하기 위해 이 강의를 추천합니다.\n\n<div class=\"content-ad\"></div>\n\n그런데 이 강좌를 시청하려면 약 $39가 드는 ZTM 멤버십이 필요하며, 이를 통해 이와 같은 매우 유익하고 매력적인 다른 강좌에도 액세스할 수 있습니다. 또한 FRIENDS10 쿠폰 코드를 사용하여 이 강좌나 선택한 구독에 10% 할인을 받을 수도 있어요.\n\n## 11. 지속적인 학습과 커뮤니티 참여\n\nFlutter 개발 분야의 최전선에 머무르려면 계속된 학습과 커뮤니티 참여가 중요합니다.\n\n최신 Flutter 릴리스를 업데이트하고, Flutter 블로그를 읽고, Flutter 컨퍼런스와 웨비나를 시청하며, 포럼과 온라인 커뮤니티에 참여하여 최신 정보를 받아보세요.\n\n<div class=\"content-ad\"></div>\n\n친구들과 함께 Flutter 개발자들과 소통하고 지식을 나누며 오픈 소스 프로젝트에 기여하세요.\n\n성장 마인드셋을 om하고 Flutter 커뮤니티에 적극적으로 참여하면 여러분의 기술을 향상시키고 전문 네트워크를 확대할 수 있습니다.\n\n## 12. Flutter 국제화 및 로컬라이제이션\n\nFlutter 애플리케이션이 글로벌 관중을 대상으로하기 때문에 국제화 및 로컬라이제이션 구현이 중요합니다.\n\n<div class=\"content-ad\"></div>\n\n사용자의 로캘에 따라 앱 콘텐츠를 지원하고 다국어를 학습하세요.\n\n번역 된 텍스트, 날짜 및 시간 형식, 숫자 형식을 제공하기 위한 Flutter의 국제화 패키지 및 기술을 탐색하세요.\n\n세계적으로 사용자에게 앱을 제공함으로써 그 영향력과 사용 범위를 확대할 수 있습니다.\n\n## 13. Flutter Firebase 통합\n\n<div class=\"content-ad\"></div>\n\nFirebase는 Google의 모바일 및 웹 개발 플랫폼으로, 플러터 애플리케이션을 향상시킬 수 있는 다양한 서비스를 제공합니다.\n\nFirebase 인증을 통한 사용자 인증, Firestore 또는 리얼타임 데이터베이스를 통한 데이터 저장, 푸시 알림을 위한 클라우드 메시징, 그리고 사용자 행동을 추적하는 분석을 위한 Firebase의 통합 방법을 배워보세요.\n\nFirebase 서비스를 통합하는 방법을 이해하면 견고하고 확장 가능한 플러터 애플리케이션을 쉽게 개발할 수 있습니다.\n\n리소스가 필요하다면, Udemy의 'Flutter & Firebase Tutorial: Build 5 Social Media Apps' 강좌를 통해 프로젝트를 구축하면서 플러터와 Firebase를 배울 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n\n![Flutter Web Development](/assets/img/2024-06-22-The2024FlutterDeveloperRoadMap_8.png)\n\n## 14. Flutter Web Development\n\nFlutter’s versatility extends beyond mobile app development — it also allows you to build web applications.\n\nExplore Flutter’s web development capabilities and learn how to adapt your existing Flutter codebase for the web.\n\n\n<div class=\"content-ad\"></div>\n\n웹 특화 위젯, 라우팅, 반응형 레이아웃, 그리고 브라우저 API와의 상호작용을 이해해 보세요. Flutter의 통합 코드베이스를 통해 앱을 웹 플랫폼으로 확장할 수 있습니다.\n\n## 15. Flutter 데스크톱 개발\n\nFlutter를 사용하면 Windows, macOS 및 Linux용 데스크톱 애플리케이션도 개발할 수 있습니다.\n\nFlutter의 데스크톱 지원에 익숙해지고 네이티브와 유사한 데스크톱 경험을 만드는 방법을 배워보세요.\n\n<div class=\"content-ad\"></div>\n\n다양한 데스크톱 운영 체제에 대한 플랫폼별 기능, 패키지 및 배포 방식을 이해하세요.\n\n플러터의 데스크톱 개발 기능을 통해 여러 플랫폼을 타깃팅해서 더 많은 사용자에게 도달할 수 있어요.\n\n프로젝트가 필요하다면, Uber 클론을 만들어보는 것을 추천해요. 'Build Uber Clone with Admin WEB Panel | Flutter & Firebase' 강의를 참고할 수 있어요.\n\n![이미지](/assets/img/2024-06-22-The2024FlutterDeveloperRoadMap_9.png)\n\n<div class=\"content-ad\"></div>\n\n## 16. 플러터 UI/UX 디자인 원칙\n\n시각적으로 매력적이고 사용자 친화적인 인터페이스를 만드는 것은 플러터 애플리케이션의 성공에 중요합니다.\n\n색 이론, 타이포그래피, 레이아웃 구성, 그리고 접근성 가이드 등 기본 UI/UX 디자인 원칙을 배워보세요.\n\n플러터의 미리 제공된 위젯과 사용자 지정 스타일링을 활용하여 일관되고 직관적인 사용자 인터페이스를 설계하는 방법을 이해하세요.\n\n<div class=\"content-ad\"></div>\n\nUI/UX 디자인 원칙을 습득함으로써 사용자에게 즐거운 경험을 제공할 수 있어요. 리소스가 필요하시면, Udemy에서 제공하는 Flutter Advanced Course — Clean Architecture With MVVM 고급 코스에 참여하여 플러터 스킬을 더욱 향상시킬 것을 제안해요.\n\n![이미지](/assets/img/2024-06-22-The2024FlutterDeveloperRoadMap_10.png)\n\n## 17. 오픈소스 기여 및 사이드 프로젝트\n\n플러터 스킬을 향상시키고 플러터 커뮤니티에서 인정받기 위해 오픈소스 프로젝트에 기여하거나 사이드 프로젝트에 참여하는 것을 고려해보세요.\n\n<div class=\"content-ad\"></div>\n\n인기있는 Flutter 라이브러리 및 프레임워크에 버그 수정, 새로운 기능 또는 문서 작업에 기여하세요.\n\n또는 창의성과 문제 해결 능력을 보여줄 수 있는 자체 Flutter 프로젝트를 개발해보세요.\n\n오픈 소스 및 개인 프로젝트에 참여함으로써 Flutter 포트폴리오를 강화하고 개발자로서 돋보이게 될 수 있습니다.\n\n## 18. Flutter 지속적 통합 및 배포 (CI/CD)\n\n<div class=\"content-ad\"></div>\n\nFlutter 애플리케이션에 대한 CI/CD 파이프라인을 구현하면 효율적이고 안정적인 코드 통합 및 배포 프로세스를 보장할 수 있어요.\n\nCodemagic, Bitrise, 또는 GitHub Actions와 같은 CI/CD 도구를 알아보고, Flutter 애플리케이션의 빌드, 테스트, 그리고 배포와 같은 작업을 자동화하세요.\n\nCI/CD 실천 방법은 개발 워크플로우를 최적화하고 Flutter 앱의 전반적인 품질과 안정성을 향상시킵니다.\n\n만약 CI/CD를 배우기 위한 리소스가 필요하다면 DevOps, CI/CD(지속적 통합/전달) 초보자를 위한 코스에서 시작할 수 있어요. 이 코스는 CI/CD뿐만 아니라 현대 소프트웨어 개발에 필요한 많은 데브옵스 개념을 개요로 학습할 수 있는 좋은 코스에요.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-22-The2024FlutterDeveloperRoadMap_11.png\" />\n\n## 19. 플러터 커뮤니티 행사 및 컨퍼런스\n\n로컬 밋업, 컨퍼런스 및 해커톤에 참석하여 플러터 커뮤니티와 연결되어 있습니다.\n\n이러한 행사들은 산업 전문가로부터 배우는 기회를 제공하며, 동료 개발자들과 네트워킹하고, 최신 트렌드와 모범 사례에 대한 통찰력을 얻을 수 있는 기회를 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n플러터 커뮤니티 이벤트는 협업, 지식 공유, 그리고 개인 성장을 촉진하여, 플러터 개발자에게 귀중한 자원이 됩니다.\n\n## 결론\n\n플러터 개발자 로드맵은 플러터를 숙달하고 크로스 플랫폼 애플리케이션을 개발하기 위한 포괄적인 프레임워크를 제공합니다. 이 로드맵을 따르고 국제화, Firebase 통합, 웹 및 데스크톱 개발, UI/UX 디자인 원칙, 오픈 소스 기여, CI/CD, 커뮤니티 이벤트, 그리고 지속적인 학습과 같은 주제를 탐험함으로써, 능숙하고 성공적인 플러터 개발자가 될 수 있습니다.\n\n실습하고 실험을 하며, 플러터 커뮤니티의 지원을 받아들이는 것을 기억해 주세요. 플러터의 강력함과 유연성을 활용하여, 다양한 플랫폼 사용자에게 오랜 시간 동안 기억에 남는 영향을 남기는 멋진 고성능 애플리케이션을 만들 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n다른 프로그래밍 및 개발 로드맵을 확인해 보세요.\n\n- 2024 데이터 분석가 로드맵\n- 플러터 개발자 로드맵\n- 2024 러스트 개발자 로드맵\n- 사이버 보안 엔지니어 로드맵\n- 2024 딥 러닝 로드맵\n- 안드로이드 개발자 로드맵\n- PHP 개발자 로드맵\n- 자바 개발자 로드맵\n- 2024 고랭 개발자 로드맵\n- 2024 블록체인 개발자 로드맵\n- 웹 개발자 로드맵\n- 자바 프로그래머가 배워야 할 25가지 기술\n- 머신러닝 개발자 로드맵\n- 2024 데이터 엔지니어링 로드맵\n- 데이터 과학을 배우기 위한 5가지 최고의 웹사이트\n- 2024 라라벨 개발자 로드맵\n- 2024 데브옵스 엔지니어 로드맵\n- 앵귤러 개발자 로드맵\n- 2024 리액트 개발자 로드맵\n- 앱 개발자가 배워야 할 10가지\n\n이 기사를 읽어 주셔서 감사합니다. 만약 이 플러터 개발 로드맵을 좋아하신다면 단어를 퍼뜨리고 소셜 미디어에서 친구들과 공유해 주세요. 진심으로 감사합니다.\n\n추신 - 플러터와 다트를 깊게 배우고 더 많은 자료와 프로젝트가 필요하다면 이 10가지 최고의 플러터 강좌와 프로젝트도 확인해 보세요. 행운을 빕니다!","ogImage":{"url":"/assets/img/2024-06-22-The2024FlutterDeveloperRoadMap_0.png"},"coverImage":"/assets/img/2024-06-22-The2024FlutterDeveloperRoadMap_0.png","tag":["Tech"],"readingTime":11},{"title":"탭 간 통신 구현하는 방법","description":"","date":"2024-06-22 05:52","slug":"2024-06-22-Howtoimplementcross-tabcommunication","content":"\n\n<img src=\"/assets/img/2024-06-22-Howtoimplementcross-tabcommunication_0.png\" />\n\n## 🌐 제 블로그에서 이 게시물을 읽어보세요\n\n웹 개발 여정 중 어느 순간, 웹 애플리케이션이 탭 간에 통신해야 하는 경우가 있을 수 있습니다. 아직 그런 적이 없다면, 왜 그럴 필요가 있는지 궁금할 수도 있겠죠.\n\n# 🗣️ 그럴 필요가 있는 이유는 무엇일까요?\n\n<div class=\"content-ad\"></div>\n\n좋아요~ 첫 번째 단락을 마무리하게 해 주셔서 감사합니다. 이제 상호 테이블 통신이 유용한 많은 상황들이 있습니다. 몇 가지 살펴보겠습니다.\n\n- 세션 관리 — 웹사이트의 여러 탭을 여는 상황을 상상해봅시다. 한 창에서 로그인하면, 다른 모든 창도 로그인해 있는 것을 기대합니다. 로그아웃도 동일하게 적용됩니다.\n- 공유 상태 — 테마, 로케일화, 또는 실시간 데이터와 같이 애플리케이션에서 탭 간에 상태를 공유해야 할 수 있습니다.\n- 메시지 브로드캐스트 — 한 탭에서 다른 탭으로 메시지를 브로드캐스트하고 싶을 때, 예를 들어 양식을 제출하거나 다른 사용자 작업 등\n\n여기까지 보셔서 정말 편리하다는 걸 느끼지 않으셨나요? 이제...어떻게 구현할 수 있는지 궁금하시죠? \n\n# 🗣️ 어떻게 구현할 수 있을까요?\n\n<div class=\"content-ad\"></div>\n\n헉, 두 번째로 방해하네요. 괜찮아요... 간단한 예제를 통해 어떻게 구현하는지 몇 가지 일반적인 방법을 선택해볼게요\n\n- 로컬 스토리지\n- 브로드캐스트 채널\n- 공유 워커\n\n위 세 가지 방법 모두 동일 출처 정책을 따르며, 즉 우리 애플리케이션이 동일한 출처를 가졌을 때만 작동하는 것을 의미해요\n\n## 로컬 스토리지\n\n<div class=\"content-ad\"></div>\n\n가장 간단하고 인기 있는 방법일 수 있어요.\n\n```js\n// 발신자\nsender.setItem('channel', 'some message');\n\n// 수신자\nwindow.addEventListener('storage', (event) => {\n  if (event.key === 'channel') {\n    // 메시지는 event.newValue에 들어 있어요\n  }\n});\n```\n\n정말 간단하죠! 수신 창에만 저장 이벤트 리스너를 추가하면 돼요. 그럼 로컬스토리지의 데이터가 변경되면 핸들러가 호출돼요.\n\n## 브로드캐스트 채널\n\n<div class=\"content-ad\"></div>\n\nBroadcast Channel을 사용한 방법은 매우 간단합니다.\n\n```js\nconst broadcastChannel = new BroadcastChannel('channel');\n\n// 발신자\nbroadcastChannel.postMessage('일부 메시지');\n\n// 수신자\nbroadcastChannel.onmessage = (event) => {\n  // 메시지는 event.data에 있습니다.\n};\n```\n\n먼저, BroadcastChannel의 새 인스턴스를 생성하고 채널 이름을 인수로 전달해야 합니다.\n\n이후에는 저가 언급한 대로 간단합니다. 제가 설명을 하지 않아도 예시 코드가 자체적으로 설명할 수 있습니다. 😆 장난이죠! 우리는 단순히 postMessage를 사용하여 메시지를 보내고, 수신자는 onmessage 이벤트 리스너를 생성하면 됩니다.\n\n<div class=\"content-ad\"></div>\n\n## 공유 워커\n\n마지막으로, 세 가지 방법 중에서 가장 복잡한 것이에요. 제가 가능한 한 간단하게 설명해 드릴게요.\n\n아마 이미 알고 있겠지만, 웹 애플리케이션은 하나의 스레드에서 실행된다는 것을 의미합니다. 이는 일부 실행이 UI를 렌더링하는 데 차단할 수 있다는 것을 의미합니다. 웹 워커는 이러한 문제를 해결하는 데 도움이 됩니다!\n\n우리는 공유 워커가 웹 애플리케이션 간의 중계 역할을 한다고 말할 수 있으며, 탭 간의 메시지 전달에 적합하다고 할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst sharedWorker = new SharedWorker('./worker.js');\n\n// sender\nsharedWorker.port.postMessage('메시지 전송');\n\n// receiver\nsharedWorker.port.onmessage = (event) => {\n  // 수신된 메시지는 event.data에 있습니다\n};\n```\n\n위의 코드 예제를 보면 Broadcast Channel의 구현과 매우 유사하다는 것을 알 수 있어요. 그러나 worker.js라는 파일 뒤에 비밀스러운 마법이 숨어있어요.\n\n```js\n// worker.js\nlet ports = [];\n\nonconnect = function(e) {\n  const currentPort = e.ports[0];\n\n  ports.push(currentPort);\n\n  currentPort.onmessage = function(event) {\n    const message = event.data;\n\n    ports.forEach(port => {\n      if (currentPort !== port) {\n        port.postMessage(message);\n      }\n    });\n  };\n};\n```\n\n여기서 마법처럼 동작하는 로직이 수행되어요. onconnect 핸들러는 동일한 출처의 스크립트 중 어떤 것이든 worker.js를 Shared Worker로 로드할 때마다 호출될 거에요.\n\n<div class=\"content-ad\"></div>\n\n우리는 각 탭에서 전달된 MessagePort가 담긴 MessagePort 배열을 정의했어. 발신자가 postMessage를 호출할 때마다 Shared Worker가 다른 탭의 다른 MessagePort로 메시지를 브로드캐스트할 거야.\n\n그리고 이렇게 우리가 탭 간 통신을 하는 세 가지 방법을 설명했지. 그런데 어떤 걸 사용해야 할까...\n\n# 🗣️ 그럼 어떤 걸 선택해야 할까?\n\n😑 ← 이게 지금 내 표정... 그건 우리가 구현하는 기능에 따라 다르다는 걸로...\n\n<div class=\"content-ad\"></div>\n\n- 상태를 공유하고 싶다면 → Local Storage\n- 메시지를 브로드캐스트하려면 → Broadcast Channel\n- 응용 프로그램이 많은 처리를 필요로 한다면 → Shared Worker\n\n그러나 올바른 선택을 결정하기 전에 다른 조건들을 고려해야 합니다.\n\n# 데모\n\n간단한 데모를 만들어서 사용해 볼 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n데모 사이트\n소스 코드\n\n여기까지 입니다! 더 많은 블로그를 punn.dev에서 확인해보세요!\n\n다음 포스트에서 만나요! 👋🏼","ogImage":{"url":"/assets/img/2024-06-22-Howtoimplementcross-tabcommunication_0.png"},"coverImage":"/assets/img/2024-06-22-Howtoimplementcross-tabcommunication_0.png","tag":["Tech"],"readingTime":4}],"page":"5","totalPageCount":28,"totalPageGroupCount":2,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}