{"pageProps":{"posts":[{"title":"Flutter로 코드 생성하기  source_gen과 build_runner 사용 방법","description":"","date":"2024-06-21 22:30","slug":"2024-06-21-CodeGenerationusingFluttersource_genbuild_runner","content":"\n![2024-06-21-CodeGenerationusingFluttersource_genbuild_runner_0.png](/assets/img/2024-06-21-CodeGenerationusingFluttersource_genbuild_runner_0.png)\n\n최근에는 전문적인 플러터 개발자로서 매일 개발 프로세스 중에 시간이 오래 걸리고 실수할 가능성이 있는 일상적인 반복 작업을 더 나은 방법과 안전한 방법으로 수행하고 싶었을 것입니다. 그러한 프로세스는 코드 생성입니다. 진보를 이루는 데 핵심은 효율성을 극대화하는 데 있습니다. 반복적인 작업은 지루하고 단조로운 성질 때문에 보편적으로 싫어하는데, 이러한 활동에서 사람들은 주목할 만큼 비효율적이며 종종 오류를 범합니다.\n\n코드 생성은 특정 입력 데이터나 규칙을 기반으로 자동으로 코드를 생성하는 기술입니다. Flutter에서 코드 생성은 JSON 데이터, 데이터베이스 및 웹 서비스와 같은 다양한 목적으로 사용됩니다. 코드 생성은 반복적인 작업을 자동화하고 필요한 수동 코딩량을 줄임으로써 코드 작성과 유지를 쉽게 할 수 있습니다.\n\n코드 생성기를 사용하는 많은 패키지들이 있습니다. json_serializable과 같은 패키지의 예시를 살펴보겠습니다. 이 패키지는 우리에게 fromJson, toJson과 같은 메서드를 생성하는 데 사용되는 일련의 주석을 제공하여, 해당 함수를 생성하려는 행에 주석을 넣기만 하면 이러한 메서드를 자동으로 생성합니다.\n\n<div class=\"content-ad\"></div>\n\n예시:\n\n| First Header | Second Header |\n| ------------ | ------------- |\n| Content Cell | Content Cell  |\n| Content Cell | Content Cell  |\n\n<div class=\"content-ad\"></div>\n\n이 글에서는 사용자 정의 주석 및 생성기를 생성하여 주석이 달린 클래스에 대해 fromJson, toJson 및 copyWith 메서드를 생성하는 방법을 배우겠습니다.\n\n우리가 자체 코드 생성기를 만들기 위해 필요한 패키지는 무엇인가요?\n\n- source_gen | Dart 패키지 (pub.dev)\n- build_runner | Dart 패키지 (pub.dev)\n\n## source_gen\n\n<div class=\"content-ad\"></div>\n\nAPI는 낮은 수준의 빌드 또는 분석기 패키지와 상호 작용 없이 코드를 생성하는 데 도움이 되는 다양한 유틸리티를 제공합니다. 이는 여러분의 삶을 훨씬 쉽게 만들어 줄 것입니다.\n\nsource_gen 패키지는 build 패키지의 확장판입니다. Dart 소스 코드 생성을 더 쉽게 만드는 일련의 유틸리티가 포함되어 있습니다.\n\n## build_runner\n\n이 패키지를 사용하면 생성기를 실행할 수 있습니다. 이는 개발 단계에서만 사용되는 dev_dependency 영역에 있을 것이므로 개발 단계에서만 사용할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n우리는 다음 명령어를 실행하여 코드를 생성할 수 있어요:\n\n```js\ndart run build_runner `command`\n```\n\n사용할 수 있는 명령어는 다음과 같아요:\n\n- build: 하나의 빌드를 실행하고 종료합니다.\n- watch: 파일 시스템을 감시하는 지속적인 빌드 서버를 실행하며 필요 시 다시 빌드합니다.\n- serve: watch와 동일하지만 개발 서버도 실행합니다.\n\n<div class=\"content-ad\"></div>\n\n# 예시\n\nGitHub에서 스타터 프로젝트를 다운로드하거나 수동으로 생성할 수 있습니다.\n\n스타터 프로젝트에는 세 개의 프로젝트가 포함되어 있습니다:\n\n- 예시: 이는 플러터 애플리케이션입니다. 이 애플리케이션은 생성기 코드를 테스트하는 데 사용됩니다.\n- 어노테이션: 이는 플러터 패키지입니다. 이는 어노테이션을 포함하고 있으며, 생성기는 이를 사용하여 처리할 클래스를 인식합니다.\n- 생성기: 이는 플러터 패키지입니다. 이 패키지에는 우리의 어노테이션에 의해 주석 처리된 코드를 방문하고 이를 위해 코드를 생성하는 코드 생성기가 포함되어 있습니다.\n\n<div class=\"content-ad\"></div>\n\n시작해보세요. Custom Gen이라는 디렉토리를 만들고 터미널에서 열어서 다음을 입력하세요:\n\ncode .\n\n그럼 VS Code가 열릴 거에요.\n\n## 예제 프로젝트\n\n<div class=\"content-ad\"></div>\n\nCtrl + Shift + p를 눌러 Flutter: New Project를 선택한 다음 Application을 선택하고 example로 이름을 지어주세요.\n\n## annotations 프로젝트\n\n터미널에서 Custom Gen 폴더를 열기 위해 이전과 같은 단계를 따라주세요.\n\nCtrl + Shift + p를 눌러 Flutter: New Project를 선택한 다음 Package를 선택하고 annotation으로 이름을 지어주세요.\n\n<div class=\"content-ad\"></div>\n\n## generators 프로젝트\n\n터미널에서 이미지와 같이 'Custom Gen' 폴더를 열기 위해 이전과 같은 단계를 수행합니다.\n\nCtr + Shift + p를 눌러 Flutter: New Project를 선택하고 Package를 선택한 후 generator라고 이름을 지정하세요.\n\n이제 이미지와 같이 세 개의 프로젝트가 생성됩니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-21-CodeGenerationusingFluttersource_genbuild_runner_1.png\" />\n\n# 주석 프로젝트\n\n주석이 무엇인가요?\n\nFlutter에서 주석은 Dart 코드에 포함하여 도구나 라이브러리에 추가 정보를 전달하는 특별한 표식이거나 지시문입니다. 주석은 build_runner 및 코드 생성기와 같은 도구에 대한 힌트로 작용하여 주석이 달린 코드와 관련된 특정 작업이나 동작을 나타냅니다.\n\n<div class=\"content-ad\"></div>\n\nannotations/lib에 src 폴더를 만들어서 생성자에 의해 사용될 주석 파일을 포함시킬 것입니다.\n\nannotations/lib/annotations.dart와 annotations/test/annotations_test.dart의 예제 코드를 제거할 것입니다.\n\nsrc 폴더에 acustom_annotation.dart 파일을 생성하여 주석을 작성할 것입니다. 이 주석은 CustomAnnotation으로 명명되었습니다.\n\n```js\n// 우리의 주석\nclass CustomAnnotation {\n  const CustomAnnotation();\n}\n\n// 이 변수는 코드를 생성하기 위한 주석으로 사용될 것입니다.\nconst customAnnotation = CustomAnnotation();\n```\n\n<div class=\"content-ad\"></div>\n\nannotations.dart 파일에서 CustomAnnotation을 export할 것입니다:\n\n```js\nlibrary annotations;\n\nexport 'src/custom_annotation.dart';\n```\n\n다른 곳에서 이 주석 라이브러리를 사용하려면 각 파일을 개별적으로 호출하는 대신 annotations.dart를 import하기만 하면 됩니다.\n\n좋아요! 이제 당신은 당신의 어노테이션을 만들었습니다. 축하해요. 🎉🎉\n\n<div class=\"content-ad\"></div>\n\n# 제너레이터 프로젝트\n\n먼저 generators/generators.dart 파일과 generators/test/generators_test.dart 파일의 초기 코드를 제거하세요.\n\n그런 다음 generators/pubspec.yaml 파일에 몇 가지 종속성을 추가해야 합니다:\n\n```js\ndependencies:\n  flutter:\n    sdk: flutter\n\n  build:\n  source_gen:\n\n  # Our annotation\n  annotations:\n    path: ../annotations/\n\ndev_dependencies:\n  flutter_test:\n    sdk: flutter\n\n  build_runner:\n  flutter_lints: ^2.0.0\n```\n\n<div class=\"content-ad\"></div>\n\n태그를 Markdown 형식으로 변경하고 다음 명령을 실행하세요: flutter pub get.\n\n- build: 이 패키지는 변수, 메소드 및 생성자와 같은 다양한 클래스 구성요소에 액세스하여 클래스를 검사하는 것을 가능하게 합니다.\n- source_gen: analyzer 또는 build와 같은 하위 수준 패키지 위에 있는 API입니다. source_gen을 사용하여 소스 코드를 생성할 필요는 없습니다. 또한 제너레이터에 유용할 수 있는 일련의 라이브러리 API를 노출합니다.\n- annotations: 이전에 작성된 annotation입니다.\n- build_runner: 주석이 달린 클래스에서 코드를 생성합니다.\n\nflutter pub get을 실행하는 중에 이와 같은 오류가 발생할 수 있습니다:\n\nPublishable packages can’t have ‘path’ dependencies.\nTry adding a publish_to: none entry to mark the package as not for publishing or remove the path dependency.\n\n<div class=\"content-ad\"></div>\n\n이 작업은 필요합니다. 왜냐하면 패키지를 Dart Dev에 업로드할 계획이라면 경로가 올바르지 않을 수 있습니다. 따라서 pubspec.yaml에서 이 예제가 실제 업로드된 패키지가 아닌 것을 명시해야 합니다. 다음 코드를 pubspec.yaml에 추가해주세요:\n\n```js\nname: generator\ndescription: A new Flutter package project.\nversion: 0.0.1\nhomepage:\npublish_to: none # <- 이 코드를 추가하여 이 패키지가 Dart Dev에 게시되지 않도록 설정\n```\n\n## build.yaml 구성하기\n\nbuild.yaml 파일은 build_runner에 의해 수행되는 코드 생성 프로세스의 설정과 구성을 지정하는 구성 파일입니다. 이 파일은 build_runner에 의해 호출되어 모든 생성기 구성을 읽기 전에 기능을 설정하며 Dart 빌드 시스템의 일부이며 Flutter 프로젝트에서 코드 생성 라이브러리를 사용할 때 생성기를 구성하는 용도로 사용됩니다. 생성된 파일의 확장자, 생성된 메서드, 생성기의 경로와 같은 설정을 지정하는 중요한 파일입니다.\n\n<div class=\"content-ad\"></div>\n\n지금, 제너레이터 패키지 루트에 build.yaml 파일을 만들어서 다음 코드를 입력해주세요:\n\n```js\ntargets:\n  $default:\n    builders:\n      generators|annotations: # generators|annotations: 주석이 달린 파일을 다룰 때 simple_generator 빌더를 사용한다는 것을 의미합니다.\n        enabled: true\n\nbuilders:\n  generators:\n    target: \":generators\" # 제너레이터 이름\n    import: \"package:generators/generators.dart\"\n    builder_factories: [\"generateJsonMethods\"] # 빌더 이름(BuilderOption)의 정의입니다.\n    build_extensions: { \".dart\": [\".g.dart\"] }\n    auto_apply: dependents\n    build_to: cache\n    applies_builders: [\"source_gen|combining_builder\"]\n```\n\n1- import: 제너레이터 경로를 결정합니다.\n\n2- builder_factories: 빌더 메서드의 이름을 나열합니다. 이 경우, \"generateJsonMethods\"라는 단일 팩토리를 포함하며 빌더를 반환합니다.\n\n<div class=\"content-ad\"></div>\n\n3- build_extensions: 빌더의 입력 및 출력 파일 확장자를 정의합니다. 이는 빌더가 .dart 파일을 처리하고 .g.part '(.g.part) 파일을 생성함을 나타냅니다. 이는 build.yaml 파일의 auto_apply 키에 기반하여 파일의 가시성을 제어합니다.\n\n4- auto_apply: 특정 빌더가 빌드 프로세스 중 자동으로 적용되어야 하는 시점을 지정하는 데 사용됩니다.\n\nauto_apply 옵션에는 여러 가지 가능한 값이 있습니다:\n\n- none: 빌더가 자동으로 적용되지 않습니다. 빌더를 명시적으로 builders 섹션에 지정하거나 build_runner 명령을 --build-filter 옵션과 함께 사용해야 합니다.\n- dependents: 빌더가 build.yaml 파일을 포함하는 패키지에 의존하는 패키지에 자동으로 적용됩니다. 이는 다른 패키지가 귀하의 패키지에 의존하는 경우 해당 빌더가 해당 의존 패키지에도 적용됨을 의미합니다.\n- all_packages: 의존성 여부에 관계없이 모든 패키지에 빌더가 자동으로 적용됩니다. 이 옵션은 드물며, 모든 패키지에 빌더가 필요하지 않은 경우 빌드 시간이 증가할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n5- build_to: 코드 생성에서 생성된 파일이 배치되어야 하는 디렉토리를 지정합니다.\n\n다음은 build_to에 대한 일반적인 값들입니다:\n\n- source: 이는 생성된 파일이 소스 파일과 동일한 디렉토리에 배치됨을 의미합니다. 소스 파일이 lib/src에 있으면 생성된 파일도 lib/src에 배치됩니다.\n- cache: 이는 생성된 파일이 빌드 캐시 디렉토리에 배치됨을 의미합니다. 빌드 캐시는 빌드 성능을 향상시키기 위해 build_runner가 관리하는 디렉토리입니다.\n\n# 생성기 생성\n\n<div class=\"content-ad\"></div>\n\n이제 build.yaml 파일을 구성한 후, 코드 생성을 위한 모든 파일 및 구현체를 생성할 것입니다.\n\n이 단계에서는 방문자(visitor) 클래스를 만들 것입니다; 이는 생성된 코드를 위해 생성자, 필드, 함수 등 모든 클래스 요소에 액세스하는 데 도움을 줍니다.\n\n## 모델 방문자\n\nlib/src 에 model_visitor.dart 파일을 만든 후, 다음 import 문을 사용할 것입니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport \"package:analyzer/dart/element/element.dart\";\nimport \"package:analyzer/dart/element/visitor.dart\";\n```\n\nThe first import comes from analyzer because both source_gen and build export it.\n\nCreate a ModelVisitor class and extend from SimpleElementVisitor:\n\n```js\nclass ModelVisitor extends SimpleElementVisitor<void> {}\n```\n\n<div class=\"content-ad\"></div>\n\nSimpleElementVisitor에는 클래스를 검사하는 데 도움이 되는 여러 메서드가 포함되어 있습니다:\n\n- visitFieldElement 메서드.\n- visitConstructorElement 메서드.\n- visitFunctionElement 메서드.\n\nSimpleElementVisitor 클래스로 이동하여 클래스를 검사하는 데 유용한 모든 메서드를 살펴볼 수 있지만, 우리의 경우 visitConstructorElement 메서드를 사용하여 클래스 이름을 가져오고 visitFunctionElement 메서드를 사용하여 클래스의 모든 필드를 가져올 것입니다.\n\nmodel_visitor.dart 파일의 전체 코드:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport 'package:analyzer/dart/element/element.dart';\nimport 'package:analyzer/dart/element/visitor.dart';\n\n// 단계 1\nclass ModelVisitor extends SimpleElementVisitor<void> {\n// 단계 2\n  String className = '';\n  Map<String, dynamic> fields = {};\n\n// 단계 3\n  @override\n  void visitConstructorElement(ConstructorElement element) {\n    final String returnType = element.returnType.toString();\n// 단계 4\n    className = returnType.replaceAll(\"*\", \"\"); // ClassName* -> ClassName\n  }\n\n// 단계 5\n  @override\n  void visitFieldElement(FieldElement element) {\n    /*\n    {\n      name: String,\n      price: double\n    }\n     */\n\n// 단계 6\n    String elementType = element.type.toString().replaceAll(\"*\", \"\");\n    fields[element.name] = elementType;\n\n  }\n}\n```\n\n단계 1: SimpleElementVisitor 클래스를 상속받은 ModelVisitor 클래스로 확장함으로써 클래스 필드, 생성자 및 함수에 대한 다양한 유용한 메서드에 액세스할 수 있습니다.\n\n단계 2: className 변수를 정의하여 클래스 이름을 저장하고, fields 변수를 정의하여 모든 클래스 필드를 저장합니다.\n\n단계 3: 이 오버라이드된 메서드는 클래스 생성자를 방문하고 element.returnType을 통해 클래스 이름을 검색할 수 있도록 합니다.\n\n<div class=\"content-ad\"></div>\n\n단계 4: element.returnType은 원소 유형 뒤에 '\\*'을 반환하므로 이를 제거합니다.\n\n단계 5: 이 방법은 클래스의 각 필드에 대해 호출되며, 필드 이름과 필드 유형에 모두 액세스할 수 있습니다.\n\n또한 더 많은 속성에 액세스할 수 있습니다.\n\n단계 6: element.type은 원소 유형 뒤에 '\\*'을 반환하므로 이를 제거합니다.\n\n<div class=\"content-ad\"></div>\n\n## 생성기\n\nlib/src에 json_generator.dart라는 파일을 생성하세요:\n\n```js\nimport \"package:annotations/annotations.dart\";\nimport \"package:source_gen/source_gen.dart\";\n\nclass JsonGenerator extends GeneratorForAnnotation<CustomAnnotation> {\n  // 이곳에 코드를 생성하는 메서드를 작성하세요!\n}\n```\n\n이 파일은 생성기의 진입점을 나타냅니다. dart run build_runner build 명령을 실행한 후, build_runner은 먼저 build.yaml 파일을 확인합니다. 이후 예제 파일을 모두 스캔하고, 어노테이션이 존재하면 이 클래스가 인지하고, 상기 생성기 클래스의 재정의된 기능을 실행하도록 합니다.\n\n<div class=\"content-ad\"></div>\n\ngenerateForAnnotatedElement을 오버라이드할 거에요. 이 메서드는 element를 인자로 받아요. 이 경우에는 클래스가 될 거예요. 이 간단한 예시에서는 다른 매개변수가 필요하지 않아요. 이 메서드는 생성된 코드를 나타내는 String 타입을 반환할 거에요.\n\n```js\nclass JsonGenerator extends GeneratorForAnnotation<CustomAnnotation> {\n  @override\n  String generateForAnnotatedElement(\n    Element element, // 이 경우에는 클래스를 나타냅니다.\n    ConstantReader annotation,\n    BuildStep buildStep,\n  ) {\n  }\n}\n```\n\n이 클래스가 생성기의 진입점이므로 ModelVisitor 클래스를 활용하여 주석이 달린 클래스의 모든 필드와 생성자를 가져올 거에요.\n\n```js\nclass JsonGenerator extends GeneratorForAnnotation<CustomAnnotation> {\n  @override\n  String generateForAnnotatedElement(\n    Element element,\n    ConstantReader annotation,\n    BuildStep buildStep,\n  ) {\n    final ModelVisitor visitor = ModelVisitor();\n    // 클래스의 필드와 생성자를 방문한 후, visitor의 className과 fields 변수에 값이 들어갈 거에요.\n    element.visitChildren(visitor);\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n클래스 이름과 필드를 가져온 후에는, `fromJson`, `toJson`, 그리고 `copyWith` 메서드를 생성하는 코드를 작성해봅시다.\n\n## fromJson 메서드\n\n- 생성된 메서드 예시:\n\n```js\n// From Json Method\nProduct _$ProductFromJson(Map<String, dynamic> json) => Product(\n      name: json['name'],\n      price: json['price'],\n    );\n```\n\n<div class=\"content-ad\"></div>\n\n- 위 예시를 생성하는 함수:\n\n```js\n// fromJSon 메소드를 생성하는 메서드\nString generateFromJsonMethod(ModelVisitor visitor) {\n  // 모델 방문자로부터 클래스 이름을 받아옴\n  String className = visitor.className;\n\n  // 생성된 클래스의 각 부분을 쓰기 위한 버퍼\n  final buffer = StringBuffer();\n\n  // --------------------fromJson 생성 코드 시작--------------------//\n  buffer.writeln('// From Json 메소드');\n  buffer.writeln(\n      '$className _\\$${className}FromJson(Map<String, dynamic> json) => ');\n  buffer.write('$className(');\n\n  for (int i = 0; i < visitor.fields.length; i++) {\n    String fieldName = visitor.fields.keys.elementAt(i);\n    String mapValue = \"json['$fieldName']\";\n\n    buffer.writeln(\n      \"${visitor.fields.keys.elementAt(i)}: $mapValue,\",\n    );\n  }\n  buffer.writeln(');');\n  buffer.toString();\n  return buffer.toString();\n  // --------------------fromJson 생성 코드 종료--------------------//\n}\n```\n\n## toJson 메소드\n\n- 생성된 메소드 예시:\n\n<div class=\"content-ad\"></div>\n\n```js\n// JSON으로 변환하는 메소드\nMap<String, dynamic> _$ProductToJson(Product instance) => <String, dynamic>{\n      'name': instance.name,\n      'price': instance.price,\n    };\n```\n\n- 위 예시를 생성하는 함수:\n\n```js\n// fromJSon 메소드를 생성하는 메소드\nString generateToJsonMethod(ModelVisitor visitor) {\n  // 모델 비지터에서 클래스 이름 가져오기\n  String className = visitor.className;\n\n  // 생성된 클래스 각 부분을 작성할 버퍼\n  final buffer = StringBuffer();\n\n  // --------------------toJson 생성 코드 시작--------------------//\n  buffer.writeln('// JSON으로 변환하는 메소드');\n  buffer.writeln(\n      'Map<String, dynamic> _\\$${className}ToJson($className instance) => ');\n  buffer.write('<String, dynamic>{');\n  for (int i = 0; i < visitor.fields.length; i++) {\n    String fieldName = visitor.fields.keys.elementAt(i);\n    buffer.writeln(\n      \"'$fieldName': instance.$fieldName,\",\n    );\n  }\n  buffer.writeln('};');\n  return buffer.toString();\n  // --------------------toJson 생성 코드 끝--------------------//\n}\n```\n\n## copyWith 메소드\n\n<div class=\"content-ad\"></div>\n\n- 생성된 메서드 예시:\n\n```js\n// Product 클래스에 'copyWith' 메서드를 제공하기 위한 확장\nextension $ProductExtension on Product {\n  Product copyWith({\n    String? name,\n    double? price,\n  }) {\n    return Product(\n      name: name ?? this.name,\n      price: price ?? this.price,\n    );\n  }\n```\n\n- 위 예제를 생성하는 함수:\n\n```js\n// fromJSon 메서드를 생성하는 함수\nString generateCopyWithMethod(ModelVisitor visitor) {\n  // 모델 방문자로부터 클래스 이름 가져오기\n  String className = visitor.className;\n\n  // 생성된 클래스 각 부분을 작성할 버퍼\n  final buffer = StringBuffer();\n\n  // --------------------copyWith 생성 코드 시작--------------------//\n  buffer.writeln(\n      \"// $className 클래스에 'copyWith' 메서드를 제공하기 위한 확장\");\n  buffer.writeln('extension \\$${className}Extension on $className {');\n  buffer.writeln('$className copyWith({');\n  for (int i = 0; i < visitor.fields.length; i++) {\n    String dataType =\n        visitor.fields.values.elementAt(i).toString().replaceAll(\"?\", \"\");\n    String fieldName = visitor.fields.keys.elementAt(i);\n    buffer.writeln(\n      '$dataType? $fieldName,',\n    );\n  }\n  buffer.writeln('}) {');\n  buffer.writeln('return $className(');\n  for (int i = 0; i < visitor.fields.length; i++) {\n    buffer.writeln(\n      \"${visitor.fields.keys.elementAt(i)}: ${visitor.fields.keys.elementAt(i)} ?? this.${visitor.fields.keys.elementAt(i)},\",\n    );\n  }\n  buffer.writeln(');');\n  buffer.writeln('}');\n  buffer.writeln('}');\n  buffer.toString();\n  return buffer.toString();\n  // --------------------copyWith 생성 코드 종료--------------------//\n}\n```\n\n<div class=\"content-ad\"></div>\n\njson_generator.dart 파일의 전체 코드:\n\n```js\nimport 'package:analyzer/dart/element/element.dart';\nimport 'package:annotations/annotations.dart';\nimport 'package:build/build.dart';\nimport 'package:build/src/builder/build_step.dart';\nimport 'package:generators/src/model_visitor.dart';\nimport 'package:source_gen/source_gen.dart';\n\nclass JsonGenerator extends GeneratorForAnnotation<CustomAnnotation> {\n  @override\n  String generateForAnnotatedElement(\n    Element element,\n    ConstantReader annotation,\n    BuildStep buildStep,\n  ) {\n    final ModelVisitor visitor = ModelVisitor();\n    // 클래스 필드 및 생성자 방문\n    element.visitChildren(visitor);\n\n    // 생성된 클래스의 각 부분을 작성할 버퍼\n    final buffer = StringBuffer();\n\n    // fromJson\n    String generatedFromJSon = generateFromJsonMethod(visitor);\n    buffer.writeln(generatedFromJSon);\n\n    // toJson\n    String generatedToJSon = generateToJsonMethod(visitor);\n    buffer.writeln(generatedToJSon);\n\n    // copyWith\n    String generatedCopyWith = generateCopyWithMethod(visitor);\n    buffer.writeln(generatedCopyWith);\n\n    return buffer.toString();\n  }\n\n  // fromJSon 메서드 생성하는 메소드\n  String generateFromJsonMethod(ModelVisitor visitor) {\n    // 모델 방문자로부터 클래스 이름 가져오기\n    String className = visitor.className;\n\n    // 생성된 클래스의 각 부분을 작성할 버퍼\n    final buffer = StringBuffer();\n\n    // --------------------fromJson 생성 코드 시작--------------------//\n    buffer.writeln('// From Json Method');\n    buffer.writeln(\n        '$className _\\$${className}FromJson(Map<String, dynamic> json) => ');\n    buffer.write('$className(');\n\n    for (int i = 0; i < visitor.fields.length; i++) {\n      String fieldName = visitor.fields.keys.elementAt(i);\n      String mapValue = \"json['$fieldName']\";\n\n      buffer.writeln(\n        \"${visitor.fields.keys.elementAt(i)}: $mapValue,\",\n      );\n    }\n    buffer.writeln(');');\n    buffer.toString();\n    return buffer.toString();\n    // --------------------fromJson 생성 코드 끝--------------------//\n  }\n\n  // toJson 메서드 생성하는 메소드\n  String generateToJsonMethod(ModelVisitor visitor) {\n    // 모델 방문자로부터 클래스 이름 가져오기\n    String className = visitor.className;\n\n    // 생성된 클래스의 각 부분을 작성할 버퍼\n    final buffer = StringBuffer();\n\n    // --------------------toJson 생성 코드 시작--------------------//\n    buffer.writeln('// To Json Method');\n    buffer.writeln(\n        'Map<String, dynamic> _\\$${className}ToJson($className instance) => ');\n    buffer.write('<String, dynamic>{');\n    for (int i = 0; i < visitor.fields.length; i++) {\n      String fieldName = visitor.fields.keys.elementAt(i);\n      buffer.writeln(\n        \"'$fieldName': instance.$fieldName,\",\n      );\n    }\n    buffer.writeln('};');\n    return buffer.toString();\n    // --------------------toJson 생성 코드 끝--------------------//\n  }\n\n  // copyWith 메서드 생성하는 메소드\n  String generateCopyWithMethod(ModelVisitor visitor) {\n    // 모델 방문자로부터 클래스 이름 가져오기\n    String className = visitor.className;\n\n    // 생성된 클래스의 각 부분을 작성할 버퍼\n    final buffer = StringBuffer();\n\n    // --------------------copyWith 생성 코드 시작--------------------//\n    buffer.writeln(\n        \"// $className 클래스에 'copyWith' 메소드를 제공하는 확장\");\n    buffer.writeln('extension \\$${className}Extension on $className {');\n    buffer.writeln('$className copyWith({');\n    for (int i = 0; i < visitor.fields.length; i++) {\n      String dataType =\n          visitor.fields.values.elementAt(i).toString().replaceAll(\"?\", \"\");\n      String fieldName = visitor.fields.keys.elementAt(i);\n      buffer.writeln(\n        '$dataType? $fieldName,',\n      );\n    }\n    buffer.writeln('}) {');\n    buffer.writeln('return $className(');\n    for (int i = 0; i < visitor.fields.length; i++) {\n      buffer.writeln(\n        \"${visitor.fields.keys.elementAt(i)}: ${visitor.fields.keys.elementAt(i)} ?? this.${visitor.fields.keys.elementAt(i)},\",\n      );\n    }\n    buffer.writeln(');');\n    buffer.writeln('}');\n    buffer.writeln('}');\n    buffer.toString();\n    return buffer.toString();\n    // --------------------copyWith 생성 코드 끝--------------------//\n  }\n}\n```\n\n이미 귀하는 프로페셔널하고 훌륭한 개발자이십니다. 🎉🎉\n\n마지막 단계에서는 build.yaml 파일에서 builder_factories: [\"generateJsonMethods\"]를 볼 수 있습니다. 이는 최상위 수준 함수를 포함하고 있으며, build.yaml 파일을 확인한 후 build_runner가 호출하게 될 것이며, 그 다음에는 이전에 생성된 생성기(JsonGenerator)를 호출하게 될 것입니다.\n\n<div class=\"content-ad\"></div>\n\n위의 정의는 다음과 같이 되어야 합니다:\n\n```js\nBuilder 이름(BuilderOption)\n```\n\nlib/generators.dart 파일에서:\n\n```js\nlibrary generators;\n\nimport 'package:build/build.dart';\nimport 'package:generators/src/json_generator.dart';\nimport 'package:source_gen/source_gen.dart';\n\nBuilder generateJsonMethods(BuilderOptions options) {\n  // Step 1\n  return SharedPartBuilder(\n    [JsonGenerator()], // Step 2\n    'json_generator', // Step 3\n  );\n}\n```\n\n<div class=\"content-ad\"></div>\n\n**단계 1:** [Builder]는 파일의 일부로 생성된 콘텐츠를 생성하는데 사용됩니다. 생성된 파일은 partId로 접두사가 붙어 있어 여러 [SharedPartBuilder]가 충돌하지 않고 일부 파일을 생성할 수 있습니다.\n\n**단계 2:** 이것은 우리의 생성기 클래스입니다.\n\n**단계 3:** partId 매개변수가 있습니다. 각 .dart 입력에 대해 어떤 파일이 생성될지 나타냅니다. 이 확장자는 다른 [SharedPartBuilder]와 충돌하지 않도록 고유해야 합니다.\n\n좋아요! 이제 생성기를 만들었네요, 축하합니다. 🎉🎉\n\n<div class=\"content-ad\"></div>\n\n이제 사용자 정의 주석 및 빌더를 테스트해 봅시다.\n\n# 예제 프로젝트\n\npubspec.yaml 파일을 열어 주석 및 빌더 패키지의 종속성을 추가하세요.\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n\n  # 우리의 주석 패키지\n  annotations:\n    path: ../annotations/\n\ndev_dependencies:\n  flutter_test:\n    sdk: flutter\n\n  build_runner:\n  # 우리의 생성기 패키지\n  generators:\n    path: ../generators/\n```\n\n<div class=\"content-ad\"></div>\n\n위 명령어를 실행하십시오: flutter pub get.\n\nlib 폴더로 이동하여 새로운 클래스를 생성하십시오. 예를 들어 Product라는 이름의 클래스를 생성하십시오:\n\n```js\nimport 'package:annotations/annotations.dart';\n\n// 스텝 1\npart 'product.g.dart'; // 파일 이름과 동일해야 함\n\n// 스텝 2\n@customAnnotation\nclass Product{\n  final String name;\n  final double price;\n\n  const Product({required this.name, required this.price});\n\n  /// 생성된 [_$ProductFromJson] 함수를 `fromJson` 팩토리와 연결합니다.\n  factory Product.fromJson(Map<String, dynamic> json) => _$ProductFromJson(json);\n\n  /// 생성된 [_$ProductToJson] 함수를 `toJson` 메소드와 연결합니다.\n  Map<String, dynamic> toJson() => _$ProductToJson(this);\n}\n```\n\n스텝 1: 파일 상단에 part `파일이름.g.dart`라는 줄을 추가하여 이 파일이 생성된 코드의 일부임을 지정하십시오. part `파일이름.g.dart`의 파일 이름이 Dart 파일 이름과 일치하는지 확인하십시오.\n\n<div class=\"content-ad\"></div>\n\n스텝 2: 제품 클래스에 우리의 주석을 추가하세요.\n\n예제 프로젝트 터미널에서 다음 명령을 실행해보세요:\n\ndart run build_runner build\n\n예제 프로젝트 터미널에서 명령을 실행한 후 다음 출력이 표시됩니다:\n\n<div class=\"content-ad\"></div>\n\n![Code Generation using Flutter](/assets/img/2024-06-21-CodeGenerationusingFluttersource_genbuild_runner_2.png)\n\nOutput/Generated file:\n\n```js\n// GENERATED CODE - DO NOT MODIFY BY HAND\n\npart of 'product.dart';\n\n// **************************************************************************\n// JsonGenerator\n// **************************************************************************\n\n// From Json Method\nProduct _$ProductFromJson(Map<String, dynamic> json) => Product(\n    name: json['name'],\n    price: json['price'],\n);\n\n// To Json Method\nMap<String, dynamic> _$ProductToJson(Product instance) => <String, dynamic>{\n    'name': instance.name,\n    'price': instance.price,\n};\n\n// Extension for a Product class to provide 'copyWith' method\nextension $ProductExtension on Product {\n    Product copyWith({\n        String? name,\n        double? price,\n    }) {\n        return Product(\n            name: name ?? this.name,\n            price: price ?? this.price,\n        );\n    }\n}\n```\n\nNow you can build your annotation with more customization 🎉😎\n\n<div class=\"content-ad\"></div>\n\n위 글을 읽어주셔서 감사합니다. 도움이 되셨으면 좋겣습니다. 궁금한 점이 있으면 언제든지 연락주세요.\n\n소스 코드\n\n질문이 있으면 LinkedIn 계정을 통해 연락주세요.\n","ogImage":{"url":"/assets/img/2024-06-21-CodeGenerationusingFluttersource_genbuild_runner_0.png"},"coverImage":"/assets/img/2024-06-21-CodeGenerationusingFluttersource_genbuild_runner_0.png","tag":["Tech"],"readingTime":22},{"title":"IntelliJ에서 Flutter 사용하는 방법","description":"","date":"2024-06-21 22:27","slug":"2024-06-21-FlutterinIntelliJ","content":"\n\n## 완전 초보자를 위한 \"플러터 시작하기\" 시리즈의 3부\n\nTiger가 묻습니다... 선호하는 IDE를 계속 사용하는 방법은 무엇인가요?\n\nVS Code는 플러터 프로젝트에서 인기 있는 선택지입니다. 그리고 그것이 그렇게 나쁜 선택은 아닙니다.\n\n하지만 나는 연령이다 유지하려는 것을 좋아하는 Jetbrain의 IntelliJ를 업무에서나 개인적으로 여러 해 동안 사용해 왔습니다. 그것을 좋아하기 때문에, 그리고 필요 없는 경우에는 그것을 포기하기를 꺼리는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n정 테이블 기호(Markdown 형식)로 변경해야 할 것 같습니다.\n\n<div class=\"content-ad\"></div>\n\n만약 더 자세한 지침에 관심이 없고 빠른 \"이것을 해야 한다\" 체크리스트를 원하신다면, 문서 맨 아래의 요약 부분으로 건너뛰세요.\n\n# 플러터 플러그인 설치\n\n그게 플러터의 \"에디터 설정\" 페이지에 언급된 유일한 항목이에요, 그래서 우리는 그것을 해볼 거에요.\n\n- Ctrl+Alt+S - Plugins 찾기\n- marketplace 탭 열고, flutter로 검색하기\n\n<div class=\"content-ad\"></div>\n\n플러터 플러그인이 많다고 하는데, 예를 들어 Bloc 등이 있습니다. 하지만 지금은 플러터 플러그인만 설치할 예정이에요. 그리고 이에 필요한 Dart 플러그인도 설치해야 한다고 알려줍니다.\n\n![이미지](/assets/img/2024-06-21-FlutterinIntelliJ_0.png)\n\n그런 다음 플러그인을 활성화하기 위해 IDE를 다시 시작하세요.\n\n# 플러터 SDK 설치하기\n\n<div class=\"content-ad\"></div>\n\n이제 IntelliJ는 Flutter를 사용하는 방법을 알고 있지만, Flutter 자체가 필요합니다.\n\n- https://docs.flutter.dev/get-started/install\n\n제 경우에는 Linux에 설치하고 Snap을 사용할 것입니다:\n\n```js\nsudo snap install flutter --classic\n```\n\n<div class=\"content-ad\"></div>\n\n만약 --classic에 대해 헷갈린다면, 스택익스체인지에 훌륭한 답변이 있으니 참고하세요. 요약하면, 이것은 플러터와는 아무 상관이 없으며 플러터에 부여된 액세스 권한에 대한 것입니다.\n\n그럼, 설치가 유효한지 확인해봅시다.\n\n```js\nflutter doctor\n```\n\n이 명령을 실행하여 많은 정보를 확인할 수 있습니다. 먼저, 실행하길 원합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nflutter --disable-analytics\n```\n\n이것은 선택 사항이지만, 나는 텔레메트리를 싫어해요.\n\n다음으로, flutter doctor는 정확히 무엇이 부족한지 알려줍니다:\n\n![FlutterinIntelliJ_1](/assets/img/2024-06-21-FlutterinIntelliJ_1.png)\n\n\n<div class=\"content-ad\"></div>\n\n안녕하세요! 안드로이드 애플리케이션을 개발할 때 플러터를 사용하기 위해 안드로이드 SDK가 필요합니다. 큰 놀라움이 아니에요. 안드로이드 에뮬레이터를 어떻게 가져올까요?\n\n실제 애플리케이션을 실행할 때 그 다리를 건너가면서 알아보도록 하겠습니다.\n\n# 플러터 프로젝트 생성\n\n![Flutter in IntelliJ](/assets/img/2024-06-21-FlutterinIntelliJ_2.png)\n\n<div class=\"content-ad\"></div>\n\nIntelliJ는 플러터 SDK 경로를 인식해야 합니다. 그렇지 않을 경우,\n\n```js\nflutter sdk-path\n```\n\n를 입력하여 확인할 수 있습니다. 거기서 새 프로젝트를 설정하는 일반적인 단계를 거치면 됩니다. 저는 이 시리즈의 개요 포스트에서 설명된 프로젝트를 설정할 것이며, iOS를 대상으로 하지는 않을 것입니다.\n\n![이미지](/assets/img/2024-06-21-FlutterinIntelliJ_3.png)\n\n<div class=\"content-ad\"></div>\n\n한 번의 git init과 커밋 후에, 우리는 출발할 준비가 되었어요.\n\n제 개인적인 의견으로는, gitignore.io에서 더 포괄적인 .gitignore 파일을 생성하여 IntelliJ가 자동으로 생성하는 것과 교체하는 것을 선호합니다. 하지만 이 작업을 할 때 주의할 점이 있습니다: 이 글을 쓰는 시점에서, gitignore.io는 *.iws 파일만 무시하지만 IntelliJ가 생성하는 것은\n\n\n# 파일 기반 프로젝트 형식\n*.iml\n*.ipr\n*.iws\n.idea/\n\n\n이렇게 추가해야 할 부분이 있을 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n# 에뮬레이터에서 앱 실행하기\n\n새로운 플러터 프로젝트에는 \"Hello world\" 보일러플레이트 애플리케이션이 자동으로 포함되어 있습니다. 놀랍게도, 플러터에 대한 미니 튜토리얼을 제공하는 유용한 주석도 포함되어 있습니다. 편리하네요.\n\n지금은 어쨌든, 일단 애플리케이션을 가상 플러터 장치에서 실행하여 모든 것이 작동하는지 확인하고 싶습니다. IntelliJ가 표시하는 경고에서 알 수 있듯이, 그렇게 되지는 않습니다.\n\n<div class=\"content-ad\"></div>\n\n참고로, IDE 오른쪽 상단의 '장치 선택 없음' 드롭다운을 보는 것을 좋아해요. 안드로이드 스튜디오에 신경을 쓰지 않은 것이 옳은 선택이었다고 느끼게 해줍니다.\n\n## 안드로이드 SDK 설치\n\n경고에서 Configure...을 누를 수도 있지만, 경고 없이 어디에서 무엇을 찾을 수 있는지 알아둘 때를 선호하기 때문에 다음으로 이동합니다.\n\n파일 - 프로젝트 구조 - +\n\n<div class=\"content-ad\"></div>\n\n수정해주셔서 감사합니다. 단 … 현재 버그가 있어서 원하는 곳이 아닙니다.\n\n![image](/assets/img/2024-06-21-FlutterinIntelliJ_5.png)\n\nAndroid SDK 다운로드를 선택하면 IntelliJ가 다운로드할 JDK 버전을 묻습니다. 제가 원하는 것이 아닙니다.\n\n언젠가는 패치될 것 같지만 그동안 Shift를 두 번 눌러 android를 검색하면 Android SDK 관리자라는 유용한 기능이 있다는 것을 알게 됩니다.\n\n<div class=\"content-ad\"></div>\n\n만약 우리가 그것을 열면, 그것이 우리가 찾고 있는 것과 더 닮아 보입니다.\n\n![Flutter in IntelliJ image 6](/assets/img/2024-06-21-FlutterinIntelliJ_6.png)\n\n여기서 '편집'을 누르면 SDK 설정을 마칠 수 있습니다.\n\n![Flutter in IntelliJ image 7](/assets/img/2024-06-21-FlutterinIntelliJ_7.png)\n\n<div class=\"content-ad\"></div>\n\n그러면 우리에게 다음을 설치할 것입니다:\n\n- 안드로이드 에뮬레이터\n- SDK 빌드 도구\n- SDK 플랫폼과 해당 도구\n- 안드로이드 소스\n\n유용합니다. 한 번의 라이센스 동의 화면을 거치고 나면, 마침내 SDK를 설치했습니다.\n\n## 올바른 Android 플랫폼 설치하기\n\n<div class=\"content-ad\"></div>\n\n하지만 조심해, 아직 Fig.5에서의 경고가 남아 있네. 왜냐하면 방금 실행한 SDK 설정은 최신 플랫폼만 설치하도록 했기 때문이야... 이는 생성된 프로젝트가 구성된 API 레벨이 아니기 때문이야.\n\n나는 API를 최신 것으로 변경할 수 있지만, 대신 앱이 기대하는 API를 설치해보자:\n\n![이미지](/assets/img/2024-06-21-FlutterinIntelliJ_8.png)\n\nApply를 누르면... 여전히 Fig.5의 경고가 남아 있어.\n\n<div class=\"content-ad\"></div>\n\nAPI 29를 설치했지만 프로젝트가 아직 그것을 사용하도록 설정되지 않았기 때문입니다.\n\n그래서 Project Structure 대화상자에서 Android API의 빌드 대상을 29로 변경해봅시다.\n\n![이미지](/assets/img/2024-06-21-FlutterinIntelliJ_9.png)\n\n그리고... 경고 메시지가 여전히 있네요. -.-\n\n<div class=\"content-ad\"></div>\n\n그래, 저희는 이 오해불쏙 끝나는 '구성...' 버튼을 사용할 거에요:\n\n![image](/assets/img/2024-06-21-FlutterinIntelliJ_10.png)\n\nFigure 11에서 안드로이드 API는 프로젝트 구조에서 SDK로 이름을 변경한 것입니다. 내 의견으로는, IntelliJ가 그것에 만족해야 하는 것이었어야 했는데, 그러나 확실히 우리에게 그것을 사용할 수 있다는 것을 알려줄 때 만족했다고 해야 할까요... 대신에 우리가 설치했으므로 이제 추가할 수 있다는 IntelliJ가 감지한 Android API 29 플랫폼 Android SDK 옵션을 선택할 겁니다.\n\n그리고 경고가 없어졌어요. 프로젝트 구조를 간략히 살펴보면, IntelliJ가 새 API를 별도의 항목으로 추가했음을 알 수 있어요. 그래서 첫 번째를 제거하기로 결정할게요.\n\n<div class=\"content-ad\"></div>\n\n## 안드로이드 가상 장치 (AVD) 만들기\n\n당신의 IntelliJ 오른쪽 가장자리, 세 개의 플러터 아이콘(플러터 인스펙터, 플러터 성능 및 플러터 아웃라인 도구) 위에 장치 관리자가 있습니다:\n\n![Device Manager](/assets/img/2024-06-21-FlutterinIntelliJ_11.png)\n\n만약 어떤 이유로 그곳에 없다면, 다시 두 번 Shift를 누르세요.\n\n<div class=\"content-ad\"></div>\n\n이미 미리 설정된 장치가 있어서 시스템 이미지를 다운로드하여 사용할 수 있습니다. 대신 나는 그것을 무시하고 + 버튼을 눌러 내 장치를 스스로 설정할 것입니다.\n\n과정은 매우 간단합니다. 먼저 전화기 크기를 선택하세요:\n\n![전화기 크기 선택](/assets/img/2024-06-21-FlutterinIntelliJ_12.png)\n\n그런 다음 장치가 실행 중이어야하는 시스템 이미지를 선택하세요. 이 이미지를 사용하는 것이 처음이라면, 다운로드해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-21-FlutterinIntelliJ_13.png\" />\n\n마지막으로 이름을 지어주면 끝입니다. (고급 옵션은 일단 건너 뜁니다.)\n\n## AVD에서 애플리케이션 실행\n\n장치 드롭다운에서 장치 목록을 새로 고침한 후, 이제 우리가 에뮬레이터에서 생성한 AVD를 시작할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"/assets/img/2024-06-21-FlutterinIntelliJ_14.png\" />\n\nIntelliJ에서 기기를 부팅하는 데 시간이 걸릴 수 있지만 결국 AVD가 준비되고 IntelliJ에서 `no device selected`이라고 표시된 이전 기기가 표시될 것입니다.\n\n만약 Android Emulator를 열 때 \"아무 일도 일어나지 않는\" 것에 혼란스러워한다면, 기본적으로 IntelliJ의 Android 에뮬레이터가 Running Devices 도구 창에서 실행되기 때문입니다. 그 창은 새로운 기기를 시작할 때 자동으로 열리지 않습니다.\n\n<img src=\"/assets/img/2024-06-21-FlutterinIntelliJ_15.png\" />\n\n\n<div class=\"content-ad\"></div>\n\n이 동작은 Android 에뮬레이터 설정에서 변경할 수 있어요 (찾으려면 double Shift를 누르세요), 그리고 Launch in a tool window 옵션을 선택하세요.\n\n![이미지](/assets/img/2024-06-21-FlutterinIntelliJ_16.png)\n\n여기에는 \"앱을 실행할 때 Running Devices 도구 창을 열기\"라는 옵션이 있다고 적혀 있지만, 제 경우에는 그렇게 되지 않았어요.\n\n![이미지](/assets/img/2024-06-21-FlutterinIntelliJ_17.png)\n\n<div class=\"content-ad\"></div>\n\n메인.dart 드롭다운 옆의 초록색 플레이 버튼 또는 버그 버튼으로 어플리케이션을 실행할 수 있습니다.\n\n# 실제 기기에서 앱 실행하기\n\n가끔은 실제 기기에서 앱을 실행하는 것이 필요할 때가 있습니다.\n\n상당히 간단한 과정입니다.\n\n<div class=\"content-ad\"></div>\n\n- 기기에서 개발자 모드를 활성화하세요 (특정 기기에 대해 하는 방법을 구글에서 검색해보세요).\n- USB 디버깅을 켜세요.\n- 안드로이드 기기를 개발용 컴퓨터에 연결하고, 기기에서 USB 디버깅을 허용하세요.\n- 이전에 AVD를 선택했던 드롭다운 메뉴에서 기기를 선택하세요.\n- IntelliJ에서 애플리케이션을 실행하세요.\n\n# Flutter doctor를 성공적으로 완료하기\n\n애플리케이션이 실행되지만, flutter 설치를 확인하기 위해 flutter doctor를 실행하면 여전히 flutter가 불평합니다:\n\n![이미지](/assets/img/2024-06-21-FlutterinIntelliJ_18.png)\n\n<div class=\"content-ad\"></div>\n\n우선, Command Line 도구에 대해 이야기해볼게요. IntelliJ에서 다시 설치할 수 있는 도구입니다. Android SDK 매니저에서 SDK Tools 탭에는 CLI 도구를 설치할 수 있는 옵션이 있습니다.\n\n이제 새 터미널에서 아래 명령어를 실행해봅시다.\n\n```js\nflutter doctor --android-licenses\n```\n\n<div class=\"content-ad\"></div>\n\n\n![Flutter doctor](/assets/img/2024-06-21-FlutterinIntelliJ_20.png)\n\nAnd if we run flutter doctor again,\n\n![Android Studio warning](/assets/img/2024-06-21-FlutterinIntelliJ_21.png)\n\nFlutter warns that it cannot find Android Studio, but that’s ok, we don’t care about that anyway.\n\n\n<div class=\"content-ad\"></div>\n\n# 요약\n\n다시 한 번 강조하자면, 안드로이드 에뮬레이터에서 플러터 앱을 성공적으로 시작하기 위해 해야 할 단계는 다음과 같습니다:\n\n- 머신에 Flutter 설치하기\n\n```js\nsudo snap install flutter --classic\n```\n\n<div class=\"content-ad\"></div>\n\n- IntelliJ를 설치해주세요 (아직 설치하지 않았다면)\n- IntelliJ에 Flutter 및 Dart 플러그인을 설치해주세요\n- IntelliJ에서 새로운 Flutter 프로젝트 생성하기 (이 과정에서 데모 앱이 만들어집니다)\n- IntelliJ에서 Android SDK 매니저 열기\n- SDK 매니저에서 편집 옵션을 눌러 Android SDK를 설치해주세요\n- SDK 플랫폼 탭에서 데모 앱이 요구하는 API 레벨의 Android SDK를 추가로 설치해주세요\n- 프로젝트가 방금 설치한 Android SDK를 사용하도록 구성해주세요\n- 프로젝트 구조에서 오래된 것(들)은 제거하고 Android SDK가 하나만 추가되어 있는지 확인해주세요\n- Device Manager를 사용하여 새로운 안드로이드 가상 장치를 만들어주세요\n- IntelliJ에서 생성한 AVD를 선택하여 앱을 실행해주세요\n- Running Devices 탭에서 안드로이드 에뮬레이터를 찾아주세요\n- 선택적으로 IntelliJ를 구성하여 에뮬레이터를 별도의 창에서 열도록 설정해주세요\n\n그러면 flutter doctor에서 완전히 만족스러운 결과를 얻을 수 있을 것입니다:\n\n- IntelliJ의 Android SDK 매니저의 SDK 도구 탭에서 android SDK 명령줄 도구를 설치해주세요\n- 새 터미널에서 flutter가 받아들이기를 원하는 모든 라이선스를 수락해주세요\n\n```js\nflutter doctor --android-licenses\n```","ogImage":{"url":"/assets/img/2024-06-21-FlutterinIntelliJ_0.png"},"coverImage":"/assets/img/2024-06-21-FlutterinIntelliJ_0.png","tag":["Tech"],"readingTime":9},{"title":"Flutter 웹에서 캐시를 방지하는 방법","description":"","date":"2024-06-21 22:25","slug":"2024-06-21-HowtopreventcacheinFlutterWeb","content":"\n\n![이미지](/assets/img/2024-06-21-HowtopreventcacheinFlutterWeb_0.png)\n\n안녕하세요, 개발자님. 잘 지내시나요? 오늘의 주제는 조금 복잡할 수 있지만 걱정하지 마세요, 5분 안에 해결할 수 있을 거예요 :) 항상처럼 우리의 해결책은 간단하고 효과적입니다!\n\n## 질문 1: 캐시란 무엇이며 브라우저가 캐시를 저장하는 이유는 무엇인가요?\n\n- 브라우저 캐시는 웹 페이지, 이미지, 스크립트 등이 임시로 저장되는 장소로, 웹 브라우저가 여러분의 기기에 저장합니다. 웹 사이트를 방문하면 브라우저가 HTML, CSS, JavaScript 및 이미지와 같은 파일을 다운로드합니다. 매번 다운로드하는 대신 브라우저는 그 사본을 캐시에 저장합니다. 사이트를 재방문하면 브라우저가 파일 확인을 캐시에서 합니다. 그 파일들이 존재하고 유효 기간이 지나지 않았다면, 브라우저는 캐시에서 그 파일을 검색하여 페이지 로딩 속도를 높입니다.\n\n<div class=\"content-ad\"></div>\n\n## 질문 2: 사람들이 캐시를 막거나 비활성화하려는 이유는 무엇인가요?\n\n- 때로는 모든 콘텐츠(이미지 및 스타일 시트와 같은 리소스)가 매번 새로 고쳐져야 하는 중요성이 커질 수 있습니다. 놀랍게도 이러한 요소들은 특정 시나리오에서 중요할 수 있습니다.\n\n이제 캐시에 대해 알았으니, 이어서 Flutter Web의 해결책을 살펴보겠습니다.\n\n해결책은 간단합니다. Flutter Web에서 캐시 문제는 web/index.html 파일에 있는 main.dart.js라는 스크립트에서 발생합니다. 이를 해결하기 위해 이 스크립트 끝에 숫자나 변수를 추가하면 됩니다.\n\n<div class=\"content-ad\"></div>\n\n우연히 손으로 매번 값 변경하거나 증가시키는 것을 피하기 위해 플러터는 index.html 파일에 \"serviceWorkerVersion\"이라는 미리 정의된 값을 제공합니다. 이 값을 수동으로 수정하는 대신 이 값을 사용할 수 있습니다.\n\n플러터가 제공하는 \"serviceWorkerVersion\"을 사용하면 버전을 수동으로 갱신하는 대신 자동으로 증가되는 동적 해결책을 얻을 수 있습니다.\n\n먼저 프로젝트로 이동하여 web/index.html 파일을 찾아보세요. 파일을 찾았다면, 이 페이지로 돌아와 다음 중 하나의 해결책을 적용하세요.\n\n## Case 1: Flutter의 새로운 버전\n\n<div class=\"content-ad\"></div>\n\n만약 새로운 Flutter 버전에서 캐시 문제를 방지해야 한다면, 몇 가지 스크립트를 수정해야 합니다. \"main.dart.js\" 스크립트는 기본적으로 존재하지 않기 때문에 직접 추가해야 합니다.\n\n\" _flutter.loader.loadEntrypoint\"를 수정하고 추가 매개변수를 넣어야 합니다: \"entrypointUrl: \"main.dart.js?v=\" + serviceWorkerVersion\" \n\n최종적으로는 아래와 같이 스크립트 부분이 보여야 합니다:\n\n```js\n<script>\n    window.addEventListener('load', function (ev) {\n      // Download main.dart.js\n      _flutter.loader.loadEntrypoint({\n        entrypointUrl: \"main.dart.js?v=\" + serviceWorkerVersion,\n        serviceWorker: {\n          serviceWorkerVersion: serviceWorkerVersion,\n        }\n      }).then(function (engineInitializer) {\n        return engineInitializer.initializeEngine();\n      }).then(function (appRunner) {\n        return appRunner.runApp();\n      });\n    });\n  </script>\n```\n\n<div class=\"content-ad\"></div>\n\n이 작은 추가로 문제가 해결되었습니다! :)\n\n## 케이스 2: Flutter의 이전 버전\n\n이전 버전의 Flutter에서 캐시 문제를 방지해야하는 경우, web/index.html의 “scriptTag.src” 값이 다음과 같이 수정되어야 합니다: “scriptTag.src = ‘main.dart.js?v=’ + serviceWorkerVersion;”.\n\n결국, 스크립트 섹션은 다음과 같이 보여야 합니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n<script>\n    var serviceWorkerVersion = null;\n    var scriptLoaded = false;\n    function loadMainDartJs() {\n      if (scriptLoaded) {\n        return;\n      }\n      scriptLoaded = true;\n      var scriptTag = document.createElement('script');\n      scriptTag.src = 'main.dart.js?v=' + serviceWorkerVersion;\n      scriptTag.type = 'application/javascript';\n      document.body.append(scriptTag);\n    }\n\n    if ('serviceWorker' in navigator) {\n      // Service workers are supported. Use them.\n      window.addEventListener('load', function () {\n        // Wait for registration to finish before dropping the <script> tag.\n        // Otherwise, the browser will load the script multiple times,\n        // potentially different versions.\n        var serviceWorkerUrl = 'flutter_service_worker.js?v=' + serviceWorkerVersion;\n        navigator.serviceWorker.register(serviceWorkerUrl)\n          .then((reg) => {\n            function waitForActivation(serviceWorker) {\n              serviceWorker.addEventListener('statechange', () => {\n                if (serviceWorker.state == 'activated') {\n                  console.log('Installed new service worker.');\n                  loadMainDartJs();\n                }\n              });\n            }\n            if (!reg.active && (reg.installing || reg.waiting)) {\n              // No active web worker and we have installed or are installing\n              // one for the first time. Simply wait for it to activate.\n              waitForActivation(reg.installing || reg.waiting);\n            } else if (!reg.active.scriptURL.endsWith(serviceWorkerVersion)) {\n              // When the app updates the serviceWorkerVersion changes, so we\n              // need to ask the service worker to update.\n              console.log('New service worker available.');\n              reg.update();\n              waitForActivation(reg.installing);\n            } else {\n              // Existing service worker is still good.\n              console.log('Loading app from service worker.');\n              loadMainDartJs();\n            }\n          });\n\n        // If service worker doesn't succeed in a reasonable amount of time,\n        // fallback to plaint <script> tag.\n        setTimeout(() => {\n          if (!scriptLoaded) {\n            console.warn(\n              'service worker disabled...',\n            );\n            loadMainDartJs();\n          }\n        }, 4000);\n      });\n    } else {\n      // Service workers not supported. Just drop the <script> tag.\n      loadMainDartJs();\n    }\n  </script>\n```\n\nWith this small change, the problem is solved! :)\n\nIn this way, we have seen how to prevent the \"Cache\" problem in Flutter with simple solutions. I hope these solutions have been helpful to you.\n\nIf you have read this article and would like to support me, don't be shy — buy me a coffee! :) ☕☕☕\n\n\n<div class=\"content-ad\"></div>\n\n커피 사줄래?\n\n제가 이 글을 쓰는 데 도움이 된 몇 가지 링크가 있어요. 꼭 확인해 보세요!\n\n- 문제 1 (반드시 확인해보세요!)\n- 스택 오버플로우 1\n- 스택 오버플로우 2\n- 스택 오버플로우 3\n\n이 글을 읽어 주셔서 감사합니다. 추가 질문이 있으시면 언제든지 댓글을 남겨 주세요. 그리고 박수 버튼 꾹 눌러주세요 :) 다음에 또 봐요, 개발자님 :)","ogImage":{"url":"/assets/img/2024-06-21-HowtopreventcacheinFlutterWeb_0.png"},"coverImage":"/assets/img/2024-06-21-HowtopreventcacheinFlutterWeb_0.png","tag":["Tech"],"readingTime":6},{"title":"Firebase로 Flutter 프로젝트에 애플 패스 추가하는 방법","description":"","date":"2024-06-21 22:23","slug":"2024-06-21-HowtoaddApplePassonaFlutterprojectwithFirebase","content":"\n\n<img src=\"/assets/img/2024-06-21-HowtoaddApplePassonaFlutterprojectwithFirebase_0.png\" />\n\n이 글에서는 Firebase 함수를 사용하여 Flutter 프로젝트에 Apple Pass를 통합하는 방법을 설명하겠습니다.\n\n저는 백엔드 개발과 Apple Pass 디자인에 대한 전문가가 아니기 때문에 정보가 부족하거나 부정확할 수 있습니다. 더 자세한 내용은 문서를 참조해주세요.\n\n# 단계 1: 인증서 준비하기\n\n<div class=\"content-ad\"></div>\n\n가장 먼저 할 일은 인증서를 준비하는 것입니다. 세 가지 요소를 다운로드해야 합니다:\n\n- 서명자 인증서 (개발자)\n- 서명자 인증서 키 (개발자)\n- WWDR (애플 월드와이드 개발자 관계) G4 인증서\n\n- 새로운 패스 유형 식별자(직접 링크)를 생성하고 설명 및 역도메인 식별자(“pass.”로 시작)를 제공하세요. pass.json 파일 또는 프로퍼티 값으로 이 식별자를 passTypeIdentifier에 넣어야 합니다.\n- Keychain Access를 열고 파일 `인증서 보조도구` `인증서 요청`으로 이동하여 양식을 작성한 후 “디스크에 저장” 옵션을 선택하고 계속하세요. 새 파일이 생성됩니다.\n- 패스 유형 식별자 목록(필터링)에서 새 패스 ID를 클릭하여 편집합니다.\n- “인증서 생성”을 클릭하세요. 패스 인증서 이름을 입력하고 Keychain Access로 방금 생성된 파일을 업로드하세요. 그런 다음 인증서를 다운로드하고 두 번 클릭하여(Keychain Access에 추가하는) 열어주세요.\n- Keychain Access로 돌아가서 “패스 유형ID: xxxx”를 마우스 오른쪽 버튼으로 클릭하고 “패스 유형ID: xxxx”를 내보내세요. 마음에 드는 곳에 저장하고(.p12 확장자와 함께) 암호를 생성해야 합니다. 이것은 나중에 필요할 것입니다.\n- 이 .p12 파일을 저장한 위치에서 터미널을 열고 다음 명령어를 입력하세요:\n\n```js\n# -passin용 <your-password>는 P12의 비밀번호입니다.\n$ openssl pkcs12 -in <cert-name>.p12 -clcerts -nokeys -out signerCert.pem -passin pass:<your-password>\n\n# -passin용 <your-password>는 P12의 비밀번호입니다. <secret-passphrase>는 passkit-generator에 전달할 privateKey를 복호화하는 데 사용할 암호입니다.\n$ openssl pkcs12 -in <cert-name>.p12 -nocerts -out signerKey.pem -passin pass:<your-password> -passout pass:<secret-passphrase>\r\n```\n\n<div class=\"content-ad\"></div>\n\n에러가 발생하면 명령 끝에 \"-legacy\"를 추가하거나 이 링크를 따르세요.\n\n암호구절을 저장해두세요. 나중에 필요할 겁니다.\n\n필요한 3개 인증서 중 2개가 생성되었습니다.\n\n마지막 인증서를 위해서는 이 링크를 열어보세요.\n\n<div class=\"content-ad\"></div>\n\n# 단계 2: 서버 측 준비\n\n우리가 말했듯이, 우리는 Firebase 함수를 사용하여 우리의 패스 생성기를 호스팅할 것입니다.\n\n주의: 이 작업을 위해 Blaze 요금제가 필요합니다 (무료가 아닌 \"사용한 만큼 지불\" 형태입니다). Firebase를 사용하지 않으려면 우리가 만들 백엔드를 원하는 곳에 호스팅하시면 됩니다.\n\n우리의 패스를 생성하기 위해 passkit-generator를 사용할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n시작해봅시다:\n\n- 터미널에서 Firebase CLI를 설치하세요.\n- 새 Firebase 프로젝트 생성하기\n- \"pass-generator-be\"라는 폴더를 만들고 여기서 터미널을 열고 다음을 실행하세요.\n\n```js\nflutter login\n```\n\n- 명령어를 입력하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nfirebase init\n```\n\n“Functions: Configure a Cloud Functions directory and its files”을 선택하고 방금 만든 프로젝트를 선택하세요. 그런 다음 \"JavaScript\"를 선택하고 \"Y\"로 모든 질문에 답하십시오. 단, \"가능한 버그를 잡고 스타일을 강제하기 위해 ESLint를 사용하시겠습니까?\"에서는 (배포할 때 Lint 예외가 발생하지 않도록 하기 위해) \"N\"을 선택하시면 됩니다. 이것이 괜찮다면 그대로 두셔도 됩니다.\n\n- 이제 코드 에디터와 함께 생성된 \"functions\" 폴더를 열어보세요.\n- 프로젝트 내부의 터미널을 열고 아래 의존성을 설치하세요.\n\n```js\nyarn add passkit-generator\nyarn add path\nyarn add file-system\n```\n\n<div class=\"content-ad\"></div>\n\n- 프로젝트 내부에 \"certs\" 폴더를 만들어서 우리가 생성한 3개의 인증서를 붙여넣으세요.\n- 또한 \"model\" 폴더를 만들어서 패스 모델을 넣을 것입니다.\n\n간단한 패스 모델을 사용할 예정이며, 레이블과 이미지만 포함됩니다. 다른 모델에 관심이 있다면, 이 링크를 따라가서 사용자 정의 JSON 파일을 만들어보세요. 여기서 샘플을 찾을 수 있습니다.\n\n- 패스 폴더를 준비했다면 (예: \"auditor.pass\", JSON 파일과 이미지가 포함된), 이를 프로젝트 내부의 \"model\" 폴더에 복사하세요.\n\n프로젝트 구조는 다음과 같이 보일 것입니다:\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-21-HowtoaddApplePassonaFlutterprojectwithFirebase_1.png)\n\nMy pass.json file is:\n\nWarnings:\n\n- passTypeIdentifier: has to be the same as the one we registered at the beginning\n- teamIdentifier: has to be your team identifier\n\n\n<div class=\"content-ad\"></div>\n\n\"index.js\"로 이동해보세요:\n\n- 의존성 가져오기\n\n```js\nconst functions = require(\"firebase-functions\");\nconst { PKPass } = require(\"passkit-generator\");\nvar fs = require(\"file-system\");\nvar path = require(\"path\");\n```\n\nPKPass를 사용하여 패스를 생성하세요\n\n<div class=\"content-ad\"></div>\n\n```js\nPKPass.from({\n        model: \"./model/auditor.pass\",\n        certificates: {\n            wwdr: fs.readFileSync(\"./certs/wwdr.pem\"),\n            signerCert: fs.readFileSync(\"./certs/signerCert.pem\"),\n            signerKey: fs.readFileSync(\"./certs/signerKey.pem\"),\n            signerKeyPassphrase: \"YOUR PASSPHRASE\"\n        }\n\n    },{})\n```\n\n모두 함께\n\n흐름은 매우 간단합니다:\n\n- 새 요청이 도착하면 패스가 생성됩니다\n- 그런 다음 요청 내의 정보를 사용하여 패스를 채웁니다\n- 패스가 클라이언트로 되돌아갑니다\n\n<div class=\"content-ad\"></div>\n\n알림: 주석 처리된 “fs.writeFileSync(“auditor.pkpass”, bufferData)”는 개발 중에 생성된 .pkpass 파일을 프로젝트 폴더에 저장하는 데 유용합니다. 에뮬레이터에서 결과를 확인하기 쉽게 할 수 있습니다.\n\n백엔드를 로컬에서 실행하려면 다음 명령어를 입력하세요.\n\n```js\nfirebase emulators:start    \n```\n\n그러면 “http://127.0.0.1:5001/XXXX/us-central1/pass”와 같은 URL을 제공해줄 겁니다.\n\n<div class=\"content-ad\"></div>\n\n로컬 개발을 마치고 프로덕션 환경으로 이동하려면 다음 명령어를 사용하여 서버를 배포하세요.\n\n```js\nfirebase deploy\n```\n\n# 단계 3: 플러터 앱\n\n우리 앱에서 할 일이 매우 적습니다.\n\n<div class=\"content-ad\"></div>\n\n- 먼저 flutter_wallet_card와 dio(또는 다른 http 클라이언트)를 가져와주세요.\n- 제안된 이미지를 사용하여 \"Apple Wallet에 추가\" 기능을 제공해주세요.\n- onTap 동작을 처리하는 함수를 작성해주세요.\n\n그러고 나서 XCode로 iOS 모듈을 열고 Runner 아래에서 'Signing & Capabilities'를 클릭한 후 \"+ Capability\"를 클릭해주세요. 마지막으로 \"특정 종류의 패스 허용\"을 선택하고 처음에 생성한 패스를 선택해주세요.\n\n![이미지](/assets/img/2024-06-21-HowtoaddApplePassonaFlutterprojectwithFirebase_2.png)\n\n그리고...... 이게 전부에요!\n\n<div class=\"content-ad\"></div>\n\n당신의 앱은 이제 \"Apple Wallet에 추가\" 기능을 구현하고 있습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:600/1*CSrT10rYaB124vi-MuXDFw.gif)","ogImage":{"url":"/assets/img/2024-06-21-HowtoaddApplePassonaFlutterprojectwithFirebase_0.png"},"coverImage":"/assets/img/2024-06-21-HowtoaddApplePassonaFlutterprojectwithFirebase_0.png","tag":["Tech"],"readingTime":5},{"title":"2024년 Flutter에서 GraphQL 사용법 쿼리, 뮤테이션, 서브스크립션 구현 완벽 가이드","description":"","date":"2024-06-21 22:20","slug":"2024-06-21-GraphQLinFlutterAComprehensiveGuidetoQueryMutationandSubscriptionImplementations","content":"\n\n![이미지](/assets/img/2024-06-21-GraphQLinFlutterAComprehensiveGuidetoQueryMutationandSubscriptionImplementations_0.png)\n\n이 기사는 플러터(Flutter)에서 GraphQL을 마스터하는 데 필수적인 가이드입니다! 기본 개념 이해부터 쿼리(query), 뮤테이션(mutation), 구독(subscription)의 핵심 개념까지 모두 다룹니다. 뿐만 아니라 Flutter 앱에 GraphQL을 원활하게 통합하는 방법을 단계별 지침과 코드 샘플을 제공하면서 안내해드립니다.\n\n# GraphQL이란?\n\nGraphQL을 주문하듯이 생각해보세요. 일반 레스토랑(전통적인 API와 같은)에서는 특정 토핑이 올라간 고정된 피자를 주문합니다. 원하는 거랑 다르면 완전히 새로운 피자를 주문해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n지금은 GraphQL을 사용하면 피자에 원하는 대로 말하는 것과 같아요 — 크러스트, 소스, 토핑 종류를 정확하게 말하는 것과 같아요. 당신을 위해 특별히 만들어진 피자를 받게 되는거죠. 딱 필요한 만큼만요. 데이터에 대한 맞춤 주문처럼 생각해보세요 — 필요한 것을 요청하면 정확히 그것을 받게 되어 매우 효율적이고 요구 사항에 맞게 제작됩니다.\n\n그 외에도, GraphQL은 데이터와 상호 작용하는 방법을 간소화하여 세 가지 주요 작업을 제공합니다: 쿼리, 뮤테이션, 그리고 구독.\n\n- 쿼리: GraphQL에서 쿼리는 특정 데이터를 요청하는 것입니다. 서버에서 정보를 요청하는 것과 같이 특정 데이터와 그 구조를 명시합니다. 당신이 원하는 토핑과 크러스트 유형을 주문하는 것과 같은 거죠.\n- 뮤테이션: GraphQL에서 뮤테이션은 데이터 수정을 다루는 작업들입니다. 새 데이터 추가, 기존 레코드 업데이트, 혹은 정보 삭제와 같은 작업을 할 수 있습니다. 피자 비유에서는 셰프에게 선호에 따라 토핑을 추가하거나 제거하도록 지시하는 것과 같아요.\n- 구독: 구독은 GraphQL에서 실시간 업데이트를 가능하도록 합니다. 클라이언트(당신)와 서버(셰프) 사이에 지속적인 연결을 설정하여 서버가 가능한 즉시 새 정보를 클라이언트에게 푸시할 수 있게 합니다. 피자 준비 과정을 알려주는 셰프와 같이 데이터 변경 사항에 대한 실시간 알림을 받는 것과 같아요.\n\n그래서, GraphQL은 주문을 맞춤 제작하는 것 이상이에요; 당신이 요구하는 대로 데이터를 조회, 수정하고 최신 상태를 유지할 수 있도록 효율적이고 요구 사항에 정확히 맞게 제작된 방법을 제공하는겁니다.\n\n<div class=\"content-ad\"></div>\n\n# 플러터에서 GraphQL 구현하기\n\n먼저, 다음 패키지를 pubspec.yaml 파일에 추가하고 flutter pub get을 실행하세요:\n\n```js\n  graphql_flutter: latest\n  graphql: latest\n```\n\n이제 다음과 같이 GraphQL 클라이언트를 생성하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\n  final HttpLink _httpLink = HttpLink(\n    \"<YOUR-BASE-URL>\",\n    defaultHeaders: {\n      'Authorization': 'Bearer <YOUR_PERSONAL_ACCESS_TOKEN>',\n      'AuthorizationSource': 'API',\n    },\n  );\n\n\n  final ValueNotifier<GraphQLClient> client = ValueNotifier(GraphQLClient(\n    link: _httpLink,\n    cache: GraphQLCache(),\n  ));\n```\n\n앱을 GraphQL 위젯을 사용하기위한 GraphQLProvider 상속 위젯으로 감싸세요:\n\n```js\n  Widget build(BuildContext context) {\n    return GraphQLProvider(\n      client: client,\n      child: MaterialApp(\n        title: 'App',\n        home: HomeScreen(),\n      ),\n    );\n  }\n```\n\n그럼 GraphQL API를 소비해봅시다.\n\n<div class=\"content-ad\"></div>\n\n# 쿼리\n\n먼저 쿼리 문서를 정의해보겠습니다.\n\n```js\nfinal getUserQuery = gql(r'''\n    query getUser($id: ID) {\n      user(id: $id) {\n        id\n        first_name\n        last_name\n      }\n    }\n''');\n```\n\n쿼리 정의:\n\n<div class=\"content-ad\"></div>\n\n- query getUser($id: ID): 이 줄은 getUser라는 GraphQL 쿼리의 정의를 시작합니다. $id는 쿼리에 전달할 수 있는 ID 유형의 변수입니다.\n\n쿼리 본문:\n\n- ' user(id: $id) ' ... ' ': 쿼리의 본문은 우리가 원하는 데이터를 지정합니다. 이 경우 주어진 id를 가진 사용자에 대한 정보를 요청하고 있습니다. 요청된 세 가지 필드는 id, first_name 및 last_name입니다.\n\n변수 사용:\n\n<div class=\"content-ad\"></div>\n\n- 쿼리 내에서 $id 변수는 요청을 매개변수화하는 데 사용됩니다. 이는 쿼리가 실행될 때 특정 ID로 동적으로 채워지는 자리 표시자입니다.\n\n## 쿼리 위젯\n\n이제 이 문서를 사용하여 GraphQL API에 요청을 보냅니다.\n\n```js\nQuery(\n  options: QueryOptions(\n    document: getUserQuery,\n    variables: const {\n      \"id\": \"1\",\n    },\n  ),\n  builder: (\n    QueryResult result, {\n    Future<QueryResult> Function(FetchMoreOptions)? fetchMore,\n    Future<QueryResult?> Function()? refetch,\n  }) {\n    if (result.hasException) {\n      return const Text(\"에러\");\n    }\n    if (result.isLoading) {\n      return const CircularProgressIndicator();\n    }\n    final user = result.data?[\"user\"];\n    return ListTile(\n      title: Text(user[\"first_name\"]),\n      subtitle: Text(user[\"last_name\"]),\n    );\n  },\n)\n```\n\n<div class=\"content-ad\"></div>\n\n쿼리 위젯:\n\n- 이 문구는 graphql_flutter 패키지에서 제공하는 Query 위젯의 일부분입니다. Query 위젯은 GraphQL 쿼리를 실행하는 데 사용됩니다.\n\n쿼리의 옵션:\n\n- 옵션 매개변수는 GraphQL 쿼리 실행에 필요한 세부 정보를 제공하는 데 사용됩니다.\n- 문서: getUserQuery: 실행할 GraphQL 쿼리는 getUserQuery 변수를 사용하여 지정됩니다. 이 변수는 코드의 이전 부분에서 정의된 쿼리입니다.\n- 변수: const '\"id\": \"1\"': 이는 쿼리에 필요한 변수를 제공합니다. 이 경우 \"id\" 변수를 \"1\"로 설정하고 있습니다.\n\n<div class=\"content-ad\"></div>\n\nBuilder 함수:\n\n- builder는 GraphQL 쿼리의 결과로 호출되는 콜백 함수입니다.\n- QueryResult result: GraphQL 쿼리 실행의 결과를 보유합니다.\n- 빌더 안에서:\n- result.hasException을 사용하여 예외를 확인합니다. 예외가 발생하면 \"Error\"를 표시하는 Text 위젯을 반환합니다.\n- result.isLoading을 사용하여 쿼리가 여전히 로딩 중인지 확인합니다. true인 경우 CircularProgressIndicator를 반환합니다.\n- 쿼리가 성공하고 로딩 중이 아닌 경우, 결과에서 사용자 데이터를 추출하고 ListTile에 표시합니다. ListTile에는 사용자의 성과 이름이 각각 제목과 부제목으로 나타납니다.\n\n## 쿼리 메소드\n\n응답을 그릴 때 더 많은 제어를 위해 GraphQL 클라이언트의 query 메소드를 사용하여 GraphQL API를 소비하는 다른 방법이 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n# Mutation\n\n이제 먼저 변이 문서를 정의해 봅시다.\n\n```js\n final updateUserMutation = gql(r'''\n    mutation updateUser($id: ID, $first_name: String, $last_name: String) {\n    updateUser(\n    input: {id: $id, first_name: $first_name, last_name: $last_name,}\n      ) {\n    user {\n      id\n      first_name\n      last_name\n    }\n    messages {\n      field\n      message\n    }\n  }\n}\n''');\n```\n\n<div class=\"content-ad\"></div>\n\n이제 문서를 사용하여 GraphQL 클라이언트 객체를 사용하여 사용자 데이터를 업데이트해 봅시다.\n\n```js\nfinal result = await client.mutate(\n        MutationOptions(\n          document: updateUserMutation,\n          variables: {\n            \"id\": \"1\",\n            \"first_name\": \"John\",\n            \"last_name\": \"Doe\"\n          },\n        ),\n```\n\nGraphQL Mutation 실행:\n\n- client.mutate: 이것은 GraphQL 클라이언트에서 mutate 메소드를 호출하는 것입니다. 클라이언트 객체는 GraphQL 클라이언트의 인스턴스입니다.\n\n<div class=\"content-ad\"></div>\n\n돌변에 대한 옵션:\n\n- 돌변 옵션은 GraphQL 돌변 실행에 대한 세부 정보를 제공하는 데 사용됩니다.\n- 변수: '\"id\": \"1\", \"first_name\": \"John\", \"last_name\": \"Doe\"': 이는 돌변에 필요한 변수를 제공합니다. 사용자의 id와 함께 업데이트할 새로운 이름 및 성 값을 포함합니다.\n\n결과 처리:\n\n- 돌변 작업의 결과는 결과 변수에 저장됩니다.\n- 결과의 실제 구조는 사용되는 GraphQL 클라이언트에 따라 다르지만 일반적으로 돌변에 의해 반환된 데이터, 오류 및 추가 메타데이터와 같은 정보를 포함합니다.\n\n<div class=\"content-ad\"></div>\n\n# 구독\n\n먼저 웹소켓을 위한 graphQL 클라이언트를 만들겠습니다.\n\n```js\nfinal WebSocketLink websocketLink = WebSocketLink(\n    url: '<YOUR-GRAPHQL-SUBSCRIPTION-ENDPOINT>',\n    config: SocketClientConfig(\n    autoReconnect: true,\n    inactivityTimeout: Duration(seconds: 30),\n  ),\n);\n\nwebsocketClient = GraphQLClient(\n  link: websocketLink,\n  cache: GraphQLCache(),\n);\n```\n\n웹소켓 링크 설정:\n\n<div class=\"content-ad\"></div>\n\n- WebSocketLink은 GraphQL 구독용 WebSocket 전송의 구현체입니다. 지정된 GraphQL 서버 엔드포인트로 WebSocket 연결을 설정합니다.\n- URL: `YOUR-GRAPHQL-SUBSCRIPTION-ENDPOINT`: 실제 웹소켓 엔드포인트로 대체합니다. 이는 GraphQL 서버에서 제공하는 실제 웹소켓 엔드포인트로 구독을 처리합니다. 이 URL은 일반적으로 ws:// 또는 wss://로 시작합니다.\n- config: SocketClientConfig(...): WebSocket 연결에 대한 구성 옵션을 제공합니다.\n- autoReconnect: true: 연결이 끊긴 경우 자동 재연결을 활성화합니다.\n- inactivityTimeout: Duration(seconds: 30): 활동이 없거나 해당 시간 내에 통신이 발생하지 않을 경우 웹소켓 연결을 닫기 위한 타임아웃 기간을 설정합니다.\n\nGraphQLClient 설정:\n\n- GraphQLClient는 구독을 위한 통신 링크로 WebSocketLink를 사용하여 인스턴스화됩니다. 또한 캐싱을 위해 GraphQLCache를 사용합니다.\n- link: websocketLink: GraphQL 클라이언트의 통신 링크로 WebSocketLink를 지정합니다. 이는 구독이 WebSocket 연결을 통해 처리되도록 합니다.\n- cache: GraphQLCache(): GraphQL 클라이언트의 로컬 상태 및 쿼리 결과를 저장하고 관리하기 위한 캐시를 초기화합니다.\n\n이제 GraphQL 구독 문서를 작성해 봅시다.\n\n<div class=\"content-ad\"></div>\n\n```javascript\n  static final userUpdatedMutation = gql(r'''\nsubscription userUpdatedSubscription($id: String) {\n        userUpdatedSubscription(id: $id) {\n            ...UserFragment\n        }\n    }\n    fragment UserFragment on User {\n        id\n        first_name\n        last_name\n    }\n    ''');\n```\n\nGraphQL Subscription:\n\n- userUpdatedMutation은 사용자가 업데이트될 때 업데이트를 청취하는 GraphQL 구독(subscription)입니다. 사용자관련 정보를 관심 있는 사용자로 지정하기 위해 String 타입의 $id 매개변수를 가져옵니다.\n- subscription userUpdatedSubscription($id: String): id 변수를 허용하는 userUpdatedSubscription이라는 이름의 구독을 선언합니다.\n- userUpdatedSubscription(id: $id): 이 구독은 지정된 id를 가진 사용자에 대한 업데이트에 관심이 있다는 것을 나타냅니다.\n- ' ...UserFragment ': 이 구독에는 fragment spread, ...UserFragment가 포함되어 있어서 UserFragment에서 지정된 필드를 수신하려는 것을 나타냅니다.\n\nGraphQL Fragment:\n\n<div class=\"content-ad\"></div>\n\n- GraphQL 프래그먼트 (UserFragment)는 여러 쿼리, 뮤테이션 또는 구독에서 사용할 수 있는 재사용 가능한 필드 세트를 정의합니다.\n- UserFragment on User ' ... '의 프래그먼트는 User 유형에서 UserFragment라는 이름의 프래그먼트를 선언합니다.\n- 이 프래그먼트에는 id, first_name, last_name과 같은 필드가 포함되어 있습니다. ...UserFragment 스프레드를 포함하는 모든 작업은 이러한 필드를 자동으로 포함합니다.\n- 프래그먼트는 필드 정의의 중복을 피하고 코드 재사용성을 촉진하는 데 도움이 됩니다. 여러 작업이 공통 필드를 공유할 때 특히 유용합니다.\n\n이제 이 구독을 들어보겠습니다\n\n```js\nvoid _subscribe() async {\n  final subscription = await websocketClient.subscribe(\n    SubscriptionOptions(\n      document: userUpdatedMutation,\n    ),\n  );\n\n  subscription.listen((result) {\n    final userData = result.data?['user'];\n    print('이름: ${userData[\"first_name\"]}');\n    print('성: ${userData[\"last_name\"]}');\n    // 실시간 업데이트 처리, 예를 들어 UI 업데이트\n  });\n}\n```\n\nSubscription Widget도 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nbody: Subscription(\n        options: SubscriptionOptions(\n        document: userUpdatedMutation,\n        ),\n        builder: (result) {\n          final user = result.data?[\"user\"];\n          return ListTile(\n            title: Text(user[\"first_name\"]),\n            subtitle: Text(user[\"last_name\"]),\n          );\n        },\n      ),\n```\n\n# 결론\n\n이 가이드를 통해 플러터에서 GraphQL 구현에 대한 포괄적인 이해를 제공했습니다. 쿼리, 뮤테이션 및 구독의 기본 사항부터 실제 통합 단계에 이르기까지의 내용이 담겨 있습니다. 실시간 업데이트를 통한 GraphQL 구독에 중점을 두고 뮤테이션 작업을 시연함으로써, 개발자들은 이제 플러터 프로젝트에 GraphQL을 원활하게 통합할 수 있습니다. 이 포괄적인 리소스는 모든 수준의 개발자가 데이터 검색을 최적화하고 앱의 효율성을 향상시키며, 플러터에서 GraphQL의 강력함을 통해 동적 사용자 경험을 제공할 수 있는 기술을 제공합니다.","ogImage":{"url":"/assets/img/2024-06-21-GraphQLinFlutterAComprehensiveGuidetoQueryMutationandSubscriptionImplementations_0.png"},"coverImage":"/assets/img/2024-06-21-GraphQLinFlutterAComprehensiveGuidetoQueryMutationandSubscriptionImplementations_0.png","tag":["Tech"],"readingTime":9},{"title":"Flutter에서 Stripe를 사용하여 결제 통합하는 방법","description":"","date":"2024-06-21 22:19","slug":"2024-06-21-IntegratePaymentinFlutterwithStripe","content":"\n\n![이미지](/assets/img/2024-06-21-IntegratePaymentinFlutterwithStripe_0.png)\n\n안녕하세요 여러분, 제가 최근에 글을 올린 지 꽤 오랜 시간이 지났죠. 지난 몇 달 동안 저는 많은 새로운 경험들로 가득했고, 그 모든 것을 해내려고 노력했습니다. 하지만 글을 오랫동안 쓰지 않았다는 것을 깨달았고, 이번 11월에 적어도 두 개의 글을 쓰기로 다짐하고 앞으로는 더 꾸준해지기로 결심했습니다. 제가 이를 통해 모든 독자들에게 책임감을 느끼도록 허락해주세요.\n\n오늘의 글은 플러터(Flutter)에서 Stripe를 이용한 결제 처리에 관한 것입니다. 최근에 어느 회사에서 나에게 모바일 앱의 여러 기능을 매우 짧은 기간 내에 작업하도록 계약을 맺었습니다. 그 기능 중 하나가 결제 기능이었고, 물론 그들은 Stripe를 사용하길 원했습니다. 저는 반면에 플러터에 Stripe를 통합한 경험이 전혀 없었지만, 도전에서 도망가는 걸 절대 못 볼 것 같아 이 일을 받아들이고 조사에 착수했습니다. 이 지식을 여러 곳에서 모았지만, 이 글을 최대한 정보성 있게 만드는 데 노력하겠습니다. 이 주제에 대한 답변을 찾기 위해 다른 곳을 더 이상 찾아다니지 않아도 되도록 하겠습니다. 긴 이야기는 여기까지, 이제 시작해보죠.\n\n## Stripe:\n\n<div class=\"content-ad\"></div>\n\n먼저, 이 멋진 결제 플랫폼인 Stripe에 대해 간단히 소개할게요. Stripe는 Shopify, Instacart 같은 수백만 개의 기업에서 사용하는 결제 게이트웨이로, Google, Amazon과 같은 대규모 기술 기업도 사용하고 있어요. 이들은 전 세계 기업 및 그들의 고객들이 결제를 받고 보내는 간단하고 편리한 프로세스를 제공해요. 가상 및 실물 카드 발급, 반복 결제 처리, 재무에 대한 지능적이고 다이어그래틱한 분석 및 보고서, 송장 생성 등과 같은 추가 서비스도 제공하고 있어요.\n\nStripe를 개발자로서 흥미롭게 느낀 점 중 하나는 다양한 스택에 쉽게 통합되며 이를 지원하는 라이브러리, 그리고 Apple 및 Google 페이와 같은 네이티브 결제를 지원한다는 것이에요.\n\n## 시작하기\n\n시작하려면, 먼저 Stripe에서 API 키를 생성해야 해요. 이를 위해 Stripe 계정을 생성해야 해요. 그러고 나서 대시보드에 로그인하여 테스트 모드를 활성화하고 통합 및 테스트를 위해 개발자 `API Keys`로 이동하여 API 키(공개 및 비밀 키)를 확인하세요.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-21-IntegratePaymentinFlutterwithStripe_1.png)\n\n## 환경 설정하기\n\n의존성에 다음 패키지들을 추가하세요:\n\n```yaml\nflutter_stripe: ^5.0.0\nflutter_dotenv: ^5.0.2\nhttp: ^0.13.5\n```\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 마크다운 형식으로 변경해주세요.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-21-IntegratePaymentinFlutterwithStripe_2.png)\n\nStripe 비밀 키를 .env 파일에 다음과 같이 넣어주세요:\n\n```js\nSTRIPE_SECRET = sk_test_39Aops3ZvLRexxxxxxxxxxx\n```\n\npubspec.yaml에 .env 경로를 자산에 추가해주세요.\n\n\n<div class=\"content-ad\"></div>\n\n\nassets:\n- assets/.env\n\n\n귀하의 .env 파일을 .gitignore에 추가하십시오.\n\n\n#Dotenv\n.env\n\n\nmain.dart\n\n\n<div class=\"content-ad\"></div>\n\n저희 앱은 단순한 홈 페이지와 결제 모달이 표시되는 버튼이 있는 페이지가 있어요.\n\n이곳은 우리의 결제 기능입니다:\n\n세 가지 간단한 단계로 나누어 보겠습니다.\n\n1단계: 결제 의도 생성 - 우리는 지불할 금액과 통화를 정의하는 createPaymentIntent 함수로 지불 의도를 만들어 시작합니다.\n\n<div class=\"content-ad\"></div>\n\n우리는 화폐와 금액을 100으로 곱한 후 Flutter_stripe에 의해 double로 변환될 때 값이 유지되도록 몸체를 포함한 Stripe에 POST 요청을 보냅니다. 그에 대한 응답으로 Stripe는 결제 의도를 다시 보내줍니다. STEP 2에서 이를 사용하여 우리의 지불 시트를 초기화할 것입니다.\n\n## STEP 2: 지불 시트 초기화\n\n7~15행에서 makePayment 함수에서 지불 시트를 초기화합니다. 여기에는 우리가 카드 세부 정보를 기입하고 지불할 지불 시트 모달을 생성할 것입니다.\n\n우리는 이전 단계에서 결제 의도로부터 얻은 client_secret를 전달합니다. 여기에서는 스타일을 포함한 다양한 매개변수에 액세스할 수 있습니다. 이를 통해 우리는 어두운 테마를 선택할 수 있습니다!\n\n<div class=\"content-ad\"></div>\n\n## 단계 3: 결제 시트 표시하기\n\n마지막 단계는 모달 시트를 표시하는 것입니다.\n\n이것으로 세 번째이자 마지막 단계가 끝났습니다.\n\n팁: 결제가 성공하였을 때 또는 결제 처리 중에 오류가 발생한 경우와 같이 사용자에게 추가 응답을 알림 대화상자 형식으로 추가할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n끝났어요! 플러터 애플리케이션에 Stripe 통합이 완료되었습니다.\n\n앱을 론칭할 준비가 되셨다면 대시보드에서 테스트 모드에서 라이브 모드로 전환하고 Stripe의 지시에 따라 진행하면 됩니다.\n\n질문이나 의견이 있으시면 언제든지 알려주세요 💬, 이 기사가 유용했다면 👏👏을 눌러주시기를 잊지 마세요.\n\n여기서 전체 소스 코드를 구할 수 있어요.","ogImage":{"url":"/assets/img/2024-06-21-IntegratePaymentinFlutterwithStripe_0.png"},"coverImage":"/assets/img/2024-06-21-IntegratePaymentinFlutterwithStripe_0.png","tag":["Tech"],"readingTime":3},{"title":"Flutter 애니메이션 종합 가이드","description":"","date":"2024-06-21 22:15","slug":"2024-06-21-FlutterAnimationsComprehensiveGuide","content":"\n이 기사에서는 플러터 애니메이션에 대해 자세히 설명하고 여러 예제와 함께 다루어보겠습니다. 이 기사를 끝까지 읽으면 다양한 복잡성을 갖는 애니메이션을 플러터 앱에 추가할 수 있을 것입니다. 또한 플러터에서 제공하는 다양한 접근 방법 중에서 여러분의 애니메이션 목표에 가장 적합한 것을 알게 될 것입니다. 그럼 바로 시작해 봅시다!\n\n![Flutter Animations](/assets/img/2024-06-21-FlutterAnimationsComprehensiveGuide_0.png)\n\n## 목차:\n\n- 소개\n- 암시적 애니메이션 - AnimatedFoo 위젯\n- 암시적 애니메이션 - TweenAnimationBuilder 위젯\n- 명시적 애니메이션 - FooTransition 위젯\n- AnimationController\n- 명시적 애니메이션 - AnimatedBuilder 위젯\n- 명시적 애니메이션 - AnimatedWidget 클래스\n- 올바른 애니메이션 접근 방법 선택하기\n- 서드파티 패키지를 사용한 애니메이션\n\n<div class=\"content-ad\"></div>\n\n## TL;DR\n\n이 튜토리얼에서 모든 애니메이션의 코드를 DartPad에서 볼 수 있어요. 코드를 손대면서 실험해보세요.\n\n최근에는 이 튜토리얼을 요약한 트위터 스레드도 올렸어요. 한 번 확인해보세요.\n\n# 소개\n\n<div class=\"content-ad\"></div>\n\n플러터 앱에서 애니메이션은 기본적으로 두 가지 유형으로 볼 수 있어요: 그리기 기반 애니메이션과 코드 기반 애니메이션이에요. 그리기 기반 애니메이션은 애니메이션된 그래픽, 벡터, 캐릭터 또는 \"그려진\" 모든 것을 말해요. 한편, 코드 기반 애니메이션은 위젯 레이아웃 및 스타일(리스트, 색상, 텍스트 등)에 중점을 두었어요. 이 글의 끝에는 그리기 기반 애니메이션에 대해 간략히 다뤄볼 거에요. 그러나 그들은 보통 3rd party 프레임워크/패키지를 사용하여 달성되므로, 우리는 코드 기반 애니메이션에보다 초점을 맞출 거예요. 코드 기반 애니메이션은 제한적이라는 의미가 아니라, 그 반대로 플러터 애니메이션을 통해 완전히 멋진, 창의적이고 매우 복잡한 애니메이션을 만들 수 있어요. 3rd party 패키지가 필요하지 않아요!\n\n플러터의 코드 기반 애니메이션에는 암시적 애니메이션 및 명시적 애니메이션이 두 가지 유형이 있어요. 이러한 유형 각각에서 준비된 위젯을 사용하거나 직접 위젯을 만들 수 있어요. 각 유형에 대해 몇 가지 예제와 함께 더 자세히 알아보겠어요.\n\n# 1. 암시적 애니메이션\n\n맨 위로 이동하기 👆🏼\n\n<div class=\"content-ad\"></div>\n\n가장 간단하고 사용하기 쉬운 애니메이션입니다. 값만 변경하면 애니메이션이 트리거되고, Flutter가 모든 것을 자동으로 처리해줍니다.\n\n## 1.1 준비된 위젯으로 암묵적 애니메이션\n\n이들은 AnimatedFoo 위젯이라고 불립니다. 여기서 Foo는 애니메이션 속성을 나타냅니다. 대부분은 이미 알고 사용하는 위젯의 애니메이션 버전입니다. 예를 들어 Container/AnimatedContainer, Padding/AnimatedPadding, Positioned/AnimatedPositioned 등이 있습니다.\n\n예를 들어, 다음 애니메이션을 확인해보세요:\n\n<div class=\"content-ad\"></div>\n\n<img src=\"https://miro.medium.com/v2/resize:fit:930/1*cjoraoQHodaUhNx7z2n1aA.gif\" />\n\n이 애니메이션은 AnimatedContainer, AnimatedPositioned 및 AnimatedDefaultTextStyle 위젯만을 사용하여 구현되었습니다. 지속 시간 값을 지정하고 변경 가능한 변수를 제공하면 끝입니다!\n\n```js\nAnimatedPositioned(\n  top: selectedItemIndex * itemHeight,\n  left: 0,\n  right: 0,\n  duration: const Duration(milliseconds: 200),\n  curve: Curves.easeInOut,\n  child: //...\n),\n//...\nAnimatedContainer(\n  duration: const Duration(milliseconds: 200),\n  curve: Curves.easeInOut,\n  decoration: BoxDecoration(\n    color: selectedItemIndex == i ? yellow : pink,\n    border: Border.all(\n      color: selectedItemIndex == i\n          ? Colors.white\n          : Colors.transparent,\n      width: 2,\n    ),\n  ),\n  child: AnimatedDefaultTextStyle(\n    duration: const Duration(milliseconds: 200),\n    style: TextStyle(\n      color: selectedItemIndex == i\n          ? Colors.black\n          : Colors.white,\n    ),\n    child: const Text('Featured!'),\n  ),\n),\n```\n\n그리고 간단히 각 목록 항목은 아래와 같은 onTap 메서드가 있는 InkWell 위젯으로 래핑되어 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nonTap: () => setState(() => selectedItemIndex = i),\n```\n\n이렇게 하면 애니메이션을 트리거할 수 있어요!\n\n여기 사용 가능한 AnimatedFoo 위젯 전체 목록이 있어요.\n\n따라서 우리는 AnimatedFoo 위젯을 투명도, 패딩, 정렬, 위치와 같은 속성용으로 가지고 있어요. 하지만 다른 속성을 애니메이션화하고 싶을 때 어떡하나요? 그럼 여전히 쉽고 빠르게 사용하고 싶어요.\n\n<div class=\"content-ad\"></div>\n\n## 1.2. TweenAnimationBuilder를 사용한 암시적 애니메이션\n\n화면 맨 위로 이동 👆🏼\n\nTweenAnimationBuilder를 사용하면 Tween 클래스를 사용하여 모든 위젯의 속성을 암시적으로 애니메이트할 수 있습니다. Tween 클래스의 이름은 \"Between\"에서 따왔습니다. 기본적으로 애니메이트해야 할 시작 및 끝 값을 제공합니다. 그리고 TweenAnimationBuilder 위젯의 빌더는 애니메이션 값으로 제공되며 이 값을 해당 빌더에서 반환하는 위젯의 어떤 속성에 적용할 수 있습니다.\n\n다음은 예시 애니메이션입니다:\n\n<div class=\"content-ad\"></div>\n\n아래는 해당 코드입니다:\n\n```js\nTweenAnimationBuilder(\n  duration: const Duration(milliseconds: 200),\n  tween: Tween<double>(begin: 0.01, end: _sliderValue),\n  child: Container(\n    decoration: BoxDecoration(\n      //...\n    ),\n    child: Slider(\n      value: _sliderValue,\n      min: 0.01,\n      onChanged: (value) {\n        setState(() => _sliderValue = value);\n      },\n    ),\n  ),\n  builder: (BuildContext context, double? value, Widget? child) {\n    return ClipRect(\n      child: BackdropFilter(\n        filter: ImageFilter.blur(\n          sigmaX: 40 * (value ?? 0.01),\n          sigmaY: 40 * (value ?? 0.01),\n        ),\n        child: child,\n      ),\n    );\n  },\n);\n```\n\n\\_sliderValue 변수는 0.01에서 1로 변경됩니다. 따라서 각 값의 변경마다 애니메이션이 트리거되며 BackdropFilter 위젯의 sigmaX 및 sigmaY 속성을 위한 새 값으로 다시 빌더 함수가 재구성됩니다. (0 값을 주면 BackdropFilter 위젯이 웹에서 오류를 발생시키기 때문에 0.01을 사용했습니다.)\n\n<div class=\"content-ad\"></div>\n\nTweenAnimationBuilder의 child 매개변수를 사용하여 더 나은 성능을 위해 빌더를 활용하고 있어요. 이 child는 애니메이션이 트리거될 때마다 다시 빌드하는 대신 한 번만 다시 빌드되어요.\n\n좋아요, 쉬운 내용은 끝났습니다. 이제 본격적인 내용을 시작해볼까요?\n\n# 2. 명시적 애니메이션\n\n맨 위로 돌아가기 👆🏼\n\n<div class=\"content-ad\"></div>\n\n암시적 애니메이션에서 AnimatedFoo 또는 TweenAnimationBuilder 위젯 내부의 값만 변경하면 애니메이션이 트리거되었던 것을 기억하시나요? 그러나 명시적 애니메이션은 \"명시적으로\" 애니메이트할 때까지 애니메이션을 트리거하지 않습니다. 애니메이션을 시작하고 어떻게 애니메이트할지 및 AnimationController를 사용하여 애니메이션을 \"제어\"하는 방법을 알려주어야 합니다.\n\n명시적 애니메이션 역시 암시적 애니메이션과 유사하게 사용하기 쉬운 위젯과 사용자 정의 수준이 추가된 위젯이 준비되어 있어 자유롭게 사용할 수 있습니다!\n\n그런데, AnimationController가 무엇인지 궁금하시죠? 이를 사용하는 명시적 애니메이션 위젯에 대해 알아보기 전에 먼저 AnimationController에 대해 학습해 보겠습니다.\n\n## AnimationController\n\n<div class=\"content-ad\"></div>\n\n위로 이동 👆🏼\n\n```js\nAnimationController({\n  double? value,\n  this.duration,\n  this.reverseDuration,\n  this.debugLabel,\n  this.lowerBound = 0.0,\n  this.upperBound = 1.0,\n  this.animationBehavior = AnimationBehavior.normal,\n  required TickerProvider vsync,\n})\n```\n\n이전에 언급했듯이 AnimationController를 사용하면 애니메이션을 \"제어\"할 수 있습니다. 그를 위해서는 vsync 값이 TickerProvider 유형이 필요합니다. Ticker는 기본적으로 Flutter의 프레임 렌더링을 추적하고 컨트롤러가 해당 티커를 따라가서 지정된 기간 내에 '애니메이션'할 수 있도록 허용하며, 기본적으로 0과 1인 lowerBound 및 upperBound 값 사이에서 선형으로 값들을 생성합니다.\n\n결과적으로, AnimationController를 사용하면 다음을 할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n- forward()을 호출하여 애니메이션을 앞으로 재생합니다.\n- reverse()를 호출하여 애니메이션을 역방향으로 재생합니다.\n- stop()을 호출하여 애니메이션을 멈춥니다.\n- repeat()을 호출하여 애니메이션을 가시 상태인 한 계속 반복합니다.\n- reset()을 호출하여 애니메이션을 lowerBound로 재설정합니다.\n- 값을 설정합니다.\n- isAnimating, isCompleted, isDismissed 등과 같이 애니메이션의 상태를 알아내기 위해 다양한 get 함수에 액세스합니다.\n\n자, 이 멋진 놈을 사용하여 실제 작업을 확인해 보겠습니다 🎬\n\n## 2.1. 준비된 위젯을 사용한 명시적 애니메이션\n\n맨 위로 이동 👆🏼\n\n<div class=\"content-ad\"></div>\n\n그들은 FooTransition 위젯이라고 불립니다. 이 때 Foo는 위젯의 애니메이션 속성입니다. 일부는 당신이 사용하는 일반 위젯의 애니메이션 가능한 위젯들입니다. 예를 들어, AlignTransition, PositionedTransition가 있습니다.\n\n이 애니메이션을 확인해보세요:\n\n![animation](https://miro.medium.com/v2/resize:fit:1400/1*GYCKdoQEUQeblnBoyoEHjQ.gif)\n\n이것은 AlignTransition 및 RotationTransition 위젯을 사용하여 달성되었습니다.\n\n<div class=\"content-ad\"></div>\n\n코드 분석:\n\n- 10번 줄 및 17번 줄: AnimationController를 초기화하고 정의합니다.\n- AnimationController의 vsync 값 (19번 줄)은 SingleTickerProviderStateMixin(9번 줄)에서 가져온 값입니다. 이 mixin은 우리에게 이야기한 TickerProvider를 제공합니다. 또한 위젯이 보이는 상태일 때만 애니메이션이 실행되도록 보장합니다.\n- 11번 줄 및 22번 줄: AlignTransition 위젯의 Animation을 초기화하고 정의합니다 (51번 줄). AlignmentGeometry 유형의 Tween을 사용하여 애니메이션을 정의합니다. 결국, 애니메이션은 Alignment.centerLeft에서 Alignment.centerRight로 애니메이션될 것임을 알려주고 Tween의 animate 메서드를 호출하여 이 애니메이션을 AnimationController와 연결한 후 AlignmentGeometry 유형의 Animation을 반환합니다. 이렇게 하면 AnimationController의 하한 및 상한이 아니라 Tween의 시작 및 종료 값 사이에서 애니메이션이 작동합니다.\n\n- 12번 줄 및 32번 줄: RotationTransition 위젯의 회전 속성(turns)의 애니메이션을 초기화하고 정의합니다 (53번 줄). 따라서 0부터 2까지의 시작 및 종료 값이 있으므로, 애니메이션이 끝나면 위젯은 두 번 회전할 것입니다.\n- 20번 줄: AnimationController에 반복을 호출하여 애니메이션이 계속되도록 만듭니다. 그리고 reverse를 true로 설정하면 애니메이션이 순방향으로 시작하여 반대로, 다시 순방향으로, ... 이렇게 반복됩니다.\n- 42번 줄: 위젯의 상태가 dispose되는 시점에 AnimationController를 폐기(dispose)합니다. 메모리 누수를 방지하기 위해 AnimationController를 dispose하는 것은 항상 중요합니다!\n\n하지만 걱정하지 마세요. 조금의 연습으로 매우 쉬워지고 익숙해질 것입니다!\n\n<div class=\"content-ad\"></div>\n\n가능한 모든 FooTransition 위젯 목록입니다:\n\n암시적 애니메이션에서 AnimatedFoo 위젯이 애니메이션 목적에 충분하지 않을 때 어떻게 했는지 기억하나요? AnimatedFoo 위젯으로 처리되지 않은 속성을 애니메이션화하기 위해 TweenAnimationBuilder를 사용했습니다. 비슷하게, 명시적 애니메이션에서는 AnimatedBuilder 위젯을 사용하여 어떤 위젯 속성을 애니메이션화할 수 있습니다. 또는 더 나아가서 직접 FooTransition을 만들기 위해 AnimatedWidget 클래스를 사용할 수도 있습니다!\n\n## 2.2 AnimatedBuilder 위젯을 사용한 명시적 애니메이션\n\n맨 위로 이동 👆🏼\n\n<div class=\"content-ad\"></div>\n\n다음 애니메이션을 확인해보세요:\n\n![Animation](https://miro.medium.com/v2/resize:fit:1400/1*whGvEQM5o0b4W0hZIkgu_A.gif)\n\nGradientTransition 위젯이 없죠? 그럼 어떻게 만들었을까요? AnimatedBuilder 위젯을 이용했어요! 여기에 코드가 있어요:\n\n우리는 AnimationController를 초기화하고 정의했고 이를 AnimatedBuilder 위젯의 애니메이션 값으로 사용했어요. 이제 AnimatedBuilder는 컨트롤러의 값이 변경될 때마다 \"다시 빌드(build)\"되고 빌더를 호출하여 업데이트된 \\_controller.value 값을 가진 새 위젯을 반환해요. 이로써 그라데이션이 애니메이션 되게 만들었어요.\n\n<div class=\"content-ad\"></div>\n\n물론, AnimationController의 lowerBound 및 upperBound 값 이외의 것을 원한다면, 자체 Animation을 만들고 AnimationController에 연결한 다음 AnimatedBuilder 위젯에 전달할 수 있습니다.\n\n```js\n_animation = Tween<double>(begin: 0, end: 0.5).animate(_controller);\n//...\nAnimatedBuilder(\n  animation: _animation,\n  builder: (context, child) {\n     //... 값 사용하기: _animation.value\n  }\n)\n```\n\n또한 AnimatedBuilder 위젯의 child 매개변수를 사용하여 성능을 향상시킬 수 있습니다. 이렇게 하면 매번 애니메이션 값이 변경될 때마다 다시 구축되지 않습니다.\n\n아직 따라오고 있나요? 조금만 더 힘내세요! 거의 끝났습니다!\n\n<div class=\"content-ad\"></div>\n\n이제 한 걸음 더 나아가서 AnimatedWidget 클래스를 사용하여 우리만의 FooTransition 위젯을 만들어보겠습니다!\n\n## 2.3 AnimatedWidget 클래스를 사용한 명시적 애니메이션\n\n맨 위로 이동 👆🏼\n\n아주 비밀스러운 비밀을 하나 알려줄게요. 어떤 FooTransition 위젯의 소스 코드로 가 보세요, 무엇을 보게 될까요?\n\n<div class=\"content-ad\"></div>\n\n![Image 1](/assets/img/2024-06-21-FlutterAnimationsComprehensiveGuide_1.png)\n\n😱 It extends an AnimatedWidget class, and from what we see, the Animation type parameter (in this case turns) is passed as a listenable to the super class:\n\n![Image 2](/assets/img/2024-06-21-FlutterAnimationsComprehensiveGuide_2.png)\n\nAnd the AnimatedWidget is basically a StatefulWidget! So we can do the exact same!\n\n<div class=\"content-ad\"></div>\n\n우리만의 GradientTransition 위젯을 만들어봅시다:\n\n```js\nclass GradientTransition extends AnimatedWidget {\n  final Animation<double> stop;\n\n  const GradientTransition({\n    Key? key,\n    required this.stop,\n  }) : super(key: key, listenable: stop);\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      height: 100,\n      decoration: BoxDecoration(\n        gradient: LinearGradient(\n          colors: const [purple, pink, yellow],\n          stops: [0, stop.value, 1],\n        ),\n      ),\n    );\n  }\n}\n```\n\n그리고 사용하기 위해서는 AnimationController를 그대로 전달하면 됩니다:\n\n```js\nGradientTransition(stop: _controller),\n```\n\n<div class=\"content-ad\"></div>\n\n그게 다야!\n\n여기까지 버텨내 왔다면, 매우 간단한 것부터 매우 복잡한 것까지 다양한 플러터 애니메이션을 만들기에 충분한 지식을 가지고 있습니다. 필요한 건 조금의 연습뿐이며, 하늘이 한계입니다!\n\n# 적절한 애니메이션 접근 방식 선택\n\n맨 위로 이동 👆🏼\n\n<div class=\"content-ad\"></div>\n\n하지만 잠시만 기다려봐요. 위에서 다룬 여러 방법 중에서 어떤 애니메이션을 선택해야 하는지 어떻게 알 수 있을까요? 플러터(Flutter) 팀의 멋진 분들이 도와주기 위해 비디오와 의사결정 트리를 만들었어요. 제가 최대한 요약해 드릴게요.\n\n## 1. 그림 기반 vs. 코드 기반\n\n첫 번째 선택은 그림 기반 및 코드 기반 애니메이션 사이에서 이루어질 거예요. 이를 위해 자신에게 물어보세요. 만약 당신의 애니메이션이 그림처럼 더 비스무런가요(그림 기반 사용, 3rd party 패키지 사용, 곧 설명할 거예요) 아니면 레이아웃, 위젯, 위젯 스타일, 색상, 테두리, 텍스트 등과 관련이 있는가요(코드 기반 사용, 위에서 설명한 것)?\n\n## 2. 암시적(Implicit) vs. 명시적(Explicit)\n\n<div class=\"content-ad\"></div>\n\n다음 선택은 암시적 및 명시적 애니메이션 중 하나가 될 것입니다. 선택을 하는 데 고려해야 할 여러 기준이 있습니다:\n\n- 무한히 반복되는 애니메이션\n- 연속되지 않는 애니메이션: 애니메이션이 시작 지점으로 돌아가지 않음\n- 여러 위젯이 함께 애니메이션화되는 경우\n\n만약 애니메이션이 위의 기준 중 하나라도 가지고 있다면, 명시적 애니메이션을 사용해야 합니다.\n\n## 3. 내장 위젯 대 사용자 정의 위젯\n\n<div class=\"content-ad\"></div>\n\n마지막 선택 사항은 내장 위젯(AnimatedFoo 및 FooTransition 위젯)과 사용자 지정 위젯(TweenAnimationBuilder 및 AnimatedBuilder/AnimatedWidget) 사이에서 합니다. 이것은 이 목록을 보고 원하는 속성을 애니메이션화하기 위해 이미 내장된 위젯이 있는지 여부를 고려하는 것만큼 간단합니다. 해당 내장 위젯을 사용하거나 (그렇지 않으면 직접 생성)\n\n# 3rd Party 패키지를 사용한 애니메이션\n\n하지만 앱에서 그림을 기반으로 한 애니메이션을 사용하고 싶다면 어떨까요? 여기서는 코딩이 절약되었네요 🫢, 또한 플러터는 여기에서도 놀라울 정도로 좋습니다! Rive 및 Lottie와 같은 훌륭한 패키지들이 있어서 3rd party 애니메이션을 원활하게 통합하고 앱에 추가할 수 있습니다. 제공되는 애니메이션을 그래픽 디자이너/모션 그래픽 디자이너와 함께 사용하거나 커뮤니티에서 만든 애니메이션을 다운로드/구매하여 빠르고 쉽게 앱에 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n3rd party 패키지를 사용하여 Flutter에서 애니메이션을 만드는 데 관한 전용 기사를 작성할 예정이에요. 지금 당장 유용한 링크 몇 개를 공유해 드릴게요:\n\n- 사용 준비가 된 멋진 애니메이션을 볼 수 있는 Rive 커뮤니티 쇼케이스\n- Rive Flutter 패키지\n- 무료 LottieFiles 애니메이션\n- LottieFiles Flutter 패키지\n\n여기까지가 제 글이에요! 이 기사를 읽어 주셔서 감사합니다. 이것이 Flutter 앱에 애니메이션을 추가하고 싶을 때 여러분의 정보원이 되었으면 좋겠어요. 그럼 여러분도 애니메이션을 넣을 때 즐겁게 시도해 보세요!\n\nhttps://twitter.com/FlutterComm\n","ogImage":{"url":"/assets/img/2024-06-21-FlutterAnimationsComprehensiveGuide_0.png"},"coverImage":"/assets/img/2024-06-21-FlutterAnimationsComprehensiveGuide_0.png","tag":["Tech"],"readingTime":12},{"title":"Flutter에서 Bloc을 사용한 상태 관리 마스터하기 종합 가이드","description":"","date":"2024-06-21 22:13","slug":"2024-06-21-MasteringStateManagementinFlutterwithBlocAComprehensiveGuide","content":"\n소개\n\n상태 관리는 견고하고 유지보수가 용이한 플러터 애플리케이션을 구축하는 중요한 측면입니다. 플러터는 다양한 상태 관리 옵션을 제공하며, 상태를 관리하는 가장 인기 있는 강력한 라이브러리 중 하나인 flutter_bloc 패키지가 있습니다. 이 포괄적인 가이드에서는 Bloc를 사용한 상태 관리의 기본 개념을 탐색하고 시작하는 데 도움이 되는 자세한 예제를 제공합니다.\n\n![마스터링 플러터 Bloc를 이용한 상태 관리: 포괄적인 가이드](/assets/img/2024-06-21-MasteringStateManagementinFlutterwithBlocAComprehensiveGuide_0.png)\n\n# 플러터 Bloc이란 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\nflutter_bloc은 Flutter 애플리케이션의 상태를 관리하기 위해 BLoC (Business Logic Component) 패턴을 활용하는 라이브러리입니다. 이는 데이터 및 이벤트의 흐름을 처리하는 구조화된 방법을 제공하여 코드베이스를 더 조직화하고 유지보수하기 쉽게 만들어줍니다. Bloc은 프리젠테이션 레이어를 비즈니스 로직에서 분리함으로써 깨끗하고 확장 가능한 아키텍처를 장려합니다.\n\n# Flutter 프로젝트 설정하기\n\n예제에 들어가기 전에 새로운 Flutter 프로젝트를 설정하고 flutter_bloc 패키지를 종속성으로 추가해 봅시다. 이를 위해 다음 단계를 따라주세요:\n\n- 다음 명령어를 사용하여 새로운 Flutter 프로젝트를 생성합니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nflutter create my_bloc_app\n```\n\n2. 즐겨 사용하는 코드 편집기에서 프로젝트를 엽니다.\n\n3. pubspec.yaml 파일에 flutter_bloc를 추가하세요:\n\n```js\ndependencies:\n  flutter:\n    sdk: flutter\n  flutter_bloc: ^7.0.0\n```\n\n<div class=\"content-ad\"></div>\n\n4. 의존성을 가져와 설치하려면 `flutter pub get`을 실행하세요.\n\n# 카운터 앱 예제\n\n이제 Bloc을 사용하여 카운터의 상태를 관리하는 간단한 Flutter 앱을 만들어 보겠습니다. 이 예제에서는 Bloc을 설정하는 방법, 이벤트와 상태를 만드는 방법 및 BlocProvider를 만드는 방법을 보여줍니다.\n\n# 1. Bloc 만들기\n\n<div class=\"content-ad\"></div>\n\n프로젝트에서 Bloc을 위한 새 Dart 파일을 만드세요. counter_bloc.dart라고 이름 짓겠어요.\n\n```js\nimport 'package:flutter_bloc/flutter_bloc.dart';\n\n// 이벤트\nabstract class CounterEvent {}\n\nclass IncrementEvent extends CounterEvent {}\n\nclass DecrementEvent extends CounterEvent {}\n\n// 상태\nabstract class CounterState {}\n\nclass InitialState extends CounterState {}\n\nclass UpdatedState extends CounterState {\n  final int count;\n\n  UpdatedState(this.count);\n}\n\n// Bloc\nclass CounterBloc extends Bloc<CounterEvent, CounterState> {\n  CounterBloc() : super(InitialState());\n\n  @override\n  Stream<CounterState> mapEventToState(CounterEvent event) async* {\n    if (event is IncrementEvent) {\n      yield UpdatedState(state is UpdatedState ? (state as UpdatedState).count + 1 : 1);\n    } else if (event is DecrementEvent) {\n      yield UpdatedState(state is UpdatedState ? (state as UpdatedState).count - 1 : -1);\n    }\n  }\n}\n```\n\n# 2. UI 만들기\n\n이제 카운터 앱을 위한 간단한 UI를 만들어보세요. main.dart 파일에서 만들어보세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport 'package:flutter/material.dart';\nimport 'package:flutter_bloc/flutter_bloc.dart';\nimport 'counter_bloc.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: BlocProvider(\n        create: (context) => CounterBloc(),\n        child: MyHomePage(),\n      ),\n    );\n  }\n}\n\nclass MyHomePage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    final CounterBloc counterBloc = BlocProvider.of<CounterBloc>(context);\n\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Flutter Bloc Counter'),\n      ),\n      body: BlocBuilder<CounterBloc, CounterState>(\n        builder: (context, state) {\n          if (state is UpdatedState) {\n            return Center(\n              child: Column(\n                mainAxisAlignment: MainAxisAlignment.center,\n                children: <Widget>[\n                  Text(\n                    'Counter Value:',\n                    style: TextStyle(fontSize: 20),\n                  ),\n                  Text(\n                    '${state.count}',\n                    style: TextStyle(fontSize: 50),\n                  ),\n                  Row(\n                    mainAxisAlignment: MainAxisAlignment.center,\n                    children: <Widget>[\n                      FloatingActionButton(\n                        onPressed: () => counterBloc.add(IncrementEvent()),\n                        child: Icon(Icons.add),\n                      ),\n                      SizedBox(width: 20),\n                      FloatingActionButton(\n                        onPressed: () => counterBloc.add(DecrementEvent()),\n                        child: Icon(Icons.remove),\n                      ),\n                    ],\n                  ),\n                ],\n              ),\n            );\n          } else {\n            return Center(\n              child: CircularProgressIndicator(),\n            );\n          }\n        },\n      ),\n    );\n  }\n}\n```\n\n# 3. 앱 실행하기\n\n이제 다음을 실행하여 Flutter 앱을 실행할 수 있습니다:\n\n```js\nflutter run\n```\n\n<div class=\"content-ad\"></div>\n\n간단한 카운터 앱이 표시되어야 합니다. '증가' 및 '감소' 버튼이 있습니다. 앱의 상태는 CounterBloc을 사용하여 관리되며, UI는 상태 변경에 따라 업데이트됩니다.\n\n# 결론\n\n이 가이드에서는 flutter_bloc 패키지를 사용하여 Flutter에서 상태 관리의 기본을 탐구했습니다. Bloc를 설정하는 방법, 이벤트 및 상태를 생성하는 방법, 및 UI와 Bloc을 통합하는 방법을 보여주기 위해 간단한 카운터 앱을 만들었습니다.\n\nFlutter Bloc은 Flutter 애플리케이션에서 상태를 관리하는 강력한 도구이며, 프로젝트가 성장함에 따라 더 복잡한 시나리오에도 적용할 수 있습니다. BLoC 패턴을 따르고 비즈니스 로직을 UI와 분리함으로써 유지 관리 가능하고 확장 가능한 Flutter 앱을 구축할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 안내서가 플러터 Bloc을 시작하고 플러터 프로젝트에서 더 복잡한 상태 관리를 위한 기초를 제공하는 데 도움이 되기를 바랍니다. 즐거운 코딩 되세요!\n","ogImage":{"url":"/assets/img/2024-06-21-MasteringStateManagementinFlutterwithBlocAComprehensiveGuide_0.png"},"coverImage":"/assets/img/2024-06-21-MasteringStateManagementinFlutterwithBlocAComprehensiveGuide_0.png","tag":["Tech"],"readingTime":5},{"title":"Flutter 앱에 런처 아이콘 추가하는 단계별 가이드","description":"","date":"2024-06-21 22:12","slug":"2024-06-21-AStep-by-StepGuidetoAddingLauncherIconstoYourFlutterApp","content":"\n\n소개: 모바일 앱 개발 세계에서 시각적으로 매력적이고 인식하기 쉬운 런처 아이콘을 만드는 것은 사용자에게 지속적으로 영향을 줄 수 있는 중요한 요소입니다. 플러터(Flutter)는 구글의 네이티브 컴파일된 애플리케이션을 구축하는 UI 툴킷으로, 앱에 런처 아이콘을 추가하는 간단한 프로세스를 제공합니다.\n\n이 가이드에서는 당신의 플러터 앱이 설치되는 순간부터 돋보이도록 보장하기 위한 단계별 프로세스를 안내해 드리겠습니다.\n\n![아이콘 디자인 준비](/assets/img/2024-06-21-AStep-by-StepGuidetoAddingLauncherIconstoYourFlutterApp_0.png)\n\n## 단계 1: 아이콘 디자인 준비\n\n<div class=\"content-ad\"></div>\n\n기술적인 세부 정보에 들어가기 전에 잘 디자인된 런처 아이콘이 있는지 확인해주세요. Flutter에서 런처 아이콘의 권장 크기는 512x512 픽셀입니다. 아이콘이 앱의 본질을 명확하고 간결하게 시각적으로 나타내도록 해주세요.\n\n# 단계 2: 필요한 이미지 자산 생성\n\nFlutter는 런처 아이콘을 포함한 자산을 관리하기 위해 pubspec.yaml이라는 구성 파일을 사용합니다. 시작하려면 pubspec.yaml 파일에 다음 줄을 추가해주세요:\n\n```yaml\n\n<div class=\"content-ad\"></div>\n\nflutter:\n  assets:\n    - assets/\n\n프로젝트 디렉토리 내 \"assets\" 폴더에 아이콘 이미지를 넣어주세요.\n\n# 단계 3: Flutter Launcher Icons 패키지 설치\n\n다양한 플랫폼용 런처 아이콘을 생성하는 과정을 간소화하기 위해 \"flutter_launcher_icons\" 패키지를 사용할 수 있습니다. 다음 의존성을 pubspec.yaml 파일에 추가해주세요:\n\n<div class=\"content-ad\"></div>\n\nYAML\n\n```\ndev_dependencies:\n  flutter_launcher_icons: ^0.13.1\n\n\n터미널에서 `flutter pub get`을 실행하여 패키지를 가져오세요.\n\n# 단계 4: 런처 아이콘 구성하기\n\n<div class=\"content-ad\"></div>\n\n패키지를 설치한 후에는 `pubspec.yaml` 파일에 다음 줄을 추가하여 구성해야 합니다:\n\n```yaml\nflutter_icons:\n  android: true\n  ios: true\n  image_path: \"assets/icon/icon.png\"\n```\n\n\"assets/icon/icon.png\"을 사용자의 아이콘 이미지 경로로 변경해주세요.\n\n<div class=\"content-ad\"></div>\n\n# 단계 5: 플러터 런처 아이콘 명령 실행\n\n이제 필요한 파일을 생성하고 새 런처 아이콘으로 앱을 업데이트할 명령을 실행할 시간입니다. 터미널에서 다음 명령을 실행하세요:\n\n```bash\nflutter pub run flutter_launcher_icons:main\n```\n\n<div class=\"content-ad\"></div>\n\n이 명령어는 Android 및 iOS용 필요한 아이콘 파일을 생성합니다.\n\n# 단계 6: 앱 실행하기\n\n새로 생성된 런처 아이콘을 사용하여 Flutter 앱을 Android 및 iOS 기기 또는 에뮬레이터에서 실행하여 변경 사항이 적용되는지 확인하세요.\n\nFlutter 앱에 사용자 정의 런처 아이콘을 추가하는 것은 간단하면서도 효과적인 방법으로 세련되고 전문적인 사용자 경험을 제공할 수 있습니다. 이 단계를 따르고 디자인 세부 사항에 주의를 기울이면 앱에 대한 기억에 남는 첫인상을 만들어낼 수 있습니다. 런처 아이콘을 사용자 정의하는 것은 앱의 미적인 면을 개선할 뿐만 아니라, 모바일 애플리케이션의 경쟁적인 세계에서 강력한 브랜드 아이덴티티를 구축하는 데 도움이 됩니다.\n\n<div class=\"content-ad\"></div>\n\n제 트위터 팔로우해주세요 - https://twitter.com/Nikhilsomansah","ogImage":{"url":"/assets/img/2024-06-21-AStep-by-StepGuidetoAddingLauncherIconstoYourFlutterApp_0.png"},"coverImage":"/assets/img/2024-06-21-AStep-by-StepGuidetoAddingLauncherIconstoYourFlutterApp_0.png","tag":["Tech"],"readingTime":2},{"title":"플러터 앱 효율성 향상 여러 Futures를 동시에 처리하는 방법","description":"","date":"2024-06-21 22:10","slug":"2024-06-21-ImproveFlutterAppEfficiencyHandlingMultipleFuturesatOnce","content":"\n\n<img src=\"/assets/img/2024-06-21-ImproveFlutterAppEfficiencyHandlingMultipleFuturesatOnce_0.png\" />\n\n## 소개\n\nFlutter에서 여러 비동기 작업을 동시에 처리하면 앱의 성능과 응답성을 크게 향상시킬 수 있습니다. 로컬 저장소에서 사용자 이름과 이메일을 동시에 가져와야 한다고 상상해보세요. 전통적으로는 한 작업이 완료될 때까지 다음 작업을 시작하지 못할 수 있지만, 이를 더 효율적으로 수행할 수 있는 방법이 있습니다. 이 글에서는 Future.wait를 사용하여 두 개의 미래 함수를 동시에 호출하는 방법을 살펴보고 전통적인 방법과 성능상의 장점을 비교해보겠습니다.\n\n## 전통적인 방법\n\n<div class=\"content-ad\"></div>\n\n전통적인 방식부터 시작해봅시다. 이 방법에서는 각 비동기 작업을 순차적으로 실행합니다.\n\n```js\nvoid fetchUserData() async {\n  LocalStorage localStorage = LocalStorage();\n  try {\n    final username = await localStorage.fetchUserName();\n    final userEmail = await localStorage.fetchUserEmail();\n    print(\"Username: $username, Email: $userEmail\");\n  } catch (error) {\n    print(\"Error: $error\");\n  }\n}\n```\n\n## 더 나은 방법: Future.wait 사용하기\n\n전통적인 방법에서 두 번째 작업은 첫 번째 작업이 완료될 때까지 기다리므로 소중한 시간이 낭비될 수 있습니다. 대신, Future.wait를 사용하여 두 작업을 동시에 실행하여 프로세스를 크게 가속화할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 예시 코드\n\n```js\nvoid fetchUserData() async {\n  LocalStorage localStorage = LocalStorage();\n  final usernameFuture = localStorage.fetchUserName();\n  final userEmailFuture = localStorage.fetchUserEmail();\n\n  try {\n    final results = await Future.wait([usernameFuture, userEmailFuture]);\n    final username = results[0];\n    final userEmail = results[1];\n    print(\"사용자 이름: $username, 이메일: $userEmail\");\n  } catch (error) {\n    print(\"오류 발생: $error\");\n  }\n}\n```\n\n## 작동 방식\n\n- Futures 시작: 두 futures (usernameFuture와 userEmailFuture)를 동시에 시작합니다.\n- 완료 대기: Future.wait는 두 futures의 완료를 기다리고 그 결과를 리스트로 반환합니다.\n- 결과 처리: 두 작업이 완료되면 결과를 함께 처리합니다.\n\n<div class=\"content-ad\"></div>\n\n## 성능 비교\n\n전통적인 방법\n\n전통적인 방법에서 총 소요 시간은 두 작업의 합계입니다.\n\n- 사용자 이름 가져오기 (예: 2초)\n- 사용자 이메일 가져오기 (예: 2초)\n\n<div class=\"content-ad\"></div>\n\n총 소요 시간: 4초\n\nFuture.wait 사용하기\n\nFuture.wait 메서드를 사용하면 두 작업이 동시에 실행됩니다.\n\n- 사용자 이름 가져오기 (예: 2초)\n- 사용자 이메일 가져오기 (예: 2초)\n\n<div class=\"content-ad\"></div>\n\n총 시간: 2초 (둘 중 늦게 완료되는 시간)\n\n## 속도 차이\n\nFuture.wait 사용하면 두 작업이 완료되는 시간을 절반으로 줄일 수 있어서 성능 상의 혜택이 명확히 나타납니다. 이 방법은 여러 개의 독립적인 비동기 작업을 처리할 때 특히 유용합니다.\n\n## 결론\n\n<div class=\"content-ad\"></div>\n\n플러터에서 Future.wait를 사용하여 동시에 여러 미래 함수를 호출하는 것은 앱 성능을 크게 향상시킬 수 있는 강력한 기술입니다. 비동기 작업을 동시에 실행함으로써 전체 소요 시간을 줄일 수 있어 앱을 더 반응적이고 효율적으로 만들 수 있습니다. 이 방법은 단순할 뿐만 아니라 매우 효과적이며, 플러터에서 여러 비동기 작업을 처리하는 데 가장 좋은 방법 중 하나입니다.\n\n## 추가 팁\n\n- 에러 처리: Future.wait를 사용할 때 강력한 에러 처리를 보장하십시오. 단일 실패가 전체 작업에 영향을 줄 수 있습니다.\n- 확장성: 이 방법은 두 개 이상의 미래에 대해 잘 확장되며, 여러 동시 작업에 대한 성능이 더욱 향상됩니다.\n\nFuture.wait를 도입함으로써 플러터 앱의 성능을 향상시켜 사용자 경험을 더 부드럽고 빠르게 제공할 수 있습니다. 다음에 여러 미래를 처리해야 할 때 Future.wait를 사용해보고 성능 차이를 확인해보세요!\n\n<div class=\"content-ad\"></div>\n\n친절한 톤으로 번역하면 다음과 같습니다.\n\n유저 경험을 우선시하고 깔끔한 코드 관행을 유지하는 전문 Flutter 개발자를 찾고 계신가요? 흥미로운 협업을 위해 여기 있습니다. 제 전체 프로필을 확인하고 LinkedIn에서 저와 소통해보세요.\n\n제 블로그가 도움이 되었기를 바라요! 궁금한 점이나 피드백이 있으시면 아래에 댓글을 남겨주세요.","ogImage":{"url":"/assets/img/2024-06-21-ImproveFlutterAppEfficiencyHandlingMultipleFuturesatOnce_0.png"},"coverImage":"/assets/img/2024-06-21-ImproveFlutterAppEfficiencyHandlingMultipleFuturesatOnce_0.png","tag":["Tech"],"readingTime":3}],"page":"13","totalPageCount":28,"totalPageGroupCount":2,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}