{"pageProps":{"posts":[{"title":"상속 위젯에 대한 심층 분석 Flutter 개발자가 알아야 할 모든 것","description":"","date":"2024-06-21 20:56","slug":"2024-06-21-InheritedWidgetsIn-depth","content":"\n\n![image](/assets/img/2024-06-21-InheritedWidgetsIn-depth_0.png)\n\n안녕하세요 여러분! 👋\n\n여러분이 Theme.of(context) 또는 MediaQuery.of(context)를 작성할 때 뒷면에서 무슨 일이 일어나는지 궁금했던 적이 있나요?🤔 그렇지 않다면, 이 글에서는 InheritedWidgets에 대해 모든 것을 배우고 재미난 사실 몇 가지를 알게될 거예요 😉\n\n이 블로그는 초심자와 경험 많은 개발자 모두를 위해 작성되었으므로 모두가 이로부터 혜택을 받을 수 있습니다. 그러니 더 이상 말이 필요 없죠, 시작해봅시다 😄\n\n<div class=\"content-ad\"></div>\n\n## 목차:\n\n- 상속 위젯의 필요성\n- 상속 위젯의 구현\n- 상속 위젯이란\n- 따를 규칙 몇 가지\n- 데모\n- 결론\n\n# 상속 위젯의 필요성\n\n우리는 모두 플러터에서 모든 것이 위젯이라고 들어본 적이 있습니다. 이 문장은 사실이 아니지만, 위젯은 플러터 앱을 개발할 때 중요한 역할을 합니다.\n\n<div class=\"content-ad\"></div>\n\n플러터(Flutter)에서는 StateLessWidget, StatefulWidget, RenderObjectWidget 등 다양한 유형의 위젯이 있어요. 하지만 대부분의 경우에는 StatelessWidget과 StatefulWidgets를 주로 사용해요. 그럼 InheritedWidget은 어디에 있을까요? 🤔\n\nInheritedWidget의 필요성을 이해하기 위해 이 위젯 트리의 예제를 살펴보겠어요:\n\n![이미지](/assets/img/2024-06-21-InheritedWidgetsIn-depth_1.png)\n\n이제 함께 살펴봐요:\n\n<div class=\"content-ad\"></div>\n\n- CustomText 위젯에서 userName 속성에 액세스하고 싶어요. 그러나 이 속성에 액세스하기 위해서는 userName 속성을 모든 위젯의 생성자 안에 전달해야 해요 🏗️\n- 여기서 보면, CustomText로 들어가기 위해 단지 3개의 위젯에서 userName을 전달해야 했어요. 하지만, 이를 위해 많은 표준 코드를 작성해야 했죠. 또한, 모든 위젯에 의존성을 만들어야 했는데, 이는 좋지 않은 방법이에요.\n\n따라서, 모든 위젯의 생성자에 데이터를 전달하는 방법보다 꼼꼼한 💪 해결책이 필요했어요 🏗️\n\n알아챈대로, InheritedWidget이 이 문제를 해결하는 방법이에요 😉 그렇다면, InheritedWidget이 이 문제를 해결하는 데 어떻게 도움이 되는 걸까요? 이 질문에 대한 대답을 드리기 위해, 아래 그래프📈를 보고 제대로 이해해보세요.\n\n<img src=\"/assets/img/2024-06-21-InheritedWidgetsIn-depth_2.png\" />\n\n<div class=\"content-ad\"></div>\n\n호출할 수 있는 데이터에 대해 알고 싶을 때, 상위 레벨에 InheritedWidget을 넣을 수 있다는 점을 확인할 수 있어요. 멋있죠?😃\n\n이제 코드에서 이를 어떻게 구현할 수 있는지 살펴보겠어요.\n\n# Inherited Widget의 구현\n\n- InheritedWidget을 생성하려면 클래스를 InheritedWidget으로 확장해야 합니다.\n- 그런 다음 updateShouldNotify 메서드를 구현해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n한 예를 통해 이 개념을 익혀봅시다:\n\n여기에는 이야기할 몇 가지 새로운 내용이 있습니다:\n\n- 생성자에서 자식 위젯을 가져오고 updateShouldNotify 메서드: 이 메서드는 InheritedWidget 내부의 데이터가 변경될 때마다 호출됩니다. 이 메서드가 true를 반환하면, 이 InheritedWidget에 의존하는 자식 위젯들이 다시 빌드될 것을 의미합니다. 이 메서드에서는 이전 InheritedWidget을 가져와서 InheritedWidget 내부의 데이터가 변경되었는지 확인할 수 있습니다. 너무 복잡해 보이나요? 걱정하지 마세요. 이에 대해 깊이 있는 이야기를 나중에 할 거에요 😉\n- static UserDataInheritedWidget? of(BuildContext context): InheritedWidget로부터 데이터를 가져오고 싶을 때는 이 메서드를 호출하여 InheritedWidget 내부의 데이터를 가져올 수 있습니다.\n\n이제 Theme.of(context)나 MediaQuery.of(context) 같은 코드를 작성할 때마다 실제로는 해당 InheritedWidget로부터 데이터를 가져오고 있었음을 알게 되었죠.\n\n<div class=\"content-ad\"></div>\n\n이제 자식 위젯에서 데이터를 가져오는 방법을 살펴보겠습니다. \n\nInheritedWidget의 참조를 가져오려면 StatelessWidget의 경우 build 메서드나 StatefulWidget의 경우 didChangeDependencies 메서드에 다음과 같이 이 문장을 작성할 수 있습니다:\n\n![image](/assets/img/2024-06-21-InheritedWidgetsIn-depth_3.png)\n\n![image](/assets/img/2024-06-21-InheritedWidgetsIn-depth_4.png)\n\n<div class=\"content-ad\"></div>\n\n이제 InheritedWidget을 사용하는 방법을 알게 되었으니, 이에 대해 더 깊이 파보겠습니다🤖.\n\n# Inherited Widget 깊이 알아보기\n\n다음 라인을 살펴보세요: UserDataInheritedWidget.of(context)?.userName\n\n- 이 라인에서는 Widget 트리의 맨 위에 위치한 UserDataInheritedWidget의 참조를 얻고 있습니다.\n- 따라서 .of(context)를 작성할 때마다, 당신의 위젯(우리의 경우 DemoWidget)이 UserDataInheritedWidget의 청취자(listener👂)로 등록됩니다.\n- 따라서 UserDataInheritedWidget 내부의 값이 바뀔 때마다, 이에 종속된 위젯들이 다시 빌드됩니다. 이에 대한 예시는 마지막에 볼 것입니다.\n\n<div class=\"content-ad\"></div>\n\n## InheritedWidget에서 데이터에 액세스 할 때 지켜야 할 몇 가지 규칙:\n\n- StatefulWidget의 initState 내에서 .of(context) 메서드를 호출하는 것을 피해야 합니다. InheritedWidget의 구성이 변경되어도 위젯이 다시 빌드되지 않기 때문에 ❌\n- build, didChangeDependencies 또는 didUpdateWidget 내에서 .of(context) 메서드를 호출할 수 있습니다 ✅\n\n다음은 .of(context) 메서드를 호출할 수 있는 예시입니다:\n\n![이미지](/assets/img/2024-06-21-InheritedWidgetsIn-depth_5.png)\n\n<div class=\"content-ad\"></div>\n\n알겠어요. 이 라이프사이클 메서드 안에서 .of(context) 메서드를 호출할 수 있지만, 어떻게 작동하는지 궁금하시군요? 🤔\n\n이에 대한 답변을 하기 위해서, 우선 didChangeDependencies에서 어떤 종속성을 다루고 있는지 알아보겠습니다. 🤔💭\n\n답은 이 종속성이 dependOnInheritWidgetOfExactType 함수에 의해 생성된다는 점입니다. 이 함수는 InheritedWidget의 static of(BuildContext context) 메서드를 만들 때 구현되었습니다.\n\n그러므로 InheritedWidget 내부의 데이터💽가 변경될 때마다 didChangeDependencies 메서드가 호출될 것입니다.\n\n<div class=\"content-ad\"></div>\n\nbuild 메소드 내부에서도 .of(context)을 호출할 수 있어요. 성능 차이가 크지 않기 때문에 didChangeDependencies 내부에 이 메소드를 사용하는 것이 좋아요. 더 큰 앱에는 많은 위젯이 있기 때문에요.\n\n이제 InheritedWidgets에 대해 깊게 알았으니, 의존하는 위젯을 다시 빌드할 수 있도록 InheritedWidget의 구성을 변경하는 방법을 살펴봐요.\n\n# 데모:\n\n- 먼저, InheritedWidget을 확장하는 ColorWidget을 만들어봅시다:\n\n<div class=\"content-ad\"></div>\n\n- 여기서는 위젯의 생성자 안에 color와 함께 onColorChanged 메서드를 전달하고 있습니다.\n- updateShouldNotify에서는 색이 변경되었는지 확인하고 있습니다. 그리고 변경되었을 경우, true를 반환하여 이 InheritedWidget에 의존하는 위젯들이 다시 빌드되도록 합니다.\n\n이제 이 InheritedWidget을 위젯 트리에 삽입하는 StatefulWidget의 코드를 살펴보겠습니다:\n\n- 이 StatefulWidget에서는 색을 설정하는 ColorWidget을 삽입하는데, 이는 InheritedWidget입니다. ElevetedButton을 누르면 색을 녹색으로 설정합니다.\n- 상태 객체의 color 변수가 InheritedWidget에 전달됩니다.\n\n이제 Column 내에 있는 ColorCardWidget의 코드를 살펴보겠습니다:\n\n<div class=\"content-ad\"></div>\n\n여기서 StatelessWidget을 보면 InheritedWidget에서 색상🎨을 받아오고 있습니다. 따라서 색상의 값이 변경될 때마다 ColorCardWidget이 다시 빌드됩니다.\n\n이제 코드를 실행하면 다음과 같은 출력을 볼 수 있어요:\n\n![Image](https://miro.medium.com/v2/resize:fit:748/0*glpgY0XHAbtBZWPz.gif)\n\n그러므로 .of(context) 메서드를 작성함으로써 해당 위젯을 InheritedWidget의 리스너로 등록하여 InheritedWidget 내부 데이터가 변경될 때 자체를 다시 빌드할 수 있다는 것을 확인할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n위 예제를 직접 시도하고 싶다면 제 GitHub 저장소를 확인해보세요:\n\n이 글을 통해 상속 위젯에 대해 어떤 통찰을 얻을 수 있었기를 바랍니다. 이 부분 중 이해하지 못한 부분이 있다면 의견란이나 제 LinkedIn 및 Twitter에서 질문해주세요.\n\n## 계속해서 박수를 보내주세요 👏 (박수를 50번 치는 것으로 감사의 표시를 할 수 있습니다)\n\n## 참고문헌:","ogImage":{"url":"/assets/img/2024-06-21-InheritedWidgetsIn-depth_0.png"},"coverImage":"/assets/img/2024-06-21-InheritedWidgetsIn-depth_0.png","tag":["Tech"],"readingTime":6},{"title":"다양한 Firebase 프로젝트로 Android 및 iOS용 Flutter 빌드 플래버 구성 방법","description":"","date":"2024-06-21 20:53","slug":"2024-06-21-BuildflavorsinFlutterAndroidandiOSwithdifferentFirebaseprojectsperflavor","content":"\n\n\n[업데이트 2020년 3월 7일]\n- iOS와 Android에서 다른 플레이버용 앱 아이콘 설명 추가함\n\n\n다양한 시도와 오류 끝에, 특히 iOS에서 플레이버가 작동하도록 하기 위해 이 기사를 쓰기로 결정했습니다. 그래서 곧 바로 플러터에서 플레이버 빌드에 대해 자세히 알아보겠습니다.\n\n## 플레이버가 필요한 이유\n\n플레이버는 일반적으로 앱을 dev 및 prod와 같은 다른 환경으로 빌드하는 데 사용됩니다.\n예를 들어,\n- 앱의 개발 버전은 dev.api.myapp.com에 위치한 API 호스트를 가리키도록 할 수 있음\n- 그리고 앱의 프로덕션 버전은 api.myapp.com을 가리키도록 할 수 있음\n\n\n<div class=\"content-ad\"></div>\n\n이 값들을 변수로 하드 코딩하고 각 환경에 앱을 수동으로 빌드하는 대신, 올바른 방법은 플레이버를 사용하고 빌드 시간 구성으로 이러한 값들을 제공하는 것입니다.\n\n재밌게도, 이 기사는 어떻게 다른 API 호스트를 처리하는지에 대한 사용 사례를 다루지 않습니다. 또 다른 기사가 이를 잘 다룬다고 생각하며, 그 정보를 반복하고 싶지는 않았어요. 동일한 내용에 대한 자세한 내용은 \"Flutter Ready to Go\"를 참조해주세요. (이 기사에서 다루는 내용은 다음 섹션에서 설명합니다)\n\n거의 모든 앱을 출시하는 사람들이 플레이버를 사용해야 한다고 생각하지만, 대부분의 사람들이 더 오래 동안 사용하지 않는다는 것을 알아봤어요. 보통 초기 설정 관성은 나중에 처리할 수 있을만큼 충분하기 때문에, 최종적으로 개발자들이 의도치 않게 시간을 많이 낭비하게 된다는 것을 알 수 있어요. 유감스럽게도, Flutter의 경우 아직도 *그렇게* 간단하게 설정되지 않으므로, 이 기사가 도움이 되기를 바랍니다.\n\n## Flutter 플레이버 문서에 대한 한 가지 참고사항\n\n<div class=\"content-ad\"></div>\n\n플러터 플레이버 지원은 공식 문서에서 아직 매우 잘 문서화되어 있지 않습니다. 이 문제는 아래의 세 가지 기사를 가리키고 있습니다.\n\n- Flutter 앱의 플레이버 생성(Android 전용)\n- Flutter ready to go (Android 전용)\n- Flutter에 플레이버 주입(Android 및 iOS)\n\nAndroid 설정은 상당히 간단합니다. 반면 iOS 설정은 자세한 부분이 부족하고 따라가기 어려웠습니다. 그래서 이 기사를 쓴 이유가 두 가지 있습니다.\n\n- 위의 기사들 위에 쌓아서, 각기 다른 플레이버에 대해 Firebase 프로젝트를 설정하는 방법도 설명합니다.\n- iOS 플레이버 설정에 대해 더 깊게 파고들어 단계를 더 명확하게 설명하려고 했습니다. 그래서 당신이 이 작업을 수행하는 데 내가 한 것 만큼의 시간을 들이지 않으셔도 되도록 했습니다.\n\n<div class=\"content-ad\"></div>\n\n## 이 튜토리얼의 접근 방식\n\n두 가지 플레이버(dev, prod)가 있는 샘플 앱을 만들어 볼 것입니다.\n각 단계 후에 커밋이 있으므로 코드 차이를 살펴보고 모든 변경 사항을 이해할 수 있습니다. 물론 상세한 지침도 제공하겠습니다. 이미 있는 앱에 대해서도 쉽게 이 지침을 사용할 수 있을 것입니다.\n\n샘플 앱은 여기 있습니다\n\n멋지죠? 그럼 이제 단계를 따라 출발해봅시다...\n\n<div class=\"content-ad\"></div>\n\n## 단계 1: 기본 플러터 앱 초기화\n\n기본 플러터 프로젝트를 생성하려면 flutter create flavor_test을 실행하세요. 특별한 것은 없어요.. 이것은 샘플 앱의 첫 번째 커밋입니다.\n\n![이미지](/assets/img/2024-06-21-BuildflavorsinFlutterAndroidandiOSwithdifferentFirebaseprojectsperflavor_0.png)\n\n## 단계 2: 앱을 Firebase에 연결하도록 구성하기\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-21-BuildflavorsinFlutterAndroidandiOSwithdifferentFirebaseprojectsperflavor_1.png\" />\n\nFirebase 콘솔에서 iOS 및 Android 앱을 만들고 각각 GoogleService-Info.plist 및 google-services.json을 다운로드하세요. Firebase를 Flutter 프로젝트에 추가하는 자세한 지침은 여기에서 확인할 수 있습니다 - https://firebase.google.com/docs/flutter/setup\n\n이 단계에서는 main.dart 파일을 업데이트하여 로컬이 아닌 Firebase Realtime DB에 카운터를 저장하였습니다. Firebase Realtime DB를 콘솔을 통해 설정하고 쓰기 액세스를 허용하는 보안 규칙을 추가해주세요.\n\n이 커밋 후 앱은 아래와 같이 나타납니다 -\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-21-BuildflavorsinFlutterAndroidandiOSwithdifferentFirebaseprojectsperflavor_2.png)\n\n다음 링크로 변경 사항을 확인할 수 있습니다 — \n\nCode Diff : Step 1 to Step 2\nhttps://github.com/animeshjain/flavor_test/compare/step_1_init...step_2_firebase\n\n\n## 단계 3: Android에 빌드 플레이버 추가하기\n\n<div class=\"content-ad\"></div>\n\n운영 환경용 새 Firebase 프로젝트를 만들 수 있습니다\n\n![이미지](/assets/img/2024-06-21-BuildflavorsinFlutterAndroidandiOSwithdifferentFirebaseprojectsperflavor_3.png)\n\n<div class=\"content-ad\"></div>\n\n프로젝트에 Android 앱도 만들어서 google-services.json 파일을 다운로드하고 손쉽게 접근할 수 있도록 해주세요. 곧 앱에 추가할 예정이에요.\n\n재미로, --flavor 플래그를 사용하여 앱을 실행하려고 시도할 때 플러터가 무슨 말을 하는지 확인해봅시다.\n\n![이미지](/assets/img/2024-06-21-BuildflavorsinFlutterAndroidandiOSwithdifferentFirebaseprojectsperflavor_4.png)\n\napp/build.gradle에 flavors를 추가하고 다음과 같이 되어야 해요.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-21-BuildflavorsinFlutterAndroidandiOSwithdifferentFirebaseprojectsperflavor_5.png\" />\n\n개발 플레이버는 기본 applicationId로 com.kanily.flavortest를 사용하며, 프로덕션 플레이버는 프로덕션 플레이버 정의에서 정의된 flavor별 applicationId인 com.kanily.flavortest.prod를 사용할 것입니다. 또한 AndroidManifest.xml에서 앱 이름을 하드 코딩하는 대신에 사용 중인 app_name이라는 문자열 리소스를 정의했습니다. 마지막으로, google-services.json은 소스 폴더 하위에 flavor와 일치하는 이름의 서브폴더에 넣을 수 있습니다. Firebase 문서에서 -\n\n<img src=\"/assets/img/2024-06-21-BuildflavorsinFlutterAndroidandiOSwithdifferentFirebaseprojectsperflavor_6.png\" />\n\n따라서 이러한 설정으로 관리할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n- 각각 다른 플레이버용 앱 ID를 사용하여 장치에 여러 플레이버를 동시에 설치할 수 있습니다.\n- 각기 다른 애플리케이션 이름을 사용하여 사용자/테스터/개발자가 쉽게 구별할 수 있습니다.\n- 각 플레이버가 고유한 Firebase 프로젝트를 가리키게 됩니다 (파일을 플레이버 이름과 동일한 폴더에 배치하는 규칙에 따라 자동으로 처리됩니다).\n\n이제 다음 명령어를 사용하여 앱을 실행할 수 있습니다.\n\nflutter run --flavor dev 또는 flutter run --flavor prod\n\n이제 두 앱을 장치에 설치하고 병렬로 실행할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n위의 코드 변경 사항을 확인하려면 다음과 같이 코드를 보시면 됩니다 —\n\n```js\n코드 변경 내역: Step 2부터 Step 3로\nhttps://github.com/animeshjain/flavor_test/compare/step_2_firebase...step_3_android_flavors\n```\n\n## 단계 4: iOS에 빌드 플레이버 추가\n\niOS 플레이버를 설정하는 것은 더 복잡할 수 있습니다. 또한, iOS 구성은 대부분 XCode UI를 사용하여 진행되며 텍스트 편집기에서 설정 파일을 편집하는 것이 아닙니다 😱. 이 설명은 말로 설명하기에 상당히 복잡하기 때문에 이해를 돕기 위해 모든 조치를 녹화하고 스크린캐스트 GIF로 제공했습니다. 그러니 물 한 잔 마시고 허리띠를 매고 준비하세요…\n\n<div class=\"content-ad\"></div>\n\n플러터 런 명령을 사용하여 iOS 장치/시뮬레이터를 대상으로 실행해 봅시다.\n\n\nflutter run --flavor dev\n\n\n![이미지](/assets/img/2024-06-21-BuildflavorsinFlutterAndroidandiOSwithdifferentFirebaseprojectsperflavor_7.png)\n\n이제 custom schemas라는 것을 설정해야 하는 것 같아요. Xcode를 열고 ios/Runner.xcworkspace를 열어 보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n그리고, 여기에 개발자라고 불리는 사용자 지정 체계를 설정하는 방법이 있습니다...\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*tctD2CuUZuCV4FcFIXXddw.gif)\n\n이제 다시 flutter run --flavor dev를 실행합니다...\n\n![image](/assets/img/2024-06-21-BuildflavorsinFlutterAndroidandiOSwithdifferentFirebaseprojectsperflavor_8.png)\n\n<div class=\"content-ad\"></div>\n\n플러터는 Debug-dev 나 유사한 이름의 빌드 구성을 기대한다고 에러 메시지에 나와 있네요. 이 빌드 구성들을 만들어봅시다...\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*XsDo_Kv4UPiS-Qeix9YEEA.gif)\n\n다시 flutter run --flavor dev을 시도해봅니다...\n\n![image](/assets/img/2024-06-21-BuildflavorsinFlutterAndroidandiOSwithdifferentFirebaseprojectsperflavor_9.png)\n\n<div class=\"content-ad\"></div>\n\n그럼 이제 잘 되었네요. 그러나 지금은 빌드 구성을 사용자 정의하지 않았기 때문에 앱은 이전과 동일한 구성으로 실행 중입니다. 기본 빌드 구성 및 빌드 스키마를 prod로 변경해보겠습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*3TPzQMrFbtwBoe3-seCDhg.gif)\n\n빌드 구성을 복제했기 때문에 개발 구성은 아직 기존 스키마(이제 prod로 변경된)에 연결되어 있습니다. 이것도 수정해 봅시다...\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*qXSwfOJfHFWmBgnb2Rqzrw.gif)\n\n<div class=\"content-ad\"></div>\n\n이제 두 개의 스키마가 각각의 빌드 구성에 연결되었습니다. 이제 스키마별로 사항을 사용자 정의할 수 있습니다. 우선 두 스키마를 위해 앱 번들 식별자를 다르게 변경해 봅시다. 안드로이드에서 우리의 프로덕션 애플리케이션 식별자는 com.kanily.flavortest.prod이었는데, iOS의 번들 식별자는 안드로이드의 애플리케이션 식별자와 동일합니다. 그래서 우리의 프로덕션 번들 식별자를 com.kanily.flavortest.prod로 변경해 봅시다...\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*huXgYB4sDD092hq75PAnyg.gif)\n\n또한 앱을 위해 서로 다른 표시 이름을 사용하고 싶습니다. 그러나 대상의 빌드 설정에는 표시 이름 매개변수가 없습니다. 따라서 사용자 정의 매개변수를 만들고 대신 사용하도록 하겠습니다...\n\n[2020년 5월 5일 업데이트. Stanford Lin님의 댓글 감사합니다]\n\n<div class=\"content-ad\"></div>\n\n플러터 iOS 빌드 방법에 변경 사항이 있어서 이 비디오는 조금 오래됐습니다. 아마 다음과 같은 오류가 발생할 것입니다.\n\n```js\nCould not find the built application bundle at build/ios/iphoneos/Runner.app\n```\n\n이 오류를 피하려면 일반 설정 탭의 표시 이름 속성에 `$(APP_DISPLAY_NAME)`을 추가하는 대신 Info.plist 파일을 업데이트하여 새로운 속성을 포함해야 합니다.\n\n```js\n<dict>\n...\n<key>CFBundleDisplayName</key>\n<string>$(APP_DISPLAY_NAME)</string>\n...\n</dict>\n```\n\n<div class=\"content-ad\"></div>\n\n일반 설정 탭에서 더 이상 Display Name 속성을 변경할 필요가 없습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*VJhfqIi3-Y365nfM3D99BQ.gif)\n\n마지막으로, 빌드 구성에 따라 다른 GoogleServices-Info.plist를 사용하는 방법을 찾아야 합니다. 이를 실행시간에 앱 시작 시 수행하거나 Firebase 사용을 시작할 때 적합한 구성 파일을 명시적으로 지정하여 Firebase를 초기화하는 것을 제안하는 해결책도 있습니다(https://firebase.google.com/docs/projects/multiprojects에 Firebase 문서에서도 같은 것을 제안합니다). 하지만 저는 앱 번들이 생성될 때 올바른 파일이 자동으로 사용되도록 기본 위치에 올바른 파일을 빌드 시간에 복사하는 다른 옵션을 선호합니다.\n\n이를 달성하기 위해 먼저 각 플레이버용 GoogleServices-Info.plist 파일을 다음과 같이 별도의 폴더에 유지합니다...\n\n<div class=\"content-ad\"></div>\n\n맨처음 코드 조각을 Markdown 글서식에 맞게 변경해볼게요. \n\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*2QT0g0XVi72daZz3tYJdmw.gif)\n\n\nXCode에 config 폴더를 명확히 복사한 후 해당 위치에서 명령줄 또는 탐색기를 통해 XCode에 명시적으로 드래그앤드랍 해주세요. XCode가 명시적으로 추가하기 전까지는 프로젝트 참조에 추가되지 않습니다. 프로젝트 디렉토리에 보관된 파일/폴더는 기본적으로 더해지지 않아요. 위 단계를 따른 후 XCode 폴더 구조는 아래와 같이 보일 거예요.\n\n\n![이미지](/assets/img/2024-06-21-BuildflavorsinFlutterAndroidandiOSwithdifferentFirebaseprojectsperflavor_10.png)\n\n\n이제 빌드 프로세스에 단계를 추가하여 각각의 GoogleServices-Info.plist 파일이 올바른 위치로, 즉 Runner 디렉토리 내부로 복사되도록 해야 합니다. 이는 새로운 Run script 빌드 단계를 타겟에 추가함으로써 성취할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*5tcidmX4DPIvskHpgtec0Q.gif\" />\n\n위의 스크립트를 사용했어요...\n\n[2020년 6월 23일 업데이트. Dharma Teja Nuli님의 코멘트에 감사드립니다.]\n\n여기서 코멘트를 편리하게 요약하면:\n\n<div class=\"content-ad\"></div>\n\n그리고 이제 다 끝났어요! 이제 flutter run --flavor dev 또는 flutter run --flavor prod 명령어를 실행할 수 있어요.\n\n그러면 iOS 기기 / 시뮬레이터에 각각 다른 Firebase DB에 연결되는 별도의 앱이 설치될 거예요!\n\n```js\n코드 차이: 단계 3에서 단계 4로\nhttps://github.com/animeshjain/flavor_test/compare/step_3_android_flavors...step_4_ios_flavors\n```\n\n<div class=\"content-ad\"></div>\n\n## 단계 5: 다른 플레이버용 앱 아이콘 추가\n\n가끔은 다른 이름만으로는 충분하지 않을 수 있습니다. 기기에 여러 가지 플레이버가 설치된 경우 시각적으로 명확하게 구분하기 위해 다른 앱 아이콘을 원할 수도 있습니다.\n\n지금까지 Flutter에서 제공하는 기본 런처 아이콘을 사용했지만, 단계를 설명하기 위해 프로드 및 데브를 위한 두 개의 아이콘을 만들었습니다.\n\n- Android용 단계\n\n<div class=\"content-ad\"></div>\n\n기본값으로 고려하는 플레이버에 따라 이 아이콘 중 하나는 android/app/src/main/res 폴더로 이동하여 모든 크기에 대한 기존 ic_launcher.png 파일을 대체할 수 있습니다. 저는 default 폴더에 개발자 아이콘을 넣을 것입니다.\n\n![아이콘 이미지](/assets/img/2024-06-21-BuildflavorsinFlutterAndroidandiOSwithdifferentFirebaseprojectsperflavor_11.png)\n\n프로드 플레이버의 경우, 몇몇 분들이 추측하신 것처럼, 우리는 간단히 prod 폴더에 res 폴더를 만들어 모든 크기별 폴더를 추가하면 됩니다. 그러면 디렉토리 구조는 다음과 같이 보일 것입니다.\n\n![디렉토리 구조](/assets/img/2024-06-21-BuildflavorsinFlutterAndroidandiOSwithdifferentFirebaseprojectsperflavor_12.png)\n\n<div class=\"content-ad\"></div>\n\n참고: 개발 앱 아이콘 파일을 특정히 dev 폴더에 넣을 수도 있습니다. 안드로이드는 먼저 플레이버별 디렉토리를 찾아보고, 그곳에서 찾을 수 없는 경우에는 기본 디렉토리인 main으로 되돌아가 그 안에 있는 리소스를 사용합니다.\n\n안드로이드에서 아이콘은 다음과 같이 보입니다 -\n\n![Android Icon](/assets/img/2024-06-21-BuildflavorsinFlutterAndroidandiOSwithdifferentFirebaseprojectsperflavor_13.png)\n\n- iOS 설정 방법\n\n<div class=\"content-ad\"></div>\n\n위에서 JSON 파일의 내용을 복사하고 붙여넣기하여 manifest.json 파일을 만들고 해당 파일을 등록합니다.\n\n<div class=\"content-ad\"></div>\n\n마침내 모든 설명을 마쳤습니다. 이 튜토리얼이 iOS에서 특히 플레이버를 설정하는 데 어떤 혼란을 해소하는 데 도움이 되길 바랍니다. 아래에는 이 작업을 수행하려고 노력하면서 발견한 유용한 기사/자료들이 있습니다.\n\n## 부가 자료\n\n- 플러터 플레이버(및 빌드 모드 — 디버그, 릴리스, 프로파일)가 해당 OS별 빌드 구조로 매핑되는 방식을 설명하는 깃헙 풀 리퀘스트 — [링크](https://github.com/flutter/flutter/pull/11734)\n- XCode가 앱을 빌드하는 방법에 대한 심화 학습을 원하는 분들을 위한 자료 — [링크](https://www.youtube.com/watch?v=yazY8hCO46s)\n- XCode 빌드를 실행하는 플러터 커맨드 라인 도구 소스 코드 — [링크](https://github.com/flutter/flutter/blob/27b058a41473d5ef136f3874ed6f0a2ccaf969d0/packages/flutter_tools/lib/src/ios/xcodeproj.dart)\n- Dart 코드에서 플레이버를 구현하는 방법에 대한 설명 — [링크](https://medium.com/flutter-community/flutter-ready-to-go-e59873f9d7de)","ogImage":{"url":"/assets/img/2024-06-21-BuildflavorsinFlutterAndroidandiOSwithdifferentFirebaseprojectsperflavor_0.png"},"coverImage":"/assets/img/2024-06-21-BuildflavorsinFlutterAndroidandiOSwithdifferentFirebaseprojectsperflavor_0.png","tag":["Tech"],"readingTime":11},{"title":"플러터에서 Expansion Tile 사용 방법","description":"","date":"2024-06-21 20:50","slug":"2024-06-21-ExpansionTileinFlutter","content":"\n![Image](/assets/img/2024-06-21-ExpansionTileinFlutter_0.png)\n\n안녕하세요 독자 여러분, 이 기사에서는 플러터 앱에 확장 가능한 목록 타일을 추가하는 방법에 대해 알아보겠습니다. 이것은 우리가 목록 뷰에서 목록 타일을 사용하는 방식과 유사합니다. 따라서 시작하기 전에 오늘 어떤 것을 달성하고 싶은지 먼저 살펴보겠습니다.\n\n![Image](https://miro.medium.com/v2/resize:fit:700/0*SAyKoBHKRJMTrECc.gif)\n\n## 확장 타일이란 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n플러터에서의 확장 타일은 이미 리스트 뷰에서 사용해본 ListTile과 거의 비슷하지만, 유일한 차이점은 사용자가 타일을 확장하거나 축소하여 타일에 대한 자세한 정보를 볼 수 있다는 것입니다. 위 이미지에서 확장 타일의 예시를 볼 수 있어요.\n\n확장 타일은 주로 ListTile에 몇 가지 추가 정보를 추가하고 싶지만, 그 정보가 처음에는 필요하지 않을 때 사용됩니다. 사용자가 보고 싶을 때 볼 수 있어요.\n\n## ListView 만들기\n\n확장 리스트 뷰를 만들기 전에 기본 리스트 뷰와 리스트 타일만 있는 리스트 뷰를 만들어 볼게요. 이를 위해, 그냥 단순히 ListView.builder()를 scaffold의 body에 추가하면 돼요.\n\n<div class=\"content-ad\"></div>\n\n```js\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n        appBar: AppBar(\n          title: const Text(\"\"),\n        ),\n        body: ListView.builder(\n          itemCount: 10,\n          itemBuilder: (context, index) {\n            return Card(\n              child: ListTile(\n                title: Text(\"사용자 $index\"),\n              ),\n            );\n          },\n        ));\n  }\n}\n```\n\n이제 리스트 뷰는 다음과 같이 보일 것입니다.\n\n![ExpansionTile in Flutter](/assets/img/2024-06-21-ExpansionTileinFlutter_1.png)\n\n## ListView에 ExpansionTile 추가하기\n\n<div class=\"content-ad\"></div>\n\n기본 목록 보기가 준비되었습니다. 목록의 항목을 확장 가능하게 만들려면 ListTile 위젯을 ExpansionTile로 변경하면 됩니다.\n\n```js\nbody: ListView.builder(\n    itemCount: 10,\n    itemBuilder: (context, index) {\n      return Card(\n        child: ExpansionTile(\n          title: Text(\"User $index\"),\n        ),\n      );\n    },\n```\n\nExpansionTile로 ListTile을 변경한 후에는 타일 끝에 화살표가 있는 것을 볼 수 있습니다. 이제 타일을 클릭하면 타일이 확장되고 강조 표시되며 화살표 방향이 바뀝니다.\n\n<img src=\"https://miro.medium.com/v2/resize:fit:600/0*dQi0SoELCTbErmxf.gif\" />\n\n<div class=\"content-ad\"></div>\n\n하지만 타일이 확장되면 아무것도 보이지 않습니다. 이는 ExpansionTile에서 children 매개변수를 제공해야하기 때문입니다. 우리가 children으로 전달하는 어떤 위젯이든, 타일을 확장할 때 표시됩니다.\n\n```js\n return Card(\n  child: ExpansionTile(\n    title: Text(\"User $index\"),\n    children: [\n      Text(\"Name : User $index\"),\n      Text(\"Phone No: $index\"),\n      const Text(\"isAdmin: No\")\n    ],\n  ),\n);\n```\n\n<img src=\"https://miro.medium.com/v2/resize:fit:700/0*SAyKoBHKRJMTrECc.gif\" />\n\n이제 우리의 목표가 달성되었습니다. 확장 가능한 자식을 가진 리스트 뷰입니다. 그러나 확장된 타일이 멋지지 않습니다. 그렇기 때문에 ExpansionTile 생성자에는 타일을 더 매력적으로 만들기 위해 사용할 수 있는 다른 매개변수들이 몇 가지 있습니다. 한 번 살펴보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n## ExpansionTile 위젯의 매개변수\n\n생성자\n\n```js\n ExpansionTile({\n  Key? key,\n  Widget? leading,\n  required Widget title,\n  Widget? subtitle,\n  void Function(bool)? onExpansionChanged,\n  List<Widget> children = const <Widget>[],\n  Widget? trailing,\n  bool initiallyExpanded = false,\n  bool maintainState = false,\n  EdgeInsetsGeometry? tilePadding,\n  CrossAxisAlignment? expandedCrossAxisAlignment,\n  Alignment? expandedAlignment,\n  EdgeInsetsGeometry? childrenPadding,\n  Color? backgroundColor,\n  Color? collapsedBackgroundColor,\n  Color? textColor,\n  Color? collapsedTextColor,\n  Color? iconColor,\n  Color? collapsedIconColor,\n  ShapeBorder? shape,\n  ShapeBorder? collapsedShape,\n  Clip? clipBehavior,\n  ListTileControlAffinity? controlAffinity,\n})\n```\n\n위는 ExpansionTile 위젯의 생성자이며 대부분의 매개변수는 ListTile과 유사하지만 ExpansionTile에서 새로운 매개변수가 있습니다.\n\n<div class=\"content-ad\"></div>\n\nonExpansionChanged\n사용자가 타일을 클릭할 때 호출되는 함수입니다. 이 함수에는 Boolean isExpanded 매개변수가 전달됩니다. 사용자가 타일을 확장했다면 값은 true가 되고, 사용자가 타일을 축소했다면 값은 false가 됩니다.\n\n```js\nonExpansionChanged: (value) {\n  ScaffoldMessenger.of(context).showSnackBar(SnackBar(\n      content: Text(\n        \"$index 타일 ${value ? \"확장됨\" : \"축소됨\"}\")));\n},\n```\n\n<img src=\"https://miro.medium.com/v2/resize:fit:420/0*FcINjFqIXC2ok_q6.gif\" />\n\ninitiallyExpanded\n위젯의 첫 번째 빌드 시에 타일을 기본적으로 확장하는 경우 true를 전달하는 부울 변수입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nExpansionTile(\n  title: Text(\"사용자 $index\"),\n  initiallyExpanded: index.isEven, // 모든 짝수 타일이 기본적으로 확장됨\n  children: [\n    Text(\"이름: 사용자 $index\"),\n    Text(\"전화번호: $index\"),\n    const Text(\"isAdmin: 아니요\")\n  ],\n),\n```\n\n![ExpansionTileinFlutter_2](/assets/img/2024-06-21-ExpansionTileinFlutter_2.png)\n\nmaintainState\n타일이 확장되고 축소될 때 체일드의 상태를 유지할지 여부를 지정합니다.\n\ntrue인 경우 타일이 축소될 때도 체일드는 트리에 유지됩니다. false인 경우 (기본값) 타일이 축소될 때 체일드가 트리에서 제거되고 확장 시에 다시 생성됩니다.\n\n<div class=\"content-ad\"></div>\n\nexpandedCrossAxisAlignment\n타일이 확장될 때 각 자식의 정렬을 지정합니다.\n\n확장된 타일의 내부에서는 [children]을 위해 [Column] 위젯을 사용하며, crossAxisAlignment 매개변수는 [Column]으로 직접 전달됩니다.\n\n```js\nreturn Card(\n  child: ExpansionTile(\n    title: Text(\"User $index\"),\n    maintainState: true,\n    expandedCrossAxisAlignment: CrossAxisAlignment.end,\n    children: [\n      Row(\n        children: const [Text(\"This is a Row\")],\n      ),\n      Text(\"Name: User $index\"),\n      Text(\"Phone No: $index\"),\n      const Text(\"isAdmin: No\")\n    ],\n  ),\n);\n```\n\n<div class=\"content-ad\"></div>\n\nexpandedAlignment\n이 속성은 확장된 타일 내부의 자식 요소를 정렬합니다.\n\n```js\nExpansionTile(\n                title: Text(\"User $index\"),\n                maintainState: true,\n                expandedAlignment: Alignment.centerLeft,\n                children: [\n                  Text(\"Name : User $index\"),\n                  Text(\"Phone No: $index\"),\n                  const Text(\"isAdmin: No\")\n                ],\n              ),\n```\n\nchildrenPadding\n이름에서 알 수 있듯이 확장된 위젯 내 자식 요소 주위의 여백입니다.\n\nbackgroundColor 및 collapsedBackgroundColor\n이것은 타일이 축소되거나 확장되었을 때 적용되는 배경색입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nreturn Card(\n              child: ExpansionTile(\n                title: Text(\"사용자 $index\"),\n                maintainState: true,\n                backgroundColor: Colors.red,\n                collapsedBackgroundColor: Colors.yellow,\n                children: [\n                  Text(\"이름: 사용자 $index\"),\n                  Text(\"전화번호: $index\"),\n                  const Text(\"관리자 권한: 아니요\")\n                ],\n              ),\n            );\n```\n\n<img src=\"https://miro.medium.com/v2/resize:fit:424/0*DuYJu0s-ySdjEb9V.gif\" />\n\ntextColor, collapsedTextColor, iconColor, collapsedIconColor\n이것은 타일이 확장되었거나 축소될 때 텍스트와 아이콘의 색상입니다.\n\n```js\nreturn Card(\n              child: ExpansionTile(\n                title: Text(\"사용자 $index\"),\n                maintainState: true,\n                textColor: Colors.red,\n                collapsedTextColor: Colors.yellow,\n                iconColor: Colors.red,\n                collapsedIconColor: Colors.yellow,\n                children: [\n                  Text(\"이름: 사용자 $index\"),\n                  Text(\"전화번호: $index\"),\n                  const Text(\"관리자 권한: 아니요\")\n                ],\n              ),\n            );\n```\n\n<div class=\"content-ad\"></div>\n\nshape 및 collapsedShape\n이 매개변수를 사용하여 타일이 축소 또는 확장될 때 모양을 변경할 수 있습니다.\n\n```js\nreturn Padding(\n              padding: const EdgeInsets.all(8.0),\n              child: ExpansionTile(\n                title: Text(\"User $index\"),\n                maintainState: true,\n                backgroundColor: Colors.red,\n                collapsedBackgroundColor: Colors.yellow,\n                shape: const RoundedRectangleBorder(\n                    borderRadius: BorderRadius.all(Radius.circular(20))),\n                collapsedShape: const RoundedRectangleBorder(\n                    borderRadius: BorderRadius.all(Radius.circular(50))),\n                children: [\n                  Text(\"이름: User $index\"),\n                  Text(\"전화번호: $index\"),\n                  const Text(\"관리자: 아니요\")\n                ],\n              ),\n            );\n```\n\n![이미지](https://miro.medium.com/v2/resize:fit:424/0*NELwUxIbDKIkdFS-.gif)\n\ncontrolAffinity\n일반적으로 확장 화살표 아이콘을 타일의 선행 또는 후행 가장자리에 강제로 배치하는 데 사용됩니다.\n\n<div class=\"content-ad\"></div>\n\n기본적으로 [controlAffinity]의 값은 [ListTileControlAffinity.platform]이며, 이는 확장 화살표 아이콘이 타일의 뒷부분에 표시된다는 것을 의미합니다.\n\n## 결론\n\n요약하면, ExpansionTile 위젯은 Flutter 앱에서 확장 가능하고 접을 수 있는 콘텐츠를 생성하는 데 유용한 도구입니다. 몇 줄의 코드로 깔끔한 사용자 인터페이스를 만들어 사용자들이 쉽게 더 많은 정보에 액세스할 수 있도록 할 수 있습니다.\n\n이 기사가 ExpansionTile 위젯에 대한 유용한 소개를 제공하고 여러분이 자신의 Flutter 개발 프로젝트에 이를 통합하도록 영감을 주었기를 바랍니다.\n\n<div class=\"content-ad\"></div>\n\n# 함께해요\n\n이 글을 읽어 주셔서 감사합니다. 만약 마음에 드셨다면 더 많은 글을 읽어보고 저를 팔로우해주세요.\n\nhttps://www.linkedin.com/in/aakashpamnani/\n","ogImage":{"url":"/assets/img/2024-06-21-ExpansionTileinFlutter_0.png"},"coverImage":"/assets/img/2024-06-21-ExpansionTileinFlutter_0.png","tag":["Tech"],"readingTime":9},{"title":"플러터와 다트에서 코드 난독화 신비로운 코드 이해하기","description":"","date":"2024-06-21 20:49","slug":"2024-06-21-ObfuscationinFlutterandDartMysteriouscodes","content":"\n\n![image](/assets/img/2024-06-21-ObfuscationinFlutterandDartMysteriouscodes_0.png)\n\n안녕하세요, 이 글에서는 플러터와 다트 코드 난독화, 플러터의 중요한 주제 중 하나를 배우게 됩니다.\n\n먼저, 난독화가 무엇인지 알아보겠습니다.\n\n난독화는 코드를 사람이 해독할 수 없도록 만드는 과정입니다. 이는 역공학 공격을 어렵게 만들어서 애플리케이션의 보안을 높이기 위해 사용됩니다. 플러터와 다트는 난독화를 위한 일부 내장 도구와 방법을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n# 왜 난독화를 사용해야 하나요?\n\n- 보안: 코드를 알아보기 어렵게 만들어 악의적 사용자가 코드를 이해하고 남용하는 것을 어렵게 합니다.\n- 지적 재산권: 코드를 보호하여 지적 재산권을 안전하게 지킵니다.\n- 용량 감소: 어떤 경우에는 난독화가 코드의 크기를 줄이는 데 도움이 될 수도 있습니다.\n\n시작해봅시다! 🥷🏻\n\n- 플러터 프로젝트를 만들어보세요.\n\n<div class=\"content-ad\"></div>\n\n\n```js\nflutter create my_app\ncd my_app\n```\n\n2. 프로젝트 구조화\n\n난독화를 활성화하려면 flutter 빌드 명령에 몇 가지 추가 매개변수를 추가해야 합니다. Android 및 iOS 모두를 위해 난독화하는 방법을 살펴보겠습니다.\n\nAndroid용으로는;\n\n\n<div class=\"content-ad\"></div>\n\n- android/app/build.gradle 파일을 열어주세요.\n- buildTypes 섹션에서 릴리스 구성을 다음과 같이 업데이트해주세요:\n\n```js\nandroid {\n    ...\n    buildTypes {\n        release {\n            ...\n            minifyEnabled true\n            shrinkResources true\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n}\n```\n\n- Proguard 규칙을 지정하려면 android/app/proguard-rules.pro 파일을 생성하고 다음 줄을 추가해주세요:\n\n```js\n# Flutter 난독화\n-ignorewarnings\n-keep class io.flutter.app.** { *; }\n-keep class io.flutter.plugin.** { *; }\n-keep class io.flutter.util.** { *; }\n-keep class io.flutter.view.** { *; }\n-keep class io.flutter.embedding.** { *; }\n-keep class io.flutter.embedding.engine.** { *; }\n-keep class io.flutter.embedding.android.** { *; }\n-keep class io.flutter.embedding.engine.plugins.** { *; }\n-keep class io.flutter.plugin.common.** { *; }\n-keep class io.flutter.plugin.platform.** { *; }\n```\n\n<div class=\"content-ad\"></div>\n\niOS에서는 다음을 수행하실 수 있습니다:\n\n- Open theios/Runner.xcodeproj 파일을 엽니다.\n- 빌드 설정 섹션에서 'Other Swift Flags' 설정을 찾아서 -D DART_OBFUSCATION을 추가합니다.\n\n3. 난독화된 애플리케이션 컴파일\n\n다음 명령어를 사용하여 Android 및 iOS용 난독화된 빌드를 생성합니다:\n\n<div class=\"content-ad\"></div>\n\n안드로이드:\n\n```js\nflutter build apk --release --obfuscate --split-debug-info=./build_info\n```\n\niOS:\n\n```js\nflutter build ios --release --obfuscate --split-debug-info=./build_info\n```\n\n<div class=\"content-ad\"></div>\n\n이 명령어들은 난독화된 코드의 디버그 정보 파일을 지정된 디렉토리에 넣습니다. 이 파일들은 디버깅 및 충돌 보고서 해결에 중요합니다.\n\n4. 애플리케이션 파일 검토\n\n난독화 프로세스의 결과물인 APK 또는 IPA 파일을 열어 코드가 숨겨져 있는지 확인할 수 있습니다. Android APK 파일을 검토하기 위해서는 apktool 또는 유사한 도구를 사용할 수 있습니다. iOS IPA 파일은 class-dump 또는 otool과 같은 도구를 사용할 수 있습니다.\n\n- Android APK 파일 검토:\napktool을 사용하여 APK 파일을 디컴파일합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\napktool d my_app.apk -o output_dir\n```\n\n- iOS IPA 파일을 조사해보세요:\nIPA 파일을 열고 Payload 디렉토리에서 응용 프로그램 파일을 추출하세요. class-dump나 otool을 사용하여 응용 프로그램 파일을 조사하세요.\n\n```js\nclass-dump -H MyApp -o output_dir\n```\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\n위의 단계를 따라 코드를 난독화하여 응용 프로그램의 안전성을 높일 수 있습니다. 이를 정기적으로 수행함으로써 응용 프로그램의 보안을 지속적으로 보호할 수 있습니다.\n\n독자 여러분, 읽어주셔서 감사합니다!\n새로운 기사에서 뵙겠습니다 💙\n\n제 계정을 여기에서 확인하고 질문을 하실 수 있습니다 ✨\n\n트위터에서 플러터 커뮤니티를 팔로우해보세요:\nhttps://www.twitter.com/FlutterComm","ogImage":{"url":"/assets/img/2024-06-21-ObfuscationinFlutterandDartMysteriouscodes_0.png"},"coverImage":"/assets/img/2024-06-21-ObfuscationinFlutterandDartMysteriouscodes_0.png","tag":["Tech"],"readingTime":3},{"title":"ThemeExtension으로 Flutter 맞춤 테마 만들기  템플릿 제공","description":"","date":"2024-06-21 20:46","slug":"2024-06-21-FlutterCustomThemewithThemeExtensionTemplates","content":"\n<img src=\"/assets/img/2024-06-21-FlutterCustomThemewithThemeExtensionTemplates_0.png\" />\n\n이 글에서는 ThemeExtensions를 사용하여 Flutter에서 사용자 정의 테마를 만드는 과정을 안내해 드리겠습니다. Color 및 TextStyle 확장을 위한 템플릿을 제공해 드릴 것이며, 내장 ColorScheme 및 TextTheme을 사용하지 않는 것을 권장하는 이유도 설명해 드리겠습니다(대부분의 경우 99%는 Material 사양을 따르지 않기 때문입니다).\n\n빠른 이동:\n\n- 문제점\n- 사용자 정의 색상 추가 방법\n- 밝은 모드와 어두운 모드 구현 방법\n- 사용자 정의 텍스트 스타일 추가 방법\n- Text 위젯에 대한 기본 TextStyle\n- 마무리(추가 링크)\n\n<div class=\"content-ad\"></div>\n\n## 문제\n\n새로운 Flutter 프로젝트를 시작할 때마다 앱에 재사용 가능한 스타일을 정의해야 합니다. 보통, 디자인 시스템에 기반한 스타일을 정의하며, 그것은 대개(사실은 절대로) Material입니다. TextStyle 토큰들(headlineLarge, bodyMedium, ...)은 Material 명명 규칙을 따르지 않습니다; 디자인 항목들은 팔레트(빨간색, 회색, ...)에서 색상을 사용하고, 색상 체계(accent, primary, background, ...)에서는 사용하지 않습니다. 이 모든 것을 살펴보고 Flutter 앱에 어떻게 적용해야 할지 모를 때가 있습니다.\n\n먼저, ThemeData를 확장하거나 고유한 사용자 정의 테마 클래스를 작성할 수 있다고 생각할 수 있지만, 그렇게 하지 마십시오. 이 기사에서 보여드리는 Flutter 앱에 자연스럽게 통합되는 훨씬 더 나은 방법이 있습니다(ThemeExtension). 하지만 먼저, 왜 내장된 Material ColorScheme 및 TextTheme에 디자인을 통합하기를 추천하지 않는지 살펴보겠습니다.\n\n## ColorScheme 및 TextTheme가 디자인에 적합하지 않은 이유\n\n<div class=\"content-ad\"></div>\n\n플러터는 전역 앱 테마를 설정하기 위해 ThemeData 클래스를 제공합니다. 이 클래스에는 여러 내장 위젯을 위한 많은 속성이 포함되어 있지만, 주요 속성은 ColorScheme과 TextTheme이라고 할 수 있어요. 이것들은 \"괜찮은\"데요, 하지만 여러분의 디자인이 머티리얼 사양을 따르는 경우에만 해당합니다. 그렇지 않으면 대부분의 경우, 디자인 시스템은 서로 다른 이름 및 색상 및 텍스트 스타일 토큰 수를 가지게 될 거에요.\n\n어쩌면 일부 색상 및 텍스트 스타일 토큰이 일치할 수도 있지만, 나머지는 일치하지 않을 수 있어요. 일부 토큰을 매핑해 볼 수도 있겠죠 (디자인: h1 - 코드: headlineLarge), 그리고 다른 토큰을 별도의 위치에 넣어 볼 수도 있어요 (ThemeExtension 또는 다른 곳). 하지만 이것은 좋은 해결책이 될 수 없어요. 이것은 이해하기 어려운 토큰 이름 매핑과 유지 및 수정이 어려운 앱 테마의 분산 선언으로 이어질 거에요. 왜 굳이 사용자 지정 디자인 시스템을 머티리얼에 넣으려고 하나요?\n\n그래서 나는 모든 사용자 지정 스타일을 완전히 제어할 수 있는 사용자 정의 ThemeExtension(s)에 넣으라고 권장해요. 혜택:\n\n- 필요한 속성을 추가, 이름 변경, 삭제할 수 있어요.\n- 머티리얼 사양이나 플러터 업데이트에 의존하지 않아요.\n- 모든 관련된 스타일이 1곳에 모이며 ColorScheme과 ExtraColorScheme 사이로 흩어지지 않아요.\n\n<div class=\"content-ad\"></div>\n\n게다가 GitHub Copilot 또는 제가 제공할 템플릿을 사용하면 매우 쉽게 작성할 수 있습니다.\n\n내가 여전히 Theme과 ThemeData를 사용하고 직접 클래스를 만들지 말 것을 추천하는 이유는 Flutter가 이미 이러한 클래스를 사용하여 필요한 모든 것을 갖추고 있기 때문입니다. UI 부분을 위한 테마 재정의, 내장 위젯의 기본 스타일링, 기본 텍스트 스타일 설정, 라이트 및 다크 모드 전환 지원 등이 모두 포함되어 있습니다. 이미 존재하는 것(ThemeExtensions)을 확장하는 것이 더 쉬울 때에는 직접 클래스를 작성할 필요가 없습니다.\n\n# Flutter에서 ThemeExtension을 사용하여 사용자 정의 색상 추가하는 방법\n\nFlutter 앱에 사용자 정의 색상을 추가하려면 3단계만 거치면 됩니다:\n\n<div class=\"content-ad\"></div>\n\n- 사용자 정의 색상 정의\n- 색상을 위한 ThemeExtension 생성\n- Light 및 Dark 모드를 위한 확장 기능 초기화\n\n## 단계 1: AppPalette\n\nAppPalette는 디자인 시스템에서 사용되는 색상 코드를 정의하는 클래스입니다. 복잡한 것은 아니며, 단순히 정적 속성을 가진 클래스일 뿐입니다:\n\n```js\nabstract class AppPalette {\n  // 빨강\n  static const red = Colors.red;\n  static const imperialRed = Color(0xFFE54B4B);\n\n  // 흰색\n  static const seashell = Color(0xFFF7EBE8);\n\n  // 회색\n  static const grey = _GreyColors();\n}\n\n/// 팔레트에서 색상을 그룹화하는 대체 방법.\n///\n/// 단점은 이러한 값들이 상수가 아니기 때문에\n/// 생성자 기본 값으로 사용할 수 없다는 것입니다.\n///\n/// 사용 예: `AppPalette.grey.grey50`.\nclass _GreyColors {\n  const _GreyColors();\n\n  final grey50 = const Color(0xFFFAFAFA);\n  final grey100 = const Color(0xFFF5F5F5);\n}\n```\n\n<div class=\"content-ad\"></div>\n\n노트:\n\n- AppPalette는 추상입니다. 왜냐하면 우리는 이를 실체화할 필요가 없기 때문입니다.\n- \\_GreyColors는 비공개입니다. 직접 액세스하는 것이 아니라 AppPalette를 통해서만 액세스를 허용합니다.\n\n## 단계 2: AppColorsExtension + 템플릿\n\n여기서는 테마 익스텐션을 정의하고 copyWith() 및 lerp() 메소드를 구현해야 합니다. 이 예제에서는 주요 및 배경 속성만 있는데도 간단한 작업에 대해 너무 많은 코드처럼 보일 수 있지만, 코드 생성 없이는 이를 해결할 방법이 없습니다. (링크는 엔딩 섹션에 있음).\n\n<div class=\"content-ad\"></div>\n\n```js\nclass AppColorsExtension extends ThemeExtension<AppColorsExtension> {\n  AppColorsExtension({\n    required this.primary,\n    required this.background,\n  });\n\n  final Color primary;\n  final Color background;\n\n  @override\n  ThemeExtension<AppColorsExtension> copyWith({\n    Color? primary,\n    Color? background,\n  }) {\n    return AppColorsExtension(\n      primary: primary ?? this.primary,\n      background: background ?? this.background,\n    );\n  }\n\n  @override\n  ThemeExtension<AppColorsExtension> lerp(\n    covariant ThemeExtension<AppColorsExtension>? other,\n    double t,\n  ) {\n    if (other is! AppColorsExtension) {\n      return this;\n    }\n\n    return AppColorsExtension(\n      primary: Color.lerp(primary, other.primary, t)!,\n      background: Color.lerp(background, other.background, t)!,\n    );\n  }\n}\n```\n\n참고:\n\n- lerp()는 다른 ThemeExtension 개체와 선형 보간을 수행하고 테마를 변경할 때 애니메이션을 만듭니다.\n\n전체 확장 템플릿 링크는 여기에 있습니다. 현재 내장 ColorScheme과 모든 속성이 동일하지만 필요에 맞게 추가, 이름 바꾸기 및 삭제할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n🔗 AppColorsExtension 템플릿\n\n## 단계 3: 밝은 모드와 어두운 모드\n\n이 단계는 다음 섹션에서 진행될 예정이에요 😅\n\n참고로, Chopper 요청에 HTTP Authorization 헤더를 추가하고 401 Unauthorized 응답일 때 재시도하는 방법에 대한 제 다른 글도 확인해보시기를 추천해요.\n\n<div class=\"content-ad\"></div>\n\n이제 다시 플러터 테마링으로 돌아왔어요! 🙂\n\n# 플러터에서 라이트 모드와 다크 모드를 구현하는 방법\n\n다시 한 번, 3가지 간단한 단계만 따르면 돼요:\n\n- 라이트와 다크 테마 데이터를 정의하세요.\n- MaterialApp에 그 데이터들을 전달하세요.\n- MaterialApp에 올바른 ThemeMode를 전달하세요.\n\n<div class=\"content-ad\"></div>\n\n## 단계 1: App 테마\n\n이 클래스는 ThemeExtensions와 테마 모드를 프로그래밍적으로 전환할 수 있는 기능을 가진 라이트 및 다크 모드용 Flutter ThemeData 게터를 포함하고 있습니다. 우선 게터를 구현해봅시다.\n\n```js\nclass AppTheme {\n  //\n  // 라이트 테마\n  //\n\n  static final light = ThemeData.light().copyWith(\n    extensions: [\n      _lightAppColors,\n    ],\n  );\n\n  static final _lightAppColors = AppColorsExtension(\n    primary: const Color(0xff6200ee),\n    onPrimary: Colors.white,\n    secondary: const Color(0xff03dac6),\n    onSecondary: Colors.black,\n    error: const Color(0xffb00020),\n    onError: Colors.white,\n    background: Colors.white,\n    onBackground: Colors.black,\n    surface: Colors.white,\n    onSurface: Colors.black,\n  );\n\n  //\n  // 다크 테마\n  //\n\n  static final dark = ThemeData.dark().copyWith(\n    extensions: [\n      _darkAppColors,\n    ],\n  );\n\n  static final _darkAppColors = AppColorsExtension(\n    primary: const Color(0xffbb86fc),\n    onPrimary: Colors.black,\n    secondary: const Color(0xff03dac6),\n    onSecondary: Colors.black,\n    error: const Color(0xffcf6679),\n    onError: Colors.black,\n    background: const Color(0xff121212),\n    onBackground: Colors.white,\n    surface: const Color(0xff121212),\n    onSurface: Colors.white,\n  );\n}\n```\n\n참고:\n\n<div class=\"content-ad\"></div>\n\n- 여기서는 템플릿에서 AppColorsExtension의 전체 버전을 사용했습니다.\n\n❗중요. 공식 문서에서는 다음과 같이 확장을 액세스합니다: Theme.of(context).extension`MyColors`()! 하지만 이것은 너무 길고 사용하기 어려울 수 있습니다. Dart 확장 메서드의 강력함을 활용하는 좋은 솔루션이 없다는 것이 안타깝습니다.\n\n```js\nextension AppThemeExtension on ThemeData {\n  /// 사용 예시: Theme.of(context).appColors;\n  AppColorsExtension get appColors =>\n      extension<AppColorsExtension>() ?? AppTheme._lightAppColors;\n}\n```\n\n참고:\n\n<div class=\"content-ad\"></div>\n\n- 만약 이 확장 기능이 AppTheme.\\_lightAppColors에 액세스해야 한다면 AppTheme과 같은 파일에 작성되어야 합니다.\n\n❗또 하나의 개선점입니다. 매번 Theme.of(context)를 작성하는 것이 너무 길 수 있으므로 BuildContext에 다른 확장 메소드를 추가하는 것을 선호합니다:\n\n```js\nextension ThemeGetter on BuildContext {\n  // 사용 예: `context.theme`\n  ThemeData get theme => Theme.of(this);\n}\n```\n\n최종 사용 방법은 다음과 같습니다: context.theme.appColors. 멋지죠? ✨ 추가로 유용한 확장 기능은 'Flutter에서 누락된 확장 기능'에 대한 제 논문에서 찾아볼 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n## 단계 2-3: 플러터에서 라이트 모드와 다크 모드 전환하는 방법\n\n플러터에서 라이트 모드와 다크 모드를 전환하려면 MaterialApp에서 theme 및 darkTheme 속성을 지정해야 합니다. 또한 앱의 현재 테마 모드를 결정하는 themeMode 속성도 제공해야 합니다. ThemeMode은 3가지 옵션을 가지고 있는 enum입니다:\n\n- ThemeMode.light\n- ThemeMode.dark\n- ThemeMode.system\n\n상태 관리를 위해 저는 ChangeNotifier를 사용했습니다. 더 복잡한 것을 사용할 필요가 없어서입니다. 나중에 BuildContext 없이 ThemeMode를 변경해야 할 경우 get_it 또는 사용하는 다른 패키지에 이 클래스를 등록할 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nclass AppTheme with ChangeNotifier {\n  ThemeMode _themeMode = ThemeMode.system;\n\n  ThemeMode get themeMode => _themeMode;\n\n  set themeMode(ThemeMode themeMode) {\n    _themeMode = themeMode;\n    notifyListeners();\n  }\n\n  ...\n}\n```\n\n이제 MaterialApp에 넣어 봅시다:\n\n```js\nvoid main() {\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return ChangeNotifierProvider(\n      // 1. MaterialApp 위에 AppTheme를 제공하여\n      // 모든 페이지에서 사용할 수 있습니다.\n      create: (_) => AppTheme(),\n      builder: (context, _) => MaterialApp(\n        title: 'Flutter Demo',\n        // 2. 라이트 테마를 제공합니다.\n        theme: AppTheme.light,\n        // 3. 다크 테마를 제공합니다.\n        darkTheme: AppTheme.dark,\n        // 4. AppTheme 변경 사항 (ThemeMode)을 감시합니다.\n        themeMode: context.watch<AppTheme>().themeMode,\n        debugShowCheckedModeBanner: false,\n        home: const MyHomePage(title: 'Flutter Demo Home Page'),\n      ),\n    );\n  }\n}\n```\n\n참고:\n\n<div class=\"content-ad\"></div>\n\n- ChangeNotifierProvider은 provider 패키지에서 제공됩니다. 이미 알고 계실 거라 믿어요 😅\n\n테마모드를 업데이트해보세요:\n\n```js\nvoid darkMode() {\n  context.read<AppTheme>().themeMode = ThemeMode.dark;\n}\n```\n\n축하합니다 🎉 ThemeExtension을 사용하여 사용자 정의 앱 테마를 만드셨군요. 이제는 커스텀 텍스트 스타일도 추가해볼까요?\n\n<div class=\"content-ad\"></div>\n\n# 플러터에서 ThemeExtension을 사용하여 사용자 지정 텍스트 스타일 추가하는 방법\n\n텍스트 스타일은 라이트 모드와 다크 모드 사이에 변경되지 않기 때문에 대부분의 경우, 테마 확장을 생성할 필요가 없고 간단한 const TextStyle 선언이 충분합니다. 그러나 두 가지 방법을 모두 보여드리겠습니다. 두 단계만으로 완성됩니다.\n\n## 단계 1: AppTypography\n\n이 클래스는 AppPalette와 동일한 용도로 사용되며 코드에서 디자인의 스타일을 정의합니다.\n\n<div class=\"content-ad\"></div>\n\n추상 클래스 AppTypography {\n고정된 body1 = TextStyle(\nfontSize: 16,\nfontWeight: FontWeight.normal,\n);\n\n고정된 h1 = TextStyle(\nfontSize: 96,\nfontWeight: FontWeight.w300,\n);\n}\n\n참고:\n\n- 만일 색상을 추가 클래스와 함께 그룹화하는 두 번째 방법이 마음에 들었다면, 이곳에서도 사용할 수 있습니다.\n\n이제 이러한 스타일을 다음과 같이 사용할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nstyle: AppTypography.h1.copyWith(color: context.theme.appColors.error)\n```\n\n## 플러터에서 Text 위젯을 위한 기본 TextStyle\n\nText 위젯을 위한 기본 TextStyle을 설정하려면 TextTheme에서 bodyMedium을 설정해야 합니다. 다음은 예제입니다:\n\n```js\nstatic final light = () {\n    final defaultTheme = ThemeData.light();\n\n    return defaultTheme.copyWith(\n      textTheme: defaultTheme.textTheme.copyWith(\n        // 참고: Text 위젯을 위한 기본 텍스트 스타일\n        bodyMedium: AppTypography.body1.copyWith(color: Colors.black),\n      ),\n      extensions: [\n        _lightAppColors,\n      ],\n    );\n  }();\n```\n\n<div class=\"content-ad\"></div>\n\n## 단계 2: AppTextThemeExtension + 템플릿\n\n텍스트 스타일을 위한 ThemeExtension을 생성하려면 색상과 같은 방법을 따라야합니다.\n\n```js\nclass AppTextTheme extends ThemeExtension<AppTextTheme> {\n  const AppTextTheme({\n    required this.body1,\n    required this.h1,\n  });\n\n  final TextStyle body1;\n  final TextStyle h1;\n\n  @override\n    ThemeExtension<AppTextTheme> copyWith({\n    TextStyle? body1,\n    TextStyle? h1,\n  }) {\n    return AppTextTheme(\n      body1: body1 ?? this.body1,\n      h1: h1 ?? this.h1,\n    );\n  }\n\n  @override\n  ThemeExtension<AppTextTheme> lerp(\n    covariant ThemeExtension<AppTextTheme>? other,\n    double t,\n  ) {\n    if (other is! AppTextTheme) {\n      return this;\n    }\n\n    return AppTextTheme(\n      body1: TextStyle.lerp(body1, other.body1, t)!,\n      h1: TextStyle.lerp(h1, other.h1, t)!,\n    );\n  }\n}\n```\n\n위는 간단한 예제이지만, 여기에서는 내장된 TextTheme과 동일한 모든 (사용되지 않는) 속성을 갖춘 전체 템플릿을 제공합니다. 필요한 대로 추가, 이름 변경, 삭제할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n🔗 AppTextThemeExtension 템플릿\n\n친구야! Light와 Dark ThemeData에 이 확장 프로그램을 추가하지 않도록 잊지 마세요:\n\n```js\nclass AppTheme with ChangeNotifier {\n\n  ...\n\n  static final light = () {\n    final defaultTheme = ThemeData.light();\n\n    return defaultTheme.copyWith(\n      textTheme: defaultTheme.textTheme.copyWith(\n        // 참고: Text 위젯에 대한 기본 텍스트 스타일입니다.\n        bodyMedium: AppTypography.body1.copyWith(color: Colors.black),\n      ),\n      extensions: [\n        _lightAppColors,\n        // 1. 여기\n        _lightTextTheme,\n      ],\n    );\n  }();\n\n  static final _lightAppColors = ...;\n\n  // 2. 여기\n  static final _lightTextTheme = AppTextThemeExtension(\n    body1: AppTypography.body1.copyWith(color: _lightAppColors.onBackground),\n    h1: AppTypography.h1.copyWith(color: Colors.black),\n  );\n\n  ...\n\n}\n\nextension AppThemeExtension on ThemeData {\n  AppColorsExtension get appColors =>\n      extension<AppColorsExtension>() ?? AppTheme._lightAppColors;\n\n  // 3. 그리고 여기\n  AppTextThemeExtension get appTextTheme =>\n      extension<AppTextThemeExtension>() ?? AppTheme._lightTextTheme;\n}\n```\n\n🎉 다시 한 번 축하드려요! 이제는 TextStyles에 대한 ThemeExtension이 생겼어요. 아래 전체 소스 코드를 확인해보세요.\n\n<div class=\"content-ad\"></div>\n\n# 마무리\n\n## 소스 코드\n\n템플릿:\n\n- 🔗 AppColorsExtension\n- 🔗 AppTextThemeExtension\n\n<div class=\"content-ad\"></div>\n\n풀 앱 예시:\n\n## 확장 가능한 부분\n\n- get_it이나 다른 패키지에 AppTheme을 등록하여 BuildContext 없이 액세스할 수 있습니다.\n- 선택한 ThemeMode를 shared_preferences에 저장합니다.\n\n## Flutter ThemeExtension 생성기\n\n<div class=\"content-ad\"></div>\n\n그 패키지는 ThemeExtension을 생성하는 것을 볼 수 있었지만, 나는 항상 최소한의 생성이 좋다고 생각해서 사용해보지는 않았어. 게다가, GitHub Copilot을 사용하면 필요한 보일러플레이트 코드를 쉽게 작성할 수 있어.\n\n## 더 많은 자료\n\n- 테마 문서.\n- ThemeExtension 문서.\n- DefaultTextStyle.merge() — 사용자 정의 위젯에서 기본 TextStyle을 처리하는 데 도움이 됨.\n\n읽어주셔서 감사합니다. 안녕 👋\n","ogImage":{"url":"/assets/img/2024-06-21-FlutterCustomThemewithThemeExtensionTemplates_0.png"},"coverImage":"/assets/img/2024-06-21-FlutterCustomThemewithThemeExtensionTemplates_0.png","tag":["Tech"],"readingTime":13},{"title":"안드로이드와 코틀린을 사용하여 모바일 애플리케이션에서 NFC 태그를 스캔하고 읽는 방법","description":"","date":"2024-06-21 20:44","slug":"2024-06-21-HowtoScanandReadNFCtagsinMobileapplicationusingAndroidKotlin","content":"\n\n\n![image](/assets/img/2024-06-21-HowtoScanandReadNFCtagsinMobileapplicationusingAndroidKotlin_0.png)\n\n- NFC 기술 소개\n- 안드로이드 기기에서 NFC 태그 스캔 기능 활성화\n- 안드로이드 프로젝트에 구현하는 기술 가이드 단계별 안내\n- 테스트\n- 결론\n\nNFC(Near Field Communication)는 두 기기가 짧은 거리를 통해 무선으로 데이터를 교환할 수 있는 기술입니다.\n\nNFC는 특히 모바일 기기에서 점점 인기를 끌고 있으며, 스마트폰과의 상호 작용 방식을 혁신적으로 바꿔놓았습니다. 또한, 접촉식 결제, 티켓 발권 및 출입 제어 등 다양한 애플리케이션에 사용될 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n이 가이드에서는 NFC의 세계에 심취하고 Android 및 Kotlin을 사용하여 모바일 애플리케이션에서 NFC 태그를 스캔하는 방법을 알아보겠습니다. 초보자든 숙련된 개발자든 상관없이, 이 포괄적인 자습서는 NFC의 기능을 앱 개발 프로젝트에서 활용하기 위한 지식과 도구를 제공할 것입니다.\n\n- 안드로이드 기기에서 NFC 태그를 활성화하려면 시스템 설정 -` 연결된 장치 -` 연결 기본값 -` NFC -` NFC 스위치를 켜십시오.\n- 그러나 NFC 설정으로 이동하는 경로는 모바일 브랜드에 따라 다를 수 있습니다. 그럴 경우 시스템 설정의 검색 바에서 NFC를 간단히 검색하십시오.\n\n![이미지](/assets/img/2024-06-21-HowtoScanandReadNFCtagsinMobileapplicationusingAndroidKotlin_1.png)\n\n본 자습서에서는 Kotlin을 사용하여 Android 모바일 앱에서 NFC 태그를 스캔하는 방법에 대해 단계별로 안내하겠습니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-21-HowtoScanandReadNFCtagsinMobileapplicationusingAndroidKotlin_2.png\" />\n\n안드로이드 앱에서 NFC를 사용하려면 AndroidManifest.xml 파일에 NFC 권한을 추가해야 합니다. 프로젝트의 AndroidManifest.xml 파일을 열고 아래와 같이 다음 줄을 추가하세요.\n\n```javascript\n<uses-permission android:name=\"android.permission.NFC\"/>\n```\n\nNFC 태그를 읽으려면 NFC 어댑터 클래스의 인스턴스를 생성해야 합니다.\n\n<div class=\"content-ad\"></div>\n\ngetSystemService() 메소드를 사용하여 이 작업을 수행할 수 있습니다. 아래 코드를 Activity의 onCreate() 메소드에 추가해보세요.\n\n```kotlin\nprivate lateinit var nfcAdapter: NfcAdapter\n\noverride fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    setContentView(R.layout.activity_main)\n    \n    // 기본 NFC 어댑터 가져오기\n    nfcAdapter = NfcAdapter.getDefaultAdapter(this)\n}\n```\n\nNFC 인텐트 필터는 앱이 읽을 수 있는 NFC 태그의 종류를 지정하는 방법입니다. 아래 코드를 Activity에 추가하여 NFC 인텐트 필터를 생성할 수 있습니다.\n\n```kotlin\nprivate fun createNFCIntentFilter(): Array<IntentFilter> {\n    val intentFilter = IntentFilter(NfcAdapter.ACTION_NDEF_DISCOVERED)\n    try {\n        intentFilter.addDataType(\"*/*\")\n    } catch (e: IntentFilter.MalformedMimeTypeException) {\n        throw RuntimeException(\"MIME 유형 추가에 실패하였습니다.\", e)\n    }\n    return arrayOf(intentFilter)\n}\n```\n\n<div class=\"content-ad\"></div>\n\nNFC 태그가 감지되면 Android 시스템은 앱에 NFC 인텐트를 보냅니다.\n\nNFC 인텐트를 처리하려면 Activity의 onNewIntent() 메소드를 오버라이드해야 합니다. 아래는 예시 코드 조각입니다.\n\n```js\noverride fun onNewIntent(intent: Intent) {\n    super.onNewIntent(intent)\n}\n```\n\n앱이 화면에 표시될 때 NFC 인텐트를 받기 위해 foreground dispatch를 활성화해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n이것은 당신의 앱이 NFC 인텐트를 먼저 받고, 처리할지 다른 앱으로 전달할지를 결정할 수 있음을 의미합니다.\n\nForeground 디스패치를 활성화하려면, 액티비티의 onResume() 메서드를 재정의하고 enableForegroundDispatch()를 호출해야 합니다. 마찬가지로, onPause() 메서드를 재정의하고 액티비티가 전경에 없을 때 foreground 디스패치를 비활성화하기 위해 disableForegroundDispatch()를 호출해야 합니다.\n\n다음은 foreground 디스패치를 활성화하고 비활성화하는 방법의 예시입니다:\n\n```js\noverride fun onResume() {\n    super.onResume()\n    val nfcAdapter = NfcAdapter.getDefaultAdapter(this)\n    val pendingIntent = PendingIntent.getActivity(\n        this, 0, Intent(this, javaClass).addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP), 0\n    )\n    val intentFilters = arrayOf<IntentFilter>(\n        IntentFilter(NfcAdapter.ACTION_NDEF_DISCOVERED),\n        IntentFilter(NfcAdapter.ACTION_TAG_DISCOVERED),\n        IntentFilter(NfcAdapter.ACTION_TECH_DISCOVERED)\n    )\n    nfcAdapter.enableForegroundDispatch(this, pendingIntent, intentFilters, null)\n}\n\noverride fun onPause() {\n    super.onPause()\n    val nfcAdapter = NfcAdapter.getDefaultAdapter(this)\n    nfcAdapter.disableForegroundDispatch(this)\n}\n```\n\n<div class=\"content-ad\"></div>\n\nonResume() 메서드에서는 기본 NfcAdapter를 가져와서 활동을위한 PendingIntent를 만듭니다. 또한 수신하려는 NFC 인텐트를 지정하는 IntentFilters 배열을 만듭니다. 그런 다음 NfcAdapter 인스턴스에 대해 enableForegroundDispatch()를 호출하고 PendingIntent 및 IntentFilters를 전달합니다.\n\nonPause() 메서드에서는 NfcAdapter 인스턴스에서 disableForegroundDispatch()를 호출하여 전경 디스패치를 비활성화합니다.\n\n전경 디스패치를 활성화 한 후에는 활동이 onNewIntent() 메서드에서 NFC 인텐트를 수신합니다. 그런 다음 NFC 태그 정보를 추출하고 적절히 처리할 수 있습니다.\n\n```js\noverride fun onNewIntent(intent: Intent?) {\n    super.onNewIntent(intent)\n    if (intent?.action == NfcAdapter.ACTION_TAG_DISCOVERED) {\n        val tag = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {\n            intent.getParcelableExtra(NfcAdapter.EXTRA_TAG, Tag::class.java)\n        } else {\n            intent.getParcelableExtra(NfcAdapter.EXTRA_TAG)\n        }\n        tag?.id?.let {\n            val tagValue = it.toHexString()\n            Toast.makeText(this, \"NFC tag detected: $tagValue\", Toast.LENGTH_SHORT).show()\n        }\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 예제에서는 NFC 인텐트가 ACTION_TAG_DISCOVERED인지 확인하여 NFC 태그가 감지되었는지 확인합니다. 그런 다음 getParcelableExtra() 메서드를 사용하여 인텐트에서 태그 객체를 추출하고 toHexString() 확장 함수를 사용하여 태그 ID를 16진수 문자열로 변환합니다. 마지막으로, 태그 ID와 함께 토스트 메시지를 표시합니다.\n\ntoHexString()이라는 확장 함수를 만들어 Tag ID를 16진수 문자열로 변환했습니다.\n\n```kotlin\nfun ByteArray.toHexString(): String {\n    val hexChars = \"0123456789ABCDEF\"\n    val result = StringBuilder(size * 2)\n\n    map { byte ->\n        val value = byte.toInt()\n        val hexChar1 = hexChars[value shr 4 and 0x0F]\n        val hexChar2 = hexChars[value and 0x0F]\n        result.append(hexChar1)\n        result.append(hexChar2)\n    }\n\n    return result.toString()\n}\n```\n\n이제 NFC 스캔 기능을 구현했으니, 실제 장치에서 테스트해보는 시간입니다. 장치에서 NFC가 활성화되어 있고 근처에 NFC 태그가 있는지 확인하세요. 앱을 실행하고 NFC 태그를 장치에 가까이 가져가보세요. 태그 ID가 표시된 토스트 메시지가 나타날 것입니다.\n\n<div class=\"content-ad\"></div>\n\n축하합니다! 안드로이드 앱에 NFC 스캔 기능을 성공적으로 구현하셨다고 가정합니다.\n\n![NFC scanning](/assets/img/2024-06-21-HowtoScanandReadNFCtagsinMobileapplicationusingAndroidKotlin_3.png)\n\n이 블로그 포스트를 여기까지 읽어 주셔서 감사합니다. 이제 NFC 스캔 기능을 성공적으로 달성하셨다고 생각합니다. 그러나 의문 사항이 있으면 언제든지 알려주세요. 언제든지 도와드릴 수 있어 기뻐요.\n\n저는 글을 쓰는 만큼 여러분이 읽는 것을 즐길 수 있기를 바랍니다.\n이 튜토리얼이 누군가에게 도움이 될 것으로 생각하시나요? 망설이지 말고 공유해주세요. 이가 도움이 되기를 바라며, 50번까지 클랩 버튼을 눌러 주세요. 감사합니다.","ogImage":{"url":"/assets/img/2024-06-21-HowtoScanandReadNFCtagsinMobileapplicationusingAndroidKotlin_0.png"},"coverImage":"/assets/img/2024-06-21-HowtoScanandReadNFCtagsinMobileapplicationusingAndroidKotlin_0.png","tag":["Tech"],"readingTime":6},{"title":"Your project requires a newer version of the Kotlin Gradle plugin 오류 해결 방법","description":"","date":"2024-06-21 20:43","slug":"2024-06-21-SolutionforYourprojectrequiresanewerversionoftheKotlinGradlepluginerror","content":"\n\n안녕하세요 여러분,\n\n이것은 제 첫 번째 미디엄 이야기입니다. 저는 저와 비슷한 사람들이 쉽게 이용 가능한 해결책을 찾지 못할 수도 있는 문제를 겪을 수 있을 것이라고 생각하기 때문에 이것을 쓰게 되었습니다.\n\n저는 현재 플러터 앱을 개발하고 있으며 ARCore Flutter 플러그인을 활용하고 있습니다. 그러나 제 프로그램 실행 중 다음과 같은 오류를 만났습니다:\n\n“Module was compiled with an incompatible version of Kotlin. The binary version of its metadata is 1.9.0, expected version is 1.7.0.”\n\n<div class=\"content-ad\"></div>\n\n정확한 버전 번호는 다를 수 있지만, Kotlin과의 호환성 문제가 문제의 핵심이었습니다. 처음에는 모듈에 대한 호환되지 않는 Kotlin 버전이 무엇인지 확신이 없었습니다. 그러나 몇 시간 동안의 연구 끝에 Kotlin Gradle 버전을 수동으로 업데이트해야 한다는 것을 알게 되었습니다.\n\n내가 발견한 해결책 중 많은 것들이 이전 버전의 Android Studio Bumblebee에 관한 것이었고, gradle 파일을 수정하는 방법에 대한 지침을 제공했습니다. 이러한 해결책들은 일반적으로 android/build.gradle의 buildscript 섹션을 수정하는 것을 제안했습니다. 아래는 추천 사항에서 일반적인 buildscript 섹션의 일부분입니다:\n\n```js\nbuildscript {\n    ext.kotlin_version = '1.3.50'\n    repositories {\n        google()\n        jcenter()\n    }\n\n    dependencies {\n        classpath 'com.android.tools.build:gradle:4.0.1'\n        classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\"\n    }\n}\n```\n\n그러나 조만간 이 buildscript 구성이 Bumblebee 업데이트 이전에 존재했음을 깨달았습니다. 더 최근의 해결책들은 여전히 파일의 처음이나 다른 곳에 buildscript 블록을 수동으로 추가하는 것을 권장했습니다. 안타깝게도, 이러한 제안들 중 어느 것도 내 문제를 해결해 주지 못했습니다.\n\n<div class=\"content-ad\"></div>\n\n1) android/settings.gradle 파일로 이동해주세요.\n\n2) 다음과 비슷한 섹션을 만날 것입니다:\n\n```js\npluginManagement {\n    def flutterSdkPath = {\n        def properties = new Properties()\n        file(\"local.properties\").withInputStream { properties.load(it) }\n        def flutterSdkPath = properties.getProperty(\"flutter.sdk\")\n        assert flutterSdkPath != null, \"local.properties에 flutter.sdk가 설정되지 않았습니다\"\n        return flutterSdkPath\n    }\n    settings.ext.flutterSdkPath = flutterSdkPath()\n\n    includeBuild(\"${settings.ext.flutterSdkPath}/packages/flutter_tools/gradle\")\n\n    repositories {\n        google()\n        mavenCentral()\n        gradlePluginPortal()\n    }\n}\n\nplugins {\n    id \"dev.flutter.flutter-plugin-loader\" version \"1.0.0\"\n    id \"com.android.application\" version \"7.3.0\" apply false\n    id \"org.jetbrains.kotlin.android\" version \"1.7.10\" apply false\n}\n\ninclude \":app\"\n```\n\n3) plugins 섹션 아래에서 문제를 일으키는 id \"org.jetbrains.kotlin.android\" version \"1.7.10\" apply false 줄을 찾아보세요.\n\n<div class=\"content-ad\"></div>\n\n여기서 Kotlin 버전을 변경하세요. 저의 경우에는 1.9.0으로 업데이트했고, 문제가 해결되었어요.\n\n이 해결책이 동일한 오류를 겪는 다른 사람들에게 도움이 되기를 바랍니다. 즐거운 하루 되세요!","ogImage":{"url":"/assets/img/2024-06-21-SolutionforYourprojectrequiresanewerversionoftheKotlinGradlepluginerror_0.png"},"coverImage":"/assets/img/2024-06-21-SolutionforYourprojectrequiresanewerversionoftheKotlinGradlepluginerror_0.png","tag":["Tech"],"readingTime":3},{"title":"외부 패키지 없이 Flutter에서 Google Autocomplete Places API 통합하기 종합 가이드","description":"","date":"2024-06-21 20:41","slug":"2024-06-21-IntegratingGoogleAutocompletePlacesAPIinFlutterWithoutExternalPackagesAComprehensiveGuide","content":"\n![image](/assets/img/2024-06-21-IntegratingGoogleAutocompletePlacesAPIinFlutterWithoutExternalPackagesAComprehensiveGuide_0.png)\n\n소스 코드: [https://github.com/axiftaj/Flutter-Google-Map-Tutorials/tree/main](https://github.com/axiftaj/Flutter-Google-Map-Tutorials/tree/main)\n\nGoogle Autocomplete Places API는 위치 제안 및 예측을 심층적으로 통합할 수 있는 강력한 솔루션을 제공합니다. 이 기능을 통합하는 데 사용할 수 있는 패키지는 있지만 기본 API 호출을 이해하면 개발자가 더 많은 제어와 사용자 정의 기능을 갖게 됩니다. 이 안내서에서는 외부 패키지에 의존하지 않고 Flutter에서 Google Autocomplete Places API를 직접 구현하는 과정을 탐색해 보겠습니다.\n\n필수 사항: 계속하기 전에 다음 사전 요구 사항이 충족되었는지 확인하세요:\n\n<div class=\"content-ad\"></div>\n\n- 플러터 SDK가 설치되어 있어야 합니다\n- 안드로이드 스튜디오 또는 VS CODE\n- 결제가 활성화된 Google Cloud Platform (GCP) 계정 및 Places API가 활성화되어 있어야 합니다\n\n단계 1: Google Cloud Platform 프로젝트 설정\n\n- Google Cloud Platform 콘솔로 이동: https://console.cloud.google.com/\n- 스크린샷에 표시된 대로 새 프로젝트를 만들거나 기존 프로젝트를 선택하세요\n\n![image](/assets/img/2024-06-21-IntegratingGoogleAutocompletePlacesAPIinFlutterWithoutExternalPackagesAComprehensiveGuide_1.png)\n\n<div class=\"content-ad\"></div>\n\n3. 프로젝트용 Google Places API를 활성화하세요. API 라이브러리로 이동하여 \"Places API\"를 검색하고 활성화하세요.\n\n왼쪽 상단 모서리에 있는 햄버거 아이콘을 클릭하고 API 및 서비스 라이브러리를 선택한 후, 우측 하단 구석에 있는 Place API를 클릭하세요.\n\n![이미지](/assets/img/2024-06-21-IntegratingGoogleAutocompletePlacesAPIinFlutterWithoutExternalPackagesAComprehensiveGuide_2.png)\n\n활성화될 때와 같이 보일 것입니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-21-IntegratingGoogleAutocompletePlacesAPIinFlutterWithoutExternalPackagesAComprehensiveGuide_3.png\" />\n\n4. “Credentials” 탭으로 이동하여 API 자격 증명을 생성하세요. “Create Credentials”를 선택하고 “API Key”를 선택한 후 지침에 따라 API 키를 생성하세요.\n\n상단 좌측 구석의 햄버거 아이콘을 클릭한 후 API 및 서비스 “Credentials”를 선택하고 CREATE CREDENTIALS를 클릭한 후 API Key를 선택하세요. 이렇게 하면 API 키가 생성되며, 이를 다른 사람과 공유하지 마세요.\n\n<img src=\"/assets/img/2024-06-21-IntegratingGoogleAutocompletePlacesAPIinFlutterWithoutExternalPackagesAComprehensiveGuide_4.png\" />\n\n<div class=\"content-ad\"></div>\n\n## 플러터 프로젝트를 생성하고 다음 패키지들을 추가해봐요\n\n```js\nuuid: ^4.3.3\nhttp:\n```\n\nuuid 패키지는 세션을 관리하는 데 사용될 거에요(세션이 무엇인지는 마지막에 설명할게요)\n\n코드 설명:\n\n<div class=\"content-ad\"></div>\n\n먼저 사용자로부터 입력을 받기 위해 Text Field를 사용하는 컨트롤러를 만들었습니다. 그리고 uuid 인스턴스를 초기화하였는데, 이는 새로운 세션을 생성하는 데 도움이 됩니다. 그리고 initState() 메서드에서는 컨트롤러의 변경사항을 감지하고 사용자가 무언가를 입력할 때 getSuggestion(\\_controller.text) 함수를 호출합니다.\n\n\\_placeList에는 API 호출이 성공했을 때 화면에 자동완성 추천을 저장합니다.\n\n```js\nfinal _controller = TextEditingController();\nvar uuid = const Uuid();\nString _sessionToken = '1234567890';\nList<dynamic> _placeList = [];\n\n@override\nvoid initState() {\n  super.initState();\n  _controller.addListener(() {\n    _onChanged();\n  });\n}\n\n_onChanged() {\n  if (_sessionToken == null) {\n    setState(() {\n      _sessionToken = uuid.v4();\n    });\n  }\n  getSuggestion(_controller.text);\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 함수에서는 http 패키지를 사용하여 입력 요청을 Google 서버로 보냅니다. 성공적으로 처리되면 해당 데이터를 배열에 저장하고 화면을 새로 고침하여 보여줍니다.\n\nAPI 키는 안전한 저장소에 보관하거나 다른 좋은 방법을 따라 오용되지 않도록 합니다.\n\n```js\nvoid getSuggestion(String input) async {\n\n\n  const String PLACES_API_KEY = \"\";\n\n  try{\n    String baseURL = 'https://maps.googleapis.com/maps/api/place/autocomplete/json';\n    String request = '$baseURL?input=$input&key=$PLACES_API_KEY&sessiontoken=$_sessionToken';\n    var response = await http.get(Uri.parse(request));\n    var data = json.decode(response.body);\n    if (kDebugMode) {\n      print('mydata');\n      print(data);\n    }\n    if (response.statusCode == 200) {\n      setState(() {\n        _placeList = json.decode(response.body)['predictions'];\n      });\n    } else {\n      throw Exception('Failed to load predictions');\n    }\n  }catch(e){\n    print(e);\n  }\n\n}\n```\n\n전체 소스 코드:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport 'dart:convert';\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\nimport 'package:uuid/uuid.dart';\nimport 'package:http/http.dart' as http;\n\nclass GoogleMapSearchPlacesApi extends StatefulWidget {\n  const GoogleMapSearchPlacesApi({Key? key}) : super(key: key);\n\n\n  @override\n  _GoogleMapSearchPlacesApiState createState() => _GoogleMapSearchPlacesApiState();\n}\n\nclass _GoogleMapSearchPlacesApiState extends State<GoogleMapSearchPlacesApi> {\n\n\n  final _controller =  TextEditingController();\n  var uuid =  const Uuid();\n  String _sessionToken = '1234567890';\n  List<dynamic> _placeList = [];\n\n  @override\n  void initState() {\n    super.initState();\n    _controller.addListener(() {\n      _onChanged();\n    });\n  }\n\n  _onChanged() {\n    if (_sessionToken == null) {\n      setState(() {\n        _sessionToken = uuid.v4();\n      });\n    }\n    getSuggestion(_controller.text);\n  }\n\n  void getSuggestion(String input) async {\n\n\n    const String PLACES_API_KEY = \"your api key\";\n\n    try{\n      String baseURL = 'https://maps.googleapis.com/maps/api/place/autocomplete/json';\n      String request = '$baseURL?input=$input&key=$PLACES_API_KEY&sessiontoken=$_sessionToken';\n      var response = await http.get(Uri.parse(request));\n      var data = json.decode(response.body);\n      if (kDebugMode) {\n        print('mydata');\n        print(data);\n      }\n      if (response.statusCode == 200) {\n        setState(() {\n          _placeList = json.decode(response.body)['predictions'];\n        });\n      } else {\n        throw Exception('Failed to load predictions');\n      }\n    }catch(e){\n      print(e);\n    }\n\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        elevation: 0,\n        title: const Text('Search places Api' ,),\n      ),\n      body: Column(\n        mainAxisAlignment: MainAxisAlignment.start,\n        children: <Widget>[\n          Align(\n            alignment: Alignment.topCenter,\n            child: TextField(\n              controller: _controller,\n              decoration: InputDecoration(\n                hintText: \"Search your location here\",\n                focusColor: Colors.white,\n                floatingLabelBehavior: FloatingLabelBehavior.never,\n                prefixIcon: const Icon(Icons.map),\n                suffixIcon: IconButton(\n                  icon: const Icon(Icons.cancel), onPressed: () {\n                  _controller.clear() ;\n                },\n                ),\n              ),\n            ),\n          ),\n          Expanded(\n            child: ListView.builder(\n              physics: NeverScrollableScrollPhysics(),\n              shrinkWrap: true,\n              itemCount: _placeList.length,\n              itemBuilder: (context, index) {\n                return GestureDetector(\n                  onTap: () async {\n\n                  },\n                  child: ListTile(\n                    title: Text(_placeList[index][\"description\"]),\n                  ),\n                );\n              },\n            ),\n          )\n        ],\n      ),\n    );\n  }\n }\n```\n\n세션 토큰에 대해 자세히 알아보고 사용한 이유에 대해 이해하십시오.\n\n감사합니다. 여러분이 무언가 좋은 것을 배웠기를 바랍니다.\n\n이 블로그가 도움이 되었다면 좋아요와 공유를 부탁드립니다.\n","ogImage":{"url":"/assets/img/2024-06-21-IntegratingGoogleAutocompletePlacesAPIinFlutterWithoutExternalPackagesAComprehensiveGuide_0.png"},"coverImage":"/assets/img/2024-06-21-IntegratingGoogleAutocompletePlacesAPIinFlutterWithoutExternalPackagesAComprehensiveGuide_0.png","tag":["Tech"],"readingTime":7},{"title":"Flutter에서 GoRouter의 ShellRoute로 중첩 네비게이션 구현 방법","description":"","date":"2024-06-21 20:39","slug":"2024-06-21-UsingGoRoutersShellRouteinFlutterforNestedNavigation","content":"\n\n안녕하세요 개발자 여러분!\n\n최근 go_router와 그 새로운 기능인 ShellRoute를 사용하여 영속하는 하단 내비게이션 바를 갖춘 중첩된 내비게이션 기능을 개발했는데, 예상대로 잘 작동합니다.\n\n여러분, 제가 보스같이 해내는 걸 한번 보여드릴게요. (Valorant의 Pheonix 대사입니다.)\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*qQvZYaN08kuIFrN6dQEskg.gif\" />\n\n<div class=\"content-ad\"></div>\n\n# 1. 소개:\n\n## GoRouter\n\ngo_router은 Flutter 앱 개발을 위한 패키지로, 앱 내에서 네비게이션을 처리하는 강력하고 유연한 방법을 제공합니다. 이 패키지는 라우터 시스템을 제공하여 앱 내에서 라우트를 정의하고 특정 위젯에 매핑할 수 있습니다. 그 중요한 기능 중 하나는 ShellRoute인데, 이는 앱 내에서 다양한 화면 또는 탭 간에 전환할 수 있는 지속적인 하단 네비게이션 바를 제공합니다.\n\n## ShellRoute\n\n<div class=\"content-ad\"></div>\n\ngo_router의 ShellRoute 기능을 사용하면 부모 경로를 만들어 하단 네비게이션 바를 추가할 수 있어요. 그리고 각 탭이나 스크린으로 표시되는 다양한 하위 경로를 표시할 수 있습니다. 이 기능은 go_router v7.0.0에서 소개되었어요. 이를 통해 여러 화면을 왔다갔다 할 필요 없이 앱의 다른 섹션이나 기능 사이를 쉽게 이동할 수 있습니다. ShellRoute는 또한 각 화면의 상태를 유지하면서 다른 탭이나 스크린 간에 쉽게 전환할 수 있게 해줍니다.\n\n전반적으로 go_router 패키지와 ShellRoute 기능은 Flutter 앱에서 네비게이션을 처리하는 강력하고 유연한 방법을 제공해주며, 앱의 다른 섹션이나 기능 사이를 전환하는 사용자 친화적이고 직관적인 방법을 제공합니다.\n\n## 지속적인 하단 네비게이션 바의 중요성\n\n잘 디자인된 지속적인 하단 네비게이션 바는 사용자 경험을 크게 향상시키고 앱을 더 사용자 친화적으로 만들 수 있어요. 사용자가 앱의 다양한 섹션과 기능을 쉽게 탐색할 수 있도록 도와주어 참여도와 유지율을 향상시킬 수 있습니다. 게다가 지속적인 하단 네비게이션 바는 앱에 더 깔끔하고 전문적인 느낌을 줄 수 있어서 전반적인 브랜드 이미지를 개선할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n요약하면, Flutter 앱에서 지속적인 하단 탐색 바는 쉬운 네비게이션을 제공하고 사용자 경험을 향상시키는 중요한 디자인 요소입니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:800/1*n6GetP4BlzpIwFIHJezhng.gif)\n\n# 2. 준비물:\n\n- PC에 최신 Flutter SDK가 설치되어 있는지 확인하세요\n- 다음 명령어를 실행하여 새 Flutter 프로젝트를 생성하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\n플러터 create go_router_demo\n```\n\n3. 프로젝트에 go_router를 추가하려면 다음 명령을 실행하세요:\n\n```js\nflutter pub add go_router\n```\n\n# 3. 하단 네비게이션 바 스캐폴드:\n\n<div class=\"content-ad\"></div>\n\n부모 화면을 만들어서 하단 네비게이션 바를 유지할 거에요. 이 화면은 자식 위젯을 인자로 받을 거에요. 이 자식 위젯을 이용해서 앱의 자식 경로를 표시하고, 하단 네비게이션 바를 모든 자식 경로에 계속 유지할 거에요.\n\n```js\n  int currentIndex = 0;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: widget.child,\n      bottomNavigationBar: BottomNavigationBar(\n        onTap: changeTab,\n        backgroundColor: const Color(0xffe0b9f6),\n        currentIndex: currentIndex,\n        items: const [\n          BottomNavigationBarItem(icon: Icon(Icons.home), label: 'Home'),\n          BottomNavigationBarItem(icon: Icon(Icons.chat), label: 'Chat'),\n        ],\n      ),\n    );\n  }\n```\n\nchangeTab 함수는 홈 및 채팅 탭 간에 이동하는 것을 다룰 거에요.\n\n```js\nvoid changeTab(int index) {\n    switch(index){\n      case 0:  \n        context.go('/');\n        break;\n      case 1:  \n        context.go('/chat');\n        break;\n      default:\n        context.go('/');\n        break;\n    }\n    setState(() {\n      currentIndex = index;\n    });\n  }\n```\n\n<div class=\"content-ad\"></div>\n\n\n![image](https://miro.medium.com/v2/resize:fit:492/1*OsfeWqkayJSX0KYe-74j3Q.gif)\n\n# 4. 라우터 설정하기:\n\n여기서 모든 마법이 일어납니다.\n\n이 가이드를 위해 4개의 페이지를 만들었습니다:\n\n\n<div class=\"content-ad\"></div>\n\n- 홈\n- 채팅\n- 설정\n- 서비스 약관\n\n이러한 페이지에 중첩된 내비게이션을 가지려면 각 수준의 중첩에 대해 별도의 내비게이션 키가 필요합니다. 우리의 경우, 2개의 내비게이터 키를 생성할 것입니다:\n\n```js\nfinal _rootNavigatorKey = GlobalKey<NavigatorState>();\nfinal _shellNavigatorKey = GlobalKey<NavigatorState>();\n```\n\n_rootNavigatorKey는 부모 내비게이션 스택에 사용되고, _shellNavigatorKey는 ShellRoute와 함께 중첩된 내비게이션에 사용될 것입니다.\n\n<div class=\"content-ad\"></div>\n\n_rootNavigatorKey은 지속적인 BottomNavigationBar를 갖지 말아야 하는 모든 루트에 도움이 될 것이고, _shellNavigatorKey는 BottomNavigationBar가 있는 모든 루트에 사용될 것입니다.\n\n그럼, 이 우리의 원귀적인 목적을 위해 다음과 같은 루트들을 생성해보도록 하겠습니다:\n\n```js\nfinal router = GoRouter(\n  navigatorKey: _rootNavigatorKey,\n  routes: [\n    ShellRoute(\n      navigatorKey: _shellNavigatorKey,\n      builder: (context, state, child) =>\n          BottomNavigationBarScaffold(child: child),\n      routes: [\n        GoRoute(\n          path: '/',\n          parentNavigatorKey: _shellNavigatorKey,\n          builder: (context, state) => const HomePage(),\n        ),\n        GoRoute(\n          path: '/chat',\n          parentNavigatorKey: _shellNavigatorKey,\n          builder: (context, state) => const ChatPage(),\n        ),\n        GoRoute(\n          path: '/settings',\n          parentNavigatorKey: _shellNavigatorKey,\n          builder: (context, state) => const SettingsPage(),\n          routes: [\n            GoRoute(\n              path: 'terms-of-services',\n              parentNavigatorKey: _rootNavigatorKey,\n              builder: (context, state) => const TermsOfServicesPage(),\n            ),\n          ],\n        ),\n      ],\n    )\n  ],\n);\n```\n\n저는 다음과 같은 계층구조로 페이지들을 생성했습니다:\n\n<div class=\"content-ad\"></div>\n\n\n-> 하단 내비게이션 바 스캐폴드\n   -> 홈\n   -> 채팅\n   -> 설정\n      -> 서비스 약관\n\n\n서비스 약관을 제외한 모든 경로는 _shellNavigatorKey를 부모 네비게이터 키로 사용합니다. 이는 서비스 약관 페이지를 제외한 모든 경로가 하단 내비게이션 바 스캐폴드 내에서 탐색되도록 하고, 서비스 약관 페이지는 하단 내비게이션 바 없이 부모 네비게이션 스택에서 완전히 새로운 페이지로 열립니다.\n\n# 5. 경로 간 탐색:\n\n모두 완료되었습니다. 프로젝트에 중첩 네비게이션을 성공적으로 구현했습니다. 우후!! \n\n\n<div class=\"content-ad\"></div>\n\n\n![image](https://miro.medium.com/v2/resize:fit:480/1*-lKavvf7-diWZdV-9TCDcg.gif)\n\n이제 할 일은 go_router에서 제공하는 context.go() 메소드를 사용하여 화면 간을 이동하기만 하면 됩니다. 방금 설정한 라우터가 모든 작업을 대신 처리해 줄 거에요. 멋지죠?!\n\n참고:\n\n\n<div class=\"content-ad\"></div>\n\n# 결론:\n\n요약하면, go_router 패키지와 ShellRoute 기능은 플러터 앱에서 지속적인 하단 네비게이션 바를 구현하는 강력한 솔루션을 제공합니다. 위에 설명된 단계를 따라서 앱의 네비게이션 경험을 향상시키고 전체 사용자 인터페이스를 개선할 수 있습니다. 즐거운 코딩 하세요!\n\n참고: 이 문서에서 제공된 코드 조각들은 예시를 위한 것이며, 특정 앱 구조와 디자인에 맞게 사용자 정의가 필요할 수 있습니다.\n\n참고: 제는 정기적으로 댓글을 확인하며, 궁금한 점이 있거나 해결하기 어려운 문제에 대한 가이드를 작성해 달라면 아래 댓글을 남겨주시면 반드시 도와드리겠습니다!\n\n<div class=\"content-ad\"></div>\n\n![Image](https://miro.medium.com/v2/resize:fit:500/1*FX70ARrhtMfCV40g0ttlAQ.gif)\n\n다음 글에서 뵙겠습니다, 마아살라마!","ogImage":{"url":"/assets/img/2024-06-21-UsingGoRoutersShellRouteinFlutterforNestedNavigation_0.png"},"coverImage":"/assets/img/2024-06-21-UsingGoRoutersShellRouteinFlutterforNestedNavigation_0.png","tag":["Tech"],"readingTime":6},{"title":"Flutter에서 Shared Preferences 사용하기 데모 앱과 함께하는 가이드","description":"","date":"2024-06-21 20:38","slug":"2024-06-21-SharedPreferencesinFlutterAGuidewithaDemonstrativeApp","content":"\n![image](/assets/img/2024-06-21-SharedPreferencesinFlutterAGuidewithaDemonstrativeApp_0.png)\n\n모바일 앱 개발에서의 공유 환경은 사용자 기기에 키-값 쌍의 작은 데이터를 저장할 수 있게 해주는데요. 이 데이터는 영구적이며 앱이 종료된 후에도 접근할 수 있습니다. Flutter에서는 shared_preferences 패키지를 사용하여 공유 환경을 쉽게 관리할 수 있어요.\n\n이 글에서는 Flutter에서의 공유 환경 기본을 살펴보고, 사용 방법을 보여줄 간단한 앱을 만들어볼 거에요.\n\nshared_preferences 시작하기\n\n<div class=\"content-ad\"></div>\n\n\"shared_preferences\" 패키지를 쉽게 추가할 수 있습니다. Flutter 프로젝트에 다음 줄을 pubspec.yaml 파일에 추가하세요:\n\n```yaml\ndependencies:\n  shared_preferences: ^0.5.12+4\n```\n\n의존성을 추가했으면 Dart 파일에서 가져와 초기화할 수 있습니다:\n\n```js\nimport 'package:shared_preferences/shared_preferences.dart';\n\nSharedPreferences prefs;\n\n// 공유 설정 초기화\nprefs = await SharedPreferences.getInstance();\n```\n\n<div class=\"content-ad\"></div>\n\n이제 공유 설정을 초기화했으니, 공유 설정에서 데이터를 저장하고 검색하는 방법을 알아보겠습니다.\n\n공유 설정에 데이터 저장\n\n공유 설정에 데이터를 저장하는 것은 간단하며 아래와 같이 수행할 수 있습니다:\n\n```js\n// 문자열 값을 저장\nprefs.setString(\"키\", \"값\");\n\n// 정수 값을 저장\nprefs.setInt(\"키\", 42);\n\n// 실수 값을 저장\nprefs.setDouble(\"키\", 3.14);\n\n// 부울 값을 저장\nprefs.setBool(\"키\", true);\n```\n\n<div class=\"content-ad\"></div>\n\n공유 프리퍼런스에서 데이터를 검색하는 것은 데이터를 저장하는 것만큼 쉽습니다:\n\n```js\n// 문자열 값 검색\nString stringValue = prefs.getString('key');\n\n// 정수 값 검색\nint intValue = prefs.getInt('key');\n\n// 배정밀도 부동 소수점 값 검색\ndouble doubleValue = prefs.getDouble('key');\n\n// 부울 값 검색\nbool boolValue = prefs.getBool('key');\n```\n\n시연용 앱\n\n<div class=\"content-ad\"></div>\n\n이번에는 Flutter에서의 공유 환경 설정(shared preferences)의 기본적인 이해를 한 것 같네요. 이제 이를 활용한 간단한 앱을 만들어보겠습니다.\n\n이 앱에서는 사용자 이름을 입력하는 TextField와 사용자 이름을 기억할지 여부를 나타내는 SwitchListTile이 있습니다. 스위치가 켜져 있고(true), \"저장\" 버튼이 눌리면 입력된 사용자 이름과 스위치 상태가 공유 환경 설정에 저장됩니다. 앱을 다음에 열면, 이전에 저장된 값이 공유 환경 설정에서 로드되어 Text에 표시되며, Switch는 여전히 true로 설정될 것입니다.\n\n다음은 우리의 데모 앱 코드입니다:\n\n```js\nimport 'package:flutter/material.dart';\nimport 'package:shared_preferences/shared_preferences.dart';\n\nvoid main() => runApp(MyApp());\n\nclass MyApp extends StatefulWidget {\n  @override\n  _MyAppState createState() => _MyAppState();\n}\n\nclass _MyAppState extends State<MyApp> {\n  // 공유 환경 설정 데이터를 저장하는 변수들\n  String _username;\n  bool _rememberMe;\n\n  @override\n  void initState() {\n    super.initState();\n    _loadPreferences();\n  }\n\n  // 공유 환경 설정 데이터를 로드하는 메서드\n  void _loadPreferences() async {\n    final prefs = await SharedPreferences.getInstance();\n    setState(() {\n      _username = prefs.getString('username') ?? '';\n      _rememberMe = prefs.getBool('rememberMe') ?? false;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text('Shared Preferences Demo'),\n        ),\n        body: Padding(\n          padding: const EdgeInsets.all(16.0),\n          child: Column(\n            children: <Widget>[\n              TextField(\n                decoration: InputDecoration(\n                  labelText: 'Username',\n                  hintText: 'Enter your username',\n                ),\n                onChanged: (value) {\n                  setState(() {\n                    _username = value;\n                  });\n                },\n              ),\n              CheckboxListTile(\n                title: Text('Remember me'),\n                value: _rememberMe,\n                onChanged: (value) {\n                  setState(() {\n                    _rememberMe = value;\n                  });\n                },\n              ),\n              RaisedButton(\n                child: Text('Save'),\n                onPressed: () async {\n                  final prefs = await SharedPreferences.getInstance();\n                  prefs.setString('username', _username);\n                  prefs.setBool('rememberMe', _rememberMe);\n                },\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 마크다운 형식으로 변경하세요.\n\n<div class=\"content-ad\"></div>\n\n다음 앱에서 사용하시고 로컬 저장소의 아름다움을 즐기세요!!!\n\n만약 유용하다고 느끼신다면, 좋아요를 남겨주세요\n\n소스 코드: github\n","ogImage":{"url":"/assets/img/2024-06-21-SharedPreferencesinFlutterAGuidewithaDemonstrativeApp_0.png"},"coverImage":"/assets/img/2024-06-21-SharedPreferencesinFlutterAGuidewithaDemonstrativeApp_0.png","tag":["Tech"],"readingTime":4}],"page":"17","totalPageCount":28,"totalPageGroupCount":2,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}