{"pageProps":{"posts":[{"title":"이미지를 실시간으로 크기 조절하는 방법","description":"","date":"2024-06-30 23:03","slug":"2024-06-30-Resizingimageson-the-fly","content":"\n\n\n![Resizing images on the fly](/assets/img/2024-06-30-Resizingimageson-the-fly_0.png)\n\n웹 아키텍트로서 자산 관리는 많은 문제 중 하나입니다. 그리고 자산 중에서도 가장 중요한 문제는 이미지입니다. 하나의 단순한 접근 방식은 이미지를 설정하고 브라우저가 CSS를 통해 이미지를 크기 조정하도록 하는 것입니다:\n\n```css\nimg {\n    height: 100%;\n    width: 100%;\n    object-fit: contain;\n}\n```\n\n하지만 이는 원본 이미지를 다운로드한다는 뜻입니다. 이로써 원본 이미지의 크기와 최적화되지 않은 브라우저 기반 크기 조정 두 가지 문제가 발생합니다.\n\n\n<div class=\"content-ad\"></div>\n\n이 포스트에서는 두 가지 대안을 다룹니다: 전통적인 방법과 새로운 솔루션.\n\n# 미리 크기 조정하기\n\n단일 이미지 원본에 대한 전통적인 솔루션은 미리 크기를 조정하는 것이었습니다. 출시하기 전에 디자이너들은 다양한 해상도의 여러 이미지 버전을 제공하는 데 시간을 할애했습니다. 이 블로그에서는 이 기술을 사용하고 있습니다. 포스트의 주 이미지를 다양한 맥락에서 백그라운드 이미지로 표시하기 위해 세 가지 해상도를 제공합니다:\n\n- 페이지의 포스트용 큰 크기\n- 홈페이지의 포스트용 중간 크기\n- 포스트 페이지에서 관련 포스트용 작은 크기\n\n<div class=\"content-ad\"></div>\n\n저는 더 높은 용량 감소를 위해 JPEG 메타데이터도 제거합니다.\n\n하지만 전통적인 방식은 HTML picture 태그를 활용하는 것입니다:\n\n그리고 다음과 같이 사용할 수 있습니다:\n\n```js\n<picture>\n    <source media=\"(max-width: 199px)\" srcset=\"ai-generated-200.jpg\" />\n    <source media=\"(max-width: 399px)\" srcset=\"ai-generated-400.jpg\" />\n    <source media=\"(max-width: 599px)\" srcset=\"ai-generated-600.jpg\" />\n    <source media=\"(max-width: 799px)\" srcset=\"ai-generated-800.jpg\" />\n    <source media=\"(max-width: 999px)\" srcset=\"ai-generated-1000.jpg\" />\n    <img src=\"ai-generated.jpg\" />\n</picture>\n```\n\n<div class=\"content-ad\"></div>\n\n이 방식은 오랫동안 잘 작동했지만 두 가지 문제가 있습니다. 먼저, 각 이미지에 대해 여러 해상도를 제공하는 작업은 시간이 많이 소요됩니다. 이를 자동화하여 AI를 사용하면 좋은 결과를 얻을 수 있습니다.\n\n그러나 필요한 저장 용량은 추가로 생성된 해상도의 수에 따라 원본 이미지의 두배 또는 세배가 될 수 있습니다. 자산이 풍부한 환경에서 예를 들어 전자 상거래와 같은 경우 비용이 크게 증가할 수 있습니다.\n\n# 실시간 크기 조정\n\n최근에 imgproxy라는 이미지 크기를 실시간으로 조정하는 구성 요소를 우연히 발견했습니다:\n\n<div class=\"content-ad\"></div>\n\nimgproxy는 다음을 정의하는 인코딩된 URL을 보낼 수 있는 엔드포인트를 제공합니다:\n- 변경할 이미지와 위치(로컬, HTTP URL, S3 버킷 등)\n- 다양한 크기 조정 매개변수, 예를 들어, 차원, 맞출지 채울지 여부 등\n- 형식. imgproxy는 JPEG 및 PNG과 같은 표준 형식을 지원하지만 WebP 및 AVIF와 같은 더 현대적인 형식도 지원합니다. 또한 'Accept' 헤더에 따라 최적의 형식을 선택할 수 있습니다.\n- 워터마킹, 필터링, 회전 등 많은(정말 많은!) 다른 옵션들\n\nimgproxy는 오픈 소스 무료 버전과 유료 버전을 제공합니다. 이 포스트에 포함된 모든 내용은 전자의 일부입니다.\n\n한 가지 해결책은 웹 개발자가 HTML에 각 imgproxy URL을 직접 코딩하는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n\n<picture>\n    <source media=\"(max-width: 199px)\" srcset=\"http://imgproxy:8080//rs:fill/w:200/plain/http://server:3000/ai-generated.jpg@webp\" />\n    <source media=\"(max-width: 399px)\" srcset=\"http://imgproxy:8080//rs:fill/w:400/plain/http://server:3000/ai-generated.jpg@webp\" />\n    <source media=\"(max-width: 599px)\" srcset=\"http://imgproxy:8080//rs:fill/w:600/plain/http://server:3000/ai-generated.jpg@webp\" />\n    <source media=\"(max-width: 799px)\" srcset=\"http://imgproxy:8080//rs:fill/w:800/plain/http://server:3000/ai-generated.jpg@webp\" />\n    <source media=\"(max-width: 999px)\" srcset=\"http://imgproxy:8080//rs:fill/w:1000/plain/http://server:3000/ai-generated.jpg@webp\" />\n    <img src=\"ai-generated.jpg\" />\n</picture>\n\n\n웹 페이지에 대한 토폴로지 관련 세부 정보가 노출됩니다. 이는 유지 관리하기 어려운 해결책입니다. 리버스 프록시나 API 게이트웨이를 사용하여 문제를 해결할 수 있습니다. 명백한 이유로 Apache APISIX를 사용하겠습니다.\n\n이 방법을 통해 위의 HTML이 훨씬 간단해집니다:\n\n\n<picture>\n    <source media=\"(max-width: 199px)\" srcset=\"/resize/200/ai-generated.jpg\" />\n    <source media=\"(max-width: 399px)\" srcset=\"/resize/400/ai-generated.jpg\" />\n    <source media=\"(max-width: 599px)\" srcset=\"/resize/600/ai-generated.jpg\" />\n    <source media=\"(max-width: 799px)\" srcset=\"/resize/800/ai-generated.jpg\" />\n    <source media=\"(max-width: 999px)\" srcset=\"/resize/1000/ai-generated.jpg\" />\n    <img src=\"ai-generated.jpg\" />\n</picture>\n\n\n<div class=\"content-ad\"></div>\n\nApache APISIX은 /resize로 시작하는 요청을 가로채어 URL을 imgproxy로 재작성하여 imgproxy에 재작성된 URL을 전달합니다. 전체 흐름은 다음과 같습니다:\n\n![image](/assets/img/2024-06-30-Resizingimageson-the-fly_1.png)\n\n해당 Apache APISIX 구성은 다음과 같습니다:\n\n```js\nroutes:\n  - uri: /resize/*\n    plugins:\n      proxy-rewrite:\n        regex_uri:\n          - /resize/(.*)/(.*)\n          - /rs:fill/w:$1/plain/http://server:3000/$2@webp\n    upstream:\n      nodes:\n        \"imgproxy:8080\": 1\n```\n\n<div class=\"content-ad\"></div>\n\n- **/resize**로 시작하는 요청 일치시키기\n- URL 다시 작성\n- 정규 표현식에서 너비와 이미지 캡처\n- 이미지 프록시를 위한 URL 형식화. http://server:3000은 원본 이미지를 호스팅하는 서버이며, @webp은 브라우저가 지원하는 경우 WebP 형식을 선호함을 나타냄\n\n위와 같이, Apache APISIX에게서 **/resize/200/ai-generated.jpg**를 받으면 imgproxy에서 **/rs:fill/w:200/plain/http://server:3000/ai-generated.jpg@webp**로 다시 작성됩니다.\n\n# 테스트\n\nDocker Compose를 사용하여 작은 테스트 샘플을 설정할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```yaml\nservices:\n  apisix:\n    image: apache/apisix:3.5.0-debian\n    volumes:\n      - ./apisix/config.yml:/usr/local/apisix/conf/config.yaml:ro\n      - ./apisix/apisix.yml:/usr/local/apisix/conf/apisix.yaml:ro\n    ports:\n      - \"9080:9080\"\n  imgproxy:\n    image: darthsim/imgproxy:v3.19\n  server:                                                         #1\n    build: content\n```\n\n- HTML 및 주 이미지를 호스팅하는 간단한 웹 서버\n\n이제 위 설정을 브라우저의 개발자 도구를 사용하여 테스트할 수 있습니다. 작은 화면 장치인 iPhone SE를 흉내 내는 것입니다. 결과는 다음과 같습니다:\n\n<img src=\"/assets/img/2024-06-30-Resizingimageson-the-fly_2.png\" />\n\n\n<div class=\"content-ad\"></div>\n\n- 화면 해상도 때문에 요청된 이미지는 원본 이미지가 아닌 400px 폭 이미지입니다. 요청 URL에서 확인할 수 있어요.\n- 반환된 이미지는 WebP 형식이며, 용량은 14.4kb입니다.\n- 원본 JPEG 이미지는 154kb로, 10배나 더 많은 용량을 차지합니다. 네트워크 대역폭을 아주 많이 절약하는 것이죠!\n\n# 토론\n\n저장 비용을 10배 줄이는 것은 당연히 큰 이점입니다. 하지만 모든 것이 완벽한 것은 아닙니다. 이미지 크기를 조정하는 것은 계산에 많은 비용이 드는 작업이에요. 각 요청마다 CPU 시간이 소요됩니다. 또한 imgproxy가 얼마나 효율적이든 이미지 생성에는 시간이 걸립니다. 우리는 저장 비용을 CPU 비용으로 교환하고, 결과적으로 성능에 약간의 저하가 발생합니다.\n\n이를 해결하려면 앞 단에 캐싱 레이어가 필요합니다. 커스텀 캐싱이나 더 가능한 CDN 등을 사용할 수 있어요. 자산을 다시 저장할 것이라는 이의가 있을 수 있습니다. 따라서 저장 비용이 다시 증가할 거라는 거죠. 그러나 캐시는 사용된 이미지에만 작동하며, 이전 솔루션에서는 모든 이미지를 저장하기 위해 비용을 지불했습니다. 이외에도, 이미지가 필요한 경우에 캐시를 미리 로딩하는 등 캐싱에 대한 이미 알려진 레시피를 적용할 수도 있어요. 예를 들어, 이벤트 전에 필요한 이미지 그룹을 미리 로딩하는 것 등이죠.\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n이 게시물에서는 Apache APISIX와 imgproxy를 사용하여 여러 해상도의 이미지 저장 비용을 줄이는 방법을 설명했습니다. 캐싱을 추가하면 전체 아키텍처에 더 많은 구성 요소가 추가되지만 저장 비용이 줄어듭니다.\n\n이 게시물은 Andreas Lehr의 StackConf 발표에서 영감을 받았습니다.\n\n이 게시물의 전체 소스 코드는 GitHub에서 찾을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n더 알아보기:\n\n- imgproxy 문서\n- imgproxy 인터랙티브 데모\n\n2023년 10월 1일에 A Java Geek에서 처음 발행되었습니다.","ogImage":{"url":"/assets/img/2024-06-30-Resizingimageson-the-fly_0.png"},"coverImage":"/assets/img/2024-06-30-Resizingimageson-the-fly_0.png","tag":["Tech"],"readingTime":6},{"title":"Flask, MongoDB, 그리고 React로 실시간 GitHub Webhook 리스너 만드는 방법","description":"","date":"2024-06-30 23:02","slug":"2024-06-30-BuildingaReal-TimeGitHubWebhookListenerwithFlaskMongoDBandReact","content":"\n\n본 기사에서는 \"Push\", \"Pull Request\", \"Merge\"와 같은 GitHub 웹훅을 수신하는 프로젝트를 만드는 방법을 안내하겠습니다. 이러한 이벤트를 Flask 애플리케이션에서 캡처하고 MongoDB에 저장하며, React 프론트엔드를 사용하여 실시간으로 표시할 것입니다. 마지막으로 Flask 앱을 Vercel에 배포해 보겠습니다.\n\n# 배울 내용\n\n- GitHub 웹훅 설정하는 방법\n- 웹훅을 처리하기 위한 Flask 애플리케이션 만드는 방법\n- 웹훅 데이터를 MongoDB에 저장하는 방법\n- 실시간 업데이트를 표시하는 React 애플리케이션 만드는 방법\n- Flask 애플리케이션을 Vercel에 배포하는 방법\n\n# 준비물\n\n<div class=\"content-ad\"></div>\n\n- Python, Flask 및 React에 대한 기본 지식\n- GitHub 계정\n- 로컬에 MongoDB 설치 또는 클라우드 MongoDB 서비스\n- Node.js 및 npm 설치\n- Vercel 계정\n\n## 단계 1: GitHub Webhook 설정\n\n- GitHub 저장소 설정\n\nGitHub에서 새 저장소를 만듭니다.\n\nGitHub에서 action-repo라는 새 저장소를 만듭니다. 이 저장소는 \"Push\", \"Pull Request\", \"Merge\"와 같은 이벤트에 기반하여 웹훅을 트리거합니다.\n\n<div class=\"content-ad\"></div>\n\n2. 웹훅 추가하기\n\n- GitHub의 작업 리포지토리로 이동합니다.\n- 설정에서 웹훅(Webhooks)으로 이동합니다.\n- 웹훅 추가를 클릭합니다.\n- 페이로드 URL을 Flask 앱의 엔드포인트로 설정합니다 (나중에 이를 설정할 예정입니다).\n- 컨텐츠 유형을 application/json으로 설정합니다.\n- 개별 이벤트를 선택하도록 \"푸쉬(Push)\", \"풀 리퀘스트(Pull Request)\", \"병합(Merge)\" 이벤트를 선택합니다.\n- 웹훅 추가를 클릭합니다.\n\n# 단계 2: Flask 애플리케이션 생성\n\n- 프로젝트 초기화\n\n<div class=\"content-ad\"></div>\n\n플라스크 프로젝트를 위한 webhook-repo라는 디렉토리를 만들어보세요.\n\n```js\nmkdir webhook-repo\ncd webhook-repo\npython3 -m venv venv\nsource venv/bin/activate\npip install Flask pymongo\n```\n\n2. Flask 앱 만들기\n\nwebhook-repo 디렉토리에 다음 코드를 사용하여 app.py를 만들어보세요.\n\n<div class=\"content-ad\"></div>\n\n```python\nfrom flask import Flask, request, jsonify\nfrom pymongo import MongoClient\nfrom datetime import datetime\n\napp = Flask(__name__)\n\n# MongoDB 연결\nclient = MongoClient('mongodb://localhost:27017/')\ndb = client['github_webhooks']\ncollection = db['events']\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    data = request.json\n    event_type = request.headers.get('X-GitHub-Event')\n    \n    if event_type == 'push':\n        author = data['pusher']['name']\n        to_branch = data['ref'].split('/')[-1]\n        timestamp = datetime.strptime(data['head_commit']['timestamp'], \"%Y-%m-%dT%H:%M:%SZ\")\n        event_data = {\n            \"type\": \"push\",\n            \"author\": author,\n            \"to_branch\": to_branch,\n            \"timestamp\": timestamp\n        }\n    elif event_type == 'pull_request':\n        author = data['pull_request']['user']['login']\n        from_branch = data['pull_request']['head']['ref']\n        to_branch = data['pull_request']['base']['ref']\n        timestamp = datetime.strptime(data['pull_request']['created_at'], \"%Y-%m-%dT%H:%M:%SZ\")\n        event_data = {\n            \"type\": \"pull_request\",\n            \"author\": author,\n            \"from_branch\": from_branch,\n            \"to_branch\": to_branch,\n            \"timestamp\": timestamp\n        }\n    elif event_type == 'pull_request' and data['pull_request']['merged']:\n        author = data['pull_request']['user']['login']\n        from_branch = data['pull_request']['head']['ref']\n        to_branch = data['pull_request']['base']['ref']\n        timestamp = datetime.strptime(data['pull_request']['merged_at'], \"%Y-%m-%dT%H:%M:%SZ\")\n        event_data = {\n            \"type\": \"merge\",\n            \"author\": author,\n            \"from_branch\": from_branch,\n            \"to_branch\": to_branch,\n            \"timestamp\": timestamp\n        }\n    else:\n        return jsonify({'message': '지원되지 않는 이벤트입니다'}), 400\n\n    collection.insert_one(event_data)\n    return jsonify({'message': '이벤트가 수신되었습니다'}), 200\n\n@app.route('/events', methods=['GET'])\ndef get_events():\n    events = list(collection.find().sort(\"timestamp\", -1).limit(10))\n    for event in events:\n        event['_id'] = str(event['_id'])\n    return jsonify(events), 200\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=5000)\n```\n\n3. requirements.txt 파일 생성\n\n필요한 의존성이 명시된 requirements.txt 파일을 만들어주세요:\n\n```python\nFlask\npymongo\n```\n\n<div class=\"content-ad\"></div>\n\n# 단계 3: Vercel에 Flask 앱 배포하기\n\n- vercel.json 파일 만들기\n\nvercel.json 설정 파일을 만듭니다:\n\n```js\n{\n  \"version\": 2,\n  \"builds\": [\n    {\n      \"src\": \"app.py\",\n      \"use\": \"@vercel/python\"\n    }\n  ],\n  \"routes\": [\n    {\n      \"src\": \"/(.*)\",\n      \"dest\": \"app.py\"\n    }\n  ]\n}\n```\n\n<div class=\"content-ad\"></div>\n\n2. Vercel에 배포하기\n\n- Vercel CLI 설치하기: npm install -g vercel\n- Vercel에 로그인하기: vercel login\n- 프로젝트를 배포하기: vercel\n\n# 단계 4: React 프론트엔드 생성\n\n- React 앱 설정하기\n\n<div class=\"content-ad\"></div>\n\nReact 애플리케이션을 새로 만들어 보세요:\n\n```js\nnpx create-react-app github-webhooks-ui\ncd github-webhooks-ui\nnpm install axios\n```\n\n2. App.js 파일을 만들어 보세요\n\nApp.js 파일 내용을 다음과 같이 변경해 주세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport React, { useState, useEffect } from 'react';\nimport axios from 'axios';\nimport './App.css';\n\nconst App = () => {\n  const [events, setEvents] = useState([]);\n\n  useEffect(() => {\n    const fetchEvents = async () => {\n      try {\n        const response = await axios.get('https://your-vercel-app.vercel.app/events');\n        setEvents(response.data);\n      } catch (error) {\n        console.error('Error fetching events', error);\n      }\n    };\n\n    fetchEvents();\n    const interval = setInterval(fetchEvents, 15000);\n    return () => clearInterval(interval);\n  }, []);\n\n  return (\n    <div className=\"App\">\n      <h1>GitHub Repository Events</h1>\n      <ul>\n        {events.map(event => (\n          <li key={event._id}>\n            {event.type === 'push' && `${event.author} pushed to ${event.to_branch} on ${new Date(event.timestamp).toUTCString()}`}\n            {event.type === 'pull_request' && `${event.author} submitted a pull request from ${event.from_branch} to ${event.to_branch} on ${new Date(event.timestamp).toUTCString()}`}\n            {event.type === 'merge' && `${event.author} merged branch ${event.from_branch} to ${event.to_branch} on ${new Date(event.timestamp).toUTCString()}`}\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n};\n\nexport default App;\n```\n\n3. React 앱 실행\n\nReact 애플리케이션을 시작하려면:\n\n```js\nnpm start\n```\n\n<div class=\"content-ad\"></div>\n\n# 테스트 및 확인\n\n- GitHub 웹훅 업데이트:\n\nGitHub 웹훅 설정에서 Payload URL을 배포된 Vercel의 Flask 앱을 가리키도록 업데이트하십시오:\n\n```js\nhttps://your-vercel-app.vercel.app/webhook\n```\n\n<div class=\"content-ad\"></div>\n\n2. 트리거 이벤트:\n\n- Push Action: 변경 사항을 만들어서 action-repo에 푸시합니다.\n- Pull Request Action: 새 브랜치를 만들어서 변경 사항을 적용하고 푸시한 다음 풀 리퀘스트를 오픈합니다.\n- Merge Action: 풀 리퀘스트를 병합합니다.\n\n3. 확인: React 앱을 확인해서 이벤트가 올바르게 표시되는지 확인해보세요.\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\n이 프로젝트에서는 다음을 배웠습니다:\n\n- GitHub 웹훅 설정 및 처리 방법\n- 웹훅 이벤트를 처리하는 Flask 애플리케이션 생성\n- MongoDB에 이벤트 저장\n- React 프론트엔드를 사용하여 실시간 이벤트 표시\n- Vercel에 Flask 애플리케이션 배포\n\n이 프로젝트는 다양한 기술을 통합하여 실시간 업데이트를 효율적으로 처리하는 풀 스택 애플리케이션을 보여줍니다. 궁금한 점이나 개선하고 싶은 부분이 있으면 인증, 추가적인 이벤트 유형 또는 더 다양하고 진보된 UI 요소를 추가하여 이 프로젝트를 확장해보세요.\n\n즐거운 코딩되세요!","ogImage":{"url":"/assets/img/2024-06-30-BuildingaReal-TimeGitHubWebhookListenerwithFlaskMongoDBandReact_0.png"},"coverImage":"/assets/img/2024-06-30-BuildingaReal-TimeGitHubWebhookListenerwithFlaskMongoDBandReact_0.png","tag":["Tech"],"readingTime":7},{"title":"25개월 휴식 후 코딩한 앱, 정말 멋진 결과물","description":"","date":"2024-06-30 23:00","slug":"2024-06-30-Icodedanappafter25MONTH-BREAKanditactuallylookscool","content":"\n\n## 플러터를 사용한 심플한 룩의 날씨 앱 (소스 코드 제공 가능)\n\n![이미지](/assets/img/2024-06-30-Icodedanappafter25MONTH-BREAKanditactuallylookscool_0.png)\n\n코딩 피로를 극복하기 위해 다양한 기술과 분야를 탐험한 후, 2.5개월 만에 코딩으로 돌아오기로 결정했습니다. 제 목표는 간단하지만 동시에 멋지게 보이는 것을 만드는 것이었습니다. 그래서 무엇을 만들었을까요? 날씨 앱입니다. 알아요, 기본적인 것 같긴 하지만, 제 오프닝을 할 수 있는 무언가를 만들어야 했고 그래서 날씨 앱을 만들기로 했습니다. 쉽고, 동시에 유용한 것을 만든 만족감을 주거든요.\n\n인도의 온도가 50도 이상으로 치솟고 있어 모든 이들의 눈은 뉴스 채널과 날씨 앱에 집중되어 있어 앱을 만드는 것이 완벽한 시기라고 생각했습니다. 더 좋은 디자인을 위해 더 많이 나아갔으며, 색상은 더욱 간소하고 단어는 더욱 줄이기로 했습니다. 그래서 Figma를 열어 (몇 달 만에), UI를 디자인하기 시작했고, 어떻게든 꽤 괜찮아 보였습니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-30-Icodedanappafter25MONTH-BREAKanditactuallylookscool_1.png\" />\n\n그래서, 이게 제가 디자인한 거에요. 가능한 한 간단하게 만들려고 노력했어요. 색상도 없고 멋진 건 없어요. 괜찮음이 최고죠!\n\n## 코딩 부분 :\n\n이제 어려운 부분이 시작됐습니다 (그렇게 어렵지는 않아요. 그냥 날씨 앱이거든요. 유튜브에 수백 개의 자습서를 찾을 수 있을 거에요) — 코딩이죠. 빠른 조언: 앱을 만드는 게 목표라면, 워크플로부터 시작해보세요. 멋진 걸 하려 할 필요는 없어요; 종이 한 장 가지고 무엇을 만들 계획 중인지 적어보세요. 항상 완전한 앱을 고려해보세요.\n\n<div class=\"content-ad\"></div>\n\n예를 들어 전자 상거래 앱을 고려해보세요. 기본 레이아웃은 무엇이어야 할까요?\n\n- 홈페이지\n- 다양한 제품 및 카테고리 검색 화면\n- 제품 상세 화면\n- 장바구니 화면\n- 주문 완료 화면\n\n물론, 이 외에도 많은 요소가 있지만, 이렇게 계획을 세우면 앱 시작부터 끝까지의 고정된 개발 방향을 얻을 수 있습니다. 이 방법이 저에게 효과적으로 작동했어요. 프로젝트가 완전히 계획되지 않았을 때 저를 괴롭히고 미루게 만던 일이 많았거든요. 이 기본적인 날씨 앱의 경우, 별도의 워크플로를 설계할 필요가 없었습니다.\n\n## 이 프로젝트를 다음과 같이 나누어 봅시다:\n\n<div class=\"content-ad\"></div>\n\n내가 하는 일은 Figma 디자인과 유사한 앱의 완전한 UI를 구축한 다음 서비스 및 API 부분으로 넘어가는 것이에요. 그 다음에는 다양한 애니메이션을 시도해보죠. Figma에서 디자인하고 다양한 애니메이션을 시도할 필요는 없어요. 그렇게 하면 시간이 많이 소요될 수 있어요. 대신, 앱이 제대로 작동한 후에 코드로 직접 애니메이션을 시도해보세요. 다시 한 번 강조하지만, 애니메이션에 너무 신경 쓸 필요는 없어요. 저는 단지 애니메이션을 위해 animate 패키지를 사용했죠.\n\n그리고 한 가지 더: 의존성 및 패키지는 생명 구원자들이에요. 특히 학습 단계에서는 주저하지 말고 사용하세요.\n\n## API 부분은 즐거워요 :\n\n한 번 앱에 API를 구현하면 멈출 수가 없어요. API와 모델/서비스에 익숙해지기 시작하면 실제로 앱 개발을 즐기기 시작할 거예요.\n\n<div class=\"content-ad\"></div>\n\n## 실제 코드 :\n\n의존성: 제가 사용한 종속성들입니다.\n\n![2024-06-30-Icodedanappafter25MONTH-BREAKanditactuallylookscool_2](/assets/img/2024-06-30-Icodedanappafter25MONTH-BREAKanditactuallylookscool_2.png)\n\n이 앱의 핵심 - `WeatherData services class page`입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport 'dart:convert';\n\nimport 'package:basicweatherapp/constants.dart';\nimport 'package:geocoding/geocoding.dart';\nimport 'package:geolocator/geolocator.dart';\nimport 'package:http/http.dart' as https;\n\nclass WeatherData {\n  String? cityname;\n  static const base_url = \"http://api.openweathermap.org/data/2.5/weather\";\n  Position? data;\n  \n  // 현재 위치의 도시 이름을 반환하는 메서드\n  Future<String> getcurrentcity() async {\n    // 위치 권한 요청\n    LocationPermission permission = await Geolocator.requestPermission();\n    if (permission == LocationPermission.denied) {\n      await Geolocator.requestPermission();\n    }\n    \n    // 현재 위치의 위도와 경도 데이터를 가져옴\n    Position position = await Geolocator.getCurrentPosition(\n        desiredAccuracy: LocationAccuracy.high);\n\n    // 위도와 경도 정보를 기반으로 현재 도시를 가져옴\n    List<Placemark> placemark =\n        await placemarkFromCoordinates(position.latitude, position.longitude);\n    String? city = placemark[0].locality ?? \"Bahraich\";\n    return city;\n  }\n\n  // 도시를 기반으로 날씨 데이터 반환\n  Future getWeatherReport(String city) async {\n    // API를 호출하여 날씨 데이터 가져오기\n    https.Response response =\n        await https.get(Uri.parse(\"$base_url?q=$city&appid=$api&units=metric\"));\n    if (response.statusCode == 200) {\n      var data = jsonDecode(response.body);\n      return data;\n    } \n    else {\n      throw Exception(\"날씨 데이터를 불러오는 데 실패했습니다\");\n    }\n  }\n}\n```\n\n모델을 사용하지 않았지만 이해를 돕기 위해 간단하게 작성했습니다.\n\nAPI를 성공적으로 호출할 때 데이터가 어떻게 보이는지 예시입니다. 맵과 리스트에 대한 이해가 있으면 이해하기 쉬울 것입니다.\n\n<div class=\"content-ad\"></div>\n\n기능 및 메소드: 이 앱에서 사용한 총 5개의 메소드에 대한 설명이 제대로 주석으로 달려 있습니다(전체 코드는 게시물의 뒷부분에 제공됩니다). 이러한 메소드는 홈 화면에서 사용됩니다.\n\n![이미지](/assets/img/2024-06-30-Icodedanappafter25MONTH-BREAKanditactuallylookscool_3.png)\n\n홈 화면 코드:\n\n처음에는 코드가 복잡해 보일 수 있지만 전체 코드를 읽으면 모든 것을 이해할 수 있을 건데요.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport 'package:basicweatherapp/constants.dart';\nimport 'package:basicweatherapp/networkErrorPage.dart';\n\nimport 'package:basicweatherapp/weatherdata.dart';\nimport 'package:basicweatherapp/widgets/Drawercontent.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter_animate/flutter_animate.dart';\n\nclass HomePage extends StatefulWidget {\n  const HomePage({super.key});\n\n  @override\n  State<HomePage> createState() => _HomePageState();\n}\n\nclass _HomePageState extends State<HomePage> {\n  TextEditingController citycontroller = TextEditingController();\n  WeatherData weatherData = WeatherData();\n\n  String? city;\n  double? temp;\n  String? condition;\n  String? country;\n  bool isLoading = true; // 이 상태 변수를 추가했어요\n\n// 현재 위치 도시 날씨 데이터를 가져오기\n  void fetchData() async {\n    setState(() {\n      isLoading = true; // 데이터를 가져오기 시작할 때 로딩을 true로 설정해줘요\n    });\n\n    String cityname = await weatherData.getcurrentcity();\n\n    try {\n      final weather = await weatherData.getWeatherReport(cityname);\n      setState(() {\n        city = weather[\"name\"];\n        temp = weather[\"main\"][\"temp\"];\n        condition = weather[\"weather\"][0][\"main\"];\n        country = weather[\"sys\"][\"country\"];\n        isLoading = false; // 데이터를 가져온 후에 로딩을 false로 설정해줘요\n      });\n    } catch (e) {\n      setState(() {\n        isLoading = false; // 에러가 발생해도 로딩을 false로 설정해줘요\n      });\n      Navigator.push(\n        context,\n        MaterialPageRoute(\n          builder: (context) => NetworkErrorPage(\n            retryCallback: fetchData,\n          ),\n        ),\n      );\n    }\n  }\n\n// 특정 도시 날씨 데이터 가져오기\n  void getCityData(String searchCity) async {\n    setState(() {\n      isLoading = true; // 데이터를 가져오기 시작할 때 로딩을 true로 설정해줘요\n    });\n\n    try {\n      final weather = await weatherData.getWeatherReport(searchCity);\n      setState(() {\n        city = weather[\"name\"];\n        temp = weather[\"main\"][\"temp\"];\n        condition = weather[\"weather\"][0][\"main\"];\n        country = weather[\"sys\"][\"country\"];\n        isLoading = false; // 데이터를 가져온 후에 로딩을 false로 설정해줘요\n      });\n    } catch (e) {\n      setState(() {\n        isLoading = false;\n\n        Navigator.push(\n          context,\n          MaterialPageRoute(\n            builder: (context) => NetworkErrorPage(\n              retryCallback: fetchData,\n            ),\n          ),\n        );\n      });\n    }\n  }\n\n// 다른 온도 범위에 따라 다른 메시지를 표시해주는 메소드\n  String getWeatherMessage(double? temp) {\n    if (temp == null) return \"로딩 중...\";\n\n    if (temp <= 0) {\n      return \"추워요... 따뜻하게 입으세요!\";\n    } else if (temp > 0 && temp <= 10) {\n      return \"쌀쌀해요. 자켓을 입어요!\";\n    } else if (temp > 10 && temp <= 20) {\n      return \"시원한 날씨에요. 신선한 공기를 즐기세요!\";\n    } else if (temp > 20 && temp <= 30) {\n      return \"따뜻하고 쾌적해요. 야외 활동하기 딱 좋아요!\";\n    } else if (temp > 30 && temp <= 40) {\n      return \"더워요. 수분을 보충하세요!\";\n    } else {\n      return \"극심한 더위! 주의를 기울이고 시원하게 지내세요.\";\n    }\n  }\n\n// 이 메소드는 \"메인 날씨 조건\"에 따라 다른 \"이미지 경로\"를 문자열로 반환해줘요\n  String getWeatherIcon(String? maincondition) {\n    if (maincondition == null) return \"images/sunny.png\";\n\n    switch (maincondition.toLowerCase()) {\n      case \"clouds\":\n      case \"fog\":\n      case \"dust\":\n      case \"mist\":\n      case \"haze\":\n        return \"images/clouds.png\";\n\n      case \"rain\":\n      case \"drizzle\":\n      case \"shower rain\":\n        return \"images/rain.png\";\n\n      case \"thunderstand\":\n        return \"images/thunderstorm.png\";\n\n      case \"clear\":\n        return \"images/sunny.png\";\n\n      default:\n        return \"images/sunny.png\";\n    }\n  }\n\n  WeatherData data = WeatherData();\n\n  @override\n  void initState() {\n    // TODO: implement initState\n    super.initState();\n    fetchData();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    Size size = MediaQuery.of(context).size;\n    return Scaffold(\n      drawer: Drawer(\n        child: DrawerContent(),\n        width: size.width * 0.5,\n      ).animate().fadeIn(duration: 1.seconds),\n      appBar: AppBar(\n        actions: [\n          Padding(\n            padding: EdgeInsets.only(right: 10),\n            child: InkWell(\n              onTap: () {\n                fetchData();\n              },\n              child: Icon(\n                Icons.location_on_outlined,\n                size: 30,\n              ).animate().fadeIn(duration: 1.seconds),\n            ),\n          )\n        ],\n      ),\n      body: isLoading ? buildLoadingIndicator() : showUi(),\n    );\n  }\n\n  Widget buildLoadingIndicator() {\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          Text(\n            \"날씨 데이터를 불러오는 중..\",\n            style: TextStyle(\n              fontSize: 20,\n              fontWeight: FontWeight.w300,\n            ),\n          ),\n          SizedBox(\n            height: 10,\n          ),\n          CircularProgressIndicator(\n            color: Colors.black,\n            strokeWidth: 1.5,\n          )\n        ],\n      ),\n    );\n  }\n\n  Widget showUi() {\n    Size size = MediaQuery.of(context).size;\n    return Padding(\n      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),\n      child: SingleChildScrollView(\n        child: Column(\n          children: [\n            SizedBox(\n              height: 15,\n            ),\n            Image.asset(\"images/city.png\")\n                .animate()\n                .fadeIn(duration: 1.seconds),\n            SizedBox(\n              height: 10,\n            ),\n            Text(\n              city ?? \"\",\n              style: TextStyle(\n                fontSize: 25,\n                fontWeight: FontWeight.w300,\n              ),\n            ).animate().fadeIn(duration: 1.seconds),\n            Text(\n              country ?? \" \",\n              style: TextStyle(\n                fontSize: 15,\n                fontStyle: FontStyle.italic,\n                fontWeight: FontWeight.w300,\n              ),\n            ).animate().fadeIn(duration: 1.seconds),\n            SizedBox(\n              height: 15,\n            ),\n            Row(\n              children: [\n                Padding(\n                  padding: EdgeInsets.only(left: 20),\n                  child: Image.asset(\n                    getWeatherIcon(condition),\n                  ).animate().fadeIn(duration: 1.seconds),\n                ),\n                SizedBox(width: 40),\n                Column(\n                  children: [\n                    Row(\n                      children: [\n                        Text(\n                          temp?.toString() ?? \" \",\n            style: style,\n                        ).animate().fadeIn(duration: 1.seconds),\n                        Text(\n                          \" °C\",\n            style: style,\n                        ).animate().fadeIn(duration: 1.seconds),\n                      ],\n                    ),\n                    Text(\n                      condition ?? \" \",\n                      style: const TextStyle(\n                        fontSize: 15,\n                        fontStyle: FontStyle.italic,\n                        fontWeight: FontWeight.w300,\n                      ),\n                    ).animate().fadeIn(duration: 1.seconds),\n                  ],\n                ),\n              ],\n            ),\n            SizedBox(\n              height: size.height * 0.12,\n            ),\n            Text(\n              getWeatherMessage(temp),\n              style: TextStyle(\n                fontSize: 25,\n                fontWeight: FontWeight.w300,\n              ),\n            ).animate().fadeIn(duration: 1.seconds).then(delay: 1000.ms).slide(),\n            SizedBox(height: size.height * 0.06),\n            Image.asset(\"images/cities.png\").animate().fadeIn(duration: 1.seconds),\n            SizedBox(height: size.height * 0.07),\n            InkWell(\n              onTap: onTap,\n              child: Hero(\n                tag: \"search\",\n                child: Image.asset(\"images/search.png\"),\n              ),\n            ),\n            SizedBox(height: 5),\n            GestureDetector(\n              onTap: onTap,\n              child: Text(\n                '다른 도시 찾기',\n                style: TextStyle(\n                  fontSize: 20,\n                  fontStyle: FontStyle.italic,\n                  fontWeight: FontWeight.w300,\n                ),\n              ).animate().fadeIn(duration: 1.seconds),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n// 이 메소드는 다른 도시를 검색하기 위해 bottomModelSheet를 열어줘요.\n  void onTap() {\n    showModalBottomSheet(\n      context: context,\n      builder: (context) {\n        return SingleChildScrollView(\n          keyboardDismissBehavior: ScrollViewKeyboardDismissBehavior.onDrag,\n          child: Column(\n            children: [\n              SizedBox(\n                height: 40,\n              ),\n              Padding(\n                padding: EdgeInsets.symmetric(horizontal: 30),\n                child: TextField(\n                  controller: citycontroller,\n                  decoration: InputDecoration(\n                    hintStyle: TextStyle(\n                      color:","ogImage":{"url":"/assets/img/2024-06-30-Icodedanappafter25MONTH-BREAKanditactuallylookscool_0.png"},"coverImage":"/assets/img/2024-06-30-Icodedanappafter25MONTH-BREAKanditactuallylookscool_0.png","tag":["Tech"],"readingTime":13},{"title":"플러터 ToDo 애플리케이션 파트 1 인프라설정 방법","description":"","date":"2024-06-30 22:59","slug":"2024-06-30-FlutterToDoapplicationPart1Infrastructure","content":"\n\n이 시리즈의 기사에서는 Flutter를 활용하여 ToDo 애플리케이션을 만들고 여러 플랫폼에서 사용하는 방법을 살펴보겠습니다. (전체 소스 코드는 GitHub에서 확인할 수 있으며, 이 시리즈의 기사를 건너뛰고 언제든지 소스 코드를 다운로드할 수 있습니다.)\n\n우선, 이러한 모든 것을 이해하기 위해 몇 가지 요구 사항이 필요합니다:\n\n- Clean Architecture\n- Multi-language\n- Multi-theme\n- Bloc\n- Unit test\n- Relational Database\n\n어느 부분이 익숙하지 않다면 각 섹션에 대해 발행된 기사를 클릭하여 읽을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n먼저 UI를 확인해야 해요. Bemani가 이 UI를 만들었고, 아래 링크에서 찾을 수 있어요.\n\n프로젝트 분석 후 코딩을 시작해요. 이 프로젝트 구조는 Clean Architecture를 기반으로 하고, 관련 기사를 참고하여 다국어 및 다테마를 추가했어요. (이 구조에 대한 더 자세한 내용은 관련 기사를 읽어보세요.)\n\n![이미지](/assets/img/2024-06-30-FlutterToDoapplicationPart1Infrastructure_0.png)\n\n# res 폴더 안에는 무엇이 있나요?\n\n<div class=\"content-ad\"></div>\n\n프로젝트에서 반복적으로 사용하는 도우미 클래스를 몇 개 만들었습니다. 아래는 일부 중요한 클래스의 소스 코드입니다.\n\n## Dimens\n\nUI의 모든 위젯에는 크기, 패딩, 둥근 모서리 등이 있습니다. 이러한 것들을 코드에 넣고 중앙에 배치하지 않으면 나중에 일부 치수를 변경할 때 문제가 발생할 수 있습니다. 그래서 이러한 값을 중앙에 정리하는 것이 좋습니다.\n\n## drawable\n\n<div class=\"content-ad\"></div>\n\n차원과 마찬가지로 아이콘, 카드 배경, 그림자 등과 같은 반복 가능한 드로어블을 사용합니다.\n\n## 스타일\n\n일부 텍스트 스타일과 애플리케이션 테마 클래스가 이 패키지 내에 있습니다.\n\n# src 폴더에는 무엇이 있나요?\n\n<div class=\"content-ad\"></div>\n\n이 폴더에서는 응용 프로그램의 src 코드를 작성합니다. 이 폴더는 깔끔한 아키텍처 역할을 따라 (더 자세한 내용은 이 기사를 읽어보세요) 흐릅니다. 우리의 src 코드에는 3개의 계층이 있습니다.\n\nApp, Domain, Data.\n\n![이미지](/assets/img/2024-06-30-FlutterToDoapplicationPart1Infrastructure_1.png)\n\n- app: 이 계층에는 UI 로직 및 다른 것들에 대한 UI와 관련된 모든 것이 의존하지 않고 포함되어 있습니다. 우리는 상태 관리자로 Bloc을 사용하고 UI를 간단한 재사용 가능한 위젯으로 분할했습니다. 각 블록 상태는 도메인 레이어에 있는 사용 사례에만 의존합니다.\n- domain: 이 계층에는 UI 데이터 모델, 리포지토리 및 사용 사례가 포함되어 있습니다. UI 계층은 사용 사례에만 의존하며 각 사용 사례는 하나 이상의 리포지토리에 의존합니다. 사용 사례는 항목이나 기능으로 분할될 수 있으며, 예를 들어, 모든 작업에 대한 모든 기능을 포함하는 TaskUseCase가 있을 수 있습니다. 또는 AddTaskUseCase, EditTaskUseCase, DeleteTaskUseCase 등과 같이 기능별로 분할할 수 있습니다. 이 프로젝트에서는 작업을 위한 하나의 사용 사례, TaskUseCase만 있지만, 재사용성과 SOLID를 위해 기능별로 분할하는 것이 좋습니다.\n- data: 이 계층은 도메인 레이어에 존재하는 리포지토리에 의존하며 데이터를 저장하거나 검색하는 데 필요한 모든 논리를 포함하고 있습니다. 도메인 레이어의 각 리포지토리에 대해 데이터 레이어에는 여러 데이터를 사용할 수 있는 하나의 구현이 있습니다. 각 데이터 제공자는 해당 구현에 데이터를 제공해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n왜 우리는 이러한 레이어를 사용하고 간단한 방법을 사용하지 않을까요?\n\n이 질문에 대한 답은 확장성 및 테스트 용이성으로 요약됩니다. 여러 레이어가 있고 서로 직접적으로 관련이 없는 경우 각 레이어와 클래스에 대해 독립적으로 테스트를 작성할 수 있습니다.\n\n애플리케이션을 개발할 때는 기능별로 코드를 작성해야 하며, 한꺼번에 모든 도메인 또는 데이터 레이어 클래스를 작성해서는 안 됩니다. 하지만 이 시리즈의 기사를 요약하면 이렇게 한다.\n\n이 프로젝트의 전체 소스 코드는 GitHub의 이 저장소에서 확인할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n다음은 저희 애플리케이션의 다음 단계입니다:\n\n도메인 레이어\n\n데이터 레이어\n\n애플리케이션 레이어","ogImage":{"url":"/assets/img/2024-06-30-FlutterToDoapplicationPart1Infrastructure_0.png"},"coverImage":"/assets/img/2024-06-30-FlutterToDoapplicationPart1Infrastructure_0.png","tag":["Tech"],"readingTime":3},{"title":"뉴욕 타임스가 Wordle을 바꿨다 내가 증명하는 방법","description":"","date":"2024-06-30 18:49","slug":"2024-06-30-NewYorkTimesHasChangedWordleICanProveIt","content":"\n\n\n![2024-06-30-NewYorkTimesHasChangedWordleICanProveIt_0](/assets/img/2024-06-30-NewYorkTimesHasChangedWordleICanProveIt_0.png)\n\n안녕하세요! 저는 주로 웹 앱 개발을 하는 주간 소프트웨어 개발자입니다. Netflix와 같은 대기업부터 PBS NewsHour와 같은 비영리 단체, 그리고 스타트업까지 다양한 회사에서 일해봤어요. 웹에서 \"이걸 어떻게 만들었을까?\" 라는 질문에 대한 해답을 찾는 건 제가 즐기는 일 중 하나에요.\n\nWordle가 인기를 얻기 시작했을 때, 저도 열광적으로 참여했어요. 800일 이상 연속으로 게임을 즐겼죠 (참고로, 그 기간 동안 두 명의 아이가 태어났는데, 네, 출산실에서도 게임을 했어요). 그래서 먼저 한 일 중 하나는 원래 게임을 만든 저자가 어떻게 만들었는지 알아내는 것이었어요.\n\n뉴욕 타임스가 인수하기 전까지, 전체적으로 그냥 간단한 웹 앱이었죠. 제작자는 명확히 앱 스토어에 출시하지 않겠다고 밝히며 웹 기반 게임을 홍보하고 싶다고 말했어요. 점점 인기를 얻는 프로그레시브 웹 앱 (PWA)이 이렇게 많은 주목을 받는 것을 보는 걸 정말 좋아했어요.\n\n\n<div class=\"content-ad\"></div>\n\n온라인에서 모든 것이 가능했기 때문에 소스 코드를 쉽게 확인하고 \"저걸 어떻게 한 거지?\"라는 질문에 답할 수 있었어요!\n\n추신으로, 그 당시에는 코드가 미니파이드되지 않았기 때문에 JavaScript 개발자에게는 게임이 어떻게 구축되었는지 정확히 볼 수 있어서 특히 쉬웠어요. 게임이 개인 정보를 수집하지 않았던 당시에는 문제가 되지 않았죠.\n\n웹 기반 게임의 두 번째 장점은 크롬 익스텐션을 작성할 수 있다는 것이었어요. 놓친 경우 이전 날짜로 돌아가서 플레이할 수 있으면 멋질 것 같아서 그렇게 생각했죠. 제가 만든 익스텐션은 정확히 그것을 가능하게 했어요. 좌측 상단에 작은 입력란을 추가해놓았어요. 거기에 날짜를 입력하면, 과거로 돌아가서 그 단어를 플레이할 수 있어요!\n\n![이미지](/assets/img/2024-06-30-NewYorkTimesHasChangedWordleICanProveIt_1.png)\n\n<div class=\"content-ad\"></div>\n\n그 앱은 빠르게 유명해졌어요. 처음 몇 날 동안 100회 이상 설치되었죠. 더구나 몇 분들로부터 즐기셨다는 친근한 이메일도 받았어요.\n\n그 후... 모든 것이 변했어요.\n\n# 뉴욕 타임즈에 대해 이야기하기 전에\n\n무엇이 변했는지 설명하기 전에, 당시에 어떻게 단어가 선택되었는지 소개할게요.\n\n<div class=\"content-ad\"></div>\n\n클라이언트에서 모든 코드가 실행되었습니다(즉, 당신의 브라우저에서). 사이트를 열 때마다 두 개의 거대한 단어 배열이 로드되었습니다. 첫 번째(14,000단어 이상)는 \"허용 가능한 답변\"이었고, 즉 당신이 추측으로 입력할 수 있는 단어들이었습니다. 이것이 당신이 터무니없는 말을 입력하는 것을 막는 역할을 합니다.\n\n두 번째는 정렬된 답변 목록이었습니다. 원래 총 2,309개의 단어가 있었으며, 이는 약 6년 가량의 퍼즐을 의미합니다.\n\n페이지를 열 때, 스크립트는 현재 날짜를 가져와 게임 출시 이후 몇 일이 지났는지를 측정했습니다. 예를 들어, 게임이 출시된 지 정확히 1년이 된 날에는, 더 짧은 단어 목록에서 365번째 단어를 찾아 그것이 그 날의 정답이 되었습니다!\n\n내 Chrome 확장 프로그램을 통해 \"일 수\" 변수를 변경할 수 있게 했어요. 정말 간단하지요!\n\n<div class=\"content-ad\"></div>\n\n# 새 주인의 등장\n\n2022년 1월, 뉴욕 타임스가 언급되지 않은 금액으로 <Wordle>의 권리를 구매했습니다 (누군가가 \"700만 달러 미만\"이라고 말했습니다). 게임은 뉴욕 타임스로 이주하게 되었고, 핵심 게임 메커니즘은 변경되지 않을 것이라고 약속되었지만, 우리는 무언가가 변할 것이라는 것을 알고 있었습니다.\n\n가장 먼저 발생한 일은 내 Chrome 확장 프로그램이 종료되었습니다. NYT는 \"부가 기능\" 게임을 만드는 것을 좋아하지 않았습니다. 게다가 코드가 결국 크게 변경되어 내 확장 프로그램이 쓸모 없어졌습니다. 하나의 웹사이트에서만 작동하도록 설계된 확장 프로그램은 거의 쉬울 대응책이 없이 중단될 수 있습니다.\n\n뉴욕 타임스 버전의 소스 코드를 찾아보려고 노력했지만 해독하기가 어려웠습니다. 먼저 코드가 압축되어 있어서 \"words\"와 같은 일반 변수 이름이 \"w\"와 같은 것으로 단축되어 검색이 불가능했습니다.\n\n<div class=\"content-ad\"></div>\n\n그러나 퍼즐에서 사용된 실제 단어와 같은 요소들은 압축해서는 안 됩니다. 예를 들어 \"브라보\"와 같은 것을 검색할 수 있어야 합니다 (몇 일 전의 해답).\n\n안타깝게도, 이제 게임은 완전히 클라이언트에서 운영되지 않습니다. iOS와 Android용 네이티브 버전이 출시된 이후, NYT는 모든 것을 클라이언트 앱에서 돌릴 수 없게 되었습니다. 변경 사항이 필요한 경우 3개의 다른 코드베이스를 업데이트해야 합니다.\n\n(저는 비슷한 앱들과의 경험을 바탕으로 한 추측입니다. 개발자들과 직접 대화한 적은 없습니다)\n\n대신, 앱은 서버로 요청을 보내 그 날짜의 해답이 담긴 JSON 파일을 받습니다.\n\n<div class=\"content-ad\"></div>\n\n요기에서 확인할 수 있어요:\n[링크](https://www.nytimes.com/svc/wordle/v2/2024-06-03.json)\n\n이것이 고객이 2024년 6월 3일에 가져온 객체에요 (네, 만약 속이기를 원하신다면 미래 날짜를 입력할 수 있어요).\n\n그래서, 우리는 단어를 가져오기 위한 새로운 방법이 생겼지만, 게임은 여전히 기본적으로 같아요. 광고, 로그인 및 기타 NYT 관련 쓰레기만 제외하면요...\n\n하지만, 선택된 단어들이 바뀌었다는 사실이 밝혀졌어요.\n\n<div class=\"content-ad\"></div>\n\n# Brave New Wordle\n\n마스터 리스트가 더 이상 없어서 최신 코드를 가져와서 내 보관 코드와 비교할 수 없었습니다. 그러나 그동안의 퍼즐 목록을 살펴보고 내가 가지고 있던 원래 정답 목록과 비교할 수는 있었습니다.\n\n새로 발견한 단어들은 다음과 같습니다:\n1. PIOUS\n2. LASER\n3. KAZOO\n4. BALSA\n5. SNAFU\n6. GUANO\n\n그럼... 왜 이런 단어들일까요?\n\n<div class=\"content-ad\"></div>\n\n\n먼저 알아야 할 사실은 Wordle의 창시자가 영국인이라는 것입니다. “Snafu”는 미국 약어로, 상황 정상: 전부 엉망이라는 뜻입니다. 아마 뉴욕 타임즈는 그냥 게임을 미국식으로 변형하고 싶었을지도 모르겠네요?\n\n그런데 “Balsa”와 “Guano”는 어떻게 해야 할까요? 여기에 더하자면, 이 게임은 어느 한 사람이 자신의 부인을 위해 만든 것입니다. 아마 그저 배제할 단어에 대해 설며으로 결정한 것 같습니다. 이상하게도, 그 두 단어는 “수용 가능한 답변” 목록에 나타납니다. 다만, 유효한 \"답변\"으로 선택되지 않았을 뿐입니다.\n\n혹은 이러한 단어들이 추가된 이유가 다른 무슨 이유가 있을 수도 있습니다 (그리고 앞으로 만나게 될 다른 단어). 결국에는, 원래 2,309개의 단어 중 거의 절반에 다다랐습니다. NYT가 이 게임을 계속 유지하고 싶다면, 어떤 것을 생각해내야 할 것입니다. 아마도 6글자로???\n\n#또 다른 Chrome Extension을 만들까요?\n\n<div class=\"content-ad\"></div>\n\n아마도 그것은 안 될 것 같아요. 하루 솔루션 요청을 빼앗아 다른 날짜를 제시하는 것을 작성할 수는 있지만, 클라이언트 측 코드에서 신뢰성 있게 할당할 수 없습니다. 왜냐하면 최소화된 코드는 매 릴리스마다 변경될 수 있기 때문이죠.","ogImage":{"url":"/assets/img/2024-06-30-NewYorkTimesHasChangedWordleICanProveIt_0.png"},"coverImage":"/assets/img/2024-06-30-NewYorkTimesHasChangedWordleICanProveIt_0.png","tag":["Tech"],"readingTime":4},{"title":"Svelte 다른 프레임워크와 차별화된 매력적인 경험은","description":"","date":"2024-06-30 18:48","slug":"2024-06-30-SvelteDifferentandEngagingExperienceUnlikeOthers","content":"\n\n![이미지](/assets/img/2024-06-30-SvelteDifferentandEngagingExperienceUnlikeOthers_0.png)\n\n# 소개\n\n기술의 세계는 항상 혁신으로 넘쳐나지만, 웹 개발 분야에서 다양한 접근 방식과 해결책을 찾는 탐색은 결코 멈추지 않습니다. 이 여정에서 각 새로운 단계는 새로운 지평과 실용적인 해결책을 가져옵니다. 이 중 하나인 놀라운 발견은 바로 Svelte와의 만남입니다!\n\n본문에서는 Svelte를 소개하고 제 개인적인 경험을 살펴볼 예정입니다.\n\n<div class=\"content-ad\"></div>\n\n# 스벨트란 무엇인가요?\n\n스벨트는 무료이자 오픈 소스인 프런트엔드 컴포넌트 프레임워크이자 언어입니다.\n\n- HTML을 확장하여 자바스크립트 식을 마크업에 추가하고, 동작을 제어하고 입력에 반응하는 지시문, 조건, 반복 및 비동기 값을 사용하는 문법을 추가합니다.\n- CSS를 확장하여 스타일이 서로 겹쳐지지 않도록 스코핑 메커니즘을 추가합니다.\n- 자바스크립트를 확장하여 반응성을 언어의 기본 요소로 만듭니다.\n\n스벨트는 JavaScript의 구문을 수정하지 않으면서도 그것을 해킹합니다. 더욱이, TypeScript와 같은 기존 도구와의 상호 작용에 방해가 되지 않습니다. 예를 들어, 보통 변수를 할당할 때, 실제로는 상태를 정의하고 있는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n# 어떤 상황에서 사용할 수 있을까요?\n\n언제나 이 답변에 의지할 수 있다고 말해도 과언이 아닙니다. 이는 Svelte가 임베디드 기기에서도 성능 저하 없이 서비스를 제공할 수 있다는 점 때문입니다. 예를 들어, 브라질에서 사용되는 약 20만 대의 POS 장치가 Svelte 프레젠테이션에서 강조되며 언급될 정도입니다.\n\n요약하자면, 리소스를 적게 사용하면서 고효율 애플리케이션을 만들고자 한다면, Svelte이 최상의 선택이 됩니다.\n\n# 어디에 사용해야 할까요?\n\n<div class=\"content-ad\"></div>\n\n## 코드를 덜 작성하기\n\n더 적은 코드 라인을 작성하면 시간을 절약하고 버그를 줄이며 가독성을 높일 수 있습니다.\n\nSvelte는 컴파일러 지향적 접근 방식 덕분에 대부분의 프레임워크에 있는 불필요한 코드를 필요로하지 않습니다. Svelte는 가독성에 희생함 없이 짧은 코드를 목표로 합니다.\n\n![Svelte Image](/assets/img/2024-06-30-SvelteDifferentandEngagingExperienceUnlikeOthers_1.png)\n\n<div class=\"content-ad\"></div>\n\n더 많은 예시와 다른 프레임워크를 비교하고 싶다면, 이 사이트를 추천해 드릴게요: [https://component-party.dev/](https://component-party.dev/)\n\n## 가상 DOM이 없음\n\n가상 DOM은 여러 JavaScript 프레임워크에서 사용되는 기술로, 실제 DOM을 흉내내는 메모리 구조를 만들고 이 구조를 변경합니다. 렌더링 프로세스 중에는 실제 DOM과 가상 DOM 간의 차이를 계산하고 실제 DOM을 업데이트합니다. 이 방법은 웹 애플리케이션의 성능을 향상시키는 데 목적을 두고 있습니다.\n\nReact와 같은 프레임워크에 가상 DOM이 유용한 이유는 상태가 업데이트될 때마다 전체 컴포넌트를 다시 렌더링하고 실제 DOM에 직접 반영하는 것은 좋지 않기 때문입니다.\n\n<div class=\"content-ad\"></div>\n\n그러나 Svelte에서는 상태를 업데이트할 때 해당 상태에 의존하는 부분만 DOM에서 업데이트되기 때문에 이러한 상황이 적용되지 않습니다. 이 방법으로 가상 DOM이 필요하지 않고 더 효율적인 애플리케이션이 달성됩니다.\n\n## 학습 곡선이 꽤 낮습니다\n\n이미 HTML, CSS 및 JavaScript를 알고 있다면 Svelte는 꽤 직관적일 것입니다.\n\n```js\n<script>\n  let name = \"World\";\n</script>\n<h1>Hello {name}!</h1>\n<style>\nh1 {\n  color: red;\n}\n</style>\n```\n\n<div class=\"content-ad\"></div>\n\n위에 작성된 코드는 처음에는 HTML과 비슷해 보일 수 있지만, 실제로는 Svelte 코드입니다.\n\n# 왜 그리고 어디에서 사용했나요?\n\n트렌디올 광고팀은 풀스택 팀으로, 프론트엔드 프로젝트에는 React를 사용합니다. 그러나 React를 사용하여 높은 성능의 애플리케이션을 구축하는 것은 깊은 이해가 없는 경우 어려울 수 있습니다. 우리 팀은 풀스택이기 때문에 일부는 프론트엔드 개발을 선호하고, 다른 사람들은 백엔드 작업을 선호할 수 있습니다. 그럼에도 불구하고, 우리 모두가 모든 프로젝트에 기여합니다. 프론트엔드 개발에 익숙하지 않은 개발자들은 React의 가파른 학습 곡선으로 인해 매우 효율적인 코드를 작성하기 어려울 수 있습니다. 그래서 저희는 Svelte를 하나의 프로젝트에 사용해보기로 결정했습니다. Svelte는 학습 곡선이 낮고 더 빠른 애플리케이션을 만들 수 있는 잠재력을 갖고 있기 때문입니다.\n\n저희가 Svelte에서 마주한 몇 가지 문제에 대해 이야기하고 싶습니다. Svelte에는 오류 경계(error boundary)가 없어서 어떤 컴포넌트에서든 처리되지 않은 오류가 전체 페이지를 다운시킬 수 있습니다. 관련 이슈는 여기에서 확인할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nUnit Tests를 작성하는 것은 React에서처럼 쉽지 않습니다. 때로는 일부 구성 요소에 대해 테스트 목적으로 새로운 컴포넌트를 만들어야 할 수도 있고, 이는 실제로 Svelte를 인라인으로 작성할 수 없기 때문입니다. 이 문제를 해결하는 몇 가지 플러그인을 본 적이 있지만, 제대로 작동하지 않았습니다. 다행히 Svelte Society의 레시피 덕분에 여기서 큰 문제가 발생하지는 않았습니다.\n\n우리는 현재 브랜드 센터의 'Reklam Yönetimi' (광고 관리) 탭에서 Svelte를 사용하고 있습니다. 어떤 문제 없이 원활하게 작동합니다. Svelte에 기회를 주신 기술 리더 및 Trendyol의 문화에 감사드립니다. 그들의 도움으로 산업에서 Svelte를 한 단계 더 나아갔다고 생각합니다.\n\n<img src=\"/assets/img/2024-06-30-SvelteDifferentandEngagingExperienceUnlikeOthers_2.png\" />\n\n# 팀 피드백\n\n<div class=\"content-ad\"></div>\n\n우리는 Svelte에 관한 우리 팀원들의 경험과 피드백을 모았어요. 이 피드백은 긍정적 측면과 부정적 측면 두 가지 주요 항목 아래에서 수집했어요.\n\n## 긍정적 측면\n\n- 일부 팀원들은 네이티브 JavaScript를 작성하는 것처럼 코드를 작성하는 과정을 즐겼어요. 이는 자연스럽고 익숙한 경험을 만들어냈어요.\n- 낮은 학습 곡선으로 인해 Svelte를 배우고 사용하기 쉬웠어요. 우리 팀원들은 언어의 기초를 빠르게 마스터하고 프로젝트에 빠르게 적응했어요.\n- 코드 작성의 용이성과 코드베이스의 간결함으로 개발 과정이 가속화되었어요.\n- 우리 팀은 코드를 효율적으로 작성하기 위해 추가 작업을 해야하지 않아서 좋았어요, 예를 들어 useMemo와 같은 것들을 다룰 필요가 없었어요.\n- Svelte의 기본 기능들이 우리에게 추가 라이브러리가 필요하지 않고도 많은 작업을 수행할 수 있게 했어요.\n- 슬롯 구조와 이벤트 디스패치의 용이성은 구성 요소간의 커뮤니케이션과 재사용성을 증가시켰어요.\n\n## 부정적 측면\n\n<div class=\"content-ad\"></div>\n\n- Svelte의 생태계와 커뮤니티는 아직 상대적으로 작습니다. 이는 특히 제3자 라이브러리 및 도구에 대한 통합과 지원 부족으로 이어질 수 있습니다.\n- 큰 객체의 반응성에 문제가 있습니다. Store를 사용할 때 큰 객체를 사용하는 것은 도전적일 수 있습니다.\n- WebStorm 인텔리센스의 부재가 개발 경험에 부정적인 영향을 미칩니다.\n\n## 결론\n\n전반적으로, 우리 팀은 Svelte와 함께 일할 수 있어 기쁘게 생각했습니다. 특히 성능, 단순함 및 사용 편의성에 대한 매우 긍정적인 피드백을 받았습니다. 그러나 생태계의 성숙도 및 일부 개발 경험적인 도전에 대한 우려가 표명되었습니다. Svelte는 특정 유형의 프로젝트에 강력한 옵션일 수 있지만, 다른 프레임워크에서 제공하는 광범위한 생태계와 커뮤니티 지원이 더 매력적일 수도 있습니다.\n\n# 참고문헌\n\n<div class=\"content-ad\"></div>\n\n- Gist - Svelte에 대한 진실\n- 반응성에 대한 재고\n- 컴포넌트 파티\n- 레시피 - Svelte Society\n- 소개 - SvelteKit\n\n우리는 산업에서 가장 빛나는 두뇌들로 팀을 구축하고 있어요. 우리와 함께 일하고 싶으신가요? 우리가 오픈한 포지션에 대해 더 알아보려면 아래 페이지를 방문해 주세요.","ogImage":{"url":"/assets/img/2024-06-30-SvelteDifferentandEngagingExperienceUnlikeOthers_0.png"},"coverImage":"/assets/img/2024-06-30-SvelteDifferentandEngagingExperienceUnlikeOthers_0.png","tag":["Tech"],"readingTime":5},{"title":"Flutter 숨겨진 보물 탐험 잘 알려지지 않은 위젯 공개  Part 3","description":"","date":"2024-06-30 18:46","slug":"2024-06-30-ExploringHiddenTreasuresinFlutterLesser-KnownWidgetsUnveiledPart3","content":"\n플러터는 다양하고 시각적으로 멋진 애플리케이션을 개발할 수 있도록 개발자들에게 넓은 위젯 카탈로그로 유명합니다. 자주 사용되는 위젯들은 잘 알려져 있지만, 플러터는 잘 알려지지 않지만 매우 유용한 다양한 위젯들도 제공합니다. UI의 세련됨과 기능성을 향상시킬 수 있는 이런 숨겨진 보석들을 알아보겠습니다.\n\n![이미지](/assets/img/2024-06-30-ExploringHiddenTreasuresinFlutterLesser-KnownWidgetsUnveiledPart3_0.png)\n\n### 1. FadeInImage\n\nFadeInImage는 주 이미지가 로딩되는 동안 플레이스홀더 이미지를 표시할 수 있는 위젯입니다. 네트워크에서 이미지를 다룰 때 사용자 경험을 향상시키는 데 특히 유용합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nFadeInImage(\n  placeholder: AssetImage('assets/placeholder.png'),\n  image: NetworkImage('https://example.com/image.jpg'),\n)\n```\n\n## 2. GridPaper\n\nGridPaper은 레이아웃 디버깅을 위한 편리한 위젯입니다. 앱에 그리드를 겹쳐서 간격, 정렬 및 레이아웃 문제를 시각화하기 쉽게 만들어줍니다.\n\n```js\nGridPaper(\n  color: Colors.blueAccent,\n  divisions: 4,\n  interval: 100.0,\n  subdivisions: 2,\n)\n```\n\n<div class=\"content-ad\"></div>\n\n## 3. 히어로\n\n히어로는 위젯을 화면에서 다른 화면으로 부드럽게 전환하여 라우트 간에 애니메이션을 제공합니다. 시각적으로 매력적인 네비게이션 애니메이션을 만드는 데 이상적입니다.\n\n```js\nHero(\n  tag: 'hero-image',\n  child: Image.network('https://example.com/image.jpg'),\n)\n```\n\n## 4. KeepAlive\n\n<div class=\"content-ad\"></div>\n\nKeepAlive은 위젯이 화면에서 벗어나도 위젯 트리에 유지되도록 돕습니다. 이는 ListView 또는 PageView에서 위젯의 상태를 유지하는 데 특히 유용합니다.\n\n```js\nclass MyStatefulWidget extends StatefulWidget {\n  @override\n  _MyStatefulWidgetState createState() => _MyStatefulWidgetState();\n}\n\nclass _MyStatefulWidgetState extends State<MyStatefulWidget> with AutomaticKeepAliveClientMixin<MyStatefulWidget> {\n  @override\n  bool get wantKeepAlive => true;\n\n  @override\n  Widget build(BuildContext context) {\n    super.build(context);\n    return Container();\n  }\n}\n```\n\n## 5. ListBody\n\nListBody는 주어진 축을 따라 자식 위젯을 선형 배열로 정렬합니다. 간단한 리스트 레이아웃이 필요한 경우 Column 및 Row 대신 간단한 대안으로 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nListBody(\n  children: <Widget>[\n    Text('Item 1'),\n    Text('Item 2'),\n    Text('Item 3'),\n  ],\n)\n```\n\n## 6. MenuRegion\n\nMenuRegion은 앱에서 컨텍스트 메뉴를 정의하는 데 사용됩니다. 이 위젯은 데스크톱 애플리케이션에서 마우스 오른쪽 클릭 컨텍스트 메뉴가 흔한 경우에 유용합니다.\n\n```js\nMenuRegion(\n  child: Container(\n    color: Colors.blue,\n    width: 100,\n    height: 100,\n  ),\n)\n```\n\n<div class=\"content-ad\"></div>\n\n## 7. LookUpBoundary\n\nLookUpBoundary은 InheritedWidget 조회 범위를 제한하는 위젯입니다. 위젯 트리의 재구성 동작을 최적화하고 제어하는 데 유용합니다.\n\n```js\nLookUpBoundary(\n  child: MyInheritedWidget(\n    child: MyWidget(),\n  ),\n)\n```\n\n## 8. Listener\n\n<div class=\"content-ad\"></div>\n\n리스너는 터치, 마우스, 스타일러스 상호작용과 같은 포인터 이벤트를 감지합니다. 이 위젯은 사용자 정의 제스처와 상호작용을 구현하는 데 유용합니다.\n\n```js\nListener(\n  onPointerDown: (PointerDownEvent event) => print('Pointer down event'),\n  child: Container(\n    color: Colors.red,\n    width: 100,\n    height: 100,\n  ),\n)\n```\n\n## 9. 확대경\n\n확대경은 특정 영역에 확대 효과를 제공합니다. 이는 접근성을 향상시키고 특정 시나리오에서 사용자 경험을 향상하는 데 좋습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n확대기(\n  자식: Text('나를 확대해주세요!'),\n)\n```\n\n## 10. 메뉴 앵커\n\n메뉴 앵커는 특정 위치에 메뉴를 고정하는 데 사용됩니다. 사용자 정의 드롭다운 메뉴와 컨텍스트 메뉴를 만드는 데 유용합니다.\n\n```js\n메뉴 앵커(\n  menuChildren: <Widget>[\n    Text('메뉴 항목 1'),\n    Text('메뉴 항목 2'),\n  ],\n  자식: Text('메뉴 열기'),\n)\n```\n\n<div class=\"content-ad\"></div>\n\n## 11. MenuBar\n\nMenuBar은 데스크톱 애플리케이션에서 사용할 수 있는 전통적인 메뉴 모음입니다. 데스크톱 사용자에게 익숙한 탐색 경험을 제공합니다.\n\n```js\nMenuBar(\n  children: <Widget>[\n    Text('File'),\n    Text('Edit'),\n    Text('View'),\n  ],\n)\n```\n\n## 12. MouseRegion\n\n<div class=\"content-ad\"></div>\n\nMouseRegion은 위젯에 마우스가 진입하거나 나가거나 호버될 때를 감지합니다. 인터랙티브 데스크톱 애플리케이션을 만드는 데 필수적인 기능이에요!\n\n```js\nMouseRegion(\n  onEnter: (_) => print('마우스 진입'),\n  onExit: (_) => print('마우스 나감'),\n  child: Container(\n    color: Colors.green,\n    width: 100,\n    height: 100,\n  ),\n)\n```\n\n이 글이 유익했기를 바라요! 제공된 정보를 감사하게 여기신다면, 제게 커피 한 잔 사주는 옵션이 있답니다! 여러분의 도움이 큰 힘이 될 거에요!\n\n<img src=\"/assets/img/2024-06-30-ExploringHiddenTreasuresinFlutterLesser-KnownWidgetsUnveiledPart3_1.png\" />\n\n<div class=\"content-ad\"></div>\n\n# 함께해요\n\n이 글을 읽어 주셔서 감사합니다. 즐겁게 읽으셨다면, 더 많은 글을 살펴보고 앞으로 제 포스트를 지켜봐 주시면 감사하겠습니다.\n\n더 많은 IT 관련 콘텐츠에 관심이 있다면, Digital Dive Hub 웹사이트를 방문해 최신 블로그와 소식을 확인해 보세요.\n\n# Stackademic 🎓\n\n<div class=\"content-ad\"></div>\n\n끝까지 읽어 주셔서 감사합니다! 떠나시기 전에 다음을 확인해 주세요:\n\n- 작가를 박수로 응원하고 팔로우해 주세요! 👏\n- 저희를 팔로우해 주세요: X | LinkedIn | YouTube | Discord\n- 다른 플랫폼에서도 만나보세요: In Plain English | CoFeed | Differ\n- 더 많은 콘텐츠는 Stackademic.com에서 확인하세요.\n","ogImage":{"url":"/assets/img/2024-06-30-ExploringHiddenTreasuresinFlutterLesser-KnownWidgetsUnveiledPart3_0.png"},"coverImage":"/assets/img/2024-06-30-ExploringHiddenTreasuresinFlutterLesser-KnownWidgetsUnveiledPart3_0.png","tag":["Tech"],"readingTime":5},{"title":"모바일 개발 탐색 플랫폼, 아키텍처, 그리고 HNG 인턴십 경험기","description":"","date":"2024-06-30 18:45","slug":"2024-06-30-NavigatingMobileDevelopmentPlatformsArchitecturesandMyJourneywithHNGInternship","content":"\n\n# 소개\n\n![이미지](/assets/img/2024-06-30-NavigatingMobileDevelopmentPlatformsArchitecturesandMyJourneywithHNGInternship_0.png)\n\n모바일 개발은 계속적인 학습과 적응이 필요한 동적이고 빠르게 변화하는 분야입니다. HNG 인턴십과 함께하는 내 여정을 시작하면서, 특히 이 산업을 형성하는 플랫폼 및 일반적인 소프트웨어 아키텍처 패턴에 초점을 맞춰 모바일 개발 세계에 대한 인사이트를 공유하고자 합니다.\n\n# 섹션 1: 모바일 개발 플랫폼 이해하기\n\n<div class=\"content-ad\"></div>\n\n## iOS 개발:\n\n![이미지](/assets/img/2024-06-30-NavigatingMobileDevelopmentPlatformsArchitecturesandMyJourneywithHNGInternship_1.png)\n\n설명: 애플이 개발한 iOS는 iPhone 및 iPad 같은 기기를 작동시킵니다.\n\n사용된 프로그래밍 언어: 개발자들은 Swift 또는 Objective-C를 사용하여 Xcode IDE에서 애플리케이션을 만듭니다.\n\n<div class=\"content-ad\"></div>\n\n장점:\n- 뛰어난 성능과 보안.\n- 강력한 개발자 지원 및 방대한 문서.\n- 앱에 지출할 의사가 있는 수요가 많고 수익성 높은 시장 접근.\n\n단점:\n- 개발을 위해 Mac이 필요합니다.\n- 앱 스토어 승인 프로세스가 엄격하고 시간이 많이 소요될 수 있습니다.\n- 안드로이드에 비해 제한된 사용자 정의 기능이 있습니다.\n\n## ``안드로이드 개발:\n\n<img src=\"/assets/img/2024-06-30-NavigatingMobileDevelopmentPlatformsArchitecturesandMyJourneywithHNGInternship_2.png\" />\n\nDescription: Google이 개발한 안드로이드는 다양한 기기에서 사용되는 오픈 소스 플랫폼입니다.\n\n<div class=\"content-ad\"></div>\n\n프로그래밍 언어 사용: 주로 안드로이드 스튜디오에서 Java 또는 Kotlin을 사용하여 개발합니다.\n\n장점:\n- 다양한 기기 호환성과 대규모 사용자 베이스.\n- 높은 맞춤 및 유연성.\n- 다중 앱 스토어를 통한 쉬운 앱 배포.\n\n단점:\n- 기기 및 OS 버전 간의 단편화로 인한 도전.\n- 플랫폼의 개방적인 특성으로 인한 보안 문제.\n- 다양한 기기로 인한 테스트의 복잡성.\n\n## \"크로스 플랫폼 개발:\"\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-30-NavigatingMobileDevelopmentPlatformsArchitecturesandMyJourneywithHNGInternship_3.png)\n\nDescription: 이름에서 알 수 있듯이, 크로스 플랫폼 접근법은 단일 코드 베이스를 사용하여 다양한 모바일 플랫폼에서 유사하게 작동하는 앱을 개발할 수 있게 합니다.\n\n사용된 프로그래밍 언어: React Native, Flutter, Xamarin과 같은 크로스 플랫폼 프레임워크를 사용하여 iOS 및 Android용 앱을 개발할 수 있습니다.\n\n장점:\n- 여러 플랫폼 간에 코드를 공유하여 시간과 자원을 절약합니다.\n- 보다 쉬운 유지보수 및 업데이트가 가능합니다.\n- 더 적은 노력으로 보다 넓은 관객에게 접근할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n단점:\n- 성능이 원래 앱보다 최적화되지 않을 수 있습니다.\n- 플랫폼별 기능에 제한적인 액세스.\n- 프레임워크의 지원 및 커뮤니티에 의존.\n\n# 섹션 2: 모바일 개발에서 일반적인 소프트웨어 아키텍처 패턴\n\n## `모델-뷰-컨트롤러 (MVC):\n\n![이미지](/assets/img/2024-06-30-NavigatingMobileDevelopmentPlatformsArchitecturesandMyJourneywithHNGInternship_4.png)\n\n<div class=\"content-ad\"></div>\n\n안녕! 아래는 애플리케이션을 세 가지 상호연결된 구성 요소로 분리하는 설명이에요:\n- Model (데이터),\n- View (UI),\n- Controller (로직).\n\n장점:\n- 개발 및 유지 관리를 간편하게 해줘요.\n- 관심사 분리가 명확해져요.\n- 재사용 가능한 컴포넌트를 활용할 수 있어요.\n\n단점:\n- 복잡한 애플리케이션에서 대형 뷰 컨트롤러로 이어질 수 있어요.\n- 구성 요소 간의 강한 결합이 유연성을 방해할 수 있어요.\n\n## ``Model-View-ViewModel (MVVM):``\n\n<div class=\"content-ad\"></div>\n\n아래는 Markdown 형식으로 변환되었습니다:\n\n![image](/assets/img/2024-06-30-NavigatingMobileDevelopmentPlatformsArchitecturesandMyJourneywithHNGInternship_5.png)\n\n설명: 프레젠테이션 로직을 처리하는 ViewModel 레이어를 추가하여 관심사의 분리를 강화합니다.\n\n장점:\n- 향상된 테스트 가능성 및 유지 관리성.\n- MVC보다 더 나은 관심사의 분리.\n- 복잡한 UI를 관리하기가 더 쉬움.\n\n단점:\n- ViewModel 추가로 복잡성이 증가.\n- 초심자에게는 높은 학습 곡선.\n\n<div class=\"content-ad\"></div>\n\n## Clean Architecture:\n\n![Clean Architecture](/assets/img/2024-06-30-NavigatingMobileDevelopmentPlatformsArchitecturesandMyJourneywithHNGInternship_6.png)\n\nDescription: 관심사의 분리와 프레임워크의 독립성을 강조하여 코드를 레이어로 구성합니다(프레젠테이션, 도메인, 데이터).\n\n장점:\n-높은 테스트 용이성과 유지 보수성.\n-책임의 명확한 분리.\n-앱을 더 유연하게 만드는 프레임워크와의 독립성.\n\n<div class=\"content-ad\"></div>\n\n단점:\n- 더 가파른 학습 곡선 및 구현이 더 복잡합니다.\n- 간단한 애플리케이션에는 오버 엔지니어링으로 이어질 수 있습니다.\n\n# 섹션 3: HNG 인턴십과 함께 하는 나의 여정\n\nFlutter로 시작한 신진 모바일 개발자로서, HNG 인턴십과의 여정을 시작하게 되어 기쁩니다. 그들에 대해 많은 이야기를 듣고, 인턴십이 얼마나 도전적인지 알고 있지만, 나는 도전을 좋아합니다. 이 기회는 기술에 대한 나의 열정과 모바일 개발 지식을 더 깊이 알고 싶은 욕구와 완벽하게 부합합니다.\n\n이 인턴십을 통해 나는 다음을 목표로 합니다:\n\n<div class=\"content-ad\"></div>\n\n- 나의 스킬 향상: 실제 프로젝트를 통해 실무 경험을 쌓고 산업 전문가로부터 배우세요.\n- 네트워크 확장: 비슷한 목표를 갖고 있는 동료와 멘토들과 연결하여 경력에 대한 조언을 받고 그들의 재능 풀에서 최고의 재능으로 성장하세요.\n- 포트폴리오 구축: 나의 능력과 창의성을 보여주는 애플리케이션을 개발하세요.\n- 커뮤니티 기여: 내 학습 내용을 공유하고 다른 사람들의 개발 여정을 돕습니다.\n\nHNG 인턴십은 능숙한 모바일 개발자가 되기 위한 제 목표를 이루는 한 걸음입니다. 이러한 도전과 기회를 함께해 주기를 고대하고 있습니다.\n\n트위터에서 저와 연락하세요.","ogImage":{"url":"/assets/img/2024-06-30-NavigatingMobileDevelopmentPlatformsArchitecturesandMyJourneywithHNGInternship_0.png"},"coverImage":"/assets/img/2024-06-30-NavigatingMobileDevelopmentPlatformsArchitecturesandMyJourneywithHNGInternship_0.png","tag":["Tech"],"readingTime":4},{"title":"Golang에서 오류 처리를 마스터하는 방법 최고의 실천 방법과 팁","description":"","date":"2024-06-27 18:32","slug":"2024-06-27-MasteringErrorHandlinginGolangBestPracticesandTips","content":"\n\n고랭(Golang)에서 에러를 우아하게 처리하는 방법을 배우고, 코드 신뢰성을 높이기 위한 에러 처리에 대한 종합 가이드를 제공합니다.\n\n![이미지](/assets/img/2024-06-27-MasteringErrorHandlinginGolangBestPracticesandTips_0.png)\n\nGo 언어에서는 일반적으로 에러를 표현하는 데 사용되는 인터페이스 타입인 error 타입이 정의됩니다.\n\n```js\ntype error interface {\n    Error() string\n}\n```\n\n<div class=\"content-ad\"></div>\n\n에러 인터페이스에는 Error() 메서드라는 하나의 메서드만 있습니다. 이 메서드는 에러를 설명하는 문자열을 반환합니다. 이는 Error() 메서드를 구현하는 모든 타입을 에러 타입으로 사용할 수 있다는 것을 의미합니다.\n\n일반적으로 Go 프로그램의 함수들은 에러가 발생했을 때 에러 타입의 값을 반환합니다. 이를 통해 호출자가 에러 정보를 처리하거나 기록할 수 있습니다.\n\n에러를 어떻게 생성할까요?\n\nGo 언어의 디자이너들은 Go 개발자들이 에러 값을 생성하는 두 가지 편리한 방법을 제공했습니다: errors.New와 fmt.Errorf.\n\n<div class=\"content-ad\"></div>\n\n- errors.New() 함수는 오직 오류 메시지 문자열만 포함하므로 오류 값을 생성하는 가장 간단한 방법입니다. 이 방법은 간단한 오류 값을 생성하는 데 적합합니다.\n- 반면에 fmt.Errorf() 함수는 fmt.Printf() 함수와 유사한 형식화된 오류 메시지를 구성할 수 있도록 합니다. 이 방법은 더 복잡한 오류 메시지를 구축해야 할 때 유용합니다.\n\n이 두 가지 방법을 사용하여 아래 코드와 같이 error 인터페이스를 만족하는 오류 값을 손쉽게 구성할 수 있습니다:\n\n```js\nerr := errors.New(\"hello error\")\nerrWithCtx = fmt.Errorf(\"index %i is out of bounds\", i)\n```\n\n이 두 가지 방법은 실제로 동일한 error 인터페이스를 구현하는 동일하지만 알려지지 않은 유형의 인스턴스를 반환합니다.\n\n<div class=\"content-ad\"></div>\n\n이 비공개 타입은 errors.errorString이며, 그 정의는 다음과 같습니다:\n\n```js\n// $GOROOT/src/errors/errors.go\ntype errorString struct {\n    s string\n}\n\nfunc (e *errorString) Error() string {\n    return e.s\n}\n```\n\n대부분의 경우에 이 두 가지 메서드를 사용하여 생성된 오류 값이 우리의 요구 사항을 충족할 것입니다.\n\n그러나 이러한 메서드가 오류 값을 생성하는 데 편리하긴 하지만, 오류 처리기에 제공하는 오류 컨텍스트는 문자열 형태로 제공된 정보에 제한된다는 점을 알아야 합니다. 이 정보는 Error 메서드에서 반환하는 정보입니다.\n\n<div class=\"content-ad\"></div>\n\n에러 유형을 사용자 정의하는 방법\n\n일부 상황에서는 에러 핸들러가 적절한 에러 처리 경로를 선택하는 데 도움이 되도록 에러 값에서 더 많은 정보를 추출해야 할 수도 있습니다.\n\n명확히 이 두 가지 메서드만으로는 그러한 경우에 충분하지 않습니다.\n\n이러한 상황에서는 이러한 요구 사항을 충족시키기 위해 에러 유형을 사용자 정의할 수 있습니다. 다음은 예시입니다:\n\n<div class=\"content-ad\"></div>\n\n```go\npackage main\n\nimport \"fmt\"\n\n// 사용자 정의 오류 유형\ntype MyError struct {\n  ErrorCode    int\n  ErrorMessage string\n}\n\n// `error` 인터페이스의 `Error` 메서드 구현\nfunc (e MyError) Error() string {\n  return fmt.Sprintf(\"Error %d: %s\", e.ErrorCode, e.ErrorMessage)\n}\n\nfunc someFunction() error {\n  // 커스텀 오류 값 생성\n  err := MyError{\n    ErrorCode:    404,\n    ErrorMessage: \"Not Found\",\n  }\n  return err\n}\n\nfunc main() {\n  err := someFunction()\n  fmt.Println(\"에러:\", err)\n}\n```\n\n또 다른 예시를 살펴보겠습니다. 표준 라이브러리의 net 패키지에 정의된 추가 컨텍스트를 가진 오류 유형입니다:\n\n```go\n// $GOROOT/src/net/net.go\ntype OpError struct {\n    Op string\n    Net string\n    Source Addr\n    Addr Addr\n    Err error\n}\n```\n\n이러한 유형의 오류 값이 제공하는 추가 컨텍스트 정보(예: Op, Net, Source 등)를 기반으로 에러 처리 경로를 결정할 수 있게끔 에러 핸들러가 결정을 내릴 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n위의 표준 라이브러리에서 다음 코드 예시를 살펴보겠습니다:\n\n```js\n// $GOROOT/src/net/http/server.go\nfunc isCommonNetReadError(err error) bool {\n    if err == io.EOF {\n        return true\n    }\n    if neterr, ok := err.(net.Error); ok && neterr.Timeout() {\n        return true\n    }\n    if oe, ok := err.(*net.OpError); ok && oe.Op == \"read\" {\n        return true\n    }\n    return false\n}\n```\n\n위 코드에서는 타입 단언(Type Assertion)을 활용하여 err 변수의 동적 타입이 *net.OpError 또는 net.Error인지를 결정합니다.\n\nerr의 동적 타입이 *net.OpError인 경우, 타입 단언은 이 동적 타입의 값(oe에 저장)을 반환하고, 코드는 그 후 해당 Op 필드가 read인지 여부를 확인하여 CommonNetRead 유형의 에러인지 결정할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n오류 유형의 장점.\n\n# 1. 오류를 처리하는 표준화된 방법을 제공합니다.\n\n서로 다른 개발자, 다른 프로젝트 및 심지어 표준 라이브러리에서 코드를 사용할 때 오류 유형을 오류 인터페이스 변수의 형태로 일관되게 표현한다면 코드 가독성을 향상시키는 것뿐만 아니라 통일된 오류 처리 전략의 수립을 용이하게 합니다.\n\n# 2. 오류는 모두 값입니다.\n\n<div class=\"content-ad\"></div>\n\n우리가 만드는 오류들은 실제로 값들입니다. 이는 오류 인터페이스 유형의 변수에 할당되었을 때에도 ==와 !=와 같은 논리적 비교를 수행할 수 있음을 의미합니다. 정수 값들과 마찬가지로요.\n\n오류를 검사하는 경험은 함수 호출자에게 동일합니다.\n\n오류가 인터페이스 유형이기 때문에, 그의 기본 제로 값은 nil입니다.\n\n그러므로, 일반적으로 함수에 의해 반환된 오류를 nil과 비교하여 함수가 성공했는지 여부 또는 오류가 발생했는지를 확인합니다.\n\n<div class=\"content-ad\"></div>\n\n만약 반환된 오류가 nil이라면, 성공적으로 함수가 실행된 것이고, 그렇지 않다면 오류가 발생했음을 나타냅니다.\n\n이 규칙을 따르면 오류 처리가 일관적이고 직관적으로 이루어집니다.\n\n예를 들어, 다음과 같은 오류 확인 코드를 자주 볼 수 있습니다:\n\n```js\nfunc someFunction() error {\n    return errors.New(\"Errors\")\n}\n\nfunc main() {\n    err := someFunction()\n\n    if err != nil {\n        fmt.Println(\"실패, 오류:\", err)\n    } else {\n        fmt.Println(\"성공\")\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n# 3. 쉽게 확장할 수 있습니다.\n\n에러들은 에러 인터페이스 변수로 일관되게 표시됩니다. 사용자 정의 에러 타입을 만들어 우리의 에러 컨텍스트를 쉽게 확장할 수 있으며, 이는 Go 표준 라이브러리의 OpError 타입과 비슷합니다.\n\n에러 인터페이스는 에러 값을 제공하는 제공자와 에러 처리를 담당하는 코드 간의 계약 역할을 합니다.\n\n에러 인터페이스를 구현하는 사람은 에러 처리 코드에서 사용할 에러 컨텍스트를 제공하는 것이 책임입니다.\n\n<div class=\"content-ad\"></div>\n\n이는 특정 오류 컨텍스트를 오류 인터페이스 유형과 분리하여 Go의 구성 가능성 및 직교성을 따르는 설계 철학과 일치합니다.\n\nGo 오류 처리의 일반적인 관행.\n\n## 1. 투명한 오류 처리 전략.\n\n간단히 말해서, Go 언어에서의 오류 처리는 함수에 의해 반환된 오류 유형 변수에 의해 전달되는 오류 값 정보를 기반으로 의사 결정을 내리고 후속 코드 실행 경로를 선택하는 과정입니다.\n\n<div class=\"content-ad\"></div>\n\n이 방식을 통해 가장 간단한 오류 전략은 반환된 오류 값이 전달하는 구체적인 컨텍스트 정보를 완전히 무시하는 것입니다.\n\n대신, 오류가 발생할 때마다 하나의 오류 처리 실행 경로로 이어집니다. 예를 들어, 다음 코드를 참고해보세요:\n\n```js\nerr := doSomething()\nif err != nil {\n    ... ...\n    return err\n}\n```\n\n이것은 Go 언어에서 가장 흔한 오류 처리 전략으로, 오류 처리 시나리오의 80% 이상을 차지합니다. 이 전략에서는 오류 핸들러가 오류 값의 컨텍스트에 신경을 쓰지 않기 때문에, 오류 생성자 (예: 예시의 doSomething 함수)는 Go 표준 라이브러리에서 제공하는 두 가지 기본 오류 값 생성 방법을 직접 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nfunc doSomething(...) error {\n    ... ...\n    return errors.New(\"일부 오류가 발생했습니다\")\n}\n```\n\n이러한 방식으로 생성된 오류 값은 오류 처리기에게 투명한 컨텍스트 정보를 나타냅니다.\n\n오류 처리기가 오류 컨텍스트에 대해 인식할 필요가 없는 상황에서는 투명한 오류 처리 전략이 오류 처리기와 오류 값 생성자 간의 결합을 최소화합니다.\n\n오류 컨텍스트가 오류 처리에 무관한 경우, 이 접근 방식은 오류 처리와 오류 값 생성 사이의 상호 의존성을 줄이는 데 효과적입니다.\n\n\n<div class=\"content-ad\"></div>\n\n# 2. Sentinel 오류 처리 전략.\n\n오류 핸들러가 투명한 오류 값에만 의존하여 오류 처리 결정을 내릴 수없는 경우, 반환된 오류 값을 검사하려고 시도할 수 있습니다. 아래 코드와 같이 이를 통해 발생하는 안티패턴이 발생할 수 있습니다:\n\n```js\ndata, err := b.Peek(1)\nif err != nil {\n    switch err.Error() {\n    case \"bufio: negative count\":\n        // ... ...\n        return\n    case \"bufio: buffer full\":\n        // ... ...\n        return\n    case \"bufio: invalid use of UnreadByte\":\n        // ... ...\n        return\n    default:\n        // ... ...\n        return\n    }\n}\n```\n\n간단히 말해서, 이 안티패턴은 오류 핸들러가 오류 처리 결정을 내릴 때 \"투명한 오류 값\"이 제공하는 단일 컨텍스트 정보에 완전히 의존하는 경우를 나타냅니다.\n\n<div class=\"content-ad\"></div>\n\n하지만 이 \"안티-패턴\"은 상당한 암시적 결합을 야기합니다.\n\n즉, 오류 값 생성자에 의한 오류 설명 문자열의 미세한 변경조차도 오류 처리 동작에 변화를 일으킬 수 있습니다.\n\n또한, 문자열 비교를 통해 오류 값들을 조사하는 이 방식은 성능적으로 효율적이지 않습니다.\n\n그렇다면 해결책은 무엇일까요? Go 표준 라이브러리는 내보낸 \"특정값(sentinel)\" 오류 값의 정의를 통해 오류 핸들러들이 오류 값을 조사하고 오류 처리 결정을 내리는 데 도움을 주는 방식을 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n예를 들어, bufio 패키지에서 정의된 \"sentinel errors\"는 다음과 같습니다:\n\n```js\n// $GOROOT/src/bufio/bufio.go\nvar (\n    ErrInvalidUnreadByte = errors.New(\"bufio: invalid use of UnreadByte\")\n    ErrInvalidUnreadRune = errors.New(\"bufio: invalid use of UnreadRune\")\n    ErrBufferFull        = errors.New(\"bufio: buffer full\")\n    ErrNegativeCount     = errors.New(\"bufio: negative count\")\n)\n```\n\n다음 코드 조각은 이전에 언급된 sentinel errors를 활용하여 에러 처리 분기에서 결정을 내리는 예시입니다:\n\n```js\ndata, err := b.Peek(1)\nif err != nil {\n    switch err {\n    case bufio.ErrNegativeCount:\n        // ... ...\n        return\n    case bufio.ErrBufferFull:\n        // ... ...\n        return\n    case bufio.ErrInvalidUnreadByte:\n        // ... ...\n        return\n    default:\n        // ... ...\n        return\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n그러나 API 개발자의 경우, \"sentinel\" 오류 값 노출은 이러한 오류 값과 패키지의 공개 함수가 API의 일부가 되는 것을 의미합니다.\n\n한 번 릴리스되면, 개발자는 효과적으로 유지 관리해야 합니다. 또한, \"sentinel\" 오류 값은 이를 사용하는 오류 처리기에 종속성을 만듭니다.\n\nGo 1.13부터 표준 라이브러리 오류 패키지에서 Is 함수가 도입되어 오류 처리기가 오류 값으로 검사할 수 있습니다.\n\nIs 함수는 다음 코드에서 보여지는 것처럼 오류 변수를 \"sentinel\" 오류 값과 비교하는 것과 유사합니다:\n\n<div class=\"content-ad\"></div>\n\n```go\nif errors.Is(err, ErrOutOfBounds) {\n    // 뭔가를 수행\n}\n```\n\n차이점은 에러 변수가 래핑된 에러를 포함하는 경우, errors.Is 메서드는 래핑된 에러 내에서 에러 체인을 탐색하여 일치하는 에러를 찾을 때까지 모든 래핑된 에러와 비교합니다.\n\n다음은 Is 함수를 사용하는 예시입니다:\n\n```go\nvar ErrSentinel = errors.New(\"기본 신호 에러\")\n\nfunc main() {\n  err1 := fmt.Errorf(\"sentinel을 래핑: %w\", ErrSentinel)\n  err2 := fmt.Errorf(\"err1을 래핑: %w\", err1)\n  println(err2 == ErrSentinel) // false\n  if errors.Is(err2, ErrSentinel) {\n    println(\"err2는 ErrSentinel입니다.\")\n    return\n  }\n\n  println(\"err2는 ErrSentinel이 아닙니다.\")\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 예제에서는 fmt.Errorf 함수와 %w 동사를 사용하여 랩핑된 오류 변수 err1과 err2를 생성합니다.\n\nerr1은 \"sentinel\" 오류 값 ErrSentinel을 랩핑하고, err2는 err1을 랩핑하여 오류 체인을 생성합니다. 오류 체인의 맨 위에는 err2가 있고, 맨 아래에는 ErrSentinel이 있습니다.\n\n그런 다음 값 비교와 errors.Is 함수를 모두 사용하여 err2와 ErrSentinel 간의 관계를 결정합니다.\n\n코드를 실행할 때 다음과 같은 결과를 관찰할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nfalse\nerr2 is ErrSentinel\n```\n\n보시다시피 동등 연산자를 사용하여 err2와 ErrSentinel을 비교하면 서로 다릅니다.\n\n그러나 errors.Is 함수는 err2 안의 오류 체인을 탐색하여 가장 깊은 수준에서 랩핑된 \"sentinel\" 오류 값 ErrSentinel을 찾습니다.\n\nGo 1.13 이상 버전을 사용하는 경우, 특정 \"sentinel\" 오류 값으로 랩핑된 예상 오류 값인지 여부를 확인하기 위해 errors.Is 메서드를 사용하는 것이 좋습니다.\n\n<div class=\"content-ad\"></div>\n\n이 접근 방식은 특히 오류 래핑과 체인이 관련된 시나리오에서 더 견고하고 유연한 오류 처리를 제공합니다.\n\n## 3. 오류 값 유형 검사 전략\n\n이전에 살펴본 대로, Go 표준 라이브러리에서 제공하는 오류 값 구성 방법을 사용하여 구성된 \"sentinel\" 오류 값은 목표 값을 비교하는 기능 이상의 추가 오류 컨텍스트 정보를 제공하지 않습니다.\n\n오류 처리기가 오류 값에서 더 많은 \"오류 컨텍스트\" 정보를 필요로 하는 경우, 이전에 논의된 전략 및 오류 값 구성 방법이 충분하지 않을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이런 경우에는 추가 “에러 컨텍스트” 정보를 제공하기 위해 사용자 정의 에러 유형을 사용하여 에러 값을 구성해야 합니다.\n\n모든 에러 값이 에러 인터페이스 변수를 통해 균일하게 표시되기 때문에 기저 에러 유형이 전달하는 에러 컨텍스트 정보를 얻으려면 Go의 타입 어설션 또는 타입 스위치 메커니즘을 사용해야 합니다.\n\n에러 값을 검사하는 이 에러 처리 접근 방식은 “에러 값 타입 검사 전략”으로 참조할 수 있습니다.\n\n우리의 이해를 깊이 있게 하기 위해 표준 라이브러리의 예제를 살펴보겠습니다. json 패키지에서 UnmarshalTypeError라는 사용자 정의 에러 유형이 정의되어 있습니다:\n\n<div class=\"content-ad\"></div>\n\n에러 핸들러는 오류 값 유형 검사 전략을 사용하여 더 많은 오류 컨텍스트 정보를 얻을 수 있습니다. 아래는 이 전략을 활용하는 json 패키지의 메서드 구현 예시입니다:\n\n```js\r\n// $GOROOT/src/encoding/json/decode.go\nfunc (d *decodeState) addErrorContext(err error) error {\n    if d.errorContext.Struct != nil || len(d.errorContext.FieldStack) > 0 {\n        switch err := err.(type) {\n        case *UnmarshalTypeError:\n            err.Struct = d.errorContext.Struct.Name()\n            err.Field = strings.Join(d.errorContext.FieldStack, \".\")\n            return err\n        }\n    }\n    return err\n}\r\n```\n\n이 코드에서는 유형 스위치 문을 사용하여 err 변수가 나타내는 동적 유형 및 값을 결정하고, 일치하는 경우 분기에서 처리하기 위해 오류 컨텍스트 정보가 활용됩니다.\n\n<div class=\"content-ad\"></div>\n\n일반적으로 사용자 정의된 내보낸 오류 유형은 XXXError 형식으로 명명됩니다.\n\n\"sentinel\" 오류 처리 전략과 유사하게, 오류 값 유형 검사 전략은 사용자 정의 오류 유형을 오류 핸들러에 노출시켜, 해당 유형들이 API의 일부가 되도록 하며, 패키지의 공개 함수와 함께 사용될 수 있도록 합니다.\n\n배포된 후에는 개발자가 이러한 사용자 정의 오류 유형을 유지 관리해야 합니다. 게다가, 이러한 유형을 검사하고 사용하는 오류 핸들러에 대한 의존성을 만듭니다.\n\nGo 1.13부터 표준 라이브러리 errors 패키지는 오류 핸들러가 오류 값들을 검사할 수 있는 As 함수를 제공합니다.\n\n<div class=\"content-ad\"></div>\n\nAs 함수는 특정 사용자 정의 오류 유형인지를 결정하기 위해 타입 단언을 사용하는 것과 유사합니다. 아래 코드에서와 같이 err 변수가 특정 사용자 정의 오류 유형인지 확인합니다.\n\n```js\nvar customErr *CustomError\nif errors.As(err, &customErr) {\n    // Handle the error as a CustomError\n}\n```\n\nAs 함수의 차이점은 오류 변수에 래핑된 오류가 포함되어 있는 경우, errors.As 함수가 래핑된 오류 내의 오류 체인을 횡단하며, 체인 내의 모든 래핑된 오류와 일치하는 오류 유형을 찾을 때까지 비교한다는 것입니다. 이는 errors.Is의 동작과 유사합니다.\n\nAs 함수 사용 예시가 여기 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\ntype MyError struct {\n    e string\n}\n\nfunc (e *MyError) Error() string {\n    return e.e\n}\n\nfunc main() {\n    var err = &MyError{\"MyError error demo\"}\n    err1 := fmt.Errorf(\"wrap err: %w\", err)\n    err2 := fmt.Errorf(\"wrap err1: %w\", err1)\n    var e *MyError\n    if errors.As(err2, &e) {\n        println(\"MyError is on the chain of err2\")\n        println(e == err)                  \n        return                             \n    }                                      \n    println(\"MyError is not on the chain of err2\")\n} \n```\n\n결과.\n\n```js\nMyError is on the chain of err2\ntrue\n```\n\n마침내 출력된 결과처럼, errors.As 함수가 err2 내의 오류 체인을 성공적으로 탐지하여 가장 깊은 오류를 찾아내고, err2를 *MyError 유형과 일치시킵니다.\n\n<div class=\"content-ad\"></div>\n\n성공적인 일치가 발생하면, errors.As는 일치한 오류 값을 As 함수의 두 번째 매개변수에 저장합니다. 따라서 println(e == err)을 실행하면 true가 반환됩니다.\n\nGo 1.13 이상 버전을 사용 중이라면, 특정 사용자 정의 오류 유형의 인스턴스인지를 확인하기 위해 errors.As 메서드를 사용하는 것이 좋습니다.\n\n이 접근 방식은 사용자 정의 오류를 처리하는 더 유연하고 효율적인 방법을 제공하며, 특히 래핑된 오류와 함께 작업할 때 유용합니다.\n\n# 4. 오류 행동 특성 검사 전략.\n\n<div class=\"content-ad\"></div>\n\n이전에 우리가 논의한 세 가지 전략 중에서는 첫 번째 전략인 \"투명한 오류 처리 전략\"만이 오류 생성자와 오류 처리자 간의 결합을 효과적으로 줄입니다.\n\n두 번째와 세 번째 전략은 현실 세계의 코딩에서 실용적이지만, 여전히 오류 생성자와 오류 처리자 간의 결합을 어느 정도 도입합니다.\n\n그래서, \"투명한 오류 처리 전략\"을 제외하고는 오류 처리자와 오류 값 생성자 간의 결합을 줄일 다른 방법이 있을까요?\n\nGo 표준 라이브러리에서는 패키지 내에서 오류 유형을 분류하고 일반적인 오류 동작 특성을 추출하여 이러한 오류 동작 특성을 공개 인터페이스 유형으로 배치하는 다른 오류 처리 접근 방식을 찾을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 접근법은 \"오류 동작 특성 검사 전략\"으로 알려져 있습니다.\n\n예를 들어, 표준 라이브러리의 net 패키지는 모든 패키지 내의 일반적인 오류 동작 특성을 추상화하고 net.Error 인터페이스에 넣습니다. 다음 코드에서 확인할 수 있습니다:\n\n```js\n// $GOROOT/src/net/net.go\ntype Error interface {\n    error\n    Timeout() bool  \n    Temporary() bool\n}\n```\n\nnet.Error 인터페이스에는 오류 동작 특성을 확인하는 두 가지 메서드가 포함되어 있습니다: Timeout은 시간 초과 오류인지 확인하고 Temporary는 임시 오류인지 확인합니다.\n\n<div class=\"content-ad\"></div>\n\n에러 핸들러는 특정 에러의 동작 특성을 검사하고 이 정보를 기반으로 후속 에러 처리 분기에 대한 결정을 내리기 위해이 공개 인터페이스에 의존해야합니다.\n\n네트워크 패키지에서 가져온 다른 예제를 통해 에러 동작 특성 검사 전략을 사용하여 에러 처리를 더 향상시켜보겠습니다.\n\n```js\n// $GOROOT/src/net/http/server.go\nfunc (srv *Server) Serve(l net.Listener) error {\n    ... ...\n    for {\n        rw, e := l.Accept()\n        if e != nil {\n            select {\n            case <-srv.getDoneChan():\n                return ErrServerClosed\n            default:\n            }\n            if ne, ok := e.(net.Error); ok && ne.Temporary() {\n                ... ...\n                time.Sleep(tempDelay)\n                continue\n            }\n            return e\n        }\n        ...\n    }\n    ... ...\n}\n```\n\n위의 코드 스니펫에서 Accept 메서드는 실제로 net 패키지 내의 사용자 지정 에러 유형 인 *OpError 유형의 에러를 반환합니다. OpError는 일반 에러 특성 인터페이스인 net.Error를 구현합니다. 아래 코드에서 확인할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n// $GOROOT/src/net/net.go\ntype OpError struct {\n    ... ...\n    // Err is the error that occurred during the operation.\n    Err error\n}\n\ntype temporary interface {\n    Temporary() bool\n}\n\nfunc (e *OpError) Temporary() bool {\n  if ne, ok := e.Err.(*os.SyscallError); ok {\n      t, ok := ne.Err.(temporary)\n      return ok && t.Temporary()\n  }\n  t, ok := e.Err.(temporary)\n  return ok && t.Temporary()\n}\n```\n\n실제로 OpError 인스턴스는 오류 처리기에 의해 검사될 수 있으며 네트.Error 인터페이스에서 제공되는 메서드를 사용하여, 해당 동작이 Temporary나 Timeout과 같은 특성과 일치하는지 여부를 결정할 수 있습니다.\n\n이를 통해 오류 처리기는 네트워크 관련 작업의 맥락에서 해당 오류의 특정 동작에 기반하여 신중한 결정을 내릴 수 있게 됩니다.\n\n요약.\n\n<div class=\"content-ad\"></div>\n\nGo 언어에서 통합된 오류 유형은 오류 인터페이스이며, 오류 값이 할당될 수 있는 빠르게 구성되는 오류 값 구성 함수인 errors.New, fmt.Errorf 등을 포함하여 다양한 함수가 제공됩니다.\n\n또한 통합된 오류 유형을 오류 유형으로 사용하는 장점에 대해 논의했습니다.\n\n이 개념을 깊이 있게 이해하는 것이 중요합니다.\n\n- 투명한 오류 처리 전략: 오류 유형을 통합하고 추가 오류 컨텍스트를 제공하지 않음으로써 오류 처리를 간단하게 만들어 대부분의 경우에 적합합니다.\n- 징표 오류 처리 전략: 상징적인 오류 값 세트를 정의함으로써 오류 처리기가 값 비교를 통해 오류 처리 경로를 선택할 수 있게 합니다.\n- 오류 값 유형 검사 전략: 오류 유형을 사용자 정의하고 더 많은 오류 컨텍스트를 제공함으로써 추가 오류 컨텍스트가 필요하고 오류 유형을 검사하기 위해 타입 단언 또는 타입 스위치를 사용하는 시나리오에 적합합니다.\n- 오류 동작 특성 검사 전략: 공개 인터페이스를 통해 오류 동작 특성을 정의함으로써 오류 처리기가 특정 유형이 아닌 오류 특성을 검사할 수 있게 하며, 오류 동작 특성이 중요한 시나리오에 적합합니다.\n\n<div class=\"content-ad\"></div>\n\n각 전략마다 장점과 사용 사례가 있습니다. 적절한 전략을 선택하는 것은 유지 보수성, 결합도, 코드 복잡성 및 오류 컨텍스트 요구사항과 같은 프로그래밍에서의 특정 요구사항과 고려사항에 따라 달라집니다.\n\n이러한 전략을 이해함으로써 오류를 더 잘 다루고 관리할 수 있으며, 코드 신뢰성과 유지 관리성을 향상시킬 수 있습니다.\n\n이야기가 마음에 드시고 제 지원을 원하신다면 클랩(clap) 눌러주세요.\n\n여러분의 지원은 제게 매우 중요합니다. 감사합니다.","ogImage":{"url":"/assets/img/2024-06-27-MasteringErrorHandlinginGolangBestPracticesandTips_0.png"},"coverImage":"/assets/img/2024-06-27-MasteringErrorHandlinginGolangBestPracticesandTips_0.png","tag":["Tech"],"readingTime":15},{"title":"클릭을 부르는 8가지 효과적인 CTA 디자인 팁","description":"","date":"2024-06-27 18:30","slug":"2024-06-27-CalltoAction8onvincingCTADesignTips","content":"\n\n디지턈 솔루션의 전환율을 극대화하기 위해 CTA(호출 행동 요소)가 무엇인지 알아보세요. \n\n웹 개발에서 CTA란 사용자가 특정 동작을 취하도록 유도하는 웹 페이지의 요소를 의미합니다. 이는 버튼, 링크 또는 등록, 뉴스레터 구독, 파일 다운로드, 구매 등과 같이 웹사이트와 상호 작용하도록 방문자를 유도하는 인터페이스 요소일 수 있습니다. 적절한 CTA 디자인이 없으면 귀하는 대다수의 관객에게 무시당할 위험이 있습니다. 따라서 저희의 글에서는 사용자들의 흥미를 끄는 CTA를 만들고 의도한 목적을 달성하는 방법에 대해 안내하겠습니다. \n\n![CTA 디자인 팁](/assets/img/2024-06-27-CalltoAction8onvincingCTADesignTips_0.png)\n\n# 매력적인 CTA 만드는 방법\n\n<div class=\"content-ad\"></div>\n\n당신의 웹사이트 방문자들의 관심을 끌고 전환율을 높일 CTA(Call to Action)를 만들 수 있는 여덟 가지 팁을 살펴보도록 합시다.\n\n## 1. 관심과 동기 파악하기\n\n대상 군의 관심과 동기를 이해하는 것은 효과적인 CTA를 만드는 기초입니다. 사용자들에게 중요한 것, 해결하고 싶은 문제, 목표 등을 연구합니다. 이러한 측면을 파악하면 사용자들의 요구와 욕구에 직접 대응하는 CTA를 만들 수 있습니다.\n\n![Image](/assets/img/2024-06-27-CalltoAction8onvincingCTADesignTips_1.png)\n\n<div class=\"content-ad\"></div>\n\n## 2. 좋은 UX 우선순위 설정\n\n좋은 사용자 경험(UX)을 우선시함은 CTA가 직관적이고 쉽게 접근 가능해야 함을 의미합니다. 당신의 목표는 웹사이트와의 상호작용을 가능한 한 편리하고 즐겁게 만드는 것입니다. 사용자가 필요한 정보를 쉽게 찾고 원하는 조치를 취할 수 있도록 내비게이션을 고려해주세요.\n\n![CTA Design Tips](/assets/img/2024-06-27-CalltoAction8onvincingCTADesignTips_2.png)\n\n## 3. UI 디자인 최적화\n\n<div class=\"content-ad\"></div>\n\nUI 디자인을 최적화하는 것은 사용자의 CTA를 콘텐츠의 나머지 부분과 구분 지을 수 있게 하는 데 중요합니다. 대조적인 색상, 두드러진 글꼴 및 CTA 주변의 충분한 공간을 활용하여 사용자의 관심을 끌어야 합니다. 잘 디자인된 UI는 사용자가 제안된 작업을 빨리 발견하고 수행할 수 있도록 도와줍니다.\n\n![이미지](/assets/img/2024-06-27-CalltoAction8onvincingCTADesignTips_3.png)\n\n## 4. 전략적 콘텐츠 및 CTA 배치\n\n콘텐츠와 CTA의 전략적 배치는 그 효과를 결정합니다. CTA를 시인성 있고 논리적인 위치에 배치하는 것이 중요합니다. 페이지의 시작과 끝, 긴 텍스트 중간, 중요 정보 옆 등에 CTA를 배치하여 사용자가 의도한 경로를 따라가도록 도와주세요.\n\n<div class=\"content-ad\"></div>\n\n\n![Call to Action Design Tips - Image 1](/assets/img/2024-06-27-CalltoAction8onvincingCTADesignTips_4.png)\n\n## 5. Designing effective CTAs\n\nCreating effective CTAs involves balancing attractive design with functionality. The button or element should be visible, but not overly intrusive. Use clear and understandable forms that are easy to understand and do not leave the user in doubt about their purpose.\n\n![Call to Action Design Tips - Image 2](/assets/img/2024-06-27-CalltoAction8onvincingCTADesignTips_5.png)\n\n\n<div class=\"content-ad\"></div>\n\n## 6. 사용자의 목표 강조\n\n사용자의 목표에 집중하면 유용하고 관련성 있는 CTA를 작성할 수 있습니다. 제품이나 서비스가 사용자의 문제를 해결하거나 삶을 개선하는 방법에 초점을 맞추세요. 호출부는 제안된 단계를 완료함으로써 사용자가 정확히 어떤 결과를 얻게 될지 보여주어야 합니다.\n\n![CTA Design Tips 6](/assets/img/2024-06-27-CalltoAction8onvincingCTADesignTips_6.png)\n\n## 7. 매력적인 텍스트 작성\n\n<div class=\"content-ad\"></div>\n\nCTA 복사본 작성에는 예술이 필요합니다. 텍스트는 간결하고 명확하며 행동을 촉발해야 합니다. 강렬한 동사와 긴급성 또는 혜택을 전달하는 언어를 사용하세요. 예: \"지금 구매\", \"할인 받기\", \"자세히 알아보기\".\n\n![](/assets/img/2024-06-27-CalltoAction8onvincingCTADesignTips_7.png)\n\n## 8. 감정에 호소\n\n감정적 충격은 마케터의 강력한 도구입니다. 사용자의 감정에 호소하여 CTA를 실행하세요: 기회를 놓치지 않을까 두려워하는 마음, 혜택을 누리고 싶어하는 욕망, 새로운 것을 소유하며 느끼는 기쁨. 감정적으로 충전된 CTA는 전환율을 크게 증가시킬 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-27-CalltoAction8onvincingCTADesignTips_8.png\" />\n\n# 아직 일이 끝나지 않았어요\n\n위의 모든 팁을 사용하여 CTA를 생성했다면, 이것은 작업의 일부일 뿐이며 아직 해야 할 중요한 단계가 남아 있습니다. 즉, 호출하여야 할 작업이 그 목적을 제공하는지 확인하는 것입니다. 이를 위해 A/B 테스트를 수행해야 합니다. 이렇게 하면 버튼 디자인이나 배치 변경이 전환율에 어떻게 영향을 주는지 이해할 수 있습니다. 최대 효과를 얻을 때까지 이러한 속성을 실험해보세요. 왜냐하면 가장 작은 수정도 더 나은 사용자 참여를 제공할 수 있기 때문입니다.\n\n# 고급 UX/UI 도구로 작업을 간편하게 만들어보세요\n\n<div class=\"content-ad\"></div>\n\nCTA를 만드는 모든 단계를 가능한 한 간단하게 만들기 위해 Flowmapp의 편리한 도구를 사용할 수 있어요. Wireframe Creator를 사용하면 웹 사이트 구조를 세밀하게 설계하고 CTA가 어떻게 보일지 전체 그림을 볼 수 있어요. 게다가 노력을 들이지 않고 쉽게 변경할 수 있는 좋은 방법이에요.\n\n또한 Flowmapp의 User Flow 도구를 사용하여 웹 사이트 방문부터 CTA와 상호 작용할 때까지 변환 퍼널을 구축할 수 있어요. 동시에 방문자가 마주치는 장애물을 추적하고 제거하여 사용자가 최대한 빠르고 쉽게 목표 동작을 완료할 수 있도록 돕을 수 있어요.\n\nCTA는 일반적인 웹 사이트 방문자를 활발한 사용자나 고객으로 전환하는 데 중요한 역할을 해요. 명확하고 설득력 있는 CTA가 없으면 방문자는 사이트에서 길을 잃거나 무슨 조치를 취해야 하는지 알 수 없어요. 효과적인 CTA는 사용자를 안내하여 사이트를 직관적이고 집중할 수 있는 방향으로 이동하게 만들어요. CTA를 만드는 작업을 간소화하고 싶다면 Flowmapp의 완전히 무료 UX/UI 디자인 도구를 사용할 수 있어요.","ogImage":{"url":"/assets/img/2024-06-27-CalltoAction8onvincingCTADesignTips_0.png"},"coverImage":"/assets/img/2024-06-27-CalltoAction8onvincingCTADesignTips_0.png","tag":["Tech"],"readingTime":4}],"page":"1","totalPageCount":28,"totalPageGroupCount":2,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}