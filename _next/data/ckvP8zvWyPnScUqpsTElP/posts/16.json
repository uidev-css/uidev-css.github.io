{"pageProps":{"posts":[{"title":"Flutter에서 Bloc과 get_it 패키지를 사용하여 클린 아키텍처 구현하는 방법","description":"","date":"2024-06-21 21:16","slug":"2024-06-21-HowtoimplementcleanarchitecturewithBlocandget_itpackageinFlutter","content":"\n이 기사에서는 get_it 패키지를 서비스 로케이터로, Bloc를 상태 관리로 사용하여 클린 아키텍처를 구현하는 방법을 가르쳐 드리겠습니다. 이를 통해 책임을 분리하고, 앱이 점점 커지고 복잡해짐에 따라 새로운 기능을 더 잘 유지하고 코드를 이해하기 쉽게 유지할 수 있습니다.\n\n다음 이미지에서 보듯이, 우리는 클린 아키텍처 레이어를 기반으로 기본 파일 시스템을 생성하는 방법에 대해 알아볼 것입니다.\n\n![이미지](/assets/img/2024-06-21-HowtoimplementcleanarchitecturewithBlocandget_itpackageinFlutter_0.png)\n\n프로젝트의 요구 사항에 따라이 파일 시스템이 변경될 수 있다는 점을 고려해야 합니다. 일부 개발자는 작은 앱에서 작업할 때 도메인 레이어를 사용하지 않는 경우가 있습니다. 이 경우에는 사용 사례와 리포지토리를 통해 비즈니스 로직을 추상화하는 데 도움이 될 것이므로 사용하겠습니다.\n\n<div class=\"content-ad\"></div>\n\n# 브레이킹 배드 앱\n\nBloc 및 get_it 패키지를 사용하여 청결한 아키텍처를 배우기 위해, 우리는 Breaking Bad Quotes API(https://api.breakingbadquotes.xyz/v1/quotes)를 사용하는 간단한 앱을 만들 것입니다. 이 API를 통해 Breaking Bad에서 랜덤 명언을 얻을 수 있습니다. 사용하기 매우 쉽고 응답은 명언과 저자가 포함된 객체가 있는 간단한 목록입니다.\n\n좋아요, 시작해 봅시다! API를 사용하면 다음과 같이 간단한 응답을 받게 됩니다.\n\n```js\n[\n  {\n    quote: \"Congratulations, you’ve just left your family a second-hand Subaru.\",\n    author: \"Saul Goodman\",\n  },\n];\n```\n\n<div class=\"content-ad\"></div>\n\n클린 아키텍처를 구현하려면 도메인 레이어부터 시작하는 것이 좋습니다. 이 레이어는 추상 리포지토리를 주입한 유스케이스를 통해 데이터와 프레젠테이션 레이어 사이의 다리 역할을 합니다.\n\n# 응답 엔티티\n\n우선 엔티티를 만들 것인데, 이는 앱에서 가장 간단한 객체를 나타냅니다. 모든 엔티티와 모델을 Equatable에서 확장하여 객체를 문제없이 비교하고, 앱의 테스트를 개선하며, 상태에서 원치 않는 동작을 피할 수 있도록 해야 합니다.\n\n```js\nimport 'package:equatable/equatable.dart';\n\nclass QuoteEntitie extends Equatable {\n\n  final String? quote;\n  final String? author;\n\n  const QuoteEntitie({\n    this.quote,\n    this.author,\n  });\n\n  @override\n  List<Object?> get props => [\n    quote,\n    author,\n  ];\n}\n```\n\n<div class=\"content-ad\"></div>\n\n# 추상 저장소\n\n이제 우리는 리포지토리를 구현하는 모든 클래스에 대해 getQuote() 함수를 강제시키는 계약으로 작용하는 추상 클래스를 통해 엔티티를 반환해야 합니다. 이 구현은 나중에 확인하겠습니다. API 서비스가 비동기 데이터를 반환하기 때문에 Future를 사용합니다.\n\n```js\nabstract class QuoteRepository{\n  Future<QuoteEntitie> getQuote();\n}\n```\n\n# 사용 사례\n\n<div class=\"content-ad\"></div>\n\n다음으로, 우리는 리포지토리를 생성자를 통해 주입하는 유스 케이스를 만들 것입니다. 이 유스 케이스는 데이터 레이어와 프레젠테이션 레이어 사이의 다리 역할을 하며 새로운 상태를 발신하는 상태 관리에 중요한 역할을 합니다.\n\n```js\nclass QuoteUsecase {\n\n  final QuoteRepository _quoteRepository;\n\n  QuoteUsecase(this._quoteRepository);\n\n  Future<QuoteEntity> getQuote() {\n    return _quoteRepository.getQuote();\n  }\n}\n```\n\n이 시점에서, 도메인 레이어를 구현합니다. 파일 시스템은 다음과 같이 보여야 합니다:\n\n![image](/assets/img/2024-06-21-HowtoimplementcleanarchitecturewithBlocandget_itpackageinFlutter_1.png)\n\n<div class=\"content-ad\"></div>\n\n이제 데이터 레이어를 구현할 차례입니다. 이름에서 알 수 있듯이 데이터 레이어는 다른 소스(우리 경우 API)에서 데이터를 관리하고 도메인 레이어와 상호 작용하여 프리젠테이션 레이어가 필요로 하는 모든 데이터를 제공합니다.\n\n# 모델 응답\n\n모델 폴더를 앱의 요구에 따라 나눌 수 있습니다. 이 경우 API 응답 모델을 위한 폴더와 API 요청 모델을 위한 폴더 두 개로 나누겠습니다. 우리 앱에서는 API 응답을 위한 모델 하나만 필요하겠지만요. 또한, 객체를 비교할 수 있도록 Equatable에서 모델을 확장하고 엔티티를 구현하는 것을 기억해주세요.\n\n```js\nclass QuoteResponseModel extends Equatable implements QuoteEntitie {\n  @override\n  final String? quote;\n  @override\n  final String? author;\n\n  const QuoteResponseModel({\n    this.quote,\n    this.author,\n  });\n\n  QuoteResponseModel copyWith({\n    String? quote,\n    String? author,\n  }) =>\n      QuoteResponseModel(\n        quote: quote ?? this.quote,\n        author: author ?? this.author,\n      );\n\n  factory QuoteResponseModel.fromRawJson(String str) =>\n      QuoteResponseModel.fromJson(json.decode(str)[0]);\n\n\n  factory QuoteResponseModel.fromJson(Map<String, dynamic> json) =>\n      QuoteResponseModel(\n        quote: json[\"quote\"],\n        author: json[\"author\"],\n      );\n\n  @override\n  List<Object?> get props => [\n        quote,\n        author,\n      ];\n}\n```\n\n<div class=\"content-ad\"></div>\n\n# 데이터 소스\n\n데이터 소스를 만들어 봅시다. 이는 필요에 따라 데이터를 가져오는 프로세스를 처리합니다. 이 예시에서는 API에서 데이터를 가져와 모든 것이 문제없이 진행되면 응답 객체를 생성하거나 오류가 발생하면 예외를 throw합니다. 보시다시피, 우리는 먼저 추상 클래스를 작성하여 추상 로직을 만듭니다. 이후 이 클래스의 구현은 선택한 클라이언트를 사용하여 데이터를 가져오는 책임을 갖게 됩니다. 이 경우 HTTP 클라이언트는 나중에 get_it 패키지를 사용하여 주입될 것입니다.\n\n```js\nimport 'package:http/http.dart' as http;\n\nabstract class QuoteDataSource {\n  Future<QuoteResponseModel> getQuote();\n}\n\nclass QuoteDataSourceImpl implements QuoteDataSource {\n  final http.Client _client;\n\n  QuoteDataSourceImpl(this._client);\n\n  @override\n  Future<QuoteResponseModel> getQuote() async {\n    final Uri url = Uri.https('api.breakingbadquotes.xyz', '/v1/quotes');\n    final http.Response response = await _client.get(url);\n    if (response.statusCode == 200) {\n      final QuoteResponseModel quoteResponseModel =\n          QuoteResponseModel.fromRawJson(response.body);\n      return quoteResponseModel;\n    } else {\n      throw Exception();\n    }\n  }\n}\n```\n\n# 저장소 구현\n\n<div class=\"content-ad\"></div>\n\n데이터 소스를 생성한 후, 이전에 만든 추상 리포지토리를 구현해야 합니다. 이는 구현 클래스의 생성자에 데이터 소스를 주입하고 추상 리포지토리 함수를 오버라이딩하여 달성할 수 있습니다.\n\n```js\nclass QuoteRepositoryImpl implements QuoteRepository{\n\n  final QuoteDataSource _dataSource;\n\n  QuoteRepositoryImpl(this._dataSource);\n\n  @override\n  Future<QuoteEntitie> getQuote() async{\n    return await _dataSource.getQuote();\n  }\n\n}\n```\n\n이 시점에서 애플리케이션에서 모든 것이 정상적으로 작동하는지 간단하게 테스트할 수 있습니다. FutureBuilder 위젯을 사용하여 API 정보를 검색하고 직접 의존성 주입을 통해 use case 객체를 만들어 확인할 수 있습니다.\n\n```js\nvoid main() => runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  MyApp({super.key});\n\n  final useCase = QuoteUsecase(QuoteRepositoryImpl(QuoteDataSourceImpl()));\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      debugShowCheckedModeBanner: false,\n      title: 'Quote App',\n      home: Scaffold(\n        appBar: AppBar(),\n        body: Center(\n          child: FutureBuilder(\n            future: useCase.getQuote(),\n            builder:\n                (BuildContext context, AsyncSnapshot<QuoteEntitie> snapshot) {\n              return Column(\n                children: [\n                  Text(\"${snapshot.data?.quote}\"),\n                  Text(\"${snapshot.data?.quote}\"),\n                ],\n              );\n            },\n          ),\n        ),\n      ),\n    );\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n하지만 이 방식에는 유지 및 확장이 어려워지고, 앱이 추가 기능과 함께 복잡해질수록 문제가 발생할 수 있습니다. 이를 해결하기 위해 홈 화면을 다른 파일로 분리하고, 서비스 로케이터 메서드를 생성하여 Bloc을 사용하여 상태를 관리할 것입니다.\n\n# Bloc 생성\n\n알다시피 Flutter 애플리케이션에서 Bloc을 구현하려면 상태 파일, 이벤트 파일, 그리고 이벤트를 기반으로 상태를 발행하는 Bloc 파일을 생성해야 합니다. 이 경우 API가 데이터를 가져오기 시작할 때와 완료될 때 피드백을 제공하는 간단한 로직 상태가 있습니다. 따라서 로딩 중인지와 견적이 이용 가능한지를 나타내는 상태가 있을 것입니다.\n\n```js\nclass QuoteBlocState extends Equatable {\n\n  final bool? isLoadingQuote;\n  final QuoteEntitie? quote;\n\n  const QuoteBlocState({this.isLoadingQuote, this.quote});\n\n  QuoteBlocState copyWith({\n    bool? isLoadingQuote,\n    QuoteEntitie? quote\n    }) {\n    return QuoteBlocState(\n      isLoadingQuote: isLoadingQuote ?? this.isLoadingQuote,\n      quote: quote ?? this.quote,\n    );\n  }\n\n  @override\n  List<Object?> get props => [\n    isLoadingQuote,\n    quote\n    ];\n}\n```\n\n<div class=\"content-ad\"></div>\n\n```js\nsealed class QuoteBlocEvent extends Equatable {\n  const QuoteBlocEvent();\n\n  @override\n  List<Object> get props => [];\n}\n\nfinal class GetQuouteEvent extends QuoteBlocEvent{\n  const GetQuouteEvent();\n}\n```\n\n```js\nclass QuoteBloc extends Bloc<QuoteBlocEvent, QuoteBlocState> {\n\n  final QuoteUsecase _quoteUsecase;\n\n  QuoteBloc(this._quoteUsecase) : super(const QuoteBlocState()) {\n    on<GetQuouteEvent>(_getQuote);\n  }\n\n  FutureOr<void> _getQuote(\n      GetQuouteEvent event, Emitter<QuoteBlocState> emit) async {\n    emit(state.copyWith(isLoadingQuote: true));\n    final QuoteEntitie response = await _quoteUsecase.getQuote();\n    emit(state.copyWith(quote: response, isLoadingQuote: false));\n  }\n}\n```\n\n여기서는 use case가 생성자로 주입되어 getQuote() 함수를 사용할 수 있도록 되어 있다는 점을 강조하는 것이 매우 중요합니다.\n\n우리의 기본 아키텍처를 완성하기 위해 필요한 유일한 것은 서비스를 위한 초기화(init) 함수를 만드는 것입니다. 이 함수를 통해 앱 전체에서 필요한 경우 서비스를 사용할 수 있습니다. get_it 패키지를 사용하면 이를 매우 간단하게 만들 수 있습니다. 아래와 같은 함수를 만드는 것만 필요합니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n최종 getIt = GetIt.instance;\n\nvoid initServices() {\n\n  이제 http.Client client = getIt.registerSingleton(http.Client());\n\n  이제 QuoteDataSourceImpl quoteDataSourceImpl =\n      getIt.registerSingleton(QuoteDataSourceImpl(client));\n\n  이제 QuoteRepositoryImpl quoteRepositoryImpl =\n      getIt.registerSingleton(QuoteRepositoryImpl(quoteDataSourceImpl));\n\n  이제 QuoteUsecase quoteUsecase =\n      getIt.registerSingleton(QuoteUsecase(quoteRepositoryImpl));\n\n  getIt.registerFactory(() => QuoteBloc(quoteUsecase));\n}\n```\n\nmain 함수에서 runApp() 이전에 initServices() 함수를 호출하여 애플리케이션의 모든 부분이 인스턴스에 액세스할 수 있도록 합니다.\n\n```js\nvoid main() {\n  intServices();\n  runApp(const MyApp());\n}\n```\n\n이 시점에서 Bloc을 사용한 상태 관리 및 이미 설정된 서비스 로케이터를 사용하여 표현 레이어가 이렇게 보여야 합니다. 화면을 독립적인 파일로 분리하는 것을 잊지 마세요.\n\n<div class=\"content-ad\"></div>\n\n![How to Implement Clean Architecture with Bloc and get_it Package in Flutter 2](/assets/img/2024-06-21-HowtoimplementcleanarchitecturewithBlocandget_itpackageinFlutter_2.png)\n\n마지막으로, 관심 분리를 위해 홈 화면은 작은 위젯으로, 랜덤 인용구와 그 저자를 표시하는 컬럼이 있습니다. 또한, API에서 새 데이터를 가져와 다른 인용구를 검색하는 버튼이 있습니다. 데이터를 가져오는 동안에는 CircularProgressIndicator 위젯을 표시합니다.\n\n```js\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({Key? key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(),\n      body: const Center(child: _QuoteWidget()),\n    );\n  }\n}\n\nclass _QuoteWidget extends StatelessWidget {\n  const _QuoteWidget();\n\n  @override\n  Widget build(BuildContext context) {\n    return Builder(builder: (context) {\n      final QuoteBlocState state = context.select((QuoteBloc bloc) => bloc.state);\n      final bool? isLoading = state.isLoadingQuote;\n      final QuoteEntity? quote = state.quote;\n\n      if (isLoading == true) {\n        return const Center(\n          child: CircularProgressIndicator(),\n        );\n      }\n\n      return Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          Text(\"${quote?.quote}\"),\n          Text(\"${quote?.author}\"),\n          ElevatedButton(\n              onPressed: () {\n                context.read<QuoteBloc>().add(const GetQuoteEvent());\n              },\n              child: const Text(\"Get another quote\"))\n        ],\n      );\n    });\n  }\n}\n```\n\n마지막 단계는 Bloc을 get_it을 사용하여 필요한 위치에 주입하는 것입니다. QuouteBloc의 인스턴스가 서비스 로케이터를 사용하여 위젯 트리에 주입되는 점에 유의하십시오. 마지막으로, Bloc 인스턴스가 생성된 후 인용구를 가져오고 새 상태를 발생시키는 이벤트를 호출하기 위해 연속 연산자를 사용하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nclass MyApp extends StatelessWidget {\n  const MyApp({Key key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n        debugShowCheckedModeBanner: false,\n        title: 'Quote App',\n        home: BlocProvider(\n          create: (context) => getIt<QuoteBloc>()..add(const GetQuouteEvent()),\n          child: Builder(builder: (context) {\n            return const HomeScreen();\n          }),\n        ));\n  }\n}\n```\n\n그러니까 이제 앱을 실행시켜서 코딩의 매력을 만끽해보세요.\n\n![image](/assets/img/2024-06-21-HowtoimplementcleanarchitecturewithBlocandget_itpackageinFlutter_3.png)\n","ogImage":{"url":"/assets/img/2024-06-21-HowtoimplementcleanarchitecturewithBlocandget_itpackageinFlutter_0.png"},"coverImage":"/assets/img/2024-06-21-HowtoimplementcleanarchitecturewithBlocandget_itpackageinFlutter_0.png","tag":["Tech"],"readingTime":11},{"title":"Flutter 웹 애플리케이션에서 화살표 키 스크롤링 구현 방법","description":"","date":"2024-06-21 21:15","slug":"2024-06-21-ArrowKeyScrollinginFlutterWeb","content":"\n\n![화살표 키 스크롤링](/assets/img/2024-06-21-ArrowKeyScrollinginFlutterWeb_0.png)\n\n환영합니다, 플러터 열정자 여러분! 오늘은 플러터 웹에서 화살표 키 스크롤링을 구현하는 방법을 알아볼 거에요. 웹 애플리케이션이 더 상호작용적으로 변화함에 따라 사용자가 콘텐츠를 탐색하는 직관적인 방법을 제공하는 것이 중요해지고 있어요. 이 글에서는 화살표 키 입력을 감지하고 스크롤링을 처리하는 단계를 안내할 거에요.\n\n플러터 웹은 고유의 도전 과제를 가지고 있는데, 그 중 하나는 화살표 키 스크롤링에 대한 기본 지원의 부재입니다. 이것은 보통 사소한 제한처럼 보이지만 사용자의 탐색에 상당한 영향을 미칠 수 있어요.\n\n그래서 플러터에서 화살표 키를 통해 스크롤링하는 몇 가지 솔루션이 있어요. 함께 솔루션을 알아보러 가볼까요? 🤓🤓\n\n<div class=\"content-ad\"></div>\n\n# 첫 번째 솔루션:\n\nListView에서 \"primary\" 속성이 있는 것을 알고 있습니다. ListView 위젯 내에서 \"primary\" 속성을 true로 설정하면 사용자가 키보드 화살표 키를 사용하여 내용을 원활하게 탐색할 수 있습니다.\n\n이 기능을 테스트하기 위해 이 코드를 복제해 보세요:\n\n# 두 번째 솔루션:\n\n<div class=\"content-ad\"></div>\n\n우리는 GestureDetector와 FocusScope를 통해 화살표 키도 활성화할 수 있어요.\n\nGestureDetector =` 'ListView'를 'GestureDetector' 위젯으로 감쌉니다. 이렇게 하면 사용자가 탭과 같은 사용자 입력 제스처를 감지할 수 있어요. 이를 활용하여 ListView 내에서 포커스를 관리할 수 있습니다.\n\n- FocusScope: 'FocusScope' 위젯을 사용하여 ListView의 포커스 상태를 동적으로 관리할 거예요. 'FocusScopeNode' 인스턴스를 만들고 유지함으로써 포커스 동작을 제어할 수 있어요. 이를 통해 ListView가 사용자 상호작용에 적절하게 응답하도록 보장합니다.\n- 기본 속성 설정: ListView 내에서 'primary' 속성을 포커스 상태에 따라 동적으로 설정합니다. ListView가 포커스를 얻을 때는 'primary'를 true로 설정하여 부모 위젯 계층 내에서 기본 스크롤 뷰가 되어야 함을 나타냅니다. 이를 통해 키보드 화살표 키를 사용하여 부드럽고 직관적인 스크롤이 가능해지며, 접근성과 사용성을 향상시킵니다.\n\n이 기능을 테스트하기 위해 이 코드를 클론하세요:\n\n<div class=\"content-ad\"></div>\n\n# 세 번째 해결책:\n\nKeyboardListener와 ScrollController를 사용합니다.\n\nKeyboardListener와 ScrollController 두 가지 위젯을 통해 플러터 웹 애플리케이션의 ListView에서 키보드 입력을 모니터하고 스크롤 동작을 동적으로 조정할 수 있습니다. 화살표 키 이벤트를 감지하고 스크롤 위치를 그에 맞게 애니메이팅함으로써 사용자에게 직관적이고 반응성 있는 스크롤 경험을 제공합니다.\n\n- KeyboardListener: ListView를 KeyboardListener 위젯으로 감싸줍니다. 이 위젯은 키보드 이벤트를 수신하고 사용자 입력에 효과적으로 응답할 수 있도록 합니다. 자동 초점 노드를 지정함으로써 ListView가 기본적으로 키보드 입력 초점을 받도록 하여 원활한 상호작용이 가능하도록 보장합니다.\n- ScrollController: ScrollController를 초기화하여 ListView의 스크롤 위치를 프로그래밍 방식으로 관리합니다. 이 컨트롤러를 통해 화살표 키 이벤트에 반응하여 스크롤 위치를 애니메이션화할 수 있어 부드럽고 유동적인 스크롤 동작을 가능하게 합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nonKeyEvent: (value) {\n  if (_controller.position.outOfRange) {\n    return;\n  }\n  final offset = _controller.offset;\n  if (value.physicalKey.debugName == \"Arrow Down\") {\n    _controller.animateTo(offset + 50,\n        duration: const Duration(milliseconds: 500),\n        curve: Curves.linear);\n  }\n  if (value.physicalKey.debugName == \"Arrow Up\") {\n    _controller.animateTo(offset - 50,\n        duration: const Duration(milliseconds: 500),\n        curve: Curves.linear);\n  }\n},\n```\n\n이 코드를 복제하여 이 기능을 테스트해보세요:\n\n# 네 번째 솔루션 :\n\n키보드 화살표 키 스크롤링을 위해 FocusableActionDetector 사용하기.\n\n<div class=\"content-ad\"></div>\n\n- FocusableActionDetector : ListView을 GestureDetector와 FocusableActionDetector의 조합으로 감쌀 것입니다. 이 설정을 통해 키보드 이벤트를 감지하고 화살표 키 입력에 대응하여 해당 작업을 트리거할 수 있습니다.\n- 단축키 및 작업 정의: FocusableActionDetector 내에서 화살표 키 이벤트 (예: arrowUp 및 arrowDown)에 대한 단축키를 정의하고 해당 단축키를 특정 콜백 작업에 연결합니다. 이러한 작업은 ListView의 스크롤 위치를 동적으로 조정하는 사용자 지정 함수를 트리거하여 부드럽고 직관적인 스크롤 경험을 제공합니다.\n- ScrollController : ListView의 스크롤 위치를 프로그래밍 방식으로 관리하기 위해 ScrollController를 초기화할 것입니다.\n\n이 기능을 테스트하려면 이 코드를 복제해 보세요:\n\n# 결론:\n\nFlutter 웹 앱에서 화살표 키 스크롤링에 대한 다양한 방법에 대해 논의했습니다. Flutter 웹에서 직면한 공통적인 도전 과제입니다.\n\n<div class=\"content-ad\"></div>\n\n이 기사가 마음에 들었기를 바라요!\n\n만약 이 기사가 도움이 되었다면 👏 손뼉을 치세요.\n\n다음에 또 만나요!","ogImage":{"url":"/assets/img/2024-06-21-ArrowKeyScrollinginFlutterWeb_0.png"},"coverImage":"/assets/img/2024-06-21-ArrowKeyScrollinginFlutterWeb_0.png","tag":["Tech"],"readingTime":4},{"title":"플러터에서 히어로 애니메이션 마스터하기 종합 가이드","description":"","date":"2024-06-21 21:13","slug":"2024-06-21-MasteringHeroAnimationsinFlutterAComprehensiveGuide","content":"\n![image](https://miro.medium.com/v2/resize:fit:1400/1*hfZq5kMkFSZtlSRsReQYdQ.gif)\n\n모바일 앱 개발 세계에서 부드럽고 시각적으로 매력적인 전환을 만드는 것은 매혹적인 사용자 경험을 위해 중요합니다. Flutter에서 이를 달성하는 가장 효과적인 방법 중 하나는 히어로 애니메이션을 통해입니다. 히어로 애니메이션은 위젯을 한 페이지에서 다른 페이지로 애니메이션화하여 서로 연결되고 동적인 느낌을 만들어 다른 화면 간에 매끄러운 전환을 제공합니다. 이 안내서에서는 Flutter에서 히어로 애니메이션의 기본 사항, 중요성 및 코드 예제로 구현하는 방법을 안내합니다.\n\n## 히어로 애니메이션의 중요성과 사용 사례\n\n히어로 애니메이션은 시각적으로 매력적일 뿐만 아니라 사용자 경험에서도 중요한 역할을 합니다. 그들은 다음에서 도움이 됩니다:\n\n<div class=\"content-ad\"></div>\n\n- 컨텍스트 유지: 사용자들이 쉽게 전환을 따라갈 수 있고 서로 다른 UI 요소 간의 관계를 이해할 수 있습니다.\n- 시각적 연속성 제공: 부드럽고 연속적인 사용자 경험을 제공하여 네비게이션이 자연스럽고 순조롭게 느껴지도록 합니다.\n- 사용자 참여 증진: 정교하게 디자인된 애니메이션은 앱을 사용하는 데 더 즐겁고 매력적으로 만들 수 있습니다.\n\n## 주요 히어로 애니메이션 사용 사례:\n\n- 이미지 갤러리 전환: 섬네일 그리드 뷰에서 전체 화면 이미지 뷰로 이동하는 것.\n- 프로필 페이지 애니메이션: 서로 다른 화면 간에 사용자 아바타나 프로필 사진을 전환하는 것.\n- 전자 상거래 앱: 제품 이미지를 목록에서 상세보기로 애니메이션하는 것.\n\n# 파트 1: 히어로 애니메이션의 기본 구조\n\n<div class=\"content-ad\"></div>\n\n## 히어로 애니메이션이란 무엇인가요?\n\nFlutter에서의 히어로 애니메이션은 위젯 간 전환 애니메이션으로, 화면 전환 시 위젯이 한 화면에서 다른 화면으로 \"비행\"하는 것을 의미합니다. 이로 인해 위젯은 출발지와 도착지 화면 사이를 부드럽게 전환하는 것처럼 보여 시각적으로 매력적인 효과를 제공합니다.\n\n## 기본 히어로 애니메이션 예제\n\n기본 히어로 애니메이션을 만들려면 다음 단계를 따라주세요:\n\n<div class=\"content-ad\"></div>\n\n1. 위젯을 히어로 위젯으로 감싸기:\n\n- 애니메이션을 적용하려는 위젯을 감싸는 데 히어로 위젯을 사용하세요.\n- 원본과 대상 히어로 위젯이 동일한 태그를 가지고 있는지 확인하세요.\n\n2. 화면 간 이동하기:\n\n- 화면 간 이동에는 Navigator.push 메서드를 사용하세요.\n\n<div class=\"content-ad\"></div>\n\n여기에 기본 hero 애니메이션을 보여주는 간단한 예제가 있어요:\n\n![영상](https://miro.medium.com/v2/resize:fit:1400/1*Tnp6mCmVil2aRqNtcxrfDg.gif)\n\n```js\nimport 'package:flutter/material.dart';\n\nvoid main() => runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: FirstPage(),\n    );\n  }\n}\n\nclass FirstPage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('First Page')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            Navigator.push(\n              context,\n              MaterialPageRoute(builder: (context) => SecondPage()),\n            );\n          },\n          child: Text('Go to Second Page'),\n        ),\n      ),\n    );\n  }\n}\n\nclass SecondPage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Second Page')),\n      body: Center(\n        child: Text('Welcome to the second page!'),\n      ),\n    );\n  }\n}\n```\n\n## 플러터에서 사용자 정의 전환\n\n<div class=\"content-ad\"></div>\n\n기본 전환 방식은 편리하지만, 사용자 정의 전환은 애니메이션에 대한 더 큰 유연성과 제어를 제공하여 더 독특한 사용자 경험을 만들 수 있습니다. 페이지 라우트 빌더를 사용하여 사용자 정의 전환을 구현할 수 있으며 전환 애니메이션을 정의할 수 있습니다.\n\n사용자 정의 슬라이드 전환 예시\n\n![사용자 정의 슬라이드 전환 예시](https://miro.medium.com/v2/resize:fit:1400/1*c5cZecOnWL5IL6g75JmoNw.gif)\n\nPageRouteBuilder를 사용하여 사용자 정의 슬라이드 전환의 예시를 확인해보세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport 'package:flutter/material.dart';\n\nvoid main() => runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: FirstScreen(),\n    );\n  }\n}\n\nclass FirstScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('First Screen')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            Navigator.push(context, PageRouteBuilder(\n              pageBuilder: (context, animation, secondaryAnimation) => SecondScreen(),\n              transitionsBuilder: (context, animation, secondaryAnimation, child) {\n                const begin = Offset(1.0, 0.0);\n                const end = Offset.zero;\n                const curve = Curves.ease;\n\n                var tween = Tween(begin: begin, end: end).chain(CurveTween(curve: curve));\n\n                return SlideTransition(\n                  position: animation.drive(tween),\n                  child: child,\n                );\n              },\n            ));\n          },\n          child: Text('Go to Second Screen'),\n        ),\n      ),\n    );\n  }\n}\n\nclass SecondScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Second Screen')),\n      body: Center(\n        child: Text('This is the second screen'),\n      ),\n    );\n  }\n}\n```\n\n# 사용자 정의 슬라이드 트랜지션 설명\n\n- PageRouteBuilder: 사용자 정의 페이지 라우트 전환을 생성하는 데 사용됩니다.\n- pageBuilder: 대상 화면을 정의합니다.\n- transitionsBuilder: 전환 애니메이션을 정의합니다. 여기서 SlideTransition을 사용하여 새 화면이 오른쪽에서 슬라이드되는 애니메이션을 구현합니다.\n\n## 코드 설명\n\n<div class=\"content-ad\"></div>\n\n- FirstScreen Class: 초기 화면으로 이미지의 작은 버전을 표시하는 곳입니다. `hero-tag` 태그로 된 Hero 위젯으로 감싸져 있습니다. GestureDetector를 사용하여 탭하면 SecondScreen으로 이동합니다.\n- SecondScreen Class: 이 화면은 동일한 이미지의 큰 버전을 표시하며, 같은 태그로 된 Hero 위젯으로도 감싸져 있습니다. Hero 애니메이션은 이 태그를 기반으로 두 위젯을 연결하고 매끄러운 전환 효과를 만듭니다.\n\n## 고급 사용자 정의\n\nFlutter를 사용하면 여러 가지 사용자 정의가 가능합니다. 예를 들어 사용자 정의 비행 경로 및 애니메이션을 정의하거나, FlightShuttleBuilder를 사용하여 전환 중에 hero의 모양을 사용자 정의할 수 있습니다.\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\n플러터의 히어로 애니메이션은 화면 간에 시각적으로 매력적이고 맥락적으로 의미 있는 전환을 만드는 강력한 도구입니다. 기본 구조를 이해하고 간단한 코드 조각으로 히어로 애니메이션을 구현하면 앱의 사용자 경험을 크게 향상시킬 수 있습니다. 사진 갤러리, 전자상거래 플랫폼 또는 부드러운 전환을 통해 혜택을 얻는 어떤 앱이든 구축 중이라면 히어로 애니메이션은 게임 체인저가 될 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-21-MasteringHeroAnimationsinFlutterAComprehensiveGuide_0.png"},"coverImage":"/assets/img/2024-06-21-MasteringHeroAnimationsinFlutterAComprehensiveGuide_0.png","tag":["Tech"],"readingTime":6},{"title":"2024년 예비 개발자에게 Flutter를 꼭 배워야 하는 이유","description":"","date":"2024-06-21 21:09","slug":"2024-06-21-WhyLearningFlutterin2024isEssentialforAspiringDevelopers","content":"\n\n<img src=\"/assets/img/2024-06-21-WhyLearningFlutterin2024isEssentialforAspiringDevelopers_0.png\" />\n\n급변하는 기술 환경에서 앞서 나가는 것은 지망 개발자에게 필수적입니다. 현재 큰 인기를 끌고 있는 기술 중 하나는 Flutter입니다. Google에서 출시된 Flutter는 개발자가 단일 코드베이스에서 모바일, 웹 및 데스크톱용 네이티브 컴파일된 애플리케이션을 빌드할 수 있는 오픈 소스 UI 소프트웨어 개발 키트(SDK)입니다. 2024년을 맞아 Flutter 학습의 중요성은 전에 없던 만큼 뚜렷해졌습니다. 이 블로그에서는 Flutter가 지망 개발자의 학습 여정에서 중심에 있어야 하는 주요 이유에 대해 탐구합니다.\n\n## 현재 앱 개발 환경 개요\n\n앱 개발 산업은 크로스 플랫폼 솔루션으로의 패러다임 변화를 겪었습니다. 과거 iOS 및 Android를 위해 별도의 코드베이스를 작성해야 했던 시대는 지나갔습니다. 오늘날 기업은 빠른 전환 시간, 줄어든 비용, 다중 플랫폼에서의 원활한 성능을 요구합니다. 이러한 변화로 Flutter와 같은 크로스 플랫폼 프레임워크가 주목받게 되었습니다.\n\n<div class=\"content-ad\"></div>\n\n## 플러터 팩트\n\n플러터가 처음 출시된 이후 구글, 알리바바, 이베이를 포함한 많은 유명 회사들이 채택했습니다. 강력한 프레임워크와 열정적이고 지원적인 커뮤니티를 갖춘 플러터는 개발자들 사이에서 인기가 많습니다. 스택 오버플로의 개발자 설문 조사에 따르면, 플러터는 지속적으로 가장 선호되고 원하는 프레임워크 중 하나로 꼽히며, 인기와 광범위한 사용을 반영하고 있습니다.\n\n## 사람들이 묻는 질문: 플러터의 미래는 어떨까요?\n\n플러터의 미래는 매우 밝아 보입니다. 지속적인 업데이트와 구글의 강력한 지원으로 플러터는 앱 개발 분야에서 주요 역할을 계속할 것으로 예상됩니다. 최신 기술 트렌드를 따라갈 수 있는 능력이 플러터를 개발자들에게 계속해서 필요하고 가치 있는 도구로 만들 것임을 보장합니다.\n\n<div class=\"content-ad\"></div>\n\n🚀 플러터 스킬 수요가 늘어나는 이유, 크로스 플랫폼 개발의 혜택💻, 탁월한 성능, 강력한 커뮤니티 지원, 그리고 구글로부터 지속적인 향상🔄을 탐구해보세요.\n\n# 이유 1: 플러터 개발자에 대한 수요 상승\n\n플러터 개발자를 위한 취업 시장이 번창하고 있습니다. 플러터를 사용하는 혜택을 더 많은 기업들이 인지함에 따라, 이 프레임워크에 능숙한 개발자들에 대한 수요가 증가하고 있습니다.\n\n## 취업 시장 동향\n\n<div class=\"content-ad\"></div>\n\n\n![Job Board](/assets/img/2024-06-21-WhyLearningFlutterin2024isEssentialforAspiringDevelopers_1.png)\n\nFlutter 개발자를 찾는 기업이 늘어나고 있습니다. 각종 산업 분야의 기업들이 Flutter의 능력을 활용하여 고품질의 크로스 플랫폼 애플리케이션을 개발할 수 있는 개발자를 찾고 있습니다.\n\n## Flutter를 채택한 기업들\n\n![Companies Adopting Flutter](/assets/img/2024-06-21-WhyLearningFlutterin2024isEssentialforAspiringDevelopers_2.png)\n\n\n<div class=\"content-ad\"></div>\n\n대형 기술 기업부터 스타트업까지가 앱 개발에 Flutter를 채택하고 있어요. Google, Tencent, Philips와 같은 기업들은 Flutter를 활용하여 원할하고 효과적인 애플리케이션을 개발하고 있어요. 이 추세는 기업들이 Flutter에 대한 신뢰와 신빙성을 나타내며, 이 프레임워크에 능숙한 개발자에 대한 수요를 더욱 촉진하고 있어요.\n\n# 이유 2: 크로스 플랫폼 개발\n\nFlutter의 가장 큰 장점 중 하나는 크로스 플랫폼 개발을 용이하게 한다는 점이에요.\n\n![이미지](/assets/img/2024-06-21-WhyLearningFlutterin2024isEssentialforAspiringDevelopers_3.png)\n\n<div class=\"content-ad\"></div>\n\n## iOS와 안드로이드를 위한 단일 코드베이스\n\nFlutter를 사용하면 개발자들은 iOS와 안드로이드 모두에서 작동하는 단일 코드베이스를 작성할 수 있습니다. 이는 시간을 절약하는 뿐만 아니라 플랫폼 간 일관성을 보장합니다. 이제 더 이상 개발자들은 다른 운영 체제를 위한 별도의 코드베이스를 유지할 필요가 없으며, 이는 개발 프로세스를 보다 간소화하고 효율적으로 만듭니다.\n\n## 시간 및 비용 효율성\n\niOS와 안드로이드를 위한 별도의 애플리케이션을 개발하는 것은 시간이 많이 걸리고 비용이 많이 발생할 수 있습니다. Flutter의 크로스 플랫폼 기능을 통해 비즈니스는 개발 비용을 줄이고 시장 진입 시간을 단축할 수 있습니다. 이러한 효율성은 리소스를 최적화하려는 스타트업 및 기업에게 큰 변화를 가져다줍니다.\n\n<div class=\"content-ad\"></div>\n\n# 이유 3: 견고한 성능\n\n플러터의 아키텍처는 원본 애플리케이션과 견주어질 정도로 견고한 성능을 제공하도록 설계되었습니다.\n\n## 네이티브와 유사한 성능\n\n플러터 애플리케이션은 네이티브 ARM 코드로 직접 컴파일되어 iOS와 Android에서 높은 성능을 제공합니다. 이를 통해 플러터로 구축된 앱이 원활하고 효율적으로 실행되어 사용자에게 네이티브와 유사한 경험을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n## 빠른 렌더링 및 실행\n\nFlutter의 렌더링 엔진 Skia는 빠르고 반응적인 UI 렌더링을 가능하게 합니다. 또한 핫 리로딩과 같은 기능을 통해 실시간으로 변경 사항의 효과를 확인할 수 있어 개발자들이 더 효율적인 개발 프로세스와 빠른 반복 주기를 가질 수 있습니다.\n\n# 이유 4: 강력한 커뮤니티와 생태계\n\n강력하고 지원적인 커뮤니티는 어떠한 기술의 성장과 지속 가능성에 중요한 요소이며, Flutter도 예외가 아닙니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-21-WhyLearningFlutterin2024isEssentialforAspiringDevelopers_4.png\" />\n\n## 활기찬 개발자 커뮤니티\n\nFlutter는 활기찬 활발한 개발자 커뮤니티를 자랑합니다. 이 커뮤니티는 입문 개발자에게 귀중한 자원으로, 지원을 제공하고 지식을 공유하며 프레임워크의 지속적인 개선에 기여합니다. GitHub, Stack Overflow 및 다양한 Flutter 중심 포럼과 같은 플랫폼들은 서로 돕고 성공하기를 바라는 개발자들로 북적입니다.\n\n## 풍부한 라이브러리와 플러그인\n\n<div class=\"content-ad\"></div>\n\n플러터의 생태계는 라이브러리와 플러그인으로 풍부하며, 개발 프로세스를 크게 가속화시킬 수 있습니다. 복잡한 애니메이션을 구현하거나, 제3자 서비스를 통합하거나, 앱 기능을 향상시킬 필요가 있다면, 플러터 플러그인을 활용하여 빠르고 효율적으로 목표를 달성할 수 있습니다.\n\n# 이유 5: 지속적인 개선 및 지원\n\n플러터의 강점 중 하나는 Google의 지속적인 개선과 견고한 지원 기능입니다.\n\n## Google로부터의 정기적인 업데이트\n\n<div class=\"content-ad\"></div>\n\nGoogle이 Flutter에 대한 헌신은 정기적인 업데이트와 개선 사항을 통해 명확하게 드러납니다. 이러한 업데이트는 Flutter가 최신 기술 발전을 따라잡고 개발자들에게 최신 기능을 제공하는 것을 보장합니다.\n\n## 장기적인 지원과 성장 잠재력\n\nGoogle로부터 받는 Flutter의 장기적인 지원은 개발자들이 이 프레임워크를 자신 있게 배우고 리소스를 투자할 수 있음을 의미합니다. Flutter가 계속 성장하고 발전함에 따라, 오늘 기술을 습득한 개발자들은 미래 기회를 활용할 준비가 잘 된 상태에 있을 것입니다.\n\n# 자주 묻는 질문 (FAQs):\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-21-WhyLearningFlutterin2024isEssentialforAspiringDevelopers_5.png\" />\n\n## 1. Flutter이란 무엇인가요?\n\n답변: Flutter는 Google이 만든 오픈 소스 UI 소프트웨어 개발 키트(SDK)입니다. 이를 사용하면 모바일(iOS 및 Android), 웹 및 데스크톱용 네이티브 컴파일된 응용 프로그램을 단일 코드베이스에서 만들 수 있습니다.\n\n## 2. 2024년에 Flutter를 배워야 하는 이유?\n\n<div class=\"content-ad\"></div>\n\n답변: 2024년에 Flutter를 배우는 것은 그것의 인기 증가, 숙련된 Flutter 개발자에 대한 수요 증가, 크로스 플랫폼 기능, 강력한 성능, 강력한 커뮤니티 지원 및 Google의 지속적인 개선으로 인해 필수적입니다.\n\n## 3. Flutter가 크로스 플랫폼 개발을 어떻게 지원하나요?\n\n답변: Flutter를 사용하면 개발자들이 iOS, Android, 웹 및 데스크톱을 포함한 여러 플랫폼에 애플리케이션을 배포하기 위해 사용할 수있는 단일 코드베이스를 작성할 수 있습니다. 이 접근 방식은 일관된 성능 및 UI/UX를 보장하면서 시간과 자원을 절약합니다.\n\n## 4. Flutter는 초보자에게 적합한가요?\n\n<div class=\"content-ad\"></div>\n\n네, 플러터는 초보자 친화적입니다. 명확한 문서, 풍부한 라이브러리 및 지원하는 커뮤니티로 인해, 플러터는 모바일 및 웹 앱 개발에 처음으로 도전하는 개발자들에게 쉽게 접근할 수 있습니다.\n\n## 5. 플러터와 함께 사용되는 프로그래밍 언어는 무엇인가요?\n\n답변: 플러터는 구글에서 개발한 Dart 프로그래밍 언어를 사용합니다. Dart는 배우기 쉽고 JavaScript나 Java와 같은 인기 있는 프로그래밍 언어와 유사한 구문을 가지고 있습니다.\n\n## 6. 플러터 개발자의 경력 전망은 어떻게 되나요?\n\n<div class=\"content-ad\"></div>\n\n답변: 플러터 개발자의 경력 전망은 밝습니다. 더 많은 기업이 앱 개발을 위해 플러터를 채택함에 따라 숙련된 개발자에 대한 수요는 계속해서 증가하고 있습니다. 많은 기술 거장 및 스타트업 기업이 고품질의 크로스 플랫폼 애플리케이션을 구축하기 위해 플러터 개발자를 찾고 있습니다.\n\n## 7. 플러터는 웹 및 데스크톱 애플리케이션에 사용될 수 있나요?\n\n답변: 네, 플러터는 모바일 앱뿐만 아니라 웹 및 데스크톱 애플리케이션 개발에도 사용할 수 있습니다. 이러한 다양성은 각종 플랫폼에서 실행되는 애플리케이션을 만들고 싶은 개발자들에게 가치 있는 도구로 작용합니다.\n\n## 8. 플러터의 성능은 네이티브 앱과 비교했을 때 어떻게 됩니까?\n\n<div class=\"content-ad\"></div>\n\nFlutter 애플리케이션은 기본 ARM 코드로 직접 컴파일되기 때문에 네이티브와 유사한 성능을 제공합니다. 이로 인해 원활하고 효율적인 실행이 가능하며, 완전한 네이티브 앱과 견줄만한 성능을 제공합니다.\n\n## 9. Flutter는 어떤 지원과 커뮤니티를 가지고 있나요?\n\nFlutter는 계속해서 개선되는 데 기여하는 개발자들의 활기찬 활동적인 커뮤니티를 보유하고 있습니다. 문서, 포럼, GitHub 저장소 및 써드파티 라이브러리 및 플러그인과 같은 다양한 리소스들이 제공되어 개발 경험을 향상시킵니다.\n\n## 10. Google은 Flutter를 얼마나 자주 업데이트하나요?\n\n<div class=\"content-ad\"></div>\n\n답변: Flutter는 구글로부터 정기적인 업데이트를 받아 최신 기술 발전에 따라 업데이트되며 개발자들에게 최신 특징을 제공하도록 합니다. 이러한 업데이트는 구글의 Flutter의 장기적인 성장과 지원에 대한 약속을 반영하고 있습니다.\n\n# 결론\n\n## Flutter 학습의 이유 요약\n\n2024년에 Flutter를 학습하는 것은 많은 이점을 제공합니다. Flutter 개발자에 대한 수요의 증가, 프레임워크의 크로스 플랫폼 기능, 강력한 성능, 뛰어난 커뮤니티, 지속적인 개선 등이 결합되어 필수 기술로 인식되고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 학습 시작\n\n앱 개발의 경쟁력 있는 세계에서 앞서나가고 싶다면, 지금이 플러터 학습을 시작할 때가 없습니다. 당신이 경험 많은 개발자이든 초보자이든, 플러터를 마스터하면 고품질의 크로스 플랫폼 애플리케이션을 효율적으로 만들 수 있는 기술을 습득할 수 있습니다. 앱 개발의 미래를 받아들이고, 지금 바로 플러터 여정을 시작하세요!","ogImage":{"url":"/assets/img/2024-06-21-WhyLearningFlutterin2024isEssentialforAspiringDevelopers_0.png"},"coverImage":"/assets/img/2024-06-21-WhyLearningFlutterin2024isEssentialforAspiringDevelopers_0.png","tag":["Tech"],"readingTime":7},{"title":"Flutter에서 더 나은 오류 처리 방법  Error Stack 알아보기","description":"","date":"2024-06-21 21:07","slug":"2024-06-21-BetterErrorHandlingforFlutterErrorStack","content":"\n\n## 플러터용 모던 오류 처리 UI가 있습니다. 이로 인해 버그를 더 빨리 해결할 수 있습니다\n\n![이미지](/assets/img/2024-06-21-BetterErrorHandlingforFlutterErrorStack_0.png)\n\n이 중간 이야기에서, 단 한 줄의 코드로 오류 화면을 멋지고 현대적인 오류 처리 UI로 변환하는 새 패키지를 공유하겠습니다. 이 패키지는 Android, iOS, Linux, macOS, Windows 및 웹에서 작동합니다.\n\n# 플러터를 위한 에러 스택 소개 🎉\n\n<div class=\"content-ad\"></div>\n\npub.dev을 통해 이 패키지를 설치할 수 있어요. 공개 저장소는 GitHub에 호스팅돼요.\n\n## 에러 스택 설치하기\n\n아래 내용을 당신의 pubspec.yaml 파일에 추가하세요:\n\n```yaml\ndependencies:\n  error_stack: ^1.7.3\n```\n\n<div class=\"content-ad\"></div>\n\n혹시 Flutter를 사용하시나요?\n\nflutter pub add error_stack\n\n프로젝트에 의존성으로 추가되었는지 확인하려면 flutter pub get을 실행해보세요.\n\n# 에러 스택 초기화하기 🛠️\n\n<div class=\"content-ad\"></div>\n\n에러 스택을 사용하려면 아래 예제처럼 main.dart 파일에 ErrorStack.init();을 추가하십시오.\n\n```js\n// main.dart 파일에 에러 스택 추가\n...\nimport 'package:error_stack/error_stack.dart';\n\nvoid main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n  await ErrorStack.init(); // 에러 스택 초기화\n  runApp(MyApp());\n}\n```\n\n이제 에러 스택이 활성화되어 UI에서 발생하는 모든 오류를 캐치할 준비가 되었습니다. 테스트를 위해 에러를 시뮬레이션해 보겠습니다!\n\n```js\nimport 'package:flutter/material.dart';\n\nclass ErrorExampleWidget extends StatefulWidget {\n  \n  ErrorExampleWidget({super.key});\n\n  @override\n  createState() => _ErrorExampleWidgetState();\n}\n\nclass _ErrorExampleWidgetState extends State<ErrorExampleWidget> {\n\n  dynamic title = [];\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(\"에러 예제\")\n      ),\n      body: SafeArea(\n         child: Container(\n           child: Text(title), // 타이틀에 대한 Subtype이 String이 아닙니다 💣\n         ),\n      ),\n    );\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n에러 발생 예제 페이지(ErrorExamplePage)는 Text 위젯이 첫 번째 인수로 문자열만 허용하기 때문에 오류가 발생할 것입니다.\n\n앱에서 이 위젯을 사용하려고 하면 에러 스택(Error Stack)이 나타납니다.\n\n<img src=\"/assets/img/2024-06-21-BetterErrorHandlingforFlutterErrorStack_1.png\" />\n\n# 주요 기능 🚀\n\n<div class=\"content-ad\"></div>\n\n- 웹 UI에서의 빠른 구글 검색을 통해 오류 해결\n- 오류 메시지를 클립보드에 복사\n- 라이트 모드 및 다크 모드 지원\n- 디버그 및 릴리스 모드 오류 화면\n- 릴리스 모드를 위한 사용자 정의 오류 페이지\n\n![이미지](/assets/img/2024-06-21-BetterErrorHandlingforFlutterErrorStack_2.png)\n\n## 빠른 구글 검색\n\n내가 좋아하는 기능은 오류를 즉시 구글에서 검색할 수 있는 기능입니다. \"이 오류로 구글에서 검색\"을 탭하면 바로 검색 페이지로 이동하여 오류를 해결하는 방법을 배울 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 앱 재시작\n\n다른 유용한 기능은 디버그 모드에서 앱을 다시 시작할 수 있는 기능입니다. 이는 앱을 수동으로 종료하고 다시 빌드할 필요가 없다는 뜻입니다.\n\n## 릴리스 모드 UI\n\n릴리스 모드에서 앱이 충돌하는 경우, 오류 스택은 사용자에게 다른 UI를 표시할 것입니다. 그러나 사용자 정의 UI를 사용하고 싶다면, 아래 예시처럼 init 메서드에 errorWidget을 추가하십시오.\n\n<div class=\"content-ad\"></div>\n\n```js\nawait ErrorStack.init(\n  errorWidget: (errorDetails) => MaterialApp(\n    home: Scaffold(\n      body: Center(\n        child: Text(\"An error occurred\"),\n      ),\n    ),\n  )\n);\n```\n\n# 마무리하며\n\n이번 미디엄 스토리가 유익했기를 바랍니다! Error Stack을 개발하는 것이 정말 재미있었는데, 더 나은 기능을 추가할 아이디어를 이미 몇 가지 생각해 두었습니다.\n\n만약 궁금하시다면 GitHub의 공개 저장소에서 내부 동작을 확인해볼 수 있습니다. 여러분의 프로젝트에서 시도해보고 피드백을 보내주세요.\n\n<div class=\"content-ad\"></div>\n\n위 문서를 읽어 주셔서 감사합니다.\n\n안토니 고든\n\nhttps://linktr.ee/agordn","ogImage":{"url":"/assets/img/2024-06-21-BetterErrorHandlingforFlutterErrorStack_0.png"},"coverImage":"/assets/img/2024-06-21-BetterErrorHandlingforFlutterErrorStack_0.png","tag":["Tech"],"readingTime":3},{"title":"Flutter로 크로스 플랫폼 앱을 만드는 방법","description":"","date":"2024-06-21 21:06","slug":"2024-06-21-HowToUseFlutterforBuildingCross-PlatformApps","content":"\n\n구글은 기술 산업에서 많은 혁신을 이끌어 온 주요한 역할을 해왔어요. 그중 하나가 플러터(Flutter)라는 강력한 프레임워크인데, 개발자들 사이에서 폭넓게 인기를 얻고 있어요. 플러터는 크로스 플랫폼 앱 개발을 용이하게 해주는 능력으로 특히 유명해요. 그리고 더욱 흥미로운 점은 플러터가 이제 웹 개발까지 지원하며, 개발자들이 단일 코드베이스를 사용해 크로스 플랫폼 웹 앱을 만들 수 있다는 것이에요. 이 글에서는 플러터의 크로스 플랫폼 앱 개발에 사용되는 장점을 탐색하고, 웹 개발을 위해 플러터로 시작하는 단계별 안내를 제공할 거에요.\n\n# 플러터를 사용한 크로스 플랫폼 앱의 장점\n\n단일 코드베이스: 플러터의 가장 큰 장점 중 하나는 코드를 한 번 작성하면 iOS, Android 및 웹에서 원활하게 배포할 수 있는 크로스 플랫폼 앱 개발을 가능하게 한다는 것이에요. 이는 코드를 한 번만 작성하고 iOS, Android 및 웹에 쉽게 배포할 수 있어 소중한 시간과 노력을 아낄 수 있게 해줘요.\n빠른 개발: Flutter는 Hot Reload라는 기능을 제공하는데, 이를 통해 개발자들은 편집을 할 때 즉시 실시간 변경 사항을 볼 수 있어요. 이는 개발 과정을 크게 가속화하여 생산성을 향상시킵니다. 개발자들은 손쉽게 앱을 세밀하게 조정할 수 있어요.\n아름다운 반응형 UI: Flutter는 사용자 인터페이스를 구축하기 위한 선언적인 방법을 제공하며 다양한 사용자 지정 위젯과 UI 요소를 제공해요. 이를 통해 다양한 플랫폼에서 네이티브 같은 경험을 제공하는 멋진 반응형 디자인을 쉽게 만들 수 있어요.\n네이티브 성능: Flutter 앱은 네이티브 코드로 컴파일되어 고성능을 보장해요. Skia 그래픽 라이브러리를 활용하여 Flutter는 부드러운 애니메이션과 빠른 렌더링을 가능하게 하며, 시각적으로 매력적인 것 뿐만 아니라 고성능의 앱을 제공해줘요.\n네이티브 기능 및 API에 액세스: Flutter는 개발자들에게 네이티브 기능과 API에 직접 액세스 권한을 부여해요. 디바이스 센서, 카메라, 위치 서비스 또는 플랫폼별 API에 액세스해야 할 때, Flutter는 프레임워크와 네이티브 기능 간의 간극을 메우는 플러그인을 제공해요.\n\n# 웹 개발을 위해 플러터로 시작하기:\n\n<div class=\"content-ad\"></div>\n\n이제 Flutter의 크로스 플랫폼 앱을 위한 장점을 탐색했으니, Flutter 웹 개발을 시작하는 방법에 대해 알아봅시다.\nFlutter 설치: 먼저 시스템에 Flutter SDK를 설치하여 시작하세요. 여러 운영 체제에 대한 자세한 설치 지침은 Flutter 공식 웹사이트에서 확인할 수 있습니다. 터미널에서 Flutter의 명령줄 도구에 어디서든 접근할 수 있도록 필요한 환경 변수를 설정해 주세요.\nIDE 설정: Flutter 개발을 지원하는 통합 개발 환경(IDE)을 선택해주세요. 인기 있는 옵션은 Flutter 익스텐션을 지원하는 Visual Studio Code, Android Studio 또는 Flutter 플러그인을 가진 IntelliJ IDEA 등이 있습니다. 원하는 IDE를 설치하고 Flutter 개발을 위해 구성하세요.\n새로운 Flutter 프로젝트 생성: 터미널이나 명령 프롬프트를 열고 Flutter의 명령줄 도구를 사용하여 새로운 Flutter 프로젝트를 생성하세요. 다음 명령을 실행하세요: flutter create my_web_app, my_web_app은 원하는 프로젝트 이름으로 대체해주세요. 이 명령은 기본 프로젝트 구조와 필요한 파일을 생성합니다.\n프로젝트 실행: 터미널이나 명령 프롬프트를 사용하여 프로젝트 디렉토리로 이동하고 다음 명령을 사용하여 프로젝트를 실행하세요: cd my_web_app 다음으로 flutter run -d chrome. 이 명령은 Flutter 웹 앱을 구글 크롬에서 실행합니다. 원하는 브라우저로 \"크롬\"을 대체할 수 있습니다.\n개발 시작: 앱이 실행 중이면 lib/main.dart 파일을 수정하여 Flutter 웹 앱을 개발을 시작하세요. 이 파일은 앱의 주 진입점으로 기능합니다. Flutter의 위젯 기반 아키텍처를 활용하여 사용자 인터페이스를 작성하고 상호 작용을 처리하며 상태를 관리하세요.\n\n## Flutter 웹 개발의 미래:\n\nFlutter의 웹 개발로의 확장은 크로스 플랫폼 앱 개발에 흥미로운 가능성을 열었습니다. Flutter를 사용하면 개발자들은 동일한 코드베이스로 네이티브 경험과 유사한 고품질 웹 앱을 만들 수 있습니다.\nFlutter 웹 개발의 미래는 더 많은 모험을 약속합니다. Flutter 팀과 활기찬 개발자 커뮤니티는 계속해서 Flutter의 웹 기능을 개선하고 최적화하여 새로운 기능, 향상된 성능 및 더 나은 툴 지원을 제공합니다. Flutter 생태계는 번창하며 웹 개발에 맞춘 ​​새로운 패키지와 리소스의 수가 증가하고 있습니다.\n\nFlutter가 웹에 대해 성숙해질수록 더 많은 기업과 개발자들이 이 프레임워크를 교차 플랫폼 웹 앱 구축의 기본 선택지로 채택할 것으로 예상됩니다. Flutter의 아름다운 UI 제공, 우수한 성능 및 다중 플랫폼에서 코드 재사용의 능력은 현재와 미래를 고려한 웹 개발에 매력적인 선택지로 만들어줍니다. 결론적으로, Flutter는 교차 플랫폼 앱 개발의 새로운 시대를 열었으며 웹 개발에 완벽하게 통합되어 앱 제작의 미래를 형성할 준비가 되어 있습니다. 숙련된 개발자이든 초심자이든 Flutter는 여러 플랫폼에서 쉽게 앱 아이디어를 현실로 만들기 위한 도구와 능력을 제공합니다.","ogImage":{"url":"/assets/img/2024-06-21-HowToUseFlutterforBuildingCross-PlatformApps_0.png"},"coverImage":"/assets/img/2024-06-21-HowToUseFlutterforBuildingCross-PlatformApps_0.png","tag":["Tech"],"readingTime":3},{"title":"Flutter 웹의 혁신적인 새로운 기능 게임 체인저 ","description":"","date":"2024-06-21 21:05","slug":"2024-06-21-FlutterWebNewFeatureGameChanger","content":"\n\nFlutter WebAssembly: 빠른 웹 앱 만들기\n\n모바일 네이티브 앱처럼 부드럽고 반응성 있는 웹 앱을 원한 적이 있나요? 플러터(WebAssembly와 함께 여러분의 꿈을 현실로 만듭니다!\n\nWebAssembly란?\n\n웹 브라우저가 복잡한 작업을 빠르게 처리할 수 있도록 하는 특별한 코드 형식을 상상해보세요. 그것이 바로 WebAssembly입니다. 이것은 C++과 같은 언어를 웹에서 컴파일하고 실행하여 네이티브 앱과 유사한 성능을 달성할 수 있게 합니다.\n\n<div class=\"content-ad\"></div>\n\n플러터와 웹어셈블리를 함께 사용하는 이유는 무엇일까요?\n\n플러터는 이미 모바일과 데스크탑에서 빠르고 아름다운 UI로 유명합니다. 이제 웹어셈블리를 사용하여 웹 프로젝트에 동일한 속도를 제공할 수 있습니다! 이는 다음을 의미합니다:\n\n- 빠른 성능: 웹어셈블리를 통해 그래픽이 많거나 복잡한 계산이 필요한 웹 앱도 원활하게 실행됩니다.\n- 한 번 작성하고 모든 곳에서 실행: 모바일, 웹, 데스크톱용 단일 코드베이스로 앱을 개발할 수 있습니다.\n- 빠른 개발: 플러터의 핫 리로드를 통해 변경 사항을 즉시 확인할 수 있습니다.\n- 미래를 대비: 웹어셈블리가 지원되어 계속 사용됨으로써 앞으로 뭐가 될지에 대비할 수 있습니다.\n\n시작하기\n\n<div class=\"content-ad\"></div>\n\n시작해볼 준비가 되셨나요? 아래에 간단한 개요가 있어요:\n\n- Flutter 설치: 컴퓨터에 최신 버전이 설치되어 있는지 확인해보세요.\n- 프로젝트 생성: Flutter 명령줄 도구를 사용하여 새 프로젝트를 시작하세요.\n- WebAssembly 구성: 구성 파일에서 WebAssembly을 타겟팅하도록 프로젝트를 설정하세요.\n- 빌드 및 배포: 웹용으로 프로젝트를 빌드하고 웹 서버에 배포하세요.\n\n함께 무언가를 만들어 봐요!\n\n버튼을 누른 횟수를 계속 추적하는 간단한 카운터 앱을 상상해보세요. 이것이 Flutter와 WebAssembly로 만들어진 앱이 보일 것입니다:\n\n<div class=\"content-ad\"></div>\n\n- 새 프로젝트 만들기: Flutter CLI를 사용하여 새 프로젝트를 만듭니다.\n- 코드 작성: 코드는 카운터 변수를 만들고 탭할 때 카운터가 증가하는 버튼을 만드는 과정을 포함할 것입니다.\n- 빌드 및 배포: 위 단계를 따라 앱을 웹에 빌드하고 배포합니다.\n\n미래는 빠릅니다\n\n플러터와 WebAssembly는 웹 개발을 변화시키는 혁신적인 기술입니다. 이러한 기술이 발전함에 따라 더 빠르고 강력한 웹 앱을 기대할 수 있습니다. 그래서 무엇을 기다리고 있나요? 지금 플러터와 WebAssembly로 빠른 웹 앱을 만들기 시작해 보세요!\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/0*DoLvv_b5xizTNwA2.gif\" />","ogImage":{"url":"/assets/img/2024-06-21-FlutterWebNewFeatureGameChanger_0.png"},"coverImage":"/assets/img/2024-06-21-FlutterWebNewFeatureGameChanger_0.png","tag":["Tech"],"readingTime":2},{"title":"Flutter에서 InheritedWidget 사용하기 간단한 카운터 예제","description":"","date":"2024-06-21 21:03","slug":"2024-06-21-UsingInheritedWidgetinFlutterASimpleCounterExample","content":"\n![사진](/assets/img/2024-06-21-UsingInheritedWidgetinFlutterASimpleCounterExample_0.png)\n\n플러터에서 상태를 관리하는 것은 어렵지만, 특히 여러 위젯 간에 데이터를 공유해야 할 때 더 어려울 수 있습니다. InheritedWidget은 이 문제를 해결하는 데 도움이 되는 플러터의 강력한 기능으로, 위젯이 공유된 데이터에 효율적으로 액세스할 수 있도록 합니다. 이 글에서는 간단한 카운터 예제와 함께 InheritedWidget을 어떻게 사용하는지 살펴보겠습니다.\n\n단계 1: Inherited Widget 생성\n\n먼저, AppState라는 InheritedWidget을 만들겠습니다. 이 위젯은 공유 상태(이 경우 카운터)를 보유하고 이를 하위 항목에 제공할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport 'package:flutter/material.dart';\n\nclass AppState extends InheritedWidget {\n  final int counter;\n  final Widget child;\n\n  AppState({\n    required this.counter,\n    required this.child,\n  }) : super(child: child);\n\n  static AppState? of(BuildContext context) {\n    return context.dependOnInheritedWidgetOfExactType<AppState>();\n  }\n\n  @override\n  bool updateShouldNotify(AppState oldWidget) {\n    return oldWidget.counter != counter;\n  }\n}\n```\n\nAppState 클래스에서:\n\n- counter와 child를 초기화하는 생성자를 정의합니다.\n- of 메서드는 하위 위젯이 AppState에 액세스할 수 있도록 합니다.\n- updateShouldNotify 메서드는 하위 항목에 변경 사항을 알리는 시점을 결정합니다.\n\n단계 2: State를 관리하는 StatefulWidget 생성\n\n<div class=\"content-ad\"></div>\n\n다음으로 상태를 관리하는 StatefulWidget 인 MyApp을 만들겠습니다. 이 위젯은 상태를 업데이트하고 필요할 때 다시 빌드를 트리거할 것입니다.\n\n```js\nclass MyApp extends StatefulWidget {\n  @override\n  _MyAppState createState() => _MyAppState();\n}\n\nclass _MyAppState extends State<MyApp> {\n  int _counter = 0;\n\n  void _incrementCounter() {\n    setState(() {\n      _counter++;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return AppState(\n      counter: _counter,\n      child: MaterialApp(\n        home: Scaffold(\n          appBar: AppBar(\n            title: Text('Inherited Widget demo'),\n          ),\n          body: CounterDisplay(),\n          floatingActionButton: FloatingActionButton(\n            onPressed: _incrementCounter,\n            child: Icon(Icons.add),\n          ),\n        ),\n      ),\n    );\n  }\n}\n```\n\n단계 3: Inherited Widget을 사용하는 위젯 생성\n\n마지막으로, 우리는 InheritedWidget을 사용하여 카운터 값을 액세스하고 표시하는 CounterDisplay라는 StatelessWidget을 만들 것입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nclass CounterDisplay extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    final appState = AppState.of(context);\n\n    return Center(\n      child: Text(\n        'Counter: ${appState?.counter}',\n        style: TextStyle(fontSize: 22),\n      ),\n    );\n  }\n}\n```\n\nCounterDisplay 클래스에서:\n\n- AppState를 액세스하고 카운터 값을 검색하려면 of 메서드를 사용합니다.\n- Text 위젯에 카운터 값을 표시합니다.\n\n이 코드를 실행해 봅시다.\n\n<div class=\"content-ad\"></div>\n\n앱을 실행하려면 MyApp을 인수로 사용하여 runApp 함수를 호출하겠습니다.\n\n```js\nvoid main() => runApp(MyApp());\n```\n","ogImage":{"url":"/assets/img/2024-06-21-UsingInheritedWidgetinFlutterASimpleCounterExample_0.png"},"coverImage":"/assets/img/2024-06-21-UsingInheritedWidgetinFlutterASimpleCounterExample_0.png","tag":["Tech"],"readingTime":3},{"title":"Flutter  Firebase로 푸시 알림 구현하는 완벽 가이드","description":"","date":"2024-06-21 21:01","slug":"2024-06-21-FlutterFirebasePushNotificationsCompleteGuide","content":"\n<img src=\"/assets/img/2024-06-21-FlutterFirebasePushNotificationsCompleteGuide_0.png\" />\n\n# 푸시 알림이란 무엇인가요?\n\n푸시 알림은 모바일 앱이나 웹사이트에서 기기로 보내는 메시지로, 기기가 활발하게 사용되지 않는 경우에도 전송됩니다. 일반적으로 사용자에게 새로운 콘텐츠나 기능을 알리거나 관심이 있을 수 있는 내용을 상기시키기 위해 사용됩니다.\n\n# 모바일 앱 개발에서 푸시 알림의 장점은 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n- 사용자 참여 향상: 푸시 알림을 통해 사용자가 앱에 계속해서 참여하도록 유도할 수 있습니다. 사용자가 앱을 활발하게 사용하지 않을 때에도 이를 통해 전반적인 앱 사용량과 인기를 증가시킬 수 있습니다.\n- 유지율 증가: 푸시 알림을 통해 사용자에게 앱을 상기시킬 수 있어, 유지율을 높이고 앱을 제거하는 사용자 수를 줄일 수 있습니다.\n- 타겟팅 메시징: 푸시 알림은 사용자의 관심사나 행동을 기반으로 특정 사용자나 그룹을 대상으로 할 수 있습니다. 이를 통해 앱 개발자는 사용자에게 개인화되고 관련성 높은 메시지를 보낼 수 있어 알림의 효과를 높일 수 있습니다.\n- 수익 증대: 푸시 알림을 통해 인앱 구매나 기타 수익화 기회를 홍보할 수 있어, 앱 개발자의 수익을 향상시킬 수 있습니다.\n- 고객 서비스 향상: 푸시 알림을 통해 업데이트나 경고와 같은 시기적절하고 관련성 있는 정보를 제공할 수 있습니다. 이를 통해 전반적인 고객 경험과 앱에 대한 만족도를 향상시킬 수 있습니다.\n\n# Firebase Cloud Messaging (FCM)이란?\n\n![이미지](/assets/img/2024-06-21-FlutterFirebasePushNotificationsCompleteGuide_1.png)\n\nFirebase에 따르면, FCM은 무료로 메시지를 신뢰할 수 있게 전송할 수 있는 크로스 플랫폼 메시징 솔루션이라고 합니다.\n\n<div class=\"content-ad\"></div>\n\nFCM은 Android, iOS 및 웹 사용자에게 메시지와 알림을 보낼 수 있는 크로스 플랫폼 메시징 솔루션입니다. 구글은 FCM을 Firebase 스위트의 일부로 제공하여 모바일 앱 개발을 위한 도구 및 서비스를 제공합니다.\n\nFCM을 사용하면 사용자 관심사, 앱 사용 방식 및 위치에 따라 특정 기기 또는 기기 그룹에 메시지를 보낼 수 있습니다. 알림, 푸시 알림 및 데이터 페이로드를 포함한 다양한 유형의 메시지를 보낼 수 있습니다. FCM은 또한 메시지 예약, 기기 그룹 관리 및 분석과 같은 기능을 제공합니다.\n\nFCM은 기존 앱 인프라와 쉽게 통합되고 사용하기 쉽게 설계되었습니다. 간단한 API를 사용하며 Firebase Analytics와 같은 다른 Firebase 서비스와 통합하여 모바일 앱 개발을 위한 포괄적인 도구 세트를 제공합니다.\n\n# 플러터 앱에서 Firebase FCM을 통해 푸시 알림을 수신하는 방법 — 구현\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-21-FlutterFirebasePushNotificationsCompleteGuide_2.png)\n\n플러터와 FCM에서 3가지 디바이스 상태\n\n- Foreground(전경): 어플리케이션이 열려 있고 보여지며 사용 중일 때입니다.\n- Background(최소화): 사용자가 장치에서 \"홈\" 버튼을 누르거나 앱 전환기를 통해 다른 앱으로 전환하거나 다른 탭(웹)에서 앱을 열었을 때 보통 발생합니다.\n- Terminated(종료됨): 장치가 잠겨 있거나 어플리케이션이 실행되지 않을 때입니다. 사용자는 장치의 앱 전환기 UI를 통해 앱을 닫거나 탭(웹)을 닫아 어플리케이션을 종료할 수 있습니다.\n\n이 프로세스가 어떻게 작동하는지 보려면 이 동영상을 시청해보세요.\n\n<div class=\"content-ad\"></div>\n\n구현 단계\n\n- CMD에서\n\n- Node.js를 다운로드 및 설치하십시오. https://nodejs.org/en/\n- firebase 도구 설치: npm install -g firebase-tools (CMD)\n- \"firebase login\"을 실행하고 Google 계정을 선택하십시오 (CMD)\n\n2. 플러터 프로젝트 터미널에서\n\n<div class=\"content-ad\"></div>\n\n- 그런 다음 플러터 프로젝트를 열고 터미널에서 다음 명령을 실행하세요\n- dart pub global activate flutterfire_cli\n- flutterfire configure (만약 이 명령이 \"flutterfire가 인식되지 않습니다.\"와 같은 오류를 발생시킨다면, 시스템 환경 변수에 \"C:\\Users\\*사용자명\\*\\AppData\\Local\\Pub\\Cache\\bin\"을 새 항목으로 추가해야 합니다. 이제 오류 없이 명령을 실행할 수 있어야 합니다.)\n\n3. Firebase 콘솔에서\n\n- 새 Firebase 프로젝트를 생성하고 Firebase FCM(메시징/클라우드 메시징으로도 알려짐)를 활성화하세요.\n\n4. 그런 다음 플러터 프로젝트의 main.dart에 다음 종속성을 추가하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\n// 의존성\nimport \"package:firebase_core/firebase_core.dart\";\nimport \"/firebase_options.dart\"; // 이 파일은 \"flutterfire config\" 명령어로 생성됩니다.\nimport \"package:firebase_messaging/firebase_messaging.dart\";\n```\n\n5. 이제 main.dart에 다음 라인을 추가하여 Firebase Messaging을 초기화합니다.\n\n```js\n// 초기화\nWidgetsFlutterBinding.ensureInitialized();\n\nawait Firebase.initializeApp(\n  options: DefaultFirebaseOptions.currentPlatform,\n);\n\nFirebaseMessaging messaging = FirebaseMessaging.instance;\n\nNotificationSettings settings = await messaging.requestPermission(\n  alert: true,\n  announcement: false,\n  badge: true,\n  carPlay: false,\n  criticalAlert: false,\n  provisional: false,\n  sound: true,\n);\n\nprint('사용자가 허용한 권한: ${settings.authorizationStatus}');\n```\n\n6. 이제 main.dart에 다음 라인을 추가하여 \"백그라운드 메시지\"를 받습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// 백그라운드 메시지 수신\nFuture<void> _firebaseMessagingBackgroundHandler(RemoteMessage message) async {\n  await Firebase.initializeApp();\n  print(\"백그라운드 메시지 처리 중: ${message.messageId}\");\n}\n```\n\n```js\n// 백그라운드 메시지 수신 대기\nWidgetsFlutterBinding.ensureInitialized();\nFirebaseMessaging.onBackgroundMessage(_firebaseMessagingBackgroundHandler);\n```\n\n7. 그런 다음 main.dart에 다음 줄을 추가하여 \"전경 메시지\"를 받습니다.\n\n```js\n// 전경 메시지 수신\nFirebaseMessaging.onMessage.listen((RemoteMessage message) {\n  print('전경에서 메시지를 받았어요!');\n  print('메시지 데이터: ${message.data}');\n\n  if (message.notification != null) {\n    print('메시지에 알림도 포함되어 있어요: ${message.notification}');\n  }\n});\n```\n\n<div class=\"content-ad\"></div>\n\n# 중요\n\n- (공통):\n- 클라우드 메시징 패키지는 애플리케이션을 Firebase Cloud Messaging (FCM) 서비스에 연결합니다.\n- 메시지 페이로드를 무료로 디바이스로 직접 보낼 수 있습니다.\n- 각 메시지 페이로드는 최대 4KB까지 가능합니다.\n- (iOS 전용):\n- iOS 플랫폼에서 Firebase 메시징을 테스트하려면 실제 디바이스가 필요합니다.\n\n# 받을 수 있는 3가지 메시지 유형\n\n메시지 페이로드를 세 가지 유형 중 하나로 볼 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n- 알림 전용 메시지: 페이로드에는 사용자에게 표시되는 알림 속성이 포함되어 있습니다.\n- 데이터 전용 메시지: \"silent message\"로도 알려진 이 페이로드에는 데이터 속성 내에 사용자가 필요에 따라 사용할 수 있는 사용자 정의 키/값 쌍이 포함되어 있습니다. 이러한 메시지는 \"우선 순위가 낮음\"으로 간주됩니다(나중에 더 자세히 설명합니다).\n- 알림 및 데이터 메시지: 알림 및 데이터 속성을 모두 포함하는 페이로드입니다.\n\n# 상호 작용 처리\n\n알림은 사용자에게 보이는 신호이므로 사용자가 해당 신호에 상호 작용하는 것이 일반적입니다(눌러서). Android 및 iOS 모두의 기본 동작은 애플리케이션을 열도록 하는 것입니다. 애플리케이션이 종료된 경우 시작되고, 백그라운드 상태인 경우 화면으로 가져옵니다.\n\n알림의 내용에 따라 애플리케이션이 열릴 때 사용자 상호 작용을 처리하고 싶을 수 있습니다. 예를 들어, 알림을 통해 새로운 채팅 메시지가 전송되고 사용자가 그것을 누른 경우, 애플리케이션이 열릴 때 특정 대화를 열도록 하고 싶을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nfirebase-messaging 패키지는 이 상호작용을 다루는 두 가지 방법을 제공합니다:\n\n- getInitialMessage(): 애플리케이션이 종료된 상태에서 열리면 RemoteMessage가 포함된 Future가 반환됩니다. RemoteMessage를 사용하면 해당 메시지는 제거됩니다.\n- onMessageOpenedApp: 백그라운드 상태에서 애플리케이션이 열릴 때 RemoteMessage를 게시하는 Stream입니다.\n\n사용자에 대한 원활한 사용자 경험을 위해 두 시나리오를 모두 처리하는 것이 좋습니다. 아래의 코드 예시는 이를 어떻게 달성할 수 있는지 보여줍니다:\n\n```js\nclass Application extends StatefulWidget {\n  @override\n  State<StatefulWidget> createState() => _Application();\n}\n\nclass _Application extends State<Application> {\n  // 모든 메시지에 'type' 키를 포함하는 데이터 필드가 있다고 가정합니다.\n  Future<void> setupInteractedMessage() async {\n    // 애플리케이션이 종료된 상태에서 열린 이유가 된 메시지를 가져옵니다.\n    RemoteMessage? initialMessage =\n        await FirebaseMessaging.instance.getInitialMessage();\n\n    // 메시지가 'type'이 'chat'인 데이터 속성도 포함하고 있다면\n    // 채팅 화면으로 이동합니다.\n    if (initialMessage != null) {\n      _handleMessage(initialMessage);\n    }\n\n    // 애플리케이션이 백그라운드에 있을 때 상호작용을 다루기 위해\n    // Stream 리스너를 통해 처리합니다.\n    FirebaseMessaging.onMessageOpenedApp.listen(_handleMessage);\n  }\n\n  void _handleMessage(RemoteMessage message) {\n    if (message.data['type'] == 'chat') {\n      Navigator.pushNamed(context, '/chat',\n        arguments: ChatArguments(message),\n      );\n    }\n  }\n\n  @override\n  void initState() {\n    super.initState();\n\n    // initState()이 비동기일 수 없기 때문에 상호작용하는 메시지를 다루는\n    // 코드를 비동기 함수에서 실행합니다.\n    setupInteractedMessage();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Text(\"...\");\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n# 특정 화면으로 이동하는 방법\n\n```js\nvoid _handleMessage(RemoteMessage message) {\n    // 메시지 객체 내용 확인\n    RemoteNotification? notification = message.notification;\n    //AndroidNotification? android = message.notification?.android;\n\n    print(\"notification: $notification\");\n    print(\"message data: ${message.data}\");\n\n    Get.toNamed(Routes.getNotificationDetailScreen(), arguments: [\n      {\"message\": message}\n    ]);\n}\n\n// 상호 작용 처리\nFirebaseMessaging.onMessageOpenedApp.listen(_handleMessage);\n```\n\n![이미지 1](/assets/img/2024-06-21-FlutterFirebasePushNotificationsCompleteGuide_3.png)\n\n![이미지 2](/assets/img/2024-06-21-FlutterFirebasePushNotificationsCompleteGuide_4.png)\n\n<div class=\"content-ad\"></div>\n\n## 참고 자료:\n\n- https://www.youtube.com/watch?v=3lsP1jZNqjE\n- https://stackoverflow.com/questions/70320263/the-term-flutterfire-is-not-recognized-as-the-name-of-a-cmdlet-function-scri\n- https://firebase.flutter.dev/docs/cli/\n- https://firebase.google.com/docs/cli#install-cli-windows\n- https://firebase.flutter.dev/docs/overview/\n- https://medium.com/@rysesoft/flutter-push-notification-with-fcm-6e7a95f5abb6\n- https://firebase.flutter.dev/docs/messaging/apple-integration/\n- https://www.youtube.com/watch?v=54vgoPgB8xE\n- https://pub.dev/packages/flutterfire_cli/install\n- https://pub.dev/packages/firebase_core/install\n- https://www.youtube.com/watch?v=2tjuUwNx6qk\n- https://firebase.flutter.dev/docs/messaging/usage/\n- https://medium.com/firebase-developers/flutter-fcm-how-to-navigate-to-a-particular-screen-after-tapping-on-push-notification-8cb5d5111ee6\n- https://pub.dev/packages/flutter_local_notifications\n- https://firebase.flutter.dev/docs/messaging/usage/\n- https://pub.dev/documentation/firebase_messaging_platform_interface/latest/firebase_messaging_platform_interface/RemoteMessage-class.html\n- https://firebase.google.com/docs/cloud-messaging/flutter/receive\n","ogImage":{"url":"/assets/img/2024-06-21-FlutterFirebasePushNotificationsCompleteGuide_0.png"},"coverImage":"/assets/img/2024-06-21-FlutterFirebasePushNotificationsCompleteGuide_0.png","tag":["Tech"],"readingTime":9},{"title":"Flutter는 2024년에도 살아남을까 크로스플랫폼 개발의 미래","description":"","date":"2024-06-21 20:59","slug":"2024-06-21-IsFlutterDyingin2024FutureofCross-PlatformDevelopment","content":"\n\n<img src=\"/assets/img/2024-06-21-IsFlutterDyingin2024FutureofCross-PlatformDevelopment_0.png\" />\n\n2024년에 플러터가 관련성을 잃고 있는 걸까요? 코틀린 멀티플랫폼, 리액트 네이티브, 퀘이사르 프레임워크, 네이티브스크립트와 비교해보세요.\n\n# 소개\n\n2017년 출시 이후, 구글의 오픈소스 UI 소프트웨어 개발 툴킷인 플러터는 크로스 플랫폼 개발 분야에서 주목받는 역할을 해왔습니다. 개발자들이 단일 코드베이스로 모바일, 웹 및 데스크톱용으로 네이티브 애플리케이션을 만들 수 있게 합니다. 그러나 크로스 플랫폼 개발 프레임워크의 변화하는 풍경과 증가하는 경쟁으로 인해, 2024년에 플러터의 관련성과 지속 가능성에 대한 의문이 제기됩니다. 이 기사는 플러터의 상태, 코틀린 멀티플랫폼, 리액트 네이티브, 퀘이사르 프레임워크, 네이티브스크립트와 구글의 플러터에 대한 미래로드맵에 대해 탐구합니다.\n\n<div class=\"content-ad\"></div>\n\n# 플러터의 부상\n\n플러터는 고성능 렌더링 엔진, 풍부한 사전 디자인 위젯 세트 및 튼튼한 개발자 도구로 인해 빠르게 주목을 받았습니다. iOS와 Android에서 네이티브와 유사한 성능과 외관을 제공하는 능력으로, 개발자들 사이에서 인기 있는 선택지로 자리매김하였습니다. 알리바바, 구글 애즈, BMW와 같은 주요 기업들이 채택함으로써 플러터의 잠재력과 다재다능성을 강조하였습니다.\n\n# 현재의 플러터 상태\n\n2024년 현재, 플러터는 크로스 플랫폼 개발 시장에서 중요한 역할을 하고 있습니다. 그러나 환경은 매우 동적이며, 중요한 것은 지속적인 혁신과 커뮤니티 지원으로 영향력을 유지하는 것입니다. 플러터의 현재 상태를 살펴보기 위해서는 GitHub에서의 활동을 살펴봄으로써 커뮤니티 참여와 진행 중인 개발의 주요 지표를 파악할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## GitHub Metrics\n\n- Stars: 2024년 중반 기준으로 Flutter는 GitHub에서 15만 개 이상의 스타를 획득했습니다. 이 지표는 해당 프레임워크가 개발자들 사이에서 널리 사용되고 인기를 얻고 있다는 것을 보여줍니다.\n- Commits: Flutter는 지난 몇 년 동안 수천 건의 기여를 받으며 꾸준한 커밋을 계속하고 있습니다. 이는 활발한 개발과 지속적인 향상을 나타냅니다.\n- Issues 및 Pull Requests: 많은 수의 이슈 및 풀 리퀘스트는 활성화된 커뮤니티와 프레임워크를 개선하려는 지속적인 노력을 보여줍니다.\n\n# 2024년의 경쟁\n\nFlutter는 강세를 유지하고 있지만, Kotlin Multiplatform, React Native, Quasar Framework, 그리고 NativeScript와 같은 여러 프레임워크도 널리 인기를 얻고 있으며 크로스 플랫폼 개발에 매력적인 대안을 제공하고 있습니다. 함께 상태와 영향을 살펴보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n## Kotlin Multiplatform\n\nKotlin Multiplatform (KMP)은 교차 플랫폼 개발 환경에서 부상 중인 플레이어입니다. JetBrains에서 개발한 KMP는 안드로이드, iOS 및 웹을 포함한 여러 플랫폼에 대한 공통 코드 작성을 허용합니다. Kotlin은 Java와의 상호 운용성 및 간결한 구문으로 개발자들 사이에서 인기가 높습니다.\n\n- GitHub Stars: Kotlin Multiplatform은 약 10k개의 스타를 모아 사람들의 인기를 반영하고 있습니다.\n- Commits: 이 프로젝트는 꾸준한 커밋과 적극적인 기여를 보이며, 강력한 커뮤니티 지원과 지속적인 개발을 시사합니다.\n- 채택: Netflix와 Cash App과 같은 회사들이 애플리케이션의 일부에 KMP를 도입함으로써 실용성을 진열하고 있습니다.\n\n## React Native\n\n<div class=\"content-ad\"></div>\n\nReact Native은 Facebook에서 지원하는 가장 기반이 탄탄한 크로스 플랫폼 프레임워크 중 하나입니다. JavaScript와 React를 활용하여 개발자들이 모바일 애플리케이션을 만들 수 있습니다.\n\n- GitHub Stars: React Native은 GitHub에서 11만 개 이상의 스타를 받아 널리 사용되고 커뮤니티 지원을 받고 있습니다.\n- 커밋: 프로젝트는 자주 커밋되고 업데이트되어 경쟁력을 유지하고 있습니다.\n- 채택: Facebook, Instagram, Airbnb 등 주요 기업들이 React Native을 사용하며 견고성과 다재다능성을 입증하고 있습니다.\n\n## Quasar Framework\n\nQuasar Framework은 Vue.js를 사용하여 크로스 플랫폼 애플리케이션을 만들기 위한 강력한 프레임워크입니다. 데스크톱 및 모바일 애플리케이션과 PWA(Progressive Web Apps)을 지원합니다.\n\n<div class=\"content-ad\"></div>\n\n- GitHub Stars: Quasar은 약 25,000개의 스타를 모았으며, 특정한 사용자들의 관심이 있는 것을 보여줍니다.\n- 커밋: Quasar는 정기적인 커밋과 업데이트로 활발하게 개발되고 있습니다.\n- 채택: Flutter나 React Native만큼 널리 사용되지는 않지만, Quasar는 유연성과 성능에 대한 칭찬을 받으며 충실한 사용자층을 보유하고 있습니다.\n\n## NativeScript\n\nNativeScript는 JavaScript, TypeScript 또는 Angular를 사용하여 모바일 앱을 개발할 수 있는 오픈 소스 프레임워크입니다. 네이티브 API에 직접 액세스할 수 있어 네이티브 수준의 성능을 제공합니다.\n\n- GitHub Stars: NativeScript는 GitHub에서 약 21,000개의 스타를 보유하고 있습니다.\n- 커밋: 이 프레임워크는 지속적인 기여와 업데이트를 받고 있습니다.\n- 채택: SAP와 Puma와 같은 기업들이 NativeScript를 사용하며 기업급 애플리케이션을 제공할 수 있는 능력을 보여주고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 구글의 플러터 로드맵\n\n구글은 플러터의 성공에 큰 관심을 가지고 있으며, 플러터의 장기적인 성공을 결정하는 구글의 로드맵과 미래 계획은 중요합니다. 구글은 공식 블로그 포스트와 소셜 미디어를 통해 발표된 다양한 공지사항과 업데이트를 통해 플러터에 대한 헌신을 보여주고 있습니다.\n\n## 공식 공지사항\n\n- 플러터 3.0 릴리스: 2023년에 구글은 플러터 3.0을 발표했으며, 이를 통해 성능 개선, 새로운 위젯, 그리고 웹 및 데스크톱 플랫폼과의 통합 개선 사항 등이 도입되었습니다. 이 릴리스는 구글이 플러터를 진정한 멀티 플랫폼 프레임워크로 만들기 위한 헌신을 강조했습니다.\n- 퓨시아 OS 통합: 구글의 실험적 운영 체제인 퓨시아는 주요 개발 프레임워크로 플러터를 사용합니다. 이 통합은 플러터의 장기적인 지원과 투자를 시사합니다.\n- 파트너십 및 에코시스템 확장: 구글은 다양한 기업들과의 파트너십을 육성하고 플러터 생태계를 확장하고 있습니다. 이는 Firebase, 구글 클라우드, 서드파티 라이브러리와 같은 도구 및 서비스와의 협업을 포함합니다.\n\n<div class=\"content-ad\"></div>\n\n## 앞으로의 계획\n\n- 향상된 도구 및 개발자 경험: Google은 Flutter의 개발 도구인 Dart 프로그래밍 언어, DevTools 및 Visual Studio Code 및 Android Studio와의 통합을 계속 개선할 예정입니다.\n- 웹 및 데스크톱 개선: Flutter의 모바일 기능이 이미 잘 알려져 있지만, Google은 웹 및 데스크톱 성능을 향상시키는 데 중점을 두고 있습니다. 이는 웹 표준에 대한 더 나은 지원, 더 빠른 로딩 시간 및 더 많은 데스크톱 특화 기능을 포함합니다.\n- 성능 및 안정성에 초점: Flutter 앱이 모든 플랫폼에서 원활하게 실행되는 것을 보장하는 것이 우선입니다. Google은 프레임워크를 최적화하여 일관된 성능과 안정성을 제공하도록 노력하고 있습니다.\n- 커뮤니티 참여: Google은 커뮤니티 기여의 중요성을 인식합니다. 오픈 소스 기여를 지원하는 계획, 이벤트 조직, 그리고 더 나은 문서 제공을 통해 활기찬 Flutter 커뮤니티를 육성하는 데 노력하고 있습니다.\n\n# 분석과 전망\n\n## Flutter의 장점\n\n<div class=\"content-ad\"></div>\n\n- 단일 코드베이스: 플러터는 여러 플랫폼에 대해 하나의 코드베이스를 사용할 수 있는 능력이 강력한 매력으로 남아 있습니다. 이는 개발 시간과 비용을 상당히 줄입니다.\n- 성능: 네이티브에 가까운 성능을 보여주는 플러터는 복잡하고 그래픽 집중적인 애플리케이션에 특히 큰 장점을 가지고 있습니다.\n- 다양한 UI 구성요소: 사전에 디자인된 다양한 위젯 집합은 매우 사용자 정의 및 반응형 UI 디자인을 가능하게 합니다.\n\n## 도전과 경쟁\n\n- 학습 곡선: 플러터는 비교적 쉽게 배울 수 있지만, 여전히 다른 언어에 익숙한 사람들에게는 장벽이 될 수 있는 다트를 배워야 합니다.\n- 경쟁 환경: React Native와 Kotlin Multiplatform과 같은 프레임워크들은 강력한 경쟁자입니다. React Native의 자바스크립트 기반 접근방식과 Kotlin의 네이티브 상호 운용성은 매력적인 대안입니다.\n- 생태계와 커뮤니티: 플러터는 강력한 커뮤니티를 가지고 있지만, 자바스크립트(React Native)와 자바/코틀린(Kotlin Multiplatform)의 거대한 생태계와 경쟁합니다.\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\n2024년에 Flutter가 사라질까요? 답은 틀림없이 '아니오'입니다. 경쟁적인 환경에도 불구하고 Google의 강력한 지원과 활기찬 커뮤니티에 의해 뒷받침되면서 Flutter는 지속적으로 성장하고 있습니다. 이 프레임워크의 지속적인 발전과 성능, 도구, 및 멀티 플랫폼 능력에 대한 전략적인 향상을 통해, 향후 몇 년 동안의 발전과 성장을 보장합니다.\n\nFlutter는 모바일, 웹, 그리고 데스크탑 애플리케이션을 위한 단일 코드베이스 솔루션을 제공할 수 있는 능력으로 매우 중요합니다. 그러나 언제나 선도하려면 Kotlin Multiplatform, React Native, Quasar Framework, 그리고 NativeScript와 같은 경쟁 업체들이 제기하는 도전에 대처해야 합니다. Google은 지속적으로 혁신하고 프레임워크를 향상시킴으로써, Flutter를 2024년 이후로도 교차 플랫폼 개발의 최고 선택으로 확고히 할 것으로 보입니다.","ogImage":{"url":"/assets/img/2024-06-21-IsFlutterDyingin2024FutureofCross-PlatformDevelopment_0.png"},"coverImage":"/assets/img/2024-06-21-IsFlutterDyingin2024FutureofCross-PlatformDevelopment_0.png","tag":["Tech"],"readingTime":6}],"page":"16","totalPageCount":28,"totalPageGroupCount":2,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}