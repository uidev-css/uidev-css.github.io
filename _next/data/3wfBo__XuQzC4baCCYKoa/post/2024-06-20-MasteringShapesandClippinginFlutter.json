{"pageProps":{"post":{"title":"플러터에서 모양과 클리핑 마스터하기","description":"","date":"2024-06-20 13:42","slug":"2024-06-20-MasteringShapesandClippinginFlutter","content":"\n\n도형과 상자를 다루는 것은 설계된 UI를 구현하는 방법을 알지 못하면 압도될 수 있습니다. 이 기사에서는 매우 기초부터 시작하여 일부 고급 예제로 이동할 것입니다.\n\n## 1. 도형과 상자란 무엇인가요?\n\n도형은 해당 경로에 의해 정의된 어떤 형태를 나타낼 수 있습니다.\n\n상자는 4개의 점으로 구성된 직사각형 모양을 나타냅니다. 테두리 반경과 같은 추가 속성을 가질 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n위젯 Flutter의 다양한 컨텍스트에서 상자가 나타날 수 있어요. \n\n예를 들어:\n\n- RenderBox: 비 슬리버 컨텍스트의 위젯의 RenderObject\n- BoxDecoration\n- BoxBorder\n\n또한 ShapeDecoration, ShapeBorder와 같은 클래스들도 있어요.\n\n우리는 Container, DecoratedSlivers 또는 DecoratedBoxes를 스타일링하기 위해 자주 BoxDecoration을 사용해요:\n\n<div class=\"content-ad\"></div>\n\n\n```js\nDecoratedBox(\n  decoration: BoxDecoration( // <- this\n    borderRadius: BorderRadius.circular(10),\n    color: Colors.amber,\n  ),\n  child: const SizedBox(height: 200, width: 200),\n)\n```\n\n그냥 이렇게 해서, 결과를 얻습니다:\n\n<img src=\"/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_0.png\" />\n\n대안으로 ShapeDecoration을 사용할 수도 있는데, 이것은 색상, 그림자, 그라디언트의 비슷한 사용자 정의를 제공하지만 주요 차이점은 그 모양 매개변수가 BoxShape 대신 ShapeBorder를 사용한다는 것입니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\nDecoratedBox(\n  decoration: ShapeDecoration( // <- 이 부분\n    color: Colors.amber,\n    shape: BeveledRectangleBorder(borderRadius: BorderRadius.circular(20)),\n  ),\n  child: const SizedBox(height: 200, width: 200),\n)\n```\n\n<img src=\"/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_1.png\" />\n\n그럼 ShapeBorder는 정확히 무엇인가요?\n\n구현을 확인하면 좀 더 명확해집니다. OutlinedBorder, StarBorder, BeveledRectangleBorder와 같은 슈퍼클래스들이 있습니다. 이것들은 위젯을 꾸미기 위한 다양한 모양들입니다. 그리고 WidgetStateOutlinedBorder도 있습니다. WidgetStates에 익숙하지 않다면 해당 기사를 읽어보세요.\n\n\n<div class=\"content-ad\"></div>\n\n경계의 본질은 내부 경로와 외부 경로 2개가 있어야 한다는 것을 의미합니다:\n\n![MasteringShapesandClippinginFlutter](/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_2.png)\n\n베지에 곡선에 익숙하지 않다면, 이 대화식 가이드를 확인하는 것을 추천합니다. 플러터의 Path는 선형, 이차, 삼차 및 콘회의 절을 지원합니다.\n\n용어는 여기까지, 이제 재미있는 일을 시작해 봅시다: 사용자 정의 모양을 만들어 보세요!\n\n<div class=\"content-ad\"></div>\n\n# 2. 사용자 정의 ShapeBorder 구현\n\n위 작업을 수행하려면 ShapeBorder의 슈퍼 클래스 또는 OutlinedBorder를 만들고 다음 메서드를 구현해야 합니다:\n\n- getInnerPath 및 getOuterPath: 해당 경로를 반환하는 메서드\n- paint: 모양을 그리는 메서드\n- scale, copyWith\n\n원하는 메시지 버블 모양을 만들어보겠습니다. 원구획을 사용하고 두께(w) 매개변수를 변수로 사용하세요.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_3.png)\n\n```js\nclass MessageShapeBorder extends OutlinedBorder {\n  final double borderRadius;\n  final double weight;\n\n  const MessageShapeBorder({\n    super.side, \n    this.borderRadius = 50,\n    this.weight = 2.5,\n  });\n\n  ...\n\n}\n```\n\n그 다음으로, getOuterPath 메서드를 구현합니다. 여기서 경로는 아래 왼쪽 모서리에서 시계 방향으로 이동하는 선 및 물결 모양 세그먼트로 구성됩니다.\n\n```js\n  @override\n  Path getOuterPath(Rect rect, {TextDirection? textDirection}) {\n    final double left = rect.left;\n    final double right = rect.right;\n    final double top = rect.top;\n    final double bottom = rect.bottom;\n\n    final radius = borderRadius;\n    final offset = 10;\n\n    return Path()\n      ..moveTo(left, bottom)\n      ..conicTo(left + offset, bottom - offset, left + offset,\n          bottom - 2 * radius, weight)\n      ..lineTo(left + offset, top + radius)\n      ..conicTo(left + offset, top, left + offset + radius, top, weight)\n      ..lineTo(right - radius, top)\n      ..conicTo(right, top, right, top + radius, weight)\n      ..lineTo(right, bottom - radius)\n      ..conicTo(right, bottom, right - radius, bottom, weight)\n      ..close();\n  }\n```\n\n\n<div class=\"content-ad\"></div>\n\n더 명확하게 하기 위해, 아래는 각 행이 하는 작업을 시각적으로 보여줍니다:\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*KKbxvf4nJa9IXIUcPdPUxg.gif)\n\n이제 약간 다른 내부 경로를 만들어 봅시다:\n\n```js\n  @override\n  Path getInnerPath(Rect rect, {TextDirection? textDirection}) {\n    final strokeWidth = side.width;\n\n    final double left = rect.left + strokeWidth;\n    final double right = rect.right - strokeWidth;\n    final double top = rect.top + strokeWidth;\n    final double bottom = rect.bottom - strokeWidth;\n\n    final radius = math.max(0, borderRadius - 10);\n    final offset = 10;\n\n    return Path()\n      ..moveTo(left + offset + radius, bottom)\n      ..conicTo(\n          left + offset, bottom, left + offset, bottom - 2 * radius, weight)\n      ..lineTo(left + offset, top + radius)\n      ..conicTo(left + offset, top, left + offset + radius, top, weight)\n      ..lineTo(right - radius, top)\n      ..conicTo(right, top, right, top + radius, weight)\n      ..lineTo(right, bottom - radius)\n      ..conicTo(right, bottom, right - radius, bottom, weight)\n      ..close();\n  }\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n  @override\n  void paint(Canvas canvas, Rect rect, {TextDirection? textDirection}) {\n    canvas.drawPath(getInnerPath(rect), Paint()..color = side.color);\n  }\n```\n\n<img src=\"/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_4.png\" />\n\n이제 이 모양을 다음과 같이 DecoratedBox에서 사용할 수 있습니다:\n\n```js\nDecoratedBox(\n  decoration: ShapeDecoration(\n    shape: MessageShapeBorder(\n      borderRadius: 30,\n      fillColor: Color(0xFF7ADEFF)\n    ),\n    color: Color(0xFFd6f5ff),\n  ),\n  child: Padding(\n    padding: EdgeInsets.all(20).copyWith(left: 30),\n    child: Text(\"샘플 메시지 텍스트\"),\n  ),\n)\n```\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_5.png\" />\n\n안녕하세요! 코닉 섹션의 무게를 AnimatedBuilder를 사용하여 애니메이션할 수 있습니다. 만약 플러터의 애니메이션에 익숙하지 않다면, 꼭 공식 안내서를 읽어보시기를 강력히 추천합니다.\n\n```js\nMessageShapeBorder(\n  side: BorderSide(color: Color(0xFF7ADEFF), width: animation.value + 2),\n  weight: animation.value,\n  borderRadius: 30\n)\n```\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1088/1*AqcXygpWbTcwMHVyDkAf6A.gif\" />\n\n\n<div class=\"content-ad\"></div>\n\n# 3. 사용 중인 클리퍼\n\nFlutter에서는 여러 내장 클리퍼가 있습니다. 예를 들면:\n\n- 직사각형에 사용하는 ClipRect\n- 둥근 직사각형에 사용하는 ClipRRect\n- 원과 타원에 사용하는 ClipOval\n- 사용자 정의 경로에 사용하는 ClipPath\n\n첫 세 개는 사용하기 매우 간단합니다. 클리핑을 원하는 위젯을 해당 클리퍼로 감싸기만 하면 클리핑 효과를 얻을 수 있습니다. 그러나 이러한 클래스들에 대해 더 알고 싶다면 여기 공식 문서 링크를 참조해주세요.\n\n<div class=\"content-ad\"></div>\n\nClipPath은 CustomClipper를 인수로 사용합니다. 대부분의 경우에는 ShapeBorder를 ShapeBorderClipper에 전달하면 됩니다. 이는 ShapeBorder의 외부 경로로 자식을 클리핑하는 CustomClipper의 구현입니다:\n\n```js\nClipPath(\n  clipper: const ShapeBorderClipper( // <- 이 부분\n    shape: MessageShapeBorder(),\n  ),\n  child: Image.asset(\n    \"assets/6392956.jpg\",\n    height: 300,\n    width: 300,\n    fit: BoxFit.cover,\n    cacheHeight: (300 * MediaQuery.of(context).devicePixelRatio).toInt(),\n  ),\n);\n```\n\n<img src=\"/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_6.png\" />\n\n클리핑이 레이아웃에서 사용될 때마다 새 레이어가 생성되는 점을 주의해야 합니다. 이는 비교적 비용이 많이 드는 작업이므로 가능한 경우 클리핑 대신 데코레이션을 사용하세요.\n\n<div class=\"content-ad\"></div>\n\n# 4. 사용자 지정 클리퍼\n\n일부 경우에는 클리핑에 대해 더 많은 제어가 필요합니다. 예를 들어, 클리핑이 콘텐츠나 일부 형제 위젯에 따라 달라져야 할 때입니다. 콘텐츠에 따라 달라지는 노치가 있는 티켓 모양 위젯을 만들어 봅시다:\n\n![이미지](/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_7.png)\n\n여기서 어려운 점은 상하 자식 위젯의 크기가 다를 수 있고, 노치가 이에 종속되어야 한다는 것입니다. Flutter에서 위젯의 크기 정보는 RenderObject의 하위 클래스인 RenderBox를 사용하여 얻을 수 있습니다. RenderObjects에 익숙하지 않다면, 공식 문서로 이동하여 확인해보세요.\n\n<div class=\"content-ad\"></div>\n\n먼저 레이아웃을 만들고 상단과 하단 자식을 나누는 SizedBox에 GlobalKey를 추가해보겠습니다.\n\n```js\nfinal notchKey = GlobalKey(); // <- 이 부분\n\n...\n\nColumn(\n  children: [\n    widget.topChild,\n    SizedBox(key: notchKey, height: 20), // <- 이 부분\n    widget.bottomChild,\n  ],\n)\n```\n\nGlobalKey를 사용하면 위젯의 BuildContext를 얻을 수 있어요. RenderObject를 얻기 위해 context가 필요한데요. SizedBox의 좌표를 티켓 위젯의 context에서 가져와야 해서 해당 RenderBoxes가 필요해요. 여기에서는 Slivers을 사용하지 않기 때문에 RenderObject를 안전하게 RenderBox로 형변환할 수 있어요.\n\n```js\nClipPath(\n  clipper: _TicketClipper( // <- 우리의 클리퍼\n    notchBox: notchKey.currentContext?.findRenderObject() as RenderBox, // <- 이 부분\n    ancestorBox: context.findRenderObject() as RenderBox, // <- 이 부분\n  ),\n  child: ColoredBox(\n    color: Color(0xFFd6f5ff),\n    child: Column(\n      children: ...\n    ),\n  ),\n)\n```\n\n<div class=\"content-ad\"></div>\n\n\n그리고 클리퍼 자체는 다음과 같이 보일 것입니다:\n\n```js\nclass _TicketClipper extends CustomClipper<Path> {\n  final RenderBox notchBox;\n  final RenderBox ancestorBox;\n\n  _TicketClipper({required this.notchBox, required this.ancestorBox});\n\n  @override\n  Path getClip(Size size) {\n    final widgetRect = RRect.fromRectAndRadius(\n      Rect.fromPoints(Offset.zero, Offset(size.width, size.height)),\n      const Radius.circular(10),\n    );\n\n    final notch = notchBox.localToGlobal(Offset.zero, ancestor: ancestorBox);\n\n    return Path.combine(\n      PathOperation.difference,\n      Path()..addRRect(widgetRect),\n      Path()\n        ..addOval(Rect.fromCenter(\n            center: Offset(0, notch.dy + 10), width: 20, height: 20))\n        ..addOval(Rect.fromCenter(\n            center: Offset(size.width, notch.dy + 10), width: 20, height: 20)),\n    );\n  }\n\n  @override\n  bool shouldReclip(covariant CustomClipper<Path> oldClipper) {\n    ...\n  }\n}\n```\n\nFlutter는 차이, 교차 등의 경로 작업을 지원합니다. 여기서는 둥근 사각형에서 2개의 원을 빼내어 원하는 모양을 얻어낸 것입니다.\n\n<img src=\"/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_8.png\" />\n\n<div class=\"content-ad\"></div>\n\n이 글이 도움이 되셨기를 바랍니다. 새로운 기술을 발견할 때마다 업데이트하겠습니다. 최신 업데이트를 받으시려면 Twitter에서 제 소식을 팔로우해주세요. 전체 코드를 읽고 싶다면 저장소를 확인해주세요.\n\n![마스터링 플러터의 형태와 클리핑](/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_9.png)","ogImage":{"url":"/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_0.png"},"coverImage":"/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_0.png","tag":["Tech"],"readingTime":9},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>도형과 상자를 다루는 것은 설계된 UI를 구현하는 방법을 알지 못하면 압도될 수 있습니다. 이 기사에서는 매우 기초부터 시작하여 일부 고급 예제로 이동할 것입니다.</p>\n<h2>1. 도형과 상자란 무엇인가요?</h2>\n<p>도형은 해당 경로에 의해 정의된 어떤 형태를 나타낼 수 있습니다.</p>\n<p>상자는 4개의 점으로 구성된 직사각형 모양을 나타냅니다. 테두리 반경과 같은 추가 속성을 가질 수 있습니다.</p>\n<p>위젯 Flutter의 다양한 컨텍스트에서 상자가 나타날 수 있어요.</p>\n<p>예를 들어:</p>\n<ul>\n<li>RenderBox: 비 슬리버 컨텍스트의 위젯의 RenderObject</li>\n<li>BoxDecoration</li>\n<li>BoxBorder</li>\n</ul>\n<p>또한 ShapeDecoration, ShapeBorder와 같은 클래스들도 있어요.</p>\n<p>우리는 Container, DecoratedSlivers 또는 DecoratedBoxes를 스타일링하기 위해 자주 BoxDecoration을 사용해요:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">DecoratedBox</span>(\n  <span class=\"hljs-attr\">decoration</span>: <span class=\"hljs-title class_\">BoxDecoration</span>( <span class=\"hljs-comment\">// &#x3C;- this</span>\n    <span class=\"hljs-attr\">borderRadius</span>: <span class=\"hljs-title class_\">BorderRadius</span>.<span class=\"hljs-title function_\">circular</span>(<span class=\"hljs-number\">10</span>),\n    <span class=\"hljs-attr\">color</span>: <span class=\"hljs-title class_\">Colors</span>.<span class=\"hljs-property\">amber</span>,\n  ),\n  <span class=\"hljs-attr\">child</span>: <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">SizedBox</span>(<span class=\"hljs-attr\">height</span>: <span class=\"hljs-number\">200</span>, <span class=\"hljs-attr\">width</span>: <span class=\"hljs-number\">200</span>),\n)\n</code></pre>\n<p>그냥 이렇게 해서, 결과를 얻습니다:</p>\n<p>대안으로 ShapeDecoration을 사용할 수도 있는데, 이것은 색상, 그림자, 그라디언트의 비슷한 사용자 정의를 제공하지만 주요 차이점은 그 모양 매개변수가 BoxShape 대신 ShapeBorder를 사용한다는 것입니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">DecoratedBox</span>(\n  <span class=\"hljs-attr\">decoration</span>: <span class=\"hljs-title class_\">ShapeDecoration</span>( <span class=\"hljs-comment\">// &#x3C;- 이 부분</span>\n    <span class=\"hljs-attr\">color</span>: <span class=\"hljs-title class_\">Colors</span>.<span class=\"hljs-property\">amber</span>,\n    <span class=\"hljs-attr\">shape</span>: <span class=\"hljs-title class_\">BeveledRectangleBorder</span>(<span class=\"hljs-attr\">borderRadius</span>: <span class=\"hljs-title class_\">BorderRadius</span>.<span class=\"hljs-title function_\">circular</span>(<span class=\"hljs-number\">20</span>)),\n  ),\n  <span class=\"hljs-attr\">child</span>: <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">SizedBox</span>(<span class=\"hljs-attr\">height</span>: <span class=\"hljs-number\">200</span>, <span class=\"hljs-attr\">width</span>: <span class=\"hljs-number\">200</span>),\n)\n</code></pre>\n<p>그럼 ShapeBorder는 정확히 무엇인가요?</p>\n<p>구현을 확인하면 좀 더 명확해집니다. OutlinedBorder, StarBorder, BeveledRectangleBorder와 같은 슈퍼클래스들이 있습니다. 이것들은 위젯을 꾸미기 위한 다양한 모양들입니다. 그리고 WidgetStateOutlinedBorder도 있습니다. WidgetStates에 익숙하지 않다면 해당 기사를 읽어보세요.</p>\n<p>경계의 본질은 내부 경로와 외부 경로 2개가 있어야 한다는 것을 의미합니다:</p>\n<p><img src=\"/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_2.png\" alt=\"MasteringShapesandClippinginFlutter\"></p>\n<p>베지에 곡선에 익숙하지 않다면, 이 대화식 가이드를 확인하는 것을 추천합니다. 플러터의 Path는 선형, 이차, 삼차 및 콘회의 절을 지원합니다.</p>\n<p>용어는 여기까지, 이제 재미있는 일을 시작해 봅시다: 사용자 정의 모양을 만들어 보세요!</p>\n<h1>2. 사용자 정의 ShapeBorder 구현</h1>\n<p>위 작업을 수행하려면 ShapeBorder의 슈퍼 클래스 또는 OutlinedBorder를 만들고 다음 메서드를 구현해야 합니다:</p>\n<ul>\n<li>getInnerPath 및 getOuterPath: 해당 경로를 반환하는 메서드</li>\n<li>paint: 모양을 그리는 메서드</li>\n<li>scale, copyWith</li>\n</ul>\n<p>원하는 메시지 버블 모양을 만들어보겠습니다. 원구획을 사용하고 두께(w) 매개변수를 변수로 사용하세요.</p>\n<p><img src=\"/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_3.png\" alt=\"이미지\"></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MessageShapeBorder</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">OutlinedBorder</span> {\n  final double borderRadius;\n  final double weight;\n\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">MessageShapeBorder</span>({\n    <span class=\"hljs-variable language_\">super</span>.<span class=\"hljs-property\">side</span>, \n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">borderRadius</span> = <span class=\"hljs-number\">50</span>,\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">weight</span> = <span class=\"hljs-number\">2.5</span>,\n  });\n\n  ...\n\n}\n</code></pre>\n<p>그 다음으로, getOuterPath 메서드를 구현합니다. 여기서 경로는 아래 왼쪽 모서리에서 시계 방향으로 이동하는 선 및 물결 모양 세그먼트로 구성됩니다.</p>\n<pre><code class=\"hljs language-js\">  @override\n  <span class=\"hljs-title class_\">Path</span> <span class=\"hljs-title function_\">getOuterPath</span>(<span class=\"hljs-params\">Rect rect, {TextDirection? textDirection}</span>) {\n    final double left = rect.<span class=\"hljs-property\">left</span>;\n    final double right = rect.<span class=\"hljs-property\">right</span>;\n    final double top = rect.<span class=\"hljs-property\">top</span>;\n    final double bottom = rect.<span class=\"hljs-property\">bottom</span>;\n\n    final radius = borderRadius;\n    final offset = <span class=\"hljs-number\">10</span>;\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Path</span>()\n      ..<span class=\"hljs-title function_\">moveTo</span>(left, bottom)\n      ..<span class=\"hljs-title function_\">conicTo</span>(left + offset, bottom - offset, left + offset,\n          bottom - <span class=\"hljs-number\">2</span> * radius, weight)\n      ..<span class=\"hljs-title function_\">lineTo</span>(left + offset, top + radius)\n      ..<span class=\"hljs-title function_\">conicTo</span>(left + offset, top, left + offset + radius, top, weight)\n      ..<span class=\"hljs-title function_\">lineTo</span>(right - radius, top)\n      ..<span class=\"hljs-title function_\">conicTo</span>(right, top, right, top + radius, weight)\n      ..<span class=\"hljs-title function_\">lineTo</span>(right, bottom - radius)\n      ..<span class=\"hljs-title function_\">conicTo</span>(right, bottom, right - radius, bottom, weight)\n      ..<span class=\"hljs-title function_\">close</span>();\n  }\n</code></pre>\n<p>더 명확하게 하기 위해, 아래는 각 행이 하는 작업을 시각적으로 보여줍니다:</p>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*KKbxvf4nJa9IXIUcPdPUxg.gif\" alt=\"이미지\"></p>\n<p>이제 약간 다른 내부 경로를 만들어 봅시다:</p>\n<pre><code class=\"hljs language-js\">  @override\n  <span class=\"hljs-title class_\">Path</span> <span class=\"hljs-title function_\">getInnerPath</span>(<span class=\"hljs-params\">Rect rect, {TextDirection? textDirection}</span>) {\n    final strokeWidth = side.<span class=\"hljs-property\">width</span>;\n\n    final double left = rect.<span class=\"hljs-property\">left</span> + strokeWidth;\n    final double right = rect.<span class=\"hljs-property\">right</span> - strokeWidth;\n    final double top = rect.<span class=\"hljs-property\">top</span> + strokeWidth;\n    final double bottom = rect.<span class=\"hljs-property\">bottom</span> - strokeWidth;\n\n    final radius = math.<span class=\"hljs-title function_\">max</span>(<span class=\"hljs-number\">0</span>, borderRadius - <span class=\"hljs-number\">10</span>);\n    final offset = <span class=\"hljs-number\">10</span>;\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Path</span>()\n      ..<span class=\"hljs-title function_\">moveTo</span>(left + offset + radius, bottom)\n      ..<span class=\"hljs-title function_\">conicTo</span>(\n          left + offset, bottom, left + offset, bottom - <span class=\"hljs-number\">2</span> * radius, weight)\n      ..<span class=\"hljs-title function_\">lineTo</span>(left + offset, top + radius)\n      ..<span class=\"hljs-title function_\">conicTo</span>(left + offset, top, left + offset + radius, top, weight)\n      ..<span class=\"hljs-title function_\">lineTo</span>(right - radius, top)\n      ..<span class=\"hljs-title function_\">conicTo</span>(right, top, right, top + radius, weight)\n      ..<span class=\"hljs-title function_\">lineTo</span>(right, bottom - radius)\n      ..<span class=\"hljs-title function_\">conicTo</span>(right, bottom, right - radius, bottom, weight)\n      ..<span class=\"hljs-title function_\">close</span>();\n  }\n</code></pre>\n<pre><code class=\"hljs language-js\">  @override\n  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">paint</span>(<span class=\"hljs-params\">Canvas canvas, Rect rect, {TextDirection? textDirection}</span>) {\n    canvas.<span class=\"hljs-title function_\">drawPath</span>(<span class=\"hljs-title function_\">getInnerPath</span>(rect), <span class=\"hljs-title class_\">Paint</span>()..<span class=\"hljs-property\">color</span> = side.<span class=\"hljs-property\">color</span>);\n  }\n</code></pre>\n<p>이제 이 모양을 다음과 같이 DecoratedBox에서 사용할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">DecoratedBox</span>(\n  <span class=\"hljs-attr\">decoration</span>: <span class=\"hljs-title class_\">ShapeDecoration</span>(\n    <span class=\"hljs-attr\">shape</span>: <span class=\"hljs-title class_\">MessageShapeBorder</span>(\n      <span class=\"hljs-attr\">borderRadius</span>: <span class=\"hljs-number\">30</span>,\n      <span class=\"hljs-attr\">fillColor</span>: <span class=\"hljs-title class_\">Color</span>(<span class=\"hljs-number\">0xFF7ADEFF</span>)\n    ),\n    <span class=\"hljs-attr\">color</span>: <span class=\"hljs-title class_\">Color</span>(<span class=\"hljs-number\">0xFFd6f5ff</span>),\n  ),\n  <span class=\"hljs-attr\">child</span>: <span class=\"hljs-title class_\">Padding</span>(\n    <span class=\"hljs-attr\">padding</span>: <span class=\"hljs-title class_\">EdgeInsets</span>.<span class=\"hljs-title function_\">all</span>(<span class=\"hljs-number\">20</span>).<span class=\"hljs-title function_\">copyWith</span>(<span class=\"hljs-attr\">left</span>: <span class=\"hljs-number\">30</span>),\n    <span class=\"hljs-attr\">child</span>: <span class=\"hljs-title class_\">Text</span>(<span class=\"hljs-string\">\"샘플 메시지 텍스트\"</span>),\n  ),\n)\n</code></pre>\n<p>안녕하세요! 코닉 섹션의 무게를 AnimatedBuilder를 사용하여 애니메이션할 수 있습니다. 만약 플러터의 애니메이션에 익숙하지 않다면, 꼭 공식 안내서를 읽어보시기를 강력히 추천합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">MessageShapeBorder</span>(\n  <span class=\"hljs-attr\">side</span>: <span class=\"hljs-title class_\">BorderSide</span>(<span class=\"hljs-attr\">color</span>: <span class=\"hljs-title class_\">Color</span>(<span class=\"hljs-number\">0xFF7ADEFF</span>), <span class=\"hljs-attr\">width</span>: animation.<span class=\"hljs-property\">value</span> + <span class=\"hljs-number\">2</span>),\n  <span class=\"hljs-attr\">weight</span>: animation.<span class=\"hljs-property\">value</span>,\n  <span class=\"hljs-attr\">borderRadius</span>: <span class=\"hljs-number\">30</span>\n)\n</code></pre>\n<h1>3. 사용 중인 클리퍼</h1>\n<p>Flutter에서는 여러 내장 클리퍼가 있습니다. 예를 들면:</p>\n<ul>\n<li>직사각형에 사용하는 ClipRect</li>\n<li>둥근 직사각형에 사용하는 ClipRRect</li>\n<li>원과 타원에 사용하는 ClipOval</li>\n<li>사용자 정의 경로에 사용하는 ClipPath</li>\n</ul>\n<p>첫 세 개는 사용하기 매우 간단합니다. 클리핑을 원하는 위젯을 해당 클리퍼로 감싸기만 하면 클리핑 효과를 얻을 수 있습니다. 그러나 이러한 클래스들에 대해 더 알고 싶다면 여기 공식 문서 링크를 참조해주세요.</p>\n<p>ClipPath은 CustomClipper를 인수로 사용합니다. 대부분의 경우에는 ShapeBorder를 ShapeBorderClipper에 전달하면 됩니다. 이는 ShapeBorder의 외부 경로로 자식을 클리핑하는 CustomClipper의 구현입니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">ClipPath</span>(\n  <span class=\"hljs-attr\">clipper</span>: <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">ShapeBorderClipper</span>( <span class=\"hljs-comment\">// &#x3C;- 이 부분</span>\n    <span class=\"hljs-attr\">shape</span>: <span class=\"hljs-title class_\">MessageShapeBorder</span>(),\n  ),\n  <span class=\"hljs-attr\">child</span>: <span class=\"hljs-title class_\">Image</span>.<span class=\"hljs-title function_\">asset</span>(\n    <span class=\"hljs-string\">\"assets/6392956.jpg\"</span>,\n    <span class=\"hljs-attr\">height</span>: <span class=\"hljs-number\">300</span>,\n    <span class=\"hljs-attr\">width</span>: <span class=\"hljs-number\">300</span>,\n    <span class=\"hljs-attr\">fit</span>: <span class=\"hljs-title class_\">BoxFit</span>.<span class=\"hljs-property\">cover</span>,\n    <span class=\"hljs-attr\">cacheHeight</span>: (<span class=\"hljs-number\">300</span> * <span class=\"hljs-title class_\">MediaQuery</span>.<span class=\"hljs-title function_\">of</span>(context).<span class=\"hljs-property\">devicePixelRatio</span>).<span class=\"hljs-title function_\">toInt</span>(),\n  ),\n);\n</code></pre>\n<p>클리핑이 레이아웃에서 사용될 때마다 새 레이어가 생성되는 점을 주의해야 합니다. 이는 비교적 비용이 많이 드는 작업이므로 가능한 경우 클리핑 대신 데코레이션을 사용하세요.</p>\n<h1>4. 사용자 지정 클리퍼</h1>\n<p>일부 경우에는 클리핑에 대해 더 많은 제어가 필요합니다. 예를 들어, 클리핑이 콘텐츠나 일부 형제 위젯에 따라 달라져야 할 때입니다. 콘텐츠에 따라 달라지는 노치가 있는 티켓 모양 위젯을 만들어 봅시다:</p>\n<p><img src=\"/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_7.png\" alt=\"이미지\"></p>\n<p>여기서 어려운 점은 상하 자식 위젯의 크기가 다를 수 있고, 노치가 이에 종속되어야 한다는 것입니다. Flutter에서 위젯의 크기 정보는 RenderObject의 하위 클래스인 RenderBox를 사용하여 얻을 수 있습니다. RenderObjects에 익숙하지 않다면, 공식 문서로 이동하여 확인해보세요.</p>\n<p>먼저 레이아웃을 만들고 상단과 하단 자식을 나누는 SizedBox에 GlobalKey를 추가해보겠습니다.</p>\n<pre><code class=\"hljs language-js\">final notchKey = <span class=\"hljs-title class_\">GlobalKey</span>(); <span class=\"hljs-comment\">// &#x3C;- 이 부분</span>\n\n...\n\n<span class=\"hljs-title class_\">Column</span>(\n  <span class=\"hljs-attr\">children</span>: [\n    widget.<span class=\"hljs-property\">topChild</span>,\n    <span class=\"hljs-title class_\">SizedBox</span>(<span class=\"hljs-attr\">key</span>: notchKey, <span class=\"hljs-attr\">height</span>: <span class=\"hljs-number\">20</span>), <span class=\"hljs-comment\">// &#x3C;- 이 부분</span>\n    widget.<span class=\"hljs-property\">bottomChild</span>,\n  ],\n)\n</code></pre>\n<p>GlobalKey를 사용하면 위젯의 BuildContext를 얻을 수 있어요. RenderObject를 얻기 위해 context가 필요한데요. SizedBox의 좌표를 티켓 위젯의 context에서 가져와야 해서 해당 RenderBoxes가 필요해요. 여기에서는 Slivers을 사용하지 않기 때문에 RenderObject를 안전하게 RenderBox로 형변환할 수 있어요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">ClipPath</span>(\n  <span class=\"hljs-attr\">clipper</span>: <span class=\"hljs-title function_\">_TicketClipper</span>( <span class=\"hljs-comment\">// &#x3C;- 우리의 클리퍼</span>\n    <span class=\"hljs-attr\">notchBox</span>: notchKey.<span class=\"hljs-property\">currentContext</span>?.<span class=\"hljs-title function_\">findRenderObject</span>() <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">RenderBox</span>, <span class=\"hljs-comment\">// &#x3C;- 이 부분</span>\n    <span class=\"hljs-attr\">ancestorBox</span>: context.<span class=\"hljs-title function_\">findRenderObject</span>() <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">RenderBox</span>, <span class=\"hljs-comment\">// &#x3C;- 이 부분</span>\n  ),\n  <span class=\"hljs-attr\">child</span>: <span class=\"hljs-title class_\">ColoredBox</span>(\n    <span class=\"hljs-attr\">color</span>: <span class=\"hljs-title class_\">Color</span>(<span class=\"hljs-number\">0xFFd6f5ff</span>),\n    <span class=\"hljs-attr\">child</span>: <span class=\"hljs-title class_\">Column</span>(\n      <span class=\"hljs-attr\">children</span>: ...\n    ),\n  ),\n)\n</code></pre>\n<p>그리고 클리퍼 자체는 다음과 같이 보일 것입니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">_TicketClipper</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">CustomClipper</span>&#x3C;<span class=\"hljs-title class_\">Path</span>> {\n  final <span class=\"hljs-title class_\">RenderBox</span> notchBox;\n  final <span class=\"hljs-title class_\">RenderBox</span> ancestorBox;\n\n  <span class=\"hljs-title function_\">_TicketClipper</span>({required <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">notchBox</span>, required <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">ancestorBox</span>});\n\n  @override\n  <span class=\"hljs-title class_\">Path</span> <span class=\"hljs-title function_\">getClip</span>(<span class=\"hljs-params\">Size size</span>) {\n    final widgetRect = <span class=\"hljs-title class_\">RRect</span>.<span class=\"hljs-title function_\">fromRectAndRadius</span>(\n      <span class=\"hljs-title class_\">Rect</span>.<span class=\"hljs-title function_\">fromPoints</span>(<span class=\"hljs-title class_\">Offset</span>.<span class=\"hljs-property\">zero</span>, <span class=\"hljs-title class_\">Offset</span>(size.<span class=\"hljs-property\">width</span>, size.<span class=\"hljs-property\">height</span>)),\n      <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Radius</span>.<span class=\"hljs-title function_\">circular</span>(<span class=\"hljs-number\">10</span>),\n    );\n\n    final notch = notchBox.<span class=\"hljs-title function_\">localToGlobal</span>(<span class=\"hljs-title class_\">Offset</span>.<span class=\"hljs-property\">zero</span>, <span class=\"hljs-attr\">ancestor</span>: ancestorBox);\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Path</span>.<span class=\"hljs-title function_\">combine</span>(\n      <span class=\"hljs-title class_\">PathOperation</span>.<span class=\"hljs-property\">difference</span>,\n      <span class=\"hljs-title class_\">Path</span>()..<span class=\"hljs-title function_\">addRRect</span>(widgetRect),\n      <span class=\"hljs-title class_\">Path</span>()\n        ..<span class=\"hljs-title function_\">addOval</span>(<span class=\"hljs-title class_\">Rect</span>.<span class=\"hljs-title function_\">fromCenter</span>(\n            <span class=\"hljs-attr\">center</span>: <span class=\"hljs-title class_\">Offset</span>(<span class=\"hljs-number\">0</span>, notch.<span class=\"hljs-property\">dy</span> + <span class=\"hljs-number\">10</span>), <span class=\"hljs-attr\">width</span>: <span class=\"hljs-number\">20</span>, <span class=\"hljs-attr\">height</span>: <span class=\"hljs-number\">20</span>))\n        ..<span class=\"hljs-title function_\">addOval</span>(<span class=\"hljs-title class_\">Rect</span>.<span class=\"hljs-title function_\">fromCenter</span>(\n            <span class=\"hljs-attr\">center</span>: <span class=\"hljs-title class_\">Offset</span>(size.<span class=\"hljs-property\">width</span>, notch.<span class=\"hljs-property\">dy</span> + <span class=\"hljs-number\">10</span>), <span class=\"hljs-attr\">width</span>: <span class=\"hljs-number\">20</span>, <span class=\"hljs-attr\">height</span>: <span class=\"hljs-number\">20</span>)),\n    );\n  }\n\n  @override\n  bool <span class=\"hljs-title function_\">shouldReclip</span>(<span class=\"hljs-params\">covariant CustomClipper&#x3C;Path> oldClipper</span>) {\n    ...\n  }\n}\n</code></pre>\n<p>Flutter는 차이, 교차 등의 경로 작업을 지원합니다. 여기서는 둥근 사각형에서 2개의 원을 빼내어 원하는 모양을 얻어낸 것입니다.</p>\n<p>이 글이 도움이 되셨기를 바랍니다. 새로운 기술을 발견할 때마다 업데이트하겠습니다. 최신 업데이트를 받으시려면 Twitter에서 제 소식을 팔로우해주세요. 전체 코드를 읽고 싶다면 저장소를 확인해주세요.</p>\n<p><img src=\"/assets/img/2024-06-20-MasteringShapesandClippinginFlutter_9.png\" alt=\"마스터링 플러터의 형태와 클리핑\"></p>\n</body>\n</html>\n"},"__N_SSG":true}