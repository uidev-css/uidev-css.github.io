{"pageProps":{"post":{"title":"플러터 Go 라우터 필수 가이드","description":"","date":"2024-06-19 08:13","slug":"2024-06-19-FlutterGoRouterTheCrucialGuide","content":"\n\n\n![FlutterGoRouter](/assets/img/2024-06-19-FlutterGoRouterTheCrucialGuide_0.png)\n\nGo_router은 Flutter에서 라우팅을 위한 서드 파티 패키지로, 기본 플러터 라우팅 옵션보다 더 유연하고 사용하기 쉬운 솔루션을 제공하기 위해 만들어졌습니다. 라우트가 어떻게 정의되고 관리되는지에 대해 더 많은 제어를 원하는 경우 유용할 수 있습니다. 또한 웹에 대한 좋은 지원을 제공하기 때문에 애플리케이션에 좋은 선택일 수 있습니다.\n\nURL 패턴을 정의하고, URL을 사용하여 탐색하며, 딥 링크를 처리하고, 기타 여러 네비게이션 관련 시나리오를 다룰 수 있습니다.\n\n# 특징\n\n\n<div class=\"content-ad\"></div>\n\n고 라우터(GoRouter)는 네비게이션을 간단하게 만들기 위한 다양한 기능을 제공합니다:\n\n- Navigator API와의 하위 호환성\n- Material 및 Cupertino 앱을 지원\n- StatefulShellRoute를 사용하여 중첩된 탭 탐색 지원\n- 목적지에 대한 여러 화면 표시 (하위 라우트)\n- 템플릿 구문을 사용하여 경로 및 쿼리 매개변수 구문 분석\n- 리디렉션 지원 — 사용자를 다른 URL로 리디렉션할 수 있으며,예를 들어 사용자가 인증되지 않은 경우에는 로그인 페이지로 이동할 수 있습니다.\n\n# 시작하기\n\n시작하려면 pubspec.yaml에 go_router를 추가하세요. 이 문서에서는 ^13.2.0을 사용하겠습니다.\n\n<div class=\"content-ad\"></div>\n\n```yaml\ndependencies:\n  go_router: ^13.2.0\n```\n\n# 라우트 구성\n\n이제 그렇게 한 다음에 GoRouter 구성을 앱에 추가해 봅시다:\n\n```dart\nimport 'package:go_router/go_router.dart';\n\n// GoRouter 구성\nfinal _router = GoRouter(\n  initialLocation: '/',\n  routes: [\n    GoRoute(\n      name: 'home', // 선택사항, 라우트에 이름 추가. 경로 대신 이름으로 이동 가능\n      path: '/',\n      builder: (context, state) => HomeScreen(),\n    ),\n    GoRoute(\n      name: 'shope',\n      path: '/shope',\n      builder: (context, state) => ShopeScreen(),\n    ),\n  ],\n);\n```\n\n<div class=\"content-ad\"></div>\n\n그럼 MaterialApp.router 또는 CupertinoApp.router 생성자를 사용하고 routerConfig 매개변수를 GoRouter 구성 객체로 설정할 수 있어요:\n\n```js\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp.router(\n      routerConfig: _router,\n    );\n  }\n}\n```\n\n이것으로 준비 끝이에요 🙂 go_router를 사용해보세요 !!!\n\n# 매개변수\n\n<div class=\"content-ad\"></div>\n\n경로 매개변수를 지정하려면 경로 세그먼트 앞에 콜론(:) 문자를 붙이고 고유한 이름(:userId와 같은)을 따라야 합니다. 빌더 콜백에 제공된 GoRouterState 객체를 통해 매개변수 값을 액세스할 수 있습니다:\n\n```js\nGoRoute(\n  path: '/fruits/:id',\n  builder: (context, state) {\n     final id = state.pathParameters[\"id\"]! // URL에서 \"id\" 매개변수 가져오기\n     return FruitsPage(id: id);\n  },\n),\n```\n\n# 하위 루트 추가\n\n일치하는 경로는 네비게이터에서 여러 화면이 표시되는 결과를 가져올 수 있습니다. 이는 push()를 호출한 것과 동일한 효과이며, 새 화면이 이전 화면 위에 표시되고 AppBar 위젯에 인앱 뒤로 가기 버튼이 제공됩니다.\n\n<div class=\"content-ad\"></div>\n\n다음과 같이 부모 라우트와 그 자식 라우트를 추가해 보세요:\n\n```js\nGoRoute(\n  path: '/fruits',\n  builder: (context, state) {\n    return FruitsPage();\n  },\n  routes: <RouteBase>[ // 자식 라우트 추가\n    GoRoute(\n      path: 'fruits-details', // 참고: 라우터의 부모에 \"/\" 문자를 명시할 필요가 없습니다.\n      builder: (context, state) {\n        return FruitDetailsPage();\n      },\n    ),\n  ],\n)\n```\n\n# 화면 간 이동\n\ngo_router를 사용하여 목적지 간에 이동하는 다양한 방법이 있습니다.\n\n<div class=\"content-ad\"></div>\n\n새 화면으로 이동하려면 URL과 함께 context.go()를 호출하십시오:\n\n```js\nbuild(BuildContext context) {\n  return TextButton(\n    onPressed: () => context.go('/fruits/fruit-detail'),\n  );\n}\n```\n\nURL 대신 이름을 사용하여 탐색할 수도 있습니다. context.goNamed()를 호출하면 됩니다.\n\n```js\nbuild(BuildContext context) {\n  return TextButton(\n    // 라우트에 \"name\"을 추가하지 않으면 오류가 발생할 수 있습니다\n    onPressed: () => context.goNamed('fruit-detail'),\n  );\n}\n```\n\n<div class=\"content-ad\"></div>\n\nURI에 경로 매개변수를 포함하여 만들려면 Uri 클래스를 사용할 수 있어요:\n\n```js\ncontext.go(\n  Uri(\n    path: '/fruit-detail',\n    pathParameters: {'id': '10'},\n  ).toString(),\n);\n```\n\ncontext.pop()을 사용하면 현재 화면에서 뒤로 이동할 수 있어요.\n\n# 중첩된 탭 탐색\n\n<div class=\"content-ad\"></div>\n\n일부 앱은 화면의 하위 섹션에 목적지를 표시합니다. 예를 들어, 화면 간을 이동할 때 항상 화면 상에 남아 있는 BottomNavigationBar와 같은 경우입니다.\n\nStatefulShellRoute를 사용하여 중첩된 탐색을 설정했습니다.\n\n이 StatefulShellRoute 클래스는 루트 네비게이터와 다른 네비게이터에 하위 루트를 배치합니다. 그러나 이 루트 클래스는 각 중첩 분기에 대해 별도의 네비게이터를 생성하므로 (즉, 병렬 탐색 트리), 상태가 있는 중첩된 네비게이션을 구축할 수 있습니다.\n\n예를 들어 BottomNavigationBar를 구현하는 경우, 각 탭에 대한 지속적인 네비게이션 상태가 있는 UI를 구현하는 것이 편리합니다.\n\n<div class=\"content-ad\"></div>\n\n상태 유지 쉘 라우트는 상태 유지 브랜치를 나타내는 각각의 StatefulShellBranch 항목 목록을 지정하여 생성됩니다. StatefulShellBranch는 브랜치를 위한 루트 라우트와 네비게이터 키 (GlobalKey) 및 선택적 초기 위치를 제공합니다.\n\n구현 방법을 살펴보겠습니다 🙂\n\n먼저 라우터를 만들어 시작합니다. StatefulShellRoute.indexedStack()을 라우트에 추가할 것이며, 이 클래스는 중첩된 내비게이션을 생성하는 역할을 맡게 됩니다.\n\nStatefulShellRoute.indexedStack()은 중첩된 네비게이터에 IndexedStack을 사용하는 StatefulShellRoute를 생성합니다.\n\n<div class=\"content-ad\"></div>\n\n이 생성자는 분기 네비게이터를 나타내는 위젯을 관리하는 컨테이너(navigatorContainerBuilder)에 대한 IndexedStack 기반 구현을 제공합니다.\n\n```dart\n// `root` 및 `section` 네비게이터를 위한 키 생성하여 불필요한 재구성을 피합니다\nfinal _rootNavigatorKey = GlobalKey<NavigatorState>();\nfinal _sectionNavigatorKey = GlobalKey<NavigatorState>();\n\n\nfinal router = GoRouter(\n  navigatorKey: _rootNavigatorKey,\n  initialLocation: '/home',\n  routes: <RouteBase>[\n    StatefulShellRoute.indexedStack(\n      builder: (context, state, navigationShell) {\n        // 커스텀 쉘(예: BottomNavigationBar)을 구현하는 위젯을 반환합니다.\n        // 다른 분기로 상태를 유지하면서 이동할 수 있도록 [StatefulNavigationShell]이 전달됩니다.\n        return ScaffoldWithNavbar(navigationShell);\n      },\n      branches: [\n        // 1번 탭을 위한 루트 분기\n        StatefulShellBranch(\n          navigatorKey: _sectionNavigatorKey,\n          // 이 분기의 루트 추가\n          // 가능한 경우 하위 루트가 있는 각 루트(예: feed/uuid/details)를 추가합니다\n          routes: <RouteBase>[\n            GoRoute(\n              path: '/shope',\n              builder: (context, state) => const ShopePage(),\n              routes: <RouteBase>[\n                GoRoute(\n                  path: 'detail',\n                  builder: (context, state) => const FeedDetailsPage(),\n                )\n              ],\n            ),\n          ],\n        ),\n\n        // 2번 탭을 위한 루트 분기\n        StatefulShellBranch(routes: <RouteBase>[\n          // 이 분기의 루트 추가\n          // 가능한 경우 하위 루트가 있는 각 루트(예: shope/uuid/details)를 추가합니다\n          GoRoute(\n            path: '/home',\n            builder: (context, state) => const HomePage(),\n          ),\n        ])\n      ],\n    ),\n  ],\n);\r\n```\n\n우리의 루트에 StatefulShellRoute.indexedStack()를 추가했습니다. 이것은 우리의 분기를 생성하고 사용자 정의 쉘(이 경우 BottomNavigationBar)을 반환합니다.\n\n- 빌더: (context, state, navigationShell)에서는 사용자 정의 쉘인 Scaffold with BottomNavigationBar를 반환하며, 이 페이지로 이동할 때 navigationShell을 전달해야 합니다(예: Shope == Home).\n- branches:[]에서는 StatefulShellBranch(분기) 목록을 제공합니다. 이전에 생성한 _sectionNavigatorKey를 첫 번째 분기에 navigatorKey 속성으로 전달하지만, 다른 분기에는 기본 키가 사용됩니다. 또한 해당 분기에 대한 지원 루트 목록인 RouteBase 목록을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n우리의 빌더가 커스텀 쉘을 반환하는 것을 확인할 수 있습니다. 이 쉘에는 BottomNavigationBar가 포함되어 있어요. 그러니 이제 그것을 만들어 봅시다. 👇🏿\n\n```js\nimport 'package:flutter/material.dart';\nimport 'package:go_router/go_router.dart';\n\nclass ScaffoldWithNavbar extends StatelessWidget {\n  const ScaffoldWithNavbar(this.navigationShell, {super.key});\n\n  /// 브랜치 네비게이터를 위한 네비게이션 쉘 및 컨테이너입니다.\n  final StatefulNavigationShell navigationShell;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: navigationShell,\n      bottomNavigationBar: BottomNavigationBar(\n        currentIndex: navigationShell.currentIndex,\n        items: const [\n          BottomNavigationBarItem(icon: Icon(Icons.shop), label: 'Shope'),\n          BottomNavigationBarItem(icon: Icon(Icons.home), label: 'Home'),\n        ],\n        onTap: _onTap,\n      ),\n    );\n  }\n\n  void _onTap(index) {\n    navigationShell.goBranch(\n      index,\n      // 바텀 네비게이션 바를 사용할 때 일반적인 패턴은 현재 활성화된 아이템을 탭했을 때 초기 위치로 이동하는 것을 지원하는 것입니다. 이 예제에서는 goBranch의 initialLocation 매개변수를 사용하여 이 동작을 지원하는 방법을 보여줍니다.\n      initialLocation: index == navigationShell.currentIndex,\n    );\n  }\n}\n```\n\n기본적으로 BottomNavigationBar가 있는 Scaffold를 반환하며, 본문은 라우터에서 얻은 navigationShell이 될 것입니다.\n\n또한 `_onTap(index)`가 있습니다. 여기서는 `navigationShell.goBranch(index)`를 사용하여 브랜치 간에 전환할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n그럼 이제 여러분의 프로젝트에 이를 구현할 준비가 끝났어요 🥳🎉\n\n자세한 예시는 아래의 저장소를 확인해주세요 👇🏿\n\n# Guards\n\n특정 경로를 보호하기 위해, 예를 들어 인증되지 않은 사용자로부터, GoRouter를 통해 전역 리디렉션이 설정될 수 있습니다. 가장 일반적인 예는 /login이 아닌 모든 경로를 보호하는 리디렉트 설정이며, 사용자가 인증되지 않은 경우 /login으로 리디렉트됩니다.\n\n<div class=\"content-ad\"></div>\n\n리다이렉션은 GoRouterRedirect 유형의 콜백입니다. 일부 응용 프로그램 상태에 따라서 들어오는 위치를 변경하려면 GoRouter 또는 GoRoute 생성자에 콜백을 추가하세요:\n\n```js\nGoRouter(\n  redirect: (BuildContext context, GoRouterState state) {\n    final isAuthenticated = // 사용자가 인증되었는지 확인하는 논리를 여기에 작성하세요\n    if (!isAuthenticated) {\n      return '/login';\n    } else {\n      return null; // 리디렉트 없이 의도한 경로를 표시하려면 \"null\"을 반환하세요\n    }\n  },\n  ...\n```\n\n- GoRouter 생성자에서 리다이렉트를 정의할 수 있습니다. 모든 탐색 이벤트보다 먼저 호출됩니다.\n- GoRoute 생성자에서 리다이렉트를 정의할 수 있습니다. 탐색 이벤트가 경로를 표시하기 직전에 호출됩니다.\n\n# 전환 애니메이션\n\n<div class=\"content-ad\"></div>\n\nGoRouter를 사용하면 각 GoRoute에 대한 전환 애니메이션을 사용자 정의할 수 있어요. 사용자 정의 전환 애니메이션을 구성하려면 GoRoute 생성자에 pageBuilder 매개변수를 제공하세요:\n\n```js\nGoRoute(\n  path: '/fruit-details',\n  pageBuilder: (context, state) {\n    return CustomTransitionPage(\n      key: state.pageKey,\n      child: FruitDetailsScreen(),\n      transitionsBuilder: (context, animation, secondaryAnimation, child) {\n        // 애니메이션의 값에 따라 화면의 불투명도를 변경합니다. \n        return FadeTransition(\n          opacity: CurveTween(curve: Curves.easeInOutCirc).animate(animation),\n          child: child,\n        );\n      },\n    );\n  },\n),\n```\n\n전체 예제는 전환 애니메이션 샘플을 참조하세요.\n\n# 에러 처리 (404 페이지)\n\n<div class=\"content-ad\"></div>\n\n기본적으로, go_router는 MaterialApp 및 CupertinoApp용 기본 오류 화면과 사용되지 않는 경우의 기본 오류 화면이 함께 제공됩니다. 또한 errorBuilder 매개변수를 사용하여 기본 오류 화면을 대체할 수도 있습니다:\n\n```js\nGoRouter(\n  /* ... */\n  errorBuilder: (context, state) => ErrorPage(state.error),\n);\n```\n\n# 이전에 이동하기 전에 !!\n\ngo_router에는 아직도 좋은 기능이 있습니다. GoRouter에 NavigatorObserver를 추가하여 Navigator의 동작을 관찰하고 route가 푸시, 팝 또는 대체될 때마다 알림을 받습니다. 이를 위해 NavigatorObserver를 확장하는 클래스를 만들어 보겠습니다:\n\n<div class=\"content-ad\"></div>\n\n```dart\nclass MyNavigatorObserver extends NavigatorObserver {\n  @override\n  void didPush(Route<dynamic> route, Route<dynamic>? previousRoute) {\n    log('did push route');\n  }\n\n  @override\n  void didPop(Route<dynamic> route, Route<dynamic>? previousRoute) {\n    log('did pop route');\n  }\n```\n\n이제 MyNavigatorObserver를 GoRouter에 추가해 봅시다.\n\n```dart\nGoRouter(\n  ...\n  observers: [ // 내비게이터 옵저버 추가\n    MyNavigatorObserver(),\n  ],\n...\n)\n```\n\n이벤트가 발생하면 내비게이터에 알림이 전달됩니다.\n","ogImage":{"url":"/assets/img/2024-06-19-FlutterGoRouterTheCrucialGuide_0.png"},"coverImage":"/assets/img/2024-06-19-FlutterGoRouterTheCrucialGuide_0.png","tag":["Tech"],"readingTime":10},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-06-19-FlutterGoRouterTheCrucialGuide_0.png\" alt=\"FlutterGoRouter\"></p>\n<p>Go_router은 Flutter에서 라우팅을 위한 서드 파티 패키지로, 기본 플러터 라우팅 옵션보다 더 유연하고 사용하기 쉬운 솔루션을 제공하기 위해 만들어졌습니다. 라우트가 어떻게 정의되고 관리되는지에 대해 더 많은 제어를 원하는 경우 유용할 수 있습니다. 또한 웹에 대한 좋은 지원을 제공하기 때문에 애플리케이션에 좋은 선택일 수 있습니다.</p>\n<p>URL 패턴을 정의하고, URL을 사용하여 탐색하며, 딥 링크를 처리하고, 기타 여러 네비게이션 관련 시나리오를 다룰 수 있습니다.</p>\n<h1>특징</h1>\n<p>고 라우터(GoRouter)는 네비게이션을 간단하게 만들기 위한 다양한 기능을 제공합니다:</p>\n<ul>\n<li>Navigator API와의 하위 호환성</li>\n<li>Material 및 Cupertino 앱을 지원</li>\n<li>StatefulShellRoute를 사용하여 중첩된 탭 탐색 지원</li>\n<li>목적지에 대한 여러 화면 표시 (하위 라우트)</li>\n<li>템플릿 구문을 사용하여 경로 및 쿼리 매개변수 구문 분석</li>\n<li>리디렉션 지원 — 사용자를 다른 URL로 리디렉션할 수 있으며,예를 들어 사용자가 인증되지 않은 경우에는 로그인 페이지로 이동할 수 있습니다.</li>\n</ul>\n<h1>시작하기</h1>\n<p>시작하려면 pubspec.yaml에 go_router를 추가하세요. 이 문서에서는 ^13.2.0을 사용하겠습니다.</p>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-attr\">dependencies:</span>\n  <span class=\"hljs-attr\">go_router:</span> <span class=\"hljs-string\">^13.2.0</span>\n</code></pre>\n<h1>라우트 구성</h1>\n<p>이제 그렇게 한 다음에 GoRouter 구성을 앱에 추가해 봅시다:</p>\n<pre><code class=\"hljs language-dart\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'package:go_router/go_router.dart'</span>;\n\n<span class=\"hljs-comment\">// GoRouter 구성</span>\n<span class=\"hljs-keyword\">final</span> _router = GoRouter(\n  initialLocation: <span class=\"hljs-string\">'/'</span>,\n  routes: [\n    GoRoute(\n      name: <span class=\"hljs-string\">'home'</span>, <span class=\"hljs-comment\">// 선택사항, 라우트에 이름 추가. 경로 대신 이름으로 이동 가능</span>\n      path: <span class=\"hljs-string\">'/'</span>,\n      builder: (context, state) => HomeScreen(),\n    ),\n    GoRoute(\n      name: <span class=\"hljs-string\">'shope'</span>,\n      path: <span class=\"hljs-string\">'/shope'</span>,\n      builder: (context, state) => ShopeScreen(),\n    ),\n  ],\n);\n</code></pre>\n<p>그럼 MaterialApp.router 또는 CupertinoApp.router 생성자를 사용하고 routerConfig 매개변수를 GoRouter 구성 객체로 설정할 수 있어요:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyApp</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">StatelessWidget</span> {\n  @override\n  <span class=\"hljs-title class_\">Widget</span> <span class=\"hljs-title function_\">build</span>(<span class=\"hljs-params\">BuildContext context</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">MaterialApp</span>.<span class=\"hljs-title function_\">router</span>(\n      <span class=\"hljs-attr\">routerConfig</span>: _router,\n    );\n  }\n}\n</code></pre>\n<p>이것으로 준비 끝이에요 🙂 go_router를 사용해보세요 !!!</p>\n<h1>매개변수</h1>\n<p>경로 매개변수를 지정하려면 경로 세그먼트 앞에 콜론(:) 문자를 붙이고 고유한 이름(:userId와 같은)을 따라야 합니다. 빌더 콜백에 제공된 GoRouterState 객체를 통해 매개변수 값을 액세스할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">GoRoute</span>(\n  <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">'/fruits/:id'</span>,\n  <span class=\"hljs-attr\">builder</span>: (context, state) {\n     final id = state.<span class=\"hljs-property\">pathParameters</span>[<span class=\"hljs-string\">\"id\"</span>]! <span class=\"hljs-comment\">// URL에서 \"id\" 매개변수 가져오기</span>\n     <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">FruitsPage</span>(<span class=\"hljs-attr\">id</span>: id);\n  },\n),\n</code></pre>\n<h1>하위 루트 추가</h1>\n<p>일치하는 경로는 네비게이터에서 여러 화면이 표시되는 결과를 가져올 수 있습니다. 이는 push()를 호출한 것과 동일한 효과이며, 새 화면이 이전 화면 위에 표시되고 AppBar 위젯에 인앱 뒤로 가기 버튼이 제공됩니다.</p>\n<p>다음과 같이 부모 라우트와 그 자식 라우트를 추가해 보세요:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">GoRoute</span>(\n  <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">'/fruits'</span>,\n  <span class=\"hljs-attr\">builder</span>: (context, state) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">FruitsPage</span>();\n  },\n  <span class=\"hljs-attr\">routes</span>: &#x3C;<span class=\"hljs-title class_\">RouteBase</span>>[ <span class=\"hljs-comment\">// 자식 라우트 추가</span>\n    <span class=\"hljs-title class_\">GoRoute</span>(\n      <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">'fruits-details'</span>, <span class=\"hljs-comment\">// 참고: 라우터의 부모에 \"/\" 문자를 명시할 필요가 없습니다.</span>\n      <span class=\"hljs-attr\">builder</span>: (context, state) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">FruitDetailsPage</span>();\n      },\n    ),\n  ],\n)\n</code></pre>\n<h1>화면 간 이동</h1>\n<p>go_router를 사용하여 목적지 간에 이동하는 다양한 방법이 있습니다.</p>\n<p>새 화면으로 이동하려면 URL과 함께 context.go()를 호출하십시오:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">build</span>(<span class=\"hljs-params\">BuildContext context</span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">TextButton</span>(\n    <span class=\"hljs-attr\">onPressed</span>: <span class=\"hljs-function\">() =></span> context.<span class=\"hljs-title function_\">go</span>(<span class=\"hljs-string\">'/fruits/fruit-detail'</span>),\n  );\n}\n</code></pre>\n<p>URL 대신 이름을 사용하여 탐색할 수도 있습니다. context.goNamed()를 호출하면 됩니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">build</span>(<span class=\"hljs-params\">BuildContext context</span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">TextButton</span>(\n    <span class=\"hljs-comment\">// 라우트에 \"name\"을 추가하지 않으면 오류가 발생할 수 있습니다</span>\n    <span class=\"hljs-attr\">onPressed</span>: <span class=\"hljs-function\">() =></span> context.<span class=\"hljs-title function_\">goNamed</span>(<span class=\"hljs-string\">'fruit-detail'</span>),\n  );\n}\n</code></pre>\n<p>URI에 경로 매개변수를 포함하여 만들려면 Uri 클래스를 사용할 수 있어요:</p>\n<pre><code class=\"hljs language-js\">context.<span class=\"hljs-title function_\">go</span>(\n  <span class=\"hljs-title class_\">Uri</span>(\n    <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">'/fruit-detail'</span>,\n    <span class=\"hljs-attr\">pathParameters</span>: {<span class=\"hljs-string\">'id'</span>: <span class=\"hljs-string\">'10'</span>},\n  ).<span class=\"hljs-title function_\">toString</span>(),\n);\n</code></pre>\n<p>context.pop()을 사용하면 현재 화면에서 뒤로 이동할 수 있어요.</p>\n<h1>중첩된 탭 탐색</h1>\n<p>일부 앱은 화면의 하위 섹션에 목적지를 표시합니다. 예를 들어, 화면 간을 이동할 때 항상 화면 상에 남아 있는 BottomNavigationBar와 같은 경우입니다.</p>\n<p>StatefulShellRoute를 사용하여 중첩된 탐색을 설정했습니다.</p>\n<p>이 StatefulShellRoute 클래스는 루트 네비게이터와 다른 네비게이터에 하위 루트를 배치합니다. 그러나 이 루트 클래스는 각 중첩 분기에 대해 별도의 네비게이터를 생성하므로 (즉, 병렬 탐색 트리), 상태가 있는 중첩된 네비게이션을 구축할 수 있습니다.</p>\n<p>예를 들어 BottomNavigationBar를 구현하는 경우, 각 탭에 대한 지속적인 네비게이션 상태가 있는 UI를 구현하는 것이 편리합니다.</p>\n<p>상태 유지 쉘 라우트는 상태 유지 브랜치를 나타내는 각각의 StatefulShellBranch 항목 목록을 지정하여 생성됩니다. StatefulShellBranch는 브랜치를 위한 루트 라우트와 네비게이터 키 (GlobalKey) 및 선택적 초기 위치를 제공합니다.</p>\n<p>구현 방법을 살펴보겠습니다 🙂</p>\n<p>먼저 라우터를 만들어 시작합니다. StatefulShellRoute.indexedStack()을 라우트에 추가할 것이며, 이 클래스는 중첩된 내비게이션을 생성하는 역할을 맡게 됩니다.</p>\n<p>StatefulShellRoute.indexedStack()은 중첩된 네비게이터에 IndexedStack을 사용하는 StatefulShellRoute를 생성합니다.</p>\n<p>이 생성자는 분기 네비게이터를 나타내는 위젯을 관리하는 컨테이너(navigatorContainerBuilder)에 대한 IndexedStack 기반 구현을 제공합니다.</p>\n<pre><code class=\"hljs language-dart\"><span class=\"hljs-comment\">// `root` 및 `section` 네비게이터를 위한 키 생성하여 불필요한 재구성을 피합니다</span>\n<span class=\"hljs-keyword\">final</span> _rootNavigatorKey = GlobalKey&#x3C;NavigatorState>();\n<span class=\"hljs-keyword\">final</span> _sectionNavigatorKey = GlobalKey&#x3C;NavigatorState>();\n\n\n<span class=\"hljs-keyword\">final</span> router = GoRouter(\n  navigatorKey: _rootNavigatorKey,\n  initialLocation: <span class=\"hljs-string\">'/home'</span>,\n  routes: &#x3C;RouteBase>[\n    StatefulShellRoute.indexedStack(\n      builder: (context, state, navigationShell) {\n        <span class=\"hljs-comment\">// 커스텀 쉘(예: BottomNavigationBar)을 구현하는 위젯을 반환합니다.</span>\n        <span class=\"hljs-comment\">// 다른 분기로 상태를 유지하면서 이동할 수 있도록 [StatefulNavigationShell]이 전달됩니다.</span>\n        <span class=\"hljs-keyword\">return</span> ScaffoldWithNavbar(navigationShell);\n      },\n      branches: [\n        <span class=\"hljs-comment\">// 1번 탭을 위한 루트 분기</span>\n        StatefulShellBranch(\n          navigatorKey: _sectionNavigatorKey,\n          <span class=\"hljs-comment\">// 이 분기의 루트 추가</span>\n          <span class=\"hljs-comment\">// 가능한 경우 하위 루트가 있는 각 루트(예: feed/uuid/details)를 추가합니다</span>\n          routes: &#x3C;RouteBase>[\n            GoRoute(\n              path: <span class=\"hljs-string\">'/shope'</span>,\n              builder: (context, state) => <span class=\"hljs-keyword\">const</span> ShopePage(),\n              routes: &#x3C;RouteBase>[\n                GoRoute(\n                  path: <span class=\"hljs-string\">'detail'</span>,\n                  builder: (context, state) => <span class=\"hljs-keyword\">const</span> FeedDetailsPage(),\n                )\n              ],\n            ),\n          ],\n        ),\n\n        <span class=\"hljs-comment\">// 2번 탭을 위한 루트 분기</span>\n        StatefulShellBranch(routes: &#x3C;RouteBase>[\n          <span class=\"hljs-comment\">// 이 분기의 루트 추가</span>\n          <span class=\"hljs-comment\">// 가능한 경우 하위 루트가 있는 각 루트(예: shope/uuid/details)를 추가합니다</span>\n          GoRoute(\n            path: <span class=\"hljs-string\">'/home'</span>,\n            builder: (context, state) => <span class=\"hljs-keyword\">const</span> HomePage(),\n          ),\n        ])\n      ],\n    ),\n  ],\n);\n</code></pre>\n<p>우리의 루트에 StatefulShellRoute.indexedStack()를 추가했습니다. 이것은 우리의 분기를 생성하고 사용자 정의 쉘(이 경우 BottomNavigationBar)을 반환합니다.</p>\n<ul>\n<li>빌더: (context, state, navigationShell)에서는 사용자 정의 쉘인 Scaffold with BottomNavigationBar를 반환하며, 이 페이지로 이동할 때 navigationShell을 전달해야 합니다(예: Shope == Home).</li>\n<li>branches:[]에서는 StatefulShellBranch(분기) 목록을 제공합니다. 이전에 생성한 _sectionNavigatorKey를 첫 번째 분기에 navigatorKey 속성으로 전달하지만, 다른 분기에는 기본 키가 사용됩니다. 또한 해당 분기에 대한 지원 루트 목록인 RouteBase 목록을 제공합니다.</li>\n</ul>\n<p>우리의 빌더가 커스텀 쉘을 반환하는 것을 확인할 수 있습니다. 이 쉘에는 BottomNavigationBar가 포함되어 있어요. 그러니 이제 그것을 만들어 봅시다. 👇🏿</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'package:flutter/material.dart'</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'package:go_router/go_router.dart'</span>;\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ScaffoldWithNavbar</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">StatelessWidget</span> {\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">ScaffoldWithNavbar</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">navigationShell</span>, {<span class=\"hljs-variable language_\">super</span>.<span class=\"hljs-property\">key</span>});\n\n  <span class=\"hljs-comment\">/// 브랜치 네비게이터를 위한 네비게이션 쉘 및 컨테이너입니다.</span>\n  final <span class=\"hljs-title class_\">StatefulNavigationShell</span> navigationShell;\n\n  @override\n  <span class=\"hljs-title class_\">Widget</span> <span class=\"hljs-title function_\">build</span>(<span class=\"hljs-params\">BuildContext context</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Scaffold</span>(\n      <span class=\"hljs-attr\">body</span>: navigationShell,\n      <span class=\"hljs-attr\">bottomNavigationBar</span>: <span class=\"hljs-title class_\">BottomNavigationBar</span>(\n        <span class=\"hljs-attr\">currentIndex</span>: navigationShell.<span class=\"hljs-property\">currentIndex</span>,\n        <span class=\"hljs-attr\">items</span>: <span class=\"hljs-keyword\">const</span> [\n          <span class=\"hljs-title class_\">BottomNavigationBarItem</span>(<span class=\"hljs-attr\">icon</span>: <span class=\"hljs-title class_\">Icon</span>(<span class=\"hljs-title class_\">Icons</span>.<span class=\"hljs-property\">shop</span>), <span class=\"hljs-attr\">label</span>: <span class=\"hljs-string\">'Shope'</span>),\n          <span class=\"hljs-title class_\">BottomNavigationBarItem</span>(<span class=\"hljs-attr\">icon</span>: <span class=\"hljs-title class_\">Icon</span>(<span class=\"hljs-title class_\">Icons</span>.<span class=\"hljs-property\">home</span>), <span class=\"hljs-attr\">label</span>: <span class=\"hljs-string\">'Home'</span>),\n        ],\n        <span class=\"hljs-attr\">onTap</span>: _onTap,\n      ),\n    );\n  }\n\n  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">_onTap</span>(<span class=\"hljs-params\">index</span>) {\n    navigationShell.<span class=\"hljs-title function_\">goBranch</span>(\n      index,\n      <span class=\"hljs-comment\">// 바텀 네비게이션 바를 사용할 때 일반적인 패턴은 현재 활성화된 아이템을 탭했을 때 초기 위치로 이동하는 것을 지원하는 것입니다. 이 예제에서는 goBranch의 initialLocation 매개변수를 사용하여 이 동작을 지원하는 방법을 보여줍니다.</span>\n      <span class=\"hljs-attr\">initialLocation</span>: index == navigationShell.<span class=\"hljs-property\">currentIndex</span>,\n    );\n  }\n}\n</code></pre>\n<p>기본적으로 BottomNavigationBar가 있는 Scaffold를 반환하며, 본문은 라우터에서 얻은 navigationShell이 될 것입니다.</p>\n<p>또한 <code>_onTap(index)</code>가 있습니다. 여기서는 <code>navigationShell.goBranch(index)</code>를 사용하여 브랜치 간에 전환할 수 있습니다.</p>\n<p>그럼 이제 여러분의 프로젝트에 이를 구현할 준비가 끝났어요 🥳🎉</p>\n<p>자세한 예시는 아래의 저장소를 확인해주세요 👇🏿</p>\n<h1>Guards</h1>\n<p>특정 경로를 보호하기 위해, 예를 들어 인증되지 않은 사용자로부터, GoRouter를 통해 전역 리디렉션이 설정될 수 있습니다. 가장 일반적인 예는 /login이 아닌 모든 경로를 보호하는 리디렉트 설정이며, 사용자가 인증되지 않은 경우 /login으로 리디렉트됩니다.</p>\n<p>리다이렉션은 GoRouterRedirect 유형의 콜백입니다. 일부 응용 프로그램 상태에 따라서 들어오는 위치를 변경하려면 GoRouter 또는 GoRoute 생성자에 콜백을 추가하세요:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">GoRouter</span>(\n  <span class=\"hljs-attr\">redirect</span>: (<span class=\"hljs-title class_\">BuildContext</span> context, <span class=\"hljs-title class_\">GoRouterState</span> state) {\n    final isAuthenticated = <span class=\"hljs-comment\">// 사용자가 인증되었는지 확인하는 논리를 여기에 작성하세요</span>\n    <span class=\"hljs-keyword\">if</span> (!isAuthenticated) {\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'/login'</span>;\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>; <span class=\"hljs-comment\">// 리디렉트 없이 의도한 경로를 표시하려면 \"null\"을 반환하세요</span>\n    }\n  },\n  ...\n</code></pre>\n<ul>\n<li>GoRouter 생성자에서 리다이렉트를 정의할 수 있습니다. 모든 탐색 이벤트보다 먼저 호출됩니다.</li>\n<li>GoRoute 생성자에서 리다이렉트를 정의할 수 있습니다. 탐색 이벤트가 경로를 표시하기 직전에 호출됩니다.</li>\n</ul>\n<h1>전환 애니메이션</h1>\n<p>GoRouter를 사용하면 각 GoRoute에 대한 전환 애니메이션을 사용자 정의할 수 있어요. 사용자 정의 전환 애니메이션을 구성하려면 GoRoute 생성자에 pageBuilder 매개변수를 제공하세요:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">GoRoute</span>(\n  <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">'/fruit-details'</span>,\n  <span class=\"hljs-attr\">pageBuilder</span>: (context, state) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">CustomTransitionPage</span>(\n      <span class=\"hljs-attr\">key</span>: state.<span class=\"hljs-property\">pageKey</span>,\n      <span class=\"hljs-attr\">child</span>: <span class=\"hljs-title class_\">FruitDetailsScreen</span>(),\n      <span class=\"hljs-attr\">transitionsBuilder</span>: (context, animation, secondaryAnimation, child) {\n        <span class=\"hljs-comment\">// 애니메이션의 값에 따라 화면의 불투명도를 변경합니다. </span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">FadeTransition</span>(\n          <span class=\"hljs-attr\">opacity</span>: <span class=\"hljs-title class_\">CurveTween</span>(<span class=\"hljs-attr\">curve</span>: <span class=\"hljs-title class_\">Curves</span>.<span class=\"hljs-property\">easeInOutCirc</span>).<span class=\"hljs-title function_\">animate</span>(animation),\n          <span class=\"hljs-attr\">child</span>: child,\n        );\n      },\n    );\n  },\n),\n</code></pre>\n<p>전체 예제는 전환 애니메이션 샘플을 참조하세요.</p>\n<h1>에러 처리 (404 페이지)</h1>\n<p>기본적으로, go_router는 MaterialApp 및 CupertinoApp용 기본 오류 화면과 사용되지 않는 경우의 기본 오류 화면이 함께 제공됩니다. 또한 errorBuilder 매개변수를 사용하여 기본 오류 화면을 대체할 수도 있습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">GoRouter</span>(\n  <span class=\"hljs-comment\">/* ... */</span>\n  <span class=\"hljs-attr\">errorBuilder</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">context, state</span>) =></span> <span class=\"hljs-title class_\">ErrorPage</span>(state.<span class=\"hljs-property\">error</span>),\n);\n</code></pre>\n<h1>이전에 이동하기 전에 !!</h1>\n<p>go_router에는 아직도 좋은 기능이 있습니다. GoRouter에 NavigatorObserver를 추가하여 Navigator의 동작을 관찰하고 route가 푸시, 팝 또는 대체될 때마다 알림을 받습니다. 이를 위해 NavigatorObserver를 확장하는 클래스를 만들어 보겠습니다:</p>\n<pre><code class=\"hljs language-dart\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyNavigatorObserver</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">NavigatorObserver</span> </span>{\n  <span class=\"hljs-meta\">@override</span>\n  <span class=\"hljs-keyword\">void</span> didPush(Route&#x3C;<span class=\"hljs-built_in\">dynamic</span>> route, Route&#x3C;<span class=\"hljs-built_in\">dynamic</span>>? previousRoute) {\n    log(<span class=\"hljs-string\">'did push route'</span>);\n  }\n\n  <span class=\"hljs-meta\">@override</span>\n  <span class=\"hljs-keyword\">void</span> didPop(Route&#x3C;<span class=\"hljs-built_in\">dynamic</span>> route, Route&#x3C;<span class=\"hljs-built_in\">dynamic</span>>? previousRoute) {\n    log(<span class=\"hljs-string\">'did pop route'</span>);\n  }\n</code></pre>\n<p>이제 MyNavigatorObserver를 GoRouter에 추가해 봅시다.</p>\n<pre><code class=\"hljs language-dart\">GoRouter(\n  ...\n  observers: [ <span class=\"hljs-comment\">// 내비게이터 옵저버 추가</span>\n    MyNavigatorObserver(),\n  ],\n...\n)\n</code></pre>\n<p>이벤트가 발생하면 내비게이터에 알림이 전달됩니다.</p>\n</body>\n</html>\n"},"__N_SSG":true}