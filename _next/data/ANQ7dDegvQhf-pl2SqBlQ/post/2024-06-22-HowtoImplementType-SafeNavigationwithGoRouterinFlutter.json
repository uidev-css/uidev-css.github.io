{"pageProps":{"post":{"title":"Flutter에서 Go Router를 사용해 타입-안전 내비게이션 구현하는 방법","description":"","date":"2024-06-22 04:10","slug":"2024-06-22-HowtoImplementType-SafeNavigationwithGoRouterinFlutter","content":"\n\n## Flutter에서 안전한 탐색: Go Router 및 Go Router Builder와 함께하는 가이드\n\n<img src=\"/assets/img/2024-06-22-HowtoImplementType-SafeNavigationwithGoRouterinFlutter_0.png\" />\n\n# 배경\n\n타입 안전한 네비게이션을 사용하면 탐색 로직이 일관되고 유지보수가 용이해지며 디버깅 및 향후 코드 수정이 상당히 간단해집니다.\n\n<div class=\"content-ad\"></div>\n\n이 기술은 웹용 Flutter 앱을 구축할 때 특히 유용합니다. URL을 원활하게 관리하고 부드러운 네비게이션 경험을 보장해줍니다.\n\n이 블로그에서는 go_router 및 go_router_builder 패키지를 사용하여 Flutter에서 유형 안전한 네비게이션을 구현하는 방법을 살펴볼 것입니다.\n\n종료까지, 유형 안전한 라우트 설정, 코드 생성 및 Flutter 애플리케이션에서 네비게이션을 관리하는 방법에 대해 포괄적으로 이해하게 될 것입니다.\n\n# 소개\n\n<div class=\"content-ad\"></div>\n\n타입 안전한 네비게이션을 사용하면 네비게이션 로직이 일관되고 오류가 없음을 보장합니다.\n\n매개변수를 잘못 구문 분석하거나 경로 이름과 매개변수에 오타를 쓰는 위험을 제거하여 코드를 유지 관리하기 쉽고 디버깅하기 쉬운 상태로 유지할 수 있습니다.\n\n웹을 대상으로 하는 플러터 앱을 개발할 때 타입 안전한 네비게이션을 사용하여 URL을 쉽게 관리할 수 있습니다.\n\n이 블로그를 통해 최종적으로 얻을 것은 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n마크다운 형식으로 테이블 태그를 변경해주세요.\n\n<div class=\"content-ad\"></div>\n\n우리는 우리가 반복적으로 하는 것이다. 훌륭함은 행위가 아니라 습관이다. Justly를 시도해보고 오늘부터 당신의 습관을 만들어보세요!\n\n# 시작해봅시다\n\n전체를 5단계로 나눠서 더 잘 이해할 수 있도록 설명해 드리겠습니다.\n\n## 단계 1: 의존성 추가\n\n<div class=\"content-ad\"></div>\n\n프로젝트의 pubspec.yaml 파일에 종속성을 추가해주세요.\n\n```yaml\ndependencies:\n  # Router API 기반의 내비게이션을 활용하기 위해 필요합니다.\n  go_router: <최신 버전> \n\ndev_dependencies:\n  # go_router와 함께 타입 안전한 경로를 생성하기 위한 도구입니다.\n  go_router_builder: <최신 버전>\n  # go_router_builder의 코드 생성을 실행하는 도구입니다.\n  build_runner: <최신 버전>\n```\n\n## 단계 2: 경로 정의\n\n이제 각 화면에 대한 클래스를 만들어 GoRouteData로 확장하고, 최상위 경로에 @TypedGoRoute() 주석을 추가해주세요.\n\n<div class=\"content-ad\"></div>\n\n모든 클래스를 하나의 파일에 작성하여 코드 생성을 보다 쉽게 할 수 있도록 해 보세요.\n\n```js\n@TypedGoRoute<HomeRoute>(\n  path: '/',\n  routes: [\n    TypedGoRoute<ItemDetailsRoute>(path: 'items/:id')\n  ],\n) \nclass HomeRoute extends GoRouteData {\n  @override\n  Widget build(BuildContext context, GoRouterState state) \n    => const HomeScreen();\n}\n\nclass ItemDetailsRoute extends GoRouteData {\n  final String id;\n  const ItemDetailsRoute({required this.id});\n\n  @override\n  Widget build(BuildContext context, GoRouterState state) =>\n      ItemDetailsScreen(id: id);\n}\n\n@TypedGoRoute<SignInRoute>(\n  path: '/sign-in',\n  routes: [\n    TypedGoRoute<VerifyOtpRoute>(path: \"verify\"),\n  ], \n)\nclass SignInRoute extends GoRouteData {\n  @override\n  Widget build(BuildContext context, GoRouterState state) =>\n      const SignInScreen();\n}\n\nclass VerifyOtpRoute extends GoRouteData {\n  final String $extra;\n\n  const VerifyOtpRoute({required this.$extra});\n\n  @override\n  Widget build(BuildContext context, GoRouterState state) => \n     VerifyOtpScreen(verificationId: $extra);\n}\n```\n\n이 코드에서는 각 화면에 대한 클래스를 GoRouteData를 확장하고 TypedGoRoute로 주석 처리하여 생성했습니다. 또 다른 화면으로 데이터를 전달하기도 했습니다.\n\n자세히 살펴보겠습니다.\n\n<div class=\"content-ad\"></div>\n\nGoRouteData: GoRouteData은 화면이나 페이지를 반환하거나 사용자를 다른 페이지로 리디렉션하는 메서드를 오버라이드할 수 있는 추상 클래스입니다. 이 메서드들 중 하나를 반드시 사용해야 합니다.\n\n```js\nclass HomeRoute extends GoRouteData {\n\n  // 이렇게 parentNavigationKey를 정의할 수 있습니다. (선택 사항)\n  static final GlobalKey<NavigatorState> $parentNavigatorKey = rootNavigatorKey;\n\n  @override\n  Widget build(BuildContext context, GoRouterState state) {\n    // 여기서 반환된 위젯은 사용자가 이 경로로 이동할 때 표시됩니다.\n    return const HomeScreen();\n}\n  \n  @override\n  Page<void> buildPage(BuildContext context, GoRouterState state) {\n    // 여기서 반환된 Page는 사용자가 이 경로로 이동할 때 표시됩니다.\n    // 여기서 CustomTransitionPage를 반환하여 페이지 전환을 설정할 수도 있습니다.\n    return const CupertinoPage(child: HomeScreen());\n  }\n\n  @override\n  String? redirect(BuildContext context, GoRouterState state){\n      // 여기서 이 경로로 이동할 때 사용자를 리디렉션해야 할 위치나 경로를 지정할 수 있습니다.\n      return \"/login\";\n      // 리디렉션을 막으려면 null을 반환하세요.\n  }\n}\n```\n\nTypedGoRoute: TypedGoRoute 어노테이션은 경로 트리를 정의하는 데 사용됩니다. 맨 위 수준 경로 클래스마다 TypedGoRoute를 사용하여 경로 목록을 생성해야 합니다.\n\n```js\n@TypedGoRoute<TopLevelRoute>(\n  path: '/top-level-route-path',\n  routes: [\n    // 여기에 서브 루트 어노테이션을 이렇게 정의할 수 있습니다.\n    TypedGoRoute<SubRoute>(\n        path: 'sub-route-path'\n        routes: []\n        name: 'sub route'\n    )\n  ],\n  name: 'top level route' // 선택 사항\n)\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n@TypedGoRoute<MyRouteGeneric>()\n```\n\n이제 쿼리 매개변수, 경로 매개변수 및 라우트에서 추가 매개변수를 어떻게 사용할 수 있는지 알아봅시다.\n\n경로 매개변수:\n\n- 경로 매개변수는 : 기호를 사용하여 라우트 경로 내에 정의됩니다 (예: /products/:id).\n- URL 구조의 특정 부분을 나타냅니다.\n\n<div class=\"content-ad\"></div>\n\n쿼리 매개변수:\n\n- URL 뒤에 ? 기호를 붙여 데이터를 추가합니다 (예: /products?category=electronics).\n- 요청을 수정하는 선택적인 필터와 같은 데이터에 사용됩니다.\n\n추가: 경로나 쿼리 매개변수로 캡처되지 않는 경로로 데이터를 전달하는 방법, 추가 개체를 전달할 수 있습니다.\n\n```js\n@TypedGoRoute<ProductDetailsRoute>(path: '/details/:id')\nclass ProductDetailsRoute extends GoRouteData {\n  // path에 정의된 변수 이름이 경로 매개변수로 사용됩니다.\n  final String id; \n\n  // path에 정의되지 않은 변수 이름은 쿼리 매개변수로 사용됩니다.\n  final String code;\n\n  // 추가 데이터를 사용하려면 변수 이름을 $extra로 설정해야 합니다.\n  final String $extra;\n  \n  const ProductDetailsRoute({required this.id, required this.code, required this.$extra});\n\n  @override\n  Widget build(BuildContext context, GoRouterState state) =>\n      ProductDetails(pathParameterId: id, queryParameterCode:code, extraData: $extra);\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## 단계 3: 코드 생성\n\n루트를 정의한 후에는 루트 목록과 확장을 생성해야 합니다. 이를 위해 build_runner를 사용해야 합니다.\n현재 파일에 생성된 파일 파트를 추가해 보겠습니다.\n\n```js\npart 'routes.g.dart'; //part '<current-file>.g.dart';\n```\n\n이제 build_runner 명령어를 실행해 봅시다.\n\n<div class=\"content-ad\"></div>\n\n```dart\ndart run build_runner build --delete-conflicting-outputs\n```\n\n현재 파일 디렉토리에 routes.g.dart 파일이 생성됩니다.\n\n## 단계 4: GoRouter 초기화\n\n이제 $appRoutes를 routes에 전달할 수 있으며, 생성된 location getter를 사용하여 정확한 경로 위치를 가져올 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```dart\n최종 라우터는 GoRouter(\n  initialLocation: HomeRoute().location, // location getter is generated.\n  //$appRoutes is generated\n  routes: $appRoutes,\n  redirect: (context, state) { // Optional\n    // 여기서 경로 위치를 반환하여 리디렉션이 가능합니다.\n    // 또한 사용자가 검색 URL을 통해 화면으로 이동하는 것을 방지할 수도 있습니다.\n    // 리디렉트를 방지하려면 null을 반환합니다.\n  }\n  errorBuilder: (context, e) => ErrorScreen(e), // Optional\n  navigatorKey: rootNavigationKey, //Optional\n);\n```\n\n## 단계 5: 다른 화면으로 이동\n\n이제 라우트를 설정했으니, 다른 화면으로 이동하는 네비게이션 방법을 살펴봅시다.\n\n## Go:\n\n<div class=\"content-ad\"></div>\n\n현재 화면 스택을 주어진 경로 대상으로 교체해주세요.\n\n```js\nawait Screen2Route(id: id).go(context);\n```\n\n![이미지](https://miro.medium.com/v2/resize:fit:1000/1*ZO9gaACCAYOszpSV1_gbKQ.gif)\n\n## 푸시:\n\n<div class=\"content-ad\"></div>\n\n페이지 스택에 위치를 푸시하세요.\n\n```js\nawait Screen2Route(id: id).push(context);\n\n// push 과정에서 값 반환도 가능합니다\nfinal result = await Screen2Route(id: id).push(context);\n```\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1000/1*_xSN1WMXDp7Oc92CBl6HMA.gif\" />\n\n## Push Replacement:\n\n<div class=\"content-ad\"></div>\n\n가장 위에 있는 페이지 스택을 해당 URL 위치로 대체합니다.\n\n```js\nawait Screen2Route(id: id).pushReplacement(context);\n```\n\n![이미지](https://miro.medium.com/v2/resize:fit:1000/1*GNaChKuABcE4PejKUFFe9A.gif)\n\n## 대체:\n\n<div class=\"content-ad\"></div>\n\n가장 상단의 스택 페이지를 주어진 페이지로 교체하지만, 동일한 페이지로 취급합니다.\n\n```js\nawait Screen2Route(id: id).replace(context);\n```\n\n![이미지](https://miro.medium.com/v2/resize:fit:1000/1*_S9SyTnfBPEFAUMNloXz1g.gif)\n\n이제 네비게이션 구현을 마쳤습니다. 👏\n\n<div class=\"content-ad\"></div>\n\n\n![image](https://miro.medium.com/v2/resize:fit:1000/0*QwBEMwvqVkuL2OUM.gif)\n\nNow, let’s take a look at how we can implement a shell route with type-safe navigation using go_router and go_router_builder.\n\n## Related Articles\n\nWe're grateful to have you on this journey with us!\n\n\n<div class=\"content-ad\"></div>\n\n만약 읽은 내용이 마음에 드신다면, 아래에 👏 👏👏를 꼭 눌러주시기 바랍니다. 작가로서 이것은 정말 소중한 일이에요!\n\n아래 댓글 섹션에서 의견을 공유해주세요. 여러분의 의견은 콘텐츠를 더욱 풍부하고 가치 있는 것으로 만들어주며, 더 많은 유익한 기사를 작성할 동기를 얻게 해줍니다.\n\n흥미로운 기사 업데이트를 받으시려면 Canopas를 팔로우해주세요!","ogImage":{"url":"/assets/img/2024-06-22-HowtoImplementType-SafeNavigationwithGoRouterinFlutter_0.png"},"coverImage":"/assets/img/2024-06-22-HowtoImplementType-SafeNavigationwithGoRouterinFlutter_0.png","tag":["Tech"],"readingTime":8},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<h2>Flutter에서 안전한 탐색: Go Router 및 Go Router Builder와 함께하는 가이드</h2>\n<h1>배경</h1>\n<p>타입 안전한 네비게이션을 사용하면 탐색 로직이 일관되고 유지보수가 용이해지며 디버깅 및 향후 코드 수정이 상당히 간단해집니다.</p>\n<p>이 기술은 웹용 Flutter 앱을 구축할 때 특히 유용합니다. URL을 원활하게 관리하고 부드러운 네비게이션 경험을 보장해줍니다.</p>\n<p>이 블로그에서는 go_router 및 go_router_builder 패키지를 사용하여 Flutter에서 유형 안전한 네비게이션을 구현하는 방법을 살펴볼 것입니다.</p>\n<p>종료까지, 유형 안전한 라우트 설정, 코드 생성 및 Flutter 애플리케이션에서 네비게이션을 관리하는 방법에 대해 포괄적으로 이해하게 될 것입니다.</p>\n<h1>소개</h1>\n<p>타입 안전한 네비게이션을 사용하면 네비게이션 로직이 일관되고 오류가 없음을 보장합니다.</p>\n<p>매개변수를 잘못 구문 분석하거나 경로 이름과 매개변수에 오타를 쓰는 위험을 제거하여 코드를 유지 관리하기 쉽고 디버깅하기 쉬운 상태로 유지할 수 있습니다.</p>\n<p>웹을 대상으로 하는 플러터 앱을 개발할 때 타입 안전한 네비게이션을 사용하여 URL을 쉽게 관리할 수 있습니다.</p>\n<p>이 블로그를 통해 최종적으로 얻을 것은 무엇인가요?</p>\n<p>마크다운 형식으로 테이블 태그를 변경해주세요.</p>\n<p>우리는 우리가 반복적으로 하는 것이다. 훌륭함은 행위가 아니라 습관이다. Justly를 시도해보고 오늘부터 당신의 습관을 만들어보세요!</p>\n<h1>시작해봅시다</h1>\n<p>전체를 5단계로 나눠서 더 잘 이해할 수 있도록 설명해 드리겠습니다.</p>\n<h2>단계 1: 의존성 추가</h2>\n<p>프로젝트의 pubspec.yaml 파일에 종속성을 추가해주세요.</p>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-attr\">dependencies:</span>\n  <span class=\"hljs-comment\"># Router API 기반의 내비게이션을 활용하기 위해 필요합니다.</span>\n  <span class=\"hljs-attr\">go_router:</span> <span class=\"hljs-string\">&#x3C;최신</span> <span class=\"hljs-string\">버전></span> \n\n<span class=\"hljs-attr\">dev_dependencies:</span>\n  <span class=\"hljs-comment\"># go_router와 함께 타입 안전한 경로를 생성하기 위한 도구입니다.</span>\n  <span class=\"hljs-attr\">go_router_builder:</span> <span class=\"hljs-string\">&#x3C;최신</span> <span class=\"hljs-string\">버전></span>\n  <span class=\"hljs-comment\"># go_router_builder의 코드 생성을 실행하는 도구입니다.</span>\n  <span class=\"hljs-attr\">build_runner:</span> <span class=\"hljs-string\">&#x3C;최신</span> <span class=\"hljs-string\">버전></span>\n</code></pre>\n<h2>단계 2: 경로 정의</h2>\n<p>이제 각 화면에 대한 클래스를 만들어 GoRouteData로 확장하고, 최상위 경로에 @TypedGoRoute() 주석을 추가해주세요.</p>\n<p>모든 클래스를 하나의 파일에 작성하여 코드 생성을 보다 쉽게 할 수 있도록 해 보세요.</p>\n<pre><code class=\"hljs language-js\">@<span class=\"hljs-title class_\">TypedGoRoute</span>&#x3C;<span class=\"hljs-title class_\">HomeRoute</span>>(\n  <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">'/'</span>,\n  <span class=\"hljs-attr\">routes</span>: [\n    <span class=\"hljs-title class_\">TypedGoRoute</span>&#x3C;<span class=\"hljs-title class_\">ItemDetailsRoute</span>>(<span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">'items/:id'</span>)\n  ],\n) \n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HomeRoute</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">GoRouteData</span> {\n  @override\n  <span class=\"hljs-title class_\">Widget</span> <span class=\"hljs-title function_\">build</span>(<span class=\"hljs-title class_\">BuildContext</span> context, <span class=\"hljs-title class_\">GoRouterState</span> state) \n    => <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">HomeScreen</span>();\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ItemDetailsRoute</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">GoRouteData</span> {\n  final <span class=\"hljs-title class_\">String</span> id;\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">ItemDetailsRoute</span>({required <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">id</span>});\n\n  @override\n  <span class=\"hljs-title class_\">Widget</span> <span class=\"hljs-title function_\">build</span>(<span class=\"hljs-title class_\">BuildContext</span> context, <span class=\"hljs-title class_\">GoRouterState</span> state) =>\n      <span class=\"hljs-title class_\">ItemDetailsScreen</span>(<span class=\"hljs-attr\">id</span>: id);\n}\n\n@<span class=\"hljs-title class_\">TypedGoRoute</span>&#x3C;<span class=\"hljs-title class_\">SignInRoute</span>>(\n  <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">'/sign-in'</span>,\n  <span class=\"hljs-attr\">routes</span>: [\n    <span class=\"hljs-title class_\">TypedGoRoute</span>&#x3C;<span class=\"hljs-title class_\">VerifyOtpRoute</span>>(<span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">\"verify\"</span>),\n  ], \n)\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SignInRoute</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">GoRouteData</span> {\n  @override\n  <span class=\"hljs-title class_\">Widget</span> <span class=\"hljs-title function_\">build</span>(<span class=\"hljs-title class_\">BuildContext</span> context, <span class=\"hljs-title class_\">GoRouterState</span> state) =>\n      <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">SignInScreen</span>();\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">VerifyOtpRoute</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">GoRouteData</span> {\n  final <span class=\"hljs-title class_\">String</span> $extra;\n\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">VerifyOtpRoute</span>({required <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$extra</span>});\n\n  @override\n  <span class=\"hljs-title class_\">Widget</span> <span class=\"hljs-title function_\">build</span>(<span class=\"hljs-title class_\">BuildContext</span> context, <span class=\"hljs-title class_\">GoRouterState</span> state) => \n     <span class=\"hljs-title class_\">VerifyOtpScreen</span>(<span class=\"hljs-attr\">verificationId</span>: $extra);\n}\n</code></pre>\n<p>이 코드에서는 각 화면에 대한 클래스를 GoRouteData를 확장하고 TypedGoRoute로 주석 처리하여 생성했습니다. 또 다른 화면으로 데이터를 전달하기도 했습니다.</p>\n<p>자세히 살펴보겠습니다.</p>\n<p>GoRouteData: GoRouteData은 화면이나 페이지를 반환하거나 사용자를 다른 페이지로 리디렉션하는 메서드를 오버라이드할 수 있는 추상 클래스입니다. 이 메서드들 중 하나를 반드시 사용해야 합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HomeRoute</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">GoRouteData</span> {\n\n  <span class=\"hljs-comment\">// 이렇게 parentNavigationKey를 정의할 수 있습니다. (선택 사항)</span>\n  <span class=\"hljs-keyword\">static</span> final <span class=\"hljs-title class_\">GlobalKey</span>&#x3C;<span class=\"hljs-title class_\">NavigatorState</span>> $parentNavigatorKey = rootNavigatorKey;\n\n  @override\n  <span class=\"hljs-title class_\">Widget</span> <span class=\"hljs-title function_\">build</span>(<span class=\"hljs-params\">BuildContext context, GoRouterState state</span>) {\n    <span class=\"hljs-comment\">// 여기서 반환된 위젯은 사용자가 이 경로로 이동할 때 표시됩니다.</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">HomeScreen</span>();\n}\n  \n  @override\n  <span class=\"hljs-title class_\">Page</span>&#x3C;<span class=\"hljs-keyword\">void</span>> <span class=\"hljs-title function_\">buildPage</span>(<span class=\"hljs-params\">BuildContext context, GoRouterState state</span>) {\n    <span class=\"hljs-comment\">// 여기서 반환된 Page는 사용자가 이 경로로 이동할 때 표시됩니다.</span>\n    <span class=\"hljs-comment\">// 여기서 CustomTransitionPage를 반환하여 페이지 전환을 설정할 수도 있습니다.</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">CupertinoPage</span>(<span class=\"hljs-attr\">child</span>: <span class=\"hljs-title class_\">HomeScreen</span>());\n  }\n\n  @override\n  <span class=\"hljs-title class_\">String</span>? <span class=\"hljs-title function_\">redirect</span>(<span class=\"hljs-params\">BuildContext context, GoRouterState state</span>){\n      <span class=\"hljs-comment\">// 여기서 이 경로로 이동할 때 사용자를 리디렉션해야 할 위치나 경로를 지정할 수 있습니다.</span>\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"/login\"</span>;\n      <span class=\"hljs-comment\">// 리디렉션을 막으려면 null을 반환하세요.</span>\n  }\n}\n</code></pre>\n<p>TypedGoRoute: TypedGoRoute 어노테이션은 경로 트리를 정의하는 데 사용됩니다. 맨 위 수준 경로 클래스마다 TypedGoRoute를 사용하여 경로 목록을 생성해야 합니다.</p>\n<pre><code class=\"hljs language-js\">@<span class=\"hljs-title class_\">TypedGoRoute</span>&#x3C;<span class=\"hljs-title class_\">TopLevelRoute</span>>(\n  <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">'/top-level-route-path'</span>,\n  <span class=\"hljs-attr\">routes</span>: [\n    <span class=\"hljs-comment\">// 여기에 서브 루트 어노테이션을 이렇게 정의할 수 있습니다.</span>\n    <span class=\"hljs-title class_\">TypedGoRoute</span>&#x3C;<span class=\"hljs-title class_\">SubRoute</span>>(\n        <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">'sub-route-path'</span>\n        <span class=\"hljs-attr\">routes</span>: []\n        <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'sub route'</span>\n    )\n  ],\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'top level route'</span> <span class=\"hljs-comment\">// 선택 사항</span>\n)\n</code></pre>\n<pre><code class=\"hljs language-js\">@<span class=\"hljs-title class_\">TypedGoRoute</span>&#x3C;<span class=\"hljs-title class_\">MyRouteGeneric</span>>()\n</code></pre>\n<p>이제 쿼리 매개변수, 경로 매개변수 및 라우트에서 추가 매개변수를 어떻게 사용할 수 있는지 알아봅시다.</p>\n<p>경로 매개변수:</p>\n<ul>\n<li>경로 매개변수는 : 기호를 사용하여 라우트 경로 내에 정의됩니다 (예: /products/:id).</li>\n<li>URL 구조의 특정 부분을 나타냅니다.</li>\n</ul>\n<p>쿼리 매개변수:</p>\n<ul>\n<li>URL 뒤에 ? 기호를 붙여 데이터를 추가합니다 (예: /products?category=electronics).</li>\n<li>요청을 수정하는 선택적인 필터와 같은 데이터에 사용됩니다.</li>\n</ul>\n<p>추가: 경로나 쿼리 매개변수로 캡처되지 않는 경로로 데이터를 전달하는 방법, 추가 개체를 전달할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\">@<span class=\"hljs-title class_\">TypedGoRoute</span>&#x3C;<span class=\"hljs-title class_\">ProductDetailsRoute</span>>(<span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">'/details/:id'</span>)\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ProductDetailsRoute</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">GoRouteData</span> {\n  <span class=\"hljs-comment\">// path에 정의된 변수 이름이 경로 매개변수로 사용됩니다.</span>\n  final <span class=\"hljs-title class_\">String</span> id; \n\n  <span class=\"hljs-comment\">// path에 정의되지 않은 변수 이름은 쿼리 매개변수로 사용됩니다.</span>\n  final <span class=\"hljs-title class_\">String</span> code;\n\n  <span class=\"hljs-comment\">// 추가 데이터를 사용하려면 변수 이름을 $extra로 설정해야 합니다.</span>\n  final <span class=\"hljs-title class_\">String</span> $extra;\n  \n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">ProductDetailsRoute</span>({required <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">id</span>, required <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">code</span>, required <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$extra</span>});\n\n  @override\n  <span class=\"hljs-title class_\">Widget</span> <span class=\"hljs-title function_\">build</span>(<span class=\"hljs-title class_\">BuildContext</span> context, <span class=\"hljs-title class_\">GoRouterState</span> state) =>\n      <span class=\"hljs-title class_\">ProductDetails</span>(<span class=\"hljs-attr\">pathParameterId</span>: id, <span class=\"hljs-attr\">queryParameterCode</span>:code, <span class=\"hljs-attr\">extraData</span>: $extra);\n}\n</code></pre>\n<h2>단계 3: 코드 생성</h2>\n<p>루트를 정의한 후에는 루트 목록과 확장을 생성해야 합니다. 이를 위해 build_runner를 사용해야 합니다.\n현재 파일에 생성된 파일 파트를 추가해 보겠습니다.</p>\n<pre><code class=\"hljs language-js\">part <span class=\"hljs-string\">'routes.g.dart'</span>; <span class=\"hljs-comment\">//part '&#x3C;current-file>.g.dart';</span>\n</code></pre>\n<p>이제 build_runner 명령어를 실행해 봅시다.</p>\n<pre><code class=\"hljs language-dart\">dart run build_runner build --delete-conflicting-outputs\n</code></pre>\n<p>현재 파일 디렉토리에 routes.g.dart 파일이 생성됩니다.</p>\n<h2>단계 4: GoRouter 초기화</h2>\n<p>이제 $appRoutes를 routes에 전달할 수 있으며, 생성된 location getter를 사용하여 정확한 경로 위치를 가져올 수 있습니다.</p>\n<pre><code class=\"hljs language-dart\">최종 라우터는 GoRouter(\n  initialLocation: HomeRoute().location, <span class=\"hljs-comment\">// location getter is generated.</span>\n  <span class=\"hljs-comment\">//$appRoutes is generated</span>\n  routes: $appRoutes,\n  redirect: (context, state) { <span class=\"hljs-comment\">// Optional</span>\n    <span class=\"hljs-comment\">// 여기서 경로 위치를 반환하여 리디렉션이 가능합니다.</span>\n    <span class=\"hljs-comment\">// 또한 사용자가 검색 URL을 통해 화면으로 이동하는 것을 방지할 수도 있습니다.</span>\n    <span class=\"hljs-comment\">// 리디렉트를 방지하려면 null을 반환합니다.</span>\n  }\n  errorBuilder: (context, e) => ErrorScreen(e), <span class=\"hljs-comment\">// Optional</span>\n  navigatorKey: rootNavigationKey, <span class=\"hljs-comment\">//Optional</span>\n);\n</code></pre>\n<h2>단계 5: 다른 화면으로 이동</h2>\n<p>이제 라우트를 설정했으니, 다른 화면으로 이동하는 네비게이션 방법을 살펴봅시다.</p>\n<h2>Go:</h2>\n<p>현재 화면 스택을 주어진 경로 대상으로 교체해주세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">await</span> <span class=\"hljs-title class_\">Screen2Route</span>(<span class=\"hljs-attr\">id</span>: id).<span class=\"hljs-title function_\">go</span>(context);\n</code></pre>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1000/1*ZO9gaACCAYOszpSV1_gbKQ.gif\" alt=\"이미지\"></p>\n<h2>푸시:</h2>\n<p>페이지 스택에 위치를 푸시하세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">await</span> <span class=\"hljs-title class_\">Screen2Route</span>(<span class=\"hljs-attr\">id</span>: id).<span class=\"hljs-title function_\">push</span>(context);\n\n<span class=\"hljs-comment\">// push 과정에서 값 반환도 가능합니다</span>\nfinal result = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title class_\">Screen2Route</span>(<span class=\"hljs-attr\">id</span>: id).<span class=\"hljs-title function_\">push</span>(context);\n</code></pre>\n<h2>Push Replacement:</h2>\n<p>가장 위에 있는 페이지 스택을 해당 URL 위치로 대체합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">await</span> <span class=\"hljs-title class_\">Screen2Route</span>(<span class=\"hljs-attr\">id</span>: id).<span class=\"hljs-title function_\">pushReplacement</span>(context);\n</code></pre>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1000/1*GNaChKuABcE4PejKUFFe9A.gif\" alt=\"이미지\"></p>\n<h2>대체:</h2>\n<p>가장 상단의 스택 페이지를 주어진 페이지로 교체하지만, 동일한 페이지로 취급합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">await</span> <span class=\"hljs-title class_\">Screen2Route</span>(<span class=\"hljs-attr\">id</span>: id).<span class=\"hljs-title function_\">replace</span>(context);\n</code></pre>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1000/1*_S9SyTnfBPEFAUMNloXz1g.gif\" alt=\"이미지\"></p>\n<p>이제 네비게이션 구현을 마쳤습니다. 👏</p>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1000/0*QwBEMwvqVkuL2OUM.gif\" alt=\"image\"></p>\n<p>Now, let’s take a look at how we can implement a shell route with type-safe navigation using go_router and go_router_builder.</p>\n<h2>Related Articles</h2>\n<p>We're grateful to have you on this journey with us!</p>\n<p>만약 읽은 내용이 마음에 드신다면, 아래에 👏 👏👏를 꼭 눌러주시기 바랍니다. 작가로서 이것은 정말 소중한 일이에요!</p>\n<p>아래 댓글 섹션에서 의견을 공유해주세요. 여러분의 의견은 콘텐츠를 더욱 풍부하고 가치 있는 것으로 만들어주며, 더 많은 유익한 기사를 작성할 동기를 얻게 해줍니다.</p>\n<p>흥미로운 기사 업데이트를 받으시려면 Canopas를 팔로우해주세요!</p>\n</body>\n</html>\n"},"__N_SSG":true}