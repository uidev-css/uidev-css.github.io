{"pageProps":{"post":{"title":"패키지 없이 Flutter에서 스크롤로 페이지네이션 하는 방법","description":"","date":"2024-06-21 23:10","slug":"2024-06-21-FlutterPaginationOnScrollwithoutanypackages","content":"\n\n안녕하세요 여러분! 이 기사는 플러터에서 어떠한 패키지를 사용하지 않고 동적 인피니티 스크롤 페이징을 구현하는 방법에 대해 소개하고 있어요.\n여기서 '동적' 이라는 용어는 스크롤 시 새로운 데이터를 로드하는 것을 의미합니다. maxScrollExtent 위치에 도달했을 때가 아니라는 거죠.\n\n페이징은 항상 앱 개발에서 가장 싫어하는 부분 중 하나였어요. 무시할 수 없지만 제대로 구현할만한 방법을 찾지 못했어요. 저는 무한 스크롤 페이징 패키지를 선호하지 않아요. 왜냐하면 특별한 ListView를 사용하도록 강요하고 때로는 화면의 모든 로직과 레이아웃을 다시 만들어야 할 수도 있기 때문이에요.\n\n그래서 이제 저는 스크롤 중에 페이징을 구현하는 방법을 나누려고 해요. 최적화되었고 데이터가 올바른 횟수만큼 로드되도록 노력했어요.\n\n1) 먼저 PaginationScrollController 클래스를 작성해야 해요. 이 클래스는 loadAction 함수와 scrollController 자체를 저장할 거에요.\nboundaryOffset은 데이터를 로드해야 하는 시점을 계산하는 데 사용돼요. 첫 번째로 화면의 반을 넘어가는 시점에 로드를 시작합니다. 그리고 그 다음에는 화면의 0.75 지점을 넘어갈 때 로드합니다. 수식은 다음과 같아요: boundaryOffset = 1-1/(currentPage*2)\n\n<div class=\"content-ad\"></div>\n\n```js\r\nclass PaginationScrollController {\n  late ScrollController scrollController;\n  bool isLoading = false;\n  bool stopLoading = false;\n  int currentPage = 1;\n  double boundaryOffset = 0.5;\n  late Function loadAction;\n\n  void init({Function? initAction, required Function loadAction}) {\n    if (initAction != null) {\n      initAction();\n    }\n    this.loadAction = loadAction;\n    scrollController = ScrollController()..addListener(scrollListener);\n  }\n\n  void dispose() {\n    scrollController.removeListener(scrollListener);\n    scrollController.dispose();\n  }\n\n  void scrollListener() {\n    if (!stopLoading) {\n      //load more data\n      if (scrollController.offset >=\n              scrollController.position.maxScrollExtent * boundaryOffset &&\n          !isLoading) {\n        isLoading = true;\n        loadAction().then((shouldStop) {\n          isLoading = false;\n          currentPage++;\n          boundaryOffset = 1 - 1 / (currentPage * 2);\n          if (shouldStop == true) {\n            stopLoading = true;\n          }\n        });\n      }\n    }\n  }\n}\r\n```\n\n2) 다음으로 로딩 함수를 작성해야 합니다. 다음과 같이 작성될 것입니다:\n\n```js\r\n  Future getNewRequests() async {\n    int lastPage = pagination.lastPage;\n    int currentPage = pagination.currentPage;\n    if (lastPage > currentPage) {\n      // 여기서 데이터를 가져옵니다. 예를 들어\n      getRequests(currentPage + 1);\n    } else if (lastPage == currentPage) {\n      return true;\n    }\n  }\r\n```\n\n이 함수는 페이지네이션의 마지막 페이지에 도달하면 true를 반환합니다. 이것은 최적화를 위해 페이지네이션 컨트롤러에서 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n3) 마지막 단계는 컨트롤러를 SingleChildScrollView에 연결하는 것입니다. 따라서 우리가 할 일은:\n\n3.1 컨트롤러 초기화 (그리고 dispose를 잊지 마세요)\n\n```dart\nclass _MyScreenState extends State<MyScreen> {\n  PaginationScrollController paginationScrollController =\n      PaginationScrollController();\n\n  @override\n  void initState() {\n    paginationScrollController.init(\n        loadAction: () => context.read<RequestCubit>().getNewRequests());\n    super.initState();\n  }\n\n  @override\n  void dispose() {\n    paginationScrollController.dispose();\n    super.dispose();\n  }\n}\n```\n\n3.2 scrollController를 ListView에 연결하기\n\n<div class=\"content-ad\"></div>\n\n```dart\n  @override\n  Widget build(BuildContext context) {\n      return Scaffold(\n        body: SingleChildScrollView(\n          controller: paginationScrollController.scrollController,\n          child: Column(\n            children: [\n              // 필요한 데이터를 포함한 위젯\n            ],\n          ),\n        )\n      );\n    \n  }\n```\n\n다음은 구현한 예시입니다 (여기서는 10개의 요소가 있는 5페이지가 있습니다):\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1200/1*D-AaGGdptQ426UvWV7uNUw.gif\" />\n\n그게 다입니다! 동적 페이징이 구현되었습니다. 데이터가 항상 신선하게 유지되며 사용자는 로딩이나 지연을 전혀 눈치채지 못할 것입니다 (물론 안정적인 인터넷 연결이 있는 경우).","ogImage":{"url":"/assets/img/2024-06-21-FlutterPaginationOnScrollwithoutanypackages_0.png"},"coverImage":"/assets/img/2024-06-21-FlutterPaginationOnScrollwithoutanypackages_0.png","tag":["Tech"],"readingTime":4},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>안녕하세요 여러분! 이 기사는 플러터에서 어떠한 패키지를 사용하지 않고 동적 인피니티 스크롤 페이징을 구현하는 방법에 대해 소개하고 있어요.\n여기서 '동적' 이라는 용어는 스크롤 시 새로운 데이터를 로드하는 것을 의미합니다. maxScrollExtent 위치에 도달했을 때가 아니라는 거죠.</p>\n<p>페이징은 항상 앱 개발에서 가장 싫어하는 부분 중 하나였어요. 무시할 수 없지만 제대로 구현할만한 방법을 찾지 못했어요. 저는 무한 스크롤 페이징 패키지를 선호하지 않아요. 왜냐하면 특별한 ListView를 사용하도록 강요하고 때로는 화면의 모든 로직과 레이아웃을 다시 만들어야 할 수도 있기 때문이에요.</p>\n<p>그래서 이제 저는 스크롤 중에 페이징을 구현하는 방법을 나누려고 해요. 최적화되었고 데이터가 올바른 횟수만큼 로드되도록 노력했어요.</p>\n<ol>\n<li>먼저 PaginationScrollController 클래스를 작성해야 해요. 이 클래스는 loadAction 함수와 scrollController 자체를 저장할 거에요.\nboundaryOffset은 데이터를 로드해야 하는 시점을 계산하는 데 사용돼요. 첫 번째로 화면의 반을 넘어가는 시점에 로드를 시작합니다. 그리고 그 다음에는 화면의 0.75 지점을 넘어갈 때 로드합니다. 수식은 다음과 같아요: boundaryOffset = 1-1/(currentPage*2)</li>\n</ol>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">PaginationScrollController</span> {\n  late <span class=\"hljs-title class_\">ScrollController</span> scrollController;\n  bool isLoading = <span class=\"hljs-literal\">false</span>;\n  bool stopLoading = <span class=\"hljs-literal\">false</span>;\n  int currentPage = <span class=\"hljs-number\">1</span>;\n  double boundaryOffset = <span class=\"hljs-number\">0.5</span>;\n  late <span class=\"hljs-title class_\">Function</span> loadAction;\n\n  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">init</span>(<span class=\"hljs-params\">{<span class=\"hljs-built_in\">Function</span>? initAction, required <span class=\"hljs-built_in\">Function</span> loadAction}</span>) {\n    <span class=\"hljs-keyword\">if</span> (initAction != <span class=\"hljs-literal\">null</span>) {\n      <span class=\"hljs-title function_\">initAction</span>();\n    }\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">loadAction</span> = loadAction;\n    scrollController = <span class=\"hljs-title class_\">ScrollController</span>()..<span class=\"hljs-title function_\">addListener</span>(scrollListener);\n  }\n\n  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">dispose</span>(<span class=\"hljs-params\"></span>) {\n    scrollController.<span class=\"hljs-title function_\">removeListener</span>(scrollListener);\n    scrollController.<span class=\"hljs-title function_\">dispose</span>();\n  }\n\n  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">scrollListener</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">if</span> (!stopLoading) {\n      <span class=\"hljs-comment\">//load more data</span>\n      <span class=\"hljs-keyword\">if</span> (scrollController.<span class=\"hljs-property\">offset</span> >=\n              scrollController.<span class=\"hljs-property\">position</span>.<span class=\"hljs-property\">maxScrollExtent</span> * boundaryOffset &#x26;&#x26;\n          !isLoading) {\n        isLoading = <span class=\"hljs-literal\">true</span>;\n        <span class=\"hljs-title function_\">loadAction</span>().<span class=\"hljs-title function_\">then</span>((shouldStop) {\n          isLoading = <span class=\"hljs-literal\">false</span>;\n          currentPage++;\n          boundaryOffset = <span class=\"hljs-number\">1</span> - <span class=\"hljs-number\">1</span> / (currentPage * <span class=\"hljs-number\">2</span>);\n          <span class=\"hljs-keyword\">if</span> (shouldStop == <span class=\"hljs-literal\">true</span>) {\n            stopLoading = <span class=\"hljs-literal\">true</span>;\n          }\n        });\n      }\n    }\n  }\n}\n</code></pre>\n<ol start=\"2\">\n<li>다음으로 로딩 함수를 작성해야 합니다. 다음과 같이 작성될 것입니다:</li>\n</ol>\n<pre><code class=\"hljs language-js\">  <span class=\"hljs-title class_\">Future</span> <span class=\"hljs-title function_\">getNewRequests</span>() <span class=\"hljs-keyword\">async</span> {\n    int lastPage = pagination.<span class=\"hljs-property\">lastPage</span>;\n    int currentPage = pagination.<span class=\"hljs-property\">currentPage</span>;\n    <span class=\"hljs-keyword\">if</span> (lastPage > currentPage) {\n      <span class=\"hljs-comment\">// 여기서 데이터를 가져옵니다. 예를 들어</span>\n      <span class=\"hljs-title function_\">getRequests</span>(currentPage + <span class=\"hljs-number\">1</span>);\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (lastPage == currentPage) {\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n    }\n  }\n</code></pre>\n<p>이 함수는 페이지네이션의 마지막 페이지에 도달하면 true를 반환합니다. 이것은 최적화를 위해 페이지네이션 컨트롤러에서 사용합니다.</p>\n<ol start=\"3\">\n<li>마지막 단계는 컨트롤러를 SingleChildScrollView에 연결하는 것입니다. 따라서 우리가 할 일은:</li>\n</ol>\n<p>3.1 컨트롤러 초기화 (그리고 dispose를 잊지 마세요)</p>\n<pre><code class=\"hljs language-dart\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">_MyScreenState</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">State</span>&#x3C;<span class=\"hljs-title\">MyScreen</span>> </span>{\n  PaginationScrollController paginationScrollController =\n      PaginationScrollController();\n\n  <span class=\"hljs-meta\">@override</span>\n  <span class=\"hljs-keyword\">void</span> initState() {\n    paginationScrollController.init(\n        loadAction: () => context.read&#x3C;RequestCubit>().getNewRequests());\n    <span class=\"hljs-keyword\">super</span>.initState();\n  }\n\n  <span class=\"hljs-meta\">@override</span>\n  <span class=\"hljs-keyword\">void</span> dispose() {\n    paginationScrollController.dispose();\n    <span class=\"hljs-keyword\">super</span>.dispose();\n  }\n}\n</code></pre>\n<p>3.2 scrollController를 ListView에 연결하기</p>\n<pre><code class=\"hljs language-dart\">  <span class=\"hljs-meta\">@override</span>\n  Widget build(BuildContext context) {\n      <span class=\"hljs-keyword\">return</span> Scaffold(\n        body: SingleChildScrollView(\n          controller: paginationScrollController.scrollController,\n          child: Column(\n            children: [\n              <span class=\"hljs-comment\">// 필요한 데이터를 포함한 위젯</span>\n            ],\n          ),\n        )\n      );\n    \n  }\n</code></pre>\n<p>다음은 구현한 예시입니다 (여기서는 10개의 요소가 있는 5페이지가 있습니다):</p>\n<p>그게 다입니다! 동적 페이징이 구현되었습니다. 데이터가 항상 신선하게 유지되며 사용자는 로딩이나 지연을 전혀 눈치채지 못할 것입니다 (물론 안정적인 인터넷 연결이 있는 경우).</p>\n</body>\n</html>\n"},"__N_SSG":true}