{"pageProps":{"posts":[{"title":"Retrofit과 Flutter로 프로처럼 개발하는 방법","description":"","date":"2024-06-22 04:08","slug":"2024-06-22-RetrofitandFlutterlikeaPRO","content":"\n\n\n![이미지](/assets/img/2024-06-22-RetrofitandFlutterlikeaPRO_0.png)\n\n데이터 처리 및 API 통합은 저희 모바일 개발자들에게 친숙한 주제입니다.\n\nFlutter로 이를 처리하는 몇 가지 방법이 있습니다. 이 기사에서는 REST API를 처리하는 데 가장 효과적이라고 생각하는 방법을 보여드립니다. 이 멋진 기사를 보신 후에는 다른 것을 사용하지 않게 될 것입니다!\n\n우리는 훌륭한 Retrofit 패키지에 대해 알아볼 것입니다. 이 패키지는 Dio 패키지의 유형 변환을 수행하며 (JSON을 Dart 객체로 변환하는 고통스러운 작업을 source_gen을 사용해 코드를 생성함으로써) 번거로움을 줄여줍니다. 시작해 봅시다.\n\n\n<div class=\"content-ad\"></div>\n\n- 개요\n- 설치\n- Retrofit 구성 방법\n- 사용 방법\n- 모든 호출에 토큰 추가하는 방법\n- freezed와 Retrofit 사용 방법\n- 응답 캐시하는 방법\n- 트래픽 로깅하는 방법\n- 편리한 팁\n\n# 개요\n\n4년 전에 Flutter를 개발하기 시작했을 때 처음 검색했던 것은 REST API를 올바르게 처리하는 방법이었습니다.\n\n안드로이드 개발자로서, Square의 Retrofit이 인터페이스와 주석을 사용하여 HTTP 요청을 설명하는 방법을 좋아했습니다. 다행히 누군가가 이 아이디어를 가져와 Flutter 세계에 구현했습니다.\n\n<div class=\"content-ad\"></div>\n\n플러터 버전에서도 REST 작업을 설명하는 인터페이스(추상 클래스)를 사용하며 대화 형식을 자동으로 만들어줍니다.\n\n안드로이드 버전은 기본 호출자로 OkHttp를 사용했습니다. 플러터의 경우 Dio를 사용하며, 이는 Dio를 사용하기 매우 쉽고 훌륭한 기능이 많이 포함되어 있어 기쁜 소식입니다. 또한 Retrofit과 함께 사용할 수 있는 애드온 몇 가지가 있어 REST에 추가적인 기능을 더해줄 수 있습니다. 예를 들어:\n\n- dio_cookie_manager - Dio용 쿠키 매니저\n- dio_http2_adapter - HTTP/2.0을 지원하는 Dio HttpClientAdapter\n\n<div class=\"content-ad\"></div>\n\n# dio_smart_retry \nDio를 위한 유연한 재시도 라이브러리\n\n# dio_cache_interceptor \n여러 저장소를 존줍하여 HTTP 지시문을 준수하는 (또는 그렇지 않은) Dio HTTP 캐시 인터셉터\n\n# dio_http_cache \n안드로이드의 Rxcache와 같은 Dio를 위한 간단한 캐시 라이브러리\n\n# pretty_dio_logger \n네트워크 호출을 읽기 쉬운 형식으로 로그하는 Dio 인터셉터, 예쁜 Dio 로거\n\n<div class=\"content-ad\"></div>\n\n# 설치\n\npubspec.yaml 파일에 아래 내용을 dependencies 아래에 추가해주세요:\n\n```js\nretrofit: check_latest_ver (^3.0.1+1 현재 버전)\n```\n\n그리고 dev_dependencies에는 아래 세 가지를 추가해주세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nretrofit_generator: 최신 버전 확인\nbuild_runner: 최신 버전 확인\njson_serializable: 최신 버전 확인\n```\n\n이제 flutter pub을 실행하고 명령어를 받은 후, Flutter 신에게 기도합니다. 종종 종속성으로 인해 약간 골을 주는 경우가 있습니다. 일시적인 해결책은 버전을 아무 값으로 설정하는 것입니다.\n\n다음으로, 주요 추상 클래스, Dio 설정을 만들고, get_it을 사용하여 나중에 리포지토리에서 액세스할 수 있는 레이지 싱글톤을 만들겠습니다.\n\n# 추상 클래스 만들기\n\n<div class=\"content-ad\"></div>\n\n- 파일을 생성하세요. 이름을 rest_client.dart로 지정할게요.\n- Retrofit은 코드를 생성하기 때문에, 파일 상단에 .g 파일을 part로 지정해야 합니다. 우리의 경우에는 rest.client.g.dart가 될 거예요.\n- 추상 클래스를 생성하고 @RestApi() 어노테이션을 사용하세요. 이렇게 하면 제너레이터가 retrofit 인터페이스(추상 클래스)임을 알 수 있어요.\n- Dio와 옵션으로 베이스 URL을 받는 팩토리 생성자를 만드세요.\n\n![이미지](/assets/img/2024-06-22-RetrofitandFlutterlikeaPRO_1.png)\n\n# Dio 설정\n\n이전에 언급했듯이, Retrofit은 Dio를 완전히 의존하므로, 이를 생성해보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n- dio_client.dart이라는 파일을 만드세요.\n- baseUrl 문자열을 인수로 받아 Dio 클라이언트를 반환하는 함수를 생성하세요. \n- baseUrl과 Interceptor(이에 대해서 나중에 논의할 것입니다.)와 같은 최소한의 *BaseOptions로 Dio 인스턴스를 만드세요.\n\nBaseOptions: Dio 인스턴스의 표준 구성입니다. 이 기사에서 다루지는 않겠지만, 연결 제한 시간, 수신 제한 시간, 전송 제한 시간, 쿼리 매개변수, 헤더 등과 같은 다양한 구성 요소가 포함되어 있습니다.\n\n![img](/assets/img/2024-06-22-RetrofitandFlutterlikeaPRO_2.png)\n\n# get_it으로 Dio 및 Retrofit 클래스 연결하기\n\n<div class=\"content-ad\"></div>\n\n의존성 주입을 선택할 때 항상 get_it을 사용했었어요. 이것은 사용하기 쉽고 컨텍스트가 필요하지 않아요. 마지막 단계는 Dio와 Retrofit을 연결하는 것이에요. 이건 한 줄의 코드만 필요해요. get_it에 관한 글이 있으니, 더 깊이 파고들고 싶다면 꼭 읽어보세요. 로케이터 설정에 해당 종속성을 추가하세요:\n\n![이미지](/assets/img/2024-06-22-RetrofitandFlutterlikeaPRO_3.png)\n\n이 두 줄의 코드는 게으른 싱글톤(처음 호출될 때만 만들어지는)을 생성할 거에요. RetrofitClient 인스턴스에서는 Dio 클라이언트와 함께 원격 구성을 전달했어요.\n\n주의 - 원격 구성은 변수로 변경하거나 Firebase와 같은 원격 서비스로 변경하여 env 기본 URL을 구성할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n드디어 Retrofit을 사용할 준비가 되었습니다! 사용 방법을 살펴봅시다.\n\n## 사용 방법\n\n먼저, 지원되는 HTTP 메소드와 그 추가 방법에 대해 이해해야 합니다. Retrofit은 다음을 지원합니다:\n\n- @GET() — GET 요청을 사용하여 리소스 표현/정보만 검색하고 수정하지 않습니다. 이는 리소스의 상태를 변경하지 않기 때문에 안전한 메소드로 알려져 있습니다.\n\n<div class=\"content-ad\"></div>\n\n@ PATCH() - PUT 요청을 보면 리소스 엔티티를 수정합니다. 좀 더 정확히 말하면 PATCH 방법은 기존 리소스를 부분적으로 업데이트하는 올바른 선택입니다. 전체 리소스를 교체하는 경우에만 PUT을 사용해야 합니다.\n\n@ PUT() - 기본적으로 PUT API를 사용하여 기존 리소스를 업데이트합니다 (리소스가 존재하지 않는 경우 API가 새 리소스를 생성할지 여부를 결정할 수 있음).\n\n@ DELETE() - 이름 그대로 DELETE API는 요청 URI로 식별된 리소스를 삭제합니다.\n\n실제 세계의 예시를 살펴보겠습니다. JSONPlaceholder 웹사이트를 사용하여 예시용 JSON을 생성하겠습니다. 간단한 GET 요청부터 시작해봅시다.\n\n<div class=\"content-ad\"></div>\n\n해당 엔드포인트를 사용할 거예요.\n\nhttps://jsonplaceholder.typicode.com/posts\n\n우선 Retrofit을 위한 기본 URL을 정의해야 해요. 이 부분이죠: https://jsonplaceholder.typicode.com/\n\n- 기본 URL 정의하기 — 나에게는 모든 원격 주소를 담은 (remote_config) dart 파일이 있는게 의미가 있어요. 그래서 Dio 클라이언트를 빌드하는 get_it 파일에 정의해요 (마지막 사진에서 어떻게 할 지 보여 줄 거예요).\r\n- 웹이나 Swager에서 JSON 응답을 받거나 백엔드 팀에게 요청해요. Retrofit이 변환할 수 있는 Freezed 파일을 만들어보죠. 가장 쉬운 방법은 JSON 요청을 붙여넣고 타깃 언어를 Dart로 선택해서 excellent web tool인 quicktype을 사용하는 거예요. 그리고 패널에서 다음을 켜주세요:\n\n<div class=\"content-ad\"></div>\n\n클래스에 인코더 및 디코더를 추가하고 @freezed 호환성을 갖도록 클래스 정의를 생성해보세요.\n\n<img src=\"/assets/img/2024-06-22-RetrofitandFlutterlikeaPRO_4.png\" />\n\n그 후, freezed 결과를 복사하여 새로운 모델 파일, 예를 들어 post_model.dart를 만들고 오른쪽 코드를 붙여넣은 다음 다음 명령을 실행해보세요. (NOTICE: quickly에서 필드들을 선택적으로하거나 필수로하지 않았는데, freezed는 그것을 허용하지 않으므로 각 부분에 ?를 추가하여 선택적으로 만듭니다.)\n\n\nflutter pub run build_runner build --delete-conflicting-outputs\n\n\n<div class=\"content-ad\"></div>\n\n이 는 대화 내용이 포함된 .g 파일과 copyWith, toString 및 해시와 같은 다른 유용한 정보가 들어 있는 .freezed 파일을 생성합니다 (Freezed에 대해 자세히 알고 싶다면 이 문서를 확인해보세요)\n\n다음에 get 호출을 추가하기 전에 API에서 수신한 데이터를 변환하기 위해 retrofit이 필요로하는 응답 클래스를 만드는 부분이 있습니다.\n\n이제 Retrofit을 위한 GET 호출을 추가해 보겠습니다.\n\n![그림](/assets/img/2024-06-22-RetrofitandFlutterlikeaPRO_5.png)\n\n<div class=\"content-ad\"></div>\n\nbuild_runner를 다시 실행하여 Retrofit이 중요한 작업을 대신 처리하도록 하세요. 이제 API를 사용할 준비가 되었어요. 멋져요. (클린 아키텍처를 사용하는 경우, 모델 레이어의 리포지토리에서 Retrofit 추상 클래스를 호출하고 나중에 FutureBuilder와 함께 위젯에서 호출하지 않고 Usecase로 전달하는 것이 좋습니다.)\n\n좋아요, 가장 간단한 호출을 다루었어요. 조금 흥미롭게 만들어 볼까요? 이제 특정 카테고리, 스포츠라는 카테고리의 게시물을 가져와야 한다고 가정해봅시다. 따라서 String 유형의 쿼리를 전달해야합니다. 문제없어요:\n\n![image](/assets/img/2024-06-22-RetrofitandFlutterlikeaPRO_6.png)\n\n동일한 카테고리 키('category')로 몇 가지 카테고리 ID를 전달해야하는 경우는 어떨까요? String 대신 String 목록으로 교체하면 됩니다. 이렇게 하세요.\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-22-RetrofitandFlutterlikeaPRO_7.png)\n\n현재 백엔드 개발자가 호출 경로에서 카테고리 ID를 지정해야 한다고 결정했습니다. 따라서 다음과 같이 될 것입니다: post/'id'.\n\n![이미지](/assets/img/2024-06-22-RetrofitandFlutterlikeaPRO_8.png)\n\n좋아요, 그럼 데이터와 함께 새로운 포스트를 보내는 것은 어떤가요? 예를 들어, 제목과 내용이 있는 POST라고 할 때요. 쉽죠, 새로운 요청을 위한 새로운 freezed 파일을 만들어보세요.\n\n<div class=\"content-ad\"></div>\n\n```dart\n@freeze\nabstract class PostModelRequest with _$PostModelRequest {\n  const factory PostModelRequest({\n    String? title,\n    String? content,\n  }) = _PostModelRequest;\n  factory PostModelRequest.fromJson(Map<String, dynamic> json) =>\n      _$PostModelRequestFromJson(json);\n}\n```\n\n그리고 PostModelRequest를 body에 보내는 Post 메서드를 추가해주세요.\n\n![image](/assets/img/2024-06-22-RetrofitandFlutterlikeaPRO_9.png)\n\n같은 방법으로 retrofit 클라이언트에 @PUT, @PATCH, @DELETE 메서드를 추가할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\nMarkdown 형식으로 변경해 보겠습니다.\n\nRetrofit은 인코딩된 폼 데이터를 사용하여 업로드도 지원합니다.\n\n![image1](/assets/img/2024-06-22-RetrofitandFlutterlikeaPRO_10.png)\n\n예를 들어, 무거운 파일을 업로드하다 중단하고 싶을 때는 다음과 같이 할 수 있습니다.\n\n![image2](/assets/img/2024-06-22-RetrofitandFlutterlikeaPRO_11.png)\n\n<div class=\"content-ad\"></div>\n\n만약 특정 호출을 위해 사용자 정의 헤더가 필요하다면, 이 훌륭한 도구를 통해 가능합니다. (보통 이러한 헤더는 전역적이며 레트로핏 클라이언트를 생성할 때 Dio 클라이언트에서 정의됩니다)\n\n![이미지](/assets/img/2024-06-22-RetrofitandFlutterlikeaPRO_12.png)\n\n사용자 정의 헤더는 다음과 같이 동적으로 전달될 수도 있습니다.\n\n![이미지](/assets/img/2024-06-22-RetrofitandFlutterlikeaPRO_13.png)\n\n<div class=\"content-ad\"></div>\n\n개발자님 안녕하세요. 업로드된 진행 상황을 얻어 업로드하는 것도 요청하셨지만, 이겪는 것은 선택 사항입니다. 네, 물론, 단지:\n\n\n<img src=\"/assets/img/2024-06-22-RetrofitandFlutterlikeaPRO_14.png\" />\n\n\n# 모든 호출에 토큰 추가하는 방법\n\n회사에서 엄격한 곳이어서 호출을 액세스 토큰으로 안전하게 보호하길 원합니다. 물론, 당신이 원하는 마지막 것은 각 호출에 수동으로 이러한 토큰을 추가하는 것입니다. 절대 안돼요! 우리에게는 인터셉터가 있어서 다행입니다. 인터셉터는 당신이 만든 모든 호출을 듣는 훌륭한 도구입니다. 이들에는 onRequest, onError 및 onResponse와 같은 세 가지 콜백이 있습니다. 우리의 작은 예에서 백엔드는 우리의 토큰을 파이어베이스에서 원합니다. 그래서 token_interceptor.dart라는 새 파일을 만들고 나중에 Dio 클라이언트에 추가합시다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-22-RetrofitandFlutterlikeaPRO_15.png)\n\n우리는 모든 요청을 듣고, IdToken이 있으면 헤더로 추가합니다.\n\n또한 오류가 발생하면 간단히 처리하는 방법이 있습니다. 실제 세계에서는 토큰이 만료되어 새로 고칠 필요가 있는 상황을 처리할 수도 있습니다. 요청에 무언가를 하고 싶다면 언제든지 onResponse를 재정의할 수 있습니다.\n\n# 응답을 캐시하는 방법\n\n\n<div class=\"content-ad\"></div>\n\nDio에는 더 많은 기능을 추가할 수있는 애드온이 많이 있어요. 그 중 하나는 Hive나 objectbox와 같은 데이터베이스를 구현하지 않고도 응답을 캐시하는 데 도움을 줍니다. pub.dev에 가서 dio_http_cache를 검색해보세요.\n\n설치는 쉬워요:\n\n첫 번째 단계:\n\n```js\ndio.interceptors.add(DioCacheManager(CacheConfig(baseUrl: RemoteConfig.baseUrl)).interceptor);\n```\n\n<div class=\"content-ad\"></div>\n\n두 번째 단계에서는 요청이 저장될 최대 연령을 설정할 수 있습니다:\n\n```js\nDio().get(\n  RemoteConfig.baseUrl,\n  options: buildCacheOptions(Duration(days: 7)),\n);\n```\n\n# 트래픽 로깅하는 방법\n\n트래픽을 로깅하지 않으면 우리의 API 문제를 이해하고 디버깅하는 데 너무 많은 시간이 걸려요. 그래서 좋은 로거가 항상 필요하죠. 다시 pub.dev에 가서 pretty_dio_logger을 검색하세요. 이를 인터셉터 목록에 추가하면 트래픽을 마음껏 볼 수 있습니다. (네트워크 도구를 사용할 수 있지만 때때로 그거 제대로 작동 안 해요. 그리고 이 방법은 AK-47처럼 신뢰할 수 있어요.)\n\n<div class=\"content-ad\"></div>\n\n```dart\ndio.interceptors.add(PrettyDioLogger(\n        requestHeader: true,\n        requestBody: true,\n        responseBody: true,\n        responseHeader: false,\n        error: true,\n        compact: true,\n        maxWidth: 90));\n```\n\n애드온 목록이 굉장히 방대하고, 이 기사는 길어지고 있습니다. Dio에 있는 다른 애드온을 확인하시기를 권장합니다 (위에 나열되어 있음).\n\n다음 기사는 오류를 전문가처럼 처리하는 방법에 대해 다룰 예정입니다. 이 내용이 도움이 되었기를 바랍니다. Flutter 서비스가 필요하신 경우 언제든지 연락해 주세요. Flutter 개발 전문 회사인 BlueBirdCoders에서는 4년 이상의 경험을 가지고 있으며, 아래 링크에서 우리 멋진 커뮤니티에 참여하실 수 있습니다:\n\nhttps://www.facebook.com/groups/flutteril/\n\n\n<div class=\"content-ad\"></div>\n\n만나서 반가워요! 함께 즐거운 시간 보내요! 🤘🏽","ogImage":{"url":"/assets/img/2024-06-22-RetrofitandFlutterlikeaPRO_0.png"},"coverImage":"/assets/img/2024-06-22-RetrofitandFlutterlikeaPRO_0.png","tag":["Tech"],"readingTime":10},{"title":"Flutter 모든 위치의 전체 주소를 가져오는 방법","description":"","date":"2024-06-22 04:06","slug":"2024-06-22-FlutterGetcompleteaddressofanylocation","content":"\n\n<img src=\"/assets/img/2024-06-22-FlutterGetcompleteaddressofanylocation_0.png\" />\n\n어떤 위치든 위도와 경도를 사용하여 완전한 주소(우편 번호 포함)를 쉽게 얻을 수 있습니다.\n\n예를 들어:\n\n이렇게 하는 법을 알아보겠습니다 ......\n\n<div class=\"content-ad\"></div>\n\n🌞 먼저 아래 종속성을 pubspec.yaml 파일에 추가해주세요\n\n```js\ngeocoding: ^2.1.1\n```\n\n🌞 그 후에 .dart 파일에서 종속성을 import해주세요\n\n```js\nimport 'package:geocoding/geocoding.dart';\n```\n\n<div class=\"content-ad\"></div>\n\n🌞 이제 Lat, Long을 입력으로 받아 주소를 문자열로 반환하는 getPlacemark라는 간단한 함수를 만들어 보겠습니다.\n\n함수를 비동기로 정의하고, 전체 내용을 try-catch로 감싸서 예외를 처리할 겁니다.\n\n🌞 그래서 try 블록 안에서 placemarkFromCoordinates 작업을 사용하여 위도와 경도를 전달하여 플레이스마크를 가져올 것입니다. 다음과 같이:\n\n```js\nList<Placemark> placemarks = await placemarkFromCoordinates(lat, long);\n```\n\n<div class=\"content-ad\"></div>\n\n이 장소 표시는 위치의 모든 세부 정보를 포함하고 있어요.\n\n그들을 추출하고 정리하기 위해 장소 표시를 반전하고 마지막 인덱스에 액세스할 수 있어요:\n\n```js\nString address = \"\";\naddress += '${placemarks.reversed.last.subLocality ?? ''}';\n```\n\n위와 같이 주소에 액세스하고 문자열에 추가할 수 있어요. 이때 널 체크를 수행하여, 위도와 경도에 어떠한 값도 포함되지 않을 경우 (즉, 널 값 반환) 대비가 되도록 해요.\n\n<div class=\"content-ad\"></div>\n\n🌞 이제 Lat Long의 거리 주소를 얻는 방법은 다음 코드를 사용할 수 있습니다. 주소의 부분에 액세스하고 정리하여 정리된 거리 주소를 얻는 코드를 포함하고 있습니다:\n\n```js\nString address = \"\";\n\n// 거리 주소 문자열 가져오기\nvar streets = placemarks.reversed\n    .map((placemark) => placemark.street)\n    .where((street) => street != null);\n\n// 불필요한 부분 필터링\nstreets = streets.where((street) =>\n    street!.toLowerCase() !=\n    placemarks.reversed.last.locality!\n        .toLowerCase()); // 도시 이름 제거\nstreets =\n    streets.where((street) => !street!.contains('+')); // 코드 제거\n\naddress += streets.join(', ');\n```\n\n이 부분은 거리 주소를 가져와 도시 이름 등을 제거하여, 도시 이름에 개별적으로 액세스할 수 있도록 구체적으로 만듭니다.\n\n🌞 아래 제공된 완전한 코드를 살펴보세요:\n\n<div class=\"content-ad\"></div>\n\n```dart\nimport 'package:geocoding/geocoding.dart';\n\nFuture<String> getPlacemarks(double lat, double long) async {\n  try {\n    List<Placemark> placemarks = await placemarkFromCoordinates(lat, long);\n\n    var address = '';\n\n    if (placemarks.isNotEmpty) {\n\n      // Address components without null values are concatenated\n      var streets = placemarks.reversed\n          .map((placemark) => placemark.street)\n          .where((street) => street != null);\n\n      // Unwanted parts are filtered out\n      streets = streets.where((street) =>\n          street!.toLowerCase() !=\n          placemarks.reversed.last.locality!\n              .toLowerCase()); // Remove city names\n      streets =\n          streets.where((street) => !street!.contains('+')); // Remove street codes\n\n      address += streets.join(', ');\n\n      address += ', ${placemarks.reversed.last.subLocality ?? ''}';\n      address += ', ${placemarks.reversed.last.locality ?? ''}';\n      address += ', ${placemarks.reversed.last.subAdministrativeArea ?? ''}';\n      address += ', ${placemarks.reversed.last.administrativeArea ?? ''}';\n      address += ', ${placemarks.reversed.last.postalCode ?? ''}';\n      address += ', ${placemarks.reversed.last.country ?? ''}';\n    }\n\n    print(\"Your Address for ($lat, $long) is: $address\");\n\n    return address;\n  } catch (e) {\n    print(\"Error getting placemarks: $e\");\n    return \"No Address\";\n  }\n}\n```\n\n🧑🏿‍💻 Follow for more such blogs ☺️….\n","ogImage":{"url":"/assets/img/2024-06-22-FlutterGetcompleteaddressofanylocation_0.png"},"coverImage":"/assets/img/2024-06-22-FlutterGetcompleteaddressofanylocation_0.png","tag":["Tech"],"readingTime":4},{"title":"함수를 인자로 전달하는 방법  Flutter","description":"","date":"2024-06-22 04:06","slug":"2024-06-22-PassingaFunctionasanArgumentFlutter","content":"\n\n함수를 인수로 전달하는 방법에 대해 궁금했던 적이 있으신가요? 더 나아가, 코드가 깔끔하고 가독성 있게 유지될 수 있도록 함수를 전달해야 하는 상황이 있으신가요?\n\n그렇다면 이제 시작해봅시다!\n\n![이미지](/assets/img/2024-06-22-PassingaFunctionasanArgumentFlutter_0.png)\n\nFlutter는 함수를 인수로 쉽게 전달할 수 있는 다양한 방법을 제공하며, 대부분의 방법이 비슷한 결과를 이끌어냅니다. 본 문서는 이러한 방법들을 설명하고 여러분의 지식 저고리에 추가하고자 합니다. 😁\n\n<div class=\"content-ad\"></div>\n\n이것은 가장 기본적이고 다른 모든 구현은 여기를 기반으로 합니다. 값과 함께 전달되는 옵션인 its variant Function(String val)을 통해 콜백 함수에서 전달된 값을 받을 수 있습니다.\n\n이름이 암시하듯이, 어떤 값을 전달하지 않는 함수 콜백을 선언할 수 있습니다. Function()과 같이 그냥 클릭 이벤트를 수신하고 전달하는 역할을 합니다.\n\nFlutter 프레임워크에서 제공하는 콜백 중 하나로, GestureDetector 위젯에서 탭 이벤트를 듣는 콜백입니다. GestureDoubleTapCallback, GestureTapDownCallback, GestureTapCancelCallback 등이 제공됩니다.\n\nValueChanged — 값을 변경할 때 사용됩니다.\n\n<div class=\"content-ad\"></div>\n\nValueSetter — 값이 변경되지 않아도 호출되는 ValueChanged와 동일한 시그니처를 가지고 있습니다. 비동기 상대편 AsyncValueSetter가 있습니다.\n\nValueGetter — 이벤트를 수신하고 필요할 때 호출됩니다. 비동기 상대편 AsyncValueGetter가 있습니다.\n\n콜백 함수에 ( )가 없다는 것을 알아채셨을 것입니다. 이것은 ( )을 추가하면 함수가 위젯 레이아웃 중에 빌드 메서드에 의해 실행되기 때문입니다. 더 나아가 이후 이벤트를 수신하지 않으므로 클릭 이벤트에서 콜백이 실행되지 않습니다.\n\nDO 🟢\n\n<div class=\"content-ad\"></div>\n\n```dart\nElevatedButton(onPressed: onTap, child: Text('Tap Me')),\n```\n\n금지 🛑\n\n```dart\nElevatedButton(onPressed: onTap(), child: Text('Tap Me')),\n```\n\nFlutter 2.5부터, Tear Off 개념이 받아들여졌어요.\n\n<div class=\"content-ad\"></div>\n\n단순히 함수를 매개변수로 전달하는 것 뿐입니다. 호출하지 않고 나중에 기본 위젯이 사용할 수 있도록 함수를 전달하는 것입니다. 아래와 같이 표시되어 있습니다. 이전 예제에서 이를 수행해 왔지만, 이 개념에 이름을 지어주면 더 좋습니다. \n\n```js\nElevatedButton(onPressed: onTap, child: Text('Tap Me')),\n```\n\nTearOffs에 관한 자세한 정보는 이 비디오를 확인하세요. \n\n오늘은 여기까지! 👋👋","ogImage":{"url":"/assets/img/2024-06-22-PassingaFunctionasanArgumentFlutter_0.png"},"coverImage":"/assets/img/2024-06-22-PassingaFunctionasanArgumentFlutter_0.png","tag":["Tech"],"readingTime":2},{"title":"실시간 머신 러닝 Flutter 카메라 사용 방법","description":"","date":"2024-06-22 04:03","slug":"2024-06-22-Real-TimeMachineLearningWithFlutterCamera","content":"\n\n내 최근 과제는 플러터를 사용하여 실시간 기계 학습을 수행하는 것이었는데, 많은 문제에 직면했습니다. 약 한 달 동안 이 일에 매달려 작업한 후에, 앞으로 나 자신을 위해 블로그를 써야겠다고 결정했습니다. 비슷한 일을 해야 하는 사람을 위해 쓰는 것도 포함해서요. 이 기사가 다른 누군가에게 시간을 아낄 수 있도록 한다면 좋겠어요. 그래서 그들이 구현 방법을 찾고 찾아다니지 않아도 되도록요. 전체 이야기를 전할 테니까요: 첫 번째 기계 학습 시도부터 모든 경우에 작동할 것으로 희망하는 최종 버전까지 말이에요.\n\n![image](/assets/img/2024-06-22-Real-TimeMachineLearningWithFlutterCamera_0.png)\n\n나의 작업은 플러터에서 얼굴 활성화 감지를 구현하는 것이었어요. 이 프로세스는 셀카의 활동성을 확인하는 것을 목적으로 합니다. 예전에는 시민 신분증을 갖고 실제 은행 지점에서 은행 계좌를 개설하기 위해 은행 직원과의 대면이 필요했습니다. 이제 거의 아무도 은행에 이를 정도로 가지 않아요. 대면 회의는 eKYC 프로세스로 대체되었어요. 디지털 시스템은 당신의 얼굴을 ID와 비교하여 같은 사람인지 확인합니다. 한편, 우리는 우리에게 보내는 얼굴 이미지가 정통한 얼굴인지, 멈춘 사진인지 확인해야 해요. 그래서 이를 감지하기 위해 기기에 ML이 필요합니다. 이미지를 가져와 ML에 보내고, 이미지를 확인한 후 플러터로 다시 되돌려주어야 합니다.\n\n# 첫 번째 버전\n\n<div class=\"content-ad\"></div>\n\n셀피를 찍기 위해 타이머를 1초로 설정하여 사진을 찍었고, 그 사진들을 Uint8List, 이진 형식으로 변환한 후 Flutter로 전송해 ML에 공급하기 위해 이미지를 재구축했습니다. 이 첫 번째 버전은 고급 기기에서만 잘 작동했습니다. 사진을 찍으면 시스템이 Flutter로 사진을 전송하는 데 약 300~400ms가 소요되고, 다음 사진이 찍히기 전에 약 600ms가 남았습니다. 내 iPhone 11 Pro Max는 약 300~400ms가 걸렸는데, iPhone X는 약 1,200ms가 걸려 실시간으로 간주하기에는 충분히 빨랐습니다. 게다가 iOS는 셀피를 찍는 동안 새터음을 냅니다. 이로 인해 사용자가 얼굴 확인을 할 때 좋지 않은 경험을 하게 됩니다. 그럼에도 불구하고, 이 버전은 얼굴 라이브니스 기능을 테스트할 테스터에게 전달하기에 적합합니다.\n\n# 두 번째 버전\n\n일련의 사진을 찍는 것은 충분히 빠르지 않았기 때문에 이미지 스트림을 가져와 ML에 공급하기로 결정했습니다.\n\nFlutter 카메라(https://pub.dev/packages/camera)에서 startImageStream라는 함수가 Flutter로 이미지를 스트리밍하는 기능이 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\ncontroller.startImageStream((cameraImage) async {\n   // 이미지를 ML에 제공\n});\n```\n\n여기에는 CameraImage가 반환됩니다. ML 이미지에 대한 경우 대부분의 사람들은 이미 CameraImage를 수용하는 플러터용 Firebase ML을 사용할 것으로 예상됩니다. 그것을 ML에 입력하여 결과를 얻어 UI에 표시할 수 있습니다.\n\n일부 경우에는 귀하의 요구 사항이 Firebase ML과 일치하지 않아 직접 모델을 구현해야 할 수도 있습니다. 물론 대부분의 ML 모델은 네이티브(스위프트 또는 코틀린)만 지원합니다. 즉, 플러터에서 카메라 이미지를 네이티브로 보내어 네이티브에서 작업을 수행하고 결과를 다시 보내야 합니다. 여기에 문제가 있습니다.\n\n대부분의 SDK는 RGB 형식 (JPG 또는 PNG)을 제공해야 합니다. 대부분의 경우 JPG를 사용합니다. CameraImage도 JPG를 지원하지만 Android에서만 가능합니다. iOS에서는 JPG를 지원하지 않는다는 것을 알게 되었습니다. Android에서 JPG 이미지를 수신하도록 설정하기 시작했습니다. iOS의 경우 카메라 문서를 읽어보니 두 가지 형식을 지원한다는 것을 알았습니다: YUV420과 BGRA8888. 저는 BGRA8888을 선택했습니다. 이미지와 같은 형식이기 때문에 다른 형식은 비디오 형식과 더 유사합니다.\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"/assets/img/2024-06-22-Real-TimeMachineLearningWithFlutterCamera_1.png\" />\n\nAndroid는 이미 JPG이기 때문에 어떠한 문제없이 동일한 기계 학습 모델에 공급할 수 있습니다. iOS는 두 형식을 JPG로 변환하는 방법을 찾아야 했습니다. 조사를 하다가 이를 발견했습니다.\n\n이 지침에 따르면 JPG 이미지를 얻을 수 있었지만, 여전히 프레임이 끊기는 문제가 있어 만족스럽지 않았습니다. 지속적으로 공급해야 하니 계속 이미지를 변환해야 했죠. 위의 기본만 사용하면 하나의 이미지에는 문제가 없지만, 실시간 얼굴 라이브니스에는 문제가 있습니다.\n\n이 문제를 해결하기 위해 저는 Flutter에서 스로틀링 기능을 추가했습니다. Flutter에서 보낸 각 카메라 이미지에 대해, 500ms마다 이미지를 한 번만 변환하는 방식으로 구현했습니다. Flutter는 이미지를 20~30ms마다 반환합니다. 시행착오 끝에, 30ms와 500ms가 사용 사례에 큰 차이가 없음을 느꼈습니다. 화면 중앙에 얼굴이 고정되어 움직임이 빠르지 않기 때문에 사용자는 지연을 느끼지 않을 것입니다.\n\n\n<div class=\"content-ad\"></div>\n\niOS에서 벽에 부딪혀 안달이 났을 때, 다른 방향으로 가기로 결정해서 Android로 전환하기로 했습니다. 적어도 한 플랫폼에서 잘 되게 만들어놓고, 나중에 나머지에 집중할 수 있게 하기 위해서였죠. Android에서는 JPG 형식이 잘 작동하며 성능도 꽤 좋았어요. 하지만 Kotlin으로 보낸 이미지들이 90도 회전된 채로 도착하는 문제가 있었습니다. 솔직히 이해가 안 가요. Flutter에서 왜 90도 회전된 이미지를 다시 보내야 할까요? 😢 그래도 전 세계 사람들이 사용하는 라이브러리니까 어떤 이유가 있겠죠. 나는 Kotlin 코드를 사용해서 비트맵을 만들고 이미지를 270도 회전하여 Matrix에 넣은 후 ML로 전달하기로 결정했어요. 중간 규모의 Android는 여전히 이미지를 만들고 회전시키고 바이너리로 변환하는 전체 프로세스가 많은 전력을 소비하여 조금 느렸어요. 하지만 여전히 사진을 찍고 ML에 보내는 것보다는 낫다고 생각했죠. 고급 Android는 잘 작동했지만 중간 규모는 약간 느렀고, 저급 Android는 사용할 수 없었습니다. 그래도 당시에는 충분했어요.\n\niOS로 돌아와서, Flutter에서 스레딩 아이디어를 생각해냈습니다. 이 기사의 지침을 따라했죠.\n\n보통 Flutter에서는 대부분 await 함수가 스레드를 차단하지 않기 때문에 스레딩이 거의 필요하지 않죠. 그러나 iOS에서는 스레드를 생성하고 지속적으로 복잡한 작업을 스레드에 넣어야 하는 경우가 많아요.\n\nDart에서 처음으로 스레딩을 사용하기로 결정했습니다. 상기한 기사를 따라하니 decodeImage의 샘플을 얻고 Flutter의 Image 라이브러리를 사용해 BGRA를 RGB로 변환했습니다.\n\n<div class=\"content-ad\"></div>\n\n와우! 결과가 완전히 다르게 나왔네요. 내 iPhone X는, BTS가 말하는 대로, 바터처럼 부드러웠어요 😄\n\n이제 두 번째 버전이 중상 및 고상위 iOS 및 안드로이드를 지원할 수 있다는 것을 증명했습니다. 더 많은 사용자들로 시험해보는 시간이 왔어요.\n\n더 넓은 테스트 후, 중요한 문제를 발견했습니다: ImageFormatGroup.jpeg 내의 JPG 플래그가 일부 기기에서 지원되지 않아요!!!\n\n이 오류를 만났습니다: GetYUVPlaneInfo: 잘못된 형식이 전달되었어요: 0x21\n\n<div class=\"content-ad\"></div>\n\n20개의 안드로이드 디바이스 중에서 이미지를 JPG로 스트리밍하려고 시도할 때 Xiaomi Note 8만 충돌했습니다. 이 문제가 이 모델에만 해당되었는지 또는 이 기능을 프로덕션 환경에 론칭했을 때 이 문제가 발생할 수 있는 다른 디바이스가 있는지 알 수 없습니다.\n\n조사를 거친 결과 ImageFormatGroup.yuv420로 변경하면 문제가 발생하지 않는 것으로 보입니다. 제가 위험을 감수하고 기능을 프로덕션에 푸시하고 싶지 않아서 Flutter의 기본 형식인 YUV420로 결정했습니다. 조사를 통해 인터넷에서 이 코드를 얻었습니다. 이를 통해 CameraImage를 Android로 전달하여 이미지를 생성할 수 있었습니다.\n\n```js\nList<int> strides = Int32List(image.planes.length * 2);\nint index = 0;\nList<Uint8List> data = image.planes.map((plane) {\n   strides[index] = (plane.bytesPerRow);\n   index++;\n   strides[index] = (plane.bytesPerPixel)!;\n   index++;\n   return plane.bytes;\n}).toList();\nawait _channel.invokeMethod<Uint8List>(\"checkLiveness\", {\n  'platforms': data,\n  'height': image.height,\n  'width': image.width,\n  'strides': strides\n});\n```\n\n안드로이드에서는 YUV를 JPG로 변환하는 코드를 이 페이지에서 가져왔습니다.\n\n<div class=\"content-ad\"></div>\n\n구현된 후에도 기능이 잘 작동했어요, 아직은 Android에서 JPG 문제를 해결한 것이 전부라서 조금 느리긴 했지만요.\n\n이제 사용자 경험을 개선하기 위해 성능을 향상시키는 시간이에요.\n\nKotlin 코루틴을 연구해서 스레딩 작업을 수행하고, Kotlin 코드에 적용해서 프로세스를 더 부드럽게 만들었어요. 결과는 매우 긍정적이었고 Android가 매우 부드럽게 작동하고 모든 단계에서 잘 작동했어요. 심지어 가장 낮은 단계도 여전히 부드러워졌어요. 제 Oppo a3s에서도 레이븐스(?)가 약간 끊김 없이 작동해요.\n\n# 최종 버전\n\n<div class=\"content-ad\"></div>\n\n이번에는 저렴한 iOS 기기인 iPhone 6s, 6s Plus, 그리고 7를 조사했어요.\n\n중간급 기기에는 Isolate가 버벅거리지 않고 잘 작동하는 것을 발견했지만, 저급 기기에는 그렇지 않았어요. Isolate가 작업을 완료하는 데 약 1-1.5초가 걸리고, 라이브니스 감지에는 또 1.5초가 소요되었는데, 이는 느린 디바이스에서는 사용자가 처리하기에 너무 많은 시간이 걸렸어요. 그래서 저는 네이티브로 전환하기로 결정했고, 그곳의 성능은 제 기대를 뛰어넘었어요. 1.5초에서 약 0.01초로 성능이 향상되었답니다!!! 제가 이미지 변환 코드를 기사 끝에 저장소로 변환하는 내용을 공유했어요. 여기 이미지를 변환하는 샘플 코드가 있어요.\n\n```js\nprivate func bytesToPixelBuffer(width: Int, height: Int, baseAddress: UnsafeMutableRawPointer, bytesPerRow: Int) -> CVBuffer? {\n   var dstPixelBuffer: CVBuffer?\n   CVPixelBufferCreateWithBytes(kCFAllocatorDefault, width, height,    kCVPixelFormatType_32BGRA, baseAddress, bytesPerRow,\n   nil, nil, nil, &dstPixelBuffer)\n   return dstPixelBuffer ?? nil\n}\nprivate func createImage(from pixelBuffer: CVPixelBuffer) -> CGImage? {\n   var cgImage: CGImage?\n   VTCreateCGImageFromCVPixelBuffer(pixelBuffer, options: nil,    imageOut: &cgImage)\n   return cgImage\n}\nprivate func createUIImageFromRawData(data: Data, imageWidth: Int, imageHeight: Int, bytes: Int) -> UIImage? {\n   data.withUnsafeBytes { rawBufferPointer in\n      let rawPtr = rawBufferPointer.baseAddress!\n      let address = UnsafeMutableRawPointer(mutating:rawPtr)\n      guard let pxBuffer = bytesToPixelBuffer(width: imageWidth, height: imageHeight, baseAddress: address, bytesPerRow: bytes), let cgiImage = createImage(from: pxBuffer) else {\n      return nil\n   }\n   return UIImage(cgImage: cgiImage)\n}\n```\n\n마지막 문제와 마지막 큰 장벽: 플러터 이미지 스트림이었습니다.\n\n<div class=\"content-ad\"></div>\n\nFlutter 프로젝트를 생성해보고, Flutter 카메라를 구현하여 이미지 스트림을 열어 어떤 작업도 수행하지 않았어요. 그런데 여전히 저사양 아이폰에서는 렉이 있었어요. 이미지 스트림을 끄면 미리보기가 다른 아이폰처럼 부드럽게 나타났어요. 그렇다면, 이미지 스트림에서 이미지를 얻지 않고 살아있는지 감지하는 방법은 무엇일까요?\n\n결국, 이 문제를 해결하는 방법을 고민하다가 한 가지 방법을 찾아냈어요: 이미지 스트림을 시작한 후 50ms 후에 끄는 거예요. 면밀히 관찰해보면, Flutter 앱이 50ms 동안 렉이 발생하는 것 같지만 대부분의 경우에는 사용자가 느끼지 못할 거예요. 그 50ms 동안, 카메라 이미지에서 1~2개의 이미지를 얻고 이를 기계 학습에 사용했어요.\n\n이렇게 한 후에, 작은 렉이 있더라도 iPhone 7 Plus로 얼굴 실시간 감지를 수행할 수 있었어요. iPhone 6s 및 6s Plus의 경우에는 훨씬 개선되었어요. 결과는 아래에서 확인할 수 있어요.\n\n## 성능 검사\n\n<div class=\"content-ad\"></div>\n\niPhone 11 Pro Max - CPU 53%, Memory 190MB, image returns every 20-40 ms\n\n![Image](/assets/img/2024-06-22-Real-TimeMachineLearningWithFlutterCamera_2.png)\n\niPhone 6s - CPU 118%, Memory 160MB, image returns every 20-30 ms\n\n![Image](/assets/img/2024-06-22-Real-TimeMachineLearningWithFlutterCamera_3.png)\n\n<div class=\"content-ad\"></div>\n\niPhone 6s Plus - CPU 138%, Memory 187 MB, 이미지는 20-50 ms마다 반환됩니다.\n\n![이미지](/assets/img/2024-06-22-Real-TimeMachineLearningWithFlutterCamera_4.png)\n\n카메라 스트림 없는 iPhone 6s Plus에서는 카메라 미리보기만 열면 CPU 소비량이 46%입니다.\n\n![이미지](/assets/img/2024-06-22-Real-TimeMachineLearningWithFlutterCamera_5.png)\n\n<div class=\"content-ad\"></div>\n\n아이폰 6s Plus의 스트림을 켜고 끕니다. 배터리 수명이 50%에서 70% 사이로 오르내리고 있어요.\n\n![이미지](/assets/img/2024-06-22-Real-TimeMachineLearningWithFlutterCamera_6.png)\n\n안드로이드로는 저의 저가형 기기, 2018년 출시된 Oppo A3s를 사용 중입니다. 안드로이드 버전은 8.1.0이고 RAM은 2GB입니다. iPhone 6s보다 더 좋은 성능을 보여주고 있어요. 이미지 스트림은 항상 열려 있고 CPU 소비량은 14% 정도, RAM 소비량은 약 320MB 정도입니다.\n\n![이미지](/assets/img/2024-06-22-Real-TimeMachineLearningWithFlutterCamera_7.png)\n\n<div class=\"content-ad\"></div>\n\n한편, 네이티브 카메라를 사용하는 iPhone 6s Plus는 CPU 소비가 단 57%, 메모리는 39.1MB만 사용해요. \n\n![image](/assets/img/2024-06-22-Real-TimeMachineLearningWithFlutterCamera_8.png)\n\n모든 중간급 iOS 및 모든 Android에서 모두 잘 작동하고 있어요. 그러나 제가 위에 공유한 코드에서 UIImage로 남은 문제가 하나 있어요. 라이브니스가 반환한 이미지를 사용해야 할 때, Thread 1: EXC_BAD_ACCESS 오류가 발생했어요.\n\n![image](/assets/img/2024-06-22-Real-TimeMachineLearningWithFlutterCamera_9.png)\n\n<div class=\"content-ad\"></div>\n\nCGDataProvider_BufferIsNotBigEnough 에 대한 해결 방법을 찾아보려고 구글링을 해봤지만, 제 문제와 관련된 내용을 찾을 수 없었어요. 어떤 사람들은 이미지가 너무 크거나 핸드폰이 오래되었다고 언급했더라구요! 저의 가장 빠른 장치인 iPhone 11 Pro Max 도 문제가 있었기 때문에 그것이 결코 아니었어요. 작은 이미지를 공급하고 더 천천히 이미지를 라이브네스에 공급하는 여러 방법을 시도해봤지만, 아무 것도 성공하지 못했어요. 제 마음은 완전히 공허했죠. 이게 뭐지? 라이브네스인가, 제 코드가 문제인가? 여러 실험과 오류를 통해 몇 일을 조사한 끝에, 마침내 라이브네스가 성공했을 때 SDK에 공급한 이미지가 값을 참조하는 형식으로 반환되었다는 것을 깨달았어요. 그 이미지는 값이 아닌 참조 유형으로 전달되었다는 걸 알게 되었죠. 그러면서 참조 타입을 값 타입으로 복사하는 방법을 찾다가, PixelBuffer에 대한 깊은 복사 함수를 찾았어요. 이를 프로젝트에 추가하고, 메모리 액세스 문제가 마침내 해결되었어요. 모든 게 이제 괜찮아졌어요. 휴..\n\n# 최종 결론!!\n\n![image](/assets/img/2024-06-22-Real-TimeMachineLearningWithFlutterCamera_10.png)\n\n플러터는 개발 시간을 줄여주는 것이 목적이에요. 만약 이 목적을 제대로 이루지 못한다면, 우리는 그냥 네이티브 방식으로 할 수 있어요. 큰 문제없죠, 모든 문제를 해결하는 마법같은 해결책은 아니잖아요 😁 Flutter에 투자한 시간을 통해 모든 문제를 해결하는 대신 네이티브 방식으로 해결할 수 있다고 믿어요.\n\n<div class=\"content-ad\"></div>\n\n업데이트: 2024년 12월 15일\n\nFlutter 방식 대신 네이티브 방식으로 작동하도록 코드를 수정하고 다시 작성했습니다. 자세한 내용은 아래 Medium에서 확인할 수 있어요.\n\n더 간단한 방법을 사용하려는 사람들을 위해 이 기사를 계속 따라가실 수 있어요.\n\n여기에는 대본 샘플 프로젝트가 있어요: 최종 버전에서 배운 모든 것을 구현했습니다. Flutter로 계속 작업하고 싶은 사람은 이것을 확인하세요.\n\n<div class=\"content-ad\"></div>\n\n이 비디오는 플러터 스트림을 사용하여 성능 비교를 보여주는 것입니다.\n\n앱 내부 얼굴 라이브니스 감지와 모든 것을 구현한 후 최종 결과는 여기 있어요.\n\n# 요약\n\n플러터 카메라 이미지는 저렴한 기기에 적합하지 않습니다. 왜냐하면 그것은 지속적으로 이미지를 플러터로 돌려보냅니다. 플러터 카메라에 반환할 수 있는 프레임 속도의 매개변수가 있다면 많은 도움이 될 것이라고 생각합니다. 쓸모없는 오버헤드 이미지를 처리해야 하는 상황이었기 때문에 쓰로틀링을 해도 플러터는 여전히 이미지를 처리해야 했습니다. 20-30ms 마다 이미지를 가져오는 대신 대신 200ms 마다 이미지를 가져올 수 있다면, 작업이 90% 줄어들 것이라고 생각합니다!\n\n<div class=\"content-ad\"></div>\n\n요청이 지금까지 2년 넘게 열려 있어요.\n\n아마 곧 일어날 것 같진 않으니까, 일단 네이티브로 진행해보자. 이 카메라에 기능을 추가하기 위해 MR을 오픈하고 싶지만 할 수 있는 기회가 있을지 보자구.\n\n자신의 프로젝트에 얼굴 라이브니스를 구현하고 싶은 사람이 있으면 플러터나 네이티브로, KBTG나 저에게 연락해주세요. 저는 여러분의 요청을 저희 팀에 전달해 드릴게요. 저희의 KBTG 얼굴 라이브니스는 iBeta가 테스트한 ISO 30107-3를 통과했습니다.\n\n![이미지](/assets/img/2024-06-22-Real-TimeMachineLearningWithFlutterCamera_11.png)\n\n<div class=\"content-ad\"></div>\n\n참고 웹사이트:\n\n이와 같은 이야기를 더 읽고 싶나요? 또는 최신 기술 트렌드를 따라가고 싶나요? 더 많은 정보를 원하시면 www.kbtg.tech에서 확인해보세요.","ogImage":{"url":"/assets/img/2024-06-22-Real-TimeMachineLearningWithFlutterCamera_0.png"},"coverImage":"/assets/img/2024-06-22-Real-TimeMachineLearningWithFlutterCamera_0.png","tag":["Tech"],"readingTime":11},{"title":"중급 Flutter 인터뷰 질문 상위 목록","description":"","date":"2024-06-22 04:02","slug":"2024-06-22-TopIntermediateFlutterInterviewQuestions","content":"\n\n- Tree shaking이란 무엇인가요?\n\nTree shaking은 빌드 프로세스 중에 번들에서 사용되지 않는 모듈을 제거하는 최적화 기술입니다. 이는 코드를 최적화하기 위해 사용되는 미사용 코드 제거 기술입니다.\n\n- 핫 리로드 vs 핫 리스타트\n\n핫 리로드는 코드 변경 사항을 VM에로드하고 위젯 트리를 다시 빌드하여 응용 프로그램 상태를 보존합니다. 이는 main() 또는 initState()을 다시 실행하지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n핫 리스타트는 코드 변경 사항을 VM에 로드하고 Flutter 앱을 다시 시작하여 앱 상태를 잃게 됩니다.\n\n풀 리스타트는 iOS, Android 또는 웹 앱을 다시 시작합니다. 네이티브 코드를 다시 컴파일하기 때문에 시간이 더 걸립니다. 웹에서는 Dart 개발 컴파일러도 다시 시작됩니다.\n\n플러터 웹은 현재 핫 리스타트를 지원하지만 핫 리로드는 지원하지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n4. Package vs Plugin?\n\n플러그인에는 Dart 및 네이티브 코드(kotlin/js/swift/...)가 모두 포함되어 있지만, 패키지에는 Dart 코드만 포함되어 있습니다. 그러나 패키지는 내부적으로 플러그인을 참조할 수 있습니다.\n\n4. Inherited Widget이란 무엇인가요?\n\n트리 아래로 정보를 효율적으로 전파하는 위젯의 기본 클래스입니다.\n\n<div class=\"content-ad\"></div>\n\n5. Inherited Widget vs Provider?\n\n대규모 애플리케이션에서 InheritedWidget을 사용하면 build 메서드가 항상 전체 build 메서드를 다시 만들어야 합니다. 그러나 Provider를 사용하면 특정 블록을 제어하는 매우 특정한 Consumer 위젯이 있으므로 더 효율적입니다.\n\n6. Stateful Widget 라이프사이클 메서드 정의:\n\n- createState: 이 메서드는 위젯의 상태 객체를 생성합니다.\n- initState: 이 메서드는 위젯의 상태를 초기화하는 데 호출됩니다.\n- didChangeDependencies: 이 메서드는 State 객체의 종속성이 InheritedWidget을 통해 변경될 때 호출됩니다.\n- build: 위젯이 다시 빌드될 때마다 호출됩니다. initState, didChangeDependencies, didUpdateWidget 이후에 또는 setState를 통해 상태가 변경될 때 발생할 수 있습니다.\n- didUpdateWidget: 이 메서드는 새로운 속성으로 위젯이 업데이트될 때 호출됩니다.\n- setState: 업데이트를 트리거합니다.\n- deactivate: 이 메서드는 GlobalKey를 사용하여 서브트리 A에서 State가 제거되고 서브트리 B로 재삽입될 때 호출됩니다.\n- dispose: 이 메서드는 위젯이 영구적으로 파괴되기 직전에 호출됩니다.\n\n<div class=\"content-ad\"></div>\n\n7. initState 메서드는 위젯에서 몇 번 호출될 수 있나요?\n\n한 번만 호출됩니다.\n\n8. Dart에서 게으른 초기화가 존재하나요? 존재한다면 어떻게 객체를 게으르게 초기화할 수 있나요?\n\n네, late 키워드를 사용하여 게으르게 초기화할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n9. SizedBox vs Container\n\nSizedBox는 크기 조정이나 여분 공간을 가지는 데 사용됩니다. 색상, borderRadius 등과 같은 장식적 속성은 포함되지 않습니다.\n\n반면에 Container()는 수정할 수 있는 위젯입니다.\n\n10. const vs final\n\n<div class=\"content-ad\"></div>\n\n상수 값은 컴파일 시간에 알려져야 하지만, 최종 값은 실행 시간에 알려져야 합니다.\n\n최종 변수는 재할당할 수 없지만, 객체는 변경할 수 있습니다.\n\n11. const widget의 목적은 무엇인가요?\n\n상태 변경(예: setState)의 경우, const 위젯은 다시 구축되지 않습니다.","ogImage":{"url":"/assets/img/2024-06-22-TopIntermediateFlutterInterviewQuestions_0.png"},"coverImage":"/assets/img/2024-06-22-TopIntermediateFlutterInterviewQuestions_0.png","tag":["Tech"],"readingTime":3},{"title":"Flutter에서 벤치마크를 추가하는 방법","description":"","date":"2024-06-22 04:01","slug":"2024-06-22-HowdoIaddabenchmarktoflutter","content":"\n\n<img src=\"/assets/img/2024-06-22-HowdoIaddabenchmarktoflutter_0.png\" />\n\n플러터를 사용하는 개발자로서, 성공적인 애플리케이션을 만드는 가장 중요한 측면 중 하나는 다양한 기기와 플랫폼에서 잘 작동하는지 확인하는 것입니다. 플러터 앱의 성능을 측정하는 한 가지 방법은 속도, 메모리 사용량 및 기타 중요한 지표를 추적하는 벤치마크를 추가하는 것입니다. 이 글에서는 플러터 앱에 벤치마크를 추가하는 방법을 탐색하고, 그렇게 하는 이점에 대해 논의할 것입니다.\n\n플러터 앱에 벤치마크를 추가하려면 Flutter Driver 패키지를 사용해야 합니다. 이 패키지는 Flutter 앱을 테스트하고 벤치마킹하는 데 필요한 도구 세트를 제공합니다.\n\nFlutter Driver 패키지를 사용하면 앱의 UI와 상호 작용하는 테스트를 작성하고 성능을 측정할 수 있습니다. Flutter Driver를 사용하여 사용자 상호작용을 모방하고 해당 상호작용에 대한 앱의 응답 시간을 추적하는 벤치마크를 만들 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n플러터 앱에 벤치마크를 추가하기 시작하려면 먼저 pubspec.yaml 파일에 Flutter Driver 패키지를 추가하여 설치해야 합니다. 패키지를 설치한 후에는 측정하고자 하는 상호 작용을 정의하는 테스트 스크립트를 작성하여 벤치마크 테스트를 생성할 수 있습니다.\n\n예를 들어, 데이터베이스에서 항목 목록을로드하는 데 앱이 얼마나 오래 걸리는지 또는 사용자가 버튼을 누르는 것에 얼마나 빨리 응답하는지를 측정하는 벤치마크 테스트를 만들 수 있습니다.\n\n플러터 앱에 벤치마크 테스트를 작성할 때는 측정하려는 구체적인 성능 지표를 고려하는 것이 중요합니다. 앱의 시작 시간, 프레임 속도, 메모리 사용량 및 CPU 사용량과 같은 일반적인 지표를 추적하는 것이 좋습니다. 벤치마크 테스트에서 이러한 지표를 정의하면 앱이 다른 조건 하에서 어떻게 성능을 발휘하는지 이해할 수 있고 성능을 최적화할 수 있는 부분을 식별할 수 있습니다.\n\n플러터 앱을 위한 벤치마크 테스트를 작성하고 나면 Flutter Driver 명령줄 도구를 사용하여 실행할 수 있습니다. Flutter Driver 도구를 사용하면 다양한 장치 및 플랫폼에서 벤치마크 테스트를 실행하여 앱의 성능을 다양한 환경에서 비교하는 것이 쉬워집니다.\n\n<div class=\"content-ad\"></div>\n\n귀하의 벤치마크 테스트를 정기적으로 실행하여 앱의 성능이 시간이 지남에 따라 어떻게 변하는지 추적하고 처리해야 할 성능 저하 사항을 식별할 수 있습니다.\n\n플러터 앱에 벤치마크를 추가하면 여러 가지 이점이 있습니다. 무엇보다도 벤치마크는 귀하의 앱 성능에 대한 유용한 통찰력을 제공하여 병목 현상과 개선이 필요한 영역을 파악하는 데 도움이 됩니다. 주요 성능 지표를 측정함으로써, 앱의 코드를 최적화하고 전반적인 성능을 개선하는 데에 대한 정보를 얻을 수 있습니다.\n\n앱의 성능을 최적화하는 데 도움을 주는 것 이외에도 벤치마크는 향후 개발 노력의 기준이 될 수 있습니다. 앱의 성능을 기준으로 설정함으로써 코드 변경이 속도와 효율성에 어떤 영향을 미치는지 추적할 수 있습니다. 이를 통해 새로운 기능과 업데이트가 앱의 성능을 저하시키지 않게 하고 사용자에게 높은 수준의 품질을 유지할 수 있습니다.\n\n결론적으로, 플러터 앱에 벤치마크를 추가하는 것은 다양한 기기와 플랫폼에서 잘 작동하도록 보장하기 위한 중요한 단계입니다. 플러터 드라이버 패키지를 사용하여 벤치마크 테스트를 생성하여 주요 성능 지표를 측정하고 최적화할 영역을 식별할 수 있습니다. 정기적으로 벤치마크 테스트를 실행하고 앱의 성능을 추적함으로써, 속도, 메모리 사용량 및 전반적인 효율성을 개선하는 방법에 대해 정보 기반 결정을 내릴 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n개발 과정에 벤치마킹을 통합하여 매끄럽고 반응이 빠른 사용자 경험을 제공하는 고품질의 Flutter 앱을 만들 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-22-HowdoIaddabenchmarktoflutter_0.png"},"coverImage":"/assets/img/2024-06-22-HowdoIaddabenchmarktoflutter_0.png","tag":["Tech"],"readingTime":3},{"title":"아이디어를 현실로 대학 시절 AiGrid 개발 이야기","description":"","date":"2024-06-22 04:00","slug":"2024-06-22-TurningIdeasintoRealityDevelopingAiGridDuringMyUniversityYears","content":"\n\n\n![Image](/assets/img/2024-06-22-TurningIdeasintoRealityDevelopingAiGridDuringMyUniversityYears_0.png)\n\n# 소개\n\n대학생으로서 AiGrid를 개발하는 것은 저에게 놀라운 경험이었습니다. 저는 항상 프로젝트를 통해 지식을 공유하고 다른 사람들을 돕는 것을 원했습니다. 어느 날, 모든 AI 도구를 한 곳에 모은 플랫폼을 만들어보자는 아이디어가 떠올랐습니다. 인터넷에는 이와 유사한 많은 플랫폼이 있지만, 저는 독특한 기능을 갖춘 나만의 플랫폼을 만들고 싶었습니다. 이 프로젝트는 제 기술적 역량을 향상시킬 뿐만 아니라 프로젝트 관리와 사용자 중심의 디자인에 관한 소중한 통찰력을 제공하여 제 경력에서 중요한 이정표를 만들었습니다.\n\n# 작동 방식\n\n\n<div class=\"content-ad\"></div>\n\n사용자들은 이미지 생성, 텍스트 생성 등 다양한 기능을 위한 AI 도구를 탐색할 수 있습니다. 게다가, 사용자들은 플랫폼에 새로운 도구를 기여할 수도 있습니다. 사용자가 사이트에 새로운 도구를 제출하면, 저는 관리 앱에서 해당 제출을 받게 됩니다. 그 후에, 제출을 승인하거나 거절할 수 있습니다. 승인되면, 새로운 도구가 웹사이트에 표시됩니다.\n\n# 컨셉\n\n이 아이디어는 TikTok을 스크롤하면서 떠올랐어요. 사람들이 새로운 AI 도구를 공유하는 것을 보고, \"왜 이러한 도구들이 모두 한 곳에서 찾아볼 수 있는 장소를 만들지 않았을까?\" 라는 생각을 했습니다. 사용자들은 플랫폼에 새로운 도구를 추가함으로써 이에 기여할 수도 있습니다.\n\n# 계획\n\n<div class=\"content-ad\"></div>\n\n초기 계획 단계에서는 HTML, CSS 및 JavaScript을 사용하여 간단한 웹 인터페이스를 만들었습니다. 도구 데이터가 포함된 JSON 파일을 호스팅했고, 새로운 도구 제출은 이메일을 통해 수신하며, 직접 JSON 파일에 추가했습니다. 이 프로세스는 혼란스럽고 처리하기 어려웠습니다. 더 나은 솔루션을 위해 약 일주일 정도 계획을 하고, Eraser.io를 사용하여 프로젝트 계획을 하게 되었습니다. 그래서 기본 사이트를 ReactJS로 변환하기로 결정했습니다.\n\nReactJS 및 UI 프레임워크로 Tailwind CSS를 사용하여 웹 사이트를 개발했습니다. Tailwind를 배워야 했기 때문에 이 프로젝트를 기회로 삼았습니다. 데이터베이스로는 제 요구 사항에 맞는 현대적인 솔루션인 Firebase Firestore를 선택했습니다. 또한 관리자 패널을 작성하고, Flutter 및 Firebase Auth를 사용하여 Android 및 iOS 애플리케이션을 개발했습니다. 이제 사용자가 사이트를 통해 새 도구를 제출하면, 앱에 나타나서 승인 또는 거부할 수 있습니다. 앱에서 데이터베이스의 모든 도구를 관리할 수 있습니다.\n\n# 개발 과정\n\n![이미지](/assets/img/2024-06-22-TurningIdeasintoRealityDevelopingAiGridDuringMyUniversityYears_1.png)\n\n<div class=\"content-ad\"></div>\n\n환경 설정하기\n\n저는 React를 사용하여 프론트엔드, Firebase를 사용하여 데이터베이스를 포함한 필수 도구 및 라이브러리를 갖춰 개발 환경을 설정하기 시작했습니다. 모바일 앱의 경우, Material Design 3과 함께 Flutter와 Dart를 사용했습니다. 코드 관리를 위해 GitHub를 통한 버전 관리 설정은 중요한 요소였습니다.\n\nUI/UX 디자인하기\n\n직관적이고 매력적인 UI/UX를 디자인하는 것이 우선이었습니다. 제가 Wireframing과 Prototyping에 Figma를 사용하여 인터페이스가 사용자 친화적이고 시각적으로 매력적인지를 보장했습니다. 디자인 반복 과정 중 사용자 피드백을 통해 플랫폼 전체적인 외관과 느낌을 정제하는 데 도움이 되었습니다.\n\n<div class=\"content-ad\"></div>\n\n# 미래 개선 사항\n\n앞으로는 리더보드, 사용자 계정 등 더 많은 기능을 추가할 계획입니다.\n\n# 이 프로젝트에서 배운 점\n\n이 프로젝트를 통해 개인으로 프로젝트를 처음부터 끝까지 계획하고 실행하는 방법을 배웠습니다. ReactJS 및 Tailwind를 사용하여 웹 개발에서 경험을 쌓았으며 Firebase Firestore를 웹 및 모바일 애플리케이션에 연결하고, Flutter를 사용하여 크로스 플랫폼 앱을 만들고 GitHub를 통해 버전 관리를 하는 방법을 익혔습니다.\n\n<div class=\"content-ad\"></div>\n\nAiGrid을 탐험하고 피드백을 공유해보세요. 플랫폼을 향상시키는 데 귀중한 제안이 될 것이며, AI 도구 및 자원의 주요 목적지로 만드는 데 도움이 될 것입니다.\n\nDizzpy | 즐거운 코딩! 🖥️🥰","ogImage":{"url":"/assets/img/2024-06-22-TurningIdeasintoRealityDevelopingAiGridDuringMyUniversityYears_0.png"},"coverImage":"/assets/img/2024-06-22-TurningIdeasintoRealityDevelopingAiGridDuringMyUniversityYears_0.png","tag":["Tech"],"readingTime":3},{"title":"Dart에서 Extension Types으로 할 수 있는 것들","description":"","date":"2024-06-22 00:40","slug":"2024-06-22-WhatcanIdowithExtensionTypesinDart","content":"\n\nDart 3.3 확장 타입\n\n![Image](/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_0.png)\n\n공식 문서는 다음과 같이 시작합니다:\n\n확장 타입은 강력한 타입 래퍼로 작용하는 컴파일 시간 추상화입니다. 성능 최적화를 위해 도입되었으며 네이티브 코드와의 향상된 상호작용을 제공합니다. Zero-cost 래퍼로서, 다른 언어와 통신할 때 Wrapper 클래스와 Helper 클래스와 관련된 전형적인 메모리 비용을 제거합니다.\n\n<div class=\"content-ad\"></div>\n\n일반 클래스 래퍼는 런타임에서 작동하며 항상 클래스 및 객체 사용량의 오버헤드가 발생하여 메모리 사용량과 GC(Garbage Collection) 비용이 증가합니다. 단기간에 많은 래퍼 인스턴스가 생성되는 시나리오에서는 이 부담이 상당해집니다.\n\n확장 유형은 특정 유형의 확장으로 컴파일 시간에 확인되므로 런타임에서는 원래 표현 유형으로 되돌아가며 추상화가 사라집니다. 따라서 확장 유형을 사용하면 응용 프로그램에 비용이 발생하지 않아 매우 효율적인 개발 방법이 됩니다.\n확장 유형은 정적 JavaScript 상호 운용을 가능하게 하며, 기존 JavaScript 유형과의 원활한 상호 작용을 허용합니다.\n\n# 혜택\n\n<div class=\"content-ad\"></div>\n\n## 유연한 제한과 확장\n\n기존 유형(예: int 또는 String)을 속성, 함수 및 다른 API를 추가하여 향상시킬 수 있습니다.\n\n## 더 명확한 추상화\n\n기본 표현 유형의 복잡성을 숨겨 의미 있는 확장을 가능하게 하여 코드 가독성과 유지 관리성을 향상시킵니다.\n\n<div class=\"content-ad\"></div>\n\n## 편리하고 안전한 상호 운용성\n\nDart 사용자 정의 유형은 기본 유형에 액세스하는 것만큼 간단하여 유형 안전성을 제공합니다. 이는 네이티브 플랫폼 및 다른 언어와의 상호 운용성에 특히 유용하며, 프로세스를 간소화합니다.\n\n## 향상된 성능\n\n각 서비스마다 Wrapper 클래스를 생성하지 않아 추가 메모리 오버헤드가 발생하지 않습니다. 특히 대량 데이터 집합이나 빈번한 객체 작업을 처리할 때 성능에 민감한 시나리오에 이상적입니다.\n\n<div class=\"content-ad\"></div>\n\n# 개발\n\n확장 형식은 선언될 때 기본 생성자가 자동으로 포함됩니다.\n\n```js\nextension type MyId(int id) {}\n\nvoid main(List<String> arguments) {\n  final id = MyId(1);\n  \n  print(id); // 1 \n  print(id.runtimeType); // int\n}\n```\n\n어떤 경우에도 확장 형식에 의해 래핑된 형식은 \"표현 형식\"으로 불리며 서브타입이 아닙니다. 따라서 일반적으로 표현 형식과 사용자 정의 확장 형식은 서로 값 할당이 불가능합니다.\n\n<div class=\"content-ad\"></div>\n\n사용자 정의된 새로운 속성과 함수 인터페이스가 없을 때에는 기능적인 작업이 없습니다. int의 원래 동작이 제한됩니다.\n\n![extension types in Dart](/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_1.png)\n\n기존 유형에 대해서는 더 많은 확장이나 유형의 제약 사항에 대해 노출되는 것이 아닌 사용 가능한 API만 노출되며, 그렇게 함으로써 일부 허용되지 않는 작업을 피할 수 있습니다. 우리가 필요로 하는 의미 있는 함수를 추가할 수 있습니다.\n\n```dart\nextension type MyId(int id) {\n  operator >(MyId other) => id > other.id;\n  \n  bool isBiggerThan(MyId other) => id > other.id;\n}\n\nvoid main(List<String> arguments) {\n  MyId safeId = MyId(200);\n  safeId + 10; // Compile error: No '+' operator.\n  safeId - 10; // Compile error: No '-' operator.\n  safeId > 10; // Compile error: Wrong type.\n  safeId > MyId(300); // ✅\n\n  int number = 100;\n  number = safeId; // Compile error: Wrong type.\n  number = safeId as int; // ✅ Cast to representation type.\n  safeId = number as MyId; // ✅ Cast to extension type.\n\n  print(safeId.isBiggerThan(MyId(300))); // false\n}\n```\n\n<div class=\"content-ad\"></div>\n\n서비스나 네이티브 API와 상호 작용 후 반환된 값은 int를 사용하여 가독성을 높일 수 있어요. 확장 유형을 통해 특정 이름을 지정할 수 있어요. 이렇게 하면 한눈에 이해하기 쉬워져요.\n\n확장 유형과 표현 유형은 as 캐스팅을 사용하여 직접 변환할 수 있어요. 재미있는 점은 상속 관계가 아님에도 불구하고 강제로 변환할 수도 있어요.\n\n```js\ni = id as int; // ✅\ni = -1;\nid = i as Id;  // ✅\n```\n\n다트 클래스처럼 확장 유형을 일반적으로 처리하고 인스턴스화하고 사용자 정의 함수를 호출할 수 있는 예제가 있어요. 다트는 이를 일반 int로 컴파일해요.\n\n<div class=\"content-ad\"></div>\n\n```dart\nextension type Wrapper(int i) {\n  void showValue() {\n    print('my value is $i');\n  }\n}\n\nvoid main() {\n  final wrapper = Wrapper(42);\n  wrapper.showValue(); // Prints 'my value is 42'\n}\n```\n\n공식 설명에 따르면 익스텐션 타입은 네이티브 코드와의 상호 운용성을 위해 유용하며, 간접 비용을 발생시키지 않고 네이티브 타입을 직접 사용할 수 있으면서도 깔끔한 Dart API를 제공합니다.\n\n# 제네릭\n\n익스텐션 타입과 제네릭을 함께 사용하기:\n\n\n<div class=\"content-ad\"></div>\n\n```dart\nextension type MyList<T>(List<T> elements) {\n void add(T value) => elements.add(value);\n}\n\nvoid main(List<String> arguments) {\n  MyList list = MyList<int>([1, 2]);\n  list.add(3);\n\n  final normalList = list as List<int>;\n  print(list); // [1, 2, 3]\n  print(normalList); // [1, 2, 3]\n}\n```\n\n# 생성자\n\nExtension 타입은 여러 개의 생성자를 가질 수 있습니다:\n\n- 일반 생성자\n- 명명된 생성자\n- private 생성자 문법을 사용한 숨겨진 생성자\n\n\n<div class=\"content-ad\"></div>\n\n```dart\nextension type Password._(String value) {\n  Password(this.value) {\n    assert(value.length >= 8);\n    \n    if (value.length < 8) {\n      throw Exception('Password must be at least 8 characters long');\n    }\n  }\n\n  Password.random() : value = _generateRandomPassword();\n\n  static String _generateRandomPassword() => ...;\n\n  bool get isValid => value.length >= 8;\n}\n\nvoid main(List<String> arguments) {\n  // 암시적 명명되지 않은 생성자.\n  Password password = Password('abcdefghijklmnopqrstuvwxyz'); // ✅\n\n  // 명명된 생성자.\n  password = Password.random(); // ✅\n  password = Password('hello12'); // Exception: Password must be at least 8 characters long\n  password = 'hello' as Password; // ✅\n}\n```\n\n기억하세요, 암시적 주 생성자에서는 assert() 체크나 다른 작업을 사용할 수 없습니다. 기본 생성자를 재정의하고 assert 체크를 추가하세요. 기본 생성자를 내부적으로(private) 만드세요.\n```dart\nextension type Password._(String value) {\n\n  Password(this.value) {\n    assert(value.length >= 8);\n    \n    if (value.length < 8) {\n      throw Exception('Password must be at least 8 characters long');\n    }\n  }\n  \n}\n```\n\n# 안전한 Alias\n\n\n<div class=\"content-ad\"></div>\n\nimplements를 사용하면 Extension Types가 기본 유형을 노출하여 Representation 타입의 모든 멤버 및 사용자 지정 도우미 API에 액세스할 수 있습니다. 이는 원래 유형의 기능을 제공하면서도 별칭 및 타입 안전성 확인을 제공합니다.\n\n```js\nextension type Height(double _) implements double {}\nextension type Weight(double _) implements double {}\n\ndouble calculateBmi(Height height, Weight weight) => weight / ( height * height);\n\nvoid main() {\n  var height = Height(1.75);\n  var weight = Weight(65);\n  var bmi = calculateBmi(height, weight);\n  print(bmi); // 21.22448979591837\n  \n  bmi = calculateBmi(1.64, 54.0);     // ❌ 컴파일 타임 오류\n  bmi = calculateBmi(weight, height); // ❌ 컴파일 타임 오류\n}\n```\n\n기존 타입에 새로운 인터페이스 추가하기:\n\n```js\nextension type MyId(int id) implements int {\n  MyId get value => this;\n}\n\nvoid main(List<String> arguments) {\n  final safeId = MyId(100);\n  safeId + 1; // 101\n  safeId - 1; // 99\n  safeId * 2; // 200\n  safeId / 2; // 50\n  safeId % 3; // 1\n  safeId.toString(); // '100'\n\n  int normalId = safeId; // 100\n  final safeId2 = safeId + normalId; // 200\n  final safeId3 = 10 + safeId; // 110\n}\n```\n\n<div class=\"content-ad\"></div>\n\n기존의 기능적 동작을 재정의하고 확장 타입의 멤버들은 완전히 부모 타입의 동일한 이름을 가진 멤버들을 대체하여 새 구현 방법을 제공합니다.\n\n```js\n확장 타입 MyId(int id)은 int를 구현합니다 {\n  bool get isEven => true;\n}\n\nvoid main(List<String> arguments) {\n  final myId = MyId(101);\n  print(myId.isEven); // true\n}\n```\n\n# 다른 시나리오\n\n## 다중 타입 확장\n\n<div class=\"content-ad\"></div>\n\n보통, 확장 유형은 하나의 유형을 확장합니다. 여러 정보가 있는 경우 Record를 사용할 수 있습니다.\n\n```js\ntypedef UserInfo = ({String email, String password});\n\nextension type User(UserInfo info) {\n  void printInfo() => print(\"Email: ${info.email}, Password: ${info.password}\");\n}\n\nvoid main(List<String> arguments) {\n  final user = User(\n    (\n      email: 'extension@gmail.com',\n      password: 'types',\n    ),\n  );\n  user.printInfo(); // Email: extension@gmail.com, Password: types\n}\n```\n\n## 테스트용 모의 데이터\n\n테스트에서 Extension Types를 사용하는 것도 가능합니다. Mock 클래스에 따르면 코드를 약간 조정하기만 하면 됩니다. 일반 클래스와의 차이점은 인터페이스를 구현하지 않은 경우 일반 클래스는 컴파일 경고를 표시하지만, Extension Types는 표시하지 않는다.\n\n<div class=\"content-ad\"></div>\n\n\n## JSON 접근\n\nJSON 데이터에 대한 Extension Types 활용.\n\n```js\nfinal userMap = json.decode(r'''\n  {\n    \"name\": {\n      \"first\": \"Yii\",\n      \"last\": \"Chen\"\n    },\n    \"email\": \"ab20803@gmail.com\"\n  }\n'''); // Map<String, dynamic>\n\nextension type User(Map<String, dynamic> _) {\n  Name get name => _['name'] as Name;\n  String get email => _['email'] as String;\n}\nextension type Name(Map<String, dynamic> _) {\n  String get first => _['first'] as String;\n  String get last => _['last'] as String;\n}\nvoid main() {\n  final person = User(userMap);\n  print(person.name.first);   // Yii\n  print(person.name.last);    // Chen\n  print(person.email);        // ab20803@gmail.com\n  print(person.email.length); // 17\n}\n```\n\n\n<div class=\"content-ad\"></div>\n\n# 상호 운용성\n\n현재 Extension Types은 주로 dart: js_interop 패키지에서 사용되며, 익숙한 구문을 사용하여 JavaScript API에 액세스하고 상호 작용할 수 있도록 합니다. 이 패키지는 JSObject 및 JSAny와 같은 많은 JS 관련 유형을 정의하여 Dart와 네이티브 플랫폼 간의 안전한 통신을 보장합니다. C++와 같은 다른 언어도 이 접근 방식에서 혜택을 볼 수 있습니다.\n\n![image](/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_2.png)\n\nexternal → 이 키워드는 일반적으로 다른 언어에서 사용하는 외부 함수에 액세스할 수 있도록 합니다. 따라서 Dart 상호 운용성 개발에서 자주 볼 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n@JS() → 만약 Dart 측에서 다른 이름을 구현하거나 동일한 JavaScript API를 가리키는 여러 Dart API를 작성하려는 경우, 상호 운용성을 위해 JS API의 이름을 정의할 수 있습니다.\n\n## 패키지 예시\n\nflutter_soloud는 C++을 기반으로 개발된 오디오 엔진 및 패키지로, 낮은 지연 시간, 고성능 플레이어를 제공합니다. 소스 코드에서 재생 기능을 실행하고자 할 때, player.cpp의 play 함수로 시작하여 최종적으로 Dart 측에서는 소리 작업의 ID를 얻기 위해 soloud.play()를 실행합니다.\n\n사용자 정의 SoundHandle은 가독성과 성능을 보장하기 위해 ID를 래핑합니다.\n\n<div class=\"content-ad\"></div>\n\n```dart\nfinal soloud = SoLoud.instance;\nawait soloud.init();\nfinal source = await soloud.loadAsset('path/to/asset.mp3');\n\nSoundHandle soundHandle = await soloud.play(source); // id(int)\n\nawait soloud.stop(soundHandle);\nawait soloud.disposeSource(soundHandle);\n```\n\n전체 API 작업 프로세스를 간단히 살펴보겠습니다:\n\n- player.cpp의 play()를 사용하여 오디오 핸들을 얻습니다.\n\n![Extension Types in Dart](/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_3.png)\n\n\n<div class=\"content-ad\"></div>\n\n2. 양쪽 간의 통신을 처리하기 위해 bindings_player_ffi.dart를 사용하여 얻은 핸들 ID를 SoundHandle으로 래핑합니다.\n\n![image](/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_4.png)\n\n3. Flutter 쪽에서는 soloud.dart를 사용하여 play()를 호출한 후 Record 유형의 결과를 반환합니다. 해당 newHandle을 추출하여 필요한 ID인 ID를 얻을 수 있습니다.\n\n![image](/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_5.png)\n\n<div class=\"content-ad\"></div>\n\n4. Dart 쪽에서는 음향 컨트롤 작업을 위해 의미 있는 확장 유형인 SoundHandle을 사용하여 id가 랩핑됩니다.\n\n![이미지](/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_6.png)\n\n# 고급 사용법\n\n팩토리 생성자: 다른 유형의 확장이 Representation 유형에 적용될 수 있습니다. 이를 통해 연산을 여러 확장 유형에 재사용할 수 있습니다 (다중 상속과 유사).\n\n<div class=\"content-ad\"></div>\n\n```js\nextension type Number(int i) {\n  const factory Number.zero() = Number2;\n}\n\nextension type Number2(int i) implements Number { \n  const Number2(int value) : this(i: value);\n}\n```\n\n# 기억해주세요\n\n확장 유형(Extension Type)은 컴파일 시간에 래핑 동작입니다. 런타임에는 존재하지 않습니다. 런타임에서는 어떤 유형의 쿼리나 작업이라도 표현 유형(Representation Type)에 적용됩니다. 이로 인해 확장 유형은 안전하지 않은 추상화이며 원래 표현 유형을 항상 찾을 수 있고 런타임에서 기본 객체에 액세스할 수 있습니다.\n\n```js\nextension type Id(int value) {}\n\nvoid idToInt() {\n  var id = Id(1);\n\n  // 'id'의 런타임 유형은 표현 유형 'int'.\n  if (id is int) print(id.value); // 1\n\n  // 런타임에서 'id'에 'int' 메서드 사용 가능.\n  if (id case int x) print(x.toString()); // 1\n  switch (id) {\n    case int(:final isEven):\n      print(\"$id (${isEven ? \"짝수\" : \"홀수\"})\"); // 1 (홀수)\n  }\n}\n\nvoid intToId() {\n  int i = 2;\n\n  if (i is Id) print(\"예\"); // 예\n\n  if (i case Id id) print(\"값: ${id.value}\"); // 값: 2\n\n  switch (i) {\n    case Id(:var value):\n      print(\"값: $value\"); // 값: 2\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n# 요약\n\n- **확장 유형**은 기존 유형을 제한할 수도 있고, 새로운 기능을 제공할 수도 있습니다.\n- **확장 유형**의 본질을 이해하는 것이 중요합니다. 이들은 컴파일 시에만 존재하며 런타임에서는 무시되며 **표현 유형**으로 표시됩니다.\n- **확장 유형**은 특정 상황에서 비용을 절약하고, 특히 상호 운용성 개발에서 성능을 크게 향상시킬 수 있습니다.\n\n# 확장 유형 비교\n\n- **확장 메서드**: 기존 유형에 간단한 기능을 추가하는 데 적합합니다.\n- **확장 유형**: 기존 유형을 향상시키고, 복잡한 기능을 구현하며, 다른 프로그래밍 언어와의 상호 운용성을 최적화하는 데 적합합니다.\n\n<div class=\"content-ad\"></div>\n\n# 참고\n\n- [Dart 언어 확장 유형](https://dart.dev/language/extension-types)\n- [Dart 상호 운용성 및 JS 상호 운용 사용법](https://dart.dev/interop/js-interop/usage)\n- [Dart 3.3 소개](https://medium.com/dartlang/dart-3-3-325bf2bf6c13)\n- [Dart와 Flutter 확장 유형에 대한 소개](https://ildysilva.medium.com/what-are-flutter-and-dart-extension-types-896eda0a3ddf)\n- [Dart 언어에 대한 유용한 기능과 팁](https://qiita.com/Cat_sushi/items/987e7eee469793369ef8)\n- [Flutter와 Dart의 개요](https://qiita.com/Cat_sushi/items/87742dc3a886dd984f46)\n- [imaNNeO 유튜브 채널](https://www.youtube.com/watch?v=YHsi1Gfz5UU&ab_channel=imaNNeO)\n- [FlutterUruguay 유튜브 채널](https://www.youtube.com/watch?v=SyFNB81p-OY&t=3276s&ab_channel=FlutterUruguay)\n- [Prof.DiegoAntunes 유튜브 채널](https://www.youtube.com/watch?v=2TJIOpBDMnU&ab_channel=Prof.DiegoAntunes)\n\n# 다른 글들\n\n- 2024년 4월 'Flutter Monthly' 😍\n- 2024년 3월 'Flutter Monthly' 😍\n- 2024년 2월 'Flutter Monthly' 😍\n- Flutter 3.19 및 Dart 3.3 업데이트 포인트!\n- 2024년 1월 'Flutter Monthly' 😍\n- 개발 기술 향상을 위한 Dart 3 사용하기. 더 많은 예제와 팁.\n- 2023년 12월 'Flutter Monthly' 😍\n- 2023년 11월 'Flutter Monthly' 😍\n- Dart 3를 숙지해서 삶을 쉽게 만들기!\n- Flutter 3.16 및 Dart 3.2 요약!\n- 2023년 10월 'Flutter Monthly' 😍\n- 2023년 9월 'Flutter Monthly' 😍\n- 2023년 8월 'Flutter Monthly' 😍\n- 2023년 7월 'Flutter Monthly' 😍","ogImage":{"url":"/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_0.png"},"coverImage":"/assets/img/2024-06-22-WhatcanIdowithExtensionTypesinDart_0.png","tag":["Tech"],"readingTime":12},{"title":"웹 어키텍처 혁신 WebAssembly, Angular v9의 비밀과 NgRx 활용 방법 24화","description":"","date":"2024-06-22 00:23","slug":"2024-06-22-Episode2424VerticalArchitecturesWebAssemblyAngularv9sSecretNgRx","content":"\n\n![Episode2424VerticalArchitecturesWebAssemblyAngularv9sSecretNgRx_0](/assets/img/2024-06-22-Episode2424VerticalArchitecturesWebAssemblyAngularv9sSecretNgRx_0.png)\n\n브랜든 로버츠는 왜 Angular 9가 가장 높은 다운로드율을 보이는지를 공개했습니다. 만프레드 스테이어는 수직 구조에 대해 이야기했습니다. Evgeniy Tuboltsev는 Angular에서 WebAssembly를 통합하는 방법에 대한 안내서를 게시했으며, NgRx 18가 릴리스되었습니다.\n\n# 수직 구조\n\nAngular 커뮤니티 미팅에서 만프레드 스테이어가 Angular에서 DDD에 대한 강화 버전을 소개했습니다.\n\n<div class=\"content-ad\"></div>\n\n그는 다른 작업을 담당하는 네 가지 유형의 팀이 존재하는 팀 토폴로지 모델에 대해 언급했습니다:\n\n1. 플랫폼 서비스 팀\n2. 전문화 팀\n3. 지원 팀\n4. 가치 흐름 팀\n\n## NgRx 18\n\nNgRx는 Angular에서 가장 인기 있는 상태 관리 라이브러리로, v18에서 발표되어 Angular 18과 호환되게 되었습니다.\n\n<div class=\"content-ad\"></div>\n\n신호 스토어를 사용하려면 주의하세요. 나중에 **안정화**되고 아직 릴리스되지 않았습니다.\n\nAngular 18에서 사용하려면 `npm i @ngrx/signals@next`를 실행하거나 스키매틱(또한 `next` 태그 사용)을 사용하세요.\n\n# Angular 9 뒤의 비밀\n\n현재 Angular은 주간 약 350만 번 다운로드되어 React와 Vue에 이어 세 번째로 가장 많이 다운로드되는 프레임워크입니다.\n\n<div class=\"content-ad\"></div>\n\n앵귤러 9가 45만 회 다운로드되었다고 합니다. 현재 버전이 18인데, 그것은 조금 이상하네요.\n\n브랜든 로버츠가 발견했는데, 앵귤러 9는 코들라이저의 의존성입니다. 코들라이저는 타입스크립트 ESLint가 나오기 전에 우리가 사용한 라이브러리입니다.\n\n코들라이저는 많은 애플리케이션에 포함되어 있을 가능성이 매우 높지만, 활성적으로 사용되지는 않고 있으므로 개발자들은 제거해야 할 것입니다.\n\n통계에 따르면, 코들라이저의 현재 다운로드 수는 60만 회입니다.\n\n<div class=\"content-ad\"></div>\n\n코드라이저가 없다면 Angular의 다운로드 수는 17% 떨어질 것입니다.\n\n# 웹어셈블리 & 앵귤러\n\n웹어셈블리는 자바스크립트보다 다른 언어로 작성된 응용 프로그램을 브라우저에서 실행할 수 있게 해줍니다. 게다가 실행 속도는 거의 네이티브 코드와 비슷합니다.\n\nEvgeniy Tuboltsev가 러스트로 작성된 응용 프로그램을 웹어셈블리로 이식하고 Angular에서 사용하는 방법을 보여준 기사를 썼습니다. 비교해보면, 그의 예시는 자바스크립트와 비교했을 때 세 배 빠르게 실행됩니다.","ogImage":{"url":"/assets/img/2024-06-22-Episode2424VerticalArchitecturesWebAssemblyAngularv9sSecretNgRx_0.png"},"coverImage":"/assets/img/2024-06-22-Episode2424VerticalArchitecturesWebAssemblyAngularv9sSecretNgRx_0.png","tag":["Tech"],"readingTime":2},{"title":"웹 개발자의 새로운 베스트 프렌드 AI , 머신러닝 활용 방법","description":"","date":"2024-06-22 00:18","slug":"2024-06-22-TheWebDevelopersNewBestFriendAIMachineLearning","content":"\n\n# AI 및 기계 학습을 통한 웹 애플리케이션의 변혁적 역할\n\n## 소개\n\n기술 발전의 끊임없이 변화하는 풍경 속에서 인공 지능(AI)과 기계 학습(ML)이 변혁적인 역할로 부상하여 산업을 재구성하고 디지털 세계와 상호 작용하는 방식을 재정의하고 있습니다. 몇 년 동안 다양한 경험을 가진 숙련된 웹 기술 전문가로서, 나는 이러한 기술이 웹 개발에 미친 깊은 영향을 직접 목도했습니다. 지능형 웹 애플리케이션부터 간소화된 개발 프로세스 및 향상된 사용자 경험까지, AI와 ML은 웹을 구축하고 상호 작용하는 방식을 혁신하고 있습니다. 본 블로그 포스트에서는 이러한 최첨단 기술이 웹 개발 풍경에 미치는 다각적인 영향을 탐험하는 여정을 떠날 것입니다.\n\n## 지능형 웹 애플리케이션의 시대:\n\n<div class=\"content-ad\"></div>\n\n정적인 일반적인 웹사이트의 날들이 멀어지고 있습니다. AI와 ML의 통합으로 웹 어플리케이션이 지능적이고 적응 가능하며 매우 개인화된 경험으로 발전해 왔습니다. 이 변화의 대표적인 사례인 인기 있는 비디오 스트리밍 플랫폼은 ML 알고리즘을 활용하여 각 사용자의 독특한 시청 기록을 기반으로 영화와 TV 프로그램을 맞춤형으로 추천합니다. 사용자 기호, 평가 및 참여 패턴을 포함한 방대한 양의 데이터를 분석함으로써, 이러한 플랫폼은 사용자가 만족하고 계속해서 이용하는 맞춤형 경험을 제공합니다.\n\n마찬가지로 전자 상거래 거물들은 AI와 ML의 파워를 이용하여 온라인 쇼핑을 혁신하고 있습니다. 지능형 제품 추천부터 동적 가격 책정 및 사기 탐지까지, 이러한 기술은 기업이 제공물을 최적화하고 고객 만족도를 향상시키며 수익 성장을 도모할 수 있게 했습니다. 한 연구 결과에 따르면, AI와 ML 기술을 도입한 소매업체들은 수익이 높아지고 비용이 줄어 2-3%의 수익 증가와 1-2%의 비용 절감을 경험했다고 나타났습니다.\n\n## 웹 개발 워크플로우 최적화하기:\n\n웹 개발의 사용자에게 보여지는 측면을 변형하는 것을 넘어서, AI와 ML은 개발 프로세스 자체를 혁신하고 있습니다. 한 가지 중요한 영향은 반복적이고 시간이 많이 소요되는 작업의 자동화입니다. 마이크로소프트에서 개발된 Sketch2Code와 같은 도구는 AI를 활용하여 손그림 와이어프레임을 기능적인 HTML 코드로 변환하여 개발자들이 매뉴얼 코딩에 소요되는 시간을 아낄 수 있습니다. 이 도구는 더 이상 유지되지는 않지만, 자동화 뿐만 아니라 개발 프로세스를 가속화시키며 개발자들이 보다 복잡하고 창의적인 작업에 집중할 수 있도록 도와주었습니다. 알찬 프로젝트였던 Sketch2Code는 마이크로소프트로부터 공식 웹사이트가 더 이상 제공되지 않으며, 이에 대한 최신 업데이트도 없습니다. 해당 프로젝트에 대한 개발 또는 미래 계획에 대한 마이크로소프트의 최신 소식도 없는 것으로 나타납니다.\n\n<div class=\"content-ad\"></div>\n\n하지만 Sketch2Code는 더 이상 활발히 유지되고 있지 않지만, 그가 개척한 개념은 AI를 활용한 웹 개발 분야에서 혁신을 이끌어내고 있습니다.\n\n뿐만 아니라, AI 기반의 코드 완성 및 지능적인 코드 제안은 웹 개발자에게 없어서는 안 될 필수 도구가 되었습니다. GitHub Copilot과 같은 플랫폼은 OpenAI의 GPT-3/4/4o 언어 모델을 기반으로 개발자에게 문맥을 고려한 코드 제안과 자동 코드 완성 기능을 제공하여 개발 프로세스를 가속화시키고 더욱 효율적인 코드를 작성하며 최상의 사례 채용을 촉진합니다. 개발자 커뮤니티의 집단적인 지식을 활용함으로써, 이러한 AI 기반 도구들은 코딩 전문성을 민주화시키고 모든 레벨의 개발자들에게 힘을 실어줍니다.\n\n<div class=\"content-ad\"></div>\n\n## 사용자 상호작용 및 접근성 향상:\n\nAI 및 ML은 웹 사이트의 사용자 상호작용 및 접근성을 향상시키는 데 중요한 역할을 하고 있습니다. NLP(자연어 처리) 및 ML 알고리즘을 기반으로 한 챗봇은 웹 사이트에서 보다 보편적으로 사용되며 즉각적인 고객 지원과 안내를 제공합니다. 이러한 지능형 어시스턴트는 제품 정보부터 문제 해결까지 다양한 질문을 다룰 수 있으며 인적 자원을 확보하고 고객 만족도를 향상시킵니다. 인기 연구에 따르면, 2024년 말까지 챗봇이 고객 상호작용의 70%를 처리할 것으로 예측되어 웹 개발 생태계에서 그 중요성이 증가하고 있습니다.\n\n또한, AI 및 ML은 장애를 가진 사용자들이 웹 사이트에 더 잘 접근할 수 있도록 돕는 데 활용되고 있습니다. 이미지 인식 알고리즘은 이미지에 대한 대체 텍스트를 자동으로 생성하여 스크린 리더에 의존하는 시각 장애인 사용자들이 접근할 수 있게 합니다. 게다가, AI 기반 도구는 웹 사이트 디자인을 분석하고 접근성을 향상시키기 위한 권고 사항을 제공함으로써 웹 사이트가 포괄적이고 접근성 표준을 준수하도록 보장합니다. 접근성을 우선시함으로써 웹 개발자들은 보다 넓은 관객들에게 맞춘 디지털 경험을 창출하고 디지털 포용성을 촉진할 수 있습니다.\n\n## 실시간 개인화와 최적화:\n\n<div class=\"content-ad\"></div>\n\nAI 및 기계 학습의 가장 흥미로운 응용 중 하나는 웹 개발에서의 실시간 개인화와 최적화입니다. 사용자의 행동, 선호도 및 상호 작용을 분석하여 웹 사이트는 콘텐츠, 레이아웃 및 기능을 동적으로 조정하여 각 사용자에게 맞춤 경험을 제공할 수 있습니다. 이러한 개인화 수준은 사용자 참여를 높일 뿐만 아니라 전환율과 고객 충성도를 향상시킵니다.\n\n예를 들어, ML 알고리즘을 사용하여 제작된 뉴스 웹 사이트는 사용자의 읽기 습관을 분석하고 관심사에 기반해 기사를 추천하여 사용자를 계속해서 참여시키고 정보를 제공할 수 있습니다. 마찬가지로, e-러닝 플랫폼은 학생의 성적 및 학습 스타일에 따라 콘텐츠와 난이도를 적응하여 개인화되고 효과적인 학습 경험을 보장할 수 있습니다. 연구 결과, 개인화된 경험은 매출을 20% 증가시킨다고 밝혀져 있으며, 이는 비즈니스 결과에 미치는 개인화의 중요성을 강조합니다.\n\n## 현대 웹 개발 도구와 기술:\n\nAI 및 기계 학습의 도입은 현대 웹 개발 도구와 기술의 등장으로 크게 촉진되었습니다. 이러한 도구와 프레임워크는 개발자에게 AI 및 기계 학습 기능을 자연스럽게 웹 애플리케이션에 통합할 수 있는 필요한 인프라 및 자원을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n## TensorFlow.js:\n\nTensorFlow.js는 Google에서 개발한 오픈 소스 라이브러리로, 개발자들이 브라우저에서 ML 모델을 직접 빌드하고 배포할 수 있게 해줍니다. TensorFlow.js를 사용하면 웹 개발자들은 서버 측 처리에 의존하지 않고 이미지 분류, 감정 분석, 예측 모델링과 같은 작업을 수행할 수 있는 지능형 웹 애플리케이션을 만들 수 있습니다. 이를 통해 개발자들은 더 많은 상호작용과 반응형 사용자 경험을 만들어낼 수 있습니다.\n\n## 서버리스 컴퓨팅 플랫폼:\n\n웹 개발 분야에서 또 다른 혁신적인 기술은 AWS Lambda, Google Cloud Functions, Azure Functions과 같은 서버리스 컴퓨팅 플랫폼의 등장입니다. 이러한 플랫폼을 통해 개발자들은 인공 지능과 기계 학습 모델을 확장 가능하고 비용 효율적으로 실행할 수 있으며, 인프라 관리를 할 필요가 없습니다. 서버리스 컴퓨팅을 활용함으로써, 웹 개발자들은 지능적인 기능과 기능을 구축하는 데 집중할 수 있고, 클라우드 제공업체가 기반 인프라를 관리해줍니다.\n\n<div class=\"content-ad\"></div>\n\n미리 훈련된 AI 모델 및 API:\n\n또한, 미리 훈련된 AI 모델과 API의 이용가능성은 웹 개발자들이 애플리케이션에 AI 기능을 통합하는 것을 더욱 쉽게 만들어주었습니다. Google Cloud Vision API, Amazon Rekognition, Microsoft Cognitive Services와 같은 서비스는 이미지 인식, 자연어 처리, 감정 분석과 같은 작업에 대한 준비된 AI 모델을 제공하여 개발자들이 이를 활용할 수 있습니다. 이러한 API를 활용함으로써, 웹 개발자들은 AI 전문 지식의 필요없이 빠르게 애플리케이션에 지능적인 기능들을 추가할 수 있습니다.\n\n인기 있는 클라우드 제공 업체의 AI 및 ML 서비스:\n\nAmazon Web Services (AWS):\n\n<div class=\"content-ad\"></div>\n\n- Amazon SageMaker: 모든 개발자와 데이터 과학자에게 ML 모델을 빠르게 구축, 훈련 및 배포할 수 있는 완전히 관리되는 서비스입니다.\n- Amazon Rekognition: 응용 프로그램에 이미지 및 비디오 분석 기능을 쉽게 추가할 수 있는 서비스입니다.\n- Amazon Polly: 텍스트를 생동감있는 음성으로 변환하여 음성 대화형 제품을 완전히 새롭게 구축할 수 있는 서비스입니다.\n\nGoogle Cloud Platform (GCP):\n\n- Google Cloud AI Platform: ML 모델을 구축, 배포 및 관리할 수 있는 통합 플랫폼입니다.\n- Google Cloud Vision API: 강력한 이미지 분석 기능을 제공합니다.\n- Google Dialogflow: 챗봇과 같은 대화형 인터페이스를 구축하는 스위트입니다.\n\nMicrosoft Azure:\n\n<div class=\"content-ad\"></div>\n\n- Azure Machine Learning: ML 모델을 구축하고 배포하는 포괄적인 서비스입니다.\n- Azure Cognitive Services: 시각, 음성, 언어 및 의사 결정을 위한 API 및 서비스의 모음입니다.\n- Azure Bot Service: 지능적이고 기업용 봇을 만들 수 있게 해줍니다.\n\n웹 개발의 미래:\n\nAI와 ML이 전례없는 속도로 발전함에 따라 웹 개발의 미래는 매우 밝아 보입니다. IoT(Internet of Things), 증강 현실(AR), 가상 현실(VR)과 같은 다른 신흥 트렌드와 이러한 기술들의 통합은 몰입형이자 지능적인 웹 경험을 위한 새로운 가능성을 열어줄 것입니다.\n\n사용자의 물리적 환경에 맞게 웹사이트가 신속하게 적응하고, IoT 장치를 활용해 맥락에 맞는 경험을 제공하는 상상해 보세요. 제품을 구매하기 전 실제 환경에서 제품을 시각화할 수 있는 AR을 지원하는 웹사이트를 상상해 보세요. AI, ML 및 이러한 신흥 기술들의 융합은 웹 개발에서 가능한 범위의 경계를 재정의할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n또한, AI 및 ML 도구의 민주화는 보다 넓은 범위의 개발자들이 지능적인 웹 애플리케이션을 만들 수 있게됩니다. 로우코드 및 노코드 플랫폼과 사전 학습된 AI 모델을 결합하면 모든 기술 수준의 개발자가 데이터 과학이나 머신러닝에 대한 심도 있는 전문 지식이 필요하지 않고도 이러한 기술의 힘을 활용할 수 있게 될 것입니다.\n\n결론:\n\nAI 및 머신러닝이 웹 개발에 미치는 영향은 깊고 광범위하며 혁신적입니다. 지능적인 웹 애플리케이션부터 개발 워크플로의 최적화, 향상된 사용자 상호작용 및 실시간 개인화까지, 이러한 기술들은 우리가 웹사이트를 구축하고 상호작용하는 방식을 형태로 재구성하고 있습니다. 웹 개발자로서 우리는 이러한 발전을 수용하고 지속적으로 기술을 적응시키며 그 잠재력을 활용하여 더 매력적이고 효율적이며 사용자 중심의 웹 경험을 창출해야 합니다.\n\n그러나 여정은 아직 끝나지 않았습니다. AI 및 ML 분야는 지속적으로 진화하고 새로운 발전이 급격히 등장하고 있습니다. 웹 개발자로서 우리는 호기심을 갖고 새로운 가능성을 탐험하고 웹 개발의 미래를 형성하는 데 적극적으로 기여해야 합니다. 이렇게 함으로써 우리는 트렌드에 앞설뿐만 아니라 혁신을 주도하고 가능한 범위의 한계를 넓힐 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n그래서, AI와 머신 러닝의 영향을 받아 다가가 봅시다. 창의성과 열정이 우리를 이끄는 새로운 지능적이고 맞춤형이며 접근성 있는 웹 경험을 만들면서 우리의 웹 개발 미래를 설계해봅시다. 웹 개발의 미래는 흥미 진진한 기회로 가득차 있으며 함께하면 전 세계 사용자들에게 직관적이고 매력적이며 더 나은 디지털 환경을 형성할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-22-TheWebDevelopersNewBestFriendAIMachineLearning_0.png"},"coverImage":"/assets/img/2024-06-22-TheWebDevelopersNewBestFriendAIMachineLearning_0.png","tag":["Tech"],"readingTime":7}],"page":"3","totalPageCount":24,"totalPageGroupCount":2,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}