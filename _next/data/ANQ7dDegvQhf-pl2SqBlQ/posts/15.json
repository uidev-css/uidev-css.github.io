{"pageProps":{"posts":[{"title":"Dart 매크로의 힘을 풀어내기 종합 가이드","description":"","date":"2024-06-21 20:04","slug":"2024-06-21-UnlockingthePowerofDartMacrosAComprehensiveGuide","content":"\n\n다트 프로그래밍 언어가 계속 발전함에 따라 도입된 가장 흥미로운 기능 중 하나는 다트 매크로입니다. 다트 매크로는 코드 생성 및 메타프로그래밍을 수행하는 강력한 방법을 제공하여 코드를 더 효율적으로 만들고 보일러플레이트를 줄일 수 있습니다. 이 기사에서는 다트 매크로가 무엇인지, 그 사용 방법은 물론 개발 작업 흐름에 가져다주는 이점을 살펴보겠습니다.\n\n## 다트 매크로란 무엇인가요?\n\n다트의 매크로는 컴파일 시간에 다른 코드를 생성하는 코드를 작성할 수 있게 해줍니다. 이는 반복적이거나 보일러플레이트가 많거나 주석이나 다른 컴파일 시간 정보에 기반한 동적 코드 생성이 필요한 작업에 특히 유용합니다.\n\n## 매크로 사용의 이점\n\n<div class=\"content-ad\"></div>\n\n- 반복적인 코딩 패턴을 자동화하여 복잡성을 줄입니다.\n- 성능 향상: 런타임이 아닌 컴파일 시간에 계산 및 최적화 작업을 수행합니다.\n- 가독성 향상: 복잡한 패턴을 추상화하여 코드베이스를 깔끔하고 간결하게 유지합니다.\n- 사용자 정의 어노테이션: 코드 생성을 트리거할 수 있는 사용자 정의 어노테이션을 만듭니다.\n\n## Dart 매크로로 시작하기\n\nDart에서 매크로를 사용하려면 매크로를 작성하고 적용하는 기본 사항을 이해해야 합니다. 간단한 예제부터 시작해보죠.\n\n예시: 데이터 클래스 생성하기\n\n<div class=\"content-ad\"></div>\n\n위의 코드를 살펴보시면 데이터 클래스를 자동으로 getter 및 setter와 함께 생성하려고 한다고 가정해 봅시다. Dart Macros를 사용하여 이 작업을 수행하는 방법은 다음과 같습니다.\n\n- Macro 주석 정의: 먼저, 매크로를 트리거할 주석을 생성하세요.\n\n```js\nclass DataClass {\n  const DataClass();\n}\n```\n\n- Macro 구현 생성: 주석을 기반으로 코드를 생성하는 로직을 구현하세요.\n\n<div class=\"content-ad\"></div>\n\n```dart\nimport 'dart:mirrors';\n\nclass DataClassMacro {\n  const DataClassMacro();\n  void generateCode(ClassMirror classMirror) {\n    // 클래스 멤버를 반복하고 게터와 세터를 생성합니다.\n    for (var variable in classMirror.declarations.values.whereType<VariableMirror>()) {\n      var name = MirrorSystem.getName(variable.simpleName);\n      var type = MirrorSystem.getName(variable.type.simpleName);\n      \n      // 게터 생성\n      print('$name에 대한 게터를 생성했습니다.');\n      \n      // 세터 생성\n      print('$name에 대한 세터를 생성했습니다.');\n    }\n  }\n}\n```\n\n- 매크로 적용: 클래스에 주석을 사용하고 매크로가 필요한 코드를 생성합니다.\n\n```dart\n@DataClass()\nclass User {\n  String name;\n  int age;\n}\n```\n\n매크로가 적용되면 User 클래스의 게터와 세터가 생성됩니다.\n\n\n<div class=\"content-ad\"></div>\n\n## Dart Macros의 고급 사용법\n\nDart Macros는 더 복잡하고 강력할 수 있으며 다음과 같은 다양한 시나리오를 처리할 수 있습니다:\n\n- 코드 유효성 검사: 컴파일 시간에 코드에서 특정 조건이 충족되는지 확인합니다.\n- 메타데이터를 기반으로 코드 생성: 주석 및 기타 컴파일 시간 정보에 기반한 코드를 생성합니다.\n- 사용자 정의 DSL (도메인별 언어) 생성: 코드베이스에서 특정 작업을 간단하게 하는 DSL을 개발합니다.\n\n예: Validation Macro\n\n<div class=\"content-ad\"></div>\n\n더 복잡한 매크로 예제로, 특정 필드가 null이 아닌지 확인하는 매크로를 만들어보겠습니다.\n\n- 유효성 검사 어노테이션 정의:\n\n```js\nclass NotNull {\n  const NotNull();\n}\n```\n\n- 유효성 검사 매크로 작성:\n\n<div class=\"content-ad\"></div>\n\n```dart\nimport 'dart:mirrors';\n\nclass NotNullMacro {\n  const NotNullMacro();\n  void validate(ClassMirror classMirror) {\n    for (var variable in classMirror.declarations.values.whereType<VariableMirror>()) {\n      if (variable.metadata.any((m) => m.reflectee is NotNull)) {\n        var name = MirrorSystem.getName(variable.simpleName);\n        print('Validation: $name should not be null');\n      }\n    }\n  }\n}\n```\n\n- Validation 적용:\n\n```dart\nclass User {\n  @NotNull()\n  String name;\n  int age;\n}\n```\n\nNotNullMacro은 User 클래스의 name 필드가 null이 아닌지 확인합니다.\n\n<div class=\"content-ad\"></div>\n\n## 결론\n\n다트 마크로는 다트에서 코드 생성과 메타프로그래밍 분야에서 새로운 가능성을 열어줍니다. 이들은 반복되는 코드를 줄이고 코드 가독성을 향상시키며 강력한 컴파일 시간 유효성 검사 및 최적화를 가능하게 합니다. 마크로를 활용하여 개발 프로세스를 최적화하고 유지보수가 쉽고 효율적인 코드를 작성할 수 있습니다.\n\n다트 생태계가 계속 성장함에 따라 마크로를 숙달하는 것은 모든 다트 또는 플러터 개발자에게 귀중한 기술이 될 것입니다. 오늘부터 프로젝트에서 다트 마크로를 실험해보고 직접 혜택을 느껴보세요!","ogImage":{"url":"/assets/img/2024-06-21-UnlockingthePowerofDartMacrosAComprehensiveGuide_0.png"},"coverImage":"/assets/img/2024-06-21-UnlockingthePowerofDartMacrosAComprehensiveGuide_0.png","tag":["Tech"],"readingTime":4},{"title":"2024년에 배워야 할 기술 Flutter vs React Native 비교 분석","description":"","date":"2024-06-21 20:02","slug":"2024-06-21-FluttervsReactNativeWhichShouldYouLearnin2024","content":"\n\n![이미지](/assets/img/2024-06-21-FluttervsReactNativeWhichShouldYouLearnin2024_0.png)\n\n모바일 앱 개발의 빠른 세계에서는 적절한 프레임워크를 선택하는 것이 귀하의 경력에 상당한 영향을 미칠 수 있습니다. Flutter와 React Native는 두 가지 주요 크로스 플랫폼 개발 프레임워크로 부상하여, 각각 독특한 이점을 제공하며 다른 요구 사항을 충족시킵니다. 2024년에 우리가 진입함에 따라, 이러한 기술의 강점과 약점을 이해함으로써 어떤 것을 배울지에 관한 판단을 내릴 수 있을 것입니다.\n\n# Flutter 개요\n\n## 주요 기능 및 이점\n\n<div class=\"content-ad\"></div>\n\nGoogle에서 개발한 Flutter는 Dart 프로그래밍 언어를 사용합니다. Flutter는 다양한 맞춤형 위젯, 견고한 생태계, 그리고 코드 변경을 즉시 확인할 수 있는 놀랍게 빠른 hot reload 기능으로 눈에 띕니다. Flutter의 아키텍처는 네이티브 컴포넌트와 통신하기 위한 bridge가 필요하지 않아 우수한 성능을 제공합니다.\n\n![Flutter Image](https://miro.medium.com/v2/resize:fit:1400/1*WuTnKtolmbzhb7qimKo-gQ.gif)\n\nFlutter의 주요 기능은 다음과 같습니다:\n\n- 풍부한 위젯: UI 개발을 간소화하는 포괄적이고 맞춤형 위젯.\n- 핫 리로드: 코드 변경을 즉시 반영하여 개발 속도를 높여줍니다.\n- 네이티브 성능: Skia를 이용한 고성능 그래픽 렌더링.\n- 단일 코드베이스: 한 번 작성하면 iOS, Android, 웹, 그리고 데스크톱에서 실행 가능합니다.\n\n<div class=\"content-ad\"></div>\n\n## 인기도와 사용 사례\n\n플러터의 고성능과 부드러운 사용자 인터페이스로 시각적으로 집중되는 애플리케이션에 대한 인기가 높아졌습니다. 알리바바, BMW, 필립스 휴 등 주요 기업들이 플러터를 활용하여 무결성 있는 앱 경험을 제공하고 있습니다. 그 유연성 때문에 플러터는 효율적으로 고품질의 크로스 플랫폼 애플리케이션을 개발하려는 스타트업 및 대기업들에게 이상적입니다.\n\n# React Native 개요\n\n## 주요 기능과 이점\n\n<div class=\"content-ad\"></div>\n\n페이스북에서 만든 React Native은 JavaScript와 React를 활용합니다. 재사용 가능한 코드 컴포넌트와 핫 리로드 기능으로 속도와 효율성을 높일 수 있어 인기가 많습니다. 다양한 서드 파티 라이브러리 모음과 강력한 커뮤니티 지원이 이를 더욱 다양하게 만듭니다.\n\n![React Native](https://miro.medium.com/v2/resize:fit:1400/1*yrB0cp5aL9fNYpnb-EpfaQ.gif)\n\nReact Native의 주요 기능은 다음과 같습니다:\n\n- 재사용 가능한 컴포넌트: 애플리케이션 간에 컴포넌트를 구축하고 재사용할 수 있습니다.\n- 핫 리로드: UI 변경 사항을 빠르게 테스트하고 반복할 수 있습니다.\n- JavaScript 기반: 기존 JavaScript 지식을 활용할 수 있습니다.\n- 다양한 라이브러리 지원: 다양한 서드 파티 라이브러리와 플러그인에 접근할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 인기도 및 사용 사례\n\nReact Native은 JavaScript에 익숙한 개발자들을 위해 학습이 쉽기 때문에 종종 선호됩니다. Facebook, Instagram 및 Airbnb와 같은 산업거인들이 사용함으로써 다양한 응용 프로그램에서 안정성과 성능을 보여줌으로써 신뢰받습니다. 이는 JavaScript 기술을 활용하려는 개발자들에게 탄탄한 선택지가 됩니다.\n\n### 성능 비교\n\n![React Native vs. Flutter Performance](/assets/img/2024-06-21-FluttervsReactNativeWhichShouldYouLearnin2024_1.png)\n\n<div class=\"content-ad\"></div>\n\n## 속도와 효율성\n\n플러터의 아키텍처에는 Skia 그래픽 엔진이 포함되어 있어 JavaScript 브리지를 필요로하지 않아 높은 성능을 제공합니다. 이로 인해 그래픽 집중 애플리케이션에서 빠르고 부드러운 성능을 제공합니다. 반면에 React Native는 효율적이지만 때로는 JavaScript 브리지에 의존하기 때문에 성능 병목 현상이 발생할 수 있습니다.\n\n## 실제 성능 측정\n\n실제 시나리오에서 두 프레임워크 모두 준수한 성능을 제공합니다. 그러나 플러터는 특히 복잡한 그래픽과 애니메이션을 필요로하는 애플리케이션에서 속도와 부드러움 측면에서 우세할 수 있습니다. React Native는 다양한 애플리케이션에 대해 효과적이지만 더욱 요구하는 사용 사례에서 최적화가 필요할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 개발 경험\n\n## 사용 편의성\n\nReact Native은 일반적으로 JavaScript 또는 React 경험이 있는 개발자들에게는 더 부드러운 학습 곡선을 제공합니다. 반면에 Flutter는 Dart를 배워야 하므로 일부에게는 더 가파른 학습 곡선일 수 있습니다. 그러나 Flutter의 방대한 문서와 Flutter Doctor와 같은 지원 도구들은 더 원활한 설정 및 개발 프로세스를 도와줍니다.\n\n## 학습 곡선\n\n<div class=\"content-ad\"></div>\n\nReact Native의 JavaScript 사용은 더 쉽게 접근할 수 있게 만들지만, Flutter의 포괄적인 문서와 빠르게 성장하는 커뮤니티 지원은 초기 학습 과정의 어려움을 완화해줍니다. 두 프레임워크에 처음 입문하는 개발자들에게는 개인적인 선호도와 해당 프로그래밍 언어에 대한 익숙함에 따라 선택이 결정될 수 있습니다.\n\n## 도구 및 문서\n\nFlutter와 React Native은 모두 강력한 도구 및 자세한 문서를 제공합니다. Flutter의 통합 개발 환경(IDE) 지원과 자세한 안내서는 조금 더 향상된 개발 경험을 제공합니다. React Native의 생태계는 잘 확립되어 있으며, 개발자들을 위한 다양한 자원이 제공됩니다.\n\n# 커뮤니티와 생태계\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-21-FluttervsReactNativeWhichShouldYouLearnin2024_2.png\" />\n\n## 라이브러리 및 플러그인의 이용 가능성\n\nReact Native는 다양한 써드파티 라이브러리와 플러그인으로 구성된 광범위한 생태계를 자랑하여 기능을 확장하기가 더 쉽습니다. Flutter의 라이브러리 컬렉션은 빠르게 성장하며, 개발자가 애플리케이션을 향상시키기 위한 다양한 옵션을 제공합니다.\n\n## 커뮤니티 지원 및 자원\n\n<div class=\"content-ad\"></div>\n\nReact Native는 보다 큰, 더 확립된 커뮤니티를 갖고 있어 개발자에게 풍부한 자원과 지원을 제공합니다. 더 최근에 등장한 Flutter의 커뮤니티는 빠르게 성장하고 있으며, 개발자들을 위한 활발한 참여와 풍부한 자원이 제공됩니다.\n\n# 사용 사례 및 산업 적용\n\n## 각 프레임워크에 적합한 프로젝트 유형\n\nReact Native는 복잡한 통합이 필요한 애플리케이션에 이상적이며 JavaScript 생태계에 깊게 관련되어 있습니다. Flutter는 여러 플랫폼에서 일관된 사용자 경험과 뛰어난 성능을 요구하는 프로젝트에 뛰어납니다. 강력한 위젯 시스템으로 복잡한 UI 및 애니메이션 애플리케이션에 특히 적합합니다.\n\n<div class=\"content-ad\"></div>\n\n## 각 프레임워크를 사용하는 주목할만한 앱 및 회사\n\nReact Native은 Facebook 및 Instagram과 같은 주요 앱을 지원하여 능력과 신뢰성을 강조합니다. Flutter는 Alibaba 및 BMW와 같은 주요 회사에서 사용되고 있어 다양성과 성능을 입증하고 있습니다. 두 프레임워크 모두 주요 브랜드에 의해 신뢰받고 있으며, 다양한 시나리오에서 각각의 장점을 반영하고 있습니다.\n\n# 자주 묻는 질문\n\n![이미지](/assets/img/2024-06-21-FluttervsReactNativeWhichShouldYouLearnin2024_3.png)\n\n<div class=\"content-ad\"></div>\n\n- 플러터(Flutter)는 정확히 무엇이며 무엇을 하는가요?\n- 2024년에 플러터를 배워야 하는 이유는 무엇인가요?\n- 플러터가 크로스 플랫폼 개발을 어떻게 간단하게 만드나요?\n- 플러터는 앱 개발 초보자에게 좋은 프레임워크인가요?\n- 플러터와 함께 사용되는 프로그래밍 언어는 무엇이며 쉽게 배울 수 있나요?\n- 플러터에 숙련된 개발자의 취업 전망은 어떻게 되나요?\n- 모바일 앱뿐만 아니라 웹 및 데스크톱 애플리케이션을 구축하는 데 플러터를 사용할 수 있나요?\n- 플러터 앱의 성능은 네이티브 애플리케이션과 어떻게 비교되나요?\n- 플러터 개발자를 위한 커뮤니티 및 지원 리소스는 어떤 종류가 있나요?\n- Google은 얼마나 자주 플러터를 업데이트하고 어떤 개선 사항을 기대할 수 있나요?\n\n2024년 이후를 위해 시간을 투자할 프레임워크를 결정할 때, 플러터와 리엑트 네이티브의 장단점을 이해함으로써 잘 판단할 수 있습니다.\n\n# 결론\n\n## 장단점 요약\n\n<div class=\"content-ad\"></div>\n\n플러터와 리액트 네이티브는 크로스 플랫폼 개발에 강력한 솔루션을 제공합니다. 리액트 네이티브의 사용 편의성과 강력한 커뮤니티 지원은 특히 JavaScript 개발자들에게 좋은 선택이 될 것입니다. 플러터의 우수한 성능과 풍부한 UI 기능은 시각적으로 멋진 애플리케이션을 개발하고자 하는 개발자들에게 이상적인 선택입니다.\n\n다양한 시나리오를 고려한 최종 권장사항\n\n이미 JavaScript에 익숙한 개발자들에게는 리액트 네이티브가 더 직관적인 선택이 될 수 있습니다. 생태계를 활용하고 뛰어난 성능을 얻고자 하는 분들에게는 플러터가 매력적인 옵션일 것입니다. 최종적으로 가장 적합한 선택은 특정 프로젝트 요구 사항과 기존 기술 세트에 달려 있습니다.","ogImage":{"url":"/assets/img/2024-06-21-FluttervsReactNativeWhichShouldYouLearnin2024_0.png"},"coverImage":"/assets/img/2024-06-21-FluttervsReactNativeWhichShouldYouLearnin2024_0.png","tag":["Tech"],"readingTime":6},{"title":"2024년 필수 Flutter와 Dart 패키지 Top 추천 목록","description":"","date":"2024-06-21 20:00","slug":"2024-06-21-TopFlutterandDartPackagesin2024","content":"\n\n\n![2024-06-21-TopFlutterandDartPackagesin2024_0](/assets/img/2024-06-21-TopFlutterandDartPackagesin2024_0.png)\n\n모바일 앱 개발 커뮤니티는 Google의 Flutter UI 프레임워크를 열정적으로 환영했습니다. 이는 크로스 플랫폼 호환성과 풍부한 오픈 소스 라이브러리 및 플러그인 컬렉션 덕분입니다. Flutter의 놀라운 성능과 사용자 친화성으로 많은 개발자들에게 인기가 빠르게 증가했습니다. 이전에 우리는 \"다음 프로젝트에 Flutter를 고려해야 하는 이유\"와 \"2024년에 어떤 프레임워크가 이기나요: Flutter vs React Native?\"를 탐구했습니다.\n\nFlutter 라이브러리와 도구들이 다양하게 있어서 개발 시간을 줄이는 데 도움이 되며 언어의 효율성을 확대할 수 있습니다. 또한 HTTP 호출과 같은 몇 가지 기능들은 휴대폰 앱 개발자와 비즈니스 오너들에게 품질 시간을 절약할 수 있도록 도와줍니다.\n\n이 기사에서는 2024년 모든 개발자들이 알아야 할 최고의 Flutter & Dart 라이브러리와 패키지를 자세히 살펴볼 것입니다. 이러한 라이브러리와 패키지는 더 덜한 노력으로 멋진 앱을 만들 수 있게 도와주며 개발 프로세스를 더욱 원활하게 만들어줄 것입니다.\n\n![2024-06-21-TopFlutterandDartPackagesin2024_1](/assets/img/2024-06-21-TopFlutterandDartPackagesin2024_1.png)\n\n\n<div class=\"content-ad\"></div>\n\n# 상태 관리 라이브러리\n\n## Provider\n\nProvider는 Flutter 커뮤니티에서 널리 사용되는 상태 관리 솔루션입니다. 앱 상태를 관리하는 과정을 단순화하고 앱 전체에서 데이터에 쉽게 액세스할 수 있도록 지원합니다. 작은 프로젝트와 뛌륭한 문서를 통해 잘 작동합니다. Provider에 대해 더 알아보기.\n\n## Riverpod\n\n<div class=\"content-ad\"></div>\n\nRiverpod은 더 고급화된 상태 관리 솔루션입니다. Provider와 비교하면 더 나은 유연성과 안전성을 제공하여 복잡한 프로젝트에 적합합니다. Riverpod은 더 견고하고 확장 가능한 애플리케이션을 만들고자 하는 사람들에게 인기가 있는 선택지입니다. Riverpod에 대해 더 알아보세요.\n\n## GetX\n\nGetX는 상태 관리, 의존성 주입 및 경로 관리를 하나의 패키지로 시원하고 고성능으로 통합한 라이브러리입니다. 이를 통해 개발자들은 명료한 코드를 작성하고 깔끔한 아키텍처를 유지하면서 프로젝트 관리와 확장을 간단하게 할 수 있습니다. 번창하는 커뮤니티와 포괄적인 문서로 GetX는 플러터 개발자에게 유익한 자원임을 입증하고 있습니다. GetX에 대해 더 자세히 알아보세요.\n\n## Flutter_bloc\n\n<div class=\"content-ad\"></div>\n\n플러터 블록(Flutter_bloc)은 플러터 애플리케이션에서 BLoC(비즈니스 로직 컴포넌트) 패턴을 구현하는 데 인기 있는 패키지입니다. 이 라이브러리는 앱의 UI와 비즈니스 로직을 분리하여 깨끗하고 유지보수가 쉬운 코드를 작성할 수 있도록 도와줍니다. 테스트에 중점을 둔 Flutter_bloc은 커뮤니티가 크고 강력하므로 어떤 플러터 프로젝트에도 훌륭한 선택입니다. Flutter_bloc에 대해 자세히 알아보세요.\n\n# 네트워킹 라이브러리\n\n## Dio\n\nDio는 가장 인기 있는 네트워킹 라이브러리입니다. Dart용 강력한 HTTP 클라이언트로, 네트워크 요청을 쉽게 만들고 응답을 처리할 수 있습니다. 인터셉터, 전역 구성, FormData, 요청 취소 등의 내장 기능이 있어 Dio를 사용하면 앱의 API 호출을 쉽게 관리할 수 있습니다. 네트워크 통신과 작업하는 개발자에게 꼭 필요한 도구입니다. Dio에 대해 더 자세히 알아보세요.\n\n<div class=\"content-ad\"></div>\n\n## 초퍼\n\n초퍼는 플러터 앱에 특히 맞춰진 Dart용 또 다른 HTTP 클라이언트입니다. 코드 생성을 사용하여 API 호출을 더 직관적이고 깔끔하게 만드는 데 중점을 두고 있습니다. 초퍼는 Provider 및 Riverpod 라이브러리와 매끄럽게 통합되어 부드러운 상태 관리를 제공합니다. 초퍼에 대해 더 알아보세요.\n\n# 저장 라이브러리\n\n## Hive\n\n<div class=\"content-ad\"></div>\n\nHive는 플러터 앱을 위한 가벼우며 고성능의 NoSQL 데이터베이스입니다. 순수한 Dart로 작성되어 저사양 장치에서도 우수한 성능을 제공합니다. Hive는 간단한 API와 암호화 지원으로 사용하기 쉽습니다.\n\n웹 애플리케이션을 위한 IndexedDB 저장 시스템을 활용하여, Hive 패키지는 이제 Android, iOS, 데스크톱, 그리고 웹을 포함한 모든 플랫폼에서 일관된 경험을 제공합니다. 개발자들은 이제 플러터 웹 애플리케이션을 위한 동일한 간단하고 효율적이며 고성능의 로컬 저장 솔루션을 즐길 수 있습니다. 계속된 유지보수와 최근에 추가된 플러터 웹 애플리케이션 지원으로, Hive는 2024년에 가장 우수한 플러터와 Dart 패키지 중 하나로 자리잡았습니다. Hive에 대해 더 알아보기.\n\n## Drift\n\nDrift는 Dart 및 Flutter 애플리케이션을 위한 강력하고 유연한 SQLite 라이브러리입니다. 이를 통해 개발자들은 데이터베이스를 타입 안전하고 직관적인 방식으로 다룰 수 있습니다. Drift를 사용하면 Dart의 표현력 있는 언어 기능인 async/await와 스트림을 활용하여 데이터베이스를 생성하고 상호작용할 수 있습니다. Drift의 구문은 이해하기 쉽고 SQL과 밀접하게 연관되어 있어, 신뢰할 수 있고 효율적인 데이터베이스 관리 솔루션을 찾는 개발자들 사이에서 인기가 있습니다. Drift에 대해 더 알아보기.\n\n<div class=\"content-ad\"></div>\n\n# Animation Libraries\n\n## Lottie\n\n로티는 디자이너가 정적 에셋을 배포하는 것만큼 쉽게 어떤 플랫폼에서도 애니메이션을 배포할 수 있는 JSON 기반의 애니메이션 파일 형식입니다. 이 파일들은 어떤 기기에서도 작동하며 확대 또는 축소할 때 픽셀화되지 않습니다. 더 자세한 정보를 확인하세요.\n\n![로티 이미지](/assets/img/2024-06-21-TopFlutterandDartPackagesin2024_2.png)\n\n<div class=\"content-ad\"></div>\n\n## Rive\n\nRive, 이전에 Flare로 인식되었던 것은 플러터와 완벽하게 작동하는 인상적인 디자인 및 애니메이션 솔루션입니다. 이 도구를 사용하면 추가 플러그인이 필요하지 않은 상태에서 벡터 애니메이션과 인터랙티브 앱 기능을 만들 수 있습니다. 실시간 편집 기능 덕분에 Rive는 개발자가 응용 프로그램 내에서 애니메이션을 생성하고 정렬하는 프로세스를 간단하게 만듭니다. Rive에 대해 더 알아보세요.\n\n![image](/assets/img/2024-06-21-TopFlutterandDartPackagesin2024_3.png)\n\n# 의존성 주입\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-21-TopFlutterandDartPackagesin2024_4.png)\n\n## Get_it\n\nGet_it은 Dart 및 Flutter 앱에서 의존성 주입을 위해 설계된 사용자 친화적인 서비스 로케이터입니다. Get_it은 컨텍스트를 필요로하지 않고 응용 프로그램 전체에서 서비스 및 인스턴스를 간단히 얻는 방법을 제공합니다. 간단한 설정 및 코드 생성과의 독립성으로, Get_it은 의존성 관리에 대한 쉽고 가벼운 접근 방식을 찾는 개발자들 사이에서 선호되는 옵션으로 자리 잡았습니다. 자세한 내용은 Get_it 페이지를 방문해주세요.\n\n## Flutter_bloc\n\n\n<div class=\"content-ad\"></div>\n\n`Flutter_bloc`는 Bloc이라는 상태 관리 라이브러리의 강점을 의존성 주입의 편리함과 결합한 인기 있는 패키지입니다. 개발자들은 `Flutter_bloc`을 사용하여 앱의 종속성을 간편하게 처리하고 최고 수준의 상태 관리 기능을 즐길 수 있습니다. 이 패키지를 통해 내장된 의존성 주입 지원을 갖춘 Bloc 인스턴스를 생성할 수 있어 앱 전반에 걸쳐 효율적으로 종속성을 제공하고 액세스할 수 있습니다. 별도의 의존성 주입 패키지에 의존하지 않고도 가능합니다.\n\n# 총정리\n\nFlutter의 보급 및 인기가 확대되면서 개발자들이 접근할 수 있는 패키지의 다양성도 증가합니다. 이 문서에서 소개된 패키지들은 2024년에 가장 우수한 Flutter 및 Dart 패키지들을 보여주며, 이 도구들을 활용하여 더 효율적이고 유지보수가 쉬우며 시각적으로 매력적인 애플리케이션을 개발할 수 있습니다. 이를 통해 궁극적인 사용자 경험 제공에 집중할 수 있습니다.\n\nFlutter의 빠르게 변화하는 환경을 주시하며, 혁신적이고 매력적인 패키지들이 계속해서 소개되고 있음을 주시해주세요.\n\n<div class=\"content-ad\"></div>\n\n이 게시물을 좋아하신다면, 당신의 지지를 보여주기 위해 다음 3가지를 해볼 수 있어요:\n1 — 이 이야기에 박수(CLAP)를 보내주세요 👏\n2 — 우리의 다가오는 기사를 구독해주세요.\n3 — 저희 앱 개발 서비스에 대해 더 알고 싶으시면, 저희 웹사이트를 방문해주세요: [https://flutter.wtf/](https://flutter.wtf/)","ogImage":{"url":"/assets/img/2024-06-21-TopFlutterandDartPackagesin2024_0.png"},"coverImage":"/assets/img/2024-06-21-TopFlutterandDartPackagesin2024_0.png","tag":["Tech"],"readingTime":5},{"title":"클린 아키텍처로 Flutter 프로젝트 설정하고 조직화하는 방법","description":"","date":"2024-06-21 19:58","slug":"2024-06-21-SettingUpandOrganizingYourFlutterProjectwithCleanArchitecture","content":"\n\n![이미지](/assets/img/2024-06-21-SettingUpandOrganizingYourFlutterProjectwithCleanArchitecture_0.png)\n\n클린 아키텍처는 확장 가능하고 유지 보수 가능하며 테스트 가능한 애플리케이션을 구축하기 위한 견고한 구조를 제공합니다. 이 기사에서는 클린 아키텍처 원칙을 준수하여 플러터 프로젝트를 설정하고 구성하는 초기 단계를 안내해드립니다. 이를 통해 앱이 성장함에 따라 코드베이스가 깔끔하고 모듈식으로 유지되도록 보장합니다.\n\n# 왜 클린 아키텍처를 사용해야 하나요?\n\n로버트 C. 마틴 (엉클 밥)이 인기있게 만든 클린 아키텍처는 애플리케이션 내에서 관심사를 분리하는 것을 강조합니다. 앱을 구별되는 계층으로 나눔으로써 핵심 비즈니스 로직이 프레임워크와 사용자 인터페이스로부터 격리되어 코드가 더 모듈식이고 테스트 가능하며 유지 보수하기 쉬워집니다.\n\n<div class=\"content-ad\"></div>\n\n## Clean Architecture의 주요 원칙\n\n- 관심사의 분리: 응용 프로그램의 각 계층은 특정 책임을 갖고 있어 복잡성을 줄이고 코드를 이해하고 유지하기 쉽게 만듭니다.\n- 의존성 규칙: 의존성은 안쪽으로 향합니다. 외부 계층은 내부 계층에 의존할 수 있지만, 내부 계층은 외부 계층에 의존해서는 안 됩니다.\n- 프레임워크로부터 독립: 아키텍처는 특정 프레임워크에 의존해서는 안 되며, 최소한의 영향으로 프레임워크를 전환할 수 있어야 합니다.\n- 테스트 가능성: 비즈니스 로직은 UI, 데이터베이스 또는 기타 외부 구성 요소와 독립적으로 테스트할 수 있어야 합니다.\n\n# Flutter에서 Clean Architecture 적용하기\n\nFlutter에서 Clean Architecture를 적용하는 것은 프로젝트를 UI와 비즈니스 로직 및 데이터 처리를 분리하는 방식으로 구성하는 것을 의미합니다. 여기서 Flutter 프로젝트를 구조화하는 방법에 대한 개요입니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-21-SettingUpandOrganizingYourFlutterProjectwithCleanArchitecture_1.png)\n\n## 도메인 레이어\n\n도메인 레이어는 앱의 핵심입니다. 비즈니스 로직과 엔티티가 포함되어 있습니다. 이 레이어는 다른 레이어에 독립적이며, 외부 프레임워크나 도구에 의존하지 않습니다.\n\n- 엔티티: 앱 전반에서 사용되는 기본 데이터 구조입니다. 이들은 핵심 데이터 개체를 나타내는 일반적인 다트 클래스입니다.\n- 유스 케이스: 비즈니스 로직을 포함하는 클래스입니다. 엔티티와 리포지토리 간의 데이터 흐름을 조정합니다. 유스 케이스는 다른 레이어나 프레임워크에 의존하지 않아야 합니다.\n- 리포지토리: 데이터 작업을 정의하는 인터페이스입니다. 이들은 데이터 레이어에서 구현됩니다.\n\n\n<div class=\"content-ad\"></div>\n\n## 데이터 계층\n\n데이터 계층은 API에서 데이터를 가져오거나 로컬 데이터베이스에서 데이터 작업을 처리합니다. 다음과 같이 구성됩니다:\n\n- 데이터 소스: 데이터 검색을 처리하는 클래스들입니다. 이들은 네트워크 요청(원격 데이터 소스) 또는 로컬 저장소(로컬 데이터 소스)에서 가져올 수 있습니다.\n- 저장소: 도메인 계층에서 정의된 저장소 인터페이스의 구현체입니다. 데이터 작업을 처리하고 여러 소스에서 데이터를 조정합니다.\n- 모델: 데이터를 파싱하고 직렬화하는 데 사용되는 데이터 구조입니다. 이러한 것들은 주로 데이터 소스로부터 받은 데이터의 형식을 나타냅니다.\n\n## 표현 계층\n\n<div class=\"content-ad\"></div>\n\n프레젠테이션 레이어는 UI와 사용자 상호작용을 관리합니다. 플러터에서 이 레이어에는 다음이 포함됩니다:\n\n- State Management: BLoC (비지니스 로직 컴포넌트) 또는 Provider와 같은 패턴을 사용하여 상태와 비지니스 로직을 관리합니다.\n- 위젯: 앱의 시각적 인터페이스를 구축하는 Flutter의 UI 구성 요소입니다.\n\n## 핵심 레이어\n\n전통적인 클린 아키텍처의 일부는 아니지만, 핵심 레이어는 앱 전반에 걸쳐 사용되는 공통 유틸리티와 구성을 제공합니다. 이 레이어는 앱 전체 설정과 도우미 함수를 구성하는 데 필수적입니다.\n\n<div class=\"content-ad\"></div>\n\n- 유틸리티: 서로 다른 레이어에서 사용되는 도우미 함수 및 클래스들.\n- 설정: 앱 전체에서 사용되는 설정 및 상수들.\n\n# 프로젝트 구조 정의 및 구성\n\n여기 플러터 앱을 Clean Architecture로 구성하는 권장된 프로젝트 구조입니다:\n\n```js\nconfigs/\nscripts/\nlib/\n├── core/\n│ ├── utils/\n│ ├── env.dart\n│ └── injection_container.dart\n├── data/\n│ ├── constants/\n│ ├── datasources/\n│ │ ├── local/\n│ │ ├── remote/\n│ │ └── cache/\n│ ├── models/\n│ │ ├── api/\n│ │ │ ├── requests/\n│ │ │ └── responses/\n│ │ ├── cache/\n│ │ ├── exception/\n│ │ └── local/\n│ ├── plugins/\n│ ├── repositories/\n│ └── utils/\n├── domain/\n│ ├── entities/\n│ ├── errors/\n│ ├── repositories/\n│ └── usecases/\n├── l10n/\n├── presentation/\n│ ├── blocs/\n│ ├── components/\n│ ├── routes/\n│ ├── screens/\n│ ├── services/\n│ └── utils/\n├── main_dev.dart\n├── main_prod.dart\n```\n\n<div class=\"content-ad\"></div>\n\n# 디렉토리와 파일 설명\n\n이 섹션은 각 주요 폴더의 목적에 대한 간단한 개요를 제공합니다. 더 자세하고 기술적인 설명은 GitHub 저장소를 참조해주세요.\n\n## configs/\n\n프로젝트의 설정 파일과 설정을 포함합니다. 이 구성에는 환경 설정, 빌드 구성 및 프로젝트에 필요한 다른 전역 설정이 포함됩니다.\n\n<div class=\"content-ad\"></div>\n\n## scripts/\n\n프로젝트 환경을 설정하거나 프로젝트를 빌드하는 등 자동화 작업을 위한 스크립트가 포함되어 있습니다.\n\n## lib/core/\n\n애플리케이션 전체에서 사용되는 중요한 기능 및 구성이 포함되어 있습니다. 이들은 앱의 다양한 계층에서 널리 사용되는 필수 구성 요소입니다.\n\n<div class=\"content-ad\"></div>\n\n- utils/: 애플리케이션 전체에서 사용되는 유틸리티 클래스와 함수가 포함되어 있습니다.\n- env.dart: envied를 사용하여 환경 구성을 하는 파일입니다.\n- injection_container.dart: get_it을 사용하여 의존성 주입을 설정하는 파일입니다.\n\n## lib/data/\n\n데이터 관리를 다루며, 데이터 소스, 모델 및 리포지토리를 포함합니다. 이 계층은 데이터를 가져오고 저장하며 관리하는 역할을 합니다.\n\n- constants/: 데이터 관리에 사용되는 상수를 정의합니다.\n- datasources/: 다른 소스에서 데이터에 액세스하는 방법을 구현합니다.\n- models/: 앱에서 사용되는 데이터의 구조를 나타내는 데이터 모델이 포함되어 있습니다.\n- plugins/: 다양한 기능을 위한 사용자 정의 플러그인이 포함됩니다.\n- repositories/: 리포지토리 패턴을 사용하여 데이터 작업을 관리합니다.\n- utils/: 데이터 계층에서 사용되는 유틸리티 클래스와 함수가 포함되어 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## lib/domain/\n\n애플리케이션의 핵심 비즈니스 로직과 엔티티를 정의합니다. 이 레이어는 다른 레이어에 독립적이며 비즈니스 규칙이 외부 요소에 영향을받지 않도록합니다.\n\n- entities/: 메인 데이터 객체를 나타내는 핵심 엔티티.\n- errors/: 오류 처리에 사용되는 실패 클래스를 정의합니다.\n- repositories/: 레포지토리 패턴을 위한 인터페이스.\n- usecases/: 비즈니스 로직을 캡슐화하는 애플리케이션별 유스케이스를 정의합니다.\n\n## lib/l10n/\n\n<div class=\"content-ad\"></div>\n\n애플리케이션의 다국어 지원을 위한 로컬라이제이션 파일이 포함되어 있습니다.\n\n## lib/presentation/\n\n애플리케이션의 UI 레이어 및 상태 관리를 관리합니다. 이 레이어는 도메인 레이어와 상호 작용하여 데이터를 사용자에게 제공합니다.\n\n- blocs/: flutter_bloc을 사용하여 상태를 관리하는 BLoC (Business Logic Component) 클래스가 포함되어 있습니다.\n- components/: 재사용 가능한 UI 컴포넌트가 포함되어 있습니다.\n- routes/: 애플리케이션 내에서 탐색 경로를 관리합니다.\n- screens/: 애플리케이션의 UI 페이지/스크린이 포함되어 있습니다.\n- services/: 프레젠테이션 레이어에서 사용되는 서비스가 포함되어 있습니다.\n- utils/: 프레젠테이션 레이어에서 사용되는 유틸리티 클래스와 함수가 포함되어 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 주요 진입 지점\n\n- main_dev.dart: 개발 환경을 위한 진입 지점. 앱을 개발 설정으로 구성합니다.\n- main_prod.dart: 프로덕션 환경을 위한 진입 지점. 앱을 프로덕션 설정으로 구성합니다.\n\n# 결론\n\nClean Architecture를 사용하여 Flutter 프로젝트를 설정하고 구성하면 코드베이스가 확장 가능하고 유지 관리 가능하며 테스트할 수 있게 됩니다. 이 원칙을 따르고 프로젝트를 적절하게 구조화함으로써 복잡성을 관리하고 코드를 깔끔하고 모듈식으로 유지할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 다음은 무엇일까요?\n\n다음 글에서는 \"플러터의 클린 아키텍처 도메인 레이어 탐구\"에 대해 더 자세히 다룰 예정입니다. 엔티티, 유즈 케이스 및 레포지토리를 정의하는 가장 좋은 방법과 예시 구현에 대해 논의할 것입니다. 계속 주목해 주세요!\n\n# 이전 글\n\n지나치셨다면, 클린 아키텍처 소개를 확인하여 클린 아키텍처와 그 원칙에 대한 개요를 얻어보세요.\n\n<div class=\"content-ad\"></div>\n\n# 참고 자료\n\n- Flutter Clean Architecture & TDD Course — Reso Coder\n- Clean Coder Blog","ogImage":{"url":"/assets/img/2024-06-21-SettingUpandOrganizingYourFlutterProjectwithCleanArchitecture_0.png"},"coverImage":"/assets/img/2024-06-21-SettingUpandOrganizingYourFlutterProjectwithCleanArchitecture_0.png","tag":["Tech"],"readingTime":6},{"title":"2024년 Flutter에서 Dio로 HTTP 요청을 간편하게 보내는 방법","description":"","date":"2024-06-21 19:56","slug":"2024-06-21-FlutterDio","content":"\n\n# Flutter에서 Dio를 활용한 네트워크 요청 마스터하기\n\nFlutter 개발 세계에서 네트워크 요청을 보내는 것은 흔한 작업입니다. Flutter는 기본적인 HTTP 요청 처리 기능을 제공하지만 Dio와 같은 강력한 라이브러리를 통해 고급 기능을 제공하고 프로세스를 간소화할 수 있습니다. 이 글에서는 Dart용 강력한 HTTP 클라이언트인 Dio에 대해 깊이 있게 알아보고, 이를 통해 Flutter 개발을 더 쉽고 효율적으로 만드는 방법을 살펴보겠습니다.\n\n## Dio란 무엇인가요?\n\nDio는 복잡한 네트워크 작업을 처리하는데 필요한 쉬운 API, 고급 구성 옵션, 다양한 기능을 제공하는 Dart용 강력한 HTTP 클라이언트입니다. 주요 기능 중 일부는 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n- 요청 및 응답 로깅을위한 인터셉터\n- 글로벌 구성 옵션\n- 폼 데이터 처리\n- 파일 다운로드\n- 시간 초과 처리\n- HTTP, WebSocket 등을위한 사용자 정의 어댑터\n- 자동 JSON 직렬화\n\n## Dio를 사용해야 하는 이유?\n\nFlutter의 내장 http 패키지는 간단한 작업에는 충분하지만, Dio는 더 많은 기능을 제공하여 복잡한 네트워크 작업에 적합합니다. 인터셉터 및 폼 데이터 처리와 같은 강력한 기능으로 많은 개발자들에게 선택되는 이유입니다.\n\n## Dio 시작하기\n\n<div class=\"content-ad\"></div>\n\nDio 시작하려면, Flutter 프로젝트의 종속성에 Dio를 추가해야 해요. pubspec.yaml 파일을 열고 다음과 같이 추가해 주세요:\n\n```yaml\ndependencies:\n  dio: ^5.0.0\n```\n\n패키지를 설치하려면 flutter pub get을 실행해 주세요.\n\n## 간단한 GET 요청하기\n\n<div class=\"content-ad\"></div>\n\n간단한 GET 요청부터 시작해봅시다. 먼저 Dio 패키지를 가져와주세요.\n\n```js\nimport 'package:dio/dio.dart';\n```\n\n이제 Dio의 인스턴스를 만들고 GET 요청을 보내보세요:\n\n```js\nvoid fetchUser() async {\n  try {\n    final dio = Dio();\n    final response = await dio.get('https://jsonplaceholder.typicode.com/users/1');\n    print(response.data);\n  } catch (e) {\n    print('Error: $e');\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 코드 스니펫은 API에서 사용자 데이터를 가져오기 위해 GET 요청을 보내는 방법을 보여줍니다.\n\n## 오류 처리\n\nDio는 견고한 오류 처리 메커니즘을 제공합니다. 다양한 유형의 오류를 catch하여 적절히 처리할 수 있습니다:\n\n```js\nvoid fetchUser() async {\n  try {\n    final dio = Dio();\n    final response = await dio.get('https://jsonplaceholder.typicode.com/users/1');\n    print(response.data);\n  } on DioError catch (e) {\n    if (e.response != null) {\n      print('에러 응답: ${e.response?.data}');\n    } else {\n      print('에러 메시지: ${e.message}');\n    }\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## Interceptors 사용하기\n\nDio의 Interceptors는 요청을 보내기 전이나 응답을 받은 후에 작업을 수행할 수 있게 해줍니다. 이는 로깅, 요청 수정 또는 전역적으로 오류를 처리하는 데 유용합니다.\n\n```js\nfinal dio = Dio();\n```\n\n```js\ndio.interceptors.add(\n  InterceptorsWrapper(\n    onRequest: (options, handler) {\n      print('Request: ${options.method} ${options.path}');\n      return handler.next(options);\n    },\n    onResponse: (response, handler) {\n      print('Response: ${response.statusCode} ${response.data}');\n      return handler.next(response);\n    },\n    onError: (DioError e, handler) {\n      print('Error: ${e.message}');\n      return handler.next(e);\n    },\n  ),\n);\n```\n\n<div class=\"content-ad\"></div>\n\n## POST 요청하기\n\nDio를 사용하여 POST 요청을 보내려면 post 메서드를 사용할 수 있습니다. 다음은 POST 요청에서 JSON 데이터를 보내는 예시입니다:\n\n```js\nvoid createUser() async {\n  try {\n    final dio = Dio();\n    final response = await dio.post(\n    'https://jsonplaceholder.typicode.com/users',\n    data: {\n      'name': 'John Doe',\n      'email': 'john.doe@example.com',\n    },\n    );\n    print(response.data);\n  } catch (e) {\n    print('Error: $e');\n  }\n}\n```\n\n## 파일 업로드 및 다운로드\n\n<div class=\"content-ad\"></div>\n\nDio를 사용하면 파일 업로드 및 다운로드를 쉽게 처리할 수 있습니다. 파일을 업로드하는 방법은 다음과 같습니다:\n\n```js\nvoid uploadFile() async {\n  try {\n    final dio = Dio();\n    final file = await MultipartFile.fromFile('파일 경로');\n    final response = await dio.post(\n      'https://example.com/upload',\n      data: FormData.fromMap({\n        'file': file,\n      }),\n    );\n    print(response.data);\n  } catch (e) {\n    print('Error: $e');\n  }\n}\n```\n\n파일을 다운로드하는 방법은 다음과 같습니다:\n\n```js\nvoid downloadFile() async {\n  try {\n    final dio = Dio();\n    final response = await dio.download(\n      'https://example.com/file',\n      '저장할 파일 경로',\n    );\n    print('파일 다운로드됨: ${response.statusCode}');\n  } catch (e) {\n    print('Error: $e');\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## 결론\n\nDio는 플러터용으로 개발된 다재다능하고 강력한 HTTP 클라이언트로, 네트워크 요청을 간단하게 만들어주고 복잡한 시나리오를 다룰 수 있는 고급 기능을 제공합니다. Dio를 플러터 프로젝트에 통합하면 네트워크 작업을 더 효율적으로 처리하고 관련 코드양을 줄일 수 있습니다.\n\n간단한 앱을 개발하거나 복잡한 기업 애플리케이션을 구축하더라도, Dio는 플러터에서 모든 네트워크 요청을 처리하는 좋은 선택지입니다. 다음 프로젝트에서 Dio를 사용해보고 차이를 경험해보세요!","ogImage":{"url":"/assets/img/2024-06-21-FlutterDio_0.png"},"coverImage":"/assets/img/2024-06-21-FlutterDio_0.png","tag":["Tech"],"readingTime":4},{"title":"Flutter vs React Native 2024년 최종 비교 분석","description":"","date":"2024-06-21 19:50","slug":"2024-06-21-FluttervsReactNativeTheUltimateComparisonfor2024","content":"\n\n<img src=\"/assets/img/2024-06-21-FluttervsReactNativeTheUltimateComparisonfor2024_0.png\" />\n\n# 목차\n\n- Flutter 개요\n- React Native 개요\n- Flutter vs React Native: 장단점\n- Flutter vs React Native: 비교 표\n- 상세 비교: Flutter vs React Native\n- 2024년 선택 이유: Flutter vs React Native\n- 인기 앱 비교: Flutter vs React Native\n- Blup이 Flutter 앱 개발을 어떻게 도울까요?\n- Blup이 React Native 앱 개발을 어떻게 도울까요?\n- Flutter vs React Native: 자주 묻는 질문\n- 마무리\n\n<div class=\"content-ad\"></div>\n\n플러터(Flutter)는 구글에서 개발한 인기 있는 오픈 소스 프레임워크로, 단일 코드베이스에서 네이티브로 컴파일된 모바일, 웹, 데스크톱 애플리케이션을 구축하는 데 사용됩니다. Dart 프로그래밍 언어를 사용하며 미리 디자인된 다양한 위젯을 제공하여 시각적으로 매력적인 애플리케이션을 쉽게 만들 수 있습니다. 플러터의 핫 리로드 기능을 통해 개발자는 실시간으로 변경 사항을 볼 수 있어 개발 프로세스를 크게 가속화할 수 있습니다. 알리바바, BMW, 필립스 휴 등 대기업들이 플러터를 사용하며 그 성능과 신뢰성을 입증하고 있습니다.\n\n# 리액트 네이티브(React Native) 개요\n\n페이스북에서 만든 리액트 네이티브(React Native)는 또 다른 인기 있는 크로스 플랫폼 애플리케이션을 구축하기 위한 프레임워크입니다. JavaScript와 React를 사용하여 많은 개발자들에게 접근하기 쉽습니다. 리액트 네이티브는 재사용 가능한 컴포넌트와 핫 리로드 기능으로 빠른 개발과 반복을 용이하게 합니다. 페이스북, 인스타그램, 에어비앤비와 같은 기업들이 리액트 네이티브를 사용하여 성공적인 애플리케이션을 만들었으며, 이로써 그의 견고함과 다재다능함을 입증하고 있습니다.\n\n# 플러터 vs 리액트 네이티브: 장단점\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-21-FluttervsReactNativeTheUltimateComparisonfor2024_1.png\" />\n\nFlutter 장점:\n\n- 네이티브 코드로 직접 컴파일링하여 고성능.\n- 다양한 사용자 정의 위젯이 풍부.\n- Google로부터 강력한 커뮤니티 지원 및 지속적 업데이트.\n- 여러 플랫폼을 위한 단일 코드베이스.\n\nFlutter 단점:\n\n<div class=\"content-ad\"></div>\n\n- React Native와 비교하여 써드 파티 라이브러리의 제한된 이용 가능성.\n- 더 큰 앱 크기.\n- 일부 개발자에겐 도전일 수 있는 Dart 학습이 필요합니다.\n\nReact Native의 장점:\n\n- 널리 사용되며 방대한 커뮤니티 지원.\n- 빠른 개발을 위한 재사용 가능한 컴포넌트.\n- 많은 개발자가 익숙한 JavaScript 사용.\n- 다양한 써드 파티 라이브러리와 플러그인을 갖춘 풍부한 생태계.\n\nReact Native의 단점:\n\n<div class=\"content-ad\"></div>\n\n- JavaScript 브릿지로 인해 성능이 영향을 받을 수 있습니다.\n- 업데이트와 버전 관리에 문제가 발생하기도 합니다.\n- 특정 기능을 위해 네이티브 모듈이 필요한 경우가 있어 개발을 복잡하게 할 수 있습니다.\n\n# 플러터 vs 리액트 네이티브: 비교 표\n\n![2024년 6월 21일-플러터 대 리액트 네이티브: 2024년을 위한 최종 비교_2.png](/assets/img/2024-06-21-FluttervsReactNativeTheUltimateComparisonfor2024_2.png)\n\n# 자세한 비교: 플러터 vs 리액트 네이티브\n\n<div class=\"content-ad\"></div>\n\n성능: Flutter의 아키텍처는 Skia 그래픽 엔진을 포함하여 JavaScript 브리지를 필요로하지 않고 높은 성능을 제공합니다. 이로 인해 그래픽 집중적인 응용 프로그램에서 특히 빠르고 부드러운 성능을 얻을 수 있습니다. 반면, React Native는 효율적이지만 네이티브 컴포넌트 통신을 위해 JavaScript 브리지에 의존하기 때문에 성능 병목 현상을 겪을 수 있습니다.\n\n개발 경험: React Native는 JavaScript 또는 React 경험을 가진 개발자들을 위해 학습 곡선이 더 부드럽습니다. Flutter는 Dart를 배워야 하므로 좀 더 어려울 수 있지만 Flutter Doctor와 같은 도구를 통해 셋업 지원을 받을 수 있는 방대한 문서 지원이 제공됩니다.\n\n커뮤니티와 생태계: React Native는 더 크고 보다 확립된 커뮤니티를 갖고 있어 방대한 자원과 지원을 제공합니다. Flutter의 커뮤니티는 비교적 새롭지만 활발한 기여와 개발자를 위한 증가하는 리소스가 빠르게 확대되고 있습니다.\n\n사용 사례 및 산업 채택: React Native는 복잡한 통합이 필요하며 JavaScript 생태계에 깊이 관련된 응용 프로그램에 이상적입니다. Flutter는 높은 성능과 여러 플랫폼에 걸쳐 일관된 사용자 경험을 필요로 하는 프로젝트에서 빛을 발합니다. 강력한 위젯 시스템을 갖고 있어 복잡한 UI 및 애니메이션을 가진 응용 프로그램에 특히 적합합니다.\n\n<div class=\"content-ad\"></div>\n\n# 플러터 대 렉트 네이티브: 2024년에 선택하는 이유\n\n2024년에 플러터를 선택하는 이유:\n\n- 성능이 우수하고 풍부하며 사용자 정의 가능한 UI가 필요한 경우.\n- 단일 코드베이스로 여러 플랫폼 (모바일, 웹, 데스크톱)을 대상으로하려는 경우.\n- 현대 앱 개발을 위해 설계된 언어 (다트)를 사용하고 싶은 경우.\n\n2024년에 렉트 네이티브를 선택하는 이유:\n\n<div class=\"content-ad\"></div>\n\n- 이미 JavaScript와 React에 익숙하시군요.\n- 다양한 제삼자 라이브러리의 거대한 생태계를 활용해야 합니다.\n- 더 넓은 커뮤니티와 지원 리소스를 갖춘 프레임워크를 선호하시군요.\n\n# 플러터 vs 리액트 네이티브: 인기 앱\n\n![이미지](/assets/img/2024-06-21-FluttervsReactNativeTheUltimateComparisonfor2024_3.png)\n\n플러터로 개발된 인기 앱:\n\n<div class=\"content-ad\"></div>\n\n- 알리바바: 선도적인 전자 상거래 플랫폼입니다.\n- BMW: 상호 작용적이고 매력적인 자동차 체험을 제공합니다.\n- Philips Hue: 스마트 홈 조명 제어 앱입니다.\n\n![이미지](/assets/img/2024-06-21-FluttervsReactNativeTheUltimateComparisonfor2024_4.png)\n\nReact Native로 개발된 인기 있는 앱:\n\n- Facebook: 소셜 미디어 거인입니다.\n- Instagram: 널리 사용되는 사진 및 동영상 공유 앱입니다.\n- Airbnb: 숙소 예약에 사용되는 인기 있는 플랫폼입니다.\n\n<div class=\"content-ad\"></div>\n\n# 블룹이 플러터 앱 개발을 어떻게 도울 수 있는지\n\n블룹에서는 플러터 앱 개발을 전문으로 하며, 비즈니스가 고성능의 크로스 플랫폼 애플리케이션을 만들도록 도와드립니다. 저희 팀은 다음과 같은 경험이 풍부한 플러터 개발자들이 있어요:\n\n- 시각적으로 멋지고 높은 성능의 애플리케이션을 구축합니다.\n- 발상부터 배포까지 포괄적인 앱 개발 서비스를 제공합니다.\n- 모든 플랫폼에서의 원활한 통합 및 기능을 보장합니다.\n- 앱을 최신 상태로 유지하기 위한 출시 후 지원 및 유지 관리를 제공합니다.\n\n# 블룹이 리액트 네이티브 앱 개발을 어떻게 도울 수 있는지\n\n<div class=\"content-ad\"></div>\n\nBlup은 자바스크립트와 리액트의 강력한 기능을 활용하여 견고한 애플리케이션을 만드는 전문 React Native 앱 개발 서비스도 제공합니다. Blup의 React Native 서비스에는 다음이 포함되어 있습니다:\n\n- 비즈니스 요구 사항에 맞게 맞춤형 앱 개발.\n- 기능을 향상시키기 위한 서드파티 라이브러리 및 플러그인 통합.\n- 안정적인 앱을 제공하기 위한 종합적인 테스트 및 품질 보증.\n- 앱의 성공을 보장하기 위한 지속적인 지원 및 유지 관리.\n\n# Flutter 대 React Native: 흔히 묻는 질문들\n\n- Flutter가 정확히 무엇이고 무슨 역할을 하는가?\n- 2024년에 Flutter를 배워야 하는 이유는 무엇인가?\n- Flutter가 크로스 플랫폼 개발을 어떻게 간소화하는가?\n- Flutter가 앱 개발 초보자에게 좋은 프레임워크인가?\n- Flutter와 함께 사용되는 프로그래밍 언어는 무엇이며 쉽게 배울 수 있는가?\n- Flutter에 능숙한 개발자의 취업 전망은 어떤가?\n- Flutter를 사용하여 모바일 앱 외에도 웹 및 데스크톱 애플리케이션을 구축할 수 있는가?\n- Flutter 앱의 성능은 네이티브 애플리케이션과 비교할 때 어떤가?\n- Flutter 개발자를 위한 커뮤니티 및 지원 리소스는 어떻게 제공되는가?\n- 구글은 얼마나 자주 Flutter를 업데이트하며 어떤 개선 사항이 기대되는가?\n\n<div class=\"content-ad\"></div>\n\n# 마치며\n\n플러터(Flutter)와 리액트 네이티브(React Native) 중 어느 것을 선택할지는 당신의 특정 요구 사항과 보유한 기술 세트에 달려있습니다. 두 프레임워크 모두 효과적인 크로스 플랫폼 개발 솔루션을 제공하는데, 플러터는 성능과 UI 디자인에서 뛰어나고, 리액트 네이티브는 JavaScript 개발자에게 더 접근하기 쉽습니다. 각각의 장단점을 이해함으로써, 2024년 앱 개발 경력을 향상시킬 수 있는 결정을 내릴 수 있습니다. 플러터를 선택하든 리액트 네이티브를 선택하든, Blup은 전문 서비스와 철저한 지원으로 개발 여정을 돕고 있습니다.","ogImage":{"url":"/assets/img/2024-06-21-FluttervsReactNativeTheUltimateComparisonfor2024_0.png"},"coverImage":"/assets/img/2024-06-21-FluttervsReactNativeTheUltimateComparisonfor2024_0.png","tag":["Tech"],"readingTime":5},{"title":"훅의 다양성 예시를 통한 탐구","description":"","date":"2024-06-20 14:10","slug":"2024-06-20-TheVersatilityofHooksanExplorationviaExample","content":"\n\n## 소개: 프리랜스 React 기회\n\n아리조나 주립대학교에서 그래픽 정보 기술 석사 과정을 졸업한 후, 전방향 개발 기술을 강화하여 더 다재다능한 UX 디자이너가 되고 싶었습니다. React는 인기 있는 프레임워크였기 때문에 문서를 읽고 여러 튜토리얼을 실행하는 것으로 시작했습니다. 튜토리얼을 몇 개 완료한 후, 프리랜스 프론트엔드 개발의 세계로 발을 들이게 되었습니다.\n\n내 첫 번째 프리랜스 프로젝트 중 하나는 별자리 계산기인 AstronoMe이었습니다. 클라이언트는 사용자에게 별자리를 알려주고 성격과 특이한 점에 대한 추가 정보를 제공하는 웹 애플리케이션을 원했습니다. 기본적인 디자인 미팅을 거친 후 클라이언트와 합의한 바에 따르면 프로젝트는 멀티페이지 React 애플리케이션이어야 했습니다. AstronoMe은 \"홈\", \"퀴즈\", \"결과\" 페이지로 이루어진 총 3개의 페이지 애플리케이션이었습니다. 독자들은 애플리케이션의 코드를 따라 가며 UI를 검토하기 위해 아래 링크를 클릭할 수 있습니다: AstronoMe 애플리케이션 링크와 AstronoMe 코드 링크\n\n## 구현: AstronoMe 웹 애플리케이션\n\n<div class=\"content-ad\"></div>\n\nAstronoMe 웹 애플리케이션은 함수형 컴포넌트를 사용하여 구축되었습니다. 함수형 컴포넌트는 유연하며 클래스 컴포넌트보다 더 간편한 방법으로 컴포넌트를 작성하는 방식입니다. 함수형 컴포넌트는 Hooks에 접근할 수 있어 상태(state)와 효과(effects)를 조작할 수 있는 함수를 사용할 수 있습니다. 이 문서는 \"퀴즈\" 및 \"결과\" 페이지의 구현과 Hooks에 의존하는 부분에 초점을 맞춥니다.\n\n\"퀴즈\" 페이지에는 두 개의 큰 부트스트랩 \"select\" 요소와 사용자를 \"결과\" 페이지로 이동시키는 버튼이 특징으로 나타납니다. 두 \"select\" 요소를 사용하여 사용자가 태어난 월과 일을 선택할 수 있습니다. \"결과\" 페이지에는 사용자의 별자리와 해당 별자리에 해당하는 정보가 들어있는 컴포넌트가 표시됩니다.\n\nAstronoMe 웹 애플리케이션의 구현은 \"useState,\" \"useEffect,\" \"useNavigate,\" 그리고 \"useLocation\" 네 가지 Hooks에 의존합니다.\n## Hooks에 대해 더 알아보기\n\n<div class=\"content-ad\"></div>\n\n\"useState\" Hook을 사용하여 사용자의 출생 월과 출생 날짜 변수의 값을 설정했습니다. 또한 사용자가 출생 일자를 선택한 후 사용자의 별자리를 설정하는 데도이 Hook을 사용했습니다.\n\n\"useEffect\" Hook은 페이지를 렌더링 한 후 if-else 문에서 비교 작업을 수행하는 데 사용되었습니다. 이러한 문에서 \"signState\"가 설정되었습니다.\n\n<img src=\"/assets/img/2024-06-20-TheVersatilityofHooksanExplorationviaExample_0.png\" />\n\n\"useNavigate\" Hook을 사용하여 사용자를 \"Result\" 페이지로 이동하면서 해당 페이지로 데이터를 전달했습니다. 여기서 \"navigate\" 함수가 매우 중요했는데, 이는 다양한 signature를 갖고 있기 때문입니다. 이 구현에서는 두 개의 인수를 사용한 signature를 사용했는데, URL 및 추가 매개 변수였습니다. \"Quiz\" 페이지의 경우, 두 번째 매개 변수는 상태 객체의 \"signState\"였습니다. \"signState\"는 \"Result\" 페이지로 전송되어 사용자에게 렌더링 될 메시지 구성 요소를 결정하는 데 사용되었습니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-20-TheVersatilityofHooksanExplorationviaExample_1.png\" />\n\n마지막으로, \"useLocation\" Hook은 \"Result\" 페이지에서 \"Result\" 페이지로 전송된 상태 객체에 액세스하는 데 사용되었습니다. \"signState\"는 상태 객체에서 비구조화되어 사용되어 사용자에게 개성 정보를 렌더링하는 데 사용되었습니다.\n\n<img src=\"/assets/img/2024-06-20-TheVersatilityofHooksanExplorationviaExample_2.png\" />\n\n## 훅을 사용하여 오류 처리하기\n\n<div class=\"content-ad\"></div>\n\n웹 애플리케이션에서 오류 가능성이 매우 낮았습니다. 사용자가 옵션을 선택하는 것으로 제한되어 데이터 입력으로 인해 발생할 수 있는 문제를 피할 수 있었습니다. 처음에는 \"선택\" 요소 두 개를 모두 비워 둔 경우에 대한 오류 케이스가 식별되었습니다. 나중에 테스트를 진행하면서 예전 동료 중 한 명이 \"선택\" 요소 중 하나를 선택하지 않은 채 다른 하나는 선택한 경우의 추가 오류 케이스를 지적했습니다. 이로 인해 \"결과\" 페이지의 렌더링이 예측할 수 없게 되었습니다.\n\n이 오류를 해결하기 위해 \"Quiz\" 페이지의 else 문에 \"signState\"를 빈 문자열로 설정했습니다. 게다가 오류 컴포넌트의 메시지를 업데이트하여 두 가지 오류 케이스를 모두 다루는 언어를 사용했습니다. 사용자를 \"Quiz\" 페이지로 되돌리는 버튼의 \"onClick\" 이벤트 내에서 \"useNavigate\" 훅을 사용했습니다. 이러한 오류 컴포넌트의 변경으로 사용자가 무엇이 잘못되었는지 진단하고 빠르게 오류를 해결할 수 있는 기회를 제공했습니다.\n\n## 결론: Hooks의 힘\n\nHooks를 사용하면 React 애플리케이션의 라이프사이클의 다양한 단계에서 변수를 조작하고 변경을 실행할 수 있는 능력을 갖게 됩니다. 이는 Java에서의 간단한 설정 방법과 유사하게 작동하며 어떤 함수가 실행되는 시점도 결정할 수 있습니다. Hooks는 매우 다양하며 함수형 컴포넌트를 React 개발에서 강력한 자산으로 만듭니다.\n\n<div class=\"content-ad\"></div>\n\nHooks에 대해 자세히 알아보려면 React Hooks를 소개하는 기사 링크를 확인해보세요!","ogImage":{"url":"/assets/img/2024-06-20-TheVersatilityofHooksanExplorationviaExample_0.png"},"coverImage":"/assets/img/2024-06-20-TheVersatilityofHooksanExplorationviaExample_0.png","tag":["Tech"],"readingTime":3},{"title":"빠른 FastAPI 애플리케이션에서 JWT 인증 구현하기","description":"","date":"2024-06-20 14:08","slug":"2024-06-20-ImplementingJWTAuthenticationInaFastAPIApplication","content":"\n\n이 블로그 포스트에서는 FastAPI 애플리케이션에서 JWT (JSON Web Token) 인증을 구현하는 방법을 안내하겠습니다. JWT는 두 당사자 간에 주장을 나타내는 컴팩트하고 URL-안전한 수단으로, 보안 인증에 일반적으로 사용됩니다.\n\n![이미지](/assets/img/2024-06-20-ImplementingJWTAuthenticationInaFastAPIApplication_0.png)\n\n## JWT란 무엇인가요?\n\nJWT는 JSON Web Token의 약자입니다. 일부 주장을 나타내는 토큰을 생성하기 위한 표준입니다. 이러한 토큰들은 비밀 키 또는 공개/개인 키 쌍으로 서명됩니다. 다음은 JWT가 작동하는 간단한 설명입니다:\n\n<div class=\"content-ad\"></div>\n\n- 헤더: 일반적으로 토큰 유형 (JWT)과 서명 알고리즘 (예: HMAC SHA256 또는 RSA)으로 구성됩니다.\n\n```json\n{\n  \"alg\": \"HS256\",\n  \"typ\": \"JWT\"\n}\n```\n\n- 페이로드: 클레임은 개체(일반적으로 사용자)에 관한 문장과 추가 데이터입니다.\n\n```json\n{\n  \"username\": \"rajan\",\n  \"email\": \"rajan12@rajan.com\"\n}\n```\n\n<div class=\"content-ad\"></div>\n\n- 서명: 서명 부분을 만들려면 인코딩된 헤더, 인코딩된 페이로드, 비밀키 및 헤더에서 지정한 알고리즘을 가져 와야 합니다.\n\n```js\n# secret id\nABjhjdsjfsh234fjhuih324$jihdfdshkgsog\n```\n\n## JWT의 장점:\n\n- 간결함: JWT는 간결하며 URL, POST 매개변수 또는 HTTP 헤더 안에 전송할 수 있어 모바일 애플리케이션에 적합합니다.\n- 자체 포함: 페이로드에는 인증에 필요한 모든 정보가 포함되어 있어 여러 개의 데이터베이스 쿼리가 필요하지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n## FastAPI에서의 단계별 구현\n\n## 단계 1: 의존성 설정\n\n먼저, FastAPI와 관련 의존성이 설치되어 있는지 확인하세요:\n\n```js\npip install fastapi \npip install passlib \npip install python-jose\n```\n\n<div class=\"content-ad\"></div>\n\n## 단계 2: 모델 및 스키마 정의\n\n사용자 모델과 요청/응답 스키마를 정의할 것입니다.\n\n## models.py\n\n```python\n# models.py\n\nfrom pydantic import BaseModel\nfrom typing import List\n\nclass User(BaseModel):\n    username: str\n    email: str\n    hashed_password: str\n\n# 메모리 내 \"데이터베이스\"\nfake_users_db: List[User] = []\nblocklist_token = []\n```\n\n<div class=\"content-ad\"></div>\n\n이 블로그에서는 데이터를 메모리에 저장합니다. 위의 코드 스니펫에서 볼 수 있듯이, fake_user_db를 사용하여 사용자 세부 정보를 저장하고, blocklist_token을 사용하여 차단된 토큰을 저장합니다.\n\n## schemas.py\n\n```js\nfrom pydantic import BaseModel, EmailStr\n\nclass UserCreate(BaseModel):\n    username: str\n    email: EmailStr\n    password: str\n\nclass UserResponse(BaseModel):\n    username: str\n    email: str\n\nclass Token(BaseModel):\n    access_token: str\n    token_type: str\n```\n\n이 스키마 모델은 사용자 요청 본문을 유효성 검사하는 데 사용되며, 적절한 형식으로 응답을 전송합니다.\n\n<div class=\"content-ad\"></div>\n\n## 단계 3: 설정 상수\n\n## constants.py\n\n```js\nSECRET_KEY = \"your_secret_key\"\nALGORITHM = \"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES = 30\n```\n\n- 이 파일은 주로 애플리케이션에 상수를 정의하는 데 사용됩니다.\n\n<div class=\"content-ad\"></div>\n\n## 단계 4: 인증 핸들러\n\n이것은 우리의 JWT 인증의 핵심입니다. 이는 비밀번호 해싱, 토큰 생성 및 사용자 인증을 처리합니다.\n\n## auth.py\n\n```python\nfrom fastapi import HTTPException, status\nfrom jose import jwt, JWTError\nfrom passlib.context import CryptContext\nfrom datetime import datetime, timedelta\nfrom typing import Optional\nfrom models import fake_users_db, blocklist_token\nfrom constants import SECRET_KEY, ALGORITHM\nfrom fastapi.security import HTTPAuthorizationCredentials, HTTPBearer\nfrom fastapi import Security\n\nclass AuthHandler:\n    security = HTTPBearer()\n    pwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\n    async def verify_password(self, plain_password, hashed_password):\n        return self.pwd_context.verify(plain_password, hashed_password)\n\n    async def get_password_hash(self, password):\n        return self.pwd_context.hash(password)\n\n    async def create_access_token(self, data: dict, expires_delta: Optional[timedelta] = None):\n        to_encode = data.copy()\n        if expires_delta:\n            expire = datetime.utcnow() + expires_delta\n        else:\n            expire = datetime.utcnow() + timedelta(minutes=15)\n        to_encode.update({\"exp\": expire})\n        encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n        return encoded_jwt\n\n    async def get_user(self, username: str):\n        user = next((user for user in fake_users_db if user.username == username), None)\n        return user\n\n    async def authenticate_user(self, username: str, password: str):\n        user = await self.get_user(username)\n        if not user:\n            return False\n        if not await self.verify_password(password, user.hashed_password):\n            return False\n        return user\n    \n    async def blocklist_token(self, token):\n        blocklist_token.append(token)\n\n    async def istokenblock(self, token):\n        return token in blocklist_token\n\n    async def auth_wrapper(self, auth: HTTPAuthorizationCredentials = Security(security)):\n        token = auth.credentials\n        if not token or await self.istokenblock(token):\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Not authenticated\",\n                headers={\"WWW-Authenticate\": \"Bearer\"},\n            )\n        try:\n            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n            username: str = payload.get(\"sub\")\n            if username is None:\n                raise HTTPException(\n                    status_code=status.HTTP_401_UNAUTHORIZED,\n                    detail=\"Not authenticated\",\n                    headers={\"WWW-Authenticate\": \"Bearer\"},\n                )\n        except JWTError:\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Not authenticated\",\n                headers={\"WWW-Authenticate\": \"Bearer\"},\n            )\n        user = await self.get_user(username)\n        if user is None:\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Not authenticated\",\n                headers={\"WWW-Authenticate\": \"Bearer\"},\n            )\n        return user\n```\n\n<div class=\"content-ad\"></div>\n\n- 이곳은 인증 애플리케이션의 핵심입니다. 여기서 verify_password, authenticate_user, blocklist_token 등과 같은 모든 중요한 기능을 정의해야 합니다.\n\n## 단계 5: 사용자 등록 및 토큰 생성\n\n## controller.py\n\n```js\nfrom schemas import UserCreate, UserResponse, Token\nfrom fastapi import APIRouter\nfrom auth import AuthHandler\nfrom fastapi import APIRouter, Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordRequestForm\nfrom datetime import timedelta\nfrom models import User, fake_users_db\nfrom constants import ACCESS_TOKEN_EXPIRE_MINUTES\nfrom fastapi.security import HTTPAuthorizationCredentials\nfrom fastapi import Security\n\n\nauth_router = APIRouter()\nauth_handle = AuthHandler()\n\n@auth_router.post(\"/register\", response_model=UserResponse)\nasync def register_user(user: UserCreate):\n    if await auth_handle.get_user(user.username):\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"이미 등록된 사용자명입니다.\",\n        )\n    hashed_password = await auth_handle.get_password_hash(user.password)\n    new_user = User(username=user.username, email=user.email, hashed_password=hashed_password)\n    fake_users_db.append(new_user)\n    return new_user\n\n@auth_router.post(\"/token\", response_model=Token)\nasync def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):\n    user = await auth_handle.authenticate_user(form_data.username, form_data.password)\n    if not user:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"잘못된 사용자명 또는 비밀번호입니다.\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    access_token = await auth_handle.create_access_token(\n        data={\"sub\": user.username}, expires_delta=access_token_expires\n    )\n    return {\"access_token\": access_token, \"token_type\": \"bearer\"}\n\n@auth_router.post(\"/logout\")\nasync def logout_access_token(auth: HTTPAuthorizationCredentials = Security(auth_handle.security)):\n    await auth_handle.blocklist_token(auth.credentials)\n    return {\"message\": \"로그아웃 되었습니다.\"}\n```\n\n<div class=\"content-ad\"></div>\n\n여기에서는 사용자를 등록하고 로그인하며 토큰을 생성하는 데 사용되는 모든 컨트롤러를 정의합니다.\n\n## 단계 6: FastAPI와 통합하기\n\n마지막으로, 모든 것을 주 애플리케이션에 통합하세요.\n\n## main.py\n\n<div class=\"content-ad\"></div>\n\n```python\nfrom fastapi import FastAPI, Depends\nfrom controller import auth_router\nfrom models import User\nfrom auth import AuthHandler\n\napp = FastAPI()\nauth_handler = AuthHandler()\napp.include_router(auth_router, prefix=\"/auth\", tags=[\"Auth\"])\n\n@app.get(\"/auth-test\")\nasync def read_users_me(current_user: User = Depends(auth_handler.auth_wrapper)):\n    return current_user\n```\n\nJWT 인증을 테스트하기 위한 라우트를 만들었습니다.\n\n여기 GitHub 링크 있어요!!\n\n## 결론\n\n\n<div class=\"content-ad\"></div>\n\nFastAPI 애플리케이션에 JWT 인증을 설정했군요. 이 설정에는 사용자 등록, JWT 토큰 생성을 위한 로그인 및 보호된 경로를 위한 토큰 확인이 포함되어 있어요. JWT는 인증된 사용자만 특정 엔드포인트에 접근할 수 있도록 보장하여 API를 안전하고 사용자 친화적으로 만들어줍니다.\n\n## 참고:\n\n- https://fastapi.tiangolo.com/\n\n독서해 주셔서 감사합니다. 만약 잘못된 부분이나 더 좋은 방법을 알고 계시다면 아래 댓글에 알려주세요.\n\n<div class=\"content-ad\"></div>\n\n만약 이 게시물이 마음에 든다면 아래의 👏 버튼을 눌러주세요. 다른 사람들이 유용하게 활용할 수 있도록 도와주세요. 또한 GitHub에서 저를 팔로우하고 Linkedin에서 저와 연결할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-20-ImplementingJWTAuthenticationInaFastAPIApplication_0.png"},"coverImage":"/assets/img/2024-06-20-ImplementingJWTAuthenticationInaFastAPIApplication_0.png","tag":["Tech"],"readingTime":9},{"title":"나의 오픈그래프xyz를 만들고 2만 달러에 판매한 여정","description":"","date":"2024-06-20 14:07","slug":"2024-06-20-MyJourneyofBuildingandSellingopengraphxyzfor20000","content":"\n\n![MyJourneyofBuildingandSellingopengraphxyzfor20000](/assets/img/2024-06-20-MyJourneyofBuildingandSellingopengraphxyzfor20000_0.png)\n\n안녕하세요, 제 마음에 가까운 모험을 공유하려고 합니다 - 제 첫 번째 사이드 프로젝트 Opengraph.xyz를 판매하는 경험을요.\n\n이 전에는 0 MRR을 가진 사이드 프로젝트가 아무 가치가 없다고 생각했었는데, 이제 일을 하고 위험을 감수할 때 어떤 일이 벌어질 수 있는지 보았으니까, 제 시각이 완전히 바뀌었어요!\n\n진짜, 큰 교훈으로 가득찬 여행이었고, 몇 가지 실수가 있었으며, 독특한 경험들이 가득한 여행이었답니다.\n\n<div class=\"content-ad\"></div>\n\n# 모든 것이 시작된 방법\n\n2019년 말, opengraph.xyz 도메인을 사용할 수 있다는 것을 알게 된 것이 모든 것이 시작되었어요.\n\n당시에 Hey Meta와 Meta Tags는 소셜 미디어 미리보기를 확인하는 데 가장 유용한 도구였어요. 정확일치 도메인 접근 방식을 사용하여 오픈 그래프 관련 키워드에서 두 사이트를 모두 앞지를 수 있을지 테스트해보고 싶었어요.\n\nSEO와 SERP에 대해 배우고 싶은 진심이 담긴 이 간단한 프로젝트가 수익을 창출할 수 있는 부수적인 프로젝트로 변할 줄 전혀 예상하지 못했어요.\n\n<div class=\"content-ad\"></div>\n\n참고: 만약 SEO에 관심이 있다면, 최신 트렌드에 대해 더 알아보기 위해 Search Engine Journal을 확인하는 것을 잊지 마세요. 또한 내 Google Search Console을 강화하는 이 2가지 도구에 대해서도 알아보세요.\n\n# 중요한 성취\n\n작성 시점에서 약 44,000명의 매월 유일한 방문자와 120,000개 이상의 매월 페이지뷰가 있습니다.\n\n저는 사이트를 위해 어떠한 마케팅도 하지 않았습니다. 단지 좋은 UI/UX에 집중하고 자연스럽게 퍼지게 뒀을 뿐이에요.\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-20-MyJourneyofBuildingandSellingopengraphxyzfor20000_1.png)\n\n이 사이트에서는 일반적인 Google Analytics 대신 더 나은 사용자 경험을 제공해주는 쿠키 동의 배너나 더 빠른 페이지 로드 없이 동작하는 Simple Analytics를 사용하고 있어요.\n\n다음과 같은 키워드로 1위를 차지하고 있어요:\n- open graph checker\n- open graph test\n- open graph tester\n- og checker\n- og image checker\n- open graph preview\n\n<div class=\"content-ad\"></div>\n\n![Image](/assets/img/2024-06-20-MyJourneyofBuildingandSellingopengraphxyzfor20000_2.png)\n\n이런 건강한 트래픽을 통해, BuySellAds를 통해 매달 약 $120~$150의 수 pass받습니다. 또한 스폰서된 광고 슬롯 판매로 얻은 수익도 추가되어 있습니다.\n\n# Opengraph가 유기적으로 성장하는 데 도움이 된 것은 무엇인가요?\n만약 소셜 미디어에서 큰 팔로워를 가진 큰 온라인 존재감이 없다면, 프로젝트에 대한 관심과 피드백을 얻는 일은 어려울 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n직접 설정한 몇 가지 툴이 초기에 중요한 역할을 한 것 같아.\n\n너도 이런 툴들을 프로젝트에 통합하는 것을 고려해봐.\n\n## 초기 사용자의 피드백을 수집\n\n![이미지](/assets/img/2024-06-20-MyJourneyofBuildingandSellingopengraphxyzfor20000_3.png)\n\n<div class=\"content-ad\"></div>\n\n행운으로 Feedback Fish를 발견했어요. 2줄의 코드로 앱에 통합할 수 있는 멋진 피드백 위젯이에요.\n\nFeedback Fish를 사용하면 사용자들이 쉽게 이슈, 아이디어 또는 칭찬을 제출할 수 있어요. 무료 플랜으로 매달 최대 25개의 제출을 받을 수 있어요.\n\n이 앱의 초기 사용자들이 제출한 아이디어 중 일부는 LinkedIn 및 Discord 미리보기를 추가하는 것이에요.\n\n다른 사용자들은 사이트에서 아이콘이 어둡게 나타나는 문제나 URL 형식의 중대한 문제와 같은 버그를 보고해주었어요.\n\n<div class=\"content-ad\"></div>\n\n총 12개의 제출된 아이디어와 39개의 피드백 피시 이슈를 발견했어요.\n\n참고: 일부 제출은 순전히 노이즈일 수 있습니다; 판단에 유의하세요!\n\n## 소셜 증명 표시\n\n제이몬과 그의 추천 서비스 앱에 대해 큰 팬입니다. 유저들로부터의 추천을 사이트에 표시하지 않는 것은 큰 손실이며, 추천은 그것을 쉽게할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n결과 페이지에서 웹사이트를 나가기 전에 사용자들로부터 평가를 수집하기 위해 팝업 모달을 발생시켰어요. 이를 사용하고 마음에 드는 내용을 보면 더 많은 평가를 남길 가능성이 높아지죠.\n\n그 후 특정 기간 동안 제공된 임베드 코드를 사용하여 이러한 평가를 홈페이지의 '사랑의 벽'에 표시했어요.\n\n총 37개의 텍스트 평가를 받았습니다.\n\n<div class=\"content-ad\"></div>\n\n# 얼마의 가치가 있을까요?\n\n$0의 월 반복 매출(MRR)이 있을 때 사이드 프로젝트의 가치를 정하는 것은 어렵습니다. 그래도 사이트에 얼마나 많은 트래픽이 유입되든 말이죠.\n\n저는 가끔 Opengraph를 매각하기 위한 제안을 받았습니다. 하지만 대부분의 구매자들은 제 사이트가 가진 트래픽 양이나 순위를 올린 키워드보다는 월 반복 매출(MRR)에 너무 많은 초점을 맞추었습니다.\n\n그래서 그들은 트래픽을 효율적으로 활용하는 것에 대한 위험을 최소화하기 위해 낮은 가격을 제시했습니다.\n\n<div class=\"content-ad\"></div>\n\n3 주 전에 빠르게 진행되어서 링크드인에서 간단한 DM을 받았어요. \"오픈그래프를 구매해도 괜찮을까?\" 라는 질문을 받은 것이죠. Bob이었는데, 그는 20,000 달러를 제안했어요.\n\n거래는 1.5 주만에 성사되었어요.\n\n# 판매 결정\n\n핵심 질문은: 왜 내가 사랑하는 프로젝트를 판매하기로 결정했을까요?\n\n<div class=\"content-ad\"></div>\n\n## 열정 부족\n\n사이트에서 할 수 있는 일들에 대한 버킷 리스트가 있지만, 많은 양의 트래픽을 가지고 있다는 점에서 항상 미루고 있습니다. 다른 프로젝트에 시간을 보내는 것이 더 나은 것 같아요.\n\n## 적절한 바이어를 만나다\n\n바이어인 밥은 소통에 있어 명확하고 간결했습니다. 제게는 처음으로 제 시간을 존중하고 여기서 노력한 것들을 가치 있게 여기는 공정한 제안을 받아본 것입니다!\n\n<div class=\"content-ad\"></div>\n\n가장 두드러진 것은, Bob이 Opengraph.xyz를 위한 훌륭한 로드맵을 보유하고 있으며, 이 겸손한 프로젝트의 성장을 무척 기대하고 있습니다.\n\n## 가치 있는 경험\n\n나는 기업가에게 꼭 필요한 소중한 기술인 판매 프로세스에 대한 직접적인 경험을 쌓고 싶었습니다. Bob은 이를 진행하며 우리가 신속히 움직이고, 한 주 안에 거래를 완료할 수 있도록 미리 프로세스를 안내해 주었습니다!\n\n# 어떻게 진행되었는지\n\n<div class=\"content-ad\"></div>\n\n판매 과정은 놀랍도록 간단합니다. 초기 서류 작업이 완료되면, 에스크로에서 정의한 절차에 따라 진행되었습니다.\n\n## 서류 작업\n\nBob은 DocuSign을 통해 모든 자산과 비경쟁 계약이 포함된 판매 계약을 작성했습니다.\n\n판매 계약을 받는 것이 처음이라서요. 목록을 꼼꼼히 살펴보고 세부 사항을 확인하는 시간을 가지세요.\n\n<div class=\"content-ad\"></div>\n\n저는 영업 계약에 익숙하지 않아 PDF.ai를 이용하여 계약을 요약, 설명하고 계약의 주요 사항을 강조했습니다.\n\n## 결제\n\n결제는 에스크로를 통해 처리되고 있습니다. 자금이 확보되면 자산 및 계정을 이체하기 시작했습니다.\n\n## 계정 소유권 이전\n\n<div class=\"content-ad\"></div>\n\nOpengraph.xyz에서 자원 페이지에 Airtable, 이미지 호스팅에 Cloudinary, FAQs에 Prismic와 같은 몇 가지 타사 서비스를 사용했어요.\n\nCloudinary 계정 간에 이미지를 전송하는 쉬운 방법이 없어서 코드를 조정해서 이미지를 Airtable로 옮겼어요.\n\n도메인과 소스 코드를 포함해 모든 것이 이전되면, 자산을 검토할 시간을 주었어요. 자산이 검토를 마치면 자금이 출시되길 기다리기만 해요.\n\n# 배운 교훈과 실수들\n\n<div class=\"content-ad\"></div>\n\n사이드 프로젝트를 만들고 판매하는 것은 쉬운 일이 아니에요. 그리고 각각의 단계마다 소중한 교훈을 얻게 되었어요.\n\n## 1. 조직을 잘 유지하세요\n\n처음으로 프로젝트를 시작할 때 판매를 고려하지 않았기 때문에 코드, 문서 및 자원을 잘 정리하지 못했어요. 이로 인해 불필요한 서비스를 사용하면서 판매 과정에서 불필요한 머리 아픔을 겪게 되었죠.\n\n## 2. 제품을 충분히 마케팅하세요\n\n<div class=\"content-ad\"></div>\n\n나의 사이드 프로젝트를 시작할 때부터 SEO에 크게 의존했는데, 그것만으로 충분할 거라고 생각했어요.\n\n결과적으로 프로젝트를 위한 적극적인 마케팅 노력을 소홀히 했죠.\n\n최근에 구글 서치 콘솔에서 캡처된 데이터를 분석하는 Guilherme의 SEO Gets를 발견했어요. 이 도구를 사용하면 구글 서치 콘솔에서 키워드와 콘텐츠 그룹화를 추적할 수 있어요.\n\n## 3. 자신의 가치를 알아라\n\n<div class=\"content-ad\"></div>\n\n초창기에는 월 반복 매출(MRR)이 부족하여 사이트의 가치가 낮게 평가되었습니다. 시간이 지남에 따라 광고 및 후원 포스트로부터 수익을 예상할 수 있게 되어, 가치 평가에 도움이 되었습니다.\n\n# 다음은 무엇인가요\n\n이 여정은 제 첫 여정이었지만, 마지막은 아니겠죠. 프로젝트를 개발하고 판매하는 것이 거창하게 느껴질 수 있지만, 보상은 위험을 크게 초월합니다.\n\n매 단계는 개발자로서 그리고 기업가로서 배우고 성장할 기회를 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n만약 사이드 프로젝트를 판매할지 망설이고 있다면, 내 경험들이 당신에게 자신감을 심어주기를 바라요.\n\n더 궁금한 점이 있으면 트위터에서 연락해 주시거나 제 글들을 확인해 보세요.\n\n행복한 개발과 판매 되세요!","ogImage":{"url":"/assets/img/2024-06-20-MyJourneyofBuildingandSellingopengraphxyzfor20000_0.png"},"coverImage":"/assets/img/2024-06-20-MyJourneyofBuildingandSellingopengraphxyzfor20000_0.png","tag":["Tech"],"readingTime":6},{"title":"날짜 조작하기 Dayjs로 날짜에 상대적인 시간 가져오기","description":"","date":"2024-06-20 14:06","slug":"2024-06-20-ManipulatingDateswithDayjsGettheTimeRelativetoaDate","content":"\n\n\n![Day.js로 날짜 조작하기](/assets/img/2024-06-20-ManipulatingDateswithDayjsGettheTimeRelativetoaDate_0.png)\n\nDay.js는 앱에서 날짜를 조작할 수 있게 해주는 JavaScript 라이브러리입니다.\n\n이 글에서는 JavaScript 앱에서 Day.js를 사용하여 날짜를 조작하는 방법을 살펴보겠습니다.\n\n# 현재까지의 시간 구하기\n\n\n<div class=\"content-ad\"></div>\n\n상대시간 플러그인과 함께 사용할 수 있는 toNow 메서드를 사용하여 현재까지의 상대 시간 문자열을 얻을 수 있습니다.\n\n예를 들어 다음과 같이 작성할 수 있습니다:\n\n```js\nconst dayjs = require(\"dayjs\");\nconst relativeTime = require(\"dayjs/plugin/relativeTime\");\ndayjs.extend(relativeTime);\nconst result = dayjs(\"1999-01-01\").toNow();\nconsole.log(result);\n```\n\n1999년 1월 1일부터 현재까지 얼마나 시간이 지났는지 확인할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n따라서, 2021년에 '23년 후'라는 결과가 나옵니다.\n\n또한, toNow에 true를 전달하여 접미사를 제거할 수 있습니다.\n\n그리고 결과로 `23년`을 얻을 수 있습니다.\n\n# 주어진 시간까지 남은 시간 가져오기\n\n<div class=\"content-ad\"></div>\n\n\"relativeTime\" 플러그인을 사용할 수 있는 \"to\" 메서드로 현재로부터 상대적인 시간의 문자열을 얻을 수 있습니다.\n\n예를 들어, 다음과 같이 작성할 수 있습니다:\n\n```js\nconst dayjs = require(\"dayjs\");\nconst relativeTime = require(\"dayjs/plugin/relativeTime\");\ndayjs.extend(relativeTime);\nconst a = dayjs(\"2020-01-01\");\nconst result = dayjs(\"1999-01-01\").to(a);\nconsole.log(result);\n```\n\n1999년 1월 1일부터 2020년 1월 1일까지 얼마나 오랜 시간이 걸렸는지 확인할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n그러므로 결과는 `in 21 years‘입니다.\n\n또한 두 번째 인수로 true를 전달하여 접미사를 제거할 수 있습니다.\n\n결과로는 `21 years`를 얻을 수 있습니다.\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\nDay.js는 우리 앱에서 날짜를 조작할 수 있게 해주는 JavaScript 라이브러리입니다.\n\n# 쉽게 이해하기 🚀\n\nIn Plain English 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 작성자를 클랩하고 팔로우하세요 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼에서도 만나보세요: CoFeed | Differ\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요.","ogImage":{"url":"/assets/img/2024-06-20-ManipulatingDateswithDayjsGettheTimeRelativetoaDate_0.png"},"coverImage":"/assets/img/2024-06-20-ManipulatingDateswithDayjsGettheTimeRelativetoaDate_0.png","tag":["Tech"],"readingTime":2}],"page":"15","totalPageCount":24,"totalPageGroupCount":2,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}