{"pageProps":{"posts":[{"title":"MySQL 트랜잭션 처리 내부 작동 방식 이해하기","description":"","date":"2024-06-22 04:29","slug":"2024-06-22-DecipheringtheInnerWorkingsofTransactionProcessinginMySQL","content":"\n\nMySQL의 트랜잭션 메커니즘에 대해 깊이 있게 탐구해 보세요. 여기서는 트랜잭션 처리의 전반적인 탐구를 통해 효율적이고 안전한 데이터 관리를 이끄는 기본 원칙을 알아봅니다.\n\n![이미지](/assets/img/2024-06-22-DecipheringtheInnerWorkingsofTransactionProcessinginMySQL_0.png)\n\nMySQL의 강력한 트랜잭션 지원을 탐구하면서, 동시성 안전성 이슈에 대해 복잡하게 살펴보게 됩니다. 동시에 동일한 데이터를 수정하려는 동시 트랜잭션들이 가져다주는 도전에 대처하기 위한 해결책을 MySQL가 선도적인 디자인을 통해 제공합니다.\n\nMySQL는 데이터 불일치를 방지하고 무결성을 유지하기 위한 솔루션을 제공하여 데이터 일관성을 유지하는 논리적인 방법을 보장합니다.\n\n<div class=\"content-ad\"></div>\n\nMySQL은 Multi-Version Concurrency Control(MVCC) 시스템, 트랜잭션 격리 메커니즘 및 잠금 메커니즘을 통해 트랜잭션 동시성을 효과적으로 처리하는 등의 과제에 대응합니다.\n\n그 말인즉, 데이터베이스에서 동시 트랜잭션이 통제되지 않고 관리되지 않는다면 잠재적인 결과를 고려해 보신 적이 있나요?\n\nDirty data.\n\nDirty data에 관련된 구체적인 개념은 dirty write, dirty read, non-repeatable read, phantom read로, 이들 개념의 의미에 대해 자세히 살펴봅시다.\n\n<div class=\"content-ad\"></div>\n\n# 1. Dirty write.\n\nDirty write은 이미 커밋된 데이터를 수정하는 한 트랜잭션이 있고, 그 수정 사항이 후속 트랜잭션이 롤백하는 상황을 가리킵니다.\n\n먼저 개념을 확인해봅시다: 두 트랜잭션 A와 B가 있다고 가정해보겠습니다. 트랜잭션 A가 먼저 시작되고 id가 1인 레코드를 수정하여 이름을 A로 변경합니다(원래 null이었다고 가정). 하지만 이 시점에서 트랜잭션 A는 아직 커밋되지 않은 상태입니다.\n\n이제 트랜잭션 B가 시작됩니다.\n\n<div class=\"content-ad\"></div>\n\nTransaction B는 레코드 ID 1의 이름을 B로 변경하고 해당 트랜잭션을 커밋했습니다. 그러나 이 시점에서 트랜잭션 A는 수정을 진행하지 않기로 결정하고 롤백하여 자체 변경 사항을 되돌립니다.\n\n결과적으로, 레코드 ID 1은 이름에 대한 null 값을 유지하게 됩니다.\n\n이후 트랜잭션 B가 이 레코드를 조회하여 이름 값이 null임을 발견하면, 이는 트랜잭션 B가 수행한 수정 사항이 트랜잭션 A에 의해 롤백되는 경우로, 더러운 쓰기로 간주됩니다.\n\n![이미지](/assets/img/2024-06-22-DecipheringtheInnerWorkingsofTransactionProcessinginMySQL_1.png)\n\n<div class=\"content-ad\"></div>\n\nMySQL은 락(lock)을 사용하여 dirty writes 문제에 대처합니다. MySQL에서 트랜잭션이 시작되면 특정 레코드에 바인딩됩니다.\n\n이 메커니즘은 Java Virtual Machine (JVM)에서의 락과 다소 유사합니다. 이 맥락에서, 트랜잭션 A가 시작되고 특정 레코드와 연관시킨다면, 트랜잭션 B가 동일한 레코드에 작업을 시도하면 대기해야 합니다.\n\n트랜잭션 A가 실행을 완료하면, 대기 중인 트랜잭션들에게 알리고, 대기 중인 다음 트랜잭션이 작업을 계속할 수 있도록 허용합니다.\n\n이러한 작업들이 직렬화된 실행을 유발하여 데이터베이스가 느리게 처리될 것이 걱정될 수 있습니다. 그러나 실제로는 이러한 작업들이 메모리 내에서, 구체적으로는 버퍼 풀(Buffer Pool) 내에서 처리됩니다. 결과적으로, 이러한 작업의 속도는 매우 빠릅니다.\n\n<div class=\"content-ad\"></div>\n\n# 2. Dirty read.\n\nDirty read(더티 리드)는 한 트랜잭션이 다른 트랜잭션이 수정했지만 아직 커밋하지 않은 레코드를 읽는 상황을 가리킵니다.\n\n두 개의 트랜잭션, A와 B를 전제로 계속해 보겠습니다. 먼저 트랜잭션 A가 시작되어 id가 1인 레코드의 이름을 A로 변경했지만 아직 커밋하지 않은 상태입니다.\n\n이 시점에서 트랜잭션 B가 시작됩니다. 트랜잭션 B는 쿼리를 실행하고 이름의 현재 값을 A로 찾습니다. 이후에는 해당 값을 A로 가정하고 로직을 진행합니다. 그러나 트랜잭션 A가 롤백되고 나서 트랜잭션 B가 다시 쿼리하면 레코드의 값이 A가 아닌 것을 발견합니다. 이 시나리오는 더티 리드를 잘 보여주는 예시입니다.\n\n<div class=\"content-ad\"></div>\n\n\n![transaction_processing](/assets/img/2024-06-22-DecipheringtheInnerWorkingsofTransactionProcessinginMySQL_2.png)\n\n# 3. Non-repeatable read.\n\nNon-repeatable read refers to a situation where reading the same record at different points in time yields different results.\n\nConsider three transactions, T1, T2, and T3.\n\n\n<div class=\"content-ad\"></div>\n\nT1 트랜잭션이 시작되지만 어떠한 작업도 수행하지 않습니다. T2 트랜잭션이 시작되고 id가 1인 레코드의 이름을 B로 변경한 뒤 트랜잭션을 커밋합니다.\n\n이 시점에서 T1 트랜잭션이 활성화되어 레코드를 쿼리하여 이름 값이 B로 확인되지만 어떠한 작업도 실행하지 않습니다.\n\n이후 T3 트랜잭션이 시작됩니다.\n\nT3은 id가 1인 레코드의 이름을 C로 수정하고 트랜잭션을 커밋합니다. 이후 T1 트랜잭션이 실행을 재개하면서 다시 레코드를 쿼리하면 이름 값이 이제 C로 나타납니다. 이는 반복되지 않는 읽기를 보여줍니다.\n\n<div class=\"content-ad\"></div>\n\n아래는 이미지를 표시하는 링크입니다.\n\n# 4. Phantom read.\n\n팬텀 리드는 반복 불가능한 리드와 어느 정도 유사하지만, 반복 불가능한 리드는 데이터 값의 차이를 강조하는 것과 달리, 팬텀 리드는 데이터 레코드의 숫자의 변화에 중점을 두어 추가나 삭제와 같은 변화를 강조합니다. 데이터 집합에서 환상이나 \"유령\"을 보는 것과 유사합니다.\n\n<div class=\"content-ad\"></div>\n\n두 개의 트랜잭션, T1과 T2를 고려해봅시다. 트랜잭션 T1이 시작되고 SQL 쿼리를 실행합니다: select * from user, 현재 결과가 5개의 행이라고 가정합니다. 이 시점에서 트랜잭션 T2가 시작되어 사용자 테이블에 레코드를 삽입하고 트랜잭션을 커밋합니다.\n\n그 후에 트랜잭션 T1이 다른 select * from user 쿼리를 실행하여 실행을 계속하면 결과가 이제 6개의 행으로 구성되어 있는 것을 발견합니다. 이는 그림 속에 있는 것과 같이 '유령 읽기'라고 알려진 것을 보여줍니다.\n\n아래는 현대 데이터베이스에서 일반적으로 발생하는 네 가지 문제이며, 이러한 문제는 서로 다른 트랜잭션 격리 수준에서 발생할 수 있습니다. 그래서 다음에 분석할 주제는 트랜잭션의 격리 수준입니다.\n\n![이미지](/assets/img/2024-06-22-DecipheringtheInnerWorkingsofTransactionProcessinginMySQL_4.png)\n\n<div class=\"content-ad\"></div>\n\n다중 버전 동시성 제어(MVCC) 메커니즘.\n\n트랜잭션 격리 수준은 다음 네 가지 유형으로 분류됩니다:\n\n- 읽지 않은 커밋.\n- 커밋된 읽기.\n- 반복 가능한 읽기.\n- 직렬화된 읽기.\n\nMVCC는 데이터베이스 관리 시스템에서 일반적으로 구현된 동시성 제어 방법입니다. 이는 데이터베이스에 대한 동시 액세스를 용이하게 하고 명시적 트랜잭션 격리의 중요한 측면으로 기능합니다.\n\n<div class=\"content-ad\"></div>\n\n이 시점에서 새로운 개념을 소개합니다: 데이터가 디스크에 저장될 때, 각 레코드는 트랜잭션 ID와 롤백 포인터와 함께 저장됩니다.\n\n![이미지](/assets/img/2024-06-22-DecipheringtheInnerWorkingsofTransactionProcessinginMySQL_5.png)\n\n- 트랜잭션 ID: 각 트랜잭션에 대한 고유 식별자입니다.\n- 롤백 포인터: 현재 트랜잭션 이전 버전의 레코드에 대한 참조(포인터)로, 현재 타임스탬프에 상대적으로 이전 데이터를 가리키는 용어입니다.\n\n특정 레코드에서 작업을 수행해야 한다고 가정해 봅시다. 먼저 해당 레코드가 버퍼 풀에 로드되어 있어야 하며, 그 레코드에 연관된 되돌리기 로그 레코드가 있어야 합니다.\n\n<div class=\"content-ad\"></div>\n\n아래는 Markdown 형식으로 변경한 내용입니다.\n\n![이미지](/assets/img/2024-06-22-DecipheringtheInnerWorkingsofTransactionProcessinginMySQL_6.png)\n\n거래 T1이 시작되었고 값을 A로 수정했다고 가정해 봅시다.\n\n![이미지](/assets/img/2024-06-22-DecipheringtheInnerWorkingsofTransactionProcessinginMySQL_7.png)\n\n거래 T1이 아직 진행 중인 동안 거래 T2가 시작되어 값을 B로 수정합니다.\n\n<div class=\"content-ad\"></div>\n\n![2024-06-22-DecipheringtheInnerWorkingsofTransactionProcessinginMySQL_8.png](/assets/img/2024-06-22-DecipheringtheInnerWorkingsofTransactionProcessinginMySQL_8.png)\n\n이 시점에서 트랜잭션 T1 및 T2는 아직 진행 중입니다. 트랜잭션 T3가 시작되어 값을 C로 수정합니다.\n\n![2024-06-22-DecipheringtheInnerWorkingsofTransactionProcessinginMySQL_9.png](/assets/img/2024-06-22-DecipheringtheInnerWorkingsofTransactionProcessinginMySQL_9.png)\n\n위 다이어그램은 MVCC 버전 제어 체인이라는 특정 용어를 소개합니다. 또한 ReadView라는 새 용어가 포함됩니다.\n\n<div class=\"content-ad\"></div>\n\n각 트랜잭션은 시작될 때마다 ReadView가 생성됩니다.\n\n이제 ReadView에 대해 자세한 설명과 분석을 진행하겠습니다.\n\nReadView.\n\n각 트랜잭션이 시작될 때마다 ReadView가 생성됩니다. 그 목적은 각 트랜잭션 내의 작업과 관련된 특정 Undo Log 항목을 기록하는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n여러 필드가 관련됩니다: m_ids, min_trx_id, max_trx_id 및 creator_trx_id입니다. 이들의 구체적인 의미는 다음과 같습니다:\n\n- m_ids: 활성 트랜잭션의 ID를 기록하는데 사용됩니다.\n- min_trx_id: 현재 활성 트랜잭션 중 가장 작은 트랜잭션 ID입니다.\n- max_trx_id: 생성될 다음 트랜잭션 ID입니다. 현재 m_ids에 없는 ID여야 합니다. (트랜잭션 ID는 오름차순으로 생성됩니다.)\n- creator_trx_id: 현재 활성 트랜잭션의 ID입니다.\n\n현재 저장된 레코드가 다음과 같이 있습니다:\n\n![이미지](/assets/img/2024-06-22-DecipheringtheInnerWorkingsofTransactionProcessinginMySQL_10.png)\n\n<div class=\"content-ad\"></div>\n\n지금쯤에는 이미 명확히 이 레코드가 이전 트랜잭션에서의 수정 결과임을 알고 계실 것입니다.\n\n이제 우리는 T4, T5 및 T6이 순차적으로 열렸다고 가정해 봅시다.\n\n우리는 트랜잭션 T4부터 시작해 봅시다. 이 시점에서 m_ids는 [T4, T5, T6]이고, min_trx_id는 T4, max_trx_id는 T7, 그리고 creator_trx_id는 T4입니다.\n\n![이미지](/assets/img/2024-06-22-DecipheringtheInnerWorkingsofTransactionProcessinginMySQL_11.png)\n\n<div class=\"content-ad\"></div>\n\nT4 트랜잭션이 쿼리 작업을 시작합니다. 아래는 실행 방법입니다: \n\n첫째로, MVCC 버전 제어 체인을 따라 내려가면서 이 레코드의 이전 작업에 대한 트랜잭션 ID를 검색합니다.\n\n해당 언도로그 항목과 연관된 트랜잭션 ID가 T3임을 발견합니다. 이 ID는 T4의 자체 트랜잭션 ID보다 작은 것으로 나타납니다.\n\n따라서 이 레코드가 T4 트랜잭션에 의해 수정되지 않았음이 확인됩니다.\n\n<div class=\"content-ad\"></div>\n\n또한 m_ids의 거래 ID가 T4, T5, T6이며 T3가 모든 것보다 작기 때문에, 현재 거래가 시작되기 전에 발견된 레코드가 있었다는 것을 유추할 수 있습니다.\n\n따라서 거래 T4는 값 C를 검색합니다.\n\n이 시점에서 거래 T5도이 레코드를 쿼리하기 시작합니다. 거래 T5는 데이터를 쿼리하는 동일한 절차를 따를 것이며, 결과는 C입니다. 위에서 거래 T4의 분석을 고려하면 간단해 보입니다.\n\n거래 T5가 값을 B로 변경하면 무엇이 발생합니까?\n\n<div class=\"content-ad\"></div>\n\n![Table](/assets/img/2024-06-22-DecipheringtheInnerWorkingsofTransactionProcessinginMySQL_12.png)\n\n이 시점에서 트랜잭션 T4가 다시 활성화되어 다른 쿼리 작업을 실행합니다. 결과는 무엇이어아아할까요?\n\n먼저, 트랜잭션 T4는 이 레코드의 MVCC 버전 제어 체인을 아래로 따라가다가 ID가 T5인 트랜잭션을 만납니다.\n\nM_ids의 최소 트랜잭션 ID보다 T5의 트랜잭션 ID가 더 크기 때문에 T5 트랜잭션이 현재 활성 상태임을 확인할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n그래서 트랜잭션 T4는 T5와 관련된 undo 로그에서 값을 검색하지 않습니다.\n\n이어서 검색을 계속하면, 트랜잭션 ID가 T3인 undo 로그 레코드를 찾습니다. 비교해보니, T3가 m_ids에 없으며 m_ids의 최소 트랜잭션 ID보다 작은 것을 확인합니다.\n\n마지막으로, 초기 쿼리 결정 프로세스를 반복합니다.\n\n이 순간에 트랜잭션 T4가이 레코드의 값을 A로 변경한다고 가정해봅시다. 그런 다음, 트랜잭션 T4가이 레코드를 다시 쿼리합니다.\n\n<div class=\"content-ad\"></div>\n\n결과는 무엇이 될까요?\n\n![이미지](/assets/img/2024-06-22-DecipheringtheInnerWorkingsofTransactionProcessinginMySQL_13.png)\n\n트랜잭션 T4가 쿼리를 시작하고 이 시점에서 롤백 로그의 첫 번째 항목의 트랜잭션 ID가 T4임을 발견합니다. 비교해보니 자신의 트랜잭션 ID라는 것을 깨달았습니다. 따라서 쿼리 결과는 A입니다.\n\n이 시점에서 트랜잭션 T5가 쿼리를 한다면 어떻게 될까요?\n\n<div class=\"content-ad\"></div>\n\n먼저, T5는 최신 트랜잭션 ID가 m_ids에 있는 T4임을 알아차립니다. 이것은 현재 진행 중인 트랜잭션으로서 자신의 트랜잭션 ID와 다르다는 것을 추론할 수 있습니다.\n\n그러므로 T5는 이 값을 가져오지 않을 것입니다.\n\n그런 다음, T5는 undo 로그 체인을 따라 거슬러 올라가 T5 트랜잭션 ID가 있는 레코드를 찾아 자신의 트랜잭션이라는 것을 깨달습니다.\n\n따라서, T5에 대한 쿼리 결과는 B입니다.\n\n<div class=\"content-ad\"></div>\n\n실제로, 거래의 기본 메커니즘은 ReadView 개념을 기반으로 설계되었습니다. 거래의 기본 원칙에 대해 알아볼 때 Read Commit (RC)와 Repeatable Read (RR)를 사용하여 분석해 보겠습니다.\n\nRead Commit.\n\nRead Commit은 거래 격리 수준 중 하나로, 커밋된 레코드를 읽는 것을 의미합니다. 예를 들어, 거래 A와 거래 B가 모두 활동 중인 경우, 거래 B에 의해 커밋된 레코드를 거래 A가 읽을 수 있습니다.\n\n차근차근 분석해 봅시다. 먼저, Read Commit 격리 수준 아래에서 각 쿼리 작업은 새로운 ReadView를 생성한다는 점을 이해하는 것이 중요합니다. 이것이 Read Commit의 핵심 아이디어입니다.\n\n<div class=\"content-ad\"></div>\n\n거래 ID가 각각 T1과 T2인 거래 T1과 T2가 있다고 가정해봅시다.\n\n거래 T1은 아직 활성화되지 않았지만, 거래 T2는 커밋하기 전에 특정 레코드의 값을 B로 변경합니다 (원래 값은 X로 가정).\n\n지금은 다음 다이어그램으로 시나리오를 시각화할 수 있습니다:\n\n![다이어그램](/assets/img/2024-06-22-DecipheringtheInnerWorkingsofTransactionProcessinginMySQL_14.png)\n\n<div class=\"content-ad\"></div>\n\n이 시점에서 트랜잭션 T1이 활성화되어 쿼리 작업을 시작합니다.\n\n위의 분석을 따라 데이터베이스는 다음 속성 값으로 새로운 ReadView를 생성합니다:\n\n- m_ids: [T1, T2].\n- min_trx_id: T1.\n- max_trx_id: T3.\n- creator_trx_id: T1.\n\n다음으로, 이 프로세스는 이전에 논의된 것과 유사합니다.\n\n<div class=\"content-ad\"></div>\n\n우선 T1은 가장 최근의 트랜잭션 ID인 T2를 조회합니다.\n\nT2가 m_ids에 있는데 자체 트랜잭션 ID와 일치하지 않음을 발견합니다.\n\n그래서 undo 로그 체인을 따라 계속 검색합니다.\n\n그런 다음 트랜잭션 ID Tx를 가진 레코드를 발견하고, Tx가 m_ids에 없으며, 최소 트랜잭션 ID(T1)보다 작음을 알아차립니다.\n\n<div class=\"content-ad\"></div>\n\n따라서, 거래 ID Tx를 가진 레코드가 원래 있었음을 결론 지을 수 있으며, 쿼리 결과는 X입니다.\n\n그다음, 거래 T2가 다시 활성화되어 거래를 커밋하고, 그런 다음 거래 T1이 다른 쿼리 작업을 시작합니다.\n\n이제 이 시점에서 Read Commit (RC)의 핵심이 분명해집니다: 데이터베이스는 거래 T1을 위해 새로운 ReadView를 생성하며, 그 네 가지 속성에 대한 다음 값이 있습니다.\n\n- m_ids: [T1].\n- min_trx_id: T1.\n- max_trx_id: T3.\n- creator_trx_id: T1.\n\n<div class=\"content-ad\"></div>\n\n위에 있는 표 태그를 Markdown 형식으로 변경해주세요.\n\n<div class=\"content-ad\"></div>\n\nRepeatable Read (RR)의 핵심 아이디어는 ReadView가 생성된 후 트랜잭션이 커밋될 때까지 다시 생성되지 않는다는 것입니다.\n\n우선, 트랜잭션 ID가 각각 T1과 T2인 T1과 T2 트랜잭션을 고려해 보겠습니다. 트랜잭션 T2는 값이 B로 수정되고(원래 값은 X였다고 가정), 그 후에 트랜잭션 T1은 쿼리 작업을 시작합니다:\n\n![이미지](/assets/img/2024-06-22-DecipheringtheInnerWorkingsofTransactionProcessinginMySQL_15.png)\n\n쿼리 프로세스는 이전과 정확히 동일합니다. 여기서 다시 자세히 설명하지는 않겠습니다.\n\n<div class=\"content-ad\"></div>\n\n다음으로, 트랜잭션 T2가 다시 활성화되어 트랜잭션을 커밋하고, 그 후에 트랜잭션 T1이 또 다른 쿼리를 시작합니다.\n\n이제 기적이 일어나는데, 방금 언급한 대로 ReadView는 트랜잭션이 커밋될 때까지 다시 생성되지 않습니다.\n\n트랜잭션 T1이 ReadView를 생성할 때 m_ids로 T1과 T2를 가지고 있었기 때문에 이제도 같은 값을 가지고 있습니다.\n\n쿼리는 다음과 같이 진행됩니다: 트랜잭션 T1은 초기에 T2의 트랜잭션 ID를 가진 레코드를 만납니다.\n\n<div class=\"content-ad\"></div>\n\nT2가 m_ids에 있기 때문에 해당 값을 가져오지 않고 검색을 계속할 것입니다.\n\n거래 ID Tx를 가진 레코드를 찾았을 때 Tx가 m_ids에 없다고 판단하면 쿼리 결과는 X가 됩니다.\n\n이제 왜 이 독립성 수준 아래의 거래가 서로 간섭하지 않는지 이해하셨죠? 이것이 그 원리입니다.\n\n<div class=\"content-ad\"></div>\n\n그런 이야기를 좋아한다면 저를 지원하고 싶으시면 박수를 부탁드립니다.\n\n여러분의 지원은 저에게 매우 중요합니다. 감사합니다.","ogImage":{"url":"/assets/img/2024-06-22-DecipheringtheInnerWorkingsofTransactionProcessinginMySQL_0.png"},"coverImage":"/assets/img/2024-06-22-DecipheringtheInnerWorkingsofTransactionProcessinginMySQL_0.png","tag":["Tech"],"readingTime":11},{"title":"HerTechTrail 여정 기술 입문 여성들을 위한 완벽 가이드","description":"","date":"2024-06-22 04:26","slug":"2024-06-22-HerTechTrailJourney","content":"\n\n프론트엔드 개발자가 되는 길\n\n![her tech trail journey](/assets/img/2024-06-22-HerTechTrailJourney_0.png)\n\n셀프 터득 개발자로서 코딩을 배우면서 겪은 일들은 정말 롤러코스터 같았어요! 상상해보세요. 기술에 흥미 없는 사람이 프론트엔드 개발 세계에 뛰어들어 HTML과 CSS에 씨름하면서 가이드가 필요했던 모습을요. 어려움이 있었고 도중에 멘토나 동료를 만날 수 없어 어려움에 부딪혔죠. 결국 4개월 동안 쉬어야만 했고 절망에 빠지곤 했어요.\n\n그래도, 걱정 마세요. 이런 평범한 애잔한 이야기가 아니에요! 수학을 좋아하지 않지만 포기하지 않고 끈기를 가졌어요. 불을 꺼지 않게 하기 위해 유데미의 유료 강좌를 구매하고 다시 코딩 세계로 돌아가 새로운 동기부여를 가지고 나서게 되었어요. HTML과 CSS 프로젝트를 다시 시작한 것이었는데, 정말 흥미진진한 여행을 했답니다. 함께 이 잊지 못할 여정을 함께할까요?\n\n<div class=\"content-ad\"></div>\n\n# HerTechTrail 아카데미\n\nHerTechTrail 아카데미는 아프리카의 여성을 위한 완전히 가상 학습 플랫폼입니다.\n\n나는 3개월 동안 가상 주간 수업을 통해 HTML, CSS 및 JavaScript에 대해 멘토링을 받게 될 Web Developer Starter 부트캠프에 지원했습니다. 부트캠프에서는 우리에게 교육과 멘토링을 제공할 것입니다. 부트캠프를 끝내면 다양한 미니 프로젝트와 포트폴리오 프로젝트를 준비하게 될 것입니다.\n\n## 무엇을 배웠나요?\n\n<div class=\"content-ad\"></div>\n\n부트캠프에서는 중급 수준의 HTML, CSS 및 Javascript을 다루었습니다.\n\n첫 달에는 HTML 요소, 태그, 속성 및 스타일에 대해 배웠어요. 또한 기본적인 HTML 폼, 미디어 및 비디오 임베드, 그리고 접근성에 대해 다뤘습니다.\n\n첫 달과 대부분의 두 번째 달에는 CSS에 초점을 맞췄어요. 몇 가지 프로젝트를 진행해왔지만 언제나 CSS에 어려움을 겪어왔어요. 라이브 수업에서 멘토로부터 배우는 것이 기분이 좋았고 많은 것을 이해할 수 있었어요. 게다가 부트스트랩과 미디어 쿼리를 사용한 반응형에 대해 배웠습니다.\n\n반응형 웹 디자인(RWD)은 웹 페이지가 모든 화면 크기와 해상도에서 잘 렌더링되어 사용성을 향상시킵니다. 이 웹 개발 측면은 웹 페이지 사용자의 다양한 화면 크기에 맞추어져 중요합니다.\n\n<div class=\"content-ad\"></div>\n\n지난 달에는 JavaScript에 집중했어요. 이것이 제가 처음 접한 프로그래밍 언어였는데, 도전적이었어요. JavaScript를 사용하면 웹 페이지에서 시기적절한 콘텐츠 업데이트, 대화식 지도, 다양한 그래픽 요소 등 복잡한 기능을 구현할 수 있어요.\n\n전반적으로, 수업은 다양한 주제를 다루었고, 배운 기술들은 제 포트폴리오를 만들기에 충분해요.\n\n## 새로 배운 것은 무엇인가요?\n\n세부 수업을 통해 HTML 기술을 향상할 수 있었어요. 다양한 스타일과 태그에 대해 더 잘 이해하고, 웹 페이지에서 적절하게 반응형을 구현하는 방법을 배웠어요.\n\n<div class=\"content-ad\"></div>\n\nCSS에 대해 이야기할 때는 미디어 쿼리를 사용한 반응형 디자인에 집중했어요. 다양한 화면으로 연습하면서 이 측면에서 능숙해졌답니다. 때로는 CSS 스타일링이 어려웠지만, 어려움을 겪을 때 Bootstrap을 활용해 도움을 받아왔어요. Bootstrap은 스타일링의 부담을 덜어주는 많은 기능을 갖춘 가치 있는 도구라고 생각해요.\n\n자바스크립트가 가진 도전에도 불구하고, 이를 배우면서 내 창의적인 면을 발휘할 수 있었어요. 이제는 자주 사용하거나 마주치는 일상 앱의 프로그래밍 흐름에 대해 이야기하게 되었어요. 예를 들어, 슈퍼마켓 계산대가 어떻게 작동하는지 설명하고, 중첩된 루프와 if, else if와 같은 조건문을 결합하여 앱을 만드는 방법에 대해 살펴보았어요.\n\nGit과 버전 관리를 처음 접했을 때는 새로웠지만, 중요성을 즉시 깨달았어요. GitHub를 자주 사용하지만, 버전 관리에 대해 완전히 이해하지 못해 파일을 직접 플랫폼에 업로드해왔죠. Git과 버전 관리 수업은 전체 부트캠프의 정점이었는데, 포트폴리오 프로젝트를 위해 이를 활용해야 했어요.\n\n## 다음 단계는 무엇일까요? 어떻게 더 나은 개발자가 될 수 있을까요?\n\n<div class=\"content-ad\"></div>\n\n연습! 연습!! 연습!! 연습하면 나는 더 나아질 수 있어요. 저는 주니어 레벨 프론트엔드 개발자로 성장했고, 일관된 연습과 웹 앱 구축으로만 더 나아질 수 있어요.\n\n올해 두 번째 반기에는 내 기술을 숙달하고 반응형 웹 앱을 만들기 위해 시간을 보낼 계획이에요.\n\n더불어 React.js를 배워 인턴십에 지원할 예정이에요.\n\n## 15 Days of Code\n\n<div class=\"content-ad\"></div>\n\nHerTechTrail Academy의 이 프로젝트는 수업에서 배운 내용을 연습하는 뛰어난 방법이었어요. 15일 동안 다양한 웹 앱을 구축, 스타일링, 배포하는 것은 정말 도전적이었죠. 저는 그 당시 JavaScript를 잘 몰라서 스타터 트랙을 선택했어요. 이 경로는 제 HTML과 CSS 스킬을 크게 시험했고, 저는 다음과 같은 웹 페이지를 만들었어요:\n\n1일~5일: HTML과 CSS를 사용하여 정적 페이지를 만들었어요. HerTechTrail Academy의 가입 페이지를 디자인하고 스타일링하여 반응성을 구현했죠. 마지막으로 CodePen을 통해 배포했어요.\n\n6일~10일: 사용자 정의 404 페이지를 만들었어요. HTML과 CSS를 사용하여 404 오류 페이지를 디자인하고 스타일링하여 모든 기기에서 완벽한 반응성을 보장했죠. 마지막으로 GitHub Pages에 호스팅했어요.\n\n11일~15일: 간단하고 반응성 있는 랜딩 페이지를 만들었어요. 수염 성장 회사를 위한 랜딩 페이지를 디자인하고 스타일링하여 반응성을 구현하고 GitHub Pages에 호스팅했어요.\n\n<div class=\"content-ad\"></div>\n\n이 도전 과제는 포트폴리오 프로젝트를 준비하는 데 도움이 되었습니다. 스타일링과 반응 형에 대해 더 많이 배웠기 때문에 더 의심스러워지지 않았어요.\n\n## 포트폴리오 프로젝트\n\n홈, 연락처, 소개, 포트폴리오 페이지를 포함한 멀티 페이지 포트폴리오 웹 앱을 작성해야 합니다.\n\n홈 페이지는 나에 대한 요약을 담은 간단한 랜딩 페이지가 될 것입니다. 그 내용에는 내가 사용하는 프로그래밍 언어가 포함됩니다. 다른 페이지로 이동하는 메뉴 바도 포함될 것입니다.\n\n<div class=\"content-ad\"></div>\n\nAbout 페이지는 웹 개발자로서의 여정을 다루며, 주요 이정표를 강조하고 제가 개발한 웹 앱 샘플을 소개할 것입니다.\n\nContact 페이지는 저의 연락처 정보를 표시하고, 이메일로 연락하고자 하는 사람들을 위한 간단한 양식을 포함할 것입니다.\n\nPortfolio 페이지는 내가 참여한 모든 프로젝트를 전시하고, 그것에 대한 외부 링크를 제공할 것입니다.\n\n개발 과정에서 홈페이지의 배경 이미지를 변경하는 것과 같은 어려움을 겪었습니다. 그러나 Pesticide 익스텐션과 Chrome 검사 도구의 도움을 받아 이를 극복했습니다. HTML Pesticide를 활용하여 코드를 디버깅하고 배경 이미지를 올바르게 스타일링했습니다.\n\n<div class=\"content-ad\"></div>\n\n또한, 제 웹 사이트의 모바일 반응성을 테스트하면서 1px의 중요성을 발견하면서 작은 세부 사항에 주의를 기울이는 것이 중요하다는 것을 배웠습니다. 저는 레드미와 삼성 두 안드로이드 기기에서 웹 사이트를 테스트했습니다. 먼저, 삼성 기기에서는 반응성이 있었지만 레드미에서는 그렇지 않았습니다. 미디어 쿼리에 픽셀을 추가한 후, 반응성 문제가 해결되었습니다.\n\n제 포트폴리오 링크는 아래에서 확인할 수 있습니다.\n\n멘토로부터의 조언과 교정, 그리고 HerTechTrail Academy의 소중한 기회와 코치 Magdalene Edozie와 Broma Elenwo의 지원에 감사드립니다.\n\n개발자 여정을 함께하고 싶다면, Linkedin, Twitter, 포트폴리오 및 GitHub에서 저를 팔로우해주세요.","ogImage":{"url":"/assets/img/2024-06-22-HerTechTrailJourney_0.png"},"coverImage":"/assets/img/2024-06-22-HerTechTrailJourney_0.png","tag":["Tech"],"readingTime":5},{"title":"NET C에서 SOLID 원칙 이해하기 코드 예시와 함께하는 실용 가이드","description":"","date":"2024-06-22 04:25","slug":"2024-06-22-UnderstandingSOLIDPrinciplesinNETCAPracticalGuidewithCodeExamples","content":"\n\nSOLID 원칙은 개발자가 쉽게 확장 가능한 코드를 작성하고 일반적인 코딩 오류를 피할 수 있게 도와줍니다.\n\n이 원칙들은 Robert C. Martin에 의해 소개되었으며 객체 지향 프로그래밍의 기본 요소가 되었습니다.\n\n.NET 개발에서 SOLID 원칙을 준수하면 코드가 더 모듈식, 유연하고 유지보수하기 쉬워질 수 있습니다. 이 글에서는 C#에서 실제 코딩 예제와 함께 각 SOLID 원칙을 자세히 살펴볼 것입니다.\n\n다음은 다섯 가지 SOLID 디자인 원칙입니다:\n\n<div class=\"content-ad\"></div>\n\n\n![Image](/assets/img/2024-06-22-UnderstandingSOLIDPrinciplesinNETCAPracticalGuidewithCodeExamples_0.png)\n\n# 1. 단일 책임 원칙 (SRP)\n\nSRP는 클래스가 변경되어야 하는 이유가 하나만 있어야 한다는 것을 말합니다. 즉, 하나의 책임만을 가져야 합니다. 이는 모듈화를 촉진하고 코드를 이해하고 유지보수하기 쉽게 만듭니다.\n\n주요 아이디어: 클래스는 한 가지 일만을 해야 하며, 그 일을 잘 수행해야 합니다.\n\n\n<div class=\"content-ad\"></div>\n\n실시간 예시: 레스토랑을 운영하거나 음식을 배달하는 것에만 전념하는 요리사를 생각해보세요.\n\nC#에서의 실용적인 코딩 예시:\n\nSRP를 적용하기 전:\n\n```js\npublic class Report\n{\n    public void GenerateReport() { }\n    public void SaveToFile() { }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 시나리오에서 Report 클래스는 리포트를 생성하고 파일로 저장하는 두 가지 책임을 갖고 있습니다. 이는 SRP를 위반합니다.\n\nSRP 적용 후:\n\n```js\npublic class Report\n{\n    public void GenerateReport() { }\n}\n\npublic class ReportSaver\n{\n    public void SaveToFile() { }\n}\n```\n\n이제 Report 클래스는 리포트 생성에만 책임이 있고, ReportSaver 클래스는 리포트 저장에 책임이 있습니다. 각 클래스는 단일 책임을 갖습니다.\n\n<div class=\"content-ad\"></div>\n\n해석: SRP에 따르면, 한 클래스는 하나의 책임을 가져야합니다. 이 문제를 해결하기 위해 보고서 기능을 저장하기 위해 다른 클래스를 작성해야 합니다. 이 때 Report 클래스를 수정해도 ReportSaver 클래스에는 영향을 미치지 않습니다.\n\n## 2. 개방/폐쇄 원칙 (OCP)\n\n개방/폐쇄 원칙은 클래스가 확장에 대해 열려 있어야 하지만 수정에 대해서는 닫혀 있어야 한다고 제안합니다. 이것은 기존 코드를 변경하지 않고 새로운 기능을 추가할 수 있다는 것을 의미합니다.\n\n주요 아이디어: 한 번 클래스를 작성하면 수정하는 것은 닫혀 있고, 확장하는 것은 열려 있어야 합니다.\n\n<div class=\"content-ad\"></div>\n\n실시간 예시: 당신의 스마트폰 - 기능을 추가하려면 열지 않고도 앱을 다운로드하여 능력을 확장할 수 있습니다.\n\nC#에서의 실용적인 코딩 예시:\n\nOCP 신청 전:\n\n```js\npublic class Rectangle\n{\n    public double Width { get; set; }\n    public double Height { get; set; }\n}\n\npublic class AreaCalculator\n{\n    public double CalculateArea(Rectangle rectangle)\n    {\n        return rectangle.Width * rectangle.Height;\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n새로운 도형을 추가할 때 이 디자인은 문제가 될 수 있습니다. 각 새로운 도형에 대해 AreaCalculator를 수정하면 OCP를 위반하게 됩니다.\n\nOCP를 적용한 후:\n\n```js\npublic interface IShape\n{\n    double CalculateArea();\n}\n\npublic class Rectangle : IShape\n{\n    // 구현\n}\n\npublic class Circle : IShape\n{\n    // 구현\n}\n```\n\n인터페이스(IShape)를 도입하여 기존 코드를 수정하지 않고도 새로운 도형(예: Circle)을 추가할 수 있습니다. OCP를 준수하는 방법입니다.\n\n<div class=\"content-ad\"></div>\n\nOCP에 따르면 클래스는 확장에 열려 있지만 수정에 대해 닫혀 있어야 합니다. 새로운 모양을 도입할 때는 그냥 인터페이스 IShape를 구현하면 됩니다. 그러면 IShape은 확장이 가능하지만 추가 수정은 불가능해집니다.\n\n## 3. 리스코프 치환 원칙 (LSP)\n\n리스코프 치환 원칙은 슈퍼클래스의 객체를 하위 클래스의 객체로 대체할 수 있어야 하며 프로그램의 정확성에 영향을 미치지 않아야 한다는 원칙입니다.\n\n주요 아이디어: 부모 클래스를 사용하는 곳에 하위 클래스를 사용할 수 있어야 합니다.\n\n<div class=\"content-ad\"></div>\n\n실시간 예시: 여러 브랜드의 TV에 모두 작동하는 원격 제어기를 가지고 있습니다.\n\nC#에서의 실용적인 코딩 예시:\n\nLSP를 적용하기 전:\n\n```csharp\npublic class Bird\n{\n    public virtual void Fly() { /* 구현 */ }\n}\n\npublic class Penguin : Bird\n{\n    public override void Fly()\n    {\n        throw new NotImplementedException(\"펭귄은 날지 못해요!\");\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n여기서 펭귄 클래스는 Fly 메서드에 예외를 발생시켜 LSP를 위반합니다.\n\nLSP를 적용한 후:\n\n```js\npublic interface IFlyable\n{\n    void Fly();\n}\n\npublic class Bird : IFlyable\n{\n    public void Fly()\n    {\n        // Bird에 특화된 구현\n    }\n}\n\npublic class Penguin : IFlyable\n{\n    public void Fly()\n    {\n        // 펭귄에 특화된 구현\n        throw new NotImplementedException(\"펭귄은 날지 못해요!\");\n    }\n}\n```\n\nIFlyable 인터페이스를 도입함으로써, Bird와 Penguin은 릴스코프 치환 원칙을 준수하게 되었습니다.\n\n<div class=\"content-ad\"></div>\n\n설명: LSP에 따르면 파생 클래스는 기본 클래스의 유형 정의와 동작을 깨뜨리지 않아야 합니다. 이는 기본 클래스의 객체를 파생 클래스의 객체로 교체해도 응용 프로그램이 깨지지 않아야 함을 의미합니다. 이는 파생 클래스의 객체가 기본 클래스의 객체와 동일한 방식으로 동작해야 한다는 것을 필요로 합니다.\n\n# 4. Interface Segregation Principle (ISP)\n\n인터페이스 분리 원칙은 클래스가 사용하지 않는 인터페이스를 강제로 구현하도록 해서는 안 된다고 말합니다. 이 원칙은 작고 특정 클라이언트용 인터페이스를 생성하는 것을 권장합니다.\n\n주요 아이디어: 클래스는 사용하지 않는 인터페이스를 구현하도록 강제되어서는 안 됩니다.\n\n<div class=\"content-ad\"></div>\n\n실시간 예시: 음악 스트리밍 서비스에 가입하여 좋아하는 장르만 선택하는 상황을 상상해보세요.\n\nC#에서의 실제 코딩 예시:\n\nISP 신청 전:\n\n```js\npublic interface IWorker\n{\n    void Work();\n    void Eat();\n}\n\npublic class Manager : IWorker\n{\n    // 구현\n}\n\npublic class Robot : IWorker\n{\n    // 구현\n}\n```\n\n<div class=\"content-ad\"></div>\n\n로봇 클래스는 ISP를 위반하지 않도록 먹는 방법을 구현해야 합니다.\n\nISP를 적용한 후:\n\n```js\npublic interface IWorkable\n{\n    void Work();\n}\n\npublic interface IEatable\n{\n    void Eat();\n}\n\npublic class Manager : IWorkable, IEatable\n{\n    // 구현\n}\n\npublic class Robot : IWorkable\n{\n    // 구현\n}\n```\n\nIWorkable 인터페이스를 IWorkable 및 IEatable 같은 작은 인터페이스로 분할하여, 각 클래스가 필요한 부분만 구현할 수 있도록 하여 ISP를 준수할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n설명: LSP에 따르면, 어떤 클라이언트도 해당 클라이언트와 관련이 없는 인터페이스를 강제로 사용해서는 안 됩니다. 다시 말해, 클라이언트는 사용하지 않는 메소드에 의존하도록 강요되어서는 안 됩니다.\n\n# 5. 의존 역전 원칙 (DIP)\n\n의존 역전 원칙은 고수준 모듈이 저수준 모듈에 의존하지 않아야 하며, 두 모듈 모두 추상화에 의존해야 한다는 것을 제안합니다. 또한, 추상화는 세부사항에 의존해서는 안 되며, 세부사항은 추상화에 의존해야 합니다.\n\n주요 아이디어: 고수준 모듈은 저수준 모듈에 의존해서는 안 되며, 두 모듈 모두 추상화에 의존해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n실시간 예제: 레고 타워 만들기 - 브릭(고수준 및 저수준 모듈)은 작은 브릭(추상화)을 통해 연결됩니다.\n\nC#에서의 실용적인 코딩 예제:\n\nDIP를 적용하기 전:\n\n```js\npublic class LightBulb\n{\n    public void TurnOn() { /* 구현 */ }\n    public void TurnOff() { /* 구현 */ }\n}\n\npublic class Switch\n{\n    private LightBulb bulb;\n\n    public Switch(LightBulb bulb)\n    {\n        this.bulb = bulb;\n    }\n\n    public void Toggle()\n    {\n        if (bulb.IsOn)\n            bulb.TurnOff();\n        else\n            bulb.TurnOn();\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n스위치 클래스는 이제 추상화에 의존하도록 변경되어 DIP(Dependency Inversion Principle)를 준수합니다.\n\n<div class=\"content-ad\"></div>\n\n해석: DIP에 따르면 어플리케이션이 점점 커져갈 때 서로 강하게 결합된 코드를 작성하는 것은 유지보수하기 어려운 악몡이 될 수 있습니다. 한 클래스가 다른 클래스에 의존할 경우, 의존하는 클래스가 변경되면 해당 클래스도 수정해야 합니다. 항상 느슨하게 결합된 클래스를 작성하려고 노력해야 합니다.\n\n결론\n\n.NET 개발자들은 이러한 SOLID 원칙을 이해하고 적용함으로써 더 강력하고 유연하며 유지보수가 쉬운 소프트웨어를 만들 수 있습니다. 이러한 원칙이 함께 작동하여 서로 보완하며 객체지향 프로그래밍의 전체적인 설계 철학에 기여한다는 점을 명심하는 것이 중요합니다.\n\n저자: Jeslur Rahman","ogImage":{"url":"/assets/img/2024-06-22-UnderstandingSOLIDPrinciplesinNETCAPracticalGuidewithCodeExamples_0.png"},"coverImage":"/assets/img/2024-06-22-UnderstandingSOLIDPrinciplesinNETCAPracticalGuidewithCodeExamples_0.png","tag":["Tech"],"readingTime":6},{"title":"온디맨드 ISR로 새로운 콘텐츠 빠르게 제공하는 방법","description":"","date":"2024-06-22 04:23","slug":"2024-06-22-DeliverNewContentFasterOnDemandISR","content":"\n\n\n![img](/assets/img/2024-06-22-DeliverNewContentFasterOnDemandISR_0.png)\n\nNext.js 버전 12.2.0에는 HTML을 정적으로 렌더링하는 새로운 기능인 On-Demand Incremental Static Regeneration이 소개되었습니다. 이 기능은 자주 변경되는 데이터 풀을 가진 기업에게 중요하며, 특히 사용자 브라우저에 최소한의 오래된 데이터가 남도록 필요로 하는 중요한 콘텐츠를 가진 기업에게 필수적입니다. 이 글에서는 정적 생성의 여러 형태를 탐구하고, 각 형태가 지난번 것의 효율성이나 성능 측면에서 어떻게 발전되어 가다가 od-ISR에 도달하는지 살펴볼 것입니다.\n\n# 정적 사이트 생성\n\n정적 사이트 생성(Static Site Generation, SSG)은 많은 사용 사례에 대해 클라이언트 사이드 렌더링(CSR)과 서버 사이드 렌더링(SSR)에 유용한 대안입니다. 클라이언트 사이드 렌더링은 클라이언트(사용자 브라우저)가 JavaScript를 HTML과 CSS로 렌더링하여 사용자에게 페이지를 제공하는 것에 의존합니다. 현재의 웹 개발 환경에서 CSR은 일반적으로 대량의 번들화된 JavaScript를 프론트엔드로 보내는 단일 페이지 응용 프로그램(Single Page Application, SPA)으로 이어집니다. 이로 인해 페이지를 렌더링하기 위해 필요한 HTML과 CSS를 브라우저에게 위임함으로써 성능이 좋지 않은 사이트를 만들 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\nSSR의 경우에는 서버가 더 많은 작업을 처리합니다. 각 페이지 이동은 서버에 요청을 일으키고, 서버는 관련 페이지와 JSON 데이터를 작성하여 응답합니다. 서버는 일반적으로 브라우저보다 강력하며, 페이지를 렌더링하는 데 필요한 내부 회사 데이터와 함께 동일한 위치에 배치될 수 있어 이 콘텐츠를 수집하기 위한 빠른 서버 측 HTTP 요청을 가능케합니다. 일반적으로 CSR은 렌더링 후 반응성이 중요한 매우 동적이고 대화형 응용 프로그램에 적합하며, SSR은 초기 페이지 로드를 더 빠르게 만드는 데 유리합니다. CSR은 캐싱된 에셋 및 콘텐츠 또는 CDN 또는 CDN이있는 CMS(예 : Sanity)에 데이터를 가져와 사용자에게 제공하여 페이지를 렌더링합니다.\n\n많은 현대적인 프레임워크는 일부 루트가 구성 파일에 따라 SSR을 통해 렌더링되고 다른 루트가 CSR을 통해 렌더링되는 하이브리드 렌더링 형태를 지원합니다. 예를 들어, Nuxt는 Nuxt 구성 파일에서 지정된 대로 다양한 루트를 대상으로 렌더링 할 수 있습니다.\n\n![image](/assets/img/2024-06-22-DeliverNewContentFasterOnDemandISR_1.png)\n\n정적 사이트 생성(SSG)은 CSR 및 SSR과는 완전히 다른 방식입니다. SSG는 모든 웹 페이지가 빌드 시간에 생성되어 서버에 저장되는 아키텍처입니다. 일반적으로 이에는 일종의 템플릿 기능이 포함됩니다. 블로그를 예로 들어보겠습니다. 모든 블로그 페이지가 동일한 형식으로 표시되는 경우를 생각해보세요. 정적 사이트 생성기는 일반적인 블로그 글 페이지에 대한 HTML 템플릿을 저장하고, 구조화된 데이터 형식 (예: JSON)을 사용하여 각 별도의 블로그 페이지를 위한 HTML 템플릿을 배포할 정보를 저장합니다. 클라이언트가 요청을 하면 저장된 사전에 생성된 HTML, CSS, 클라이언트 측 JavaScript (예를 들어 사용자 상호 작용에서의 HTTP 요청 제작용) 및 데이터가 즉시 사용자의 브라우저로 전송됩니다. 페이지를 브라우저에서 빌드하는 작업은 필요하지 않습니다. 이로 인해 초기 페이지 로드가 빠릅니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-22-DeliverNewContentFasterOnDemandISR_2.png)\n\n위 다이어그램은 SSG를 통해 렌더링된 블로그 사이트 아키텍처의 단순한 예제를 보여줍니다. 빌드 시기에 (1) Next는 콘텐츠 관리 시스템 (CMS)에 서버 측 호출을 수행하여 (2) 데이터를 받아 (3) 블로그 게시물을 정적으로 생성합니다. 또한 Next는 추가로 하나 이상의 API (4)를 호출하여 이 콘텐츠를 생성하거나 추가 데이터를 받을 수 있습니다 (5). 클라이언트가 요청을 보낼 때 (6), 미리 빌드된 페이지가 응답으로 제공되며, 클라이언트 측 JavaScript, HTML, CSS 및 관련 데이터 (7)가 포함됩니다. SSG는 사이트에서 상호 작용을 금지하지 않으며, 각 페이지와 함께 전송되는 클라이언트 측 JavaScript에 의해 하나 이상의 API 또는 서비스 (예: Stripe)로 추가 CRUD 요청이 수행될 수 있습니다 (8, 9). 정적 사이트 생성기에 의해 생성된 페이지는 엔드 유저에게 가능한 한 가까운 위치에 있는 CDN에 캐시될 수도 있습니다 (여기서는 생략). 요청-응답 주기에서 증가된 거리가 가장 큰 성능 억제 요인 중 하나이므로, 이를 통해 페이지 로드 시간을 더욱 줄일 수 있습니다.\n\n정적 사이트 생성은 매우 뛰어난 로드 시간 성능을 제공합니다. 그러나 큰 단점이 하나 있습니다. 순수 SSG를 통해 렌더링된 사이트에서 하나의 페이지를 변경하면 서버에 저장된 모든 페이지를 완전히 다시 빌드해야 합니다. 이것이 순수 SSG의 가장 큰 병목 현상입니다. 밤 늦은 글쓰기 세션 중에 블로그 게시물 하나에서 철자를 잘못 입력한 경우를 상상해보세요. 사이트에 게시물이 얼마나 많이 있는지에 따라, 그것은 치명적인 실수일 수 있습니다.\n\n# stale-while-revalidate 및 증분 정적 재생\n\n\n<div class=\"content-ad\"></div>\n\n순수 SSG의 명백한 단점은 자주 변경되는 콘텐츠에 대해 아키텍처를 쓸모없게 만든다는 것입니다. SSG로 돌아가서, 모든 페이지가 생성되고 서버에 저장될 때 (다시 말해 캐시되어 있을 때), 개발자가 이 내부 캐시를 무효화하여 페이지를 다시 만드는 것을 막는 것은 무엇인가요? 여기에서 나타나는 것이 바로 SWR(지속-중재 확율)입니다. HTTP Cache-Control 헤더에 설정된이 값은 동반하는 max-age 값에 따라 캐시된 응답의 유효성을 결정합니다. SWR이 있는 Cache-Control HTTP 헤더는 다음과 같이 설정할 수 있습니다:\n\n```js\nCache-Control: max-age=604800, stale-while-revalidate=86400\n```\n\n이 헤더는 받는 서버, CDN 또는 클라이언트에게 콘텐츠를 재검증하기 전에 7일 동안 HTTP 응답을 캐시하도록 지시합니다. 일곱 일이 지나면 캐시된 응답은 더 이상 유효하지 않습니다. 이때 특정 URL의 특정 서버, CDN 또는 브라우저에 대한 요청이 발생하면, 즉시 스테일 콘텐츠가 응답으로 제공되고 백그라운드에서 내용을 다시 확인하고 캐시를 새로 고침하기 위해 원본 서버에 새 요청이 이루어집니다.\n\n여기에서 몇 가지 네이밍 컨벤션 혼란이 발생합니다. SWR을 렌더링 모드로 부르고 CDN의 존재 여부에 따라 Incremental Static Regeneration (ISR)와 의미론적으로 구분하여 네이밍을 혼동할 수 있습니다. CDN이 없는 경우 SWR은 렌더링 아키텍처이고 CDN이 있는 경우 ISR이 아키텍처이므로 (Nuxt 3 참조).\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-22-DeliverNewContentFasterOnDemandISR_3.png)\n\nSWR의 아이디어를 렌더링 모드와 분리하는 것이 현실적입니다. 이는 Cache-Control 헤더에 설정된 값을 의미하며, 해당 응답의 캐시 동작을 제어할 수 있습니다 (서버, CDN 또는 클라이언트가 stale-while-revalidate을 Cache-Control 값으로 수락할 수 있다면). Cache-Control 헤더의 must-revalidate 값과 마찬가지로 일반적입니다.\n\n![이미지](/assets/img/2024-06-22-DeliverNewContentFasterOnDemandISR_4.png)\n\n그러나 증분 정적 재생성은 SWR 헤더를 사용하여 정적으로 생성된 콘텐츠를 저장하고 다시 유효성을 검사하는 서버 또는 CDN에서 SWR 헤더를 활용한 아키텍처로 취급할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-22-DeliverNewContentFasterOnDemandISR_5.png)\n\n위 다이어그램은 ISR 기반 아키텍처가 어떻게 보일 수 있는지 간단히 보여줍니다. 이를 현대적인 뉴스 사이트로 생각해보면 지친 기자들이 악화되는 정치적 기후에 대응하고, AI가 생성한 실수에 대처하고, 독자들의 트위터에서의 소란한 피드백에 대응하며 자주 변경되는 컨텐츠를 가질 것입니다. 여기서 Next 서버는 모든 페이지를 빌드 시간에 생성합니다(1), CMS(2) 또는 API(4)로 서버 콜을 통해 관련 데이터(3, 5)를 수신합니다. 이러한 페이지는 TTL(Time-To-Live) 값(12)으로 생성되며, 이 경우 60초입니다. 이는 Cache Control 값을 나타내는 max-age 와 동일합니다. 만약 클라이언트가 이와 같은 뉴스 기사에 대한 요청을 할 경우, 우리 아키텍처에서 요청은 먼저 CDN(8)에 도달합니다. TTL이 만료되지 않았고 60초 창 안에 있다면, CDN는 즉시 페이지를 제공(9)하고 추가 조치가 필요하지 않습니다.\n\n![이미지](/assets/img/2024-06-22-DeliverNewContentFasterOnDemandISR_6.png)\n\n만약 60초의 TTL이 지났다면, CDN는 페이지를 사용자에게 제공하는데 문제가 없습니다. 사용자는 CDN 캐시에서 즉시 정적으로 생성된 페이지를 받습니다(9). CDN는 이로써 끝나지 않으며, 서버에 신선하게 생성된 페이지를 요청합니다(6). 이 시점에서 서버는 CMS 또는 API에서 데이터를 다시 가져오도록 서버쪽에서 스크램블하여 이 특정 페이지(2, 4)를 재검증하며 해당 데이터를 받아 다시 해당 페이지를 생성합니다(3, 5). 그런 다음, 해당 페이지를 CDN에 다시 캐시하기 위해 보냅니다(7). 이러한 방식으로 생성된 사이트는 사용자가 HTTPS 요청을 통해 클라이언트 측 JavaScript(10, 11)를 사용하여 하나 이상의 API 또는 서비스에 대한 CRUD 작업을 시작하는 등 추가 상호작용을 제한하지 않습니다.\n\n\n<div class=\"content-ad\"></div>\n\nISR보다 SSG의 혜택은 즉각적으로 나타납니다. 이제 한 가지 오타를 고치거나 기사 일부를 철회하거나 불운한 제목을 수정하기 위해 전체 사이트를 다시 빌드할 필요가 없습니다. 이로 인해 많은 비용이 드는 전체 사이트 재구축을 피할 수 있습니다. 콘텐츠가 한 페이지에서만 변경된다면, 왜 모든 페이지를 재구축해야 할 때와 같은 시간과 컴퓨팅 비용을 낭비해야 할까요? 또한 사용자 상호 작용을 통해 페이지를 다시 생성함으로써 불필요한 재구축을 최소화합니다. 드물게 방문하는 페이지는 상호 작용이 있을 때에만 다시 빌드됩니다.\n\n그러나 이 아키텍처에는 단점도 있습니다. ISR의 경우 실시간 데이터 업데이트는 여전히 진정한 기능이 아닙니다. 예를 들어 기자가 7일 TTL이 설정된 뉴스 기사를 게시했다고 가정해봅시다. 모든 QA 확인을 통과하고 게시된 후에 기사 제목에 철자 오류가 있다는 것을 깨닳기 전에 사용자들에게 즉각적으로 알려져 조롱하는 트위터 게시물에 응답을 받습니다. 만약 창조자가 게시물을 편집하고 그냥 기다린다면, 기사가 새롭게 업데이트되기까지 전체 7일이 걸릴 수 있습니다. 캐시는 수동으로 무효화되어야 할 것입니다. 또한 서버가 페이지를 재생성하는 데 시간이 걸립니다. 그동안 모든 사용자는 CDN이나 서버가 답변으로 반환하는 제목 오타가 있는 낡은 콘텐츠를 받게 됩니다. 게다가 위에서 언급한 드물게 방문하는 페이지가 오랜 기간 동안 재구축되지 않으면 문제가 발생할 수 있습니다. 한 달 동안 방문하지 않은 페이지가 있다고 생각해보세요. 질문이 생깁니다 — 너무 오래된 것은 과연 얼마나 오래 된 것인가요?\n\n# 온디맨드 증분 정적 재생성\n\n![Deliver New Content Faster On-Demand ISR](/assets/img/2024-06-22-DeliverNewContentFasterOnDemandISR_7.png)\n\n<div class=\"content-ad\"></div>\n\nOn-Demand Incremental Static Regeneration (od-ISR, 동료 엔지니어가 만든 비표준 약어)은 위에 나열된 많은 질문에 대해 다룹니다. TTL에 기반한 캐시 무효화 대신, 실시간 데이터 변경을 다루지 못하는 시간 기반 지표가 아닌 동적으로 만들어낼 수 있습니다. 정적 콘텐츠의 이 온디맨드 재구성 유형은 중요한 데이터를 가진 웹사이트에 필수적입니다.\n\n전형적인 예로 전자 상거래 사이트를 들 수 있습니다. 하루 종일 잘리지 않는 상품 데이터의 대부분은 변경되지 않지만, 뒷면에서는 제품 매니저가 여러 가지 이유로 다양한 제품 풀에서 설명, 제목 및 카테고리를 편집할 수 있습니다. 그들은 당신(개발자)이 이러한 변경 사항을 빠르게 인식하는 사이트를 만들도록 요구합니다, 특히 위험 요인이 높은 상황에서.\n\n시카고 기반의 휴일 전자 상거래 사이트이며 여러 공급 업체의 제품을 제공합니다. 구운 과자, 의상, 크리스마스 트리 등 신선하게 수확한 지역 유기농 코벗 홀리 홀리 리스를 판매합니다. 비즈니스는 번창하고 분당 수십 명의 고객이 사이트에서 제품을 둘러보고 아름다운 홀리 홀리 리스를 신속하게 구매합니다. 휴일 정신이 가득한 상황입니다. 그러나 홀리 홀리 리스에 신선하게 꽃을 포함하는 지역 공급 업체 중 한 명이 실제로는 홀리 홀리 리스에 약속한 제품을 보내지 않을 것이라고 알려주기 위해 당신에게 전화를 걸어옵니다.\n\n그는 매우 사과하며 전액 환불을 약속하지만 여전히 문제가 발생합니다. 그 홀리 홀리 리스는 여전히 당신의 사이트에 있으며, 시카고 사용자들에게 지역 무기화로 유기농 신선한 꽃이 들어가 있습니다. 이미 여러 사용자의 장바구니에 들어가 있습니다(하지만 이 부분은 고객 서비스에 넘기죠). 지금 이 혼란을 막아야 합니다. 새로운 지역 공급 업체를 발견했습니다. 꽃을 사용하지만 유기농 제품은 아니며 홀리만 유기농입니다. od-ISR이 이 문제를 어떻게 완화하는지 알아봅시다.\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-22-DeliverNewContentFasterOnDemandISR_8.png)\n\nod-ISR에서, Next는 모든 페이지를 빌드 시간에 생성합니다 (1). CMS 및/또는 API로부터 데이터를 전달받아 이러한 페이지를 작성하는 이전 화살표는 생략했지만, 이러한 호출은 여전히 빌드 시간에 발생합니다. 우리의 매혹적인 이야기를 계속해 봅시다. 어느 날 밤, 서둘러 콘텐츠 제작자나 제품 관리자가 올해 가장 바쁜 판매일 전에 네 시간 전에 전화를 받고 성수기 활동(편집, 설명, 이미지 및 기타 데이터)를 즉시 CMS에서 수정해야 한다는 전화를 받는 상황이 벌어집니다. 홀리 리스 태그를. 가까이 있는 하인드만 충실한 콘텐츠 제작자는 그런 일을 합니다 (2). CMS는 데이터 풀의 변경 사항에 대해 특정 조치를 실행하는 웹훅으로 구성되어 있습니다. 이 경우, 인증을 위해 숨은 토큰을 전달하기 위해 Next 웹 서버에 요청을 보냅니다 (3). 이것은 대신 내부 회사 서버나 기계를 사용하여 수행할 수 있으며, 여기서는 API라고 부르고 클라이언트 측 상호 작용을 위해 무균형적으로 재사용할 수 있게 했습니다 (4). Next는 즉시 데이터 변경에 영향을 받는 지정된 페이지 또는 페이지를 재구축합니다 (5). 이제 새 홀리 리스 페이지를 얻었습니다.\n\n![이미지](/assets/img/2024-06-22-DeliverNewContentFasterOnDemandISR_9.png)\n\n그런데, CDN이 잘못된 정보를 표시하는 홀리 리스가 있는 냅을 즉시 제공 대신, 그 구식이라고 하는 위험 콘텐트를 제공해버릴 때 어떻게 해야 할까요? 이 아키텍처에서 가장 어려운 부분입니다. 많은 CDN은 캐시의 일부 또는 전체를 무효화하거나 지우는 기능을 제공하므로, CDN이 즉시 구식 페이지를 제공하는 대신 오리진 서버로 반환하도록 강제합니다 (12). 때로는 이 기능이 GUI에 기반하거나 콘솔을 통해 수행되기도 하며 때로는 API를 통해 프로그래밍적으로 제공됩니다. 일반적으로 질문하는 CDN에 특정하며, 특정 CDN을 사용하는 개발자들은 임시방편을 활용하고 있습니다. 위의 개발팀이 CDN을 무효화하는 방법을 갖고 있다고 가정합시다, 이는 이 문서의 범위를 벗어난 것입니다. 클라이언트가 CDN에 요청을 보내면 (8), 오리진 서버로 돌아가 (6) 신선한 페이지를 응답하고 (7) 사용자에게 반환되며 (9) 다시 한번 CDN에 캐시됩니다 (표시되지 않음). 다시 말해, 이러한 유형의 아키텍처는 클라이언트 측 JavaScript에서 한 개 이상의 API나 서비스로 추가 CRUD 요청을 만드는 것을 배척하지 않습니다 (10, 11).\n\n<div class=\"content-ad\"></div>\n\n여기서 우리는 stale-while-revalidate ISR 콘텐츠 생성의 시간 기반 지표에서 상당한 개선을 볼 수 있습니다. 여기서 콘텐츠는 요청에 따라 업데이트됩니다. 사용자가 방문하지 않아도 페이지가 ‘너무 오래된’ 상태가 되지 않을 것입니다. 대신 콘텐츠 생성자와 제품 관리자가 CMS나 데이터베이스를 업데이트하면 해당 콘텐츠는 요청을 받은 후 Next에 의해 다시 생성됩니다. 이는 웹훅이나 간단한 HTTP 요청을 통해 매개될 수 있으며 (Next의 경우) 비밀 토큰의 포함으로 인증됩니다. 페이지 재생성은 더 이상 사용자 상호작용을 통해 이루어지지 않습니다.\n\n이 재생성은 여전히 즉각적이지 않다는 점을 강조해야 합니다. 심지어 한 페이지의 재생성에도 시간이 걸릴 수 있습니다. 하나의 제품을 변경하는 것은 웹사이트 구조에 따라 여러 페이지의 재생성이 필요할 수 있습니다. Next는 요청을 받고 페이지를 재구성하고 CDN을 무효화할 수 있으며, 이 작업이 GUI를 통해 수동으로 이루어지지 않을 경우입니다. 그 동안 사용자는 여전히 오래된 콘텐츠를 받게 될 것입니다. 실제로, 적절하게 설계된 애플리케이션에서 이러한 변경 사항은 캐시된 콘텐츠가 만료되기를 기다릴 수 없는 빈번한 데이터 변경을 필요로 하는 동적 웹사이트의 요구를 충족시키기에 충분히 빠를 것으로 예상됩니다.\n\n우리 탐험이 시작될 때로 돌아가보면, 다양한 사용 사례에 대해 다른 렌더링 방법 대비 od-ISR이 상당한 개선임이 명백합니다. 대규모 전자상거래 사이트는 CSR만 있는 아키텍처에서 느린 로딩 속도를 겪을 것입니다. 서버에 추가된 계산 성능이 있더라도, 하나의 페이지가 여러 API 및 CMS로부터 데이터를 요구할 가능성이 높아 여전히 SSR 기반 아키텍처로 인해 더 긴 로드 시간이 필요할 수 있습니다.\n\n게다가 제품이 자주 변경되지 않는 페이지에서는, 동일한 페이지를 사용자 요청마다 서버에서 반복해서 다시 렌더링하는 비효율성이 이 사이트에 이상적이지 않습니다. SSG는 사이트에 작은 변경 사항을 위해 전체 재구성이 필요하며, 수천 개 제품을 보유한 비즈니스는 단일 페이지나 심지어 한 줄의 변경에 대해 엄청난 재생성 시간을 겪게 될 것입니다. od-ISR은 자주 변하는 내용을 필요로 하는 사이트에 이상적이지만 변경 사항을 최대한 빨리 반영해야 하는 사이트에는 적합하지 않습니다. od-ISR은 온디맨드 변경의 이점과 정적으로 생성된 콘텐츠에 대상 페이지 재생성을 결합하여, 높은 리스크, 동적이고 빈번하게 변경되는 데이터를 보유한 비즈니스에 완벽하게 적합합니다.\n\n<div class=\"content-ad\"></div>\n\n지금 시점에서 Next는 온디맨드 증분 정적 재생성을 제공합니다. Vue 기반의 Nuxt는 ISR을 제공하지만 Next와 같이 온디맨드 페이지 재구성은 아직 제공하지 않습니다. 그러나 수많은 Github 이슈 티켓과 응답에 따르면 해당 기능은 준비 중에 있습니다! Next에서 od-ISR에 대해 더 알고 싶다면 여기에서 문서를 확인해보세요.\n\n# Stackademic\n\n끝까지 읽어주셔서 감사합니다. 그 전에:\n\n- 작가를 추천하고 팔로우해주시는 걸 고려해주세요! 👏\n- 트위터(X), 링크드인, YouTube에서 우리를 팔로우해주세요.\n- Stackademic.com을 방문하여 전 세계에서 무료 프로그래밍 교육을 민주화하는 방법에 대해 더 많이 알아보세요.","ogImage":{"url":"/assets/img/2024-06-22-DeliverNewContentFasterOnDemandISR_0.png"},"coverImage":"/assets/img/2024-06-22-DeliverNewContentFasterOnDemandISR_0.png","tag":["Tech"],"readingTime":11},{"title":"최고의 미니멀리스트 UI 디자인 아이디어  vol 165","description":"","date":"2024-06-22 04:21","slug":"2024-06-22-UIDesignIdeasHigh-qualityMinimalistvol165","content":"\n\n## 고품질이고 미니멀한 UI/UX 디자인을 살펴보세요. 섬세하고 프리미엄한 빌드로 눈에 띄는 디자인들입니다. 이 작품들은 최고의 사용자 경험 디자인 에이전시에서 나온 것으로, 미니멀리즘에 초점을 맞추고 있습니다.\n\n## 오루클 아이덴티티\n\n👨‍🎨 줄리아 드미트리에브나\n👥 기엑스 아트\n\n## 나이키 AF1 웹사이트 컨셉\n\n<div class=\"content-ad\"></div>\n\n👨‍🎨 마리우스 미트코\n\n## 스킬젯 UI-UX\n\n👨‍🎨 파힘 샤리아르\n\n[이미지](/assets/img/2024-06-22-UIDesignIdeasHigh-qualityMinimalistvol165_0.png)\n\n<div class=\"content-ad\"></div>\n\n이 그림에서 소개된 인터페이스는 심플하면서도 고품질의 UX 디자인을 자랑합니다.\n\n생동감 넘치는 녹색 강조와 어두운 컬러 팔레트의 사용은 활성 강좌와 사용자 진행 상황 등 핵심 기능에 효과적으로 관심을 끌어줍니다.\n\n나침반은 잘 구성된 모듈과 명확하고 간결한 텍스트로 간결하게 유지되어, 사용자를 압도하지 않으면서 직관적인 사용자 경험을 촉진합니다. 이 디자인은 미적 매력과 실용적 사용성 사이의 균형을 이룹니다.\n\n## Vision Pro Duolingo — 공간 디자인 월의 4번째 날\n\n<div class=\"content-ad\"></div>\n\n👨‍🎨 안드레아스 크루새킨-리보스카\n\n이 교육 앱 인터페이스는 간결함과 기능성을 조화롭게 결합하여 미니멀리스트 UX 디자인 원칙을 보여줍니다.\n\n깔끔한 레이아웃, 어조가 점잖은 색 구성 및 직관적인 아이코노그래피는 빠른 학습과 사용자 유지에 도움이 됩니다.\n\n현저하게 식별하기 쉬운 이미지와 간결한 텍스트가 사용자의 집중이 분산되지 않도록 보장하여 전체 사용자 참여도와 효과를 향상시킵니다.\n\n<div class=\"content-ad\"></div>\n\n## Roomeet Virtual Workspace\n\n👨‍🎨 Brolis  \n👥 Odama  \n\n![Image](https://miro.medium.com/v2/resize:fit:1400/1*OZFee7rd_ns8gVQhy7hBCA.gif)\n\nThis virtual office application combines high-quality visuals with minimalist UX principles effectively.\n\n<div class=\"content-ad\"></div>\n\n이는 가상 공간을 구성하고 시각화하기 위해 3D 퍼스펙티브를 활용하여 공간 인식을 향상시키고 혼잡함 없이 시각적으로 표현합니다.\n\n간소화된 내비게이션 요소와 명확하고 집중된 아바타를 통해 사용자가 쉽게 상호 작용하고 레이아웃 복잡성보다는 커뮤니케이션에 집중할 수 있도록 지원하여 깔끔하고 매력적인 사용자 경험을 제공합니다.\n\n## 제품 페이지 전자상거래\n\n👨‍🎨 Anton Shmatko\n\n<div class=\"content-ad\"></div>\n\n\n![Mobile app design](https://miro.medium.com/v2/resize:fit:1400/1*-x1OZFSA7_GO-48ocKz0EA.gif)\n\nThis mobile app design for a product catalog demonstrates a high-quality, minimalist approach by employing a dark theme with high contrast text and vibrant product images, which enhance readability and visual appeal.\n\nInterface layout is clean, with essential information like price and ratings immediately visible, fostering an efficient browsing experience.\n\nSegmented control for product categories at the top provides an easy filter method, streamlining user interaction and access to desired products.\n\n\n<div class=\"content-ad\"></div>\n\n## 은행\n\n👨‍🎨 Slava Kornilov\n👥 Geex Arts\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*3X4yU0hAAgB7wdwtkena_w.gif)\n\n이 예산 관리 앱의 디자인은 고품질이며 미니멀한 UX를 보여주며 선명한 색상 사용과 깔끔한 타이포그래피로 중요한 숫자와 통찰이 효과적으로 돋보이도록합니다.\n\n<div class=\"content-ad\"></div>\n\n과도하게 큰 원을 사용한 그래픽 디스플레이는 시선을 사로 잡아 복잡한 데이터를 손쉽게 이해하기 쉬운 형식으로 단순화합니다.\n\n전반적으로, 이 인터페이스는 사용자를 압도하지 않으면서 중요한 정보를 우선적으로 표시하여 재무 관리에 유용하고 사용자 친화적인 환경을 조성합니다.\n\n## 메뉴 상호작용\n\n👨‍🎨 Filip Legierski\n👥 Riotters\n\n<div class=\"content-ad\"></div>\n\n\n![img](https://miro.medium.com/v2/resize:fit:1400/1*N6w2jPdVy9FH8E6Pgp6KmQ.gif)\n\n이 앱의 메뉴 디자인은 어두운 테마와 대비 있는 버튼 색상을 활용하여 미니멀한 사용자 경험 원칙을 대변합니다. 이로써 사용자가 주요 액션에 집중할 수 있습니다.\n\n레이아웃은 깔끔하고 간단하여 시각적 혼란 없이 명확히 옵션을 구분하여 탐색의 용이성을 촉진합니다.\n\n넉넉한 간격과 큰 타이포그래피의 활용은 접근성과 상호 작용의 편의성을 보장하여 뛰어난 사용자 경험을 제공합니다.\n\n\n<div class=\"content-ad\"></div>\n\n## 부동산 웹사이트 모바일 페이지\n\n👨‍🎨 Farzan Faruk\n👥 Rylic Studio\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*FMNgPUJLTTljoD138zTqqw.gif)\n\n“Hoomie” 앱의 디자인은 밝고 매력적인 색 구성을 활용하여 고객 지원 및 부동산 검색과 같은 주요 기능을 효과적으로 강조하여 즉시 접근할 수 있도록 합니다.\n\n<div class=\"content-ad\"></div>\n\n레이아웃은 사용자 친화적이며 큰 명확한 타이포그래피와 생생한 관련 이미지를 활용하여 직관적인 탐색 경험을 보장합니다.\n\n각 화면은 사용자가 압도당하지 않으면서 사용자 참여를 촉진하도록 신중하게 구조화되어 있습니다. 또한 주요 기능과 사용 편의성에 중점을 두어 미니멀한 UX 디자인 원칙과 잘 조화를 이룹니다.\n\n## Out of Dark — 고객 여정\n\n👨‍🎨 Martin Strba\n👥 Outloud\n\n<div class=\"content-ad\"></div>\n\n## Banksad — 금융 모바일 앱 UI 키트\n\n👨‍🎨 Caraka UI 키트  \n👥 Caraka  \n\n![Bankasd](/assets/img/2024-06-22-UIDesignIdeasHigh-qualityMinimalistvol165_1.png)  \n\n“Banksad” 금융 앱 UI 키트는 심플하고 깔끔한 디자인을 자랑하며, 여백을 효과적으로 활용하고 키포인트인 최근 거래 내역 및 계좌 잔액을 강조하기 위해 몽드톤 팔레트와 전략적으로 사용된 컬러 하이라이트를 적용했습니다.\n\n<div class=\"content-ad\"></div>\n\n디자인 시스템이 일관되고 계층이 정리되며 사용자 경로가 명확히 정의되어 있어 사용자 경험이 원활합니다. 네비게이션과 사용자 정의 옵션의 편리함으로부터 명백히 확인할 수 있습니다.\n\n이 UI 키트는 명확성과 사용자 친화적 인터페이스에 중점을 둔 현대적인 디자인 원칙을 보여줍니다.\n\n## 비전 프로 박물관 - 공간 디자인 달의 5 번째 날\n\n👨‍🎨 안드레아스 크루자킨 리보스카\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-22-UIDesignIdeasHigh-qualityMinimalistvol165_2.png)\n\n이 앱 디자인은 증강 현실을 효과적으로 활용하여 박물관 환경에서 시선을 끄는 뷰잉 경험을 향상시키며, 반 고흐의 \"해바라기\"를 인터랙티브하고 정보적인 오버레이로 강조합니다.\n\n깔끔한 선, 절제된 색상 팔레트, 직선적인 타이포그래피와 같은 미니멀리즘 디자인 요소의 사용은 사용자가 산물과 관련 디테일에 집중할 수 있도록 하여 산물을 즐기고 방해되지 않도록 합니다.\n\n이 접근 방식은 미술 작품의 시각적 중요성을 존중할 뿐 아니라, 인터페이스가 사용자 친화적이고 교육적인 것을 보장하여 방문자 참여와 학습을 증진합니다.\n\n\n<div class=\"content-ad\"></div>\n\n## 벤토 그리드\n\n👨‍🎨 Levi Wilson\n👥 QClay\n\n![Image](https://miro.medium.com/v2/resize:fit:1400/1*-EFO3D0xuGmi2KfNgHKwpw.gif)\n\n제품 기능을 소개하는 이 슬라이드 프레젠테이션은 명확한 미니멀한 디자인을 보여주며 일관된 색상 구성으로 가독성을 높이고 중요 요소에 집중할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n번호가 매겨진 섹션과 명확한 시각 자료는 서로 다른 제품 특징을 쉽게 이해하고 비교할 수 있도록 돕습니다.\n\n이 방식은 복잡한 정보를 효율적으로 전달하여 사용자들이 제시된 AI 기술의 능력과 장점을 빠르게 이해할 수 있도록 합니다.\n\n## 혁신적인 UI로 미래의 우유 배송을 경험해보세요\n\n👨‍🎨 aPurple\n\n<div class=\"content-ad\"></div>\n\n\n![RouteMilk](https://miro.medium.com/v2/resize:fit:1400/1*q9FM_RX5I5MpWQdfKYB_LQ.gif)\n\n\"RouteMilk\" 앱의 인터페이스는 고품질이며 심플한 UX 디자인을 보여주며 부드럽고 중립적인 색상 팔레트를 강조하여 접근성과 탐색의 용이성을 강조합니다.\n\n제품 카테고리, 상세 설명, 명확한 가격과 같은 주요 요소들은 잘 조직되어 사용자 친화적인 쇼핑 경험을 보장합니다.\n\n시각적 요소들은 깔끔하고 매력적이며, 기능성을 희생하지 않고 앱의 미적인 요소를 강화합니다. 이 디자인은 심플함과 쇼핑 앱의 포괄적인 요구 사항 사이에 스마트하게 균형을 맞춥니다.\n","ogImage":{"url":"/assets/img/2024-06-22-UIDesignIdeasHigh-qualityMinimalistvol165_0.png"},"coverImage":"/assets/img/2024-06-22-UIDesignIdeasHigh-qualityMinimalistvol165_0.png","tag":["Tech"],"readingTime":6},{"title":"고성능 JSON 파싱 라이브러리 분석 - Go 언어를 위한 비교 분석","description":"","date":"2024-06-22 04:18","slug":"2024-06-22-Analyzevarioushigh-performanceJSONparsinglibrariesinGo","content":"\n\n![image](/assets/img/2024-06-22-Analyzevarioushigh-performanceJSONparsinglibrariesinGo_0.png)\n\n`fastjson`, `gjson`, `jsonparser`의 성능, 장단점을 비교해보세요.\n\n이 기사는 Go의 표준 라이브러리가 JSON을 파싱하는 방식을 분석하고, 인기 있는 JSON 파싱 라이브러리, 그 특징들을 탐구하여 다양한 시나리오에서 개발을 더 잘 지원할 수 있는 방법에 대해 알아봅니다.\n\n나는 JSON 라이브러리의 성능 문제를 조사하려고 한 계획은 없었습니다. 그러나 최근에 프로젝트를 pprof로 분석해보니 아래의 flame 그래프에서 비즈니스 로직 처리 시 성능 소비량의 절반 이상이 JSON 파싱 중에 발생했다는 것을 알게 되었습니다. 그래서 이 기사가 만들어졌습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-22-Analyzevarioushigh-performanceJSONparsinglibrariesinGo_1.png)\n\n이 기사는 Go의 표준 라이브러리가 JSON을 구문 분석하는 방식을 분석하고, 인기있는 JSON 구문 분석 라이브러리, 그 특징, 그리고 다양한 시나리오에서 개발을 더 잘 돕는 방법을 탐색합니다.\n\n주로 다음 라이브러리들의 분석을 소개합니다 (2024년 6월 13일):\n\n![이미지](/assets/img/2024-06-22-Analyzevarioushigh-performanceJSONparsinglibrariesinGo_2.png)\n\n\n<div class=\"content-ad\"></div>\n\n## JSON Unmarshal\n\n```go\nfunc Unmarshal(data []byte, v interface{})\n```\n\n\"공식 JSON 구문 분석 라이브러리는 두 개의 매개변수가 필요합니다: 직렬화할 객체와이 객체의 유형입니다. 실제 JSON 구문 분석을 수행하기 전에 reflect.ValueOf를 호출하여 매개변수 v의 리플렉션 객체를 가져옵니다. 그런 다음 들어오는 데이터 객체의 처음에 있는 비어 있지 않은 문자열을 기반으로 구문 분석 방법이 결정됩니다.\"\n\n```go\nfunc (d *decodeState) value(v reflect.Value) error {\n    switch d.opcode {\n    default:\n        panic(phasePanicMsg)\n    // 배열\n    case scanBeginArray:\n        ...\n    // 구조체 또는 맵\n    case scanBeginObject:\n        ...\n    // int, string, float 등을 포함하는 리터럴\n    case scanBeginLiteral:\n        ...\n    }\n    return nil\n}\n```\n\n<div class=\"content-ad\"></div>\n\n파싱된 객체가 [,으로 시작하면 배열 객체이고 scanBeginArray 분기로 들어가게 됩니다. '로 시작하면 객체가 구조체 또는 맵이라는 것을 나타내며 scanBeginObject 분기로 들어가고 이와 같은 방식입니다.\n\n## 하위 요약\n\nUnmarshal의 소스 코드를 살펴보면 많은 양의 반사가 필드 값을 얻기 위해 사용되는 것을 볼 수 있습니다. JSON이 중첩되어 있다면 값 얻기 위해 반복적인 반사가 필요합니다. 따라서 성능은 매우 저조할 것으로 생각됩니다.\n\n하지만 성능이 높은 가치를 가지고 있지 않다면 직접 사용하는 것이 좋은 선택입니다. 완전한 기능성을 갖추고 있으며 공식 팀이 지속적으로 반복 및 최적화하고 있습니다. 미래 버전에서 성능도 질적인 발전을 이룰 수도 있습니다. Go 구조체로 직접 JSON 객체를 변환할 수 있는 유일한 방법일 것입니다.\n\n<div class=\"content-ad\"></div>\n\n# fastjson\n\n이 라이브러리의 특징은 이름이 시사하는 대로 빠르다는 것입니다. 소개 페이지에는 다음과 같이 언급되어 있습니다:\n\n사용 방법도 간단합니다. 아래와 같이 사용할 수 있습니다:\n\n```js\nfunc main() {\n     var p fastjson.Parser\n     v, _ := p.Parse(`{\n                 \"str\": \"bar\",\n                 \"int\": 123,\n                 \"float\": 1.23,\n                 \"bool\": true,\n                 \"arr\": [1, \"foo\", {}]\n         }`)\n     fmt.Printf(\"foo=%s\\n\", v.GetStringBytes(\"str\"))\n     fmt.Printf(\"int=%d\\n\", v.GetInt(\"int\"))\n     fmt.Printf(\"float=%f\\n\", v.GetFloat64(\"float\"))\n     fmt.Printf(\"bool=%v\\n\", v.GetBool(\"bool\"))\n     fmt.Printf(\"arr.1=%s\\n\", v.GetStringBytes(\"arr\", \"1\"))\n }\n // 출력:\n // foo=bar\n // int=123\n // float=1.230000\n // bool=true\n // arr.1=foo\n```\n\n<div class=\"content-ad\"></div>\n\nfastjson을 사용하려면 먼저 JSON 문자열을 구문 분석하기 위해 Parser parser에 전달한 다음 Parse 메서드로 반환된 객체를 통해 검색해야 합니다. 중첩된 객체인 경우 Get 메서드에 매개변수를 전달할 때 해당 부모-자식 키를 직접 전달할 수 있습니다.\n\n## 분석\n\nfastjson의 설계는 표준 라이브러리 Unmarshal과 다르게 JSON 구문 분석을 Parse와 Get으로 나누는 특징이 있습니다.\n\nParse는 JSON 문자열을 구조체로 구문 분석하고 반환하는 역할을 합니다. 그런 다음 반환된 구조체에서 데이터를 검색합니다. Parse 프로세스는 락이 없으므로 동시에 Parse를 호출하려면 ParserPool을 사용해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n**fastjson**은 JSON을 가장 위에서부터 아래로 트래버스하여 구문 분석된 데이터를 Value 구조에 저장합니다:\n\n```js\ntype Value struct { o Object a []*Value s string t Type }\n```\n\n이 구조는 다음과 같습니다:\n\n- o Object: 구문 분석된 구조가 객체임을 나타냅니다.\n- a []*Value: 구문 분석된 구조가 배열임을 나타냅니다.\n- s string: 구문 분석된 구조가 객체나 배열이 아닌 경우, 다른 유형의 값은 문자열로 이 필드에 저장됩니다.\n- t Type: 이 구조의 유형을 나타내며, TypeObject, TypeArray, TypeString, TypeNumber 등이 될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```go\ntype Object struct { kvs []kv keysUnescaped bool } type kv struct { k string v *Value }\n```\n\n이 구조는 객체의 재귀 구조를 저장합니다. 위 예시의 JSON 문자열을 구문 분석한 후, 결과물은 다음과 같이 보입니다:\n\n![구조 이미지](/assets/img/2024-06-22-Analyzevarioushigh-performanceJSONparsinglibrariesinGo_3.png)\n\n## 코드\n\n<div class=\"content-ad\"></div>\n\n구현 측면에서 반사 코드의 부재로 인해 전체 구문 분석 프로세스가 매우 깔끔해졌어요. 구문 분석의 중심 부분을 직접 살펴보죠:\n\n```js\nfunc parseValue(s string, c *cache, depth int) (*Value, string, error) {\n     if len(s) == 0 {\n         return nil, s, fmt.Errorf(\"빈 문자열을 구문 분석할 수 없습니다\")\n     }\n     depth++\n     // json 문자열의 최대 깊이는 MaxDepth를 초과할 수 없습니다\n     if depth > MaxDepth {\n         return nil, s, fmt.Errorf(\"중첩 된 JSON에 대한 너무 큰 깊이; %d를 초과합니다\", MaxDepth)\n     }\n     // 객체 구문 분석\n     if s[0] == '{' {\n         v, tail, err := parseObject(s[1:], c, depth)\n         if err != nil {\n             return nil, tail, fmt.Errorf(\"객체를 구문 분석할 수 없음: %s\", err)\n         }\n         return v, tail, nil\n     }\n     // 배열 구문 분석\n     if s[0] == '[' {\n         ...\n     }\n     // 문자열 구문 분석\n     if s[0] == '\"' {\n         ...\n     } \n     ...\n     return v, tail, nil\n }\n```\n\nparseValue 함수는 문자열의 첫 번째 비어 있지 않은 문자를 기반으로 구문 분석할 유형을 결정할 거에요. 여기서 객체 유형이 분석에 사용됩니다:\n\n```js\nfunc parseObject(s string, c *cache, depth int) (*Value, string, error) {\n     ...\n     o := c.getValue()\n     o.t = TypeObject\n     o.o.reset()\n     for {\n         var err error\n         // Object 구조 내에서 kv 객체 가져오기\n         kv := o.o.getKV()\n         ... \n         // 키 값 구문 분석\n \n         kv.k, s, err = parseRawKey(s[1:])\n         ... \n         // 재귀적 값 구문 분석\n         kv.v, s, err = parseValue(s, c, depth)\n         ...\n         // 만났을 때, 계속 구문 분석\n         if s[0] == ',' {\n             s = s[1:]\n             continue\n         }\n         // 구문 분석 완료\n         if s[0] == '}' {\n             return o, s[1:], nil\n         }\n         return nil, s, fmt.Errorf(\"객체 값 후 ','가 누락되었습니다\")\n     }\n }\n```\n\n<div class=\"content-ad\"></div>\n\nparseObject 함수도 간단합니다. 루프에서 키 값을 가져와서 순환적으로 parseValue 함수를 호출하여 위에서 아래로 값을 구문 분석하고 '를 마주할 때까지 JSON 객체들을 하나씩 구문 분석합니다.\n\n## 하위 요약\n\n위의 분석을 통해 fastjson은 구현이 훨씬 간단하고 표준 라이브러리보다 성능이 더 높다는 것을 알 수 있습니다. JSON 트리를 구문 분석하는 Parse를 사용한 후에는 여러 번 재사용할 수 있어 반복 구문 분석이 필요 없어지고 성능이 향상됩니다.\n\n그러나 그 기능은 매우 기본적이며 JSON을 구조체로 또는 JSON을 맵으로 변환하는 공통 작업이 부족합니다. JSON에서 값을 간단히 검색하려면이 라이브러리를 사용하는 것이 매우 편리합니다. 하지만 JSON 값을 구조체로 변환하려면 각 값을 수동으로 설정해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n# GJSON\n\n제 테스트 결과, GJSON의 성능은 fastjson만큼 극단적이진 않지만, 기능적으로는 매우 완전하며 성능도 꽤 괜찮습니다. 이제 GJSON의 기능을 간단히 소개하겠습니다.\n\nGJSON의 사용법은 fastjson과 유사하며, 매우 간단합니다. JSON 문자열과 필요한 값을 매개변수로 전달하기만 하면 됩니다.\n\n```js\njson := `{\"name\":{\"first\":\"li\",\"last\":\"dj\"},\"age\":18}`\nlastName := gjson.Get(json, \"name.last\")\n```\n\n<div class=\"content-ad\"></div>\n\n이 함수 외에도 간단한 퍼지 매칭을 수행할 수 있습니다. *와 ?와 같은 와일드카드 문자를 지원합니다. *는 모든 문자와 매치되고 ?는 한 문자와 매치됩니다. 예시는 다음과 같습니다:\n\n```js\njson := `{\n     \"name\":{\"first\":\"Tom\", \"last\": \"Anderson\"},\n     \"age\": 37,\n     \"children\": [\"Sara\", \"Alex\", \"Jack\"]\n }`\n fmt.Println(\"세 번째 자식*:\", gjson.Get(json, \"child*.2\"))\n fmt.Println(\"첫 번째 c?ild:\", gjson.Get(json, \"c?ildren.0\"))\n```\n\n- child*.2: 먼저, child*는 children과 매치되며, .2는 세 번째 요소를 읽습니다;\n- c?ildren.0: c?ildren은 children과 매치되며, .0은 첫 번째 요소를 읽습니다;\n\n퍼지 매칭뿐만 아니라 수정자 작업도 지원합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\njson := `{\n     \"name\":{\"first\":\"Tom\", \"last\": \"Anderson\"},\n     \"age\": 37,\n     \"children\": [\"Sara\", \"Alex\", \"Jack\"]\n }`\n fmt.Println(\"세 번째 자녀*:\", gjson.Get(json, \"children|@reverse\"))\n```\n\nchildren|@reverse 먼저 배열 \"children\"를 읽은 다음 수정자 \"@reverse\"를 사용하여 뒤집어서 출력합니다.\n\n```js\nnestedJSON := `{\"nested\": [\"one\", \"two\", [\"three\", \"four\"]]}` fmt.Println(gjson.Get(nestedJSON, \"nested|@flatten\"))\n```\n\n@flatten은 내장된 배열을 외부 배열로 평탄화하고 다음을 반환합니다:\n\n<div class=\"content-ad\"></div>\n\n```json\n[\"one,\" \"two,\" \"three,\" \"four\"]\n```\n\n다른 흥미로운 기능도 있으니 공식 문서에서 확인해보세요.\n\n## 분석\n\ngjson의 Get 메서드 매개변수는 JSON 문자열과 경로(Path)를 포함하며, 해당 JSON 값을 가져올 수 있는 일치 경로를 나타냅니다.\n\n<div class=\"content-ad\"></div>\n\ngjson에서는 파싱을 여러 가지 파싱 시나리오의 정의를 충족해야 하기 때문에 두 부분으로 나뉘어집니다. JSON 문자열을 탐색하기 전에 경로를 파싱해야 합니다.\n\n파싱 프로세스 중 일치하는 값을 만날 경우 해당 값이 직접 반환되며 뒷 부분을 계속해서 탐색할 필요가 없습니다. 여러 값이 일치하는 경우 JSON 문자열 전체가 항상 탐색됩니다. JSON 문자열에서 일치하는 경로를 만나지 못할 경우 전체 JSON 문자열을 탐색해야 합니다.\n\n파싱 과정에서 파싱 내용이 fastjson과 같이 구조에 저장되지 않습니다. 따라서 GetMany를 호출하여 여러 값을 반환할 때 JSON 문자열을 반복적으로 탐색해야 하기 때문에 효율이 비교적 낮아집니다.\n\n![이미지](/assets/img/2024-06-22-Analyzevarioushigh-performanceJSONparsinglibrariesinGo_4.png)\n\n<div class=\"content-ad\"></div>\n\n@flatten 함수는 JSON을 유효성 검사하지 않는다는 사실을 알아두는 것이 중요합니다. 이는 입력 문자열이 유효한 JSON이 아니더라도 구문 분석된다는 의미입니다. 따라서 사용자들은 잠재적인 문제를 피하기 위해 입력이 유효한 JSON인지 다시 한번 확인해야 합니다.\n\n## 코드\n\n```js\nfunc Get(json, path string) Result {\n     // 패스를 분석합니다\n     if len(path) > 1 {\n         ...\n     }\n     var i int\n     var c = &parseContext{json: json}\n     if len(path) >= 2 && path[0] == '.' && path[1] == '.' {\n         c.lines = true\n         parseArray(c, 0, path[2:])\n     } else {\n         // 다양한 객체에 따라 구문 분석하고 여기서 '{' 또는 '['이 발견될 때까지 루프\n         for ; i < len(c.json); i++ {\n             if c.json[i] == '{' {\n                 i++\n \n                 parseObject(c, i, path)\n                 break\n             }\n             if c.json[i] == '[' {\n                 i++\n                 parseArray(c, i, path)\n                 break\n             }\n         }\n     }\n     if c.piped {\n         res := c.value.Get(c.pipe)\n         res.Index = 0\n         return res\n     }\n     fillIndex(json, c)\n     return c.value\n }\n```\n\nGet 메서드에서 다양한 경로를 구문 분석하는 데 사용된 긴 코드 문자열을 볼 수 있습니다. 그런 다음 '‘나 ‘[‘를 찾을 때까지 for 루프가 JSON을 계속 탐색한 후 해당하는 논리 처리를 수행합니다.\n\n<div class=\"content-ad\"></div>\n\n```go\nfunc parseObject(c *parseContext, i int, path string) (int, bool) {\n     var pmatch, kesc, vesc, ok, hit bool\n     var key, val string\n     rp := parseObjectPath(path)\n     if !rp.more && rp.piped {\n         c.pipe = rp.pipe\n         c.piped = true\n     }\n     // 두 개의 for 루프를 중첩하여 키 값을 찾습니다.\n     for i < len(c.json) {\n         for ; i < len(c.json); i++ {\n             if c.json[i] == '\"' {\n                 i++\n                 var s = i\n                 for ; i < len(c.json); i++ {\n                     if c.json[i] > '\\\\' {\n                         continue\n                     }\n                     // 키 값을 찾고 parse_key_string_done으로 이동합니다.\n                     if c.json[i] == '\"' {\n                         i, key, kesc, ok = i+1, c.json[s:i], false, true\n                         goto parse_key_string_done\n                     }\n                     ...\n                 }\n                 key, kesc, ok = c.json[s:], false, false\n                 // break\n              parse_key_string_done:\n                     break\n                 }\n                 if c.json[i] == '}' {\n                     return i + 1, false\n                 }\n             }\n             if !ok {\n                 return i, false\n             }\n             // 퍼지 매치인지 확인합니다.\n             if rp.wild {\n                 if kesc {\n                     pmatch = match.Match(unescape(key), rp.part)\n                 } else {\n                     pmatch = match.Match(key, rp.part)\n                 }\n             } else {\n                 if kesc {\n                     pmatch = rp.part == unescape(key)\n                 } else {\n                     pmatch = rp.part == key\n                 }\n             }\n             // 값을 파싱합니다.\n             hit = pmatch && !rp.more\n             for ; i < len(c.json); i++ {\n                 switch c.json[i] {\n                 default:\n                     continue\n                 case '\"':\n                     i++\n                     i, val, vesc, ok = parseString(c.json, i)\n                     if !ok {\n                         return i, false\n                     }\n                     if hit {\n                         if vesc {\n                             c.value.Str = unescape(val[1 : len(val)-1])\n                         } else {\n                             c.value.Str = val[1 : len(val)-1]\n                         }\n                         c.value.Raw = val\n                         c.value.Type = String\n                         return i, true\n                     }\n                 case '{':\n                     if pmatch && !hit {\n                         i, hit = parseObject(c, i+1, rp.path)\n                         if hit {\n                             return i, true\n                         }\n                     } else {\n                         i, val = parseSquash(c.json, i)\n                         if hit {\n                             c.value.Raw = val\n                             c.value.Type = JSON\n                             return i, true\n                         }\n                     }\n                 ...\n                 break\n             }\n         }\n     }\n     return i, false\n}\n```\n\n`parseObject` 코드를 검토할 때 JSON 파싱이나 문자열 탐색 방법을 가르치는 것이 아니라 나쁜 경우의 시나리오를 설명하는 것이 목적이었습니다. 중첩된 for 루프와 연이어 나오는 if 문들은 압도적일 수 있고, 직장에서 만난 동료의 코드를 떠올릴 수도 있습니다.\n\n## 하위 요약\n\n장점:\n\n<div class=\"content-ad\"></div>\n\n- 성능: jsonparser는 표준 라이브러리와 비교하여 상대적으로 우수한 성능을 보여줍니다.\n- 유연성: 다양한 검색 방법과 사용자 정의 반환 값 옵션을 제공하여 매우 편리합니다.\n\n단점:\n\n- JSON 유효성 검사 미지원: JSON 입력의 정확성을 확인하지 않습니다.\n- 코드 구조가 지저분하고 읽기 어렵다. 유지보수가 어려울 수 있습니다.\n\n## 참고문서\n\n<div class=\"content-ad\"></div>\n\nJSON 값을 가져오기 위해 JSON을 파싱할 때, 지정된 키에 따라 GetMany 함수가 JSON 문자열을 여러 번 횡단합니다. JSON을 맵으로 변환하면 횡단 횟수를 줄일 수 있습니다.\n\n## 결론\n\njsonparser는 주목할 만한 성능과 유연성을 가지고 있지만, JSON 유효성 검사 부족과 복잡하고 읽기 어려운 코드 구조는 상당한 단점으로 나타납니다. JSON을 파싱하고 값을 자주 가져와야 하는 경우, 성능과 코드 유지 관리성 사이의 균형을 고려해야 합니다.\n\n# jsonparser\n\n<div class=\"content-ad\"></div>\n\n## 분석\n\njsonparser는 입력 JSON 바이트 슬라이스도 처리하며 여러 키를 전달하여 값을 빠르게 찾아내고 반환할 수 있습니다.\n\nGJSON과 유사하게, jsonparser는 fastjson이 하는 것처럼 파싱된 JSON 문자열을 데이터 구조에 캐시하지 않습니다. 하지만 다수의 값을 파싱해야 하는 경우 EachKey 함수를 사용하여 JSON 문자열을 한 번에 여러 값으로 파싱할 수 있습니다.\n\n일치하는 값을 찾으면 jsonparser는 추가적인 탐색 없이 즉시 반환합니다. 다수의 일치하는 값이 있을 경우 전체 JSON 문자열을 탐색합니다. JSON 문자열에서 경로가 일치하는 값이 없다면 여전히 전체 문자열을 탐색합니다.\n\n<div class=\"content-ad\"></div>\n\njsonparser는 재귀 사용을 줄이고 호출 스택의 깊이를 낮추며 성능을 향상시키기 위해 JSON 탐색 중에 루프를 사용합니다.\n\nArrayEach, ObjectEach 및 EachKey 함수는 사용자 정의 함수를 전달하여 특정 요구 사항을 충족시키는 기능을 제공하여 jsonparser의 유틸리티를 크게 향상시킵니다.\n\njsonparser의 코드는 간단하고 명확하여 분석하기 쉽습니다. 관심 있는 사람은 직접 검토할 수 있습니다.\n\n## 하위 요약\n\n<div class=\"content-ad\"></div>\n\njsonparser의 뛰어난 성능은 다음과 같은 이유가 있습니다:\n\n- 재귀를 최소화하기 위해 for 루프를 사용합니다.\n- 표준 라이브러리와는 달리 반영(reflection)을 사용하지 않습니다.\n- 해당 키 값이 발견되면 즉시 종료하여 추가 재귀를 피합니다.\n- 전달된 JSON 문자열에서 작업하며 새로운 공간을 할당하지 않아 메모리 할당을 줄입니다.\n\n또한 API 디자인이 편리합니다. ArrayEach, ObjectEach, EachKey와 같은 함수는 사용자 정의 함수를 전달할 수 있어 실제 비즈니스 개발에서 많은 문제를 해결할 수 있습니다.\n\n하지만 jsonparser에는 중요한 단점이 있습니다: JSON을 유효성 검사하지 않습니다. 입력이 유효한 JSON이 아닌 경우 jsonparser는 감지하지 못합니다.\n\n<div class=\"content-ad\"></div>\n\n# 성능 비교\n\n## 작은 JSON 문자열 구문 분석\n\n약 190바이트 정도의 간단한 JSON 문자열을 구문 분석하는 것\n\n![이미지](/assets/img/2024-06-22-Analyzevarioushigh-performanceJSONparsinglibrariesinGo_5.png)\n\n<div class=\"content-ad\"></div>\n\n## JSON 문자열 구문 분석하기\n\n중간 정도 복잡성의 JSON 문자열을 구문 분석하려면, 대략 2.3KB 크기를 가질 것입니다.\n\n![이미지](/assets/img/2024-06-22-Analyzevarioushigh-performanceJSONparsinglibrariesinGo_6.png)\n\n## 큰 JSON 문자열 구문 분석하기\n\n<div class=\"content-ad\"></div>\n\nJSON 문자열을 파싱하려면, 대략 2.2MB의 크기가 있어요.\n\n![이미지](/assets/img/2024-06-22-Analyzevarioushigh-performanceJSONparsinglibrariesinGo_7.png)\n\n# 요약\n\n이 비교를 통해 여러 고성능 JSON 파싱 라이브러리를 분석했어요. 이 라이브러리들은 몇 가지 공통 특징을 공유하고 있어요:\n\n<div class=\"content-ad\"></div>\n\n- 리플렉션 사용을 피합니다.\n- JSON을 순차적으로 바이트 단위로 탐색하여 파싱합니다.\n- 입력 JSON 문자열을 직접 파싱하여 메모리 할당을 최소화합니다.\n- 성능을 위해 어느 정도의 호환성을 희생합니다.\n\n이런 점들을 고려해도, 각 라이브러리는 독특한 기능을 제공합니다. fastjson API는 가장 간단한 사용 방법을 제공하며, GJSON은 퍼지 검색 기능과 높은 사용자 정의 가능성을 제공합니다. jsonparser는 고성능 파싱 중에 콜백 함수 삽입을 지원하여 사용 편의성을 제공합니다.\n\n나의 사용 사례는 미리 정의된 필드와 가끔한 사용자 정의 작업이 포함된 HTTP 응답 JSON 문자열에서 특정 필드를 단순히 파싱하는 것이므로, jsonparser가 가장 적합한 도구입니다.\n\n그러므로 성능에 관심이 있다면 비즈니스 요구 사항을 기반으로 JSON 파서를 선택하는 것을 고려해보세요.\n\n<div class=\"content-ad\"></div>\n\n# 참고 자료\n\n- https://github.com/buger/jsonparser\n- https://github.com/tidwall/gjson\n- https://github.com/valyala/fastjson\n- https://github.com/json-iterator/go\n- https://github.com/mailru/easyjson\n- https://github.com/Jeffail/gabs\n- https://github.com/bitly/go-simplejson\n\n![이미지](/assets/img/2024-06-22-Analyzevarioushigh-performanceJSONparsinglibrariesinGo_8.png)\n\n## 👋 만약 이 정보가 도움이 되었다면, 아래 👏 버튼을 몇 번 눌러서 저자를 지원해주세요 👇\n\n<div class=\"content-ad\"></div>\n\n## 🚀 FAUN 개발자 커뮤니티에 참여하고 매주 비슷한 이야기를 이메일로 받아보세요","ogImage":{"url":"/assets/img/2024-06-22-Analyzevarioushigh-performanceJSONparsinglibrariesinGo_0.png"},"coverImage":"/assets/img/2024-06-22-Analyzevarioushigh-performanceJSONparsinglibrariesinGo_0.png","tag":["Tech"],"readingTime":16},{"title":"Julia로 프록시 서버 구축하는 방법","description":"","date":"2024-06-22 04:15","slug":"2024-06-22-BuildingAProxyServerInJulia","content":"\n\n올해에 서버 및 웹사이트를 배포하는 데 중요한 계획이 있어요. 1년 반 동안 데이터 과학 관점에서 웹 개발을 위해 타깃으로 삼는 줄리아 모듈 시리즈를 개발해 왔어요. 이러한 모듈들이 결합되어 상호 연결된 서버 시스템을 형성하고 이를 올해 초에 배포할 계획입니다. Chifi, Toolips, Olive와 관련해서는 2024년이 될 것입니다. 이 웹 시스템을 용이하게 지원하기 위해 만들어 놓은 생태계 개요를 확인하고 싶다면, chifi README가 좋은 시작점이에요:\n\nLaboratory의 배포를 용이하게 하기 위해, 서버 시스템이 인터넷과 통신할 필요가 있어요. 컴퓨터가 인터넷을 통해 다른 컴퓨터에 연결하는 데 필요한 여러 단계가 있고, 이 모든 단계에 대해 제 프로젝트를 직접 개발할 계획입니다.\n\n# 인터넷 서버\n\n인터넷은 표준화된 프로토콜 세트로, 컴퓨터가 다른 포트에 정렬된 다양한 헤더와 프로토콜을 사용하여 통신할 수 있게 합니다. 웹 기반 TCP 연결의 라우팅을 용이하게 하기 위해 사용되는 서로 다른 유형의 서버가 몇 가지 있어요. 표준 네트워킹 설정에 따라, 사용자를 URL 창에서 웹 페이지로 이동시키기 위한 과정 모두에 주소할 수 있는 다음 서버들이 일부입니다:\n\n<div class=\"content-ad\"></div>\n\n- 최상위 도메인(TLD) 이름 서버\n- 동적 호스트 컨트롤 프로토콜(DHCP) 서버\n- (도메인) 이름 서버(DNS)\n- 웹 서버(HTTP 서버)\n\n이 네 가지 서버 유형 중 두 가지는 서버를 인터넷에 연결하는 데 필요합니다. 이것들은 DHCP 서버와 웹 서버입니다. DHCP 서버는 집 네트워크에서 인터넷으로의 인터페이스이며, 이 서버는 연결된 각 클라이언트에 대해 외부 주소를 할당합니다. 이 주소는 네트워크 주소라고 합니다. 네트워크 주소는 두 가지 주소 유형 중 하나이며, 이는 인터넷 프로토콜에서 귀하의 서버를 다른 모든 서버와 명명하는 데 사용됩니다. 이러한 주소 유형은 각각 인터넷 프로토콜 버전 4와 인터넷 프로토콜 버전 6 (IPv4; IPv6)입니다.\n\nDHCP 서버는 넓은 인터넷, 로컬 네트워크 연결 및 귀하의 기기 간의 중개자 역할을 합니다. 이 서버는 귀하의 기기를 가져오고, 로컬 영역 네트워크(LAN)와 상호 작용하는 주소를 할당하며, 웹과 상호 작용하는 또 다른 주소를 할당합니다. 후자는 외부 또는 공용 IP 주소라고 하며, 전자는 로컬 IP 주소입니다.\n\n![image](/assets/img/2024-06-22-BuildingAProxyServerInJulia_0.png)\n\n<div class=\"content-ad\"></div>\n\n라우터는 DHCP 서버를 호스팅하기 위해 설계된 작은 기계입니다. 대부분의 경우, 라우터는 DHCP와 함께 웹 서버도 호스팅하며, 이를 통해 DHCP 서버를 구성할 수 있습니다. 이 웹 서버는 대중적으로 Default Gateway로 알려져 있으며, DHCP가 할당된 IP 주소의 라우터에 위치합니다.\n\n웹 브라우저에 Default Gateway를 입력하여 이 서버의 웹 인터페이스에 방문할 수 있습니다. 이 Default Gateway는 DHCP 서버를 실행 중인 라우터의 로컬 IP이며, DHCP 서버는 서버 측에서 포트 67을 사용합니다. 이 인터페이스를 통해 DHCP 서버를 구성할 수 있으며, 인터넷으로 다시 전달되는 포트를 포워딩할 수 있습니다. 네트워크의 Default Gateway에 액세스하려면 다음 명령어를 사용하실 수 있습니다.\n\n- Linux — ip route\n- Windows — ipconfig\n- OSx — netstat -nr\n\nURL은 프로토콜(http/https), 서브도메인, 도메인 이름, 최상위 도메인(TLD), 대상 또는 경로 및 매개변수 네 가지 부분으로 구성되어 있습니다. 서브도메인과 매개변수는 이 퍼즐의 선택적인 부분이므로, 이에 대해 집중해 보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n- 도메인 (name.tld)\n- 타겟\n- 아규먼트\n\n타겟과 아규먼트는 저희 웹 서버에서 처리되지만, 도메인은 DNS 서버에서 처리됩니다. 웹 브라우저에 URL을 입력하고 브라우저를 탐색할 때, 웹 브라우저는 TLD 네임 서버에 핑을 보냅니다. TLD 서버는 TLD 앞에 입력된 이름과 관련된 DNS에 대한 정보를 반환합니다. 이후 사용자는 TLD 서버에서 반환된 DNS 서버로 이동합니다. 그런 다음 DNS 서버는 그러한 이름을 로컬 IP로 라우팅합니다. 마지막으로 DNS 서버가 이 주소의 서버의 IP 및 포트를 반환한 후, 웹 브라우저는 해당 주소로 서브도메인 및 도메인 이름을 사용하여 이동합니다. 이름 서버에 대해 더 알고 싶다면, 저는 실제로 그 중 하나를 작성 중이고, 해당 프로젝트에 대해 작성한 두 부분을 여기에서 읽을 수 있습니다:\n\n위에서 언급된 서버들은 웹 서버를 호스팅하는 데 필수적이지만, 웹 개발에서 모두 다른 중요한 사용 사례를 가진 이러한 유형의 연결을 용이하게 하는 다양한 선택적 옵션이 있습니다. 더 고급 서버 인프라를 만드는 데 큰 도움이 되는 서버의 한 예로 프록시 서버라는 것이 있습니다.\n\n## 프록시 서버란 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n\"프록시\" 라는 단어는 다른 개체를 대표하는 것을 의미합니다. 예를 들어, 프록시 투표는 다른 사람이 내가 되는 척하여 투표한 투표를 나타냅니다. 컴퓨팅에서, 프록시 애플리케이션은 애플리케이션을 실행하는 데 사용되는 애플리케이션으로, 이상적으로는 해당 애플리케이션을 협박하게 합니다. 이 비유에서 투표는 우리의 애플리케이션이고, 프록시는 프록시 서버입니다. 왜 프록시 서버가 필요한지 이해하기 위해서는 우리의 애플리케이션을 고려하는 것이 타당합니다.\n\n우리의 도메인은 서버를 우리 IP로 연결할 것입니다 — 여기서 IP는 단순히 도메인이 연결된 기계를 가리킵니다. 각 포트에는 하나의 서버만 실행될 수 있다는 점을 염두에 두십시오. 웹 서버의 경우 포트는 항상 80이므로, 우리는 https://IP:80 에 하나의 서버만 배포할 수 있습니다. 이는 하나의 애플리케이션을 실행하려면 괜찮지만, 여러 애플리케이션을 실행하려면 새로운 IP — 전혀 새로운 컴퓨터가 필요하다는 것을 의미합니다. 물론 가상 IP 옵션도 있지만, 이 경우에서 가장 좋은 옵션은 다른 방법을 사용하는 것입니다.\n\n프록시 서버는 이 문제에 대한 인터넷의 표준적인 해결책입니다. 프록시 서버는 대상 이름에 대해 여러 서버 주소를 등록하고 요청 시에 해당 서버로 프록시 패스를 수행합니다. 현재 사용되는 대부분의 표준 프록시 서버는 SSL 및 부하 분산 기능과 결합되어 있습니다. 널리 사용되는 프록시 서버의 예로는 NGINX가 있습니다.\n\n## 부하 분산기란 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n서버가 종종 거대한 기계일 때 이유가 있습니다. 이론적으로 무한대의 클라이언트 목록을 제공하기 위해서는 많은 처리 능력이 필요합니다. 로드 밸런서가 없는 서버 시스템은 특정 도메인이나 IP를 요청하는 모든 클라이언트를 특정 서버로 보냅니다. 로드 밸런서가있는 서버 시스템은 들어오는 사용자를 여러 서버로 분산합니다. 이는 유용하며 프록시 서버의 사용 사례에 인접하기 때문에 로드 밸런싱은 프록시 서버 위에 쉽게 구현할 수 있습니다.\n\n# ChiProxy.jl\n\n오늘은 이 두 가지 개념을 결합하여 프록시 서버를 만들고, 최종적으로 SSL, 로드 밸런싱 및 더 많은 기능을 추가할 의도로 확장 가능한 프록시 라우팅 플랫폼에 프록시 서버를 만들겠습니다. 이 프로젝트는 ChiProxy 라고 부르겠습니다.\n\n![image](/assets/img/2024-06-22-BuildingAProxyServerInJulia_1.png)\n\n<div class=\"content-ad\"></div>\n\n# 프록시 서버 구축\n\n프록시 서버는 놀라울 정도로 유용하고 흥미로운 기능을 가지고 있지만, 복잡한 것은 아닙니다. 다행히도 나의 신경 쓸 부분은 없으며, 간단한 프록시 서버에서 데이터 전송 시 검토해야 할 헤더나 RST는 없습니다. 프록시 서버에서 우리가 정말로 해야 할 일은 들어오는 연결을 저장된 서버 주소(및 포트)로 보내는 것뿐입니다. 이를 어떻게 할지에 대한 몇 가지 아이디어가 있습니다. 특히 줄리아 타입 시스템 및 Toolips 하에서 어떻게 할지에 대한 아이디어가 있습니다. 이 단계로 진입하기 전에, 내 웹 개발 프레임워크의 발전에서 다음 중요 단계를 소개하고 싶습니다.\n\n![프록시 서버 구축](/assets/img/2024-06-22-BuildingAProxyServerInJulia_2.png)\n\n이 프로젝트에서는 새롭고 개선된 Toolips의 중대 버전을 사용할 것입니다! 이 중대 한 릴리스는 Toolips의 기본 컨셉을 달성했던 0.2와는 달리 0.3에서 컨셉을 아주 잘 달성했습니다. 시작 프로젝트도 이를 잘 반영한 것으로 생각됩니다. 그래서 새로운 앱인 ChiProxy를 생성해 보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n\n```js\nusing Toolips\nToolips.new_app(\"ChiProxy\")\n```\n\n이제 기본 프로젝트를 살펴보겠습니다.\n\n```js\nmodule ChiProxy\nusing Toolips\n\n# routes\nmain = route(\"/\") do c::Connection\n    write!(c, \"hello world!\")\nend\n\n# 404\nerr_404 = Toolips.default_404\n\nexport main, err_404\nend\n```\n\n이것을 예전 Toolips와 비교해 보면...\n\n\n<div class=\"content-ad\"></div>\n\n```js\r\nmodule ProgressTest\nusing Toolips\nusing ToolipsSession\nusing ToolipsCoolProgress\n# 새로운 Toolips 프로젝트에 오신 것을 환영합니다!\n\"\"\"\nhome(c::Connection) -> _\n--------------------\nhome 함수는 기본적으로 서버 내에서 라우트로 제공됩니다. 이를 변경하려면 아래의 start 메서드를 확인하십시오.\n\"\"\"\nfunction home(c::Connection)\n    prog = ToolipsCoolProgress.circular_progress(\"test\")\n    on(c, prog, \"click\") do cm::ComponentModifier\n        update_progress!(cm, prog, 50)\n    end\n    write!(c, p(\"helloworld\", text = \"hello world!\"))\n    write!(c, prog)\nend\n\nfourofour = route(\"404\") do c\n    write!(c, p(\"404message\", text = \"404, not found!\"))\nend\n\nroutes = [route(\"/\", home), fourofour]\nextensions = Vector{ServerExtension}([Logger(), Files(), Session(), ])\n\n\"\"\"\nstart(IP::String, PORT::Integer, ) -> ::ToolipsServer\n--------------------\nstart 함수는 WebServer를 시작합니다.\n\"\"\"\nfunction start(IP::String = \"127.0.0.1\", PORT::Integer = 8000)\n     ws = WebServer(IP, PORT, routes = routes, extensions = extensions)\n     ws.start(); ws\nend\n\n\nend # - module\r\n```\n\n이 버전은 이해하기 훨씬 쉽고, 훨씬 간결하며 — 확장부터 라우팅까지 모두 완전히 자동으로 처리됩니다. 이번 릴리스에 대한 자세한 정보가 포함된 개요를 곧 공개할 예정입니다.\n\n이 문제에 대한 내 접근 방식은 AbstractRoute 디스패치 아래에 여러 디스패치를 사용하는 것입니다. Toolips 0.3은 모듈 내에 정의된 모든 AbstractRoute을 찾아내기 때문에, 간단히 새로운 라우트 유형을 만들어서 라우트의 기능을 변경할 수 있습니다. 우리 프로젝트에서는 추상 타입 AbstractProxyRoute로 시작할 것입니다. 새로운 프로젝트로 아직 라우트를 생성하지 않을 것이며, 대신 서버 레코드를 간단하게 만들어 프록시 서버가 인식할 수 있도록 하는 기본적인 타입 시스템을 만들 것입니다.\n\n```js\r\nabstract type AbstractProxyRoute <: Toolips.AbstractRoute end\r\n```\n\n<div class=\"content-ad\"></div>\n\n## 프록시 라우트\n\n이 새로운 추상 타입을 기억하며, ProxyRoute를 상상해봅니다 — ProxyRoute에는 어떤 데이터가 필요할까요? AbstractRoute의 일관성을 확인하기 위해 ?를 사용할 수 있습니다:\n\n```js\nhelp?> Toolips.AbstractRoute\n```\n\n그래서 필요한 두 가지 일관성은 경로(path)와 route!로의 디스패치입니다. 구조를 시작해봅시다.\n\n<div class=\"content-ad\"></div>\n\n```js\nmodule ChiProxy\nusing Toolips\n\nabstract type AbstractProxyRoute <: Toolips.AbstractRoute end\n\nmutable struct ProxyRoute <: AbstractProxyRoute\n    path::String\nend\n\n# routes\nmain = route(\"/\") do c::Connection\n    write!(c, \"hello world!\")\nend\n\n# 404\nerr_404 = Toolips.default_404\n\nstart(IP::String = \"127.0.0.1\", PORT::Integer = 8000) = start!(ChiProxy, IP, PORT)\nend\n```\n\n자, 우리가 일관된 구조를 가진 라우팅을 가지게 되었으니, route!를 가져와 확장할 것입니다. route! 함수를 확장함으로써 우리는 두 가지를 할 수 있게 됩니다:\n\n- 새로운 라우터 생성.\n- 단일 라우트 기능 변경.\n\n```js\nimport Toolips: route!\n```\n\n<div class=\"content-ad\"></div>\n\n라우터 기능을 변경하려면 경로로 이동하며, 경로는 두 번 호출됩니다 - 벡터에서 한 번 호출되고, 그런 다음 다시 경로로 호출됩니다. 이에 대한 코드를 아래에서 확인하세요:\n\n```js\nmodule ChiProxy\nusing Toolips\nimport Toolips: route!\n\nabstract type AbstractProxyRoute <: Toolips.AbstractRoute end\n\nmutable struct ProxyRoute <: AbstractProxyRoute\n    path::String\nend\n\nfunction route!(c::Toolips.AbstractConnection, pr::AbstractProxyRoute)\n    write!(c, \"</br>수정된 `ProxyRoute` 페이지\")\nend\n\nfunction route!(c::Connection, vec::Vector{<:AbstractProxyRoute})\n    write!(c, Components.DOCTYPE())\n    write!(c, \"`Connection` 라우터를 수정합니다.\")\n    route!(c, pr)\nend\n```\n\n우리의 벡터는 라우트에 해당하는 높은 추상 유형으로 유지되어야 하므로 이를 기억해 주세요 - Vector'Union'... 으로 경로를 설정할 수 있습니다. 일반적으로 Julia 타입 추상화를 사용하며, AbstractRoute s의 벡터가 어떠한 특정 배열 차원인지에 따라 진행할 수 있습니다.\n\n라우트는 내보낸 경우에만 경로 설정됩니다. ProxyRoute 를 구성하고 내보내므로 이를 빠르게 테스트할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n```js\ntest = ProxyRoute(\"/\")\n```\n\n```js\nmodule ChiProxy\nusing Toolips\nimport Toolips: route!\n\nabstract type AbstractProxyRoute <: Toolips.AbstractRoute end\n\nmutable struct ProxyRoute <: AbstractProxyRoute\n    path::String\nend\n\nfunction route!(c::Toolips.AbstractConnection, pr::AbstractProxyRoute)\n    write!(c, \"</br>our modified `ProxyRoute` page\")\nend\n\nfunction route!(c::Connection, vec::Vector{<:AbstractProxyRoute})\n    write!(c, Components.DOCTYPE())\n    write!(c, \"our modified `Connection` router.\")\n            # indexing our routes with our `Connection's` route\n    route!(c, vec[get_route(c)])\nend\nmain = route(\"/\") do c::Connection\n    write!(c, \"$(c.routes)\")\nend\n\ntest = ProxyRoute(\"/\")\n# 404\nerr_404 = Toolips.default_404\n\nexport test\nend\n```\n\n이제 서버를 시작하여 라우터에 대한 메시지 하나와 Route에 대한 메시지 하나를 작성해야합니다.\n\n```js\ninclude(\"dev.jl\")\n``` \n\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-22-BuildingAProxyServerInJulia_3.png)\n\n여기서 필요한 마지막 것은 호스트입니다. 이는 get_host를 통해 얻을 수 있습니다.\n\n```js\nfunction route!(c::Toolips.AbstractConnection, pr::AbstractProxyRoute)\n    system = Toolips.get_client_system(c)\n    mobile = \"not mobile\"\n    if system[2]\n        mobile = \"mobile\"\n    end\n    write!(c, \"</br>our modified 'ProxyRoute' page<h3>host:</h3>\")\n    write!(c, get_host(c))\nend\n```\n\n![image](/assets/img/2024-06-22-BuildingAProxyServerInJulia_4.png)\n\n\n<div class=\"content-ad\"></div>\n\n이제 라우팅 시스템이 설정되었고 호스트 이름을 가지고 있으니, 기본 프록시 시스템을 확장할 수 있는 ProxyRoute의 필드를 확장할 것입니다. 이 경우에 경로가 호스트 이름이 될 것입니다. 여기서 이름의 트래픽을 리디렉트할 IP와 포트를 가져올 것입니다.\n\n```js\nabstract type AbstractProxyRoute <: Toolips.AbstractRoute end\n\nmutable struct ProxyRoute <: AbstractProxyRoute\n    path::String\n    ip::String\n    port::Int64\nend\n```\n\n새로운 필드인 ip와 port를 가지고 하위 함수를 만들어 이 유형을 쉽게 만들 것입니다.\n\n```js\nfunction proxy_route(path::String, ip::IP4)\n    ProxyRoute(path, ip.ip, ip.port)\nend\n```\n\n<div class=\"content-ad\"></div>\n\n이제 새로운 고수준 구문을 사용하여 ProxyRoute를 만들어 봅시다.\n\n```js\n테스트 = proxy_route(\"127.0.0.1:8000\", \"127.0.0.1\":8000)\n```\n\n## 기본 테스트\n\n프록시 라우터의 기본 사항을 작성했으니, 모든 데이터를 보여주고 프록시 서버가 무엇을 하는지 보여줄 기본 레이아웃을 만들어 봅시다. 다음 예제에서는 라우트된 호스트를 출력한 다음 그 호스트를 실행할 서버를 선택합니다. 여기서 기대하는 바는 127.0.0.1이 두 번 나열되는 것을 볼 수 있어야 합니다.\n\n<div class=\"content-ad\"></div>\n\n```kotlin\nfun route!(c::Toolips.AbstractConnection, pr::AbstractProxyRoute)\n    write!(c, \"<h3>선택된 서버:</h3>$(pr.path)\")\nend\n\nfun route!(c::Connection, vec::Vector{<:AbstractProxyRoute})\n    write!(c, Components.DOCTYPE())\n    write!(c, \"저희 수정된 `Connection` 라우터입니다.\")\n    write!(c, \"<h3>호스트</h3>$(get_host(c))\")\n    route!(c, vec[get_host(c)])\nend\n```\n\n![Build Proxy Server](/assets/img/2024-06-22-BuildingAProxyServerInJulia_5.png)\n\n이제 할 일은 dev.jl에서 서버 포트를 80으로 변경하는 것입니다. 이 포트는 2000 미만이므로 방화벽 구성을 위해 조치해야 합니다. Windows나 OSX에서는 이를 어떻게 해야 할지 잘 모르겠습니다. Ubuntu에서는 Ubuntu Firewall인 ufw를 사용하면 됩니다.\n\n```bash\nufw allow 80\n```\n\n<div class=\"content-ad\"></div>\n\n저는 firewalld와 Fedora 38을 사용하고 있습니다. 다른 여러 배포판들도 firewalld를 사용하기 때문에, 만약 리눅스를 사용 중이라면 이 방법이 도움이 될 수도 있습니다.\n\n```js\nfirewall-cmd --zone=public --add-port=80/tcp\n```\n\n또 다른 방법으로는 방화벽 서비스를 구성할 수도 있습니다. 이 부분에 대해서는 설명을 드리지 않겠습니다. 추가로, 방화벽을 조정하지 않고 해결할 수 있는 빠른 방법은 sudo를 사용하는 것입니다. 이를 통해 root의 Bash 프로필이 사용되므로 root의 Julia 패키지를 사용하게 됩니다. 이는 이상적이지는 않지만 테스트 목적으로는 문제 없을 수도 있습니다. 포트를 포워딩하지 않는 비공개 네트워크에 연결돼 있다면 잘 동작할 것입니다.\n\n```js\nsudo julia -L dev.jl\n```\n\n<div class=\"content-ad\"></div>\n\n이제 서버가 80 포트에서 호스팅되고 있으므로 호스트 이름을 서버의 IP 주소로 변경하려고 합니다.\n\n```js\ntest = proxy_route(\"127.0.0.1\", \"127.0.0.1\":8000)\n```\n\n```js\nfunction route!(c::Toolips.AbstractConnection, pr::AbstractProxyRoute)\n    write!(c, \"<h3>선택된 서버:</h3>$(pr.ip):$(pr.port)\")\nend\n```\n\n이제 이 서버를 사용하려면 127.0.0.1에서 접속해야 합니다 — 웹 서버가 80 포트에 있으므로 포트를 사용할 필요가 없습니다. 우리의 ProxyRoute는 그런 다음 80 포트에서 8000 포트로 우리를 리디렉션해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-22-BuildingAProxyServerInJulia_6.png)\n\n프록시 라우팅을 마무리하려면 Toolips.proxy_pass!를 사용하여 연결을 리디렉션해야 합니다. 서버가 활성화되지 않았으면 터미널에 오류가 발생할 수 있습니다.\n\n```js\nfunction route!(c::Toolips.AbstractConnection, pr::AbstractProxyRoute)\n    proxy_pass!(c, \"http://$(pr.ip):$(pr.port)\")\nend\n```\n\n이것을 기억하면 다른 포트(8000)에서 호스팅된 또 다른 서버를 만들어야 합니다. 이 서버는 이 프록시 패스에 응답할 것입니다.\n\n\n<div class=\"content-ad\"></div>\n\n\n```js\nmodule TestServer\nusing Toolips\nmain = route(\"/\") do c::Connection\n    write!(c, \"</br>this is 127.0.0.1 responding\")\nend\n\nexport main\nend\n```\n\n\n이 TestServer를 시작하려면 dev.jl을 업데이트해야 합니다. 일관성을 위해 두 파일을 살펴보겠습니다:\n\n- dev.jl\n\n```js\nusing Pkg; Pkg.activate(\".\")\nusing ChiProxy\nusing ChiProxy: TestServer\n\nChiProxy.start!(\"127.0.0.1\":80)\n\nTestServer.start!(\"127.0.0.1\":8000)\n```\n\n\n<div class=\"content-ad\"></div>\n\n- ChiProxy.jl\n\n```js\nmodule ChiProxy\nusing Toolips\nimport Toolips: route!\n\nabstract type AbstractProxyRoute <: Toolips.AbstractRoute end\n\nmutable struct ProxyRoute <: AbstractProxyRoute\n    path::String\n    ip::String\n    port::Int64\nend\n\nfunction proxy_route(path::String, ip::IP4)\n    ProxyRoute(path, ip.ip, ip.port)\nend\n\nfunction route!(c::Toolips.AbstractConnection, pr::AbstractProxyRoute)\n    Toolips.proxy_pass!(c, \"http://$(pr.ip):$(pr.port)\")\nend\n\nfunction route!(c::Connection, vec::Vector{<:AbstractProxyRoute})\n    write!(c, Components.DOCTYPE())\n    write!(c, \"our modified `Connection` router.\")\n    write!(c, \"<h3>host</h3>$(get_host(c))\")\n    route!(c, vec[get_host(c)])\nend\n\nmain = route(\"/\") do c::Connection\n    write!(c, \"$(c.routes)\")\nend\n\ntest = proxy_route(\"127.0.0.1\", \"127.0.0.1\":8000)\n# 404\nerr_404 = Toolips.default_404\n#== Test server\n==#\nmodule TestServer\nusing Toolips\n\nmain = route(\"/\") do c::Connection\n    write!(c, \"</br>this is 127.0.0.1 responding\")\nend\n\nexport main\nend\n#==\n==#\n\nexport test\nend\n```\n\n이제 다시 포트 80에서 시도해 봅시다.\n\n이제 8000번 포트의 서버가 80번 포트의 서버를 통해 응답했습니다. 다음 단계는 ProxyRoute 라우터에서 모든 쓰기를 제거하는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nmodule ChiProxy\nusing Toolips\nimport Toolips: route!\n\nabstract type AbstractProxyRoute <: Toolips.AbstractRoute end\n\nmutable struct ProxyRoute <: AbstractProxyRoute\n    path::String\n    ip::String\n    port::Int64\nend\n\nfunction proxy_route(path::String, ip::IP4)\n    ProxyRoute(path, ip.ip, ip.port)\nend\n\nfunction route!(c::Toolips.AbstractConnection, pr::AbstractProxyRoute)\n    Toolips.proxy_pass!(c, \"http://$(pr.ip):$(pr.port)\")\nend\n\nfunction route!(c::Connection, vec::Vector{<:AbstractProxyRoute})\n    route!(c, vec[get_host(c)])\nend\n\nmain = route(\"/\") do c::Connection\n    write!(c, \"$(c.routes)\")\nend\n\ntest = proxy_route(\"127.0.0.1\", \"127.0.0.1\":8000)\n# 404\nerr_404 = Toolips.default_404\n\nmodule TestServer\nusing Toolips\nmain = route(\"/\") do c::Connection\n    write!(c, \"</br>this is 127.0.0.1 responding\")\nend\n\nexport main\nend\n\nexport test\nend\n```\n\n## 결론\n\n이번 1월 초에 일들이 서두를 겪고 있습니다. 이 프록시 서버는 제가 개발할 긴 여정 중 단 한 걸음에 불과하며, DNS 서버와 함께 많은 웹 인프라를 구축하기 위한 준비를 세우고 있습니다. 물론 여전히 해야 할 일이 많습니다. 현재 우리의 프록시 서버에는 SSL도 없고 로드 밸런싱도 없으며, 여러 디스패치를 중심으로 한 이 구현에 대한 더 복잡한 계획도 있습니다.\n\n중요한 것은 Toolips의 이 전 릴리스 버전을 사용하고 있다는 점입니다. Toolips의 메인 실행 버전이 될 때까지 많은 일이 필요합니다. 이 릴리스는 전체 생태계를 파괴합니다. 다행히도, 실제로는 생각보다 더 부담스럽지 않고 이 새로운 Toolips 버전은 상당히 멋질 것입니다! 오늘 사용된 구문에서 유추하신 대로, 몇 가지 함수를 간단히 작성함으로써 Toolips용 사용자 정의 라우터를 만들 수 있습니다. Toolips가 개선된 유일한 측면이 아닙니다.\n\n<div class=\"content-ad\"></div>\n\n모두 읽어 주셔서 감사합니다. 제 웹 사이트는 곧 준비될 것이며 곧 돌아와서 로드 밸런싱 및 \"소스\"를 추가하는 이 프록시 서버의 두 번째 부분을 진행할 계획입니다. 그 후에는 파일 형식에서 프록시 설정을 불러와 완성된 프록시 서버를 갖게 될 것입니다. 다시 한 번 읽어 주셔서 감사합니다. 즐거운 하루 되세요.","ogImage":{"url":"/assets/img/2024-06-22-BuildingAProxyServerInJulia_0.png"},"coverImage":"/assets/img/2024-06-22-BuildingAProxyServerInJulia_0.png","tag":["Tech"],"readingTime":16},{"title":"GetX로 API 통합하기 Flutter를 이용한 쉬운 방법","description":"","date":"2024-06-22 04:13","slug":"2024-06-22-APIIntegrationusingGetXinflutter","content":"\n\n![APIIntegrationusingGetXinflutter](/assets/img/2024-06-22-APIIntegrationusingGetXinflutter_0.png)\n\n플러터에서 API 통합은 앱과 외부 서비스 간의 데이터 통신을 활성화하여 동적이고 실시간이며 확장 가능한 기능을 제공하고 서로 다른 플랫폼 간에 일관된 경험을 제공하는 데 중요합니다.\n\nAPI 통합은 플러터 애플리케이션이 외부 서비스와 상호 작용하고 데이터를 검색하고 다양한 기능을 수행할 수 있도록 가능하게 합니다. 다음은 플러터 개발에서 API 통합이 중요하게 간주되는 몇 가지 이유입니다:\n\n- 데이터 검색: 대부분의 애플리케이션은 데이터베이스, 서버 또는 제3자 서비스와 같은 외부 소스에서 데이터를 필요로합니다. API 통합을 통해 플러터 앱이 이러한 데이터를 동적으로 가져와 표시하므로 사용자가 항상 최신 정보에 액세스할 수 있습니다.\n- 실시간 업데이트: API를 사용하면 클라이언트(플러터 앱)와 서버 간의 실시간 통신이 가능해집니다. 이는 메시징 앱, 협업 도구 또는 실시간 데이터 피드와 같은 실시간 업데이트가 필요한 애플리케이션에 중요합니다.\n- 오프라인 지원: API는 장치에 로컬로 정보를 캐싱하여 오프라인 데이터 액세스를 지원할 수 있도록 설계될 수 있습니다. 이는 일시적이거나 인터넷 연결이 없는 환경에서 기능해야 하는 애플리케이션에 중요합니다.\n- 보안: API는 종종 인증 메커니즘을 통합하여 특정 데이터에만 인가된 사용자만이 액세스하거나 특정 작업을 수행할 수 있도록합니다. 이는 응용프로그램 및 데이터의 보안 유지에 도움이 됩니다.\n\n<div class=\"content-ad\"></div>\n\n## Android Studio에 JsonToDart 플러그인 설치하기\n\n플러그인: [JsonToDart](https://plugins.jetbrains.com/plugin/12562-jsontodart-json-to-dart-)\n\n## HTTP 패키지 추가하기\n\nHTTP 요청을 하기 위해 pubspec.yaml 파일에 http 패키지를 추가하고 flutter pub get을 실행하세요.\n\n<div class=\"content-ad\"></div>\n\n## Getx 패키지 추가하기\n\nGetX는 플러터를 위한 가벼우면서 강력한 솔루션입니다. 높은 성능의 상태 관리, 지능적인 의존성 주입, 빠르고 실용적인 라우트 관리를 결합하고 있습니다. GetX를 사용하려면 flutter pub add get 명령어를 실행하세요.\n\n## main.dart 파일에 GetMaterialApp 추가하기\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:get/get.dart'; // Get 패키지 가져오기\nimport 'UserListScreens.dart'; // 화면 파일 import하기\n\nvoid main() {\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({Key key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return GetMaterialApp(\n      debugShowCheckedModeBanner: false,\n      title: 'Flutter Demo',\n      theme: ThemeData(\n        colorScheme: ColorScheme.fromSwatch(primary: Colors.deepPurple), // 주요 색상 deepPurple로 설정\n        useMaterial3: false,\n      ),\n      home: const UserListScreen(), // 처음 화면으로 UserListScreen 표시\n    );\n  }\n}\n```  \n\n<div class=\"content-ad\"></div>\n\n## APIConstant 클래스 생성\n\n```dart\nimport 'dart:io';\n\nclass APIConstant {\n  \n  static const url = 'https://reqres.in/api/users?page=2';\n\n  static Map<String, String> authHeader = {\n    HttpHeaders.contentTypeHeader: 'application/json; charset=UTF-8'\n  };\n\n}\n```\n\n## UserModels 클래스 생성\n\n```dart\nclass UserModels {\n  UserModels({\n    num? page, \n    num? perPage, \n    num? total, \n    num? totalPages, \n    List<Data>? data, \n    Support? support,\n  }) {\n    _page = page;\n    _perPage = perPage;\n    _total = total;\n    _totalPages = totalPages;\n    _data = data;\n    _support = support;\n  }\n\n  UserModels.fromJson(dynamic json) {\n    _page = json['page'];\n    _perPage = json['per_page'];\n    _total = json['total'];\n    _totalPages = json['total_pages'];\n    if (json['data'] != null) {\n      _data = [];\n      json['data'].forEach((v) {\n        _data?.add(Data.fromJson(v));\n      });\n    }\n    _support = json['support'] != null ? Support.fromJson(json['support']) : null;\n  }\n\n  num? _page;\n  num? _perPage;\n  num? _total;\n  num? _totalPages;\n  List<Data>? _data;\n  Support? _support;\n\n  UserModels copyWith({\n    num? page,\n    num? perPage,\n    num? total,\n    num? totalPages,\n    List<Data>? data,\n    Support? support,\n  }) => UserModels(  \n    page: page ?? _page,\n    perPage: perPage ?? _perPage,\n    total: total ?? _total,\n    totalPages: totalPages ?? _totalPages,\n    data: data ?? _data,\n    support: support ?? _support,\n  );\n\n  num? get page => _page;\n  num? get perPage => _perPage;\n  num? get total => _total;\n  num? get totalPages => _totalPages;\n  List<Data>? get data => _data;\n  Support? get support => _support;\n\n  Map<String, dynamic> toJson() {\n    final map = <String, dynamic>{};\n    map['page'] = _page;\n    map['per_page'] = _perPage;\n    map['total'] = _total;\n    map['total_pages'] = _totalPages;\n    if (_data != null) {\n      map['data'] = _data?.map((v) => v.toJson()).toList();\n    }\n    if (_support != null) {\n      map['support'] = _support?.toJson();\n    }\n    return map;\n  }\n\n}\n\nclass Support {\n  Support({\n    String? url,\n    String? text,\n  }) {\n    _url = url;\n    _text = text;\n  }\n\n  Support.fromJson(dynamic json) {\n    _url = json['url'];\n    _text = json['text'];\n  }\n\n  String? _url;\n  String? _text;\n\n  Support copyWith({\n    String? url,\n    String? text,\n  }) => Support(  \n    url: url ?? _url,\n    text: text ?? _text,\n  );\n\n  String? get url => _url;\n  String? get text => _text;\n\n  Map<String, dynamic> toJson() {\n    final map = <String, dynamic>{};\n    map['url'] = _url;\n    map['text'] = _text;\n    return map;\n  }\n\n}\n\nclass Data {\n  Data({\n    num? id,\n    String? email,\n    String? firstName,\n    String? lastName,\n    String? avatar,\n  }) {\n    _id = id;\n    _email = email;\n    _firstName = firstName;\n    _lastName = lastName;\n    _avatar = avatar;\n  }\n\n  Data.fromJson(dynamic json) {\n    _id = json['id'];\n    _email = json['email'];\n    _firstName = json['first_name'];\n    _lastName = json['last_name'];\n    _avatar = json['avatar'];\n  }\n\n  num? _id;\n  String? _email;\n  String? _firstName;\n  String? _lastName;\n  String? _avatar;\n\n  Data copyWith({\n    num? id,\n    String? email,\n    String? firstName,\n    String? lastName,\n    String? avatar,\n  }) => Data(  \n    id: id ?? _id,\n    email: email ?? _email,\n    firstName: firstName ?? _firstName,\n    lastName: lastName ?? _lastName,\n    avatar: avatar ?? _avatar,\n  );\n\n  num? get id => _id;\n  String? get email => _email;\n  String? get firstName => _firstName;\n  String? get lastName => _lastName;\n  String? get avatar => _avatar;\n\n  Map<String, dynamic> toJson() {\n    final map = <String, dynamic>{};\n    map['id'] = _id;\n    map['email'] = _email;\n    map['first_name'] = _firstName;\n    map['last_name'] = _lastName;\n    map['avatar'] = _avatar;\n    return map;\n  }\n\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## UserListController 클래스 생성 및 GetxController를 상속받도록 클래스 확장\n\n```dart\nimport 'dart:async';\nimport 'dart:convert';\nimport 'dart:io';\nimport 'package:flutter/cupertino.dart';\nimport 'package:http/http.dart' as http;\nimport 'package:get/get.dart';\nimport 'package:post_project/Models/UserModels.dart';\nimport '../APIConstant.dart';\n\nclass UserListController extends GetxController implements GetxService {\n\n  var isLoading = true.obs;\n  var getUserList = <Data>[].obs;\n\n  @override\n  void onInit() {\n    super.onInit();\n    userList();\n  }\n\n  Future<dynamic> userList() async {\n    try {\n      final response = await http.get(\n        Uri.parse(APIConstant.url),\n        headers: APIConstant.authHeader,\n      );\n      debugPrint(\"UserList\");\n      debugPrint(response.body);\n      const utf8Decoder = Utf8Decoder(allowMalformed: true);\n      final decodedBytes = utf8Decoder.convert(response.bodyBytes);\n      Map<String, dynamic> responseBody = json.decode(decodedBytes);\n      if (response.statusCode == 200) {\n        isLoading.value = false;\n        UserModels model = UserModels.fromJson(responseBody);\n        getUserList.value = model.data!;\n      }\n    } on TimeoutException catch (e) {\n      isLoading.value = false;\n      debugPrint(e.toString());\n    } on SocketException catch (e) {\n      isLoading.value = false;\n      debugPrint(e.toString());\n    } on Error catch (e) {\n      isLoading.value = false;\n      debugPrint(e.toString());\n    } catch (e) {\n      debugPrint(e.toString());\n    }\n    return null;\n  }\n\n}\n```\n\n## listView를 위한 UserItems 위젯 작성\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:post_project/Models/UserModels.dart';\n\nclass UserItems extends StatelessWidget {\n\n  final Data data;\n  const UserItems({Key key, required this.data});\n\n  @override\n  Widget build(BuildContext context) {\n    return Padding(\n      padding: const EdgeInsets.all(8.0),\n      child: Container(\n        decoration: BoxDecoration(border: Border.all(color: Colors.black)),\n        child: Row(\n          children: [\n            SizedBox(\n              height: 100,\n              width: 70,\n              child: Image.network(\n                data.avatar.toString(),\n                fit: BoxFit.cover,\n              ),\n            ),\n            Padding(\n              padding: const EdgeInsets.all(15.0),\n              child: Column(\n                crossAxisAlignment: CrossAxisAlignment.start,\n                children: [\n                  Text(\n                    \"${data.firstName} ${data.lastName}\",\n                    style: const TextStyle(\n                        fontSize: 20, fontWeight: FontWeight.w600),\n                  ),\n                  const SizedBox(height: 5),\n                  Text(data.email.toString()),\n                ],\n              ),\n            )\n          ],\n        ),\n      ),\n    );\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## 이렇게 GetxController를 호출하세요\n\n```js\nfinal userListController = Get.put(UserListController(), permanent: true);\n```\n\n## UserListScreen 클래스를 생성하세요\n\n전체 코드:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\nimport 'package:get/get.dart';\nimport 'package:post_project/Controller/UserListController.dart';\nimport 'package:post_project/UserItems.dart';\n\nclass UserListScreen extends StatefulWidget {\n  const UserListScreen({super.key});\n\n  @override\n  State<UserListScreen> createState() => _UserListScreenState();\n}\n\nclass _UserListScreenState extends State<UserListScreen> {\n\n  final userListController = Get.put(UserListController(),permanent: true);\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        systemOverlayStyle: const SystemUiOverlayStyle(\n          statusBarColor: Colors.green,\n          statusBarIconBrightness: Brightness.dark, // For Android (dark icons)\n          statusBarBrightness: Brightness.light, // For iOS (dark icons)\n        ),\n        titleSpacing: 5,\n        centerTitle: false,\n        elevation: 0,\n        automaticallyImplyLeading: false,\n        backgroundColor: Colors.green,\n        title: const Text(\"User List\",\n            style: TextStyle(\n                fontSize: 18,\n                color: Colors.white,\n                fontWeight: FontWeight.w600)),\n      ),\n      body: Column(\n        children: [\n          Expanded(\n            child: Obx(() {\n              return userListController.getUserList.isEmpty\n                  ? const Center(\n                      child: Text(\"data\"),\n                    )\n                  : ListView.builder(\n                      shrinkWrap: true,\n                      itemCount: userListController.getUserList.length,\n                      itemBuilder: (BuildContext context, int index) {\n                        return UserItems(\n                            data: userListController.getUserList[index]);\n                      });\n            }),\n          )\n        ],\n      ),\n    );\n  }\n}\n```\n\n## 스크린샷:\n\n<img src=\"/assets/img/2024-06-22-APIIntegrationusingGetXinflutter_1.png\" />\n\n## 소스 코드:\n\n<div class=\"content-ad\"></div>\n\nGitHub 링크: [https://github.com/sanjaysharmajw/UserList](https://github.com/sanjaysharmajw/UserList)\n\n## 저와 소통해요:\n\n- LinkedIn: [https://www.linkedin.com/in/sanjaydeveloper/](https://www.linkedin.com/in/sanjaydeveloper/)\n- Instagram: [https://www.instagram.com/sanjayjw/](https://www.instagram.com/sanjayjw/)\n\n![이미지](/assets/img/2024-06-22-APIIntegrationusingGetXinflutter_2.png)\n\n<div class=\"content-ad\"></div>\n\n이 기사를 즐겨 보셨기를 바라요! 제공된 정보를 감사하게 생각하신다면, 'Buy Me A Coffee'로 저를 지원할 수 있어요! 여러분의 작은 선행에 감사하겠습니다!","ogImage":{"url":"/assets/img/2024-06-22-APIIntegrationusingGetXinflutter_0.png"},"coverImage":"/assets/img/2024-06-22-APIIntegrationusingGetXinflutter_0.png","tag":["Tech"],"readingTime":12},{"title":"강력한 저코드 Flutter IDE, Blup 소개하기","description":"","date":"2024-06-22 04:12","slug":"2024-06-22-IntroductiontoBlupAPowerfulLow-CodeFlutterIDE","content":"\n\n![블로그 시리즈](/assets/img/2024-06-22-IntroductiontoBlupAPowerfulLow-CodeFlutterIDE_0.png)\n\n# 소개\n\nBlup에 관한 우리의 블로그 시리즈에 오신 것을 환영합니다. Blup는 혁신적인 Low-Code Flutter IDE로 앱 개발 방식을 혁신하고 있습니다. 이 시리즈에서는 Blup의 기능, 장점, 그리고 이 강력한 도구를 사용하여 첫 번째 Flutter 앱을 만드는 방법에 대해 안내해 드리겠습니다.\n\n## Blup 개요\n\n<div class=\"content-ad\"></div>\n\nBlup은 플러터 앱 개발을 보다 간편하고 빠르게 만들 수 있도록 설계된 시각적 개발 환경입니다. 직관적인 드래그 앤 드롭 인터페이스를 통해 Blup을 사용하면 깊은 코딩 지식이 없어도 복잡한 애플리케이션을 만들 수 있습니다. Blup을 활용하여 개발자들은 창의성과 기능성에 집중할 수 있어 아이디어를 현실로 구현하는 데 필요한 시간과 노력을 줄일 수 있습니다.\n\n## 플러터 개발을 위해 Blup을 선택하는 이유\n\nBlup은 사용자 친화적인 디자인, 강력한 기능 및 기존 프로젝트와 원활하게 통합할 수 있는 능력으로 플러터 개발의 최상위 선택지로 자리매깁니다. 경험 많은 개발자든 앱 개발 초보든, Blup은 작업 흐름과 생산성을 향상시킬 도구와 자원을 제공합니다.\n\n# Blup이란 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\nBlup은 Flutter를 위해 특별히 설계된 로우코드 개발 환경입니다. Flutter는 구글이 제공하는 인기 있는 오픈소스 UI 소프트웨어 개발 키트입니다. Blup을 사용하면 시각적 드래그 앤 드롭 인터페이스와 미리 제공된 구성 요소 및 템플릿을 활용하여 최소한의 코딩 노력으로 크로스 플랫폼 모바일 애플리케이션을 만들 수 있습니다.\n\nBlup의 주요 기능:\n\n- 드래그 앤 드롭 인터페이스: UI 요소를 시각적으로 정렬하여 디자인 프로세스를 간소화합니다.\n- 미리 제공된 구성 요소 및 템플릿: 개발을 가속화하기 위해 다양한 사용 준비된 구성 요소를 제공합니다.\n- 실시간 협업: 여러 사용자가 동시에 동일한 프로젝트에 작업할 수 있도록 팀워크를 촉진합니다.\n- 기존 Flutter 프로젝트 통합: 현재의 Flutter 프로젝트와 원활하게 통합되어 처음부터 다시 시작하지 않고 발전시킵니다.\n- 코드 생성 및 사용자 정의: 시각적 디자인을 기반으로 자동으로 코드를 생성하고, 더 나은 특정 요구 사항을 충족시키기 위해 사용자 정의할 수 있습니다.\n\n다른 로우코드 플랫폼과 비교했을 때, Blup은 Flutter에 특별히 초점을 맞추어 Flutter 개발자들을 위한 최적화된 환경을 제공하여 눈에 띕니다. 이러한 초점은 플랫폼이 항상 최신의 Flutter 기능과 모베스트 프랙티스로 유지됨을 보장합니다.\n\n<div class=\"content-ad\"></div>\n\n# 다른 Low-Code 플랫폼과 비교\n\n![이미지](/assets/img/2024-06-22-IntroductiontoBlupAPowerfulLow-CodeFlutterIDE_1.png)\n\nBlup은 일반적인 Low-Code 도구와 다르게 Google이 개발한 인기 있는 오픈 소스 UI 소프트웨어 개발 키트인 Flutter에 중점을 두고 있어요. 일반적인 Low-Code 도구와 달리 Blup은 Flutter에 최적화되어 있어 Flutter 앱 개발에 더 관련성 있고 효율적인 기능을 제공해요.\n\n## Blup를 사용하는 이유\n\n<div class=\"content-ad\"></div>\n\n- 속도와 효율성: Blup은 많은 코딩 작업을 자동화하여 애플리케이션을 개발하고 배포하는 데 필요한 시간을 크게 단축합니다.\n- 접근성: Blup은 비개발자들에게 애플리케이션 개발을 접근 가능하게 하여 진입 장벽을 낮추고 더 많은 사람들이 기능적이고 시각적으로 매력적인 앱을 만들 수 있도록 합니다.\n- 유연성: 기존 프로젝트와 통합하고 코드를 사용자 정의할 수 있는 기능으로 Blup은 간편함과 유연성을 제공하여 다양한 사용자 요구를 충족합니다.\n\n# Blup의 주요 기능\n\n![Blup 소개 이미지](/assets/img/2024-06-22-IntroductiontoBlupAPowerfulLow-CodeFlutterIDE_2.png)\n\n기존 플러터 프로젝트와 통합\n\n<div class=\"content-ad\"></div>\n\nBlup은 플러터 앱 개발을 더 빠르고 쉽고 효율적으로 만들기 위해 설계된 다양한 기능으로 가득합니다. Blup을 개발자들이 최상의 선택으로 만드는 이유를 자세히 살펴보겠습니다:\n\n## 드래그 앤 드롭 인터페이스\n\n드래그 앤 드롭 인터페이스는 Blup의 핵심 요소로, 사용자가 복잡한 사용자 인터페이스를 방대한 코드를 작성하지 않고도 만들 수 있습니다. 구성 요소 라이브러리에서 요소를 간단히 드래그하여 디자인 캔버스에 놓아 원하는 위치에 정확히 배치할 수 있습니다.\n\n## 사전 제작된 구성 요소와 템플릿\n\n<div class=\"content-ad\"></div>\n\nBlup는 기본 UI 요소인 버튼과 텍스트 필드부터 내비게이션 서랍과 데이터 테이블과 같은 복잡한 구조물까지 다양한 미리 만들어진 구성 요소 및 템플릿 라이브러리를 제공합니다. 이러한 템플릿은 완전히 사용자 정의할 수 있어 프로젝트의 요구에 맞게 조정할 수 있습니다.\n\n## 실시간 협업 도구\n\nBlup는 실시간 협업을 지원하여 팀에게 최적의 선택지가 됩니다. 여러 개발자가 동시에 동일한 프로젝트에 작업할 수 있으며 서로의 변경 사항을 실시간으로 볼 수 있습니다. 이 기능은 생산성을 크게 향상시키며 모든 팀원이 동일한 페이지에 있는지 확인합니다.\n\n## 기존 Flutter 프로젝트 통합\n\n<div class=\"content-ad\"></div>\n\nBlup의 뛰어난 기능 중 하나는 기존 Flutter 프로젝트와 완벽하게 통합할 수 있는 능력입니다. 이는 Blup의 도구로 현재 프로젝트를 새로 시작하지 않고도 향상시킬 수 있음을 의미합니다. 시간과 노력을 절약할 수 있습니다.\n\n## 코드 생성 및 사용자 정의 옵션\n\nBlup은 시각적 디자인을 기반으로 청결하고 유지보수가 쉬운 코드를 자동으로 생성합니다. 이 코드는 추가적으로 사용자 정의할 수 있어서 로우코드 개발의 속도와 전통적 코딩의 유연성을 모두 누릴 수 있습니다.\n\n# Blup이 게임 체인저인 이유\n\n<div class=\"content-ad\"></div>\n\n블럽은 플러터 개발자에게 반드시 가져야 할 도구로서 여러 혁신적인 혜택을 제공합니다:\n\n## 앱 개발 속도 및 효율성\n\nBlup은 UI 디자인 과정을 간단하게 만들고 다양한 미리 제작된 구성 요소를 제공함으로써 앱을 구축하는 데 필요한 시간을 크게 단축시킵니다. 개발자들은 반복적인 코딩 작업에 시간을 허비하는 대신 기능과 사용자 경험에 더 집중할 수 있습니다.\n\n## 비 개발자를 위한 진입 장벽 낮추기\n\n<div class=\"content-ad\"></div>\n\nBlup의 직관적인 인터페이스는 개발자가 아닌 사람들에게 접근하기 쉽게 만들어 디자이너, 프로젝트 매니저 및 다른 이해 관계자들이 앱 개발 프로세스에 직접 참여할 수 있습니다. 이 앱 개발의 민주화는 혁신과 협업을 위한 새로운 가능성을 열어줍니다.\n\n## 사례 연구 또는 성공 스토리\n\nBlup은 이미 수많은 성공 이야기로 그 가치를 입증했습니다. 예를 들어, 작은 스타트업이 Blup을 활용하여 MVP(Minimum Viable Product)를 단 몇 주 만에 개발해 출시 기간을 크게 단축하고 빠르게 사용자 피드백을 수집하고 제품을 개선할 수 있었습니다.\n\n또 다른 예로는 대규모 기업이 내부 앱 개발 프로세스를 간소화하기 위해 Blup을 도입하여 생산성이 40% 향상되고 개발 비용이 30% 감소한 사례가 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\nBlup은 고급 기능과 사용 편의성을 결합한 강력한 로우코드 IDE를 제공하여 Flutter 앱 개발을 혁신할 준비가 되어 있습니다. 생산성을 높이고 싶은 베테랑 개발자이든 앱 개발에 빠져들고 싶은 초보자이든 Blup은 성공을 거두기 위해 필요한 도구와 유연성을 제공합니다.\n\n저희 시리즈의 다음 부분을 기대해주시기 바랍니다. Blup의 인터페이스를 탐험하는 방법과 설정 프로세스를 안내해 드릴 것입니다. Blup을 사용하면 아름답고 기능적인 Flutter 앱을 만드는 것이 이제보다 쉬워집니다.","ogImage":{"url":"/assets/img/2024-06-22-IntroductiontoBlupAPowerfulLow-CodeFlutterIDE_0.png"},"coverImage":"/assets/img/2024-06-22-IntroductiontoBlupAPowerfulLow-CodeFlutterIDE_0.png","tag":["Tech"],"readingTime":5},{"title":"Flutter에서 Go Router를 사용해 타입-안전 내비게이션 구현하는 방법","description":"","date":"2024-06-22 04:10","slug":"2024-06-22-HowtoImplementType-SafeNavigationwithGoRouterinFlutter","content":"\n\n## Flutter에서 안전한 탐색: Go Router 및 Go Router Builder와 함께하는 가이드\n\n<img src=\"/assets/img/2024-06-22-HowtoImplementType-SafeNavigationwithGoRouterinFlutter_0.png\" />\n\n# 배경\n\n타입 안전한 네비게이션을 사용하면 탐색 로직이 일관되고 유지보수가 용이해지며 디버깅 및 향후 코드 수정이 상당히 간단해집니다.\n\n<div class=\"content-ad\"></div>\n\n이 기술은 웹용 Flutter 앱을 구축할 때 특히 유용합니다. URL을 원활하게 관리하고 부드러운 네비게이션 경험을 보장해줍니다.\n\n이 블로그에서는 go_router 및 go_router_builder 패키지를 사용하여 Flutter에서 유형 안전한 네비게이션을 구현하는 방법을 살펴볼 것입니다.\n\n종료까지, 유형 안전한 라우트 설정, 코드 생성 및 Flutter 애플리케이션에서 네비게이션을 관리하는 방법에 대해 포괄적으로 이해하게 될 것입니다.\n\n# 소개\n\n<div class=\"content-ad\"></div>\n\n타입 안전한 네비게이션을 사용하면 네비게이션 로직이 일관되고 오류가 없음을 보장합니다.\n\n매개변수를 잘못 구문 분석하거나 경로 이름과 매개변수에 오타를 쓰는 위험을 제거하여 코드를 유지 관리하기 쉽고 디버깅하기 쉬운 상태로 유지할 수 있습니다.\n\n웹을 대상으로 하는 플러터 앱을 개발할 때 타입 안전한 네비게이션을 사용하여 URL을 쉽게 관리할 수 있습니다.\n\n이 블로그를 통해 최종적으로 얻을 것은 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n마크다운 형식으로 테이블 태그를 변경해주세요.\n\n<div class=\"content-ad\"></div>\n\n우리는 우리가 반복적으로 하는 것이다. 훌륭함은 행위가 아니라 습관이다. Justly를 시도해보고 오늘부터 당신의 습관을 만들어보세요!\n\n# 시작해봅시다\n\n전체를 5단계로 나눠서 더 잘 이해할 수 있도록 설명해 드리겠습니다.\n\n## 단계 1: 의존성 추가\n\n<div class=\"content-ad\"></div>\n\n프로젝트의 pubspec.yaml 파일에 종속성을 추가해주세요.\n\n```yaml\ndependencies:\n  # Router API 기반의 내비게이션을 활용하기 위해 필요합니다.\n  go_router: <최신 버전> \n\ndev_dependencies:\n  # go_router와 함께 타입 안전한 경로를 생성하기 위한 도구입니다.\n  go_router_builder: <최신 버전>\n  # go_router_builder의 코드 생성을 실행하는 도구입니다.\n  build_runner: <최신 버전>\n```\n\n## 단계 2: 경로 정의\n\n이제 각 화면에 대한 클래스를 만들어 GoRouteData로 확장하고, 최상위 경로에 @TypedGoRoute() 주석을 추가해주세요.\n\n<div class=\"content-ad\"></div>\n\n모든 클래스를 하나의 파일에 작성하여 코드 생성을 보다 쉽게 할 수 있도록 해 보세요.\n\n```js\n@TypedGoRoute<HomeRoute>(\n  path: '/',\n  routes: [\n    TypedGoRoute<ItemDetailsRoute>(path: 'items/:id')\n  ],\n) \nclass HomeRoute extends GoRouteData {\n  @override\n  Widget build(BuildContext context, GoRouterState state) \n    => const HomeScreen();\n}\n\nclass ItemDetailsRoute extends GoRouteData {\n  final String id;\n  const ItemDetailsRoute({required this.id});\n\n  @override\n  Widget build(BuildContext context, GoRouterState state) =>\n      ItemDetailsScreen(id: id);\n}\n\n@TypedGoRoute<SignInRoute>(\n  path: '/sign-in',\n  routes: [\n    TypedGoRoute<VerifyOtpRoute>(path: \"verify\"),\n  ], \n)\nclass SignInRoute extends GoRouteData {\n  @override\n  Widget build(BuildContext context, GoRouterState state) =>\n      const SignInScreen();\n}\n\nclass VerifyOtpRoute extends GoRouteData {\n  final String $extra;\n\n  const VerifyOtpRoute({required this.$extra});\n\n  @override\n  Widget build(BuildContext context, GoRouterState state) => \n     VerifyOtpScreen(verificationId: $extra);\n}\n```\n\n이 코드에서는 각 화면에 대한 클래스를 GoRouteData를 확장하고 TypedGoRoute로 주석 처리하여 생성했습니다. 또 다른 화면으로 데이터를 전달하기도 했습니다.\n\n자세히 살펴보겠습니다.\n\n<div class=\"content-ad\"></div>\n\nGoRouteData: GoRouteData은 화면이나 페이지를 반환하거나 사용자를 다른 페이지로 리디렉션하는 메서드를 오버라이드할 수 있는 추상 클래스입니다. 이 메서드들 중 하나를 반드시 사용해야 합니다.\n\n```js\nclass HomeRoute extends GoRouteData {\n\n  // 이렇게 parentNavigationKey를 정의할 수 있습니다. (선택 사항)\n  static final GlobalKey<NavigatorState> $parentNavigatorKey = rootNavigatorKey;\n\n  @override\n  Widget build(BuildContext context, GoRouterState state) {\n    // 여기서 반환된 위젯은 사용자가 이 경로로 이동할 때 표시됩니다.\n    return const HomeScreen();\n}\n  \n  @override\n  Page<void> buildPage(BuildContext context, GoRouterState state) {\n    // 여기서 반환된 Page는 사용자가 이 경로로 이동할 때 표시됩니다.\n    // 여기서 CustomTransitionPage를 반환하여 페이지 전환을 설정할 수도 있습니다.\n    return const CupertinoPage(child: HomeScreen());\n  }\n\n  @override\n  String? redirect(BuildContext context, GoRouterState state){\n      // 여기서 이 경로로 이동할 때 사용자를 리디렉션해야 할 위치나 경로를 지정할 수 있습니다.\n      return \"/login\";\n      // 리디렉션을 막으려면 null을 반환하세요.\n  }\n}\n```\n\nTypedGoRoute: TypedGoRoute 어노테이션은 경로 트리를 정의하는 데 사용됩니다. 맨 위 수준 경로 클래스마다 TypedGoRoute를 사용하여 경로 목록을 생성해야 합니다.\n\n```js\n@TypedGoRoute<TopLevelRoute>(\n  path: '/top-level-route-path',\n  routes: [\n    // 여기에 서브 루트 어노테이션을 이렇게 정의할 수 있습니다.\n    TypedGoRoute<SubRoute>(\n        path: 'sub-route-path'\n        routes: []\n        name: 'sub route'\n    )\n  ],\n  name: 'top level route' // 선택 사항\n)\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n@TypedGoRoute<MyRouteGeneric>()\n```\n\n이제 쿼리 매개변수, 경로 매개변수 및 라우트에서 추가 매개변수를 어떻게 사용할 수 있는지 알아봅시다.\n\n경로 매개변수:\n\n- 경로 매개변수는 : 기호를 사용하여 라우트 경로 내에 정의됩니다 (예: /products/:id).\n- URL 구조의 특정 부분을 나타냅니다.\n\n<div class=\"content-ad\"></div>\n\n쿼리 매개변수:\n\n- URL 뒤에 ? 기호를 붙여 데이터를 추가합니다 (예: /products?category=electronics).\n- 요청을 수정하는 선택적인 필터와 같은 데이터에 사용됩니다.\n\n추가: 경로나 쿼리 매개변수로 캡처되지 않는 경로로 데이터를 전달하는 방법, 추가 개체를 전달할 수 있습니다.\n\n```js\n@TypedGoRoute<ProductDetailsRoute>(path: '/details/:id')\nclass ProductDetailsRoute extends GoRouteData {\n  // path에 정의된 변수 이름이 경로 매개변수로 사용됩니다.\n  final String id; \n\n  // path에 정의되지 않은 변수 이름은 쿼리 매개변수로 사용됩니다.\n  final String code;\n\n  // 추가 데이터를 사용하려면 변수 이름을 $extra로 설정해야 합니다.\n  final String $extra;\n  \n  const ProductDetailsRoute({required this.id, required this.code, required this.$extra});\n\n  @override\n  Widget build(BuildContext context, GoRouterState state) =>\n      ProductDetails(pathParameterId: id, queryParameterCode:code, extraData: $extra);\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## 단계 3: 코드 생성\n\n루트를 정의한 후에는 루트 목록과 확장을 생성해야 합니다. 이를 위해 build_runner를 사용해야 합니다.\n현재 파일에 생성된 파일 파트를 추가해 보겠습니다.\n\n```js\npart 'routes.g.dart'; //part '<current-file>.g.dart';\n```\n\n이제 build_runner 명령어를 실행해 봅시다.\n\n<div class=\"content-ad\"></div>\n\n```dart\ndart run build_runner build --delete-conflicting-outputs\n```\n\n현재 파일 디렉토리에 routes.g.dart 파일이 생성됩니다.\n\n## 단계 4: GoRouter 초기화\n\n이제 $appRoutes를 routes에 전달할 수 있으며, 생성된 location getter를 사용하여 정확한 경로 위치를 가져올 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```dart\n최종 라우터는 GoRouter(\n  initialLocation: HomeRoute().location, // location getter is generated.\n  //$appRoutes is generated\n  routes: $appRoutes,\n  redirect: (context, state) { // Optional\n    // 여기서 경로 위치를 반환하여 리디렉션이 가능합니다.\n    // 또한 사용자가 검색 URL을 통해 화면으로 이동하는 것을 방지할 수도 있습니다.\n    // 리디렉트를 방지하려면 null을 반환합니다.\n  }\n  errorBuilder: (context, e) => ErrorScreen(e), // Optional\n  navigatorKey: rootNavigationKey, //Optional\n);\n```\n\n## 단계 5: 다른 화면으로 이동\n\n이제 라우트를 설정했으니, 다른 화면으로 이동하는 네비게이션 방법을 살펴봅시다.\n\n## Go:\n\n<div class=\"content-ad\"></div>\n\n현재 화면 스택을 주어진 경로 대상으로 교체해주세요.\n\n```js\nawait Screen2Route(id: id).go(context);\n```\n\n![이미지](https://miro.medium.com/v2/resize:fit:1000/1*ZO9gaACCAYOszpSV1_gbKQ.gif)\n\n## 푸시:\n\n<div class=\"content-ad\"></div>\n\n페이지 스택에 위치를 푸시하세요.\n\n```js\nawait Screen2Route(id: id).push(context);\n\n// push 과정에서 값 반환도 가능합니다\nfinal result = await Screen2Route(id: id).push(context);\n```\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1000/1*_xSN1WMXDp7Oc92CBl6HMA.gif\" />\n\n## Push Replacement:\n\n<div class=\"content-ad\"></div>\n\n가장 위에 있는 페이지 스택을 해당 URL 위치로 대체합니다.\n\n```js\nawait Screen2Route(id: id).pushReplacement(context);\n```\n\n![이미지](https://miro.medium.com/v2/resize:fit:1000/1*GNaChKuABcE4PejKUFFe9A.gif)\n\n## 대체:\n\n<div class=\"content-ad\"></div>\n\n가장 상단의 스택 페이지를 주어진 페이지로 교체하지만, 동일한 페이지로 취급합니다.\n\n```js\nawait Screen2Route(id: id).replace(context);\n```\n\n![이미지](https://miro.medium.com/v2/resize:fit:1000/1*_S9SyTnfBPEFAUMNloXz1g.gif)\n\n이제 네비게이션 구현을 마쳤습니다. 👏\n\n<div class=\"content-ad\"></div>\n\n\n![image](https://miro.medium.com/v2/resize:fit:1000/0*QwBEMwvqVkuL2OUM.gif)\n\nNow, let’s take a look at how we can implement a shell route with type-safe navigation using go_router and go_router_builder.\n\n## Related Articles\n\nWe're grateful to have you on this journey with us!\n\n\n<div class=\"content-ad\"></div>\n\n만약 읽은 내용이 마음에 드신다면, 아래에 👏 👏👏를 꼭 눌러주시기 바랍니다. 작가로서 이것은 정말 소중한 일이에요!\n\n아래 댓글 섹션에서 의견을 공유해주세요. 여러분의 의견은 콘텐츠를 더욱 풍부하고 가치 있는 것으로 만들어주며, 더 많은 유익한 기사를 작성할 동기를 얻게 해줍니다.\n\n흥미로운 기사 업데이트를 받으시려면 Canopas를 팔로우해주세요!","ogImage":{"url":"/assets/img/2024-06-22-HowtoImplementType-SafeNavigationwithGoRouterinFlutter_0.png"},"coverImage":"/assets/img/2024-06-22-HowtoImplementType-SafeNavigationwithGoRouterinFlutter_0.png","tag":["Tech"],"readingTime":8}],"page":"2","totalPageCount":24,"totalPageGroupCount":2,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}