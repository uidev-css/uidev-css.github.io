{"pageProps":{"post":{"title":"플러터에서 BloC 패턴으로 Fetch API 사용 방법","description":"","date":"2024-06-21 22:39","slug":"2024-06-21-FetchAPIWithBloCinFlutter","content":"\n\n이 문서에서는 블록 라이브러리를 사용하여 HTTP 요청을 수행하고 애플리케이션의 상태를 관리하는 방법을 살펴보겠습니다. 최종 애플리케이션은 다음과 같습니다:\n\n![애플리케이션 데모](https://miro.medium.com/v2/resize:fit:576/1*amzYfYKgiZ8zpehBTVcx4w.gif)\n\n앱이 처음 실행될 때, 서버에서 데이터를 가져올 때 로딩 표시기가 표시됩니다. 데이터를 가져온 후에는 목록에 표시됩니다.\n\n이를 위해 몇 가지 패키지를 사용하겠습니다:\n\n<div class=\"content-ad\"></div>\n\n```yaml\ndependencies:\n  flutter_bloc: ^8.1.1\n  http: ^0.13.5\n  equatable: ^2.0.5\n```\n\n이제 API를 사용하여 서버에서 데이터를 가져오는 메커니즘을 만들어 보겠습니다. http 작업을 수행하기 위해 lib 내부에 폴더를 생성하고 repo라는 이름으로 지정합니다. 이 repo 내부에 repositories.dart라는 새 파일을 생성합니다.\n\n```dart\nimport 'dart:convert';\n\nimport 'package:bloc_example/models/user_model.dart';\nimport 'package:http/http.dart';\n\nclass UserRepository {\n  String userUrl = 'https://reqres.in/api/users?page=2';\n\n  Future<List<UserModel>> getUsers() async {\n    Response response = await get(Uri.parse(userUrl));\n   \n    if (response.statusCode == 200) {\n      final List result = jsonDecode(response.body)['data'];\n      return result.map((e) => UserModel.fromJson(e)).toList();\n    } else {\n      throw Exception(response.reasonPhrase);\n    }\n  }\n}\n```\n\nhttp 요청을 수행하려면 http 패키지를 사용할 것입니다. 이제 json 내용을 살펴봅시다. 우리는 이 링크의 API를 사용하고 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n위의 링크에서 제공되는 JSON을 보면 모델이 어떻게 보일지에 대한 아이디어를 얻을 수 있습니다. 이 JSON에서는 데이터 태그의 속성을 갖게 될 것입니다. 여기서 우리는 firstname, lastname, email, 그리고 avatar에 초점을 맞출 것입니다.\n\n이제 모델 클래스를 만들어 봅시다.\n\n```js\nclass UserModel {\n  int? id;\n  String? email;\n  String? firstName;\n  String? lastName;\n  String? avatar;\n\n  UserModel({this.id, this.email, this.firstName, this.lastName, this.avatar});\n\n  UserModel.fromJson(Map<String, dynamic> json) {\n    id = json['id'];\n    email = json['email'];\n    firstName = json['first_name'];\n    lastName = json['last_name'];\n    avatar = json['avatar'];\n  }\n}\n```\n\n계속해서, 이제 우리의 블록이 어떻게 작동하는지에 대해 알아보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-21-FetchAPIWithBloCinFlutter_0.png\" />\n\n위의 그림을 보면\n\n- 먼저 UI가 있고 UI에서 블록으로 요청을 합니다.\n- 블록에는 이벤트와 상태 두 가지가 있습니다. 먼저 UI가 블록에 연결되면 이벤트를 생성하고 트리거합니다.\n- 이벤트는 최종적으로 엔드포인트를 통해 서버에 저장소를 호출합니다.\n- 서버에서 데이터를 가져와 블록에 다시 전달합니다. 데이터가 있으므로 상태를 트리거합니다.\n- 상태가 변경되었으므로 UI는 Bloc 패턴에서 알고 UI를 업데이트합니다.\n\n새 폴더 blocs를 만들고 app_states.dart라는 새 파일을 생성합니다.\n\n<div class=\"content-ad\"></div>\n\n\n```dart\nimport 'package:bloc_example/models/user_model.dart';\nimport 'package:equatable/equatable.dart';\nimport 'package:flutter/material.dart';\n\n@immutable\nabstract class UserState extends Equatable {}\n\nclass UserLoadingState extends UserState {\n  @override\n  List<Object?> get props => [];\n}\n\nclass UserLoadedState extends UserState {\n  final List<UserModel> users;\n  UserLoadedState(this.users);\n  @override\n  List<Object?> get props => [users];\n}\n\nclass UserErrorState extends UserState {\n  final String error;\n  UserErrorState(this.error);\n  @override\n  List<Object?> get props => [error];\n}\n```\n\nEquatable를 사용하면 값들을 비교할 수 있습니다. 두 변수가 동일한 값을 갖고 있다면 UI를 변경하거나 업데이트하지 않을 것입니다.\n\n먼저 상태를 생성하려면 equatable을 확장해야 하는 추상 클래스를 생성해야 합니다.\n\nBloc에서 x.obs를 통해 변수를 반응형으로 만들 수 있는 Getx와 달리 Bloc에서는 이와 같이 작동하지 않습니다. Bloc을 사용할 때는 모든 상태가 클래스임을 염두에 두어야 합니다.\n\n\n<div class=\"content-ad\"></div>\n\n이 프로젝트에서는 세 가지 상태가 있습니다.\n\n- 데이터를 불러올 때의 상태\n- 데이터를 불러왔을 때의 상태\n- 데이터를 가져오는 데 오류가 발생했을 때의 상태\n\n그리고 Equatable 내부에 get props라는 속성이 있습니다. 이를 재정의해야 합니다. UserState 클래스가 Equatable을 확장했으므로 UserLoadingState, UserLoadedState 및 UserErrorState 상태 클래스가 get props 속성에 액세스할 수 있게 됩니다. 이를 얻기 위해 재정의하고 해당 값을 설정해야 합니다.\n\n상태 이후, Flutter 블록에서는 각 상태마다 이벤트가 있습니다. 지금 app_events.dart라는 파일을 만들어야 합니다. 상태와 마찬가지로 이벤트를 위한 클래스를 생성해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport 'package:equatable/equatable.dart';\nimport 'package:flutter/material.dart';\n\n@immutable\nabstract class UserEvent extends Equatable {\n  const UserEvent();\n}\n\nclass LoadUserEvent extends UserEvent {\n  @override\n  List<Object?> get props => [];\n}\n```\n\n상태처럼 이벤트도 Equatable 클래스를 확장해야 합니다. 각 이벤트를 위한 전용 클래스를 만들어야 합니다. 이벤트 클래스는 기본 클래스를 확장해야 합니다. 여기서 기본 클래스는 UserEvent입니다. 그리고 이벤트는 LoadUserEvent입니다. 그리고 get props를 재정의해야 합니다.\n\n@immutable은 클래스의 속성을 변경하고 싶지 않다는 것을 나타냅니다.\n\n상태와 이벤트를 생성한 후에는 그들을 연결하는 방법을 찾아야 합니다.\n\n\n<div class=\"content-ad\"></div>\n\n그러려면 새 클래스를 만들고 방금 만든 상태와 이벤트를 삽입해야 해요. 이제 Bloc 라이브러리를 사용하여 이것들을 연결해 보죠.\n\nblocs 폴더 안에 app_blocs라는 새 파일을 만들어주세요.\n\n```dart\nimport 'package:bloc_example/blocs/app_events.dart';\nimport 'package:bloc_example/blocs/app_states.dart';\nimport 'package:bloc_example/repos/repositories.dart';\nimport 'package:flutter_bloc/flutter_bloc.dart';\n\nclass UserBloc extends Bloc<UserEvent, UserState> {\n  final UserRepository _userRepository;\n\n  UserBloc(this._userRepository) : super(UserLoadingState()) {\n    on<LoadUserEvent>((event, emit) async {\n      emit(UserLoadingState());\n      try {\n        final users = await _userRepository.getUsers();\n        emit(UserLoadedState(users));\n      } catch (e) {\n        emit(UserErrorState(e.toString()));\n      }\n    });\n  }\n}\n```\n\n여기엔 UserBloc이라는 클래스가 있습니다. 이 클래스는 Bloc을 확장합니다. 이 Bloc은 이벤트와 상태를 가져와야 합니다. 저희 경우에는 UserEvent와 UserState입니다. 이곳에서 사용하는 Bloc은 실제로 Bloc 라이브러리에서 제공됩니다.\n\n<div class=\"content-ad\"></div>\n\n이 UserBloc에는 리포지토리를 전달하는 생성자가 있어요. UI에서 이것을 호출할 거거든요. 이 클래스를 호출하는 동안 UserRepository를 전달합니다. Bloc을 사용했기 때문에 초기 상태를 슈퍼 생성자에 전달해야해요. 초기값을 호출한 후에는 on 메소드를 호출하게 됩니다.\n\n이제 on 메소드는 이벤트 유형을 가져와서 LoadUserEvent를 여기에 전달합니다. 이 이벤트를 사용하여 어떤 작업을 수행할 수 있어요. 이 이벤트가 호출되면 일부 상태를 방출하도록 지정합니다. 이 경우에는 UserLoadingState를 UI에서 변경 사항을 확인하려고 해요.\n\nBLoc에서 상태, 이벤트를 연결하여 상태를 트리거하고 작업할 수 있도록 하려면 lib 폴더에 homepage.dart라는 새 파일을 만들어요.\n\n```js\nclass HomePage extends StatelessWidget {\n  const HomePage({Key key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MultiBlocProvider(\n      providers: [\n        BlocProvider<UserBloc>(\n          create: (BuildContext context) => UserBloc(UserRepository()),\n        ),\n      ],\n      child: Scaffold(\n          appBar: AppBar(title: const Text('The BloC App')),\n          body: blocBody()),\n    );\n  }\n\nWidget blocBody() {\n    return BlocProvider(\n      create: (context) => UserBloc(\n        UserRepository(),\n      )..add(LoadUserEvent()),\n      child: BlocBuilder<UserBloc, UserState>(\n        builder: (context, state) {\n          if (state is UserLoadingState) {\n            return const Center(\n              child: CircularProgressIndicator(),\n            );\n          }\n           if (state is UserErrorState) {\n            return const Center(child:  Text(\"Error\"));\n          }\n          if (state is UserLoadedState) {\n            List<UserModel> userList = state.users;\n            return ListView.builder(\n                itemCount: userList.length,\n                itemBuilder: (_, index) {\n                  return Padding(\n                    padding:\n                        const EdgeInsets.symmetric(vertical: 4, horizontal: 8),\n                    child: Card(\n                        color: Theme.of(context).primaryColor,\n                        child: ListTile(\n                            title: Text(\n                              '${userList[index].firstName}  ${userList[index].lastName}',\n                              style: const TextStyle(color: Colors.white),\n                            ),\n\n                            subtitle: Text(\n                              '${userList[index].email}',\n                              style: const TextStyle(color: Colors.white),\n                            ),\n                            \n                            leading: CircleAvatar(\n                              backgroundImage: NetworkImage(\n                                  userList[index].avatar.toString()),\n                            ))),\n                  );\n                });\n          }\n\n          return Container();\n        },\n      ),\n    );\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n보시다시피 'MultiBlocProvider'가 제공되는 우리의 bloc 라이브러리에서 온 것을 확인할 수 있어요. 서버에서 데이터를로드하고 한 번만 로드하려고하기 때문에 빌드 방법에서 UserRepository를 주입합니다. bloc 형식의 MultiBlocProvider에서는 클래스에 여러 Bloc을 추가하여 전체 클래스에서 사용할 수 있습니다. 또한이 리포지토리를 배치할 위치에는 클래스가 있어야합니다. 우리의 경우에는 Scaffold입니다.\n\n그래서 MultiBlocProvider가 하는 일은 서버에서 데이터를 이동시키고 이를 만들어서 데이터와 상태를 모든 하위 요소에서 사용할 수 있게하는 것입니다.\n\nblocBody 내부에서 BlocProvider를 볼 수 있습니다. Getx에 익숙하다면 Get.put와 비슷합니다. BlocProvider 내부에서는 리포지토리와 함께 bloc 즉 UserBloc을 주입합니다. 위에서 이미 bloc을 주입했으므로 blocBody 내에서 이벤트에 액세스 할 수 있습니다.\n\n리포지토리와 함께 bloc을 주입 한 후에는 이벤트 즉 LoadUserEvent를 추가하고 이를 사용하여 UserBloc에서 UserLoadingState를 트리거하는 캐스캐이딩 연산자를 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n이제 빌더 내부의 상태를 확인할 수 있습니다. 세 가지 상태가 있으므로 각각을 확인하여 다른 작업을 수행하고 다른 UI를 반환합니다.\n\n다음과 같이 확인할 수 있습니다.\n\n- `UserLoadingState`일 때는 데이터를 불러오고 있다는 의미로 CircularProgressIndicator를 표시합니다.\n- `UserLoadedState`일 때는 데이터 목록을 반환합니다.\n- `UserErrorState`일 때는 오류 메시지를 반환합니다.\n\n이제 애플리케이션을 실행하면 bloc 라이브러리를 사용하여 데이터가 검색될 것입니다.\n\n<div class=\"content-ad\"></div>\n\n단점을 확인하려면 잘못된 종단점을 만들어 보실 수 있습니다.\n\n# 결론\n\n이 글에서 Bloc 및 Bloc 작업 메커니즘에 대해 설명했습니다. 필요에 맞게 코드를 조정하여 사용해 보세요. 새 페이지를 만들어 보는 것도 좋은 방법입니다. Bloc 아키텍처는 대규모 프로젝트에 매우 유용할 수 있습니다.\n\n이 블로그 게시물이 앞으로의 프로젝트에서 bloc 라이브러리와 아키텍처를 사용하는 데 충분한 중요한 정보를 제공해 줄 것을 바랍니다.\n\n<div class=\"content-ad\"></div>\n\n❤ ❤ 이 글 읽어주셔서 감사합니다 ❤ ❤\n\n만약 이 글을 좋아하셨다면 👏 두 번 치세요.\n\n또한, 업데이트되는 흥미로운 글과 프로젝트를 확인하려면 팔로우하세요.\n\n무엇인가 잘못된 점이 있다면? 댓글로 알려주세요. 개선해나가겠습니다.\n\n<div class=\"content-ad\"></div>\n\n# 함께 연결해요\n\n우리 친구가 되어요. 페이스북, 링크드인, 깃허브, 유튜브, BuyMeACoffee, 그리고 인스타그램에서 찾아요.\n\n방문하기: Flutter Junction\n\n기여하기: BuyMeACoffee\n\n<div class=\"content-ad\"></div>\n\n다음 링크에서 전체 코드를 확인하세요:","ogImage":{"url":"/assets/img/2024-06-21-FetchAPIWithBloCinFlutter_0.png"},"coverImage":"/assets/img/2024-06-21-FetchAPIWithBloCinFlutter_0.png","tag":["Tech"],"readingTime":10},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>이 문서에서는 블록 라이브러리를 사용하여 HTTP 요청을 수행하고 애플리케이션의 상태를 관리하는 방법을 살펴보겠습니다. 최종 애플리케이션은 다음과 같습니다:</p>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:576/1*amzYfYKgiZ8zpehBTVcx4w.gif\" alt=\"애플리케이션 데모\"></p>\n<p>앱이 처음 실행될 때, 서버에서 데이터를 가져올 때 로딩 표시기가 표시됩니다. 데이터를 가져온 후에는 목록에 표시됩니다.</p>\n<p>이를 위해 몇 가지 패키지를 사용하겠습니다:</p>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-attr\">dependencies:</span>\n  <span class=\"hljs-attr\">flutter_bloc:</span> <span class=\"hljs-string\">^8.1.1</span>\n  <span class=\"hljs-attr\">http:</span> <span class=\"hljs-string\">^0.13.5</span>\n  <span class=\"hljs-attr\">equatable:</span> <span class=\"hljs-string\">^2.0.5</span>\n</code></pre>\n<p>이제 API를 사용하여 서버에서 데이터를 가져오는 메커니즘을 만들어 보겠습니다. http 작업을 수행하기 위해 lib 내부에 폴더를 생성하고 repo라는 이름으로 지정합니다. 이 repo 내부에 repositories.dart라는 새 파일을 생성합니다.</p>\n<pre><code class=\"hljs language-dart\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'dart:convert'</span>;\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'package:bloc_example/models/user_model.dart'</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'package:http/http.dart'</span>;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">UserRepository</span> </span>{\n  <span class=\"hljs-built_in\">String</span> userUrl = <span class=\"hljs-string\">'https://reqres.in/api/users?page=2'</span>;\n\n  Future&#x3C;<span class=\"hljs-built_in\">List</span>&#x3C;UserModel>> getUsers() <span class=\"hljs-keyword\">async</span> {\n    Response response = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">get</span>(<span class=\"hljs-built_in\">Uri</span>.parse(userUrl));\n   \n    <span class=\"hljs-keyword\">if</span> (response.statusCode == <span class=\"hljs-number\">200</span>) {\n      <span class=\"hljs-keyword\">final</span> <span class=\"hljs-built_in\">List</span> result = jsonDecode(response.body)[<span class=\"hljs-string\">'data'</span>];\n      <span class=\"hljs-keyword\">return</span> result.map((e) => UserModel.fromJson(e)).toList();\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-keyword\">throw</span> Exception(response.reasonPhrase);\n    }\n  }\n}\n</code></pre>\n<p>http 요청을 수행하려면 http 패키지를 사용할 것입니다. 이제 json 내용을 살펴봅시다. 우리는 이 링크의 API를 사용하고 있습니다.</p>\n<p>위의 링크에서 제공되는 JSON을 보면 모델이 어떻게 보일지에 대한 아이디어를 얻을 수 있습니다. 이 JSON에서는 데이터 태그의 속성을 갖게 될 것입니다. 여기서 우리는 firstname, lastname, email, 그리고 avatar에 초점을 맞출 것입니다.</p>\n<p>이제 모델 클래스를 만들어 봅시다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">UserModel</span> {\n  int? id;\n  <span class=\"hljs-title class_\">String</span>? email;\n  <span class=\"hljs-title class_\">String</span>? firstName;\n  <span class=\"hljs-title class_\">String</span>? lastName;\n  <span class=\"hljs-title class_\">String</span>? avatar;\n\n  <span class=\"hljs-title class_\">UserModel</span>({<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">id</span>, <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">email</span>, <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">firstName</span>, <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">lastName</span>, <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">avatar</span>});\n\n  <span class=\"hljs-title class_\">UserModel</span>.<span class=\"hljs-title function_\">fromJson</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">Map</span>&#x3C;<span class=\"hljs-built_in\">String</span>, dynamic> json</span>) {\n    id = json[<span class=\"hljs-string\">'id'</span>];\n    email = json[<span class=\"hljs-string\">'email'</span>];\n    firstName = json[<span class=\"hljs-string\">'first_name'</span>];\n    lastName = json[<span class=\"hljs-string\">'last_name'</span>];\n    avatar = json[<span class=\"hljs-string\">'avatar'</span>];\n  }\n}\n</code></pre>\n<p>계속해서, 이제 우리의 블록이 어떻게 작동하는지에 대해 알아보겠습니다.</p>\n<p>위의 그림을 보면</p>\n<ul>\n<li>먼저 UI가 있고 UI에서 블록으로 요청을 합니다.</li>\n<li>블록에는 이벤트와 상태 두 가지가 있습니다. 먼저 UI가 블록에 연결되면 이벤트를 생성하고 트리거합니다.</li>\n<li>이벤트는 최종적으로 엔드포인트를 통해 서버에 저장소를 호출합니다.</li>\n<li>서버에서 데이터를 가져와 블록에 다시 전달합니다. 데이터가 있으므로 상태를 트리거합니다.</li>\n<li>상태가 변경되었으므로 UI는 Bloc 패턴에서 알고 UI를 업데이트합니다.</li>\n</ul>\n<p>새 폴더 blocs를 만들고 app_states.dart라는 새 파일을 생성합니다.</p>\n<pre><code class=\"hljs language-dart\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'package:bloc_example/models/user_model.dart'</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'package:equatable/equatable.dart'</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'package:flutter/material.dart'</span>;\n\n<span class=\"hljs-meta\">@immutable</span>\n<span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">UserState</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Equatable</span> </span>{}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">UserLoadingState</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">UserState</span> </span>{\n  <span class=\"hljs-meta\">@override</span>\n  <span class=\"hljs-built_in\">List</span>&#x3C;<span class=\"hljs-built_in\">Object?</span>> <span class=\"hljs-keyword\">get</span> props => [];\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">UserLoadedState</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">UserState</span> </span>{\n  <span class=\"hljs-keyword\">final</span> <span class=\"hljs-built_in\">List</span>&#x3C;UserModel> users;\n  UserLoadedState(<span class=\"hljs-keyword\">this</span>.users);\n  <span class=\"hljs-meta\">@override</span>\n  <span class=\"hljs-built_in\">List</span>&#x3C;<span class=\"hljs-built_in\">Object?</span>> <span class=\"hljs-keyword\">get</span> props => [users];\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">UserErrorState</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">UserState</span> </span>{\n  <span class=\"hljs-keyword\">final</span> <span class=\"hljs-built_in\">String</span> error;\n  UserErrorState(<span class=\"hljs-keyword\">this</span>.error);\n  <span class=\"hljs-meta\">@override</span>\n  <span class=\"hljs-built_in\">List</span>&#x3C;<span class=\"hljs-built_in\">Object?</span>> <span class=\"hljs-keyword\">get</span> props => [error];\n}\n</code></pre>\n<p>Equatable를 사용하면 값들을 비교할 수 있습니다. 두 변수가 동일한 값을 갖고 있다면 UI를 변경하거나 업데이트하지 않을 것입니다.</p>\n<p>먼저 상태를 생성하려면 equatable을 확장해야 하는 추상 클래스를 생성해야 합니다.</p>\n<p>Bloc에서 x.obs를 통해 변수를 반응형으로 만들 수 있는 Getx와 달리 Bloc에서는 이와 같이 작동하지 않습니다. Bloc을 사용할 때는 모든 상태가 클래스임을 염두에 두어야 합니다.</p>\n<p>이 프로젝트에서는 세 가지 상태가 있습니다.</p>\n<ul>\n<li>데이터를 불러올 때의 상태</li>\n<li>데이터를 불러왔을 때의 상태</li>\n<li>데이터를 가져오는 데 오류가 발생했을 때의 상태</li>\n</ul>\n<p>그리고 Equatable 내부에 get props라는 속성이 있습니다. 이를 재정의해야 합니다. UserState 클래스가 Equatable을 확장했으므로 UserLoadingState, UserLoadedState 및 UserErrorState 상태 클래스가 get props 속성에 액세스할 수 있게 됩니다. 이를 얻기 위해 재정의하고 해당 값을 설정해야 합니다.</p>\n<p>상태 이후, Flutter 블록에서는 각 상태마다 이벤트가 있습니다. 지금 app_events.dart라는 파일을 만들어야 합니다. 상태와 마찬가지로 이벤트를 위한 클래스를 생성해야 합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'package:equatable/equatable.dart'</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'package:flutter/material.dart'</span>;\n\n@immutable\nabstract <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">UserEvent</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Equatable</span> {\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">UserEvent</span>();\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">LoadUserEvent</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">UserEvent</span> {\n  @override\n  <span class=\"hljs-title class_\">List</span>&#x3C;<span class=\"hljs-title class_\">Object</span>?> get props => [];\n}\n</code></pre>\n<p>상태처럼 이벤트도 Equatable 클래스를 확장해야 합니다. 각 이벤트를 위한 전용 클래스를 만들어야 합니다. 이벤트 클래스는 기본 클래스를 확장해야 합니다. 여기서 기본 클래스는 UserEvent입니다. 그리고 이벤트는 LoadUserEvent입니다. 그리고 get props를 재정의해야 합니다.</p>\n<p>@immutable은 클래스의 속성을 변경하고 싶지 않다는 것을 나타냅니다.</p>\n<p>상태와 이벤트를 생성한 후에는 그들을 연결하는 방법을 찾아야 합니다.</p>\n<p>그러려면 새 클래스를 만들고 방금 만든 상태와 이벤트를 삽입해야 해요. 이제 Bloc 라이브러리를 사용하여 이것들을 연결해 보죠.</p>\n<p>blocs 폴더 안에 app_blocs라는 새 파일을 만들어주세요.</p>\n<pre><code class=\"hljs language-dart\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'package:bloc_example/blocs/app_events.dart'</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'package:bloc_example/blocs/app_states.dart'</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'package:bloc_example/repos/repositories.dart'</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'package:flutter_bloc/flutter_bloc.dart'</span>;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">UserBloc</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Bloc</span>&#x3C;<span class=\"hljs-title\">UserEvent</span>, <span class=\"hljs-title\">UserState</span>> </span>{\n  <span class=\"hljs-keyword\">final</span> UserRepository _userRepository;\n\n  UserBloc(<span class=\"hljs-keyword\">this</span>._userRepository) : <span class=\"hljs-keyword\">super</span>(UserLoadingState()) {\n    <span class=\"hljs-keyword\">on</span>&#x3C;LoadUserEvent>((event, emit) <span class=\"hljs-keyword\">async</span> {\n      emit(UserLoadingState());\n      <span class=\"hljs-keyword\">try</span> {\n        <span class=\"hljs-keyword\">final</span> users = <span class=\"hljs-keyword\">await</span> _userRepository.getUsers();\n        emit(UserLoadedState(users));\n      } <span class=\"hljs-keyword\">catch</span> (e) {\n        emit(UserErrorState(e.toString()));\n      }\n    });\n  }\n}\n</code></pre>\n<p>여기엔 UserBloc이라는 클래스가 있습니다. 이 클래스는 Bloc을 확장합니다. 이 Bloc은 이벤트와 상태를 가져와야 합니다. 저희 경우에는 UserEvent와 UserState입니다. 이곳에서 사용하는 Bloc은 실제로 Bloc 라이브러리에서 제공됩니다.</p>\n<p>이 UserBloc에는 리포지토리를 전달하는 생성자가 있어요. UI에서 이것을 호출할 거거든요. 이 클래스를 호출하는 동안 UserRepository를 전달합니다. Bloc을 사용했기 때문에 초기 상태를 슈퍼 생성자에 전달해야해요. 초기값을 호출한 후에는 on 메소드를 호출하게 됩니다.</p>\n<p>이제 on 메소드는 이벤트 유형을 가져와서 LoadUserEvent를 여기에 전달합니다. 이 이벤트를 사용하여 어떤 작업을 수행할 수 있어요. 이 이벤트가 호출되면 일부 상태를 방출하도록 지정합니다. 이 경우에는 UserLoadingState를 UI에서 변경 사항을 확인하려고 해요.</p>\n<p>BLoc에서 상태, 이벤트를 연결하여 상태를 트리거하고 작업할 수 있도록 하려면 lib 폴더에 homepage.dart라는 새 파일을 만들어요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HomePage</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">StatelessWidget</span> {\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">HomePage</span>({<span class=\"hljs-title class_\">Key</span> key});\n\n  @override\n  <span class=\"hljs-title class_\">Widget</span> <span class=\"hljs-title function_\">build</span>(<span class=\"hljs-params\">BuildContext context</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">MultiBlocProvider</span>(\n      <span class=\"hljs-attr\">providers</span>: [\n        <span class=\"hljs-title class_\">BlocProvider</span>&#x3C;<span class=\"hljs-title class_\">UserBloc</span>>(\n          <span class=\"hljs-attr\">create</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">BuildContext context</span>) =></span> <span class=\"hljs-title class_\">UserBloc</span>(<span class=\"hljs-title class_\">UserRepository</span>()),\n        ),\n      ],\n      <span class=\"hljs-attr\">child</span>: <span class=\"hljs-title class_\">Scaffold</span>(\n          <span class=\"hljs-attr\">appBar</span>: <span class=\"hljs-title class_\">AppBar</span>(<span class=\"hljs-attr\">title</span>: <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Text</span>(<span class=\"hljs-string\">'The BloC App'</span>)),\n          <span class=\"hljs-attr\">body</span>: <span class=\"hljs-title function_\">blocBody</span>()),\n    );\n  }\n\n<span class=\"hljs-title class_\">Widget</span> <span class=\"hljs-title function_\">blocBody</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">BlocProvider</span>(\n      <span class=\"hljs-attr\">create</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">context</span>) =></span> <span class=\"hljs-title class_\">UserBloc</span>(\n        <span class=\"hljs-title class_\">UserRepository</span>(),\n      )..<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-title class_\">LoadUserEvent</span>()),\n      <span class=\"hljs-attr\">child</span>: <span class=\"hljs-title class_\">BlocBuilder</span>&#x3C;<span class=\"hljs-title class_\">UserBloc</span>, <span class=\"hljs-title class_\">UserState</span>>(\n        <span class=\"hljs-attr\">builder</span>: (context, state) {\n          <span class=\"hljs-keyword\">if</span> (state is <span class=\"hljs-title class_\">UserLoadingState</span>) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Center</span>(\n              <span class=\"hljs-attr\">child</span>: <span class=\"hljs-title class_\">CircularProgressIndicator</span>(),\n            );\n          }\n           <span class=\"hljs-keyword\">if</span> (state is <span class=\"hljs-title class_\">UserErrorState</span>) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Center</span>(<span class=\"hljs-attr\">child</span>:  <span class=\"hljs-title class_\">Text</span>(<span class=\"hljs-string\">\"Error\"</span>));\n          }\n          <span class=\"hljs-keyword\">if</span> (state is <span class=\"hljs-title class_\">UserLoadedState</span>) {\n            <span class=\"hljs-title class_\">List</span>&#x3C;<span class=\"hljs-title class_\">UserModel</span>> userList = state.<span class=\"hljs-property\">users</span>;\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">ListView</span>.<span class=\"hljs-title function_\">builder</span>(\n                <span class=\"hljs-attr\">itemCount</span>: userList.<span class=\"hljs-property\">length</span>,\n                <span class=\"hljs-attr\">itemBuilder</span>: (_, index) {\n                  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Padding</span>(\n                    <span class=\"hljs-attr\">padding</span>:\n                        <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">EdgeInsets</span>.<span class=\"hljs-title function_\">symmetric</span>(<span class=\"hljs-attr\">vertical</span>: <span class=\"hljs-number\">4</span>, <span class=\"hljs-attr\">horizontal</span>: <span class=\"hljs-number\">8</span>),\n                    <span class=\"hljs-attr\">child</span>: <span class=\"hljs-title class_\">Card</span>(\n                        <span class=\"hljs-attr\">color</span>: <span class=\"hljs-title class_\">Theme</span>.<span class=\"hljs-title function_\">of</span>(context).<span class=\"hljs-property\">primaryColor</span>,\n                        <span class=\"hljs-attr\">child</span>: <span class=\"hljs-title class_\">ListTile</span>(\n                            <span class=\"hljs-attr\">title</span>: <span class=\"hljs-title class_\">Text</span>(\n                              <span class=\"hljs-string\">'${userList[index].firstName}  ${userList[index].lastName}'</span>,\n                              <span class=\"hljs-attr\">style</span>: <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">TextStyle</span>(<span class=\"hljs-attr\">color</span>: <span class=\"hljs-title class_\">Colors</span>.<span class=\"hljs-property\">white</span>),\n                            ),\n\n                            <span class=\"hljs-attr\">subtitle</span>: <span class=\"hljs-title class_\">Text</span>(\n                              <span class=\"hljs-string\">'${userList[index].email}'</span>,\n                              <span class=\"hljs-attr\">style</span>: <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">TextStyle</span>(<span class=\"hljs-attr\">color</span>: <span class=\"hljs-title class_\">Colors</span>.<span class=\"hljs-property\">white</span>),\n                            ),\n                            \n                            <span class=\"hljs-attr\">leading</span>: <span class=\"hljs-title class_\">CircleAvatar</span>(\n                              <span class=\"hljs-attr\">backgroundImage</span>: <span class=\"hljs-title class_\">NetworkImage</span>(\n                                  userList[index].<span class=\"hljs-property\">avatar</span>.<span class=\"hljs-title function_\">toString</span>()),\n                            ))),\n                  );\n                });\n          }\n\n          <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Container</span>();\n        },\n      ),\n    );\n  }\n}\n</code></pre>\n<p>보시다시피 'MultiBlocProvider'가 제공되는 우리의 bloc 라이브러리에서 온 것을 확인할 수 있어요. 서버에서 데이터를로드하고 한 번만 로드하려고하기 때문에 빌드 방법에서 UserRepository를 주입합니다. bloc 형식의 MultiBlocProvider에서는 클래스에 여러 Bloc을 추가하여 전체 클래스에서 사용할 수 있습니다. 또한이 리포지토리를 배치할 위치에는 클래스가 있어야합니다. 우리의 경우에는 Scaffold입니다.</p>\n<p>그래서 MultiBlocProvider가 하는 일은 서버에서 데이터를 이동시키고 이를 만들어서 데이터와 상태를 모든 하위 요소에서 사용할 수 있게하는 것입니다.</p>\n<p>blocBody 내부에서 BlocProvider를 볼 수 있습니다. Getx에 익숙하다면 Get.put와 비슷합니다. BlocProvider 내부에서는 리포지토리와 함께 bloc 즉 UserBloc을 주입합니다. 위에서 이미 bloc을 주입했으므로 blocBody 내에서 이벤트에 액세스 할 수 있습니다.</p>\n<p>리포지토리와 함께 bloc을 주입 한 후에는 이벤트 즉 LoadUserEvent를 추가하고 이를 사용하여 UserBloc에서 UserLoadingState를 트리거하는 캐스캐이딩 연산자를 사용합니다.</p>\n<p>이제 빌더 내부의 상태를 확인할 수 있습니다. 세 가지 상태가 있으므로 각각을 확인하여 다른 작업을 수행하고 다른 UI를 반환합니다.</p>\n<p>다음과 같이 확인할 수 있습니다.</p>\n<ul>\n<li><code>UserLoadingState</code>일 때는 데이터를 불러오고 있다는 의미로 CircularProgressIndicator를 표시합니다.</li>\n<li><code>UserLoadedState</code>일 때는 데이터 목록을 반환합니다.</li>\n<li><code>UserErrorState</code>일 때는 오류 메시지를 반환합니다.</li>\n</ul>\n<p>이제 애플리케이션을 실행하면 bloc 라이브러리를 사용하여 데이터가 검색될 것입니다.</p>\n<p>단점을 확인하려면 잘못된 종단점을 만들어 보실 수 있습니다.</p>\n<h1>결론</h1>\n<p>이 글에서 Bloc 및 Bloc 작업 메커니즘에 대해 설명했습니다. 필요에 맞게 코드를 조정하여 사용해 보세요. 새 페이지를 만들어 보는 것도 좋은 방법입니다. Bloc 아키텍처는 대규모 프로젝트에 매우 유용할 수 있습니다.</p>\n<p>이 블로그 게시물이 앞으로의 프로젝트에서 bloc 라이브러리와 아키텍처를 사용하는 데 충분한 중요한 정보를 제공해 줄 것을 바랍니다.</p>\n<p>❤ ❤ 이 글 읽어주셔서 감사합니다 ❤ ❤</p>\n<p>만약 이 글을 좋아하셨다면 👏 두 번 치세요.</p>\n<p>또한, 업데이트되는 흥미로운 글과 프로젝트를 확인하려면 팔로우하세요.</p>\n<p>무엇인가 잘못된 점이 있다면? 댓글로 알려주세요. 개선해나가겠습니다.</p>\n<h1>함께 연결해요</h1>\n<p>우리 친구가 되어요. 페이스북, 링크드인, 깃허브, 유튜브, BuyMeACoffee, 그리고 인스타그램에서 찾아요.</p>\n<p>방문하기: Flutter Junction</p>\n<p>기여하기: BuyMeACoffee</p>\n<p>다음 링크에서 전체 코드를 확인하세요:</p>\n</body>\n</html>\n"},"__N_SSG":true}