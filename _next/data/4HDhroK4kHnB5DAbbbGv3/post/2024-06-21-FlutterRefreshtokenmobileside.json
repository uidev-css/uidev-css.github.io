{"pageProps":{"post":{"title":"Flutter에서 리프레시 토큰 사용하는 방법 모바일","description":"","date":"2024-06-21 23:50","slug":"2024-06-21-FlutterRefreshtokenmobileside","content":"\n\n플러터에서 Dio를 사용하여 토큰을 새로 고치는 방법\n\n![image](/assets/img/2024-06-21-FlutterRefreshtokenmobileside_0.png)\n\n현대 모바일 애플리케이션에서는 사용자 인증 세션을 원활하게 유지하는 것이 사용자 경험에 매우 중요합니다. 인증을 관리하는 효과적인 방법 중 하나는 리프레시 토큰을 사용하는 것입니다. 이 기사에서는 Dio를 사용하여 플러터 애플리케이션에서 리프레시 토큰을 처리하는 방법에 대해 살펴보겠습니다.\n\n토큰이란 무엇인가요?\n토큰은 토큰 기반 인증에서 애플리케이션이 API에 액세스할 수 있도록 허용하는 데 사용됩니다. 사용자가 성공적으로 인증하고 액세스 권한을 부여한 후 애플리케이션은 액세스 토큰을 받아들이고 대상 API를 호출할 때 자격 증명으로서 액세스 토큰을 전달합니다. 전달된 토큰은 API에게 전달된 토큰의 소유자가 API에 액세스할 권한이 있으며 승인 중에 부여된 범위에 따라 특정 조치를 수행할 수 있음을 알립니다.\n\n<div class=\"content-ad\"></div>\n\n리프레시 토큰이 무엇인가요?\n리프레시 토큰은 사용자가 다시 인증을 받지 않고 새로운 엑세스 토큰을 얻는 메커니즘입니다. 일반적으로 엑세스 토큰은 보안상의 이유로 수명이 짧지만, 리프레시 토큰은 더 오래 지속됩니다. 엑세스 토큰이 만료되면 리프레시 토큰을 사용하여 새로운 엑세스 토큰을 얻을 수 있어 사용자의 세션을 중단시키지 않고 유지할 수 있습니다.\n\n단계별로 리프레시 토큰 구현하기\n\nDio의 인스턴스를 구성하고 초기화하는 'DioFactory' 클래스를 만드세요.\n\n```js\nclass DioFactory {\n\n  Future<Dio> getDio() async {\n    Dio dio = Dio();\n\n    Map<String, String> headers = {\n      contentType: applicationJson,\n      accept: applicationJson,\n    };\n\n    dio.options = BaseOptions(\n      baseUrl: ConstantsApi.baseUrl,\n      headers: headers,\n      receiveTimeout: const Duration(milliseconds: Constants.apiTimeOut),\n      sendTimeout: const Duration(milliseconds: Constants.apiTimeOut),\n      connectTimeout: const Duration(milliseconds: Constants.apiTimeOut),\n    );\n\n    if (!kReleaseMode) {\n      dio.interceptors.add(\n        PrettyDioLogger(\n          requestHeader: true,\n          requestBody: true,\n          responseHeader: true,\n          error: true,\n        ),\n      );\n    }\n\n    return dio;\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\nApiService 클래스는 Dio를 사용하여 API 요청을 처리하고 인증 토큰을 관리하기 위해 설계된 포괄적인 서비스 레이어입니다. 이 클래스와 기능에 대한 자세한 설명을 제공합니다.\n\n01- 클래스 선언 및 필드\n“_dio1”과 “_dio2”는 \"Dio\"의 인스턴스입니다. “_dio1”은 일반 API 요청에 사용되고, “_dio2”는 토큰 갱신 요청에 사용됩니다.\n\n```js\nclass ApiService {\n  final Dio _dio1;\n  final Dio _dio2;\n  final AppPreferences _appPref;\n\n  ApiService(\n    this._dio1,\n    this._dio2,\n    this._appPref,\n  ) {\n    _dio1.interceptors.add(\n      InterceptorsWrapper(\n        onRequest: _onRequest,\n        onError: _onError,\n      ),\n    );\n  }\n}\n```\n\n02- 인터셉터\n\n<div class=\"content-ad\"></div>\n\n생성자는 요청 및 오류 처리를 처리하기 위해 \"dio\"에 인터셉터를 추가합니다.\n\n오류 인터셉터:\n이 메서드는 오류를 처리합니다. 특히, 오류가 401 Unauthorized인 경우 토큰을 새로 고치려고 시도합니다.\n\n```js\n_onError(DioException e, ErrorInterceptorHandler handler) async {\n  if(e.response?.statusCode == 401) {\n    _refreshToken(e, handler);\n  } else {\n    handler.next(e);\n  }\n}\n```\n\n03- 토큰 새로고침 로직\n\" _refreshToken \"메서드는 새 액세스 토큰을 받아오기 위해 리프레시 토큰을 사용하려고 시도합니다.\n\n<div class=\"content-ad\"></div>\n\n- 성공하면 저장된 토큰을 업데이트하고 원래 요청을 다시 시도합니다.\n- 새로 고침이 실패하는 경우 (특히 새로 고침 토큰도 잘못된 경우), 사용자를 로그아웃 처리하고 오류를 거절합니다.\n\n```js\n  Future<void> _refreshToken(DioException e, ErrorInterceptorHandler handler) async {\n    try {\n      final refreshToken = _appPref.getRefreshToken();\n      final response = await _dio2.post(\n        ConstantsApi.refreshTokenUrl,\n        data: {'refreshToken': refreshToken},\n      );\n      _appPref.setToken(response.data['accessToken']);\n      _appPref.setRefreshToken(response.data['refreshToken']);\n      handler.resolve(await _dio1.fetch(e.requestOptions));\n    } catch (error) {\n      if (error is DioException) {\n        if (error.response?.statusCode == 401) {\n          _logout();\n          handler.reject(e);\n        } else {\n          handler.next(error);\n        }\n      } else {\n        handler.next(e);\n      }\n    }\n  }\n```\n\n위 단계를 따라 하면 Dio를 사용하여 Flutter 애플리케이션에서 새로 고침 토큰을 처리할 수 있어서 사용자가 원할한 경험을 얻을 수 있습니다. 이 방법은 Dio 인스턴스의 구성을 중앙 집중화하고 토큰을 효율적으로 관리하는 데 도움이 됩니다.","ogImage":{"url":"/assets/img/2024-06-21-FlutterRefreshtokenmobileside_0.png"},"coverImage":"/assets/img/2024-06-21-FlutterRefreshtokenmobileside_0.png","tag":["Tech"],"readingTime":4},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>플러터에서 Dio를 사용하여 토큰을 새로 고치는 방법</p>\n<p><img src=\"/assets/img/2024-06-21-FlutterRefreshtokenmobileside_0.png\" alt=\"image\"></p>\n<p>현대 모바일 애플리케이션에서는 사용자 인증 세션을 원활하게 유지하는 것이 사용자 경험에 매우 중요합니다. 인증을 관리하는 효과적인 방법 중 하나는 리프레시 토큰을 사용하는 것입니다. 이 기사에서는 Dio를 사용하여 플러터 애플리케이션에서 리프레시 토큰을 처리하는 방법에 대해 살펴보겠습니다.</p>\n<p>토큰이란 무엇인가요?\n토큰은 토큰 기반 인증에서 애플리케이션이 API에 액세스할 수 있도록 허용하는 데 사용됩니다. 사용자가 성공적으로 인증하고 액세스 권한을 부여한 후 애플리케이션은 액세스 토큰을 받아들이고 대상 API를 호출할 때 자격 증명으로서 액세스 토큰을 전달합니다. 전달된 토큰은 API에게 전달된 토큰의 소유자가 API에 액세스할 권한이 있으며 승인 중에 부여된 범위에 따라 특정 조치를 수행할 수 있음을 알립니다.</p>\n<p>리프레시 토큰이 무엇인가요?\n리프레시 토큰은 사용자가 다시 인증을 받지 않고 새로운 엑세스 토큰을 얻는 메커니즘입니다. 일반적으로 엑세스 토큰은 보안상의 이유로 수명이 짧지만, 리프레시 토큰은 더 오래 지속됩니다. 엑세스 토큰이 만료되면 리프레시 토큰을 사용하여 새로운 엑세스 토큰을 얻을 수 있어 사용자의 세션을 중단시키지 않고 유지할 수 있습니다.</p>\n<p>단계별로 리프레시 토큰 구현하기</p>\n<p>Dio의 인스턴스를 구성하고 초기화하는 'DioFactory' 클래스를 만드세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DioFactory</span> {\n\n  <span class=\"hljs-title class_\">Future</span>&#x3C;<span class=\"hljs-title class_\">Dio</span>> <span class=\"hljs-title function_\">getDio</span>() <span class=\"hljs-keyword\">async</span> {\n    <span class=\"hljs-title class_\">Dio</span> dio = <span class=\"hljs-title class_\">Dio</span>();\n\n    <span class=\"hljs-title class_\">Map</span>&#x3C;<span class=\"hljs-title class_\">String</span>, <span class=\"hljs-title class_\">String</span>> headers = {\n      <span class=\"hljs-attr\">contentType</span>: applicationJson,\n      <span class=\"hljs-attr\">accept</span>: applicationJson,\n    };\n\n    dio.<span class=\"hljs-property\">options</span> = <span class=\"hljs-title class_\">BaseOptions</span>(\n      <span class=\"hljs-attr\">baseUrl</span>: <span class=\"hljs-title class_\">ConstantsApi</span>.<span class=\"hljs-property\">baseUrl</span>,\n      <span class=\"hljs-attr\">headers</span>: headers,\n      <span class=\"hljs-attr\">receiveTimeout</span>: <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Duration</span>(<span class=\"hljs-attr\">milliseconds</span>: <span class=\"hljs-title class_\">Constants</span>.<span class=\"hljs-property\">apiTimeOut</span>),\n      <span class=\"hljs-attr\">sendTimeout</span>: <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Duration</span>(<span class=\"hljs-attr\">milliseconds</span>: <span class=\"hljs-title class_\">Constants</span>.<span class=\"hljs-property\">apiTimeOut</span>),\n      <span class=\"hljs-attr\">connectTimeout</span>: <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Duration</span>(<span class=\"hljs-attr\">milliseconds</span>: <span class=\"hljs-title class_\">Constants</span>.<span class=\"hljs-property\">apiTimeOut</span>),\n    );\n\n    <span class=\"hljs-keyword\">if</span> (!kReleaseMode) {\n      dio.<span class=\"hljs-property\">interceptors</span>.<span class=\"hljs-title function_\">add</span>(\n        <span class=\"hljs-title class_\">PrettyDioLogger</span>(\n          <span class=\"hljs-attr\">requestHeader</span>: <span class=\"hljs-literal\">true</span>,\n          <span class=\"hljs-attr\">requestBody</span>: <span class=\"hljs-literal\">true</span>,\n          <span class=\"hljs-attr\">responseHeader</span>: <span class=\"hljs-literal\">true</span>,\n          <span class=\"hljs-attr\">error</span>: <span class=\"hljs-literal\">true</span>,\n        ),\n      );\n    }\n\n    <span class=\"hljs-keyword\">return</span> dio;\n  }\n}\n</code></pre>\n<p>ApiService 클래스는 Dio를 사용하여 API 요청을 처리하고 인증 토큰을 관리하기 위해 설계된 포괄적인 서비스 레이어입니다. 이 클래스와 기능에 대한 자세한 설명을 제공합니다.</p>\n<p>01- 클래스 선언 및 필드\n“_dio1”과 “_dio2”는 \"Dio\"의 인스턴스입니다. “_dio1”은 일반 API 요청에 사용되고, “_dio2”는 토큰 갱신 요청에 사용됩니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ApiService</span> {\n  final <span class=\"hljs-title class_\">Dio</span> _dio1;\n  final <span class=\"hljs-title class_\">Dio</span> _dio2;\n  final <span class=\"hljs-title class_\">AppPreferences</span> _appPref;\n\n  <span class=\"hljs-title class_\">ApiService</span>(\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_dio1</span>,\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_dio2</span>,\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_appPref</span>,\n  ) {\n    _dio1.<span class=\"hljs-property\">interceptors</span>.<span class=\"hljs-title function_\">add</span>(\n      <span class=\"hljs-title class_\">InterceptorsWrapper</span>(\n        <span class=\"hljs-attr\">onRequest</span>: _onRequest,\n        <span class=\"hljs-attr\">onError</span>: _onError,\n      ),\n    );\n  }\n}\n</code></pre>\n<p>02- 인터셉터</p>\n<p>생성자는 요청 및 오류 처리를 처리하기 위해 \"dio\"에 인터셉터를 추가합니다.</p>\n<p>오류 인터셉터:\n이 메서드는 오류를 처리합니다. 특히, 오류가 401 Unauthorized인 경우 토큰을 새로 고치려고 시도합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">_onError</span>(<span class=\"hljs-title class_\">DioException</span> e, <span class=\"hljs-title class_\">ErrorInterceptorHandler</span> handler) <span class=\"hljs-keyword\">async</span> {\n  <span class=\"hljs-keyword\">if</span>(e.<span class=\"hljs-property\">response</span>?.<span class=\"hljs-property\">statusCode</span> == <span class=\"hljs-number\">401</span>) {\n    <span class=\"hljs-title function_\">_refreshToken</span>(e, handler);\n  } <span class=\"hljs-keyword\">else</span> {\n    handler.<span class=\"hljs-title function_\">next</span>(e);\n  }\n}\n</code></pre>\n<p>03- 토큰 새로고침 로직\n\" _refreshToken \"메서드는 새 액세스 토큰을 받아오기 위해 리프레시 토큰을 사용하려고 시도합니다.</p>\n<ul>\n<li>성공하면 저장된 토큰을 업데이트하고 원래 요청을 다시 시도합니다.</li>\n<li>새로 고침이 실패하는 경우 (특히 새로 고침 토큰도 잘못된 경우), 사용자를 로그아웃 처리하고 오류를 거절합니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\">  <span class=\"hljs-title class_\">Future</span>&#x3C;<span class=\"hljs-keyword\">void</span>> <span class=\"hljs-title function_\">_refreshToken</span>(<span class=\"hljs-title class_\">DioException</span> e, <span class=\"hljs-title class_\">ErrorInterceptorHandler</span> handler) <span class=\"hljs-keyword\">async</span> {\n    <span class=\"hljs-keyword\">try</span> {\n      final refreshToken = _appPref.<span class=\"hljs-title function_\">getRefreshToken</span>();\n      final response = <span class=\"hljs-keyword\">await</span> _dio2.<span class=\"hljs-title function_\">post</span>(\n        <span class=\"hljs-title class_\">ConstantsApi</span>.<span class=\"hljs-property\">refreshTokenUrl</span>,\n        <span class=\"hljs-attr\">data</span>: {<span class=\"hljs-string\">'refreshToken'</span>: refreshToken},\n      );\n      _appPref.<span class=\"hljs-title function_\">setToken</span>(response.<span class=\"hljs-property\">data</span>[<span class=\"hljs-string\">'accessToken'</span>]);\n      _appPref.<span class=\"hljs-title function_\">setRefreshToken</span>(response.<span class=\"hljs-property\">data</span>[<span class=\"hljs-string\">'refreshToken'</span>]);\n      handler.<span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-keyword\">await</span> _dio1.<span class=\"hljs-title function_\">fetch</span>(e.<span class=\"hljs-property\">requestOptions</span>));\n    } <span class=\"hljs-keyword\">catch</span> (error) {\n      <span class=\"hljs-keyword\">if</span> (error is <span class=\"hljs-title class_\">DioException</span>) {\n        <span class=\"hljs-keyword\">if</span> (error.<span class=\"hljs-property\">response</span>?.<span class=\"hljs-property\">statusCode</span> == <span class=\"hljs-number\">401</span>) {\n          <span class=\"hljs-title function_\">_logout</span>();\n          handler.<span class=\"hljs-title function_\">reject</span>(e);\n        } <span class=\"hljs-keyword\">else</span> {\n          handler.<span class=\"hljs-title function_\">next</span>(error);\n        }\n      } <span class=\"hljs-keyword\">else</span> {\n        handler.<span class=\"hljs-title function_\">next</span>(e);\n      }\n    }\n  }\n</code></pre>\n<p>위 단계를 따라 하면 Dio를 사용하여 Flutter 애플리케이션에서 새로 고침 토큰을 처리할 수 있어서 사용자가 원할한 경험을 얻을 수 있습니다. 이 방법은 Dio 인스턴스의 구성을 중앙 집중화하고 토큰을 효율적으로 관리하는 데 도움이 됩니다.</p>\n</body>\n</html>\n"},"__N_SSG":true}