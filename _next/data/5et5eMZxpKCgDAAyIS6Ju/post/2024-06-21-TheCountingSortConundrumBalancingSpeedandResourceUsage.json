{"pageProps":{"post":{"title":"카운팅 정렬 딜레마 속도와 자원 사용 균형 맞추는 방법","description":"","date":"2024-06-21 20:31","slug":"2024-06-21-TheCountingSortConundrumBalancingSpeedandResourceUsage","content":"\n## 다트에서 카운팅 정렬 및 실용적인 응용 프로그램에 대해 깊이 파헤쳐보기\n\n![이미지](/assets/img/2024-06-21-TheCountingSortConundrumBalancingSpeedandResourceUsage_0.png)\n\n카운팅 정렬은 선형 시간에 작동하는 정수 정렬 알고리즘입니다. 원소의 범위(최대값과 최소 값의 차이)가 원소의 개수보다 크게 차이나지 않은 배열을 정렬하는 데 특히 효과적입니다. 카운팅 정렬은 각 고유한 요소의 발생 횟수를 세고, 이러한 요소들이 정렬된 배열에서의 위치를 계산하여 작동합니다.\n\n# 카운팅 정렬 작동 방식\n\n<div class=\"content-ad\"></div>\n\n- 범위 결정: 배열에서 최솟값과 최댓값을 찾아 요소들의 범위를 결정합니다.\n- 발생 횟수 카운트: 각 고유 요소의 발생 횟수를 저장할 카운트 배열을 만듭니다.\n- 위치 계산: 각 인덱스의 요소가 이전 카운트들의 합을 저장하도록 카운트 배열을 수정합니다. 이렇게 하면 정렬된 배열에서 요소의 위치를 알 수 있게 됩니다.\n- 요소 배치: 카운트 배열에 지시된 대로 요소를 올바른 위치에 배치하여 출력 배열을 생성합니다.\n\n# 카운팅 정렬 사용 시기\n\n카운팅 정렬은 다음 경우에 특히 유용합니다:\n\n- 정렬해야 하는 요소가 정수인 경우.\n- 요소의 범위가 요소의 개수보다 크지 않은 경우.\n- 선형 시간 복잡도를 갖는 비교 기반 정렬 알고리즘이 필요한 경우.\n\n<div class=\"content-ad\"></div>\n\n# Counting Sort 알고리즘의 Dart 구현\n\nDart로 Counting Sort 알고리즘을 구현해봅시다.\n\n```js\nvoid countingSort(List<int> arr) {\n  if (arr.isEmpty) return;\n\n  // Step 1: 최솟값과 최댓값 찾기\n  int min = arr[0];\n  int max = arr[0];\n  for (int num in arr) {\n    if (num < min) {\n      min = num;\n    } else if (num > max) {\n      max = num;\n    }\n  }\n\n  // Step 2: count 배열 생성\n  int range = max - min + 1;\n  List<int> count = List.filled(range, 0);\n\n  // Step 3: 각 요소의 발생 횟수 세기\n  for (int num in arr) {\n    count[num - min]++;\n  }\n\n  // Step 4: 위치를 계산하기 위해 count 배열 수정\n  for (int i = 1; i < count.length; i++) {\n    count[i] += count[i - 1];\n  }\n\n  // Step 5: 정렬된 배열 작성\n  List<int> output = List.filled(arr.length, 0);\n  for (int i = arr.length - 1; i >= 0; i--) {\n    int num = arr[i];\n    output[count[num - min] - 1] = num;\n    count[num - min]--;\n  }\n\n  // Step 6: 정렬된 요소를 원래 배열로 복사\n  for (int i = 0; i < arr.length; i++) {\n    arr[i] = output[i];\n  }\n}\n\nvoid main() {\n  List<int> arr = [4, 2, 2, 8, 3, 3, 1, 7];\n  print(\"원본 배열: $arr\");\n\n  countingSort(arr);\n\n  print(\"정렬된 배열: $arr\");\n}\n```\n\n# 코드 설명\n\n<div class=\"content-ad\"></div>\n\n- 범위 찾기: 배열을 순회하여 최소값과 최대값을 찾습니다.\n- Count 배열 생성: 범위를 계산하고 각 고유 요소의 개수를 저장하는 Count 배열을 생성합니다.\n- 발생 회수 계산: 입력 배열을 순회하며 각 요소의 발생 회수로 Count 배열을 업데이트합니다.\n- 위치 계산: 누적 카운트를 저장하는 Count 배열을 수정하여 정렬된 배열에서 요소의 위치를 결정하는 데 도움이 되게 합니다.\n- 출력 배열 빌드: Count 배열을 기반으로 출력 배열에 요소를 올바른 위치에 배치합니다.\n- 정렬된 요소 복사: 마지막으로, 정렬된 요소를 출력 배열에서 원래 배열로 복사합니다.\n\n# 결론\n\nCounting Sort는 요소의 범위가 제한적일 때 특히 효율적이고 간단한 정렬 알고리즘입니다. 선형 시간 복잡성은 특정 범위 내에서 대량의 데이터를 정렬하는 데 유용한 도구로 만들어줍니다. 제공된 Dart 구현은 Counting Sort를 실제 상황에 적용하는 방법을 보여주며 사용법과 이점을 명확히 전달하여 실용적인 예제를 제공합니다.\n","ogImage":{"url":"/assets/img/2024-06-21-TheCountingSortConundrumBalancingSpeedandResourceUsage_0.png"},"coverImage":"/assets/img/2024-06-21-TheCountingSortConundrumBalancingSpeedandResourceUsage_0.png","tag":["Tech"],"readingTime":3},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<h2>다트에서 카운팅 정렬 및 실용적인 응용 프로그램에 대해 깊이 파헤쳐보기</h2>\n<p><img src=\"/assets/img/2024-06-21-TheCountingSortConundrumBalancingSpeedandResourceUsage_0.png\" alt=\"이미지\"></p>\n<p>카운팅 정렬은 선형 시간에 작동하는 정수 정렬 알고리즘입니다. 원소의 범위(최대값과 최소 값의 차이)가 원소의 개수보다 크게 차이나지 않은 배열을 정렬하는 데 특히 효과적입니다. 카운팅 정렬은 각 고유한 요소의 발생 횟수를 세고, 이러한 요소들이 정렬된 배열에서의 위치를 계산하여 작동합니다.</p>\n<h1>카운팅 정렬 작동 방식</h1>\n<div class=\"content-ad\"></div>\n<ul>\n<li>범위 결정: 배열에서 최솟값과 최댓값을 찾아 요소들의 범위를 결정합니다.</li>\n<li>발생 횟수 카운트: 각 고유 요소의 발생 횟수를 저장할 카운트 배열을 만듭니다.</li>\n<li>위치 계산: 각 인덱스의 요소가 이전 카운트들의 합을 저장하도록 카운트 배열을 수정합니다. 이렇게 하면 정렬된 배열에서 요소의 위치를 알 수 있게 됩니다.</li>\n<li>요소 배치: 카운트 배열에 지시된 대로 요소를 올바른 위치에 배치하여 출력 배열을 생성합니다.</li>\n</ul>\n<h1>카운팅 정렬 사용 시기</h1>\n<p>카운팅 정렬은 다음 경우에 특히 유용합니다:</p>\n<ul>\n<li>정렬해야 하는 요소가 정수인 경우.</li>\n<li>요소의 범위가 요소의 개수보다 크지 않은 경우.</li>\n<li>선형 시간 복잡도를 갖는 비교 기반 정렬 알고리즘이 필요한 경우.</li>\n</ul>\n<div class=\"content-ad\"></div>\n<h1>Counting Sort 알고리즘의 Dart 구현</h1>\n<p>Dart로 Counting Sort 알고리즘을 구현해봅시다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">countingSort</span>(<span class=\"hljs-params\">List&#x3C;int> arr</span>) {\n  <span class=\"hljs-keyword\">if</span> (arr.<span class=\"hljs-property\">isEmpty</span>) <span class=\"hljs-keyword\">return</span>;\n\n  <span class=\"hljs-comment\">// Step 1: 최솟값과 최댓값 찾기</span>\n  int min = arr[<span class=\"hljs-number\">0</span>];\n  int max = arr[<span class=\"hljs-number\">0</span>];\n  <span class=\"hljs-keyword\">for</span> (int num <span class=\"hljs-keyword\">in</span> arr) {\n    <span class=\"hljs-keyword\">if</span> (num &#x3C; min) {\n      min = num;\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (num > max) {\n      max = num;\n    }\n  }\n\n  <span class=\"hljs-comment\">// Step 2: count 배열 생성</span>\n  int range = max - min + <span class=\"hljs-number\">1</span>;\n  <span class=\"hljs-title class_\">List</span>&#x3C;int> count = <span class=\"hljs-title class_\">List</span>.<span class=\"hljs-title function_\">filled</span>(range, <span class=\"hljs-number\">0</span>);\n\n  <span class=\"hljs-comment\">// Step 3: 각 요소의 발생 횟수 세기</span>\n  <span class=\"hljs-keyword\">for</span> (int num <span class=\"hljs-keyword\">in</span> arr) {\n    count[num - min]++;\n  }\n\n  <span class=\"hljs-comment\">// Step 4: 위치를 계산하기 위해 count 배열 수정</span>\n  <span class=\"hljs-keyword\">for</span> (int i = <span class=\"hljs-number\">1</span>; i &#x3C; count.<span class=\"hljs-property\">length</span>; i++) {\n    count[i] += count[i - <span class=\"hljs-number\">1</span>];\n  }\n\n  <span class=\"hljs-comment\">// Step 5: 정렬된 배열 작성</span>\n  <span class=\"hljs-title class_\">List</span>&#x3C;int> output = <span class=\"hljs-title class_\">List</span>.<span class=\"hljs-title function_\">filled</span>(arr.<span class=\"hljs-property\">length</span>, <span class=\"hljs-number\">0</span>);\n  <span class=\"hljs-keyword\">for</span> (int i = arr.<span class=\"hljs-property\">length</span> - <span class=\"hljs-number\">1</span>; i >= <span class=\"hljs-number\">0</span>; i--) {\n    int num = arr[i];\n    output[count[num - min] - <span class=\"hljs-number\">1</span>] = num;\n    count[num - min]--;\n  }\n\n  <span class=\"hljs-comment\">// Step 6: 정렬된 요소를 원래 배열로 복사</span>\n  <span class=\"hljs-keyword\">for</span> (int i = <span class=\"hljs-number\">0</span>; i &#x3C; arr.<span class=\"hljs-property\">length</span>; i++) {\n    arr[i] = output[i];\n  }\n}\n\n<span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-title class_\">List</span>&#x3C;int> arr = [<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">7</span>];\n  <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"원본 배열: $arr\"</span>);\n\n  <span class=\"hljs-title function_\">countingSort</span>(arr);\n\n  <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"정렬된 배열: $arr\"</span>);\n}\n</code></pre>\n<h1>코드 설명</h1>\n<div class=\"content-ad\"></div>\n<ul>\n<li>범위 찾기: 배열을 순회하여 최소값과 최대값을 찾습니다.</li>\n<li>Count 배열 생성: 범위를 계산하고 각 고유 요소의 개수를 저장하는 Count 배열을 생성합니다.</li>\n<li>발생 회수 계산: 입력 배열을 순회하며 각 요소의 발생 회수로 Count 배열을 업데이트합니다.</li>\n<li>위치 계산: 누적 카운트를 저장하는 Count 배열을 수정하여 정렬된 배열에서 요소의 위치를 결정하는 데 도움이 되게 합니다.</li>\n<li>출력 배열 빌드: Count 배열을 기반으로 출력 배열에 요소를 올바른 위치에 배치합니다.</li>\n<li>정렬된 요소 복사: 마지막으로, 정렬된 요소를 출력 배열에서 원래 배열로 복사합니다.</li>\n</ul>\n<h1>결론</h1>\n<p>Counting Sort는 요소의 범위가 제한적일 때 특히 효율적이고 간단한 정렬 알고리즘입니다. 선형 시간 복잡성은 특정 범위 내에서 대량의 데이터를 정렬하는 데 유용한 도구로 만들어줍니다. 제공된 Dart 구현은 Counting Sort를 실제 상황에 적용하는 방법을 보여주며 사용법과 이점을 명확히 전달하여 실용적인 예제를 제공합니다.</p>\n</body>\n</html>\n"},"__N_SSG":true}