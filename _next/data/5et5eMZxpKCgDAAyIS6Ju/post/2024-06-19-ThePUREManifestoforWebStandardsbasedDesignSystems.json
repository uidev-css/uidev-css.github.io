{"pageProps":{"post":{"title":"퓨어 매니페스토  웹 표준 기반 디자인 시스템을 위한","description":"","date":"2024-06-19 00:33","slug":"2024-06-19-ThePUREManifestoforWebStandardsbasedDesignSystems","content":"\n\n## 초경량, 웹 표준 기반 디자인 시스템에 대한 기본 규칙\n\n![이미지](/assets/img/2024-06-19-ThePUREManifestoforWebStandardsbasedDesignSystems_0.png)\n\n알고 계실지 모르겠지만, 저는 간단하게 유지하는 것을 선호해요.\n\n![이미지](/assets/img/2024-06-19-ThePUREManifestoforWebStandardsbasedDesignSystems_1.png)\n\n<div class=\"content-ad\"></div>\n\n요즘에는 웹 컴포넌트 전용 PWA를 개발 중이었어요. 구글의 가벼운 라이브러리인 Google Lit을 활용해서요. 이 라이브러리는 무려 5KB밖에 안 되죠.\n\n이 중 하나의 프로젝트는 이미 완성된 피그마 디자인을 가지고 있던 젊은 B2B 스타트업을 위한 것이었어요. 처음에는 목표로 했던 모바일 앱 대신 PWA 기술을 이용하자는 이야기를 나눴을 때, 컴포넌트 라이브러리와 디자인 시스템에 관한 문제가 생겼어요.\n\n앱의 디자인은 신선하고 다채롭고 독창적이었어요. \n\n일반적인 UI 라이브러리(Material Web, FAST, Shoelace 등)를 사용하면 맞춤 작업을 많이 해야 했기 때문에 결정을 내리는 데 시간이 걸렸어요.\n\n<div class=\"content-ad\"></div>\n\n우리만의 사용자 정의 구성 요소 라이브러리로 나아갈까요? 분명히 많은 작업이 필요할 겁니다.\n\n디자인 시스템을 분리하고 Storybook 인스턴스를 만드는 추가 작업이 필요하기 때문에 스마트하게 대응해야 합니다:\n\n- 자체 디자인 시스템 구축은 가능한 최소한의 부담을 동반해야 합니다.\n- 이미 있는 모범 사례를 활용해야 합니다.\n- 언제나 네이티브 솔루션을 지향하고 표준을 준수해야 합니다.\n- 외부 종속성을 최소화하기 위해 최선을 다해야 합니다.\n- 신속히 반복하고 실용적인 선택을 해야 합니다.\n- 열렬하지 않아도 되며 바퀴를 다시 발명하는 것을 막기 위해 좋은 이유가 있을 때 외부 구성 요소를 사용할 여지를 열어두어야 합니다 😉.\n\n제 경험을 바탕으로 PURE 선언을 소개하겠습니다.\n\n<div class=\"content-ad\"></div>\n\n# 1순위: 순수한(의미론적) HTML+CSS 사용하기\n\n적절한 의미론을 가진 표준 HTML+CSS 솔루션을 항상 찾아보세요.\n\n가끔은 표준 의미론적 HTML 이상이 필요하지 않을 수도 있습니다.\n\n```js\n<section class=\"callout warning\">\n  <h3>Warning</h3>\n  <div>This is a simple callout test message.</div>\n</section>\n```\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-19-ThePUREManifestoforWebStandardsbasedDesignSystems_2.png)\n\n가끔은 표준 HTML 구조를 사용하여 흥미로운 사용자 정의 결과를 얻을 수 있습니다. 이는 완전한 의미론적인 응답입니다:\n\n```js\n<hr data-content=\"or\"/>\n```\n\n...약간의 스타일링을 추가하면 멋진 구분선이 될 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n![image](/assets/img/2024-06-19-ThePUREManifestoforWebStandardsbasedDesignSystems_3.png) \n\n# 우선 순위 2: 점진적 향상을 생각하세요\n\n최근 프로젝트 중 하나에서는 Google Material Web의 텍스트 필드 구성 요소를 살펴보았고, 우리의 요구 사항을 충족할 수 있는 완전한 Web 구성 요소를 개발하는 것을 고려했지만, 간단함을 위해 어느 쪽도 사용하지 않기로 결정했습니다.\n\n다음은 'id' 및 'for' 속성을 사용하지 않고도 레이블이 있는 양식 필드를 만드는 방법을 보여주는 내가 항상 사용하는 코드 조각입니다(모든 브라우저에서 오랜 기간 동안 작동되어 왔습니다):\n\n<div class=\"content-ad\"></div>\n\n```js\n<label>\n  <span data-label>Email address</span>\n  <input name=\"email\" type=\"email\" placeholder=\"john@doe.com\">\n</label>\r\n```\n\n간단한 점진적 향상을 작성했는데, 'data-label' 속성을 가진 컨트롤을 자동으로 확장하여 위의 구조로 표시됩니다:\n\n```js\n<input name=\"email\" required\n  data-label=\"Email address\"\n  placeholder=\"john@doe.com\"\n/>\r\n```\n\n<img src=\"/assets/img/2024-06-19-ThePUREManifestoforWebStandardsbasedDesignSystems_4.png\" />\n\n<div class=\"content-ad\"></div>\n\n매우 간단한 점진적 개선 방법은 HTML 입력의 모든 표준 로직이 보존된다는 것을 의미합니다. Web 컴포넌트가 Web Forms에서 일등 시민으로 동작하도록 하는 데 필요한 것과 비교해보면, 절약할 수 있는 규모를 감을 수 있을 겁니다. \n\n우리는 모든 폼 요소에 이 방법을 사용하기로 결정했고, 우리 자체 맞춤형 컴포넌트와 같이 네이티브가 아닌 HTML 요소를 사용하더라도 동일한 점진적 개선을 사용할 수 있습니다:\n\n```js\n<switch-check name=\"email\" required\n  data-label=\"Email address\"\n  placeholder=\"john@doe.com\"\n></switch-check>\n```\n\n# 우선순위 3: 사용자 정의 태그 시험 (스타일 적용하기)\n\n<div class=\"content-ad\"></div>\n\n많은 웹 표준(예: PWA — 이름은 무슨 뜻일까?)과 마찬가지로, 웹 컴포넌트는 HTML 언어 자체의 확장성을 통해 시작되는 점진적인 향상을 제공합니다. 이는 사용자 정의 태그를 사용하는 것으로 이루어져 있습니다.\n\n따라서, 사용자 정의 태그는 웹 컴포넌트가 아닙니다. 웹 컴포넌트는 기능이 첨부된 사용자 정의 태그입니다.\n\n사용자 정의 태그는 단순히 선언함으로써 사용할 수 있으며, 해당 태그에 첨부된 웹 컴포넌트를 정의하지 않고 사용자 정의 태그를 사용하는 것은 HTML 구성 요소화에 유효한 접근 방식일 수 있습니다.\n\n가끔은 의미있는 앵커 포인트가 있는 것이면서 해당 포인트에 특정 사용자 정의 태그 CSS를 첨부하는 것만으로 충분할 수 있습니다. 확실히 잘 선택된 사용자 정의 태그 이름은 향후 개발자가 당신의 애플리케이션 흐름을 읽는 데 도움이 됩니다!\n\n<div class=\"content-ad\"></div>\n\n하지만 사용자 정의 태그를 정의할 때는 언제나 CSS만 적용할 경우(기능은 없음)일까요?\n\n내 기준은 다음과 같습니다:\n\n- 우리의 목표와 가장 일치하는 의미론적 요소가 없습니다.\n- 사용자 정의 태그는 사용자 정의 방식을 따르는 내부 HTML을 기대하는 래퍼입니다.\n\n```js\n<custom-grid columns=\"1\">\n  [내용을 입력하세요]\n</custom-grid>\n```\n\n<div class=\"content-ad\"></div>\n\n위의 예제는 Markdown 형식의 표로 변경해야 합니다.\n\n```js\ncustom-grid {\n  display: grid;\n  grid-gap: var(--gutter-small, .5rem);\n  &[columns=\"1\"]{\n    grid-template-columns: 1fr;\n  }\n}\n```\n\n그리고 다른 복잡한 예제로는 최근에 작성한 TabStrip이 있습니다. 이는 tab-strip라는 사용자 지정 태그를 사용하며 매우 구체적인 콘텐츠를 필요로 합니다: 각 탭은 하나의 링크와 하나의 div로 구성된 섹션으로 표현됩니다.\n\n```js\n<tab-strip>\n  <section id=\"tab1\"><a href=\"#insights\">Tab 1</a>\n    <div class=\"tab-content\" id=\"overview\">\n      Tab 1 content\n    </div>\n  </section>  \n  <section id=\"tab2\"><a href=\"#tab2\">Tab 2</a>\n    <div class=\"tab-content\">\n      Tab 2 content\n    </div>\n  </section>  \n  <section id=\"tab3\"><a href=\"#tab3\">Tab 3</a>\n    <div class=\"tab-content\">\n      Tab 3 content\n    </div>\n  </section>\n</tab-strip>\n```\n\n<div class=\"content-ad\"></div>\n\n물론, 상황이 더 복잡해지면, 예를 들어 탭 콘텐츠를 탭을 클릭할 때 가져와야 하는 경우, 다음 단계는 사용자 정의 태그의 로직을 정의하고 이를 웹 구성 요소로 만드는 것입니다.\n\n# 우선순위 4: 웹 컴포넌트 로직 추가 (Light DOM 사용)\n\n사용자 정의 태그를 사용할 때 트리거되는 기능이 필요한 경우, customElements.define()를 사용하여 해당 기능을 첨부해야 합니다.\n\n많은 경우 전역 스타일링을 활용하거나 전역 상태를 처리하고 버블링 이벤트를 캐치하는 등 JavaScript 기능을 가진 컨테이너 유형의 요소가 필요할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 컨테이너 요소를 고려해보세요:\n\n```js\n<spa-route>\n  [HTML 내용을 입력하세요]\n</spa-route>\n```\n\n```js\nimport {html, LitElement} from \"lit\";\nimport {Router} from \"./router\";\nimport {config} from \"../app-config\";\nimport {until} from \"lit/directives/until.js\";\n\ncustomElements.define(\n  \"spa-route\",\n\n  class PWARenderRoute extends LitElement {\n\n     #router = new Router(config.routes));\n\n    // Light DOM 사용\n    createRenderRoot() {\n      return this;\n    }\n\n    render() {\n      return html`${until(this.#router.matchRoute(), app.loader)}`;\n    }\n  }\n)\n```\n\n이 코드는 SPA 라우터의 간소화된 버전으로, 구성된 라우트에 기반하여 콘텐츠를 렌더링합니다. 완전한 예제는 \"The Browser is your Framework: Building a PWA with only Web Components and Lit\"에서 확인할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n웹 컴포넌트 중심의 PWA에서는 본문 태그 아래에 모든 것을 포함하는 웹 컴포넌트를 두는 것이 모범 사례입니다.\n\n```js\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\"/>\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, user-scalable=1.0, minimum-scale=1.0, maximum-scale=1.0\">\n    <title>My App</title>\n    <link rel=\"manifest\" href=\"/manifest.webmanifest\"/>\n    <meta name=\"apple-mobile-web-app-capable\" content=\"yes\"/>\n    <meta name=\"mobile-web-app-capable\" content=\"yes\"/>\n    <meta name=\"theme-color\" content=\"#655122\"/>\n    <link rel=\"apple-touch-icon\" href=\"/assets/img/icon512px\"/>\n    <link rel=\"shortcut icon\" href=\"/assets/img/favicon.ico\">\n    <link href=\"/assets/css/main.css\" rel=\"stylesheet\"/>\n    <script type=\"module\" defer src=\"/assets/js/app.js\"></script>\n</head>\n\n<body>\n\n<my-app class=\"app-canvas\">\n  <main>\n    <spa-route></spa-route>\n  </main>\n</my-app>\n\n</body>\n\n</html>\n```\n\n그러니까, my-app 구성요소는 글로벌 앱 상태를 관리하고, localStorage를 처리하며, 인증 세션을 관리하며, 버블링 이벤트를 처리합니다.\n\n# 5순위: 완전한 웹 컴포넌트 생성하기 (Shadow DOM 활용)\n\n<div class=\"content-ad\"></div>\n\n위에 표시된 코드 중 일부에서 Light DOM을 사용하는 꿀팁(Light DOM을 사용하면 전역 스타일이 웹 컴포넌트의 태그 아래에 모두 적용됩니다)은 다음과 같은 Lit 코드입니다:\n\n```js\n// Light DOM 사용하기\ncreateRenderRoot() {\n  return this;\n}\n```\n\n기본적으로 LitElement 기반의 웹 컴포넌트는 Shadow DOM을 사용하여 렌더링되므로 확장된 HTMLElement 자체를 반환하여 사용을 비활성화해야 합니다!\n\n커스텀 HTML을 출력하고 문서의 전역 스타일과 격리되어야 하는 커스텀 스타일을 사용하는 복잡한 컴포넌트의 경우, 이 아이디어가 좋지만 몇 가지 추가 복잡성을 받아 들여야 합니다:\n\n<div class=\"content-ad\"></div>\n\n- 먼저 Shadow DOM의 격리 수준에 대해 알아야 합니다. 웹 구성 요소 중에서 복잡한 부분이 있다면 바로 그것입니다.\n- CSS 속성(또는 변수)을 사용하는 것은 추가 작업이 필요합니다.\n- 테마 공유(테두리, 색상, 그림자, 안쪽 간격 등)는 조금 더 복잡하고 설명이 필요합니다.\n- 컨텐츠 배치(슬롯 사용)는 매우 특정하며 항상 명확하지는 않습니다.\n- 접근성 및 사용 용이성 노력(특히 양식 요소를 빌드할 때)은 개발 시간을 늘릴 것입니다.\n\n이렇게 말씀드리는 것에, 많은 구성 요소와 흐름이 있는 복잡한 컨트롤은 물론 단일 단위로 작동합니다. 당연히 매우 가치가 있고, 웹 표준은 이러한 모듈성을 만들기 위한 좋은 방법을 제공합니다.\n\n# 결론\n\n웹 구성 요소 중심의 애플리케이션 개발은 훌륭하고, 초고속 그리고 가벼운 PWA를 제공하지만 웹 구성 요소는 훌륭한 앱을 제공하는 유일한 수단으로 간주되어서는 안 됩니다. 그들에 대한 많은 사용 사례가 있지만, 항상 그것들이 다른 웹 표준과 마찬가지로 점진적 향상의 한 형태임을 염두에 두어야 합니다.\n\n<div class=\"content-ad\"></div>\n\n따라서 코드를 모조리 웹 구성 요소 또는 완전히 격리된 Shadow DOM을 사용하는 것에 대해서는 신중하게 고려해야 합니다.\n\n이 선언은 Lean Startup 관점에서 항상 올바르고 실용적이며 때로는 기회적인 선택을 하는 데 관한 것입니다. 항상 가장 간단하고 지속 가능한 해결책을 찾으려 노력하며 잡기 어려운 방법으로 접근합니다.\n\n가끔은 재사용하기 쉬운 가벼운 구조부터 시작하여 미래에 프로그레시브한 향상을 위한 여지도 남겨두는 것을 의미합니다 😉.\n\nPURE 선언의 많은 개념은 이전 (오픈 소스) 작업에서 기인한 것으로, PurePWA - 파워 & 순수성 (pure-pwa.com)과 같은 작업이 있습니다.","ogImage":{"url":"/assets/img/2024-06-19-ThePUREManifestoforWebStandardsbasedDesignSystems_0.png"},"coverImage":"/assets/img/2024-06-19-ThePUREManifestoforWebStandardsbasedDesignSystems_0.png","tag":["Tech"],"readingTime":8},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<h2>초경량, 웹 표준 기반 디자인 시스템에 대한 기본 규칙</h2>\n<p><img src=\"/assets/img/2024-06-19-ThePUREManifestoforWebStandardsbasedDesignSystems_0.png\" alt=\"이미지\"></p>\n<p>알고 계실지 모르겠지만, 저는 간단하게 유지하는 것을 선호해요.</p>\n<p><img src=\"/assets/img/2024-06-19-ThePUREManifestoforWebStandardsbasedDesignSystems_1.png\" alt=\"이미지\"></p>\n<div class=\"content-ad\"></div>\n<p>요즘에는 웹 컴포넌트 전용 PWA를 개발 중이었어요. 구글의 가벼운 라이브러리인 Google Lit을 활용해서요. 이 라이브러리는 무려 5KB밖에 안 되죠.</p>\n<p>이 중 하나의 프로젝트는 이미 완성된 피그마 디자인을 가지고 있던 젊은 B2B 스타트업을 위한 것이었어요. 처음에는 목표로 했던 모바일 앱 대신 PWA 기술을 이용하자는 이야기를 나눴을 때, 컴포넌트 라이브러리와 디자인 시스템에 관한 문제가 생겼어요.</p>\n<p>앱의 디자인은 신선하고 다채롭고 독창적이었어요.</p>\n<p>일반적인 UI 라이브러리(Material Web, FAST, Shoelace 등)를 사용하면 맞춤 작업을 많이 해야 했기 때문에 결정을 내리는 데 시간이 걸렸어요.</p>\n<div class=\"content-ad\"></div>\n<p>우리만의 사용자 정의 구성 요소 라이브러리로 나아갈까요? 분명히 많은 작업이 필요할 겁니다.</p>\n<p>디자인 시스템을 분리하고 Storybook 인스턴스를 만드는 추가 작업이 필요하기 때문에 스마트하게 대응해야 합니다:</p>\n<ul>\n<li>자체 디자인 시스템 구축은 가능한 최소한의 부담을 동반해야 합니다.</li>\n<li>이미 있는 모범 사례를 활용해야 합니다.</li>\n<li>언제나 네이티브 솔루션을 지향하고 표준을 준수해야 합니다.</li>\n<li>외부 종속성을 최소화하기 위해 최선을 다해야 합니다.</li>\n<li>신속히 반복하고 실용적인 선택을 해야 합니다.</li>\n<li>열렬하지 않아도 되며 바퀴를 다시 발명하는 것을 막기 위해 좋은 이유가 있을 때 외부 구성 요소를 사용할 여지를 열어두어야 합니다 😉.</li>\n</ul>\n<p>제 경험을 바탕으로 PURE 선언을 소개하겠습니다.</p>\n<div class=\"content-ad\"></div>\n<h1>1순위: 순수한(의미론적) HTML+CSS 사용하기</h1>\n<p>적절한 의미론을 가진 표준 HTML+CSS 솔루션을 항상 찾아보세요.</p>\n<p>가끔은 표준 의미론적 HTML 이상이 필요하지 않을 수도 있습니다.</p>\n<pre><code class=\"hljs language-js\">&#x3C;section <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">\"callout warning\"</span>>\n  <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">h3</span>></span>Warning<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">h3</span>></span></span>\n  <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>This is a simple callout test message.<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n&#x3C;/section>\n</code></pre>\n<div class=\"content-ad\"></div>\n<p><img src=\"/assets/img/2024-06-19-ThePUREManifestoforWebStandardsbasedDesignSystems_2.png\" alt=\"이미지\"></p>\n<p>가끔은 표준 HTML 구조를 사용하여 흥미로운 사용자 정의 결과를 얻을 수 있습니다. 이는 완전한 의미론적인 응답입니다:</p>\n<pre><code class=\"hljs language-js\">&#x3C;hr data-content=<span class=\"hljs-string\">\"or\"</span>/>\n</code></pre>\n<p>...약간의 스타일링을 추가하면 멋진 구분선이 될 수 있습니다.</p>\n<div class=\"content-ad\"></div>\n<p><img src=\"/assets/img/2024-06-19-ThePUREManifestoforWebStandardsbasedDesignSystems_3.png\" alt=\"image\"></p>\n<h1>우선 순위 2: 점진적 향상을 생각하세요</h1>\n<p>최근 프로젝트 중 하나에서는 Google Material Web의 텍스트 필드 구성 요소를 살펴보았고, 우리의 요구 사항을 충족할 수 있는 완전한 Web 구성 요소를 개발하는 것을 고려했지만, 간단함을 위해 어느 쪽도 사용하지 않기로 결정했습니다.</p>\n<p>다음은 'id' 및 'for' 속성을 사용하지 않고도 레이블이 있는 양식 필드를 만드는 방법을 보여주는 내가 항상 사용하는 코드 조각입니다(모든 브라우저에서 오랜 기간 동안 작동되어 왔습니다):</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\">&#x3C;label>\n  <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">data-label</span>></span>Email address<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">span</span>></span></span>\n  <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"email\"</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"email\"</span> <span class=\"hljs-attr\">placeholder</span>=<span class=\"hljs-string\">\"john@doe.com\"</span>></span>\n<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">label</span>></span></span>\n</code></pre>\n<p>간단한 점진적 향상을 작성했는데, 'data-label' 속성을 가진 컨트롤을 자동으로 확장하여 위의 구조로 표시됩니다:</p>\n<pre><code class=\"hljs language-js\">&#x3C;input name=<span class=\"hljs-string\">\"email\"</span> required\n  data-label=<span class=\"hljs-string\">\"Email address\"</span>\n  placeholder=<span class=\"hljs-string\">\"john@doe.com\"</span>\n/>\n</code></pre>\n<img src=\"/assets/img/2024-06-19-ThePUREManifestoforWebStandardsbasedDesignSystems_4.png\">\n<div class=\"content-ad\"></div>\n<p>매우 간단한 점진적 개선 방법은 HTML 입력의 모든 표준 로직이 보존된다는 것을 의미합니다. Web 컴포넌트가 Web Forms에서 일등 시민으로 동작하도록 하는 데 필요한 것과 비교해보면, 절약할 수 있는 규모를 감을 수 있을 겁니다.</p>\n<p>우리는 모든 폼 요소에 이 방법을 사용하기로 결정했고, 우리 자체 맞춤형 컴포넌트와 같이 네이티브가 아닌 HTML 요소를 사용하더라도 동일한 점진적 개선을 사용할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\">&#x3C;<span class=\"hljs-keyword\">switch</span>-check name=<span class=\"hljs-string\">\"email\"</span> required\n  data-label=<span class=\"hljs-string\">\"Email address\"</span>\n  placeholder=<span class=\"hljs-string\">\"john@doe.com\"</span>\n>&#x3C;/<span class=\"hljs-keyword\">switch</span>-check>\n</code></pre>\n<h1>우선순위 3: 사용자 정의 태그 시험 (스타일 적용하기)</h1>\n<div class=\"content-ad\"></div>\n<p>많은 웹 표준(예: PWA — 이름은 무슨 뜻일까?)과 마찬가지로, 웹 컴포넌트는 HTML 언어 자체의 확장성을 통해 시작되는 점진적인 향상을 제공합니다. 이는 사용자 정의 태그를 사용하는 것으로 이루어져 있습니다.</p>\n<p>따라서, 사용자 정의 태그는 웹 컴포넌트가 아닙니다. 웹 컴포넌트는 기능이 첨부된 사용자 정의 태그입니다.</p>\n<p>사용자 정의 태그는 단순히 선언함으로써 사용할 수 있으며, 해당 태그에 첨부된 웹 컴포넌트를 정의하지 않고 사용자 정의 태그를 사용하는 것은 HTML 구성 요소화에 유효한 접근 방식일 수 있습니다.</p>\n<p>가끔은 의미있는 앵커 포인트가 있는 것이면서 해당 포인트에 특정 사용자 정의 태그 CSS를 첨부하는 것만으로 충분할 수 있습니다. 확실히 잘 선택된 사용자 정의 태그 이름은 향후 개발자가 당신의 애플리케이션 흐름을 읽는 데 도움이 됩니다!</p>\n<div class=\"content-ad\"></div>\n<p>하지만 사용자 정의 태그를 정의할 때는 언제나 CSS만 적용할 경우(기능은 없음)일까요?</p>\n<p>내 기준은 다음과 같습니다:</p>\n<ul>\n<li>우리의 목표와 가장 일치하는 의미론적 요소가 없습니다.</li>\n<li>사용자 정의 태그는 사용자 정의 방식을 따르는 내부 HTML을 기대하는 래퍼입니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\">&#x3C;custom-grid columns=<span class=\"hljs-string\">\"1\"</span>>\n  [내용을 입력하세요]\n&#x3C;/custom-grid>\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>위의 예제는 Markdown 형식의 표로 변경해야 합니다.</p>\n<pre><code class=\"hljs language-js\">custom-grid {\n  <span class=\"hljs-attr\">display</span>: grid;\n  grid-<span class=\"hljs-attr\">gap</span>: <span class=\"hljs-title function_\">var</span>(--gutter-small, .5rem);\n  &#x26;[columns=<span class=\"hljs-string\">\"1\"</span>]{\n    grid-template-<span class=\"hljs-attr\">columns</span>: 1fr;\n  }\n}\n</code></pre>\n<p>그리고 다른 복잡한 예제로는 최근에 작성한 TabStrip이 있습니다. 이는 tab-strip라는 사용자 지정 태그를 사용하며 매우 구체적인 콘텐츠를 필요로 합니다: 각 탭은 하나의 링크와 하나의 div로 구성된 섹션으로 표현됩니다.</p>\n<pre><code class=\"hljs language-js\">&#x3C;tab-strip>\n  <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">section</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"tab1\"</span>></span><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"#insights\"</span>></span>Tab 1<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">a</span>></span>\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"tab-content\"</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"overview\"</span>></span>\n      Tab 1 content\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n  <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">section</span>></span></span>  \n  <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">section</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"tab2\"</span>></span><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"#tab2\"</span>></span>Tab 2<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">a</span>></span>\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"tab-content\"</span>></span>\n      Tab 2 content\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n  <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">section</span>></span></span>  \n  <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">section</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"tab3\"</span>></span><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"#tab3\"</span>></span>Tab 3<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">a</span>></span>\n    <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"tab-content\"</span>></span>\n      Tab 3 content\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n  <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">section</span>></span></span>\n&#x3C;/tab-strip>\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>물론, 상황이 더 복잡해지면, 예를 들어 탭 콘텐츠를 탭을 클릭할 때 가져와야 하는 경우, 다음 단계는 사용자 정의 태그의 로직을 정의하고 이를 웹 구성 요소로 만드는 것입니다.</p>\n<h1>우선순위 4: 웹 컴포넌트 로직 추가 (Light DOM 사용)</h1>\n<p>사용자 정의 태그를 사용할 때 트리거되는 기능이 필요한 경우, customElements.define()를 사용하여 해당 기능을 첨부해야 합니다.</p>\n<p>많은 경우 전역 스타일링을 활용하거나 전역 상태를 처리하고 버블링 이벤트를 캐치하는 등 JavaScript 기능을 가진 컨테이너 유형의 요소가 필요할 수 있습니다.</p>\n<div class=\"content-ad\"></div>\n<p>이 컨테이너 요소를 고려해보세요:</p>\n<pre><code class=\"hljs language-js\">&#x3C;spa-route>\n  [<span class=\"hljs-variable constant_\">HTML</span> 내용을 입력하세요]\n&#x3C;/spa-route>\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> {html, <span class=\"hljs-title class_\">LitElement</span>} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"lit\"</span>;\n<span class=\"hljs-keyword\">import</span> {<span class=\"hljs-title class_\">Router</span>} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"./router\"</span>;\n<span class=\"hljs-keyword\">import</span> {config} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"../app-config\"</span>;\n<span class=\"hljs-keyword\">import</span> {until} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"lit/directives/until.js\"</span>;\n\ncustomElements.<span class=\"hljs-title function_\">define</span>(\n  <span class=\"hljs-string\">\"spa-route\"</span>,\n\n  <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">PWARenderRoute</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">LitElement</span> {\n\n     #router = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Router</span>(config.<span class=\"hljs-property\">routes</span>));\n\n    <span class=\"hljs-comment\">// Light DOM 사용</span>\n    <span class=\"hljs-title function_\">createRenderRoot</span>(<span class=\"hljs-params\"></span>) {\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>;\n    }\n\n    <span class=\"hljs-title function_\">render</span>(<span class=\"hljs-params\"></span>) {\n      <span class=\"hljs-keyword\">return</span> html`<span class=\"hljs-subst\">${until(<span class=\"hljs-variable language_\">this</span>.#router.matchRoute(), app.loader)}</span><span class=\"xml\">`</span>;\n    }\n  }\n)\n</code></pre>\n<p>이 코드는 SPA 라우터의 간소화된 버전으로, 구성된 라우트에 기반하여 콘텐츠를 렌더링합니다. 완전한 예제는 \"The Browser is your Framework: Building a PWA with only Web Components and Lit\"에서 확인할 수 있습니다.</p>\n<div class=\"content-ad\"></div>\n<p>웹 컴포넌트 중심의 PWA에서는 본문 태그 아래에 모든 것을 포함하는 웹 컴포넌트를 두는 것이 모범 사례입니다.</p>\n<pre><code class=\"hljs language-js\">&#x3C;!<span class=\"hljs-variable constant_\">DOCTYPE</span> html>\n&#x3C;html lang=\"en\">\n\n&#x3C;head>\n    &#x3C;meta charset=\"UTF-8\"/>\n    &#x3C;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, user-scalable=1.0, minimum-scale=1.0, maximum-scale=1.0\">\n    &#x3C;title>My App&#x3C;/title>\n    &#x3C;link rel=\"manifest\" href=\"/manifest.webmanifest\"/>\n    &#x3C;meta name=\"apple-mobile-web-app-capable\" content=\"yes\"/>\n    &#x3C;meta name=\"mobile-web-app-capable\" content=\"yes\"/>\n    &#x3C;meta name=\"theme-color\" content=\"#655122\"/>\n    &#x3C;link rel=\"apple-touch-icon\" href=\"/assets/img/icon512px\"/>\n    &#x3C;link rel=\"shortcut icon\" href=\"/assets/img/favicon.ico\">\n    &#x3C;link href=\"/assets/css/main.css\" rel=\"stylesheet\"/>\n    &#x3C;script type=\"module\" defer src=\"/assets/js/app.js\">&#x3C;/script>\n&#x3C;/head>\n\n&#x3C;body>\n\n&#x3C;my-app class=\"app-canvas\">\n  &#x3C;main>\n    &#x3C;spa-route>&#x3C;/spa-route>\n  &#x3C;/main>\n&#x3C;/my-app>\n\n&#x3C;/body>\n\n&#x3C;/html>\n</code></pre>\n<p>그러니까, my-app 구성요소는 글로벌 앱 상태를 관리하고, localStorage를 처리하며, 인증 세션을 관리하며, 버블링 이벤트를 처리합니다.</p>\n<h1>5순위: 완전한 웹 컴포넌트 생성하기 (Shadow DOM 활용)</h1>\n<div class=\"content-ad\"></div>\n<p>위에 표시된 코드 중 일부에서 Light DOM을 사용하는 꿀팁(Light DOM을 사용하면 전역 스타일이 웹 컴포넌트의 태그 아래에 모두 적용됩니다)은 다음과 같은 Lit 코드입니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// Light DOM 사용하기</span>\n<span class=\"hljs-title function_\">createRenderRoot</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>;\n}\n</code></pre>\n<p>기본적으로 LitElement 기반의 웹 컴포넌트는 Shadow DOM을 사용하여 렌더링되므로 확장된 HTMLElement 자체를 반환하여 사용을 비활성화해야 합니다!</p>\n<p>커스텀 HTML을 출력하고 문서의 전역 스타일과 격리되어야 하는 커스텀 스타일을 사용하는 복잡한 컴포넌트의 경우, 이 아이디어가 좋지만 몇 가지 추가 복잡성을 받아 들여야 합니다:</p>\n<div class=\"content-ad\"></div>\n<ul>\n<li>먼저 Shadow DOM의 격리 수준에 대해 알아야 합니다. 웹 구성 요소 중에서 복잡한 부분이 있다면 바로 그것입니다.</li>\n<li>CSS 속성(또는 변수)을 사용하는 것은 추가 작업이 필요합니다.</li>\n<li>테마 공유(테두리, 색상, 그림자, 안쪽 간격 등)는 조금 더 복잡하고 설명이 필요합니다.</li>\n<li>컨텐츠 배치(슬롯 사용)는 매우 특정하며 항상 명확하지는 않습니다.</li>\n<li>접근성 및 사용 용이성 노력(특히 양식 요소를 빌드할 때)은 개발 시간을 늘릴 것입니다.</li>\n</ul>\n<p>이렇게 말씀드리는 것에, 많은 구성 요소와 흐름이 있는 복잡한 컨트롤은 물론 단일 단위로 작동합니다. 당연히 매우 가치가 있고, 웹 표준은 이러한 모듈성을 만들기 위한 좋은 방법을 제공합니다.</p>\n<h1>결론</h1>\n<p>웹 구성 요소 중심의 애플리케이션 개발은 훌륭하고, 초고속 그리고 가벼운 PWA를 제공하지만 웹 구성 요소는 훌륭한 앱을 제공하는 유일한 수단으로 간주되어서는 안 됩니다. 그들에 대한 많은 사용 사례가 있지만, 항상 그것들이 다른 웹 표준과 마찬가지로 점진적 향상의 한 형태임을 염두에 두어야 합니다.</p>\n<div class=\"content-ad\"></div>\n<p>따라서 코드를 모조리 웹 구성 요소 또는 완전히 격리된 Shadow DOM을 사용하는 것에 대해서는 신중하게 고려해야 합니다.</p>\n<p>이 선언은 Lean Startup 관점에서 항상 올바르고 실용적이며 때로는 기회적인 선택을 하는 데 관한 것입니다. 항상 가장 간단하고 지속 가능한 해결책을 찾으려 노력하며 잡기 어려운 방법으로 접근합니다.</p>\n<p>가끔은 재사용하기 쉬운 가벼운 구조부터 시작하여 미래에 프로그레시브한 향상을 위한 여지도 남겨두는 것을 의미합니다 😉.</p>\n<p>PURE 선언의 많은 개념은 이전 (오픈 소스) 작업에서 기인한 것으로, PurePWA - 파워 &#x26; 순수성 (pure-pwa.com)과 같은 작업이 있습니다.</p>\n</body>\n</html>\n"},"__N_SSG":true}