{"pageProps":{"posts":[{"title":"Flutter 앱에 디자인 시스템 적용하는 방법 단계별 가이드","description":"","date":"2024-06-22 05:11","slug":"2024-06-22-HowtoimplementyourdesignsysteminaFlutterapp12","content":"\n<img src=\"/assets/img/2024-06-22-HowtoimplementyourdesignsysteminaFlutterapp12_0.png\" />\n\n코드를 깔끔하게 작성할 때 우리는 종종 앱의 기능을 위해 최상의 디자인 및 아키텍처 패턴을 구현하는 것을 먼저 생각합니다. 이것은 확실히 좋은 실천 방법이며, 여러분에게 충분히 권장할 수밖에 없어요.\n\n하지만 프론트엔드 코드는 어떻게 해야 할까요? 어떻게 앱에서 디자인 시스템을 적절하게 구현할 수 있을까요? 그리고 디자인 시스템이란 무엇인가요? 그 목적과 가치는 무엇일까요?\n\n이 글은 Aloïs Deniel의 작업에서 영감을 받았습니다. 해당 작업은 여기에서 찾아볼 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n# 디자인 시스템? 디자인 시스템이 정확히 뭘까요?\n\n우선 시작해 봅시다.\n\n디자인 시스템은 재사용 가능한 컴포넌트, 스타일 가이드(글꼴, 색상, 크기 등), 표준들의 집합으로, 디지털 제품의 디자인에서 일관성과 효율성을 촉진하기 위해 구성됩니다. 다양한 플랫폼과 애플리케이션에서 시각적 외형, 동작 및 사용자 경험의 일관성을 보장하기 위해 디자이너와 개발자들을 위한 중앙화된 자원으로 작용합니다.\n\n모바일 앱의 경우, 디자인 시스템은 보통 3가지 카테고리로 나뉘어 집니다(이 사용 사례에 대해서 이 글의 나머지 부분도 이에 고수할 것입니다):\n\n<div class=\"content-ad\"></div>\n\n- 원자 수준: 이 수준에서는 디자인 시스템의 매우 기본적인 부분인 색상, 글꼴, 그림자, 공통 간격, 카드의 반지름(있는 경우), 아이콘 등과 관련된 모든 내용을 찾을 수 있습니다.\n- 분자 수준: 이 수준에서는 버튼, 체크박스, 라디오 버튼, 구분선, 입력 필드 등과 같은 가장 기본적이고 일반적인 위젯을 찾을 수 있습니다.\n- 세포 수준: 이 수준에서는 앱바, 복잡한 카드 또는 사용자 정의 위젯(CustomPainter를 사용하는) 등과 같은 더 복잡한 위젯을 찾을 수 있습니다. 이러한 위젯은 앱 전체 또는 특정 페이지에 특화될 수 있습니다.\n\n# 그러면 Material Design 또는 Cupertino Design으로 작업할 수 있겠네요.\n\n음, 예... 하지만 사실은 아닙니다.\n\n확실한 것은, Flutter SDK에서 제공하는 기본 테마를 사용하여 앱을 디자인할 수 있습니다. 그러나 빠르게 막히게 되고, 앱이 초보 학생이 만든 기본적인 앱처럼 보일 가능성이 높습니다.\n\n<div class=\"content-ad\"></div>\n\n예를 들어, 기본 테마의 텍스트 테마의 제목 스타일을 사용자 정의할 수 있지만, 큰, 중간, 작은 3단계로 제한됩니다. 이것이 너무 제한적일 수 있습니다.\n\n## 알아야 할 점. 어디서 시작해야 하나요?\n\n### 전용 패키지\n\n디자인 시스템을 위한 전용 패키지를 생성하는 것이 좋습니다. 필수는 아니지만, 중간 규모의 프로젝트에서도 이 부분을 완전히 건너뛸 수 있지만, 두 가지 이유로 이렇게 하는 것을 권장합니다:\n\n<div class=\"content-ad\"></div>\n\n- 여러 앱 간에 쉽게 구현된 디자인 시스템을 공유할 수 있습니다.\n- 앱의 로직에 대해 위젯이 알고 있는 것이 전혀 없다는 것이 보장됩니다.\n\n## 네이밍 규칙\n\n디자이너와 협업 중이라면 네이밍 규칙에 동의하는 것을 적극 권장합니다. 특히 앱의 서로 다른 화면을 구현하기 시작할 때 이는 특히 중요합니다. 각 화면의 각 구성 요소의 이름을 알고 있다면 (특히 Figma나 유사한 도구를 사용하는 경우) 설계 시스템 문서와 IDE 간에 오가며 작업 중인 문서에 해당하는 올바른 위젯을 찾아야 하는 번거로움을 피할 수 있습니다.\n\n# 이제 디자인 시스템을 구현하는 시간입니다!\n\n<div class=\"content-ad\"></div>\n\n## 테마 확장\n\n테마 확장은 사용자 정의 테마를 만드는 데 훌륭한 도구입니다. 일반적으로 색상에 사용되지만 때로는 여러 위젯에서 공유되는 사용자 정의 텍스트 테마와 차원에도 사용됩니다.\n\n먼저 색상부터 시작해보겠습니다. 다음과 같이 AppColorsTheme이라는 새 클래스를 생성하세요:\n\n```js\nclass AppColorsTheme extends ThemeExtension<AppColorsTheme>\n{\n  // 참조 색상:\n  static const _grey = Color(0xFFB0B0B0);\n  static const _green = Color(0xFF00C060);\n  static const _red = Color(0xFFED4E52);\n\n  // 앱 전체에서 사용되는 실제 색상:\n  final Color backgroundDefault;\n  final Color backgroundInput;\n  final Color snackbarValidation;\n  final Color snackbarError;\n  final Color textDefault;\n\n  // 비공개 생성자 (아래의 팩토리를 대신 사용하세요):\n  const AppColorsTheme._internal({\n    required this.backgroundDefault,\n    required this.backgroundInput,\n    required this.snackbarValidation,\n    required this.snackbarError,\n    required this.textDefault,\n  });\n\n  // 라이트 모드용 팩토리:\n  factory AppColorsTheme.light() {\n    return AppColorsTheme._internal(\n      backgroundDefault: _grey,\n      backgroundInput: _grey,\n      snackbarValidation: _green,\n      snackbarError: _red,\n      textDefault: _grey\n    );\n  }\n\n  // 다크 모드용 팩토리:\n  factory AppColorsTheme.dark() {\n    return AppColorsTheme._internal(...);\n  }\n\n  @override\n  ThemeExtension<AppColorsTheme> copyWith({bool? lightMode})\n  {\n    if (lightMode == null || lightMode == true) {\n      return AppColorsTheme.light();\n    }\n    return AppColorsTheme.dark();\n  }\n\n  @override\n  ThemeExtension<AppColorsTheme> lerp(\n    covariant ThemeExtension<AppColorsTheme>? other,\n    double t) => this;\n}\n```\n\n<div class=\"content-ad\"></div>\n\n여기 몇 가지 언급할 사항이 있어요:\n\n- 내 앱에서 실제로 사용되는 색상과 기본 색상을 의도적으로 분리했어요. 이유는 경우에 따라 다른 위젯들이 한 모드에서 동일한 색상을 공유하더라도, 다른 모드에서는 다른 색상이 필요할 수 있기 때문이에요. 이는 꽤 드물긴 하지만요.\n- 여기서 팩토리를 사용하면 다양한 모드를 생성하는 것이 매우 간편해져요. 그래서 각 모드에 필요한 색상을 매우 쉽게 선택할 수 있어요. 분명히 몇 분 안에 새 모드를 추가할 수 있어요! 그리고 단지 다크 모드와 라이트 모드로만 제한되지 않고, 추가하고 싶은 어떤 색상 모드든 추가할 수 있어요!\n- 저는 lerp() 메서드를 단순히 this로 다시 반환하여 재정의했지만, 만약 다른 색상 모드들 간의 부드러운 전환을 만들고 싶다면 여기서 보여주는 대로 Color.lerp()를 사용할 수 있어요. 크게 유용하진 않겠지만, 어쨌든 말이죠.\n\n이제 글꼴에 대해 계속해봅시다. 아래와 같이 새 클래스인 AppTextsTheme을 생성해보세요:\n\n```js\nclass AppTextsTheme extends ThemeExtension<AppTextsTheme>\n{\n  static const _baseFamily = \"Base\";\n\n  final TextStyle labelBigEmphasis;\n  final TextStyle labelBigDefault;\n  final TextStyle labelDefaultEmphasis;\n  final TextStyle labelDefaultDefault;\n\n  const AppTextsTheme._internal({\n    required this.labelBigEmphasis,\n    required this.labelBigDefault,\n    required this.labelDefaultEmphasis,\n    required this.labelDefaultDefault,\n  });\n\n  factory AppTextsTheme.main() => AppTextsTheme._internal(\n    labelBigEmphasis: TextStyle(\n      fontFamily: _baseFamily,\n      fontWeight: FontWeight.w400,\n      fontSize: 18,\n      height: 1.4,\n    ),\n    labelBigDefault: TextStyle(\n      fontFamily: _baseFamily,\n      fontWeight: FontWeight.w300,\n      fontSize: 18,\n      height: 1.4,\n    ),\n    labelDefaultEmphasis: TextStyle(\n      fontFamily: _baseFamily,\n      fontWeight: FontWeight.w400,\n      fontSize: 16,\n      height: 1.4,\n    ),\n    labelDefaultDefault: TextStyle(\n      fontFamily: _baseFamily,\n      fontWeight: FontWeight.w300,\n      fontSize: 16,\n      height: 1.4,\n    ),\n  );\n\n  @override\n  ThemeExtension<AppTextsTheme> copyWith()\n  {\n    return AppTextsTheme._internal(\n      labelBigEmphasis: labelBigEmphasis,\n      labelBigDefault: labelBigDefault,\n      labelDefaultEmphasis: labelDefaultEmphasis,\n      labelDefaultDefault: labelDefaultDefault,\n    );\n  }\n\n  @override\n  ThemeExtension<AppTextsTheme> lerp(\n    covariant ThemeExtension<AppTextsTheme>? other,\n    double t) => this;\n}\n```\n\n<div class=\"content-ad\"></div>\n\n여기 몇 가지 언급할 사항이 있습니다:\n\n- 가능한 한 적은 글꼴을 사용하도록 노력하고, 앱에서 사용하는 글꼴에 대한 설계팀과의 명명 규칙에 합의하는 것이 중요합니다. 자주 사용할 수 있기 때문에 모의 구성에서 사용해야 할 올바른 글꼴을 알고있는 것은 매우 소중한 시간과 에너지를 절약할 수 있습니다.\n- 이 사용 사례에서는 lerp() 메서드가 무용지물이므로 그냥 이를 반환합니다.\n- 간단함을 위해 여기서 글꼴 크기를 하드코딩했지만, 나중에 화면 크기에 따라 글꼴 크기가 다양할 수 있도록 일부 응답 형식을 추가하는 방법을 보겠습니다.\n\n마지막으로, 다음과 같이 차원에 대한 새로운 클래스인 AppDimensionsTheme을 생성합시다:\n\n```js\nclass AppDimensionsTheme extends ThemeExtension<AppDimensionsTheme>\n{\n  final double radiusHelpIndication;\n  final EdgeInsets paddingHelpIndication;\n\n  const AppDimensionsTheme._internal({\n    required this.radiusHelpIndication,\n    required this.paddingHelpIndication,\n  });\n\n  factory AppDimensionsTheme.main() => AppDimensionsTheme._internal(\n    radiusHelpIndication: 8,\n    paddingHelpIndication: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),\n  );\n\n  @override\n  ThemeExtension<AppDimensionsTheme> copyWith()\n  {\n    return AppDimensionsTheme._internal(\n      radiusHelpIndication: radiusHelpIndication,\n      paddingHelpIndication: paddingHelpIndication,\n    );\n  }\n\n  @override\n  ThemeExtension<AppDimensionsTheme> lerp(\n    covariant ThemeExtension<AppDimensionsTheme>? other,\n    double t) => this;\n}\n```\n\n<div class=\"content-ad\"></div>\n\n여기 몇 가지 언급할 사항이 있어요:\n\n- 앱의 각 차원에 이 클래스를 사용해야 할까요? 절대 그렇지 않아요. 차원을 한 곳에만 설정해야 하는 경우나 동일 위젯 내에서 여러 곳에 설정할 경우 해당 위젯에 유지하세요(예: const로). 위의 글꼴 및 색상 테마와는 달리 해당 클래스를 여러 위젯에서 차원을 공유해야 하는 경우에만 추천드립니다.\n- 예상하신 대로, 반응성을 구현하는 좋은 출발점이기도 하지만, 이에 대해서는 나중에 다루겠습니다.\n\n# 멋져요. 어떻게 사용하나요?\n\n## 주 파일\n\n<div class=\"content-ad\"></div>\n\n먼저 main.dart 파일로 이동하신 후, MaterialApp() 위젯 안에 ThemeData? 타입의 theme 속성이 있습니다. 단순히 아래와 같이 확장을 추가할 수 있습니다:\n\n```js\nMaterialApp(\n  ...\n  theme: Theme.of(context).copyWith(\n    extensions: [\n      AppDimensionsTheme.main(),\n      AppColorsTheme.light(),\n      AppTextsTheme.main(),\n    ],\n  ),\n  ...\n),\n```\n\n## ThemeData extension\n\n다음 단계, 필수는 아니지만, 확장에 액세스하는 보일러플레이트 코드를 피하고 코드 구문을 간소화하는 데 매우 유용합니다. 다음과 같이 ThemeData 확장을 만드세요:\n\n<div class=\"content-ad\"></div>\n\n```js\n확장자 ThemeDataExtended에서 ThemeData에 대한 다음과 같은 테이블 태그를 Markdown 형식으로 변경하십시오.\n\n## 구현 예시\n\n이제 다음 예시와 같이 테마를 사용할 수 있습니다.\n\nText(\n  \"내 텍스트 예시\",\n  style: Theme.of(context).appTexts.labelDefaultEmphasis.copyWith(\n    color: Theme.of(context).appColors.textDefault,\n  ),\n)\n\n<div class=\"content-ad\"></div>\n\n# 반응형에 대해 이야기했었죠. 테마 파일에 적용할 수 있을까요?\n\n물론이죠! 함께 알아봅시다.\n\n## FlutterView 확장\n\n다시 말씀드리지만, 다음 단계는 필수는 아닙니다. 그러나 앱에서 적합한 반응형을 구현하는 데 매우 도움이 될 수 있습니다. 또한, 이는 단순히 예시일 뿐이니 필요에 맞게 수정해 사용해주시기 바랍니다.\n\n<div class=\"content-ad\"></div>\n\n위의 내용을 한국어로 번역해 드리겠습니다:\n\n먼저 다음과 같이 FlutterView 확장을 생성해 봅시다:\n\nextension FlutterViewExtended on FlutterView\n{\n  static const double responsive360 = 360;\n  static const double responsive480 = 480;\n  static const double responsive600 = 600;\n  static const double responsive800 = 800;\n  static const double responsive900 = 900;\n  static const double responsive1200 = 1200;\n\n  double get logicalWidth => physicalSize.width / devicePixelRatio;\n  double get logicalHeight => physicalSize.height / devicePixelRatio;\n  double get logicalWidthSA => (physicalSize.width - padding.left - padding.right) / devicePixelRatio;\n  double get logicalHeightSA => (physicalSize.height - padding.top - padding.bottom) / devicePixelRatio;\n\n  bool get isSmallSmartphone\n  {\n    if (logicalWidthSA < logicalHeightSA)\n    {\n      return (logicalWidthSA <= responsive360 || logicalHeightSA <= responsive600);\n    }\n    else\n    {\n      return (logicalWidthSA <= responsive600 || logicalHeightSA <= responsive360);\n    }\n  }\n\n  bool get isRegularSmartphoneOrLess\n  {\n    if (logicalWidthSA < logicalHeightSA)\n    {\n      return (logicalWidthSA <= responsive480 || logicalHeightSA <= responsive800);\n    }\n    else\n    {\n      return (logicalWidthSA <= responsive800 || logicalHeightSA <= responsive480);\n    }\n  }\n\n  bool get isSmallTabletOrLess\n  {\n    if (logicalWidthSA < logicalHeightSA)\n    {\n      return (logicalWidthSA <= responsive600 || logicalHeightSA <= responsive900);\n    }\n    else\n    {\n      return (logicalWidthSA <= responsive900 || logicalHeightSA <= responsive600);\n    }\n  }\n\n  bool get isRegularTabletOrLess\n  {\n    if (logicalWidthSA < logicalHeightSA)\n    {\n      return (logicalWidthSA <= responsive800 || logicalHeightSA <= responsive1200);\n    }\n    else\n    {\n      return (logicalWidthSA <= responsive1200 || logicalHeightSA <= responsive800);\n    }\n  }\n}\n\nisSmallSmartphone 및 이후의 getter들이 필수는 아니지만, 위젯을 반응형으로 구현하고 싶을 때마다 다양한 값의 여러 개의 브레이크포인트를 추가하는 것보다 훨씬 간단하고 깔끔한 방식으로 반응형을 구현하는 데 도움이 될 것입니다. 이제 이전에 만든 AppDimensionsTheme로 돌아가서 다음과 같이 수정할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n클래스 AppDimensionsTheme은 ThemeExtension<AppDimensionsTheme>으로 확장됩니다.\n{\n  ...\n\n  factory AppDimensionsTheme.main(FlutterView flutterView) => AppDimensionsTheme._internal(\n    radiusHelpIndication: flutterView.isSmallSmartphone ? 8 : 16, // <- 여기서 반응형이 사용됩니다!\n    paddingHelpIndication: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),\n  );\n\n  ...\n}\n\n보시는 대로, FlutterView의 인스턴스를 AppDimensionsTheme.main의 인수로 전달합니다. 이전에 생성한 확장을 import하는 것을 잊지 마세요.\n\n그리고 main.dart 파일을 다음과 같이 업데이트하는 것을 잊지 마세요:\n\nMaterialApp(\n  ...\n  theme: Theme.of(context).copyWith(\n    extensions: [\n      AppDimensionsTheme.main(View.of(context)),\n      ...\n    ],\n  ),\n  ...\n)\n```\n\n<div class=\"content-ad\"></div>\n\n자 이제 앱에서 radiusHelpIndication을 사용할 때마다, 작은 스마트폰에서는 자동으로 8을 반환하고 그렇지 않으면 16을 반환합니다. 정말 간단하죠.\n\n그런데 기다려주세요! MediaQuery 대신에 FlutterView를 사용하는 이유는 뭘까요? 실은 둘 중 어느 것이라도 상호 교환해서 사용할 수 있습니다. 거의요.\n\n하지만 사실은 약간 다른 점이 있습니다. 위의 예시에서 View.of(context) 대신에 MediaQuery.of(context)를 사용하고 싶다고 가정해봅시다. 이것도 잘 동작하지만, MediaQuery를 사용하는 경우 위젯이 FlutterView를 사용할 때보다 더 자주 생성될 수 있는 경우가 있습니다.\n\n그 예로는 가상 키보드를 열고 닫을 때(예: TextFormField에 포커스를 주거나 해제할 때) 추가적으로 빌드가 발생하는 것이 있습니다. 물론 MediaQuery.sizeOf(context)와 같은 것을 사용하여 이를 수정할 수 있지만, 그것을 덜 편한 것으로 여기기도 합니다. 최종적으로 어떻게 할지는 여러분에게 달려 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이제 2부로 계속하실 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-22-HowtoimplementyourdesignsysteminaFlutterapp12_0.png"},"coverImage":"/assets/img/2024-06-22-HowtoimplementyourdesignsysteminaFlutterapp12_0.png","tag":["Tech"],"readingTime":12},{"title":"Flutter에서 MQTT로 ESP8266 IOT 기기 연결하는 방법 종합 가이드  PART I","description":"","date":"2024-06-22 05:09","slug":"2024-06-22-MQTTinFlutterAComprehensiveGuidetoConnectApplicationswithESP8266IOTDevicesPARTI","content":"\n\n요즘에는 많은 IOT 기기들과 작업하고 있어요. 많은 기기들을 다루는 데 큰 어려움이 있어요. 운영, 데이터 수집, 유지관리 등을 모두 집중적으로 하기가 어려워요.\n\n![이미지](/assets/img/2024-06-22-MQTTinFlutterAComprehensiveGuidetoConnectApplicationswithESP8266IOTDevicesPARTI_0.png)\n\n## 리얼타임 기기들이 클라우드와 어떻게 소통할 수 있는 가장 좋은 방법은 무엇인가요?\n\n![이미지](/assets/img/2024-06-22-MQTTinFlutterAComprehensiveGuidetoConnectApplicationswithESP8266IOTDevicesPARTI_1.png)\n\n<div class=\"content-ad\"></div>\n\n# MQTT 프로토콜에 대해 알아봐요!!!!!!!!\n\n이 글에서는 다음의 내용을 다룹니다.\n\n- MQTT 브로커와의 ESP8266 연결\n- MQTT 브로커와의 Flutter 연결\n\n가이드를 두 부분으로 나눴어요.\n\n<div class=\"content-ad\"></div>\n\n첫 번째 파트에서는 우리의 브로커와 Esp8266을 구성하는 방법에 대해 다룹니다.\n\n두 번째 파트에서는 어플리케이션에서 데이터를 읽고 쓰는 방법에 대해 다룹니다.\n\n## MQTT 브로커란 무엇인가요?\n\n아키텍처 사이에서 중개자 역할을 한다고 생각해보세요. Esp8266 장치는 데이터를 브로커로 보내고, 거기서 데이터가 저장됩니다. 그런 후 어플리케이션은 MQTT 브로커에 연결하여 데이터에 접근할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n![2024-06-22-MQTTinFlutterAComprehensiveGuidetoConnectApplicationswithESP8266IOTDevicesPARTI_2.png](/assets/img/2024-06-22-MQTTinFlutterAComprehensiveGuidetoConnectApplicationswithESP8266IOTDevicesPARTI_2.png)\n\n**참고:** 대부분의 경우, 데이터를 처리하기 위해 백엔드가 필요하고 응용 프로그램이 이에 액세스하지만, MQTT를 사용하여 연결하고 데이터를 보내는 방법을 알고 나면 쉽다는 것을 이 문서에서 다루지는 않습니다. 나중에 전체 IOT 인프라를 보여주는 글을 쓸 수도 있습니다.\n\n# 준비물\n\n- MQTT의 이해\n- 발행/구독 아키텍처의 기본 이해\n- ESP8266 Node MCU 모듈\n- Flutter 또는 다른 기본 프레임워크에 대한 이해\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-22-MQTTinFlutterAComprehensiveGuidetoConnectApplicationswithESP8266IOTDevicesPARTI_3.png)\n\n# 파트 1: 설정\n\n전체 아키텍처를 구현하려면 먼저 MQTT 브로커가 필요합니다. HiveMQ와 EMQX와 같은 많은 무료 브로커들이 있으며 Mosquitto를 사용하여 로컬 브로커를 만들 수도 있습니다.\n\n![image](/assets/img/2024-06-22-MQTTinFlutterAComprehensiveGuidetoConnectApplicationswithESP8266IOTDevicesPARTI_4.png)\n\n\n<div class=\"content-ad\"></div>\n\nEMQX에 계정을 등록하고 브로커를 생성했습니다.\n\n![이미지](/assets/img/2024-06-22-MQTTinFlutterAComprehensiveGuidetoConnectApplicationswithESP8266IOTDevicesPARTI_5.png)\n\n그런 다음 브로커에 액세스하는 데 사용될 몇 가지 사용자 계정을 만듭니다.\n\n![이미지](/assets/img/2024-06-22-MQTTinFlutterAComprehensiveGuidetoConnectApplicationswithESP8266IOTDevicesPARTI_6.png)\n\n<div class=\"content-ad\"></div>\n\n# Part 2: ESP8266 펌웨어\n\n펌웨어 작업을 시작하기 전에 몇 가지 알아야 할 사항이 있습니다.\n\n웹에서 MQTT 브로커에 액세스할 때 TLS를 사용하거나 사용하지 않을 수 있습니다. 제 경험상 TLS를 사용하지 않고 브로커에 연결하려고 시도하면 Esp8266에서 작동하지 않습니다. 모든 연결 요청이 거부됩니다. 따라서 저는 연결을 가장 안전하게 만드는 방법을 보여드리겠습니다.\n\n- 브로커에서 인증서를 다운로드하십시오 (나중에 필요할 것입니다)\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-22-MQTTinFlutterAComprehensiveGuidetoConnectApplicationswithESP8266IOTDevicesPARTI_7.png)\n\n- Arduino IDE를 열고 Esp8266을 설정합니다.\n\nEsp8266을 사용해본 적이 없다면, 이 가이드를 따를 수 있습니다.\n\n우선 라이브러리를 가져오겠습니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\r\n#include <ESP8266WiFi.h>\n\n#include <PubSubClient.h>\n\n// 이 부분은 선택 사항입니다. 센서 데이터로 보낼 무작위 숫자를 생성하기 위해 사용했습니다.\n#include <ESP8266TrueRandom.h>\n\n// 인터넷과의 시간 동기화에 사용됩니다.\n#include <time.h>\r\n```\n\n이제 자격 증명을 정의해 봅시다.\n\n```js\r\nconst char *ntp_server = \"0.pool.ntp.org\";     // 기본 NTP 서버\nconst long gmt_offset_sec = 0;            // GMT 오프셋(시간대에 맞게 조정)\nconst int daylight_offset_sec = 0;        // 일광 절약 시간 오프셋(초)\n\nconst char* SSID = \"************\";\nconst char* PASSWORD = \"************\";\n\nconst char* MQTT_HOST = \"************\"; // 브로커 대시보드에서 가져오세요\nconst int MQTT_PORT = 8883; // 기본 MQTT TCP TLS 포트\n\nconst char* MQTT_USERNAME = \"\";\nconst char* MQTT_PASSWORD = \"\";\nconst char* MQTT_TOPIC = \"test\";\n\nchar payload[10] = \"\";\n\nBearSSL::WiFiClientSecure espClient;\n\nPubSubClient mqtt_client(espClient);\r\n```\n\n이제 다운로드한 인증서 데이터를 입력해 봅시다. 텍스트 편집기로 해당 파일을 열어 내용을 복사하세요.\n\n<div class=\"content-ad\"></div>\n\n다음은 Markdown 형식으로 table 태그를 변경해주세요.\n\n```js\nstatic const char ca_cert[] = R\"EOF(\n|-----BEGIN CERTIFICATE-----|\n|---MIIDrzCCApegAwIBAgIQCDvgVpBCRrGhdWrJWZHHSjANBgkqhkiG9w0BAQUFADBh---|\n|---MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3---|\n|---d3cuZGlnaWNlcnQuYa9tMSAwHgYDVQQDExdEaWdpQ2VydCBHbG9iYWwgUm9vdCBD---|\n|-----END CERTIFICATE-----|\n)EOF\";\r\n```\n\n먼저, WiFi에 연결해야 합니다.\n\n```js\r\nvoid connectToWiFi() {\r\n    WiFi.begin(SSID, PASSWORD);\r\n    Serial.print(\"WiFi에 연결 중\");\r\n    while (WiFi.status() != WL_CONNECTED) {\r\n        delay(500);\r\n        Serial.print(\".\");\r\n    }\r\n    Serial.println(\"\\nWiFi 네트워크에 연결되었습니다\");\r\n}\r\n```\n\n<div class=\"content-ad\"></div>\n\n우리의 Esp8266과 시간을 동기화하기 위해 NTP(Network Time Protocol) 서버를 사용합니다.\n\n```js\nvoid syncTime() {\n    configTime(gmt_offset_sec, daylight_offset_sec, ntp_server);\n    \n    Serial.print(\"NTP 시간 동기화를 기다리는 중: \");\n\n    while (time(nullptr) < 8 * 3600 * 2) {\n        delay(1000);\n        Serial.print(\".\");\n    }\n\n    Serial.println(\"시간이 동기화되었습니다.\");\n    \n    struct tm timeinfo;\n    \n    if (getLocalTime(&timeinfo)) {\n        Serial.print(\"현재 시간: \");\n        Serial.println(asctime(&timeinfo));\n    \n    } else {\n        Serial.println(\"로컬 시간을 가져오지 못했습니다.\");\n    }\n}\n```\n\n브로커에 연결하려면 다음 함수를 사용할 것입니다.\n\n```js\nvoid connectToMQTTBroker() {\n    \n    // 우리의 인증서를 사용하여 신뢰할 수 있는 연결 요청을 수행합니다\n    BearSSL::X509List serverTrustedCA(ca_cert);\n\n    espClient.setTrustAnchors(&serverTrustedCA);\n\n    while (!mqtt_client.connected()) {\n\n        String client_id = \"esp8266-client-\" + String(WiFi.macAddress());\n        \n        Serial.printf(\"%s로 MQTT 브로커에 연결 중.....\\n\", client_id.c_str());\n        \n        if (mqtt_client.connect(client_id.c_str(), MQTT_USERNAME, MQTT_PASSWORD)) {\n            \n            Serial.println(\"MQTT 브로커에 연결되었습니다.\");\n        \n        } else {\n            char err_buf[128];\n            \n            espClient.getLastSSLError(err_buf, sizeof(err_buf));\n            \n            Serial.print(\"MQTT 브로커에 연결에 실패했습니다. rc=\");\n            Serial.println(mqtt_client.state());\n            Serial.print(\"SSL 오류: \");\n            Serial.println(err_buf);\n\n            delay(5000);\n        }\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n해당 함수를 사용하여 주제에 대한 데이터를 게시합니다.\n\n```js\nvoid publishData(int data){\n  // Int 데이터를 String으로 변환합니다.\n  itoa(data, payload, 10);\n\n  // 주제 \"test\"에 데이터를 게시합니다.\n  mqtt_client.publish(MQTT_TOPIC, payload);\n}\n```\n\n이벤트에 구독하려면 다음과 같이 작성합니다.\n\n```js\nvoid subscribeToTopic(char* topic){\n\n  mqtt_client.subscribe(topic);\n  Serial.print(\"주제에 구독함: \");\n  Serial.println(topic);\n}\n```\n\n<div class=\"content-ad\"></div>\n\n구독한 주제를 듣습니다.\n\n```js\nvoid mqttCallback(char *topic, byte *payload, unsigned int length) {\n    Serial.print(\"주제에서 메시지 받음: \");\n    Serial.println(topic);\n    Serial.print(\"메시지:\");\n    for (unsigned int i = 0; i < length; i++) {\n        Serial.print((char) payload[i]);\n    }\n    Serial.println();\n    Serial.println(\"-----------------------\");\n}\n```\n\n마지막으로 전체 펌웨어 코드를 작성해 봅시다.\n\n```js\n#include <ESP8266WiFi.h>\n#include <PubSubClient.h>\n#include <ESP8266TrueRandom.h>\n#include <time.h>\n\n// NTP 서버 설정\nconst char *ntp_server = \"0.pool.ntp.org\";     // 기본 NTP 서버\nconst long gmt_offset_sec = 0;            // GMT 오프셋(시간대에 따라 조정)\nconst int daylight_offset_sec = 0;        // 일광 절약 시간 오프셋(초)\n\nconst char* SSID = \"본인의 와이파이를 사용해주세요\";\nconst char* PASSWORD = \"패스워드\";\n\nconst char* MQTT_HOST = \"f4b0e072.ala.asia-southeast1.emqxsl.com\";\nconst int MQTT_PORT = 8883;\n\nconst char* MQTT_USERNAME = \"test2\";\nconst char* MQTT_PASSWORD = \"testpass123A\";\nconst char* MQTT_TOPIC = \"test\";\n\nchar payload[10] = \"\";\n\nstatic const char ca_cert[] = R\"EOF(\n-----BEGIN CERTIFICATE-----\n여기에 인증서 내용을 복사하세요\n-----END CERTIFICATE-----\n)EOF\";\n\nBearSSL::WiFiClientSecure espClient;\nPubSubClient mqtt_client(espClient);\n\nvoid subscribeToTopic(char* topic){\n\n  mqtt_client.subscribe(topic);\n  Serial.print(\"주제에 구독 완료: \");\n  Serial.println(topic);\n}\n\nvoid mqttCallback(char *topic, byte *payload, unsigned int length) {\n    Serial.print(\"주제에서 받은 메시지: \");\n    Serial.println(topic);\n    Serial.print(\"메시지:\");\n    for (unsigned int i = 0; i < length; i++) {\n        Serial.print((char) payload[i]);\n    }\n    Serial.println();\n    Serial.println(\"-----------------------\");\n}\n\nvoid connectToMQTTBroker() {\n    \n    // 인증서를 사용하여 신뢰할 수 있는 연결 요청을 수행합니다\n    BearSSL::X509List serverTrustedCA(ca_cert);\n\n    espClient.setTrustAnchors(&serverTrustedCA);\n\n    while (!mqtt_client.connected()) {\n\n        String client_id = \"esp8266-client-\" + String(WiFi.macAddress());\n        \n        Serial.printf(\"%s로 MQTT 브로커에 연결 중.....\\n\", client_id.c_str());\n        \n        if (mqtt_client.connect(client_id.c_str(), MQTT_USERNAME, MQTT_PASSWORD)) {\n            \n            Serial.println(\"MQTT 브로커에 연결됨\");\n\n            subscribeToTopic(\"test\");\n        \n        } else {\n            char err_buf[128];\n            \n            espClient.getLastSSLError(err_buf, sizeof(err_buf));\n            \n            Serial.print(\"MQTT 브로커에 연결 실패, 상태=\");\n            Serial.println(mqtt_client.state());\n            Serial.print(\"SSL 오류: \");\n            Serial.println(err_buf);\n\n            delay(5000);\n        }\n    }\n}\n\nvoid syncTime() {\n    configTime(gmt_offset_sec, daylight_offset_sec, ntp_server);\n    \n    Serial.print(\"NTP 시간 동기화 대기 중: \");\n\n    while (time(nullptr) < 8 * 3600 * 2) {\n        delay(1000);\n        Serial.print(\".\");\n    }\n\n    Serial.println(\"시간 동기화 완료\");\n    \n    struct tm timeinfo;\n    \n    if (getLocalTime(&timeinfo)) {\n        Serial.print(\"현재 시간: \");\n        Serial.println(asctime(&timeinfo));\n    \n    } else {\n        Serial.println(\"로컬 시간 획득 실패\");\n    }\n}\n\nvoid publishData(int data){\n  // 정수 데이터를 문자열로 변환합니다\n  itoa(data,payload,10);\n\n  // \"test\" 주제에 데이터를 발행합니다\n  mqtt_client.publish(MQTT_TOPIC,payload);\n}\n\n\nvoid connectToWiFi() {\n    WiFi.begin(SSID, PASSWORD);\n    Serial.print(\"WiFi에 연결 중\");\n    while (WiFi.status() != WL_CONNECTED) {\n        delay(500);\n        Serial.print(\".\");\n    }\n    Serial.println(\"\\nWiFi 네트워크에 연결됨\");\n}\n\n\nvoid setup() {\n  Serial.begin(115200);\n\n  connectToWiFi();\n\n  syncTime();\n\n  mqtt_client.setServer(MQTT_HOST,MQTT_PORT);\n\n  connectToMQTTBroker();\n\n}\n\nvoid loop() {\n  if (!mqtt_client.connected()) {\n        connectToMQTTBroker();\n    }\n\n\n    mqtt_client.loop();\n\n    // 3초마다 무작위 숫자를 보냅니다. 여러분은 센서 데이터를 전송할 수 있습니다.\n    publishData(ESP8266TrueRandom.random(1,500));\n    delay(3000);\n\n}\n```\n\n<div class=\"content-ad\"></div>\n\n마침내, 코드를 Esp8266에 업로드하세요.\n\nmqtt-cli를 설치하고 컴퓨터 터미널에서 실행하여 데이터가 발행되는지 확인하세요.\n\n설치 후, 다음 명령어를 실행하세요\n\n```js\nmqtt sub -h <호스트> -p <포트> -s -u <사용자이름> -pw <비밀번호> -t <토픽>\n```\n\n<div class=\"content-ad\"></div>\n\n우리 경우에는 \"test\" 주제입니다.\n\n다음 출력을 볼 수 있습니다.\n\n\n<img src=\"/assets/img/2024-06-22-MQTTinFlutterAComprehensiveGuidetoConnectApplicationswithESP8266IOTDevicesPARTI_8.png\" />\n\n\n이것은 우리의 Esp8266이 데이터를 MQTT 브로커로 보내고, 우리 컴퓨터에서 실행되는 CLI 도구를 사용하여 해당 데이터를 구독한다는 것을 보여줍니다.\n\n<div class=\"content-ad\"></div>\n\n# 마지막으로\n\nMQTT를 Esp8266 및 Flutter와 함께 사용하는 방법에 대한 두 부분 가이드의 첫 번째 부분이 끝났습니다.\n\n소중한 시간 내주셔서 감사합니다. 이에 대한 생각을 알려주세요!\n\n도움이 되었다면 LinkedIn에서 제 소식을 지켜보실 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n![Animated GIF](https://miro.medium.com/v2/resize:fit:440/0*xIWi3szlPmvPpqh0.gif)","ogImage":{"url":"/assets/img/2024-06-22-MQTTinFlutterAComprehensiveGuidetoConnectApplicationswithESP8266IOTDevicesPARTI_0.png"},"coverImage":"/assets/img/2024-06-22-MQTTinFlutterAComprehensiveGuidetoConnectApplicationswithESP8266IOTDevicesPARTI_0.png","tag":["Tech"],"readingTime":11},{"title":"웹에서의 Flutter 접근성 높이는 방법","description":"","date":"2024-06-22 05:07","slug":"2024-06-22-AccessibilityinFlutterontheWeb","content":"\n\n## Flutter가 어떻게 보조 기술을 사용하는 사용자에게 캔버스 렌더링 앱을 접근 가능하게 만들려고 하는가\n\nFlutter 프레임워크가 지원하는 대상 플랫폼 중 하나는 웹입니다. Flutter 애플리케이션은 모든 UI 요소를 캔버스 요소에 렌더링하여 픽셀 완벽성과 플랫폼 일관성을 보장합니다. 그러나 기본적으로 캔버스 요소는 접근할 수 없습니다. 이 사례 연구에서는 이러한 캔버스 렌더링된 Flutter 앱을 위한 접근성 지원이 어떻게 작동하는지 설명합니다.\n\n![image](/assets/img/2024-06-22-AccessibilityinFlutterontheWeb_0.png)\n\nFlutter에는 자동으로 접근성 트리를 생성하는 많은 기본 위젯이 있습니다. 접근성 트리는 보조 기술이 속성 및 속성을 쿼리하고 작업을 수행할 수 있는 접근성 객체의 트리입니다. 사용자 지정 위젯의 경우, Flutter의 Semantics 클래스를 사용하여 개발자가 위젯의 의미를 설명할 수 있으며, 이는 보조 기술이 위젯 콘텐츠를 이해할 수 있도록 돕습니다.\n\n<div class=\"content-ad\"></div>\n\n성능상의 이유로, 이 글을 작성하는 시점에서 플러터의 접근성은 기본적으로 사용자 동의를 받아야 합니다. 플러터 팀은 향후 플러터 웹에서 기본적으로 의미론을 활성화하고 싶어합니다. 그러나 현재는 상당 수의 경우에 성능에 미치는 비용이 두드러지며, 기본값을 변경하기 전에 최적화가 필요합니다. 항상 플러터의 접근성 모드를 활성화하려는 개발자는 다음 코드 조각을 사용할 수 있습니다.\n\n```js\nimport 'package:flutter/semantics.dart';\n\nvoid main() {\n  runApp(const MyApp());\n  if (kIsWeb) {\n    SemanticsBinding.instance.ensureSemantics();\n  }\n}\n```\n\n플러터의 접근성 지원을 선택하면 HTML이 자동으로 변경되며, 이 페이지의 나머지 부분에서 설명하겠습니다.\n\n# 플러터의 접근성 동의하기\n\n<div class=\"content-ad\"></div>\n\n플러터의 선택 참여 메커니즘은 숨겨진 버튼입니다. 구체적으로 말하면, 버튼을 배치합니다. `flt-semantics-placeholder` 엘리먼트는 role=\"button\"으로 만들어졌는데, 이는 시각적으로 보이지 않고 시각 장애가 있는 사용자들에게는 접근할 수 없습니다. 이 엘리먼트에는 스타일이 적용되어 사용자가 화면 판독기를 사용하지 않는 한 숨겨지고 선택할 수 없습니다.\n\n```js\n<flt-semantics-placeholder\n  role=\"button\"\n  aria-live=\"polite\"\n  aria-label=\"접근성 활성화\"\n  tabindex=\"0\"\n  style=\"  \n        position: absolute;  \n        left: -1px;  \n        top: -1px;  \n        width: 1px;  \n        height: 1px;\"\n></flt-semantics-placeholder>\n```\n\n```js\n/* `<flt-semantics-placeholder>`는 `<flutter-view>`에서 상속됩니다. */\nflutter-view {\n  user-select: none;\n}\n```\n\n# 선택 참여 후 변경사항\n\n<div class=\"content-ad\"></div>\n\n스크린 리더 사용자가 이 버튼을 클릭하면 어떤 일이 발생합니까? 플러터 갤러리의 카드와 같이 복잡하지 않은 예시를 고려하세요. 다음 스크린샷에 표시된 것과 같이.\n\n![카드 예시](/assets/img/2024-06-22-AccessibilityinFlutterontheWeb_1.png)\n\n사용자가 버튼을 클릭할 때 변경되는 부분을 이해하기 위해 Chrome DevTools에서 접근성 트리를 검사하면서 전 후 스크린샷을 비교하십시오. 두 번째 스크린샷이 첫 번째보다 훨씬 많은 의미 정보를 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-22-AccessibilityinFlutterontheWeb_2.png\" />\n\n동의 후:\n\n<img src=\"/assets/img/2024-06-22-AccessibilityinFlutterontheWeb_3.png\" />\n\n# 실행 내용\n\n<div class=\"content-ad\"></div>\n\nFlutter의 핵심 아이디어는 현재 캔버스에 표시된 내용을 반영하는 접근 가능한 DOM 구조를 생성하는 것입니다. 이는 `flt-semantics-host` 상위 사용자 지정 요소를 포함하며, 이 요소에는 차례로 중첩될 수 있는 `flt-semantics` 및 `flt-semantics-container` 하위 요소가 포함됩니다. 예를 들어 TextButton과 같은 버튼 위젯을 고려해보십시오. 이 위젯은 DOM에서 `flt-semantics` 요소로 표시됩니다. `flt-semantics` 요소의 ARIA 주석(예: role 또는 aria-label) 및 다른 DOM 속성(tabindex, 이벤트 처리기)은 화면 판독기가 사용자에게 해당 요소를 버튼으로 알릴 수 있게 하고 클릭하거나 탭하도록 지원합니다. 실제 `button` 요소가 아님에도 불구하고 사용자에게 버튼으로 발표하고 클릭하고 탭할 수 있게 합니다. 다음 스크린샷에서 공유 버튼은 이러한 버튼의 한 예입니다.\n\n이 `flt-semantics` 요소는 해당 버튼이 캔버스에 그려진 위치에 정확히 나타나도록 절대 위치로 배치됩니다. 이는 Flutter가 모든 위젯의 레이아웃을 소유하고 모든 의미 노드의 위치와 크기를 미리 계산하기 때문입니다. 절대 레이아웃은 접근성 요소를 사용자가 기대하는 위치에 정확히 배치할 수 있게 합니다. 그러나 사용자가 스크롤할 때 위치를 조정해야 하므로 일부 상황에서는 비용이 많이 들 수도 있습니다.\n\n# 모든 기본 위젯에 접근 방식을 확장하기\n\nFlutter는 DOM 구조에서 `flt-semantics role=\"button\"`로 표시된 내용이 원래 Flutter TextButton으로 표현되었음을 알기 때문에, 모든 기존 Flutter 위젯을 해당 WAI-ARIA 역할로 매핑하는 접근 방식을 쉽게 확장하고 구현할 수 있습니다. 이 접근 방식은 Flutter의 기본 위젯에 대해 기본적으로 제공됩니다. 예를 들어, 현재 Flutter는 다음 역할을 지원합니다:\n\n<div class=\"content-ad\"></div>\n\n- 텍스트\n- 버튼\n- 체크박스\n- 라디오 버튼\n- 텍스트 필드\n- 링크\n- 대화상자\n- 이미지\n- 슬라이더\n- 실시간 영역\n- 스크롤 가능한\n- 컨테이너 및 그룹\n\n위의 역할 목록이 짧지만 다양한 위젯 범주가 종종 동일한 역할을 공유한다는 점에 유의하세요. 예를 들어, Material TextField와 CupertinoTextField는 동일한 텍스트 필드 역할을 공유할 수 있습니다. Stack, Column, Row, Flex 등과 같은 대부분의 레이아웃 위젯은 모두 컨테이너/그룹으로 표현될 수 있습니다.\n\n# 사용자 정의 위젯에 대한 도전 과제\n\n사용자 정의 위젯을 구축할 때, Flutter는 자동으로 올바른 역할을 적용하지 못할 수 있습니다. 위젯이 단순히 기존 위젯의 장식된 변형인 경우(예: EditableText 위에 래퍼인 경우), 올바르게 표시될 수 있습니다(텍스트 필드로). 그러나 처음부터 위젯을 작성하는 경우, Flutter는 사용자가 Semantics 위젯을 사용하여 이에 대한 접근성 속성을 설명하도록 요구합니다. WAI-ARIA는 다양한 위젯 역할을 정의합니다. Flutter는 역할의 하위 집합만 지원하지만 이러한 하위 집합은 지속적으로 확장됩니다.\n\n<div class=\"content-ad\"></div>\n\n예를 들어, 아래 스크린샷에서 확인할 수 있듯이 I/O Flip 게임에서 팀 클래스 선택기를 실시간으로 탐색할 수 있습니다. 웹 용어로 말하자면, 이것은 본질적으로 `select` 또는 WAI-ARIA 용어로 말하면 리스트 상자입니다. 사용 가능한 옵션은 일반 텍스트로 표시되지만(오히려 `option` 요소여야 합니다), 더 큰 문제는 접근성 트리에서 위젯의 뷰포트 외에 선택할 옵션이 더 있다는 사실이 명확하지 않다는 것입니다. 스크롤하기 전에 접근성 트리에서 사용 가능한 옵션을 보고 스크롤을 한 후의 상황을 살펴봅니다.\n\n스크롤 전:\n\n![이미지](/assets/img/2024-06-22-AccessibilityinFlutterontheWeb_4.png)\n\n스크롤 후:\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-22-AccessibilityinFlutterontheWeb_5.png\" />\n\n만약 소스 코드를 살펴보면, Semantics 클래스를 사용하지 않는다는 것을 알 수 있습니다. Semantics는 아직 listbox 및 option 역할 주석 사용 사례를 지원하지 않습니다. 그러나 ListWheelScrollView를 사용하여 일반 ListView와 유사하게 작동하므로 이것이 목록임을 인지합니다. 그러나 액세스 가능성 트리는 현재 보이는 항목과 뷰포트 위 아래에 몇 개의 항목만 표시되고 모든 항목은 절대 표시되지 않음에 주의하십시오. (웹에서 거의 네이티브로 얻은 앱 성능 요령으로 이것은 가끔 `virtual-scroller` 형식으로도 웹에서 얻을 수 있습니다.)\n\nFlutter의 액세스 가능성 트리를 ARIA Authoring Practices Guide의 스크롤 가능한 listbox 예제와 비교해보면, 액세스 가능성 트리에 모든 옵션이 표시되지만 뷰포트 외부에 있는 것도 포함됩니다. 이 listbox 사용 사례를 완전히 지원하지 않는 것은 현재까지의 Flutter 솔루션의 단점이며 앞으로 처리될 것입니다.\n\n# 텍스트 편집\n\n<div class=\"content-ad\"></div>\n\n플러터에는 `flt-text-editing-host` 요소가 있습니다. 이 요소는 `input` 또는 `textarea` 중 하나가 하위 요소로 포함되어 있고 해당 캔버스 영역에 완벽하게 배치됩니다. 이는 자동 입력 외에도 브라우저의 편의 기능이 정상 작동한다는 것을 의미합니다. 이 기능은 항상 활성화되어 있으며 접근성이 활성화되었는지 여부에 관곝 받지 않습니다. 의미론적 트리에서 텍스트 필드는 `input` 요소로 표현되며, 해당 내용을 설명하는 ARIA 레이블이 있는 경우도 있습니다. 다음의 텍스트 필드 예시는 플러터 갤러리에서 찾을 수 있습니다. 사용자가 탭 키를 누를 때마다 `input` 필드가 동적으로 재배치되는 것을 확인할 수 있습니다.\n\n시각 장애가 없는 사용자에게는 텍스트 입력란에 표시된 레이블 텍스트가 보여지지만, 스크린 리더 사용자에게는 \"편집, 빈칸\"이나 \"텍스트 편집, 빈칸\"과 같이 발표됩니다. 이는 현재 플러터에서 `label` 요소를 생성하지 않기 때문에 발생하는 현상입니다. VoiceOver on macOS에서 스크린 리더 출력을 아래 이미지에서 확인할 수 있습니다. 이 부분은 플러터가 미래에 해결할 문제입니다.\n\n텍스트 필드가 적절히 레이블이 지정된 경우, 스크린 리더는 의도된 의미를 발표합니다. 아래의 순수 HTML 예시를 참고하세요.\n\n<div class=\"content-ad\"></div>\n\n![2024-06-22-AccessibilityinFlutterontheWeb_7.png](/assets/img/2024-06-22-AccessibilityinFlutterontheWeb_7.png)\n\n# 결론\n\n이 사례 연구는 웹에서 Flutter 캔버스 애플리케이션 내에서 접근성 지원이 어떻게 기능하는지에 대해 심층적으로 다루었습니다. Flutter의 접근성은 구체적인 속성과 스타일을 가진 숨겨진 버튼을 통해 드러납니다. 활성화되면 이 접근 방식은 스크린 리더 및 기타 보조 기술을 사용하는 사용자들에게 경험을 크게 향상시킵니다. Flutter의 핵심 개념은 캔버스 디스플레이를 반영하는 접근 가능한 DOM 구조를 만드는 것으로, `flt-semantics-host`, `flt-semantics`, `flt-semantics-container` 등과 같은 사용자 정의 요소를 활용합니다.\n\nFlutter는 기본 위젯을 WAI-ARIA 역할에 능숙하게 매핑하지만, 팀은 몇 가지 남아 있는 과제를 인정합니다. Flutter에서 텍스트 편집을 탐구하면 `input` 또는 `textarea`를 사용하는 `flt-text-editing-host`의 트릭을 보여 주며, 동적으로 입력 필드를 재배치하는 것을 보여줍니다.\n\n<div class=\"content-ad\"></div>\n\n앞으로 Flutter의 접근성 프레임워크를 더욱 개선할 기회가 있습니다. 이미 팀이 작업을 시작했습니다. 이에는 사용자 정의 위젯에 대한 목록 상자 사용 사례를 해결하고 텍스트 편집을 위한 레이블 요소 생성을 개선하는 것이 포함됩니다. 예상되는 이러한 향상은 Flutter가 계속해서 웹 컴파일 대상의 지속적인 개선에 대한 약속을 반영하여, 더 포괄적이고 매끄러운 접근성 경험을 제공하는 것을 목표로 합니다.\n\n# 감사의 글\n\n이 사례 연구는 Flutter 팀의 Yegor Jbanov, Kevin Moore, Michael Thomsen 및 Shams Zakhour에 의해 정확성을 검토했습니다. 편집 리뷰는 Rachel Andrew와 Shams Zakhour가 맡았습니다.","ogImage":{"url":"/assets/img/2024-06-22-AccessibilityinFlutterontheWeb_0.png"},"coverImage":"/assets/img/2024-06-22-AccessibilityinFlutterontheWeb_0.png","tag":["Tech"],"readingTime":7},{"title":"Flutter 앱에 Gemini 연동 방법","description":"","date":"2024-06-22 05:06","slug":"2024-06-22-IntegratingGeminiIntoFlutterApp","content":"\n안녕하세요 여러분! 이 기사에서는 플러터 프로젝트에서 제미니를 사용하는 방법에 대해 이야기하고 싶습니다.\n\n![Gemini](/assets/img/2024-06-22-IntegratingGeminiIntoFlutterApp_0.png)\n\n## 제미니란 무엇인가요?\n\n제미니 AI는 구글의 최첨단 AI 모델로, 인공지능 분야에서의 중요한 발전을 이루었습니다. 이 모델은 다양한 형식인 텍스트, 이미지, 오디오 및 비디오와 같은 콘텐츠를 이해하고 처리할 수 있는 다재다능한 기능으로 눈에 띕니다.\n\n<div class=\"content-ad\"></div>\n\n젬니의 능력과 다양한 변형:\n\n젬니는 특정 사용자 요구 사항을 충족하기 위해 세 가지 다른 변형을 제공합니다:\n\n젬니 1.5 Pro: 이 신기술 모델은 AI의 경계를 넓혀 다양한 입력 형식인 오디오, 시각, 비디오, 텍스트를 처리합니다. 이 모델은 텍스트 생성, 코딩, 문제 해결, 데이터 추출과 같은 복잡한 작업에 뛰어납니다.\n\n젬니 1.5 Flash: 민첩성으로 유명한 이 모델은 다양한 형식의 입력을 신속하게 처리하여 텍스트 결과물을 생성합니다. 이 모델의 다재다능함으로 다양한 작업에 효과적입니다.\n\n<div class=\"content-ad\"></div>\n\n젬니 1.0 Pro: 자연어 처리 작업에 특화된 이 모델은 다양한 텍스트 및 코드 대화, 코드 생성과 같은 영역에서 우수한 성능을 보여줍니다.\n\n언어 지원 및 API 액세스\n\n젬니 모델은 약 40가지 다른 언어에서 작동하도록 훈련되어 다양한 사용자를 대상으로 합니다. 게다가, 젬니 API를 통해 개발자들은 이 강력한 AI 모델을 자신의 프로젝트에 통합할 수 있는 기회를 제공받습니다.\n\n![이미지](/assets/img/2024-06-22-IntegratingGeminiIntoFlutterApp_1.png)\n\n<div class=\"content-ad\"></div>\n\n## 플러터 프로젝트에 Gemini 통합하기 단계별 안내\n\nAPI 키를 안전하게 보관하고 절대 공개하지 마세요.\n\n![Gemini 통합 이미지](/assets/img/2024-06-22-IntegratingGeminiIntoFlutterApp_2.png)\n\n다음 명령을 실행하여 추가하세요:\n\n<div class=\"content-ad\"></div>\n\nflutter pub add google_generative_ai\n\n이 패키지를 사용하려면 다트 코드에 이 줄을 추가하세요:\n\n```js\nimport \"package:google_generative_ai/google_generative_ai.dart\";\n```\n\n```js\nimport 'package:google_generative_ai/google_generative_ai.dart';\n\nfinal apiKey = Platform.environment['API_KEY'];\n\nfinal model = GenerativeModel(model: 'MODEL_NAME', apiKey: apiKey);\n```\n\n<div class=\"content-ad\"></div>\n\n[model] 인자는 `gemini-1.5-flash-latest`와 같은 모델 이름 또는 `models/gemini-1.5-flash-latest`와 같은 모델 코드가 될 수 있습니다.\n\nGenerativeModel을 자세히 살펴봅시다.\n\n## GenerativeModel이란 무엇인가요?\n\nGenerativeModel 클래스는 텍스트, 이미지 또는 기타 콘텐츠를 생성하는 데 상호 작용하는 큰 언어 모델 (LLM)을 나타냅니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n(new) GenerativeModel GenerativeModel({\n  필수 요소 String model,\n  필수 요소 String apiKey,\n  List<SafetySetting> safetySettings = const [],\n  GenerationConfig? generationConfig,\n  List<Tool>? tools,\n  Client? httpClient,\n  RequestOptions? requestOptions,\n  Content? systemInstruction,\n  ToolConfig? toolConfig,\n})\n```\n\nmodel 및 apiKey는 필수입니다. 다른 매개변수들은 선택 사항입니다.\n\n매개변수 설명\n\n필수 요소 String model: 사용하려는 특정 LLM의 이름 또는 식별자입니다 (예: \"models/text-bison-001\"). Gemini는 다양한 기능을 가진 여러 모델을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n다음은 문서의 번역입니다:\n\n`apiKey` 필수 문자열: Google Cloud에서 획득한 API 키는 요청을 인증하고 Gemini API에 액세스하는 데 필요합니다.\n\nList`SafetySetting` safetySettings: 안전 설정은 LLMs와 작업할 때 중요한 측면입니다. 이러한 설정을 사용하면 모델 출력에 적용되는 콘텐츠 필터를 제어하여 해로운 또는 부적절한 콘텐츠 생성을 방지할 수 있습니다.\n\nGenerationConfig? generationConfig: 이 매개변수는 모델이 응답을 생성하는 방식을 구성합니다. 다음과 같은 옵션이 포함되어 있습니다.\n\n- temperature: 출력의 무작위성을 제어합니다(높은 값은 더 창의적이지만 정확하지 않을 수 있음).\n- topP: 무작위성을 제어하는 대안적인 방법입니다.\n- topK: 각 단계에서 상위 K개의 가장 가능성이 높은 단어를 고려하도록 모델을 제한합니다.\n- maxOutputTokens: 생성된 응답의 길이에 대한 최대 제한을 설정합니다.\n\n<div class=\"content-ad\"></div>\n\nList`Tool`? tools: 일부 LLM(라이프사이클 매니저)는 특히 최신 버전은 외부 도구를 사용하여 기능을 강화할 수 있습니다. 예를 들어, 계산기 도구는 수학 문제를 해결하는 데 도움이 될 수 있습니다.\n\nClient? httpClient: API 요청을 만들기 위한 사용자 지정 HTTP 클라이언트입니다. 일반적으로 특별한 네트워크 요구사항이 없는 경우 기본 클라이언트를 신뢰할 수 있습니다.\n\nRequestOptions? requestOptions: API 요청 동작을 세밀하게 조정하기 위한 추가 옵션입니다.\n\nContent? systemInstruction: LLM의 전반적인 동작과 응답을 안내하는 지침입니다.\n\n<div class=\"content-ad\"></div>\n\nToolConfig? toolConfig: 모델에서 사용하는 외부 도구에 대한 추가 구성 옵션입니다.\n\n이제 플러터 프로젝트에서 Gemini AI를 사용할 수 있습니다.\n\n## 사용 예시:\n\nGemini를 사용하여 스토리 앱을 만들고 싶다고 가정해 봅시다.\n\n<div class=\"content-ad\"></div>\n\n```js\n최종 모델 = 생성 모델(\n    모델: '젬니 1.5 프로',\n    apiKey: Apiclass.apiKey,\n    시스템명령: Content.system('당신은 이야기꾼이에요. 당신은 짧은 공포 이야기를 만드는 것을 좋아해요.'),);\n\n콘텐츠 = [\n    Content.text(\n        \"이야기를 써라\")\n    ];\n\n응답 = await model.generateContent(content);\n```\n\n이 코드를 사용하면 Gemini는 짧은 공포 이야기를 좋아하는 이야기꾼처럼 행동합니다. \"응답\"에는 짧은 공포 이야기가 생성됩니다.\n\n일부 UI 디자인 코드를 추가하면 결과물은 다음과 같습니다:\n\n![이미지](/assets/img/2024-06-22-IntegratingGeminiIntoFlutterApp_3.png)\n\n<div class=\"content-ad\"></div>\n\n스토리 앱의 모든 코드에 접근하려면 제 Github 페이지를 방문해 주세요!\n\n더 많은 정보를 얻으시려면 Gemini API 문서와 Google AI 포럼을 방문하는 것을 잊지 마세요.\n\n제 글을 읽어 주셔서 감사합니다. 연락을 원하시면 LinkedIn과 Twitter 계정을 통해 저에게 연락하실 수 있습니다. 다음 글에서 뵙겠습니다!\n","ogImage":{"url":"/assets/img/2024-06-22-IntegratingGeminiIntoFlutterApp_0.png"},"coverImage":"/assets/img/2024-06-22-IntegratingGeminiIntoFlutterApp_0.png","tag":["Tech"],"readingTime":5},{"title":"다양한 강의를 한눈에 볼 수 있는 링크 모음","description":"","date":"2024-06-22 04:31","slug":"2024-06-22-LotsOfLinkofcourses","content":"\n\nhttps://mega.nz/folder/Q9E3ha4Q#nvW42NukmfqYboQQhqEGVQ\n\nhttps://soft.uclv.edu.cu/Microsoft/\n\nhttps://mega.nz/folder/FNtV2AJD#M7wZ8EnVSwt9ZGbgVkEElQ\n\nhttps://mega.nz/folder/YMZUxJ6b#5Rx5UxG7zSp9-X1qHY8i3Q\n\n<div class=\"content-ad\"></div>\n\nhttps://mega.nz/folder/9ZckiLLJ#jH3CcsgJ1q5StsPC29zP-Q\n\nandroid\n\nhttps://mega.nz/folder/3WhSkBjJ#YSDBnDegckd9-xSQ04W0qA\n\n30+ Recorded video Course\n\n<div class=\"content-ad\"></div>\n\n🎯 소셜 미디어 마케팅 코스\n🎯 워드프레스 개발 코스\n🎯 안드로이드 앱 개발 코스\n🎯 페이스북 광고 코스\n🎯 검색 엔진 최적화 코스\n🎯 이메일 마케팅 코스\n🎯 구글 광고 코스\n🎯 YouTube 확장 코스\n🎯 아마존 비즈니스 코스\n🎯 피버 프리랜싱 코스\n🎯 콘텐츠 작성 코스\n🎯 그래픽 디자인 코스\n🎯 비디오 편집 코스\n🎯 전자상거래 비즈니스 코스\n🎯 드롭쉽핑 코스\n🎯 페이스북 애드브레이크 코스\n🎯 전자상거래 비즈니스 코스\n🎯 쇼핑몰 코스\n🎯 웹 개발 및 디자인 코스\n🎯 그 외 다수\n\n[자세히 보기](https://drive.google.com/drive/folders/1ezDZ3uDplBOjbuBGw1qxzzD64tiXhtDt?usp=sharing)\n\n🔰 사이버 보안 코스의 가장 큰 컬렉션.🔰\n\n🪬 블랙해트 윤리적 해킹.\n⭐️ VMware에 대한 모든 것.\n🛡 고급 키로거 만들기.\n🔰 완벽한 윤리적 해킹 코스.\n🔰 윤리적 해킹 클라우드 컴퓨팅.\n⭕️ 컴퓨터 포렌식.\n🔹 소셜 엔지니어링.\n▪️ 리버스 엔지니어링.\n⭐️ Termux 완전 가이드.\n⭕️ 레드팀 해킹 코스.\n💣 해킹 및 페네트레이션.\n🧨 무선 네트워크 해킹.\n🏮 하드웨어 보안.\n⚒ 실용적 버그 사냥.\n🛡 리눅스 완벽 가이드.\n💉 SQL Injection 완전 가이드. + 50가지 이상의 윤리적 해킹 코스.\n\n<div class=\"content-ad\"></div>\n\n디veloper님께,\n\n아래는 새로운 포인트들이에요.\n\nSize — 625 GB+\n\nDownload Link-\nhttps://mega.nz/folder/QtUBkSyI#pWhNWowJhOTamWY0PuODLA\n\n😈All Adobe 2021 Products Last Versions Cracked [For Free] 😈\n\nAdobe Photoshop 2021 v22.1.0 : http://www.mediafire.com/file/4wb9fe1rvjlfs2j/AdobePhotoshop2021v22.1.Win.rar/file?fbclid=IwAR3TPU11evGivcodh43YiWnlyp5_SHggRLn0zhJpRA0XTKIq0hZgxQWCRig\n\n더 궁금한 점이 있으면 언제든지 물어봐 주세요!\n\n<div class=\"content-ad\"></div>\n\nMarkdown 형식으로 변환해보겠습니다:\n\nAdobe Premiere Pro 2020 v14.7 : [다운로드 링크](http://www.mediafire.com/file/73voa795qcku3pt/AdobePremierePro2020v14.7.Win.rar/file?fbclid=IwAR0xGK3e5pdpgAu6myfej_LjzBHzEL5OyxZUAL95B6H7V1JZf8tVLy1b9f4)\n\nAdobe Lightroom Classic 2021 v10.1 [다운로드 링크](http://www.mediafire.com/file/hpcur9khuxtrozv/AdobePhotoshopLightroomClassic2021v10.1.Win.rar/file?fbclid=IwAR0Vjl67ZA8iqeH467CbZafu24RVBnCvMvcwxRLqNC-av4jU2l6jjrQnB8A)\n\nAdobe Media Encoder 2020 v14.7 : [다운로드 링크](https://www.mediafire.com/file/ywmye7d2qxdeo7y/AdobeMediaEncoder2020v14.7.Win.rar/file?fbclid=IwAR2Lj1j1E5yCatGLBLc7Dfu1jfwoFWPUxdCZ5kBIFQEcLw11i_8NjiW7O4Q)\n\nAdobe Premiere Rush v1.5.40 : [다운로드 링크](http://www.mediafire.com/file/2twks2fabd6vxzq/AdobePremiereRush1.5.40.Win.rar/file?fbclid=IwAR3tsmfK6cFqQ_AzjroFDPxGtX2-cJw8IM__lp8Nu0XL8s02uhOjpvvIh3Q)\n\n<div class=\"content-ad\"></div>\n\nAdobe Audition 2020 13.0.12.45 : [다운로드 링크](http://www.mediafire.com/file/j4otbvrxct3dqkr/Audition_2020_13.0.12.45.rar/file?fbclid=IwAR2Xp7EDcyuEFi6-WiH5ZrUuIy_DId83-bGneYoNliDZvh8UUunkPUqpkoM)\n\nAdobe After Effects 2020 v17.5.1 : [다운로드 링크](http://www.mediafire.com/file/8h9nlqc2syzpj6u/AfterE_2020_17.5.1.47.rar/file?fbclid=IwAR1jJSND5fPtq3_iBoEZn70m1JnThHUI5X3z3TYLYhFhp5vxPK1xAwlHfXQ)\n\nAdobe Illustrator 2021 v25 : [다운로드 링크](https://www.mediafire.com/file/i5anq76nqirxc5g/Illustrator_.rar/file?fbclid=IwAR1A9bo7yT23uDWzKKETQDEBbbw9ZFtEA2ucLuT4xhmSTxq5fcrVX1zJbNs)\n\nChatGPT 마스터리 코스\n\n<div class=\"content-ad\"></div>\n\nhttps://mega.nz/folder/aVIyjIAS#xqjp5Sz712H5KIJMzhOt2A\n\nMERN 스택 개발\n\nhttps://mega.nz/folder/PughDCwZ#EGis0KF0qCMpIoeaWqZLlw\n\nUdemy — 애플리케이션을 만들며 C# 배우기\n\n<div class=\"content-ad\"></div>\n\nhttps://mega.nz/folder/DjgnySaJ#sPqDZwIU6ASslUuWFOhX2g\n\n용량: 2GB\n\nhttps://mega.nz/folder/dcIkERZC#9CO-2tNZ_5NIMuum-tPhSQ\n\n🔰 웹 개발 과정 🔰\n@TheStarkArmyX 님 제공\n\n<div class=\"content-ad\"></div>\n\n\nEJS\nCSS\nDOM\nSQL\nHTML\nAPIs\nJQuery\nNode.js\nMongoDB\nDatabase\nMongoose\nBootstrap\nExpress.js\nJavascript\nGit & Github\nAdvance Javascript\nBack-End Web Development\nFront-End Web Development\n\n[Download link](https://mega.nz/folder/lxhERBZL#WPhYniXuRPwRS29_M0ygJQ)\n\nCredit: @freecodingcourses1\n▪️Share & Support us▪️\n\nGAME DEVELOPMENT COURSE\nLEARN HOW TO MAKE GAMES IN UNITY!\nNOOB-FRIENDLY\n\n\n<div class=\"content-ad\"></div>\n\nhttps://mega.nz/folder/CdwTzYDQ#e0nDPWHj6mTzBWBGQ7LKBA/folder/bQIw1Jqa\n\n🛡윤리적 해킹 - 가장 고급 수준의 NMAP 강좌\n\n🛡프론트엔드 마스터스 - 나만의 프로그래밍 언어 만들기\n\n🛡풀 해킹 영웅이 되는 법 🤖\n\n<div class=\"content-ad\"></div>\n\n🛡 스팸 강의 모두 마감되었습니다\n\n🛡 Udemy - Wi-Fi 비밀번호 침투 테스트 배우기 (WEP, WPA, WPA2)\n\n🛡 도구를 활용한 전체 포렌식 강의\n\n🔑 윈도우 해킹 전체 기초부터 프로까지의 지식과 링크, 비디오\n\n<div class=\"content-ad\"></div>\n\n🔒 모든 도구를 해킹하기\n\n🔒 모든 도구로 스팸 전송\n➖➖➖➖➖➖➖➖➖➖➖➖➖➖\n🍏다운로드 링크 :- https://mega.nz/folder/JhdyUbKZ#Z6wmJRc83y6Q7P5-PlenCw\n➖➖➖➖➖➖➖➖➖➖➖➖➖➖\n\nhttps://t.me/+TF93tpwpDNSoy2rX\n공유는 사랑입니다❤️\n\n웹사이트 해킹\nhttps://mega.nz/file/kqxkQKxB#7TjCd2-_YwZZjBx6Hm15VT_E99tF-8-LbWc_kpiOS2I\n\n<div class=\"content-ad\"></div>\n\nLeetcode 문제 솔루션 — https://github.com/Devn913/LeetCode\n\n플러터\nhttps://mega.nz/folder/C0BmXZhC#G57vmsZ9ENh-lFUV6j5J5g\n\n안드로이드 앱 개발\n\nhttps://drive.google.com/drive/folders/15DZTb3kraSVCRRQnk3duOz1sPPcrK0Ti?fbclid=IwAR2driJCbqocy8fIgJhO7OVBhudjZ8BmtaWHSU0Vqxl15nzb-3-wfwlOeWs\n\n<div class=\"content-ad\"></div>\n\n### 안녕하세요! 😊\n\n14가지 앱을 만들면서 배우는 안드로이드 개발자 코스가 완성되었습니다! 아래 링크를 통해 자세한 내용을 확인해보세요.\n\n[안드로이드 개발자 코스 자료](https://drive.google.com/drive/folders/1BnqNr49J_dLbS37gUwJGo70Yv-ZPSXum)\n\n또한, 칼리 리눅스를 활용한 와이파이 해킹 코스와 MSB 아카데미에서 제공하는 리액트 네이티브 코스도 소개해드리고 싶어요. 아래 링크를 통해 자세한 정보를 확인해보세요.\n\n[와이파이 해킹 코스 - 칼리 리눅스](https://drive.google.com/drive/folders/0Bwl2hpDfvDN1RFV5VE1TMVQ0Vms?resourcekey=0-rQRPGupelyiYqsX81LwCIw)\n\n[MSB 아카데미 리액트 네이티브 코스](https://mega.nz/folder/vR5kwbgQ#I8WZzNCJguEQXvrK5aXbjA)\n\n궁금한 점 있으면 언제든지 물어보세요! 함께 공부하면 더 즐거울 거예요. 🚀","ogImage":{"url":"/assets/img/2024-06-22-LotsOfLinkofcourses_0.png"},"coverImage":"/assets/img/2024-06-22-LotsOfLinkofcourses_0.png","tag":["Tech"],"readingTime":6},{"title":"MySQL 트랜잭션 처리 내부 작동 방식 이해하기","description":"","date":"2024-06-22 04:29","slug":"2024-06-22-DecipheringtheInnerWorkingsofTransactionProcessinginMySQL","content":"\n\nMySQL의 트랜잭션 메커니즘에 대해 깊이 있게 탐구해 보세요. 여기서는 트랜잭션 처리의 전반적인 탐구를 통해 효율적이고 안전한 데이터 관리를 이끄는 기본 원칙을 알아봅니다.\n\n![이미지](/assets/img/2024-06-22-DecipheringtheInnerWorkingsofTransactionProcessinginMySQL_0.png)\n\nMySQL의 강력한 트랜잭션 지원을 탐구하면서, 동시성 안전성 이슈에 대해 복잡하게 살펴보게 됩니다. 동시에 동일한 데이터를 수정하려는 동시 트랜잭션들이 가져다주는 도전에 대처하기 위한 해결책을 MySQL가 선도적인 디자인을 통해 제공합니다.\n\nMySQL는 데이터 불일치를 방지하고 무결성을 유지하기 위한 솔루션을 제공하여 데이터 일관성을 유지하는 논리적인 방법을 보장합니다.\n\n<div class=\"content-ad\"></div>\n\nMySQL은 Multi-Version Concurrency Control(MVCC) 시스템, 트랜잭션 격리 메커니즘 및 잠금 메커니즘을 통해 트랜잭션 동시성을 효과적으로 처리하는 등의 과제에 대응합니다.\n\n그 말인즉, 데이터베이스에서 동시 트랜잭션이 통제되지 않고 관리되지 않는다면 잠재적인 결과를 고려해 보신 적이 있나요?\n\nDirty data.\n\nDirty data에 관련된 구체적인 개념은 dirty write, dirty read, non-repeatable read, phantom read로, 이들 개념의 의미에 대해 자세히 살펴봅시다.\n\n<div class=\"content-ad\"></div>\n\n# 1. Dirty write.\n\nDirty write은 이미 커밋된 데이터를 수정하는 한 트랜잭션이 있고, 그 수정 사항이 후속 트랜잭션이 롤백하는 상황을 가리킵니다.\n\n먼저 개념을 확인해봅시다: 두 트랜잭션 A와 B가 있다고 가정해보겠습니다. 트랜잭션 A가 먼저 시작되고 id가 1인 레코드를 수정하여 이름을 A로 변경합니다(원래 null이었다고 가정). 하지만 이 시점에서 트랜잭션 A는 아직 커밋되지 않은 상태입니다.\n\n이제 트랜잭션 B가 시작됩니다.\n\n<div class=\"content-ad\"></div>\n\nTransaction B는 레코드 ID 1의 이름을 B로 변경하고 해당 트랜잭션을 커밋했습니다. 그러나 이 시점에서 트랜잭션 A는 수정을 진행하지 않기로 결정하고 롤백하여 자체 변경 사항을 되돌립니다.\n\n결과적으로, 레코드 ID 1은 이름에 대한 null 값을 유지하게 됩니다.\n\n이후 트랜잭션 B가 이 레코드를 조회하여 이름 값이 null임을 발견하면, 이는 트랜잭션 B가 수행한 수정 사항이 트랜잭션 A에 의해 롤백되는 경우로, 더러운 쓰기로 간주됩니다.\n\n![이미지](/assets/img/2024-06-22-DecipheringtheInnerWorkingsofTransactionProcessinginMySQL_1.png)\n\n<div class=\"content-ad\"></div>\n\nMySQL은 락(lock)을 사용하여 dirty writes 문제에 대처합니다. MySQL에서 트랜잭션이 시작되면 특정 레코드에 바인딩됩니다.\n\n이 메커니즘은 Java Virtual Machine (JVM)에서의 락과 다소 유사합니다. 이 맥락에서, 트랜잭션 A가 시작되고 특정 레코드와 연관시킨다면, 트랜잭션 B가 동일한 레코드에 작업을 시도하면 대기해야 합니다.\n\n트랜잭션 A가 실행을 완료하면, 대기 중인 트랜잭션들에게 알리고, 대기 중인 다음 트랜잭션이 작업을 계속할 수 있도록 허용합니다.\n\n이러한 작업들이 직렬화된 실행을 유발하여 데이터베이스가 느리게 처리될 것이 걱정될 수 있습니다. 그러나 실제로는 이러한 작업들이 메모리 내에서, 구체적으로는 버퍼 풀(Buffer Pool) 내에서 처리됩니다. 결과적으로, 이러한 작업의 속도는 매우 빠릅니다.\n\n<div class=\"content-ad\"></div>\n\n# 2. Dirty read.\n\nDirty read(더티 리드)는 한 트랜잭션이 다른 트랜잭션이 수정했지만 아직 커밋하지 않은 레코드를 읽는 상황을 가리킵니다.\n\n두 개의 트랜잭션, A와 B를 전제로 계속해 보겠습니다. 먼저 트랜잭션 A가 시작되어 id가 1인 레코드의 이름을 A로 변경했지만 아직 커밋하지 않은 상태입니다.\n\n이 시점에서 트랜잭션 B가 시작됩니다. 트랜잭션 B는 쿼리를 실행하고 이름의 현재 값을 A로 찾습니다. 이후에는 해당 값을 A로 가정하고 로직을 진행합니다. 그러나 트랜잭션 A가 롤백되고 나서 트랜잭션 B가 다시 쿼리하면 레코드의 값이 A가 아닌 것을 발견합니다. 이 시나리오는 더티 리드를 잘 보여주는 예시입니다.\n\n<div class=\"content-ad\"></div>\n\n\n![transaction_processing](/assets/img/2024-06-22-DecipheringtheInnerWorkingsofTransactionProcessinginMySQL_2.png)\n\n# 3. Non-repeatable read.\n\nNon-repeatable read refers to a situation where reading the same record at different points in time yields different results.\n\nConsider three transactions, T1, T2, and T3.\n\n\n<div class=\"content-ad\"></div>\n\nT1 트랜잭션이 시작되지만 어떠한 작업도 수행하지 않습니다. T2 트랜잭션이 시작되고 id가 1인 레코드의 이름을 B로 변경한 뒤 트랜잭션을 커밋합니다.\n\n이 시점에서 T1 트랜잭션이 활성화되어 레코드를 쿼리하여 이름 값이 B로 확인되지만 어떠한 작업도 실행하지 않습니다.\n\n이후 T3 트랜잭션이 시작됩니다.\n\nT3은 id가 1인 레코드의 이름을 C로 수정하고 트랜잭션을 커밋합니다. 이후 T1 트랜잭션이 실행을 재개하면서 다시 레코드를 쿼리하면 이름 값이 이제 C로 나타납니다. 이는 반복되지 않는 읽기를 보여줍니다.\n\n<div class=\"content-ad\"></div>\n\n아래는 이미지를 표시하는 링크입니다.\n\n# 4. Phantom read.\n\n팬텀 리드는 반복 불가능한 리드와 어느 정도 유사하지만, 반복 불가능한 리드는 데이터 값의 차이를 강조하는 것과 달리, 팬텀 리드는 데이터 레코드의 숫자의 변화에 중점을 두어 추가나 삭제와 같은 변화를 강조합니다. 데이터 집합에서 환상이나 \"유령\"을 보는 것과 유사합니다.\n\n<div class=\"content-ad\"></div>\n\n두 개의 트랜잭션, T1과 T2를 고려해봅시다. 트랜잭션 T1이 시작되고 SQL 쿼리를 실행합니다: select * from user, 현재 결과가 5개의 행이라고 가정합니다. 이 시점에서 트랜잭션 T2가 시작되어 사용자 테이블에 레코드를 삽입하고 트랜잭션을 커밋합니다.\n\n그 후에 트랜잭션 T1이 다른 select * from user 쿼리를 실행하여 실행을 계속하면 결과가 이제 6개의 행으로 구성되어 있는 것을 발견합니다. 이는 그림 속에 있는 것과 같이 '유령 읽기'라고 알려진 것을 보여줍니다.\n\n아래는 현대 데이터베이스에서 일반적으로 발생하는 네 가지 문제이며, 이러한 문제는 서로 다른 트랜잭션 격리 수준에서 발생할 수 있습니다. 그래서 다음에 분석할 주제는 트랜잭션의 격리 수준입니다.\n\n![이미지](/assets/img/2024-06-22-DecipheringtheInnerWorkingsofTransactionProcessinginMySQL_4.png)\n\n<div class=\"content-ad\"></div>\n\n다중 버전 동시성 제어(MVCC) 메커니즘.\n\n트랜잭션 격리 수준은 다음 네 가지 유형으로 분류됩니다:\n\n- 읽지 않은 커밋.\n- 커밋된 읽기.\n- 반복 가능한 읽기.\n- 직렬화된 읽기.\n\nMVCC는 데이터베이스 관리 시스템에서 일반적으로 구현된 동시성 제어 방법입니다. 이는 데이터베이스에 대한 동시 액세스를 용이하게 하고 명시적 트랜잭션 격리의 중요한 측면으로 기능합니다.\n\n<div class=\"content-ad\"></div>\n\n이 시점에서 새로운 개념을 소개합니다: 데이터가 디스크에 저장될 때, 각 레코드는 트랜잭션 ID와 롤백 포인터와 함께 저장됩니다.\n\n![이미지](/assets/img/2024-06-22-DecipheringtheInnerWorkingsofTransactionProcessinginMySQL_5.png)\n\n- 트랜잭션 ID: 각 트랜잭션에 대한 고유 식별자입니다.\n- 롤백 포인터: 현재 트랜잭션 이전 버전의 레코드에 대한 참조(포인터)로, 현재 타임스탬프에 상대적으로 이전 데이터를 가리키는 용어입니다.\n\n특정 레코드에서 작업을 수행해야 한다고 가정해 봅시다. 먼저 해당 레코드가 버퍼 풀에 로드되어 있어야 하며, 그 레코드에 연관된 되돌리기 로그 레코드가 있어야 합니다.\n\n<div class=\"content-ad\"></div>\n\n아래는 Markdown 형식으로 변경한 내용입니다.\n\n![이미지](/assets/img/2024-06-22-DecipheringtheInnerWorkingsofTransactionProcessinginMySQL_6.png)\n\n거래 T1이 시작되었고 값을 A로 수정했다고 가정해 봅시다.\n\n![이미지](/assets/img/2024-06-22-DecipheringtheInnerWorkingsofTransactionProcessinginMySQL_7.png)\n\n거래 T1이 아직 진행 중인 동안 거래 T2가 시작되어 값을 B로 수정합니다.\n\n<div class=\"content-ad\"></div>\n\n![2024-06-22-DecipheringtheInnerWorkingsofTransactionProcessinginMySQL_8.png](/assets/img/2024-06-22-DecipheringtheInnerWorkingsofTransactionProcessinginMySQL_8.png)\n\n이 시점에서 트랜잭션 T1 및 T2는 아직 진행 중입니다. 트랜잭션 T3가 시작되어 값을 C로 수정합니다.\n\n![2024-06-22-DecipheringtheInnerWorkingsofTransactionProcessinginMySQL_9.png](/assets/img/2024-06-22-DecipheringtheInnerWorkingsofTransactionProcessinginMySQL_9.png)\n\n위 다이어그램은 MVCC 버전 제어 체인이라는 특정 용어를 소개합니다. 또한 ReadView라는 새 용어가 포함됩니다.\n\n<div class=\"content-ad\"></div>\n\n각 트랜잭션은 시작될 때마다 ReadView가 생성됩니다.\n\n이제 ReadView에 대해 자세한 설명과 분석을 진행하겠습니다.\n\nReadView.\n\n각 트랜잭션이 시작될 때마다 ReadView가 생성됩니다. 그 목적은 각 트랜잭션 내의 작업과 관련된 특정 Undo Log 항목을 기록하는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n여러 필드가 관련됩니다: m_ids, min_trx_id, max_trx_id 및 creator_trx_id입니다. 이들의 구체적인 의미는 다음과 같습니다:\n\n- m_ids: 활성 트랜잭션의 ID를 기록하는데 사용됩니다.\n- min_trx_id: 현재 활성 트랜잭션 중 가장 작은 트랜잭션 ID입니다.\n- max_trx_id: 생성될 다음 트랜잭션 ID입니다. 현재 m_ids에 없는 ID여야 합니다. (트랜잭션 ID는 오름차순으로 생성됩니다.)\n- creator_trx_id: 현재 활성 트랜잭션의 ID입니다.\n\n현재 저장된 레코드가 다음과 같이 있습니다:\n\n![이미지](/assets/img/2024-06-22-DecipheringtheInnerWorkingsofTransactionProcessinginMySQL_10.png)\n\n<div class=\"content-ad\"></div>\n\n지금쯤에는 이미 명확히 이 레코드가 이전 트랜잭션에서의 수정 결과임을 알고 계실 것입니다.\n\n이제 우리는 T4, T5 및 T6이 순차적으로 열렸다고 가정해 봅시다.\n\n우리는 트랜잭션 T4부터 시작해 봅시다. 이 시점에서 m_ids는 [T4, T5, T6]이고, min_trx_id는 T4, max_trx_id는 T7, 그리고 creator_trx_id는 T4입니다.\n\n![이미지](/assets/img/2024-06-22-DecipheringtheInnerWorkingsofTransactionProcessinginMySQL_11.png)\n\n<div class=\"content-ad\"></div>\n\nT4 트랜잭션이 쿼리 작업을 시작합니다. 아래는 실행 방법입니다: \n\n첫째로, MVCC 버전 제어 체인을 따라 내려가면서 이 레코드의 이전 작업에 대한 트랜잭션 ID를 검색합니다.\n\n해당 언도로그 항목과 연관된 트랜잭션 ID가 T3임을 발견합니다. 이 ID는 T4의 자체 트랜잭션 ID보다 작은 것으로 나타납니다.\n\n따라서 이 레코드가 T4 트랜잭션에 의해 수정되지 않았음이 확인됩니다.\n\n<div class=\"content-ad\"></div>\n\n또한 m_ids의 거래 ID가 T4, T5, T6이며 T3가 모든 것보다 작기 때문에, 현재 거래가 시작되기 전에 발견된 레코드가 있었다는 것을 유추할 수 있습니다.\n\n따라서 거래 T4는 값 C를 검색합니다.\n\n이 시점에서 거래 T5도이 레코드를 쿼리하기 시작합니다. 거래 T5는 데이터를 쿼리하는 동일한 절차를 따를 것이며, 결과는 C입니다. 위에서 거래 T4의 분석을 고려하면 간단해 보입니다.\n\n거래 T5가 값을 B로 변경하면 무엇이 발생합니까?\n\n<div class=\"content-ad\"></div>\n\n![Table](/assets/img/2024-06-22-DecipheringtheInnerWorkingsofTransactionProcessinginMySQL_12.png)\n\n이 시점에서 트랜잭션 T4가 다시 활성화되어 다른 쿼리 작업을 실행합니다. 결과는 무엇이어아아할까요?\n\n먼저, 트랜잭션 T4는 이 레코드의 MVCC 버전 제어 체인을 아래로 따라가다가 ID가 T5인 트랜잭션을 만납니다.\n\nM_ids의 최소 트랜잭션 ID보다 T5의 트랜잭션 ID가 더 크기 때문에 T5 트랜잭션이 현재 활성 상태임을 확인할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n그래서 트랜잭션 T4는 T5와 관련된 undo 로그에서 값을 검색하지 않습니다.\n\n이어서 검색을 계속하면, 트랜잭션 ID가 T3인 undo 로그 레코드를 찾습니다. 비교해보니, T3가 m_ids에 없으며 m_ids의 최소 트랜잭션 ID보다 작은 것을 확인합니다.\n\n마지막으로, 초기 쿼리 결정 프로세스를 반복합니다.\n\n이 순간에 트랜잭션 T4가이 레코드의 값을 A로 변경한다고 가정해봅시다. 그런 다음, 트랜잭션 T4가이 레코드를 다시 쿼리합니다.\n\n<div class=\"content-ad\"></div>\n\n결과는 무엇이 될까요?\n\n![이미지](/assets/img/2024-06-22-DecipheringtheInnerWorkingsofTransactionProcessinginMySQL_13.png)\n\n트랜잭션 T4가 쿼리를 시작하고 이 시점에서 롤백 로그의 첫 번째 항목의 트랜잭션 ID가 T4임을 발견합니다. 비교해보니 자신의 트랜잭션 ID라는 것을 깨달았습니다. 따라서 쿼리 결과는 A입니다.\n\n이 시점에서 트랜잭션 T5가 쿼리를 한다면 어떻게 될까요?\n\n<div class=\"content-ad\"></div>\n\n먼저, T5는 최신 트랜잭션 ID가 m_ids에 있는 T4임을 알아차립니다. 이것은 현재 진행 중인 트랜잭션으로서 자신의 트랜잭션 ID와 다르다는 것을 추론할 수 있습니다.\n\n그러므로 T5는 이 값을 가져오지 않을 것입니다.\n\n그런 다음, T5는 undo 로그 체인을 따라 거슬러 올라가 T5 트랜잭션 ID가 있는 레코드를 찾아 자신의 트랜잭션이라는 것을 깨달습니다.\n\n따라서, T5에 대한 쿼리 결과는 B입니다.\n\n<div class=\"content-ad\"></div>\n\n실제로, 거래의 기본 메커니즘은 ReadView 개념을 기반으로 설계되었습니다. 거래의 기본 원칙에 대해 알아볼 때 Read Commit (RC)와 Repeatable Read (RR)를 사용하여 분석해 보겠습니다.\n\nRead Commit.\n\nRead Commit은 거래 격리 수준 중 하나로, 커밋된 레코드를 읽는 것을 의미합니다. 예를 들어, 거래 A와 거래 B가 모두 활동 중인 경우, 거래 B에 의해 커밋된 레코드를 거래 A가 읽을 수 있습니다.\n\n차근차근 분석해 봅시다. 먼저, Read Commit 격리 수준 아래에서 각 쿼리 작업은 새로운 ReadView를 생성한다는 점을 이해하는 것이 중요합니다. 이것이 Read Commit의 핵심 아이디어입니다.\n\n<div class=\"content-ad\"></div>\n\n거래 ID가 각각 T1과 T2인 거래 T1과 T2가 있다고 가정해봅시다.\n\n거래 T1은 아직 활성화되지 않았지만, 거래 T2는 커밋하기 전에 특정 레코드의 값을 B로 변경합니다 (원래 값은 X로 가정).\n\n지금은 다음 다이어그램으로 시나리오를 시각화할 수 있습니다:\n\n![다이어그램](/assets/img/2024-06-22-DecipheringtheInnerWorkingsofTransactionProcessinginMySQL_14.png)\n\n<div class=\"content-ad\"></div>\n\n이 시점에서 트랜잭션 T1이 활성화되어 쿼리 작업을 시작합니다.\n\n위의 분석을 따라 데이터베이스는 다음 속성 값으로 새로운 ReadView를 생성합니다:\n\n- m_ids: [T1, T2].\n- min_trx_id: T1.\n- max_trx_id: T3.\n- creator_trx_id: T1.\n\n다음으로, 이 프로세스는 이전에 논의된 것과 유사합니다.\n\n<div class=\"content-ad\"></div>\n\n우선 T1은 가장 최근의 트랜잭션 ID인 T2를 조회합니다.\n\nT2가 m_ids에 있는데 자체 트랜잭션 ID와 일치하지 않음을 발견합니다.\n\n그래서 undo 로그 체인을 따라 계속 검색합니다.\n\n그런 다음 트랜잭션 ID Tx를 가진 레코드를 발견하고, Tx가 m_ids에 없으며, 최소 트랜잭션 ID(T1)보다 작음을 알아차립니다.\n\n<div class=\"content-ad\"></div>\n\n따라서, 거래 ID Tx를 가진 레코드가 원래 있었음을 결론 지을 수 있으며, 쿼리 결과는 X입니다.\n\n그다음, 거래 T2가 다시 활성화되어 거래를 커밋하고, 그런 다음 거래 T1이 다른 쿼리 작업을 시작합니다.\n\n이제 이 시점에서 Read Commit (RC)의 핵심이 분명해집니다: 데이터베이스는 거래 T1을 위해 새로운 ReadView를 생성하며, 그 네 가지 속성에 대한 다음 값이 있습니다.\n\n- m_ids: [T1].\n- min_trx_id: T1.\n- max_trx_id: T3.\n- creator_trx_id: T1.\n\n<div class=\"content-ad\"></div>\n\n위에 있는 표 태그를 Markdown 형식으로 변경해주세요.\n\n<div class=\"content-ad\"></div>\n\nRepeatable Read (RR)의 핵심 아이디어는 ReadView가 생성된 후 트랜잭션이 커밋될 때까지 다시 생성되지 않는다는 것입니다.\n\n우선, 트랜잭션 ID가 각각 T1과 T2인 T1과 T2 트랜잭션을 고려해 보겠습니다. 트랜잭션 T2는 값이 B로 수정되고(원래 값은 X였다고 가정), 그 후에 트랜잭션 T1은 쿼리 작업을 시작합니다:\n\n![이미지](/assets/img/2024-06-22-DecipheringtheInnerWorkingsofTransactionProcessinginMySQL_15.png)\n\n쿼리 프로세스는 이전과 정확히 동일합니다. 여기서 다시 자세히 설명하지는 않겠습니다.\n\n<div class=\"content-ad\"></div>\n\n다음으로, 트랜잭션 T2가 다시 활성화되어 트랜잭션을 커밋하고, 그 후에 트랜잭션 T1이 또 다른 쿼리를 시작합니다.\n\n이제 기적이 일어나는데, 방금 언급한 대로 ReadView는 트랜잭션이 커밋될 때까지 다시 생성되지 않습니다.\n\n트랜잭션 T1이 ReadView를 생성할 때 m_ids로 T1과 T2를 가지고 있었기 때문에 이제도 같은 값을 가지고 있습니다.\n\n쿼리는 다음과 같이 진행됩니다: 트랜잭션 T1은 초기에 T2의 트랜잭션 ID를 가진 레코드를 만납니다.\n\n<div class=\"content-ad\"></div>\n\nT2가 m_ids에 있기 때문에 해당 값을 가져오지 않고 검색을 계속할 것입니다.\n\n거래 ID Tx를 가진 레코드를 찾았을 때 Tx가 m_ids에 없다고 판단하면 쿼리 결과는 X가 됩니다.\n\n이제 왜 이 독립성 수준 아래의 거래가 서로 간섭하지 않는지 이해하셨죠? 이것이 그 원리입니다.\n\n<div class=\"content-ad\"></div>\n\n그런 이야기를 좋아한다면 저를 지원하고 싶으시면 박수를 부탁드립니다.\n\n여러분의 지원은 저에게 매우 중요합니다. 감사합니다.","ogImage":{"url":"/assets/img/2024-06-22-DecipheringtheInnerWorkingsofTransactionProcessinginMySQL_0.png"},"coverImage":"/assets/img/2024-06-22-DecipheringtheInnerWorkingsofTransactionProcessinginMySQL_0.png","tag":["Tech"],"readingTime":11},{"title":"HerTechTrail 여정 기술 입문 여성들을 위한 완벽 가이드","description":"","date":"2024-06-22 04:26","slug":"2024-06-22-HerTechTrailJourney","content":"\n\n프론트엔드 개발자가 되는 길\n\n![her tech trail journey](/assets/img/2024-06-22-HerTechTrailJourney_0.png)\n\n셀프 터득 개발자로서 코딩을 배우면서 겪은 일들은 정말 롤러코스터 같았어요! 상상해보세요. 기술에 흥미 없는 사람이 프론트엔드 개발 세계에 뛰어들어 HTML과 CSS에 씨름하면서 가이드가 필요했던 모습을요. 어려움이 있었고 도중에 멘토나 동료를 만날 수 없어 어려움에 부딪혔죠. 결국 4개월 동안 쉬어야만 했고 절망에 빠지곤 했어요.\n\n그래도, 걱정 마세요. 이런 평범한 애잔한 이야기가 아니에요! 수학을 좋아하지 않지만 포기하지 않고 끈기를 가졌어요. 불을 꺼지 않게 하기 위해 유데미의 유료 강좌를 구매하고 다시 코딩 세계로 돌아가 새로운 동기부여를 가지고 나서게 되었어요. HTML과 CSS 프로젝트를 다시 시작한 것이었는데, 정말 흥미진진한 여행을 했답니다. 함께 이 잊지 못할 여정을 함께할까요?\n\n<div class=\"content-ad\"></div>\n\n# HerTechTrail 아카데미\n\nHerTechTrail 아카데미는 아프리카의 여성을 위한 완전히 가상 학습 플랫폼입니다.\n\n나는 3개월 동안 가상 주간 수업을 통해 HTML, CSS 및 JavaScript에 대해 멘토링을 받게 될 Web Developer Starter 부트캠프에 지원했습니다. 부트캠프에서는 우리에게 교육과 멘토링을 제공할 것입니다. 부트캠프를 끝내면 다양한 미니 프로젝트와 포트폴리오 프로젝트를 준비하게 될 것입니다.\n\n## 무엇을 배웠나요?\n\n<div class=\"content-ad\"></div>\n\n부트캠프에서는 중급 수준의 HTML, CSS 및 Javascript을 다루었습니다.\n\n첫 달에는 HTML 요소, 태그, 속성 및 스타일에 대해 배웠어요. 또한 기본적인 HTML 폼, 미디어 및 비디오 임베드, 그리고 접근성에 대해 다뤘습니다.\n\n첫 달과 대부분의 두 번째 달에는 CSS에 초점을 맞췄어요. 몇 가지 프로젝트를 진행해왔지만 언제나 CSS에 어려움을 겪어왔어요. 라이브 수업에서 멘토로부터 배우는 것이 기분이 좋았고 많은 것을 이해할 수 있었어요. 게다가 부트스트랩과 미디어 쿼리를 사용한 반응형에 대해 배웠습니다.\n\n반응형 웹 디자인(RWD)은 웹 페이지가 모든 화면 크기와 해상도에서 잘 렌더링되어 사용성을 향상시킵니다. 이 웹 개발 측면은 웹 페이지 사용자의 다양한 화면 크기에 맞추어져 중요합니다.\n\n<div class=\"content-ad\"></div>\n\n지난 달에는 JavaScript에 집중했어요. 이것이 제가 처음 접한 프로그래밍 언어였는데, 도전적이었어요. JavaScript를 사용하면 웹 페이지에서 시기적절한 콘텐츠 업데이트, 대화식 지도, 다양한 그래픽 요소 등 복잡한 기능을 구현할 수 있어요.\n\n전반적으로, 수업은 다양한 주제를 다루었고, 배운 기술들은 제 포트폴리오를 만들기에 충분해요.\n\n## 새로 배운 것은 무엇인가요?\n\n세부 수업을 통해 HTML 기술을 향상할 수 있었어요. 다양한 스타일과 태그에 대해 더 잘 이해하고, 웹 페이지에서 적절하게 반응형을 구현하는 방법을 배웠어요.\n\n<div class=\"content-ad\"></div>\n\nCSS에 대해 이야기할 때는 미디어 쿼리를 사용한 반응형 디자인에 집중했어요. 다양한 화면으로 연습하면서 이 측면에서 능숙해졌답니다. 때로는 CSS 스타일링이 어려웠지만, 어려움을 겪을 때 Bootstrap을 활용해 도움을 받아왔어요. Bootstrap은 스타일링의 부담을 덜어주는 많은 기능을 갖춘 가치 있는 도구라고 생각해요.\n\n자바스크립트가 가진 도전에도 불구하고, 이를 배우면서 내 창의적인 면을 발휘할 수 있었어요. 이제는 자주 사용하거나 마주치는 일상 앱의 프로그래밍 흐름에 대해 이야기하게 되었어요. 예를 들어, 슈퍼마켓 계산대가 어떻게 작동하는지 설명하고, 중첩된 루프와 if, else if와 같은 조건문을 결합하여 앱을 만드는 방법에 대해 살펴보았어요.\n\nGit과 버전 관리를 처음 접했을 때는 새로웠지만, 중요성을 즉시 깨달았어요. GitHub를 자주 사용하지만, 버전 관리에 대해 완전히 이해하지 못해 파일을 직접 플랫폼에 업로드해왔죠. Git과 버전 관리 수업은 전체 부트캠프의 정점이었는데, 포트폴리오 프로젝트를 위해 이를 활용해야 했어요.\n\n## 다음 단계는 무엇일까요? 어떻게 더 나은 개발자가 될 수 있을까요?\n\n<div class=\"content-ad\"></div>\n\n연습! 연습!! 연습!! 연습하면 나는 더 나아질 수 있어요. 저는 주니어 레벨 프론트엔드 개발자로 성장했고, 일관된 연습과 웹 앱 구축으로만 더 나아질 수 있어요.\n\n올해 두 번째 반기에는 내 기술을 숙달하고 반응형 웹 앱을 만들기 위해 시간을 보낼 계획이에요.\n\n더불어 React.js를 배워 인턴십에 지원할 예정이에요.\n\n## 15 Days of Code\n\n<div class=\"content-ad\"></div>\n\nHerTechTrail Academy의 이 프로젝트는 수업에서 배운 내용을 연습하는 뛰어난 방법이었어요. 15일 동안 다양한 웹 앱을 구축, 스타일링, 배포하는 것은 정말 도전적이었죠. 저는 그 당시 JavaScript를 잘 몰라서 스타터 트랙을 선택했어요. 이 경로는 제 HTML과 CSS 스킬을 크게 시험했고, 저는 다음과 같은 웹 페이지를 만들었어요:\n\n1일~5일: HTML과 CSS를 사용하여 정적 페이지를 만들었어요. HerTechTrail Academy의 가입 페이지를 디자인하고 스타일링하여 반응성을 구현했죠. 마지막으로 CodePen을 통해 배포했어요.\n\n6일~10일: 사용자 정의 404 페이지를 만들었어요. HTML과 CSS를 사용하여 404 오류 페이지를 디자인하고 스타일링하여 모든 기기에서 완벽한 반응성을 보장했죠. 마지막으로 GitHub Pages에 호스팅했어요.\n\n11일~15일: 간단하고 반응성 있는 랜딩 페이지를 만들었어요. 수염 성장 회사를 위한 랜딩 페이지를 디자인하고 스타일링하여 반응성을 구현하고 GitHub Pages에 호스팅했어요.\n\n<div class=\"content-ad\"></div>\n\n이 도전 과제는 포트폴리오 프로젝트를 준비하는 데 도움이 되었습니다. 스타일링과 반응 형에 대해 더 많이 배웠기 때문에 더 의심스러워지지 않았어요.\n\n## 포트폴리오 프로젝트\n\n홈, 연락처, 소개, 포트폴리오 페이지를 포함한 멀티 페이지 포트폴리오 웹 앱을 작성해야 합니다.\n\n홈 페이지는 나에 대한 요약을 담은 간단한 랜딩 페이지가 될 것입니다. 그 내용에는 내가 사용하는 프로그래밍 언어가 포함됩니다. 다른 페이지로 이동하는 메뉴 바도 포함될 것입니다.\n\n<div class=\"content-ad\"></div>\n\nAbout 페이지는 웹 개발자로서의 여정을 다루며, 주요 이정표를 강조하고 제가 개발한 웹 앱 샘플을 소개할 것입니다.\n\nContact 페이지는 저의 연락처 정보를 표시하고, 이메일로 연락하고자 하는 사람들을 위한 간단한 양식을 포함할 것입니다.\n\nPortfolio 페이지는 내가 참여한 모든 프로젝트를 전시하고, 그것에 대한 외부 링크를 제공할 것입니다.\n\n개발 과정에서 홈페이지의 배경 이미지를 변경하는 것과 같은 어려움을 겪었습니다. 그러나 Pesticide 익스텐션과 Chrome 검사 도구의 도움을 받아 이를 극복했습니다. HTML Pesticide를 활용하여 코드를 디버깅하고 배경 이미지를 올바르게 스타일링했습니다.\n\n<div class=\"content-ad\"></div>\n\n또한, 제 웹 사이트의 모바일 반응성을 테스트하면서 1px의 중요성을 발견하면서 작은 세부 사항에 주의를 기울이는 것이 중요하다는 것을 배웠습니다. 저는 레드미와 삼성 두 안드로이드 기기에서 웹 사이트를 테스트했습니다. 먼저, 삼성 기기에서는 반응성이 있었지만 레드미에서는 그렇지 않았습니다. 미디어 쿼리에 픽셀을 추가한 후, 반응성 문제가 해결되었습니다.\n\n제 포트폴리오 링크는 아래에서 확인할 수 있습니다.\n\n멘토로부터의 조언과 교정, 그리고 HerTechTrail Academy의 소중한 기회와 코치 Magdalene Edozie와 Broma Elenwo의 지원에 감사드립니다.\n\n개발자 여정을 함께하고 싶다면, Linkedin, Twitter, 포트폴리오 및 GitHub에서 저를 팔로우해주세요.","ogImage":{"url":"/assets/img/2024-06-22-HerTechTrailJourney_0.png"},"coverImage":"/assets/img/2024-06-22-HerTechTrailJourney_0.png","tag":["Tech"],"readingTime":5},{"title":"NET C에서 SOLID 원칙 이해하기 코드 예시와 함께하는 실용 가이드","description":"","date":"2024-06-22 04:25","slug":"2024-06-22-UnderstandingSOLIDPrinciplesinNETCAPracticalGuidewithCodeExamples","content":"\n\nSOLID 원칙은 개발자가 쉽게 확장 가능한 코드를 작성하고 일반적인 코딩 오류를 피할 수 있게 도와줍니다.\n\n이 원칙들은 Robert C. Martin에 의해 소개되었으며 객체 지향 프로그래밍의 기본 요소가 되었습니다.\n\n.NET 개발에서 SOLID 원칙을 준수하면 코드가 더 모듈식, 유연하고 유지보수하기 쉬워질 수 있습니다. 이 글에서는 C#에서 실제 코딩 예제와 함께 각 SOLID 원칙을 자세히 살펴볼 것입니다.\n\n다음은 다섯 가지 SOLID 디자인 원칙입니다:\n\n<div class=\"content-ad\"></div>\n\n\n![Image](/assets/img/2024-06-22-UnderstandingSOLIDPrinciplesinNETCAPracticalGuidewithCodeExamples_0.png)\n\n# 1. 단일 책임 원칙 (SRP)\n\nSRP는 클래스가 변경되어야 하는 이유가 하나만 있어야 한다는 것을 말합니다. 즉, 하나의 책임만을 가져야 합니다. 이는 모듈화를 촉진하고 코드를 이해하고 유지보수하기 쉽게 만듭니다.\n\n주요 아이디어: 클래스는 한 가지 일만을 해야 하며, 그 일을 잘 수행해야 합니다.\n\n\n<div class=\"content-ad\"></div>\n\n실시간 예시: 레스토랑을 운영하거나 음식을 배달하는 것에만 전념하는 요리사를 생각해보세요.\n\nC#에서의 실용적인 코딩 예시:\n\nSRP를 적용하기 전:\n\n```js\npublic class Report\n{\n    public void GenerateReport() { }\n    public void SaveToFile() { }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 시나리오에서 Report 클래스는 리포트를 생성하고 파일로 저장하는 두 가지 책임을 갖고 있습니다. 이는 SRP를 위반합니다.\n\nSRP 적용 후:\n\n```js\npublic class Report\n{\n    public void GenerateReport() { }\n}\n\npublic class ReportSaver\n{\n    public void SaveToFile() { }\n}\n```\n\n이제 Report 클래스는 리포트 생성에만 책임이 있고, ReportSaver 클래스는 리포트 저장에 책임이 있습니다. 각 클래스는 단일 책임을 갖습니다.\n\n<div class=\"content-ad\"></div>\n\n해석: SRP에 따르면, 한 클래스는 하나의 책임을 가져야합니다. 이 문제를 해결하기 위해 보고서 기능을 저장하기 위해 다른 클래스를 작성해야 합니다. 이 때 Report 클래스를 수정해도 ReportSaver 클래스에는 영향을 미치지 않습니다.\n\n## 2. 개방/폐쇄 원칙 (OCP)\n\n개방/폐쇄 원칙은 클래스가 확장에 대해 열려 있어야 하지만 수정에 대해서는 닫혀 있어야 한다고 제안합니다. 이것은 기존 코드를 변경하지 않고 새로운 기능을 추가할 수 있다는 것을 의미합니다.\n\n주요 아이디어: 한 번 클래스를 작성하면 수정하는 것은 닫혀 있고, 확장하는 것은 열려 있어야 합니다.\n\n<div class=\"content-ad\"></div>\n\n실시간 예시: 당신의 스마트폰 - 기능을 추가하려면 열지 않고도 앱을 다운로드하여 능력을 확장할 수 있습니다.\n\nC#에서의 실용적인 코딩 예시:\n\nOCP 신청 전:\n\n```js\npublic class Rectangle\n{\n    public double Width { get; set; }\n    public double Height { get; set; }\n}\n\npublic class AreaCalculator\n{\n    public double CalculateArea(Rectangle rectangle)\n    {\n        return rectangle.Width * rectangle.Height;\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n새로운 도형을 추가할 때 이 디자인은 문제가 될 수 있습니다. 각 새로운 도형에 대해 AreaCalculator를 수정하면 OCP를 위반하게 됩니다.\n\nOCP를 적용한 후:\n\n```js\npublic interface IShape\n{\n    double CalculateArea();\n}\n\npublic class Rectangle : IShape\n{\n    // 구현\n}\n\npublic class Circle : IShape\n{\n    // 구현\n}\n```\n\n인터페이스(IShape)를 도입하여 기존 코드를 수정하지 않고도 새로운 도형(예: Circle)을 추가할 수 있습니다. OCP를 준수하는 방법입니다.\n\n<div class=\"content-ad\"></div>\n\nOCP에 따르면 클래스는 확장에 열려 있지만 수정에 대해 닫혀 있어야 합니다. 새로운 모양을 도입할 때는 그냥 인터페이스 IShape를 구현하면 됩니다. 그러면 IShape은 확장이 가능하지만 추가 수정은 불가능해집니다.\n\n## 3. 리스코프 치환 원칙 (LSP)\n\n리스코프 치환 원칙은 슈퍼클래스의 객체를 하위 클래스의 객체로 대체할 수 있어야 하며 프로그램의 정확성에 영향을 미치지 않아야 한다는 원칙입니다.\n\n주요 아이디어: 부모 클래스를 사용하는 곳에 하위 클래스를 사용할 수 있어야 합니다.\n\n<div class=\"content-ad\"></div>\n\n실시간 예시: 여러 브랜드의 TV에 모두 작동하는 원격 제어기를 가지고 있습니다.\n\nC#에서의 실용적인 코딩 예시:\n\nLSP를 적용하기 전:\n\n```csharp\npublic class Bird\n{\n    public virtual void Fly() { /* 구현 */ }\n}\n\npublic class Penguin : Bird\n{\n    public override void Fly()\n    {\n        throw new NotImplementedException(\"펭귄은 날지 못해요!\");\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n여기서 펭귄 클래스는 Fly 메서드에 예외를 발생시켜 LSP를 위반합니다.\n\nLSP를 적용한 후:\n\n```js\npublic interface IFlyable\n{\n    void Fly();\n}\n\npublic class Bird : IFlyable\n{\n    public void Fly()\n    {\n        // Bird에 특화된 구현\n    }\n}\n\npublic class Penguin : IFlyable\n{\n    public void Fly()\n    {\n        // 펭귄에 특화된 구현\n        throw new NotImplementedException(\"펭귄은 날지 못해요!\");\n    }\n}\n```\n\nIFlyable 인터페이스를 도입함으로써, Bird와 Penguin은 릴스코프 치환 원칙을 준수하게 되었습니다.\n\n<div class=\"content-ad\"></div>\n\n설명: LSP에 따르면 파생 클래스는 기본 클래스의 유형 정의와 동작을 깨뜨리지 않아야 합니다. 이는 기본 클래스의 객체를 파생 클래스의 객체로 교체해도 응용 프로그램이 깨지지 않아야 함을 의미합니다. 이는 파생 클래스의 객체가 기본 클래스의 객체와 동일한 방식으로 동작해야 한다는 것을 필요로 합니다.\n\n# 4. Interface Segregation Principle (ISP)\n\n인터페이스 분리 원칙은 클래스가 사용하지 않는 인터페이스를 강제로 구현하도록 해서는 안 된다고 말합니다. 이 원칙은 작고 특정 클라이언트용 인터페이스를 생성하는 것을 권장합니다.\n\n주요 아이디어: 클래스는 사용하지 않는 인터페이스를 구현하도록 강제되어서는 안 됩니다.\n\n<div class=\"content-ad\"></div>\n\n실시간 예시: 음악 스트리밍 서비스에 가입하여 좋아하는 장르만 선택하는 상황을 상상해보세요.\n\nC#에서의 실제 코딩 예시:\n\nISP 신청 전:\n\n```js\npublic interface IWorker\n{\n    void Work();\n    void Eat();\n}\n\npublic class Manager : IWorker\n{\n    // 구현\n}\n\npublic class Robot : IWorker\n{\n    // 구현\n}\n```\n\n<div class=\"content-ad\"></div>\n\n로봇 클래스는 ISP를 위반하지 않도록 먹는 방법을 구현해야 합니다.\n\nISP를 적용한 후:\n\n```js\npublic interface IWorkable\n{\n    void Work();\n}\n\npublic interface IEatable\n{\n    void Eat();\n}\n\npublic class Manager : IWorkable, IEatable\n{\n    // 구현\n}\n\npublic class Robot : IWorkable\n{\n    // 구현\n}\n```\n\nIWorkable 인터페이스를 IWorkable 및 IEatable 같은 작은 인터페이스로 분할하여, 각 클래스가 필요한 부분만 구현할 수 있도록 하여 ISP를 준수할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n설명: LSP에 따르면, 어떤 클라이언트도 해당 클라이언트와 관련이 없는 인터페이스를 강제로 사용해서는 안 됩니다. 다시 말해, 클라이언트는 사용하지 않는 메소드에 의존하도록 강요되어서는 안 됩니다.\n\n# 5. 의존 역전 원칙 (DIP)\n\n의존 역전 원칙은 고수준 모듈이 저수준 모듈에 의존하지 않아야 하며, 두 모듈 모두 추상화에 의존해야 한다는 것을 제안합니다. 또한, 추상화는 세부사항에 의존해서는 안 되며, 세부사항은 추상화에 의존해야 합니다.\n\n주요 아이디어: 고수준 모듈은 저수준 모듈에 의존해서는 안 되며, 두 모듈 모두 추상화에 의존해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n실시간 예제: 레고 타워 만들기 - 브릭(고수준 및 저수준 모듈)은 작은 브릭(추상화)을 통해 연결됩니다.\n\nC#에서의 실용적인 코딩 예제:\n\nDIP를 적용하기 전:\n\n```js\npublic class LightBulb\n{\n    public void TurnOn() { /* 구현 */ }\n    public void TurnOff() { /* 구현 */ }\n}\n\npublic class Switch\n{\n    private LightBulb bulb;\n\n    public Switch(LightBulb bulb)\n    {\n        this.bulb = bulb;\n    }\n\n    public void Toggle()\n    {\n        if (bulb.IsOn)\n            bulb.TurnOff();\n        else\n            bulb.TurnOn();\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n스위치 클래스는 이제 추상화에 의존하도록 변경되어 DIP(Dependency Inversion Principle)를 준수합니다.\n\n<div class=\"content-ad\"></div>\n\n해석: DIP에 따르면 어플리케이션이 점점 커져갈 때 서로 강하게 결합된 코드를 작성하는 것은 유지보수하기 어려운 악몡이 될 수 있습니다. 한 클래스가 다른 클래스에 의존할 경우, 의존하는 클래스가 변경되면 해당 클래스도 수정해야 합니다. 항상 느슨하게 결합된 클래스를 작성하려고 노력해야 합니다.\n\n결론\n\n.NET 개발자들은 이러한 SOLID 원칙을 이해하고 적용함으로써 더 강력하고 유연하며 유지보수가 쉬운 소프트웨어를 만들 수 있습니다. 이러한 원칙이 함께 작동하여 서로 보완하며 객체지향 프로그래밍의 전체적인 설계 철학에 기여한다는 점을 명심하는 것이 중요합니다.\n\n저자: Jeslur Rahman","ogImage":{"url":"/assets/img/2024-06-22-UnderstandingSOLIDPrinciplesinNETCAPracticalGuidewithCodeExamples_0.png"},"coverImage":"/assets/img/2024-06-22-UnderstandingSOLIDPrinciplesinNETCAPracticalGuidewithCodeExamples_0.png","tag":["Tech"],"readingTime":6},{"title":"온디맨드 ISR로 새로운 콘텐츠 빠르게 제공하는 방법","description":"","date":"2024-06-22 04:23","slug":"2024-06-22-DeliverNewContentFasterOnDemandISR","content":"\n\n\n![img](/assets/img/2024-06-22-DeliverNewContentFasterOnDemandISR_0.png)\n\nNext.js 버전 12.2.0에는 HTML을 정적으로 렌더링하는 새로운 기능인 On-Demand Incremental Static Regeneration이 소개되었습니다. 이 기능은 자주 변경되는 데이터 풀을 가진 기업에게 중요하며, 특히 사용자 브라우저에 최소한의 오래된 데이터가 남도록 필요로 하는 중요한 콘텐츠를 가진 기업에게 필수적입니다. 이 글에서는 정적 생성의 여러 형태를 탐구하고, 각 형태가 지난번 것의 효율성이나 성능 측면에서 어떻게 발전되어 가다가 od-ISR에 도달하는지 살펴볼 것입니다.\n\n# 정적 사이트 생성\n\n정적 사이트 생성(Static Site Generation, SSG)은 많은 사용 사례에 대해 클라이언트 사이드 렌더링(CSR)과 서버 사이드 렌더링(SSR)에 유용한 대안입니다. 클라이언트 사이드 렌더링은 클라이언트(사용자 브라우저)가 JavaScript를 HTML과 CSS로 렌더링하여 사용자에게 페이지를 제공하는 것에 의존합니다. 현재의 웹 개발 환경에서 CSR은 일반적으로 대량의 번들화된 JavaScript를 프론트엔드로 보내는 단일 페이지 응용 프로그램(Single Page Application, SPA)으로 이어집니다. 이로 인해 페이지를 렌더링하기 위해 필요한 HTML과 CSS를 브라우저에게 위임함으로써 성능이 좋지 않은 사이트를 만들 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\nSSR의 경우에는 서버가 더 많은 작업을 처리합니다. 각 페이지 이동은 서버에 요청을 일으키고, 서버는 관련 페이지와 JSON 데이터를 작성하여 응답합니다. 서버는 일반적으로 브라우저보다 강력하며, 페이지를 렌더링하는 데 필요한 내부 회사 데이터와 함께 동일한 위치에 배치될 수 있어 이 콘텐츠를 수집하기 위한 빠른 서버 측 HTTP 요청을 가능케합니다. 일반적으로 CSR은 렌더링 후 반응성이 중요한 매우 동적이고 대화형 응용 프로그램에 적합하며, SSR은 초기 페이지 로드를 더 빠르게 만드는 데 유리합니다. CSR은 캐싱된 에셋 및 콘텐츠 또는 CDN 또는 CDN이있는 CMS(예 : Sanity)에 데이터를 가져와 사용자에게 제공하여 페이지를 렌더링합니다.\n\n많은 현대적인 프레임워크는 일부 루트가 구성 파일에 따라 SSR을 통해 렌더링되고 다른 루트가 CSR을 통해 렌더링되는 하이브리드 렌더링 형태를 지원합니다. 예를 들어, Nuxt는 Nuxt 구성 파일에서 지정된 대로 다양한 루트를 대상으로 렌더링 할 수 있습니다.\n\n![image](/assets/img/2024-06-22-DeliverNewContentFasterOnDemandISR_1.png)\n\n정적 사이트 생성(SSG)은 CSR 및 SSR과는 완전히 다른 방식입니다. SSG는 모든 웹 페이지가 빌드 시간에 생성되어 서버에 저장되는 아키텍처입니다. 일반적으로 이에는 일종의 템플릿 기능이 포함됩니다. 블로그를 예로 들어보겠습니다. 모든 블로그 페이지가 동일한 형식으로 표시되는 경우를 생각해보세요. 정적 사이트 생성기는 일반적인 블로그 글 페이지에 대한 HTML 템플릿을 저장하고, 구조화된 데이터 형식 (예: JSON)을 사용하여 각 별도의 블로그 페이지를 위한 HTML 템플릿을 배포할 정보를 저장합니다. 클라이언트가 요청을 하면 저장된 사전에 생성된 HTML, CSS, 클라이언트 측 JavaScript (예를 들어 사용자 상호 작용에서의 HTTP 요청 제작용) 및 데이터가 즉시 사용자의 브라우저로 전송됩니다. 페이지를 브라우저에서 빌드하는 작업은 필요하지 않습니다. 이로 인해 초기 페이지 로드가 빠릅니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-22-DeliverNewContentFasterOnDemandISR_2.png)\n\n위 다이어그램은 SSG를 통해 렌더링된 블로그 사이트 아키텍처의 단순한 예제를 보여줍니다. 빌드 시기에 (1) Next는 콘텐츠 관리 시스템 (CMS)에 서버 측 호출을 수행하여 (2) 데이터를 받아 (3) 블로그 게시물을 정적으로 생성합니다. 또한 Next는 추가로 하나 이상의 API (4)를 호출하여 이 콘텐츠를 생성하거나 추가 데이터를 받을 수 있습니다 (5). 클라이언트가 요청을 보낼 때 (6), 미리 빌드된 페이지가 응답으로 제공되며, 클라이언트 측 JavaScript, HTML, CSS 및 관련 데이터 (7)가 포함됩니다. SSG는 사이트에서 상호 작용을 금지하지 않으며, 각 페이지와 함께 전송되는 클라이언트 측 JavaScript에 의해 하나 이상의 API 또는 서비스 (예: Stripe)로 추가 CRUD 요청이 수행될 수 있습니다 (8, 9). 정적 사이트 생성기에 의해 생성된 페이지는 엔드 유저에게 가능한 한 가까운 위치에 있는 CDN에 캐시될 수도 있습니다 (여기서는 생략). 요청-응답 주기에서 증가된 거리가 가장 큰 성능 억제 요인 중 하나이므로, 이를 통해 페이지 로드 시간을 더욱 줄일 수 있습니다.\n\n정적 사이트 생성은 매우 뛰어난 로드 시간 성능을 제공합니다. 그러나 큰 단점이 하나 있습니다. 순수 SSG를 통해 렌더링된 사이트에서 하나의 페이지를 변경하면 서버에 저장된 모든 페이지를 완전히 다시 빌드해야 합니다. 이것이 순수 SSG의 가장 큰 병목 현상입니다. 밤 늦은 글쓰기 세션 중에 블로그 게시물 하나에서 철자를 잘못 입력한 경우를 상상해보세요. 사이트에 게시물이 얼마나 많이 있는지에 따라, 그것은 치명적인 실수일 수 있습니다.\n\n# stale-while-revalidate 및 증분 정적 재생\n\n\n<div class=\"content-ad\"></div>\n\n순수 SSG의 명백한 단점은 자주 변경되는 콘텐츠에 대해 아키텍처를 쓸모없게 만든다는 것입니다. SSG로 돌아가서, 모든 페이지가 생성되고 서버에 저장될 때 (다시 말해 캐시되어 있을 때), 개발자가 이 내부 캐시를 무효화하여 페이지를 다시 만드는 것을 막는 것은 무엇인가요? 여기에서 나타나는 것이 바로 SWR(지속-중재 확율)입니다. HTTP Cache-Control 헤더에 설정된이 값은 동반하는 max-age 값에 따라 캐시된 응답의 유효성을 결정합니다. SWR이 있는 Cache-Control HTTP 헤더는 다음과 같이 설정할 수 있습니다:\n\n```js\nCache-Control: max-age=604800, stale-while-revalidate=86400\n```\n\n이 헤더는 받는 서버, CDN 또는 클라이언트에게 콘텐츠를 재검증하기 전에 7일 동안 HTTP 응답을 캐시하도록 지시합니다. 일곱 일이 지나면 캐시된 응답은 더 이상 유효하지 않습니다. 이때 특정 URL의 특정 서버, CDN 또는 브라우저에 대한 요청이 발생하면, 즉시 스테일 콘텐츠가 응답으로 제공되고 백그라운드에서 내용을 다시 확인하고 캐시를 새로 고침하기 위해 원본 서버에 새 요청이 이루어집니다.\n\n여기에서 몇 가지 네이밍 컨벤션 혼란이 발생합니다. SWR을 렌더링 모드로 부르고 CDN의 존재 여부에 따라 Incremental Static Regeneration (ISR)와 의미론적으로 구분하여 네이밍을 혼동할 수 있습니다. CDN이 없는 경우 SWR은 렌더링 아키텍처이고 CDN이 있는 경우 ISR이 아키텍처이므로 (Nuxt 3 참조).\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-22-DeliverNewContentFasterOnDemandISR_3.png)\n\nSWR의 아이디어를 렌더링 모드와 분리하는 것이 현실적입니다. 이는 Cache-Control 헤더에 설정된 값을 의미하며, 해당 응답의 캐시 동작을 제어할 수 있습니다 (서버, CDN 또는 클라이언트가 stale-while-revalidate을 Cache-Control 값으로 수락할 수 있다면). Cache-Control 헤더의 must-revalidate 값과 마찬가지로 일반적입니다.\n\n![이미지](/assets/img/2024-06-22-DeliverNewContentFasterOnDemandISR_4.png)\n\n그러나 증분 정적 재생성은 SWR 헤더를 사용하여 정적으로 생성된 콘텐츠를 저장하고 다시 유효성을 검사하는 서버 또는 CDN에서 SWR 헤더를 활용한 아키텍처로 취급할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-22-DeliverNewContentFasterOnDemandISR_5.png)\n\n위 다이어그램은 ISR 기반 아키텍처가 어떻게 보일 수 있는지 간단히 보여줍니다. 이를 현대적인 뉴스 사이트로 생각해보면 지친 기자들이 악화되는 정치적 기후에 대응하고, AI가 생성한 실수에 대처하고, 독자들의 트위터에서의 소란한 피드백에 대응하며 자주 변경되는 컨텐츠를 가질 것입니다. 여기서 Next 서버는 모든 페이지를 빌드 시간에 생성합니다(1), CMS(2) 또는 API(4)로 서버 콜을 통해 관련 데이터(3, 5)를 수신합니다. 이러한 페이지는 TTL(Time-To-Live) 값(12)으로 생성되며, 이 경우 60초입니다. 이는 Cache Control 값을 나타내는 max-age 와 동일합니다. 만약 클라이언트가 이와 같은 뉴스 기사에 대한 요청을 할 경우, 우리 아키텍처에서 요청은 먼저 CDN(8)에 도달합니다. TTL이 만료되지 않았고 60초 창 안에 있다면, CDN는 즉시 페이지를 제공(9)하고 추가 조치가 필요하지 않습니다.\n\n![이미지](/assets/img/2024-06-22-DeliverNewContentFasterOnDemandISR_6.png)\n\n만약 60초의 TTL이 지났다면, CDN는 페이지를 사용자에게 제공하는데 문제가 없습니다. 사용자는 CDN 캐시에서 즉시 정적으로 생성된 페이지를 받습니다(9). CDN는 이로써 끝나지 않으며, 서버에 신선하게 생성된 페이지를 요청합니다(6). 이 시점에서 서버는 CMS 또는 API에서 데이터를 다시 가져오도록 서버쪽에서 스크램블하여 이 특정 페이지(2, 4)를 재검증하며 해당 데이터를 받아 다시 해당 페이지를 생성합니다(3, 5). 그런 다음, 해당 페이지를 CDN에 다시 캐시하기 위해 보냅니다(7). 이러한 방식으로 생성된 사이트는 사용자가 HTTPS 요청을 통해 클라이언트 측 JavaScript(10, 11)를 사용하여 하나 이상의 API 또는 서비스에 대한 CRUD 작업을 시작하는 등 추가 상호작용을 제한하지 않습니다.\n\n\n<div class=\"content-ad\"></div>\n\nISR보다 SSG의 혜택은 즉각적으로 나타납니다. 이제 한 가지 오타를 고치거나 기사 일부를 철회하거나 불운한 제목을 수정하기 위해 전체 사이트를 다시 빌드할 필요가 없습니다. 이로 인해 많은 비용이 드는 전체 사이트 재구축을 피할 수 있습니다. 콘텐츠가 한 페이지에서만 변경된다면, 왜 모든 페이지를 재구축해야 할 때와 같은 시간과 컴퓨팅 비용을 낭비해야 할까요? 또한 사용자 상호 작용을 통해 페이지를 다시 생성함으로써 불필요한 재구축을 최소화합니다. 드물게 방문하는 페이지는 상호 작용이 있을 때에만 다시 빌드됩니다.\n\n그러나 이 아키텍처에는 단점도 있습니다. ISR의 경우 실시간 데이터 업데이트는 여전히 진정한 기능이 아닙니다. 예를 들어 기자가 7일 TTL이 설정된 뉴스 기사를 게시했다고 가정해봅시다. 모든 QA 확인을 통과하고 게시된 후에 기사 제목에 철자 오류가 있다는 것을 깨닳기 전에 사용자들에게 즉각적으로 알려져 조롱하는 트위터 게시물에 응답을 받습니다. 만약 창조자가 게시물을 편집하고 그냥 기다린다면, 기사가 새롭게 업데이트되기까지 전체 7일이 걸릴 수 있습니다. 캐시는 수동으로 무효화되어야 할 것입니다. 또한 서버가 페이지를 재생성하는 데 시간이 걸립니다. 그동안 모든 사용자는 CDN이나 서버가 답변으로 반환하는 제목 오타가 있는 낡은 콘텐츠를 받게 됩니다. 게다가 위에서 언급한 드물게 방문하는 페이지가 오랜 기간 동안 재구축되지 않으면 문제가 발생할 수 있습니다. 한 달 동안 방문하지 않은 페이지가 있다고 생각해보세요. 질문이 생깁니다 — 너무 오래된 것은 과연 얼마나 오래 된 것인가요?\n\n# 온디맨드 증분 정적 재생성\n\n![Deliver New Content Faster On-Demand ISR](/assets/img/2024-06-22-DeliverNewContentFasterOnDemandISR_7.png)\n\n<div class=\"content-ad\"></div>\n\nOn-Demand Incremental Static Regeneration (od-ISR, 동료 엔지니어가 만든 비표준 약어)은 위에 나열된 많은 질문에 대해 다룹니다. TTL에 기반한 캐시 무효화 대신, 실시간 데이터 변경을 다루지 못하는 시간 기반 지표가 아닌 동적으로 만들어낼 수 있습니다. 정적 콘텐츠의 이 온디맨드 재구성 유형은 중요한 데이터를 가진 웹사이트에 필수적입니다.\n\n전형적인 예로 전자 상거래 사이트를 들 수 있습니다. 하루 종일 잘리지 않는 상품 데이터의 대부분은 변경되지 않지만, 뒷면에서는 제품 매니저가 여러 가지 이유로 다양한 제품 풀에서 설명, 제목 및 카테고리를 편집할 수 있습니다. 그들은 당신(개발자)이 이러한 변경 사항을 빠르게 인식하는 사이트를 만들도록 요구합니다, 특히 위험 요인이 높은 상황에서.\n\n시카고 기반의 휴일 전자 상거래 사이트이며 여러 공급 업체의 제품을 제공합니다. 구운 과자, 의상, 크리스마스 트리 등 신선하게 수확한 지역 유기농 코벗 홀리 홀리 리스를 판매합니다. 비즈니스는 번창하고 분당 수십 명의 고객이 사이트에서 제품을 둘러보고 아름다운 홀리 홀리 리스를 신속하게 구매합니다. 휴일 정신이 가득한 상황입니다. 그러나 홀리 홀리 리스에 신선하게 꽃을 포함하는 지역 공급 업체 중 한 명이 실제로는 홀리 홀리 리스에 약속한 제품을 보내지 않을 것이라고 알려주기 위해 당신에게 전화를 걸어옵니다.\n\n그는 매우 사과하며 전액 환불을 약속하지만 여전히 문제가 발생합니다. 그 홀리 홀리 리스는 여전히 당신의 사이트에 있으며, 시카고 사용자들에게 지역 무기화로 유기농 신선한 꽃이 들어가 있습니다. 이미 여러 사용자의 장바구니에 들어가 있습니다(하지만 이 부분은 고객 서비스에 넘기죠). 지금 이 혼란을 막아야 합니다. 새로운 지역 공급 업체를 발견했습니다. 꽃을 사용하지만 유기농 제품은 아니며 홀리만 유기농입니다. od-ISR이 이 문제를 어떻게 완화하는지 알아봅시다.\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-22-DeliverNewContentFasterOnDemandISR_8.png)\n\nod-ISR에서, Next는 모든 페이지를 빌드 시간에 생성합니다 (1). CMS 및/또는 API로부터 데이터를 전달받아 이러한 페이지를 작성하는 이전 화살표는 생략했지만, 이러한 호출은 여전히 빌드 시간에 발생합니다. 우리의 매혹적인 이야기를 계속해 봅시다. 어느 날 밤, 서둘러 콘텐츠 제작자나 제품 관리자가 올해 가장 바쁜 판매일 전에 네 시간 전에 전화를 받고 성수기 활동(편집, 설명, 이미지 및 기타 데이터)를 즉시 CMS에서 수정해야 한다는 전화를 받는 상황이 벌어집니다. 홀리 리스 태그를. 가까이 있는 하인드만 충실한 콘텐츠 제작자는 그런 일을 합니다 (2). CMS는 데이터 풀의 변경 사항에 대해 특정 조치를 실행하는 웹훅으로 구성되어 있습니다. 이 경우, 인증을 위해 숨은 토큰을 전달하기 위해 Next 웹 서버에 요청을 보냅니다 (3). 이것은 대신 내부 회사 서버나 기계를 사용하여 수행할 수 있으며, 여기서는 API라고 부르고 클라이언트 측 상호 작용을 위해 무균형적으로 재사용할 수 있게 했습니다 (4). Next는 즉시 데이터 변경에 영향을 받는 지정된 페이지 또는 페이지를 재구축합니다 (5). 이제 새 홀리 리스 페이지를 얻었습니다.\n\n![이미지](/assets/img/2024-06-22-DeliverNewContentFasterOnDemandISR_9.png)\n\n그런데, CDN이 잘못된 정보를 표시하는 홀리 리스가 있는 냅을 즉시 제공 대신, 그 구식이라고 하는 위험 콘텐트를 제공해버릴 때 어떻게 해야 할까요? 이 아키텍처에서 가장 어려운 부분입니다. 많은 CDN은 캐시의 일부 또는 전체를 무효화하거나 지우는 기능을 제공하므로, CDN이 즉시 구식 페이지를 제공하는 대신 오리진 서버로 반환하도록 강제합니다 (12). 때로는 이 기능이 GUI에 기반하거나 콘솔을 통해 수행되기도 하며 때로는 API를 통해 프로그래밍적으로 제공됩니다. 일반적으로 질문하는 CDN에 특정하며, 특정 CDN을 사용하는 개발자들은 임시방편을 활용하고 있습니다. 위의 개발팀이 CDN을 무효화하는 방법을 갖고 있다고 가정합시다, 이는 이 문서의 범위를 벗어난 것입니다. 클라이언트가 CDN에 요청을 보내면 (8), 오리진 서버로 돌아가 (6) 신선한 페이지를 응답하고 (7) 사용자에게 반환되며 (9) 다시 한번 CDN에 캐시됩니다 (표시되지 않음). 다시 말해, 이러한 유형의 아키텍처는 클라이언트 측 JavaScript에서 한 개 이상의 API나 서비스로 추가 CRUD 요청을 만드는 것을 배척하지 않습니다 (10, 11).\n\n<div class=\"content-ad\"></div>\n\n여기서 우리는 stale-while-revalidate ISR 콘텐츠 생성의 시간 기반 지표에서 상당한 개선을 볼 수 있습니다. 여기서 콘텐츠는 요청에 따라 업데이트됩니다. 사용자가 방문하지 않아도 페이지가 ‘너무 오래된’ 상태가 되지 않을 것입니다. 대신 콘텐츠 생성자와 제품 관리자가 CMS나 데이터베이스를 업데이트하면 해당 콘텐츠는 요청을 받은 후 Next에 의해 다시 생성됩니다. 이는 웹훅이나 간단한 HTTP 요청을 통해 매개될 수 있으며 (Next의 경우) 비밀 토큰의 포함으로 인증됩니다. 페이지 재생성은 더 이상 사용자 상호작용을 통해 이루어지지 않습니다.\n\n이 재생성은 여전히 즉각적이지 않다는 점을 강조해야 합니다. 심지어 한 페이지의 재생성에도 시간이 걸릴 수 있습니다. 하나의 제품을 변경하는 것은 웹사이트 구조에 따라 여러 페이지의 재생성이 필요할 수 있습니다. Next는 요청을 받고 페이지를 재구성하고 CDN을 무효화할 수 있으며, 이 작업이 GUI를 통해 수동으로 이루어지지 않을 경우입니다. 그 동안 사용자는 여전히 오래된 콘텐츠를 받게 될 것입니다. 실제로, 적절하게 설계된 애플리케이션에서 이러한 변경 사항은 캐시된 콘텐츠가 만료되기를 기다릴 수 없는 빈번한 데이터 변경을 필요로 하는 동적 웹사이트의 요구를 충족시키기에 충분히 빠를 것으로 예상됩니다.\n\n우리 탐험이 시작될 때로 돌아가보면, 다양한 사용 사례에 대해 다른 렌더링 방법 대비 od-ISR이 상당한 개선임이 명백합니다. 대규모 전자상거래 사이트는 CSR만 있는 아키텍처에서 느린 로딩 속도를 겪을 것입니다. 서버에 추가된 계산 성능이 있더라도, 하나의 페이지가 여러 API 및 CMS로부터 데이터를 요구할 가능성이 높아 여전히 SSR 기반 아키텍처로 인해 더 긴 로드 시간이 필요할 수 있습니다.\n\n게다가 제품이 자주 변경되지 않는 페이지에서는, 동일한 페이지를 사용자 요청마다 서버에서 반복해서 다시 렌더링하는 비효율성이 이 사이트에 이상적이지 않습니다. SSG는 사이트에 작은 변경 사항을 위해 전체 재구성이 필요하며, 수천 개 제품을 보유한 비즈니스는 단일 페이지나 심지어 한 줄의 변경에 대해 엄청난 재생성 시간을 겪게 될 것입니다. od-ISR은 자주 변하는 내용을 필요로 하는 사이트에 이상적이지만 변경 사항을 최대한 빨리 반영해야 하는 사이트에는 적합하지 않습니다. od-ISR은 온디맨드 변경의 이점과 정적으로 생성된 콘텐츠에 대상 페이지 재생성을 결합하여, 높은 리스크, 동적이고 빈번하게 변경되는 데이터를 보유한 비즈니스에 완벽하게 적합합니다.\n\n<div class=\"content-ad\"></div>\n\n지금 시점에서 Next는 온디맨드 증분 정적 재생성을 제공합니다. Vue 기반의 Nuxt는 ISR을 제공하지만 Next와 같이 온디맨드 페이지 재구성은 아직 제공하지 않습니다. 그러나 수많은 Github 이슈 티켓과 응답에 따르면 해당 기능은 준비 중에 있습니다! Next에서 od-ISR에 대해 더 알고 싶다면 여기에서 문서를 확인해보세요.\n\n# Stackademic\n\n끝까지 읽어주셔서 감사합니다. 그 전에:\n\n- 작가를 추천하고 팔로우해주시는 걸 고려해주세요! 👏\n- 트위터(X), 링크드인, YouTube에서 우리를 팔로우해주세요.\n- Stackademic.com을 방문하여 전 세계에서 무료 프로그래밍 교육을 민주화하는 방법에 대해 더 많이 알아보세요.","ogImage":{"url":"/assets/img/2024-06-22-DeliverNewContentFasterOnDemandISR_0.png"},"coverImage":"/assets/img/2024-06-22-DeliverNewContentFasterOnDemandISR_0.png","tag":["Tech"],"readingTime":11},{"title":"최고의 미니멀리스트 UI 디자인 아이디어  vol 165","description":"","date":"2024-06-22 04:21","slug":"2024-06-22-UIDesignIdeasHigh-qualityMinimalistvol165","content":"\n\n## 고품질이고 미니멀한 UI/UX 디자인을 살펴보세요. 섬세하고 프리미엄한 빌드로 눈에 띄는 디자인들입니다. 이 작품들은 최고의 사용자 경험 디자인 에이전시에서 나온 것으로, 미니멀리즘에 초점을 맞추고 있습니다.\n\n## 오루클 아이덴티티\n\n👨‍🎨 줄리아 드미트리에브나\n👥 기엑스 아트\n\n## 나이키 AF1 웹사이트 컨셉\n\n<div class=\"content-ad\"></div>\n\n👨‍🎨 마리우스 미트코\n\n## 스킬젯 UI-UX\n\n👨‍🎨 파힘 샤리아르\n\n[이미지](/assets/img/2024-06-22-UIDesignIdeasHigh-qualityMinimalistvol165_0.png)\n\n<div class=\"content-ad\"></div>\n\n이 그림에서 소개된 인터페이스는 심플하면서도 고품질의 UX 디자인을 자랑합니다.\n\n생동감 넘치는 녹색 강조와 어두운 컬러 팔레트의 사용은 활성 강좌와 사용자 진행 상황 등 핵심 기능에 효과적으로 관심을 끌어줍니다.\n\n나침반은 잘 구성된 모듈과 명확하고 간결한 텍스트로 간결하게 유지되어, 사용자를 압도하지 않으면서 직관적인 사용자 경험을 촉진합니다. 이 디자인은 미적 매력과 실용적 사용성 사이의 균형을 이룹니다.\n\n## Vision Pro Duolingo — 공간 디자인 월의 4번째 날\n\n<div class=\"content-ad\"></div>\n\n👨‍🎨 안드레아스 크루새킨-리보스카\n\n이 교육 앱 인터페이스는 간결함과 기능성을 조화롭게 결합하여 미니멀리스트 UX 디자인 원칙을 보여줍니다.\n\n깔끔한 레이아웃, 어조가 점잖은 색 구성 및 직관적인 아이코노그래피는 빠른 학습과 사용자 유지에 도움이 됩니다.\n\n현저하게 식별하기 쉬운 이미지와 간결한 텍스트가 사용자의 집중이 분산되지 않도록 보장하여 전체 사용자 참여도와 효과를 향상시킵니다.\n\n<div class=\"content-ad\"></div>\n\n## Roomeet Virtual Workspace\n\n👨‍🎨 Brolis  \n👥 Odama  \n\n![Image](https://miro.medium.com/v2/resize:fit:1400/1*OZFee7rd_ns8gVQhy7hBCA.gif)\n\nThis virtual office application combines high-quality visuals with minimalist UX principles effectively.\n\n<div class=\"content-ad\"></div>\n\n이는 가상 공간을 구성하고 시각화하기 위해 3D 퍼스펙티브를 활용하여 공간 인식을 향상시키고 혼잡함 없이 시각적으로 표현합니다.\n\n간소화된 내비게이션 요소와 명확하고 집중된 아바타를 통해 사용자가 쉽게 상호 작용하고 레이아웃 복잡성보다는 커뮤니케이션에 집중할 수 있도록 지원하여 깔끔하고 매력적인 사용자 경험을 제공합니다.\n\n## 제품 페이지 전자상거래\n\n👨‍🎨 Anton Shmatko\n\n<div class=\"content-ad\"></div>\n\n\n![Mobile app design](https://miro.medium.com/v2/resize:fit:1400/1*-x1OZFSA7_GO-48ocKz0EA.gif)\n\nThis mobile app design for a product catalog demonstrates a high-quality, minimalist approach by employing a dark theme with high contrast text and vibrant product images, which enhance readability and visual appeal.\n\nInterface layout is clean, with essential information like price and ratings immediately visible, fostering an efficient browsing experience.\n\nSegmented control for product categories at the top provides an easy filter method, streamlining user interaction and access to desired products.\n\n\n<div class=\"content-ad\"></div>\n\n## 은행\n\n👨‍🎨 Slava Kornilov\n👥 Geex Arts\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*3X4yU0hAAgB7wdwtkena_w.gif)\n\n이 예산 관리 앱의 디자인은 고품질이며 미니멀한 UX를 보여주며 선명한 색상 사용과 깔끔한 타이포그래피로 중요한 숫자와 통찰이 효과적으로 돋보이도록합니다.\n\n<div class=\"content-ad\"></div>\n\n과도하게 큰 원을 사용한 그래픽 디스플레이는 시선을 사로 잡아 복잡한 데이터를 손쉽게 이해하기 쉬운 형식으로 단순화합니다.\n\n전반적으로, 이 인터페이스는 사용자를 압도하지 않으면서 중요한 정보를 우선적으로 표시하여 재무 관리에 유용하고 사용자 친화적인 환경을 조성합니다.\n\n## 메뉴 상호작용\n\n👨‍🎨 Filip Legierski\n👥 Riotters\n\n<div class=\"content-ad\"></div>\n\n\n![img](https://miro.medium.com/v2/resize:fit:1400/1*N6w2jPdVy9FH8E6Pgp6KmQ.gif)\n\n이 앱의 메뉴 디자인은 어두운 테마와 대비 있는 버튼 색상을 활용하여 미니멀한 사용자 경험 원칙을 대변합니다. 이로써 사용자가 주요 액션에 집중할 수 있습니다.\n\n레이아웃은 깔끔하고 간단하여 시각적 혼란 없이 명확히 옵션을 구분하여 탐색의 용이성을 촉진합니다.\n\n넉넉한 간격과 큰 타이포그래피의 활용은 접근성과 상호 작용의 편의성을 보장하여 뛰어난 사용자 경험을 제공합니다.\n\n\n<div class=\"content-ad\"></div>\n\n## 부동산 웹사이트 모바일 페이지\n\n👨‍🎨 Farzan Faruk\n👥 Rylic Studio\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*FMNgPUJLTTljoD138zTqqw.gif)\n\n“Hoomie” 앱의 디자인은 밝고 매력적인 색 구성을 활용하여 고객 지원 및 부동산 검색과 같은 주요 기능을 효과적으로 강조하여 즉시 접근할 수 있도록 합니다.\n\n<div class=\"content-ad\"></div>\n\n레이아웃은 사용자 친화적이며 큰 명확한 타이포그래피와 생생한 관련 이미지를 활용하여 직관적인 탐색 경험을 보장합니다.\n\n각 화면은 사용자가 압도당하지 않으면서 사용자 참여를 촉진하도록 신중하게 구조화되어 있습니다. 또한 주요 기능과 사용 편의성에 중점을 두어 미니멀한 UX 디자인 원칙과 잘 조화를 이룹니다.\n\n## Out of Dark — 고객 여정\n\n👨‍🎨 Martin Strba\n👥 Outloud\n\n<div class=\"content-ad\"></div>\n\n## Banksad — 금융 모바일 앱 UI 키트\n\n👨‍🎨 Caraka UI 키트  \n👥 Caraka  \n\n![Bankasd](/assets/img/2024-06-22-UIDesignIdeasHigh-qualityMinimalistvol165_1.png)  \n\n“Banksad” 금융 앱 UI 키트는 심플하고 깔끔한 디자인을 자랑하며, 여백을 효과적으로 활용하고 키포인트인 최근 거래 내역 및 계좌 잔액을 강조하기 위해 몽드톤 팔레트와 전략적으로 사용된 컬러 하이라이트를 적용했습니다.\n\n<div class=\"content-ad\"></div>\n\n디자인 시스템이 일관되고 계층이 정리되며 사용자 경로가 명확히 정의되어 있어 사용자 경험이 원활합니다. 네비게이션과 사용자 정의 옵션의 편리함으로부터 명백히 확인할 수 있습니다.\n\n이 UI 키트는 명확성과 사용자 친화적 인터페이스에 중점을 둔 현대적인 디자인 원칙을 보여줍니다.\n\n## 비전 프로 박물관 - 공간 디자인 달의 5 번째 날\n\n👨‍🎨 안드레아스 크루자킨 리보스카\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-22-UIDesignIdeasHigh-qualityMinimalistvol165_2.png)\n\n이 앱 디자인은 증강 현실을 효과적으로 활용하여 박물관 환경에서 시선을 끄는 뷰잉 경험을 향상시키며, 반 고흐의 \"해바라기\"를 인터랙티브하고 정보적인 오버레이로 강조합니다.\n\n깔끔한 선, 절제된 색상 팔레트, 직선적인 타이포그래피와 같은 미니멀리즘 디자인 요소의 사용은 사용자가 산물과 관련 디테일에 집중할 수 있도록 하여 산물을 즐기고 방해되지 않도록 합니다.\n\n이 접근 방식은 미술 작품의 시각적 중요성을 존중할 뿐 아니라, 인터페이스가 사용자 친화적이고 교육적인 것을 보장하여 방문자 참여와 학습을 증진합니다.\n\n\n<div class=\"content-ad\"></div>\n\n## 벤토 그리드\n\n👨‍🎨 Levi Wilson\n👥 QClay\n\n![Image](https://miro.medium.com/v2/resize:fit:1400/1*-EFO3D0xuGmi2KfNgHKwpw.gif)\n\n제품 기능을 소개하는 이 슬라이드 프레젠테이션은 명확한 미니멀한 디자인을 보여주며 일관된 색상 구성으로 가독성을 높이고 중요 요소에 집중할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n번호가 매겨진 섹션과 명확한 시각 자료는 서로 다른 제품 특징을 쉽게 이해하고 비교할 수 있도록 돕습니다.\n\n이 방식은 복잡한 정보를 효율적으로 전달하여 사용자들이 제시된 AI 기술의 능력과 장점을 빠르게 이해할 수 있도록 합니다.\n\n## 혁신적인 UI로 미래의 우유 배송을 경험해보세요\n\n👨‍🎨 aPurple\n\n<div class=\"content-ad\"></div>\n\n\n![RouteMilk](https://miro.medium.com/v2/resize:fit:1400/1*q9FM_RX5I5MpWQdfKYB_LQ.gif)\n\n\"RouteMilk\" 앱의 인터페이스는 고품질이며 심플한 UX 디자인을 보여주며 부드럽고 중립적인 색상 팔레트를 강조하여 접근성과 탐색의 용이성을 강조합니다.\n\n제품 카테고리, 상세 설명, 명확한 가격과 같은 주요 요소들은 잘 조직되어 사용자 친화적인 쇼핑 경험을 보장합니다.\n\n시각적 요소들은 깔끔하고 매력적이며, 기능성을 희생하지 않고 앱의 미적인 요소를 강화합니다. 이 디자인은 심플함과 쇼핑 앱의 포괄적인 요구 사항 사이에 스마트하게 균형을 맞춥니다.\n","ogImage":{"url":"/assets/img/2024-06-22-UIDesignIdeasHigh-qualityMinimalistvol165_0.png"},"coverImage":"/assets/img/2024-06-22-UIDesignIdeasHigh-qualityMinimalistvol165_0.png","tag":["Tech"],"readingTime":6}],"page":"7","totalPageCount":29,"totalPageGroupCount":2,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}