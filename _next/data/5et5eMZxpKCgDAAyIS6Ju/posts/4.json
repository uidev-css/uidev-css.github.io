{"pageProps":{"posts":[{"title":"Keystore를 사용하여 Flutter 앱 서명하는 방법","description":"","date":"2024-06-23 14:57","slug":"2024-06-23-SigningyourflutterappwithKeystore","content":"\n\n파이널?에서 플러터는 기본적으로 앱이 디버그 키스토어로 서명됩니다. 이를 디버그 키스토어라고 합니다. 이 키스토어는 기본적으로 다음 위치에 있습니다.\n\nC:\\Users\\LENOVO\\.android\\debug.keystore\n\n기본/default SHA-1 및 다른 서명을 (C:\\Users\\LENOVO\\.android\\debug.keystore)에서 가져오려면\n\n- 터미널 또는 명령 프롬프트를 엽니다.\n- Flutter 프로젝트의 `android` 디렉터리로 이동합니다.\n- 다음 명령을 실행하여 SHA-1 지문을 가져옵니다:\n```bash\n…..\\android` ./gradlew signingReport\n```\n\n<div class=\"content-ad\"></div>\n\n위의 코드에서 SHA-1과 다른 지문을 찾아보세요.\n\n![이미지](/assets/img/2024-06-23-SigningyourflutterappwithKeystore_0.png)\n\n이 SHA-1 및 다른 키는 PC마다 항상 같습니다. 이 서명 키는 주로 디버깅 용도로만 사용할 것입니다.\n\n예를 들어 Firebase에서 Google 기능에 로그인하기 위해 SHA-1 키가 필요한 경우가 있습니다. 앱이 개발 중인 동안 기본 서명을 Firebase에 추가할 수 있습니다. 동일한 앱에 여러 명의 개발자가 있을 수 있기 때문에 모든 앱이 Firebase 기능에 액세스해야 하므로 각 개발자가 생성한 여러 개의 SHA-1 키를 Firebase에 추가해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n# 키스토어의 적절한 관리 및 사용\n\n다음 단계에서는 키스토어를 사용하여 APK에 서명하여 앱을 배포하는 방법 및 기타 여러 용도에 적절하게 논의할 것입니다.\n\nAPK에 서명하려면 signingConfigs에서 코드를 작성해야 합니다.\n\n이것이 디버그 APK 및 프로덕션 APK용 app\\build.gradle에서 signingConfigs를 설정하는 방법입니다.\n\n<div class=\"content-ad\"></div>\n\n참고: 디버그 APK에 서명할 필요가 없습니다. 그것은 자체적으로 진행되며 아무것도 손대지 않아도 됩니다. 여기서 디버그 APK에 서명하는 것은 학습 목적으로 진행됩니다.\n\n- 자체 디버그용 및 제품용 키스토어(1개씩 총 2개)를 생성하세요.\n\n![image](/assets/img/2024-06-23-SigningyourflutterappwithKeystore_1.png)\n\n키툴(`keytool`) 유틸리티를 사용하여 자바 개발 키트(JDK)에 함께 제공되는 만큼 많은 수의 키스토어를 생성할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\na. 터미널이나 명령 프롬프트를 열고 다음 명령을 실행하세요:\n\n```bash\nkeytool -genkeypair -v -keystore your_keystore_name.keystore -alias your_alias_name -keyalg RSA -keysize 2048 -validity 10000\n```\n\nb. 정보 입력:\n\n이름, 조직 및 위치와 같은 정보를 입력하라는 메시지가 표시됩니다. 필수 정보를 입력해주세요.\n\n<div class=\"content-ad\"></div>\n\nc. 비밀번호 설정:\n키스토어 및 키 쌍에 대한 비밀번호를 설정하라는 프롬프트가 표시됩니다. 나중에 이 비밀번호가 필요하므로 기억해 두세요.\n\n2. 키스토어 이동:\n생성된 키스토어 파일을 프로젝트 디렉토리의 안전하고 접근 가능한 위치로 이동하세요. 보안상의 이유로 프로젝트의 버전 관리 시스템 외부에 보관하는 것이 좋은 관행입니다.\n\n![이미지](/assets/img/2024-06-23-SigningyourflutterappwithKeystore_2.png)\n\n3. key.properties 파일 생성하기:\n\n<div class=\"content-ad\"></div>\n\n안녕하세요! `android` 폴더 안에 `key.properties` 파일을 추가해주세요.\n\n기억해주세요: `storePassword`와 `keyPassword`는 앞에서 입력한 비밀번호와 동일하니 `storePassword`는 항상 `keyPassword`와 동일할 겁니다. 그리고 `keyAlias`는 앞에서 입력한 `your_alias_name`과 동일해야 합니다.\n\n<img src=\"/assets/img/2024-06-23-SigningyourflutterappwithKeystore_3.png\" />\n\n4. app/build.gradle 안의 `signingConfig`를 사용하여 APK에 서명하기\n\n<div class=\"content-ad\"></div>\n\n\n![이미지1](/assets/img/2024-06-23-SigningyourflutterappwithKeystore_4.png)\n\n![이미지2](/assets/img/2024-06-23-SigningyourflutterappwithKeystore_5.png)\n\n프로덕션 APK의 SHA-1 키를 생성하려면 아래 단계를 따르세요.\n\n1. Keystore 파일 찾기: 먼저, 앱을 위해 생성한 릴리스 keystore 파일을 찾으세요. 이 파일은 일반적으로 .jks 또는 .keystore 확장자를 가지고 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n2. SHA-1 키 생성: SHA-1 키를 생성하려면 Java 개발 킷(JDK)과 함께 제공되는 keytool 명령줄 유틸리티를 사용할 수 있습니다. 터미널이나 명령 프롬프트를 열고 keystore 파일이 있는 디렉토리로 이동하세요.\n\n3. keytool 명령 실행: 다음 명령을 사용하여 SHA-1 키를 생성하세요:\n\n```js\nkeytool -list -v -keystore your_keystore_filename.jks -alias your_alias_name\n```\n\nyour_keystore_filename.jks를 사용자의 keystore 파일 이름으로, your_alias_name을 keystore를 생성할 때 사용한 별칭으로 대체하세요(별칭을 지정하지 않았다면, 디버그 keystore에는 androiddebugkey를 사용하거나 릴리스 keystore 생성 시 사용한 별칭을 사용하세요).\n\n<div class=\"content-ad\"></div>\n\n4. **Keystore 비밀번호 입력:** Keystore 비밀번호를 입력하라는 메시지가 표시됩니다. Keystore를 생성할 때 사용한 비밀번호를 입력하세요.\n\n5. **SHA-1 키 가져오기:** 비밀번호를 입력한 후에는 도구가 Keystore에 대한 여러 정보를 표시합니다. 이 중 'SHA-1 key'를 찾아보세요. 'Certificate fingerprints' 섹션 하단에 있는 SHA1 항목을 확인해보세요.\n\n6. **Firebase에 SHA-1 키 추가하기:**\n\n![이미지](/assets/img/2024-06-23-SigningyourflutterappwithKeystore_6.png)\n\n<div class=\"content-ad\"></div>\n\nSHA-1 키를 복사하여 Firebase 콘솔에 프로젝트를 추가해 주세요.\n\nFirebase 프로젝트로 이동하시고, \"Project Overview\" 근처에 있는 설정 아이콘을 클릭한 후 \"프로젝트 설정\"을 클릭해주세요. 여기에서 SHA-1 키를 추가할 수 있습니다.\n\n플러터와 모바일 앱 개발에 대해 더 알고 싶다면 도움이 될 겁니다.","ogImage":{"url":"/assets/img/2024-06-23-SigningyourflutterappwithKeystore_0.png"},"coverImage":"/assets/img/2024-06-23-SigningyourflutterappwithKeystore_0.png","tag":["Tech"],"readingTime":4},{"title":"Flutter를 클라우드에 연결하는 방법 2024 최신 가이드","description":"","date":"2024-06-23 14:55","slug":"2024-06-23-FluttertoCloud","content":"\n\n# 소개\n\n본 문서 시리즈의 목표는 AWS Amplify를 사용하여 Flutter 모바일 애플리케이션을 개발하고 필요에 따라 다른 방법으로 전환할 수 있는 환경을 구축하는 것입니다. 이 과정에서 발생하는 모든 문제에 대해 다룰 것입니다.\n\n본 애플리케이션은 언어 학습용 간단한 플래시카드 애플리케이션이며, 개발하는 과정을 계속해서 업데이트할 예정입니다.\n\n본 시리즈는 실시간 여정으로, 각 단계를 문서화하고 직면한 도전과정 및 그에 따른 결정 사항을 기록할 것입니다. 구조는 프로젝트의 요구에 따라 발전할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n여기 이 시리즈에서 다룰 내용입니다:\n\n- 파트 1: 아키텍처\n- 파트 2: Flutter 및 Amplify 설정\n- 파트 3: GraphQL 스키마 정의\n- 파트 4: 인증 구현\n- 파트 5: 핵심 기능 개발\n- 파트 6: UI 개발 및 상태 관리\n- 파트 7: 추가 서비스 통합\n- 파트 8: 배포 및 모니터링\n- 파트 9: 대안 및 이전 이주 표 평가\n- 파트 10: 반성 및 향후 방향\n\n# 파트 1\n\n## 아키텍처\n\n<div class=\"content-ad\"></div>\n\n어떤 일을 하기 전에 먼저 해야 할 질문은 아키텍처에 관한 것입니다. 한쪽에서는 필요할 경우 클라우드 제공 업체를 변경할 유연성을 가지고 싶지만, 다른 한쪽에서는 BaaS가 내 요구사항을 충족시키지 못하는 경우, 최소한의 비용과 노력으로 나만의 백엔드를 구현할 수 있기를 원합니다. 이것은 제 첫 번째 BaaS 경험이며, 이 과정 중에 필요한 변경에 대비하고자 합니다. 이를 위해 간단한 플래시카드 앱을 만들 것입니다.\n\nClean Architecture는 소프트웨어 응용 프로그램에서 관심사 분리, 유지 관리 가능성 및 확장성을 보장하는 견고한 아키텍처 패턴입니다. 백엔드 개발자로서 이 아키텍처는 종종 올바른 선택입니다. 클린 아키텍처의 주요 아이디어는 로버트 C. 마틴이 “Clean Architecture” 책에서 쓴 것처럼, 비즈니스 규칙은 UI, 프레임워크, 데이터베이스 및 다른 외부 응용 프로그램과 쉽게 테스트할 수 있고 독립적이어야 한다는 것입니다.\n\n클린 아키텍처를 컨셉으로 경험을 쌓는 과정에서 헥사고널 아키텍처를 탐구했습니다 (Alistair Cockburn, “Hexagonal Architecture”, and Tom Hombergs, “Get Your Hands Dirty on Clean Architecture”). 이 아키텍처는 소프트웨어를 유연하게 만들고 개발 비용을 줄입니다. 그러나 작은 애플리케이션의 경우, 헥사고널 아키텍처가 과도하게 복잡할 수 있다는 것을 발견했습니다.\n\nFlutter로 새로운 모바일 애플리케이션을 시작할 때, 올바른 아키텍처와 코드 구조를 정의하는 것이 첫 번째 도전이었습니다. 모바일 애플리케이션을 위한 다양한 아키텍처와 디자인을 찾아보면 Model-View-Controller (MVC), Model-View-Presenter (MVP), Model-View-ViewModel (MVVM), Provider, Riverpod 및 Bloc과 같은 결과가 나오며, 각각 장단점이 있습니다.\n\n<div class=\"content-ad\"></div>\n\n목표는 깨끗한 아키텍처 개념을 따르는 구조를 찾는 것이었습니다. UI와 비즈니스 로직을 분리하고 BaaS 제공업체를 쉽게 교체하거나 사용자 지정 백엔드로 이전할 수 있도록 하는 것이 목표였습니다. 본 문서에서는 Flutter 애플리케이션에서 Clean Architecture를 Riverpod를 사용하여 구현한 내용을 다루며, 해당 방법이 어떤 이점을 제공하며 클라우드 제공자 간 또는 사용자 지정 백엔드로 전환하는 것을 간단하게 만드는 방법에 대해 살펴보겠습니다.\n\n다음 다이어그램에서 깨끗한 아키텍처의 주요 아이디어를 고려해 봅시다:\n\n핵심은 엔티티이며, 다른 종속성과 독립적입니다. 프레임워크, 데이터베이스, UI 등에서 최대한 분리되어 유연하고 테스트 가능한 소프트웨어를 개발할 수 있습니다.\n\n나는 육각형 아키텍처를 시도해 보기로 결정했지만, 소규모 애플리케이션에 대해 과도하게 설계된 것으로 간주될 수 있는 기업 앱이 아니기 때문에 곧 포기했습니다.\n\n<div class=\"content-ad\"></div>\n\n여러 가지 아키텍처 패턴을 고려하며, Clean Architecture와 일치하는 아키텍처를 찾고, UI와 비즈니스 로직을 분리하는 것뿐만 아니라 BaaS 접근 방식을 다른 제공 업체로 교체하거나 BaaS에서 클라우드의 백엔드로 쉽게 이동할 수 있도록 해줍니다.\n\n이 부분은 Riverpod를 상태 관리에 사용하는 Flutter 애플리케이션에서 Clean Architecture의 사용에 대해 설명합니다. 이 아키텍처의 장점을 살펴보고, 클라우드 제공 업체 간 전환이나 UI 레이어에 영향을 미치지 않고 사용자 정의 백엔드로 이동하는 것을 어떻게 간소화하는지 살펴볼 것입니다.\n\nClean Architecture로 진입하기 전에 다른 옵션을 간단히 살펴볼까요? 모바일 애플리케이션을 위한 아키텍처를 찾다 보면 다양한 용어가 등장합니다.\n\n주로 Model–view–controller, Model-view-Presenter, MVVM, Provider, Riverpod, Bloc이 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 모델 뷰 컨트롤러\n\nMVC는 응용 프로그램을 세 가지 주요 구성 요소로 분리합니다:\n\n모델: 응용 프로그램의 데이터와 비즈니스 로직을 나타냅니다.\n뷰: UI 구성 요소와 프레젠테이션 로직을 나타냅니다.\n컨트롤러: 모델과 뷰 사이의 중개자 역할을 하며 사용자 입력을 처리하고 둘 다 업데이트합니다.\n\n![image](/assets/img/2024-06-23-FluttertoCloud_0.png)\n\n<div class=\"content-ad\"></div>\n\n뷰와 로직을 분리하는 데 장점이 있지만, 일부 구현에서 컨트롤러가 뷰와 긴밀하게 결합되어 수정 또는 교체하기 어려워질 수 있습니다. 대부분의 핵심 비즈니스 로직은 컨트롤러에 있기 때문에 파일이 커져서 코드를 유지보수하기 힘들어지는 문제가 발생할 수 있습니다.\n\n# 모델 뷰 프레젠터\n\nMVP는 MVC의 문제를 해결하기 위해 나왔습니다. 세 가지 부분으로 구성되어 있습니다:\n모델: 도메인 로직, 데이터베이스 및 네트워크 통신을 처리합니다.\n뷰: UI 및 사용자 작업을 관리합니다.\n프레젠터: 모델에서 데이터를 가져와 UI 로직을 적용하고 뷰 상태를 관리합니다.\n\n이는 더 나은 모듈성을 제공하며 프로젝트 코드를 보다 쉽게 구조화하고 유닛 테스트 능력을 향상시킵니다.\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-23-FluttertoCloud_1.png)\n\n# Model View ViewModel\n\nMVVM은 다음 구성 요소를 갖추고 있습니다:\n\nModel: 데이터 소스를 추상화하고 ViewModel과 함께 데이터 작업을 처리합니다.\n\nView: ViewModel을 관찰하고 비즈니스 로직을 포함하지 않고 사용자 작업을 알립니다.\n\nViewModel: Model과 View를 연결하여 관련 데이터 스트림을 View에 노출합니다.\n\n<div class=\"content-ad\"></div>\n\nMPV와 비교하여 MVVM은 다음과 같은 점들이 개선되었습니다:\n\n- Tight Coupling Issue: MVVM은 UI와 비즈니스 로직 간의 강한 결합을 줄여 업데이트와 유지보수를 쉽게 할 수 있습니다.\n- 향상된 테스트 용이성: MVVM은 Android SDK 구성 요소에 대한 의존성을 최소화하여 단위 테스트를 더 간편하게 만들어줍니다.\n- 관심사의 분리가 더 잘 이루어집니다: MVVM은 데이터 표현 로직과 핵심 비즈니스 로직을 더 명확하게 분리하여 더 조직적이고 유지보수가 쉬운 코드베이스를 제공합니다.\n\n![사진](/assets/img/2024-06-23-FluttertoCloud_2.png)\n\n더 자세한 비교는 https://www.geeksforgeeks.org/difference-between-mvp-and-mvvm-architecture-pattern-in-android/에서 확인할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# BLOC 구조\n\nBLOC은 MVVM과 많은 유사성을 가지고 있지만 ViewModel은 Bloc으로 대체됩니다. BLOC에서 상태를 관리하는 핵심 메커니즘은 스트림 또는 반응형 접근 방식의 사용입니다. 기본적으로 데이터는 BLOC과 UI 사이를 스트림으로 흐릅니다.\n\n이는 데이터가 BLOC에서 UI로 지속적으로 전송되고, UI에서 다시 BLOC으로 돌아가는 것을 의미하며, 상태가 효율적이고 일관되게 관리되도록 보장합니다.\n\n![이미지](/assets/img/2024-06-23-FluttertoCloud_3.png)\n\n<div class=\"content-ad\"></div>\n\n# 클린 아키텍처 개요\n\n클린 아키텍처는 응용 프로그램을 다음과 같이 명확하게 계층으로 나눕니다:\n\n- 프리젠테이션 계층: UI 및 사용자 상호작용을 관리합니다.\n- 응용 계층: 비즈니스 로직과 서비스를 포함합니다.\n- 도메인 계층: 핵심 비즈니스 모델과 로직을 정의합니다.\n- 데이터 계층: 데이터 검색 및 지속성을 처리합니다.\n\n각 계층은 특정한 책임을 가지며 다른 계층과 명확한 인터페이스를 통해 통신하여 관심사의 명확한 분리를 보장합니다.\n\n<div class=\"content-ad\"></div>\n\n# 깨끗한 아키텍처의 장점\n\n- 관심사 분리\n각 계층은 애플리케이션의 특정 측면에 집중하여 단일 책임을 촉진합니다:\n\n- 프레젠테이션 계층: 사용자 인터페이스 및 상호 작용 로직을 관리합니다.\n- 응용 계층: 애플리케이션별 비즈니스 규칙을 관리합니다.\n- 도메인 계층: 핵심 비즈니스 로직 및 엔티티를 포함합니다.\n- 데이터 계층: 데이터 원본 및 저장소를 관리합니다.\n\n이러한 분리로 코드베이스를 이해, 테스트 및 유지보수하기 쉬워집니다.\n\n<div class=\"content-ad\"></div>\n\n2. 확장성\n\n시스템 구조는 확장이 가능하여, 새로운 기능을 추가할 때 기존 코드에 최소한의 영향을 미치게 합니다. 각 계층은 독립적으로 개발 및 테스트할 수 있어 병렬 개발을 용이하게 합니다.\n\n3. 유지보수성\n\n각 계층 사이에 명확한 경계가 존재함으로써 코드베이스를 유지하고 업데이트하는 것이 간단해집니다. 각 계층은 다른 계층에 영향을 주지 않고 수정할 수 있어 새로운 기능을 도입하거나 버그를 수정하기가 더 쉬워집니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-23-FluttertoCloud_4.png\" />\n\n# 코드 구조 예시\n\n플래시 카드와 덱을 모델로 하는 예시에서 코드 구조는 다음과 같을 수 있습니다. 각 패키지는 Riverpod 구조의 하나의 레이어를 나타냅니다:\n\n```js\nib/\n|-- presentation/\n|   |-- widgets/\n|   |   |-- flashcard_widget.dart\n|   |   |-- deck_widget.dart\n|   |-- states/\n|   |   |-- flashcard_state.dart\n|   |   |-- deck_state.dart\n|   |-- controllers/\n|       |-- flashcard_controller.dart\n|       |-- deck_controller.dart\n|-- application/\n|   |-- services/\n|       |-- flashcard_service.dart\n|       |-- deck_service.dart\n|       |-- transformation_utils.dart\n|-- domain/\n|   |-- models/\n|       |-- flashcard.dart\n|       |-- deck.dart\n|       |-- domain_deck.dart\n|       |-- domain_flashcard.dart\n|       |-- ideck.dart\n|       |-- iflashcard.dart\n|       |-- model_provider.dart\n|-- data/\n|   |-- repositories/\n|   |   |-- flashcard_repository_impl.dart\n|   |   |-- deck_repository_impl.dart\n|   |   |-- ideck_repository.dart\n|   |   |-- iflashcard_repository.dart\n|   |   |-- mappers.dart\n|   |-- dtos/\n|   |   |-- flashcard_dto.dart\n|   |   |-- deck_dto.dart\n|   |-- data_sources/\n|       |-- deck_aws_data_source.dart\n|       |-- flashcard_aws_data_source.dart\n|-- amplifyconfiguration.dart\n|-- main.dart\n```\n\n<div class=\"content-ad\"></div>\n\n# 아키텍처 선언\n\n인터페이스와 구조 설명\n인터페이스와 계층 구조를 사용하면 아키텍처에 여러 가지 이점이 있습니다:\n\n- 추상화를 위한 인터페이스: 인터페이스(IDeck, IFlashcard, IDeckRepository, IFlashcardRepository)를 정의함으로써, 아키텍처는 구현 세부 정보를 비즈니스 로직과 분리합니다. 이를 통해 다른 구현을 동일한 인터페이스를 구현하여 상호 교환 가능하게 만들 수 있으며, 응용 프로그램의 나머지 부분에 영향을 미치지 않고 사용할 수 있습니다. 예를 들어, AWS Amplify를 다른 클라우드 제공 업체로 또는 사용자 지정 백엔드로 대체할 수 있습니다.\n\n2. 표시 계층: UI 구성 요소를 포함하며 사용자 상호 작용을 관리합니다. 이 계층은 데이터를 표시하고 사용자 작업을 응용 프로그램 계층으로 전달하는 것에만 책임이 있습니다.\n\n<div class=\"content-ad\"></div>\n\n3. Application Layer: 비즈니스 로직과 사용 사례를 포함하고 있습니다. 도메인 레이어와 상호 작용하여 데이터를 검색하고 조작한 후 표현 레이어를 업데이트합니다. UI와 비즈니스 로직을 분리함으로써 애플리케이션은 유지보수 가능하고 테스트 가능해집니다.\n\n4. Domain Layer: 핵심 비즈니스 모델과 로직을 정의합니다. 이러한 모델은 다른 레이어에 의존성이 없는 간단한 Dart 클래스들로 구성되어 있어 독립적이고 재사용 가능하도록 보장합니다. 도메인 레이어에는 데이터 레이어에서 구현된 저장소에 대한 인터페이스가 포함되어 있습니다.\n\n5. Data Layer: 데이터 검색 및 지속성을 관리합니다. 이 레이어에는 저장소 인터페이스의 구현이 포함되어 있으며, 이것들은 데이터 원본 (예: AWS Amplify)과 상호 작용합니다. 맵퍼를 사용하여 이 레이어는 도메인 모델과 데이터 전송 객체(DTO) 간에 데이터를 변환합니다.\n\n# Riverpod이 아키텍처에 미치는 영향\n\n<div class=\"content-ad\"></div>\n\nRiverpod은 Clean Architecture를 향상시키는 상태 관리 라이브러리로 다음을 제공합니다:\n\n- 확장성: 복잡한 사용 사례를 지원하며 전체 응용 프로그램에서 상태를 쉽게 관리합니다.\n- 테스트 용이성: Riverpod은 상태 관리의 쉬운 모의 및 테스트를 가능하게 합니다.\n- 유연성: UI 구성 요소에서 상태 관리를 분리하여 Clean Architecture의 원칙을 준수합니다.\n\nRiverpod을 사용하면 상태 관리 논리가 응용 프로그램 계층 내에 있어 관심사를 구분하고 표현 계층이 UI 관련 논리에 집중할 수 있습니다.\n\nBloc을 사용할 때 상태 변경은 데이터의 스트림으로 일관되게 표현됩니다. 반면에 Riverpod은 Streams, Futures, StateNotifiers, ChangeNotifiers를 비롯한 다양한 유형의 데이터를 감시할 수 있는 유연성을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n이 다양성은 Riverpod가 다른 상태 메커니즘을 매끄럽게 관리할 수 있도록 합니다.\n\n# 클라우드 제공 업체를 변경하거나 사용자 정의 백엔드로 이동하는 유연성\n\n이 깔끔한 아키텍처 접근 방식을 따르면, 다른 BaaS(Backend as a Service)를 다른 것으로 교체하거나 심지어 사용자 정의 백엔드로 마이그레이션하는 것이 쉬워집니다.\n\n이 아키텍처는 UI와 비즈니스 로직이 데이터 접근 레이어와 완전히 분리되어 있음을 보장합니다. 이 느슨한 결합은 마이그레이션 프로세스를 크게 용이하게 만듭니다.\n\n<div class=\"content-ad\"></div>\n\n기능 분리: 아키텍처는 프레젠테이션, 도메인 및 데이터와 같이 잘 정의된 인터페이스를 통해 통신하는 주요 레이어로 응용 프로그램을 분리합니다. 이 분리는 한 레이어의 변경이 다른 레이어에 영향을 미치지 않도록 보장합니다.\n\n느슨한 결합: 인터페이스와 의존성 주입 (우리의 경우 Riverpod 프로바이더를 통해)의 사용은 데이터 소스의 다양한 구현을 쉽게 교체할 수 있게 합니다. 예를 들어, AWS Amplify에서 사용자 정의 백엔드로 전환하는 경우 데이터 레이어에서만 변경이 필요합니다.\n\n유지 관리성: 데이터 액세스 로직을 비즈니스 로직 및 UI에서 격리시킴으로써 응용 프로그램을 더 유지 보수 가능하고 이해하기 쉽게 만듭니다. 각 레이어에는 특정 책임이 있어 변경 사항을 할 때 우발적인 부작용의 위험을 줄입니다.\n\n확장성: 이 아키텍처는 확장 가능하도록 설계되었습니다. 백엔드의 새로운 기능이나 변경 사항을 기존 코드베이스를 크게 수정하지 않고 수용할 수 있습니다. 이 확장성은 시간이 지남에 따라 다른 서비스와 통합해야 하는 진화하는 응용 프로그램에 필수적입니다.\n\n<div class=\"content-ad\"></div>\n\n다음에는 Flutter 및 Amplify를 설정한 다음 스키마를 정의할 것입니다.\n\n소스:\nhttps://codewithandrea.com/articles/flutter-app-architecture-riverpod-introduction/\nhttps://www.thenifemi.com/articles/ddd-series-part-2\nhttps://codewithandrea.com/articles/comparison-flutter-app-architectures/#comparison-with-bloc-architecture\nhttps://medium.com/@nikilapi/i-found-the-perfect-architecture-for-flutter-apps-59fc2dc8f00f\nhttps://github.com/Uuttssaavv/flutter-clean-architecture-riverpod\nhttps://codewithandrea.com/articles/flutter-presentation-layer/","ogImage":{"url":"/assets/img/2024-06-23-FluttertoCloud_0.png"},"coverImage":"/assets/img/2024-06-23-FluttertoCloud_0.png","tag":["Tech"],"readingTime":10},{"title":"Flutter 카드 위젯 완벽 가이드 고급 기능을 활용한 아름다운 카드 만들기 방법","description":"","date":"2024-06-23 14:54","slug":"2024-06-23-CompleteGuidetoCardWidgetinFlutterCreatingBeautifulCardswithAdvancedFeatures","content":"\n![Card Widget](/assets/img/2024-06-23-CompleteGuidetoCardWidgetinFlutterCreatingBeautifulCardswithAdvancedFeatures_0.png)\n\n플러터 프레임워크의 Card 위젯은 그림자와 둥근 모서리를 가진 표면을 만들 수 있어서 기사, 목록 및 다른 UI 섹션에 정보를 표시하는 데 적합합니다. 이 위젯에는 카드의 모양을 사용자 지정할 수 있는 다양한 속성이 있습니다.\n\n1. 자식 위젯 지정:\n   Card 위젯은 카드의 내용으로 작동하는 자식 위젯을 허용합니다. 다음 예제는 카드 안에 텍스트를 배치하는 방법을 보여줍니다:\n\n```js\nCard(\n  child: Text('This is a card'),\n)\n```\n\n<div class=\"content-ad\"></div>\n\n2. 색상 설정\n   `color` 속성을 사용하여 카드의 배경색을 변경할 수 있습니다. 아래 예시는 다채로운 카드를 표시합니다:\n\n```js\nCard(\n  color: Colors.blue,\n  child: Text('Colored Card'),\n)\n```\n\n# 3. 고도 증가\n\n`elevation` 속성은 카드의 그림자 높이를 제어합니다. 이 속성에 더 큰 값이 할당되면 더 높은 그림자가 생성됩니다. 아래는 고도가 증가된 카드 예시입니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nCard(\n  elevation: 8,\n  child: Text('Elevated Card'),\n)\n```\n\n# 4. 모양\n\n모양 속성을 사용하여 카드의 모서리 모양을 변경할 수 있습니다. 예를 들어, 모서리를 둥글게 만들 수 있습니다:\n\n```js\nCard(\n  shape: RoundedRectangleBorder(\n    borderRadius: BorderRadius.circular(15.0),\n  ),\n  child: Text('Rounded Corners Card'),\n)\n```\n\n<div class=\"content-ad\"></div>\n\n# 5. 여백\n\n카드의 여백은 margin 속성을 사용하여 설정할 수 있습니다:\n\n```js\nCard(\n  margin: EdgeInsets.all(16.0),\n  child: Text('여백 카드'),\n)\n```\n\n# 6. 전경 제어에 대한 테두리\n\n<div class=\"content-ad\"></div>\n\n`borderOnForeground` 속성을 사용하면 카드의 테두리가 전경에 배치되는지 여부를 제어할 수 있습니다:\n\n```js\nCard(\n  borderOnForeground: false,\n  child: Text('테두리가 전경에 표시되지 않는 카드'),\n)\n```\n\n# 7. 클립 동작\n\n`clipBehavior` 속성을 사용하면 카드 내부 콘텐츠가 어떻게 클립되는지 결정할 수 있습니다. 가능한 값으로 Clip.none, Clip.hardEdge 및 Clip.antiAlias가 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nCard(\n  clipBehavior: Clip.antiAlias,\n  child: Text('Anti-aliased Clip Card'),\n)\n```\n\n# 8. 시맨틱 컨테이너\n\n만약 이 속성이 true이면, 카드는 시맨틱 컨테이너로 정의되며, 그렇지 않으면 자식 요소의 의미론이 가장 가까운 둘러싸는 시맨틱 컨테이너와 병합됩니다.\n\n```js\nCard(\n  semanticContainer: true,\n  child: Text('Semantic Container Card'),\n)\n```\n\n<div class=\"content-ad\"></div>\n\n# 9. 그림자 색상\n\n그림자 색상을 설정하려면 shadowColor 속성을 사용할 수 있습니다:\n\n```js\nCard(\n  shadowColor: Colors.red,\n  child: Text('그림자 색상 카드'),\n)\n```\n\n# 10. 테두리 반지름\n\n<div class=\"content-ad\"></div>\n\nborderRadius 속성을 사용하여 카드의 모서리의 반지름을 설정할 수 있습니다.\n\n```js\nCard(\n  shape: RoundedRectangleBorder(\n    borderRadius: BorderRadius.circular(30.0),\n  ),\n  child: Text('사용자 정의 보더 반경 카드'),\n)\n```\n\n<img src=\"/assets/img/2024-06-23-CompleteGuidetoCardWidgetinFlutterCreatingBeautifulCardswithAdvancedFeatures_1.png\" />\n\n플러터의 Card 위젯의 다양한 기능을 활용하여, Material Design 표준에 부합하는 다양한 외관의 카드를 생성할 수 있습니다. 이러한 기능을 통해 시각적으로 매력적이며 이해하기 쉽고 직관적인 사용자 인터페이스를 만들 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-23-CompleteGuidetoCardWidgetinFlutterCreatingBeautifulCardswithAdvancedFeatures_0.png"},"coverImage":"/assets/img/2024-06-23-CompleteGuidetoCardWidgetinFlutterCreatingBeautifulCardswithAdvancedFeatures_0.png","tag":["Tech"],"readingTime":3},{"title":"Flutter 앱 테마 커스터마이즈 라이트와 다크 모드 전환 및 익스텐션 사용 방법","description":"","date":"2024-06-23 14:53","slug":"2024-06-23-CustomizeFlutterAppThemesSwappingBetweenLightDarkModesandUsingExtensions","content":"\n플러터는 테마 지원을 통해 개발자들이 다양한 테마 기능으로 애플리케이션을 사용자 정의할 수 있도록 훌륭한 지원을 제공합니다. 이 글에서는 두 가지 핵심 테마 기능에 중점을 두겠습니다:\n\nA) 다크 테마와 라이트 테마 간 전환하기.\n\nB) 테마 확장을 사용하여 추가 테마 데이터 클래스를 생성하여 더 많은 사용자 정의를 할 수 있습니다.\n\n完전한 작동하는 샘플 코드에 대한 접근은 동봉된 GitHub 저장소를 참조해주세요.\n\n<div class=\"content-ad\"></div>\n\n![image](/assets/img/2024-06-23-CustomizeFlutterAppThemesSwappingBetweenLightDarkModesandUsingExtensions_0.png)\n\n# 다크 테마와 라이트 테마 사이를 전환하세요\n\n다크 테마와 라이트 테마 사이를 전환하는 것은 다음 예시에서 알 수 있듯이 매우 간단합니다:\n\n```js\nreturn MaterialApp(\n  ...\n  themeMode: themeMode,\n  darkTheme: ThemeData.dark(),\n  theme: ThemeData.light(),\n  ...\n);\n```\n\n<div class=\"content-ad\"></div>\n\n이 세 가지 필드는 앱이 적용해야 하는 테마의 유형을 지정할 수 있습니다. 기본적으로 themeMode는 darkTheme 또는 theme을 사용할지를 결정합니다.\n\nThemeMode에는 세 가지 값이 있습니다:\n\n- ThemeMode.light: 앱에 밝은 테마를 사용하도록 지시합니다.\n- ThemeMode.dark: 앱에 어두운 테마를 사용하도록 지시합니다.\n- ThemeMode.system: 앱이 시스템의 테마와 일치하도록 지시합니다.\n\n애플리케이션의 테마를 동적으로 변경하려면 코드가 반응해야 합니다. 실제적이고 효율적인 방법은 변경 사항에 응답할 수 있는 상태를 App 위젯 위에 배치하는 것입니다. 이 상태는 원하는 방식으로 관리할 수 있습니다. 현재, 저는 애플리케이션의 상태 관리에 플러터 프로바이더를 사용하고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nreturn Solid(\n  providers: [\n    Provider<Signal<ThemeMode>>(create: () => Signal(ThemeMode.system)),\n  ],\n  builder: (context) {\n    final themeMode = context.observe<ThemeMode>();\n    return MaterialApp(\n      ...\n      themeMode: themeMode,\n      darkTheme: ThemeData.dark(),\n      theme: ThemeData.light(),\n      ...\n    );\n  },\n);\n```\n\n그 후, 애플리케이션 어디서든 메서드를 호출하여 프로바이더에게 값을 변경하도록 지시할 수 있습니다. 이는 애플리케이션을 그에 맞게 다시 빌드합니다:\n\n```js\ncontext.get<Signal<ThemeMode>>().value = newThemeMode;\n```\n\n앱이 시작할 때마다 ThemeMode를 저장하고 가져와서 사용자의 테마 선호도를 유지해야 합니다. 이렇게 하면 사용자의 선택사항이 기억되고 일관되게 적용됩니다.\n\n<div class=\"content-ad\"></div>\n\n# 테마 확장 사용하기\n\n다크 테마와 라이트 테마를 전환하는 것만으로도 좋지만, Flutter를 사용하면 테마 확장을 통해 더 많은 사용자 정의가 가능합니다. 테마 확장은 표준 ThemeData를 넘어 사용자 정의 속성과 스타일을 정의할 수 있게 해줍니다.\n\n다음은 ThemeExtension을 확장한 클래스의 일부 코드입니다:\n\n```js\nclass MyCustomThemeExtension extends ThemeExtension<MyCustomThemeExtension> {\n  const MyCustomThemeExtension({\n    required this.customColor,\n  });\n\n  MyCustomThemeExtension.light() : customColor = Colors.yellow.shade900;\n\n  MyCustomThemeExtension.dark() : customColor = Colors.green.shade900;\n\n  final Color customColor;\n\n  @override\n  ThemeExtension<MyCustomThemeExtension> copyWith({\n    Color? customColor,\n  }) {\n    return MyCustomThemeExtension(customColor: customColor ?? this.customColor);\n  }\n\n  @override\n  ThemeExtension<MyCustomThemeExtension> lerp(\n    covariant ThemeExtension<MyCustomThemeExtension>? other,\n    double t,\n  ) {\n    if (other is! MyCustomThemeExtension) return this;\n    return MyCustomThemeExtension(\n      customColor: Color.lerp(customColor, other.customColor, t)!,\n    );\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n저는 이 클래스를 매우 간단하게 유지하여 효과적으로 사용하는 방법을 보여주기 위해 노력했습니다.\n\n먼저, 이 클래스를 ThemeData에 추가하여 확장하고 해당 확장을 서브트리 내에서 접근할 수 있도록 해야 합니다:\n\n```js\nreturn ThemeData(\n  ...\n  extensions: [MyCustomThemeExtension.light()],\n  ...\n);\n```\n\n우리가 이전에 선언한 customColor를 활용하기 위해서는 해당 확장에 접근하면 됩니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n마지막 색상 = Theme.of(context)\n                        .extension<MyCustomThemeExtension>()!\n                        .customColor;\n```\n\nThemeExtension의 사용은 특히 Material 사양과 긴밀히 연결되지 않은 디자인 시스템을 코딩할 때 특히 유용하다고 생각합니다. 이러한 경우에는 ThemeData의 기본 필드가 충분하지 않거나 디자인 시스템의 요구 사항과 의미적으로 일치하지 않을 수 있습니다.\n\n# 결론\n\n테마 전환을 통해 개발자는 더 동적이고 현대적인 애플리케이션을 만들 수 있을 뿐만 아니라 사용자의 요구를 존중할 수 있다고 생각합니다. 저는 개인적으로 다크 모드를 많이 사용하고 애플리케이션이 그것을 지원하지 않을 때 약간 긴장을 느낍니다.\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 Markdown 형식으로 변경해 드렸어요.\n\n좋은 하루 보내세요!\n\n## 참고문헌\n","ogImage":{"url":"/assets/img/2024-06-23-CustomizeFlutterAppThemesSwappingBetweenLightDarkModesandUsingExtensions_0.png"},"coverImage":"/assets/img/2024-06-23-CustomizeFlutterAppThemesSwappingBetweenLightDarkModesandUsingExtensions_0.png","tag":["Tech"],"readingTime":4},{"title":"Flutter와 SocketIO 실시간 통합 방법","description":"","date":"2024-06-23 14:53","slug":"2024-06-23-FlutterandSocketIOReal-timeIntegration","content":"\n![Socket.IO package for Flutter](/assets/img/2024-06-23-FlutterandSocketIOReal-timeIntegration_0.png)\n\n## Socket.IO는 무엇인가요?\n\nSocket.IO는 실시간 이중방향 및 이벤트 주도 통신을 가능하게 하는 JavaScript 라이브러리입니다. 모든 플랫폼, 브라우저 또는 디바이스에서 작동하여 클라이언트와 서버 간의 원활한 연결을 보장합니다. Socket.IO는 WebSocket 프로토콜을 기반으로 작동하지만 다시 연결 지원, 멀티플렉싱 및 채널 지원과 같은 추가 기능을 제공합니다. 이는 즉각적인 데이터 업데이트 및 동적 상호작용이 필요한 애플리케이션에 이상적인 선택이 됩니다.\n\n<div class=\"content-ad\"></div>\n\nSocket.IO를 Flutter와 통합하기 위해서는, 개발자들이 socket_io_client 패키지를 활용합니다. 이 패키지는 Socket.IO 클라이언트의 Dart 구현을 제공하여 Flutter 애플리케이션이 Socket.IO 서버와 원활하게 연결할 수 있도록 합니다.\n\n# Flutter 프로젝트 설정하기:\n\n- 의존성 추가: pubspec.yaml 파일을 열고 다음 종속성을 추가하세요:\n\n```yaml\ndependencies:\n  socket_io_client: ^2.0.3+1\n```\n\n<div class=\"content-ad\"></div>\n\n# 로컬호스트에 연결하기:\n\n- 로컬에서 Socket.IO 서버가 실행 중인지 확인하세요.\n- `socketUrl` 함수는 에뮬레이터(IOS 또는 Android)에 적합한 로컬호스트 URL을 반환합니다.\n\n```js\nString socketUrl() {\n  if (Platform.isAndroid) {\n    return \"http://10.0.2.2:3000\";  // 안드로이드 에뮬레이터의 기본 IP 주소\n  } else {\n    return \"http://localhost:3000\"; // iOS 시뮬레이터용\n  }\n}\n```\n\n# 온라인 서버에 연결하기:\n\n<div class=\"content-ad\"></div>\n\n온라인 Socket.IO 서버에 연결하려면:\n\n- Socket.IO 서버를 온라인으로 배포하거나 기존 서버를 사용합니다.\n- socketUrl 함수를 업데이트하여 온라인 서버 URL을 반환하세요.\n\n```js\nString socketUrl() {\n  return \"https://your-online-server-url.com\";\n}\n```\n\n사용자가 HomeScreen을 열자마자 소켓 서버에 연결을 설정하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\n@override\nvoid initState() {\n  super.initState();\n\n  // 소켓 서버에 연결\n  socket = IO.io(socketUrl(), <String, dynamic>{\n    'transports': ['websocket'],\n  });\n\n  // 'connect' 이벤트에 대한 이벤트 리스너\n  socket.on('connect', (_) {\n    print('서버에 연결되었습니다');\n  });\n\n  // 서버로부터 메시지 수신\n  socket.on('message', (data) {\n    _streamController.add(data);\n  });\n}\n```\n\n## 메시지 전송:\n\n```js\nvoid sendMessage(String message) {\n  socket.emit('sendMessage', message);\n}\n```\n\nsendMessage 메서드는 제공된 메시지와 함께 `sendMessage` 이벤트를 서버로 전송합니다.\n\n<div class=\"content-ad\"></div>\n\n## 정리 작업 시 Dispose:\n\n```js\n@override\nvoid dispose() {\n  socket.disconnect();\n  _streamController.close();\n  super.dispose();\n}\n```\n\n- dispose()은 위젯이 제거될 때 호출되며, 소켓을 연결 해제하고 스트림을 닫습니다.\n\n# 출력:\n\n<div class=\"content-ad\"></div>\n\n![Socket.IO Flutter Demo](https://miro.medium.com/v2/resize:fit:1200/1*fdjqKbSJXfSqS_13uHvy9g.gif)\n\n# 전체 코드:\n\n```js\nimport 'dart:async';\nimport 'dart:io';\n\nimport 'package:flutter/material.dart';\nimport 'package:socket_io_client/socket_io_client.dart' as IO;\n\nclass HomeScreen extends StatefulWidget {\n  const HomeScreen({Key? key});\n\n  @override\n  HomeScreenState createState() => HomeScreenState();\n}\n\nclass HomeScreenState extends State<HomeScreen> {\n  late IO.Socket socket;\n  final StreamController<String> _streamController = StreamController<String>();\n  Stream<String> get messagesStream => _streamController.stream;\n\n  TextEditingController controller = TextEditingController();\n\n  //This will give platofrm specific url for ios and android emulator\n  String socketUrl() {\n    if (Platform.isAndroid) {\n      return \"http://10.0.2.2:3000\";\n    } else {\n      return \"http://localhost:3000\";\n    }\n  }\n\n  @override\n  void initState() {\n    super.initState();\n    // Connect to the Socket.IO server\n    socket = IO.io(socketUrl(), <String, dynamic>{\n      'transports': ['websocket'],\n    });\n\n    socket.on('connect', (_) {\n      print('Connected to server');\n    });\n\n    // Listen for messages from the server\n    socket.on('message', (data) {\n      _streamController.add(data);\n    });\n  }\n\n  @override\n  void dispose() {\n    // Disconnect from the Socket.IO server when the app is disposed\n    socket.disconnect();\n\n    //close stream\n    _streamController.close();\n    super.dispose();\n  }\n\n  void sendMessage(String message) {\n    // Send a message to the server\n    socket.emit('sendMessage', message);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Socket.IO Flutter Demo'),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            Padding(\n              padding: const EdgeInsets.symmetric(horizontal: 40),\n              child: TextFormField(\n                onChanged: (value) {\n                  if (socket.connected) {\n                    sendMessage(value);\n                  }\n                },\n                controller: controller,\n                decoration: const InputDecoration(hintText: \"Enter Message\"),\n              ),\n            ),\n            const SizedBox(height: 40),\n            StreamBuilder<String>(\n              stream: messagesStream,\n              builder: (context, snapshot) {\n                if (snapshot.hasError) {\n                  return Text('Error: ${snapshot.error}');\n                }\n                return Padding(\n                  padding: const EdgeInsets.symmetric(horizontal: 25),\n                  child: ListTile(\n                    title: Text(\"Received Message: ${snapshot.data ?? \"\"}\"),\n                  ),\n                );\n              },\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n```\n","ogImage":{"url":"/assets/img/2024-06-23-FlutterandSocketIOReal-timeIntegration_0.png"},"coverImage":"/assets/img/2024-06-23-FlutterandSocketIOReal-timeIntegration_0.png","tag":["Tech"],"readingTime":6},{"title":"Flutter에서 동적으로 앱 아이콘 변경하는 방법","description":"","date":"2024-06-23 14:51","slug":"2024-06-23-DynamicchangeAppIconFlutter","content":"\n안녕하세요! 이번 기사에서는 앱 아이콘을 동적으로 변경하는 방법을 구성하고 코딩하는 방법을 살펴보겠습니다. 안드로이드에서는 원하는 경우 라벨도 변경할 수 있습니다.\n\n우선, 새로운 Flutter 프로젝트를 만들어보세요. 저희 예시에서는 dynamic_icon_example이라는 프로젝트를 만들었습니다. 너무 많은 코딩 시간을 낭비하지 않도록 미리 만들어둔 예시 코드를 사용하겠습니다.\n\n시작해봅시다. 첫 번째로 이해해야 할 것은 MethodChannel입니다. 이 클래스를 사용하면 Flutter 애플리케이션 내에서 네이티브 코드를 작성할 수 있으며 (iOS의 경우 Swift, Android의 경우 Kotlin), 이 코드를 호출할 수 있습니다. 실용적인 예시를 살펴보겠습니다.\n\n앱 폴더 내에서 android → app → src → main → kotlin → MainActivity.kt 파일을 열어보세요. 다음과 같은 내용을 볼 수 있을 것입니다:\n\n<div class=\"content-ad\"></div>\n\n![Dynamic Change App Icon](/assets/img/2024-06-23-DynamicchangeAppIconFlutter_0.png)\n\n프로젝트를 생성할 때 생성된 이름이 첫 번째 줄입니다. 이제 Flutter 측에서 메소드를 호출하기 위한 코드를 작성해야 합니다. 여기에서 호출할 채널을 구성할 것인데, 그 채널의 이름은 \"com.example.dynamic_icon_example/icon\"으로 지정할 것입니다. 또한 몇 가지 import 문을 추가해야 합니다. 여기에 있습니다:\n\n```js\npackage com.example.com.example.dynamic_icon_example\n\nimport androidx.annotation.NonNull\nimport io.flutter.embedding.android.FlutterFragmentActivity\nimport io.flutter.embedding.engine.FlutterEngine\nimport io.flutter.plugin.common.MethodChannel\nimport io.flutter.embedding.android.FlutterActivity\nimport io.flutter.plugins.GeneratedPluginRegistrant\n```\n\n이제 도움이 될 몇 가지 속성을 만들 수 있습니다. MainActivity 클래스 내부에 두 개의 변수를 추가할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n    private val CHANNEL = \"app.com.get.number\"\n    var methodChannelResult: MethodChannel.Result? = null\n```\n\nCHANNEL 변수는 호출할 채널의 이름입니다; 원하는 이름을 넣을 수 있어요. 이후에 configureFlutterEngine을 오버라이드하고 우리의 메소드를 생성할 수 있어요.\n\n```js\n@Override\n    override fun configureFlutterEngine(@NonNull flutterEngine: FlutterEngine) {\n        GeneratedPluginRegistrant.registerWith(flutterEngine)\n        super.configureFlutterEngine(flutterEngine)\n\n        MethodChannel(flutterEngine.dartExecutor, CHANNEL).setMethodCallHandler { call, result ->\n            try {\n                methodChannelResult = result\n                if (call.method.equals(\"odd\")) {\n                    result.success(1)\n                } else if (call.method.equals(\"even\")) {\n                    result.success(2)\n                } else {\n                    result.success(-1)\n                }\n            } catch (e: Exception) {\n                print(e)\n            }\n        }\n    }\n```\n\n이렇게 하면 Flutter 측에서 우리의 메소드를 호출할 수 있어요. 마지막으로, 완전한 코드는 다음과 같아요:\n\n<div class=\"content-ad\"></div>\n\n```kotlin\npackage com.example.dynamic_icon_example\n\nimport androidx.annotation.NonNull\nimport io.flutter.embedding.android.FlutterFragmentActivity\nimport io.flutter.embedding.engine.FlutterEngine\nimport io.flutter.plugin.common.MethodChannel\nimport io.flutter.embedding.android.FlutterActivity\nimport io.flutter.plugins.GeneratedPluginRegistrant\n\nclass MainActivity: FlutterActivity() {\n\n    private val CHANNEL = \"app.com.get.number\"\n    var methodChannelResult: MethodChannel.Result? = null\n\n    @Override\n    override fun configureFlutterEngine(@NonNull flutterEngine: FlutterEngine) {\n        GeneratedPluginRegistrant.registerWith(flutterEngine)\n        super.configureFlutterEngine(flutterEngine)\n\n        MethodChannel(flutterEngine.dartExecutor, CHANNEL).setMethodCallHandler { call, result ->\n            try {\n                methodChannelResult = result\n                if (call.method.equals(\"odd\")) {\n                    result.success(1)\n                } else if (call.method.equals(\"even\")) {\n                    result.success(2)\n                } else {\n                    result.success(-1)\n                }\n            } catch (e: Exception) {\n                print(e)\n            }\n        }\n    }\n}\n```\n\n우리의 Android에서의 MethodChannel 설정이 완료되었습니다. 이제 iOS로 넘어갑시다. ios 폴더로 이동하여 `Runner` -> `AppDelegate.swift`로 이동해주세요.\n![앱 아이콘을 동적으로 변경하는 플러터 앱의 스크린샷](/assets/img/2024-06-23-DynamicchangeAppIconFlutter_1.png)\n\n여기가 iOS 측의 코드입니다. 코드는 다음과 같이 보일 것입니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport UIKit\nimport Flutter\n\n@UIApplicationMain\n@objc class AppDelegate: FlutterAppDelegate {\n  override func application(\n    _ application: UIApplication,\n    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?\n  ) -> Bool {\n\n    let controller: FlutterViewController = window?.rootViewController as! FlutterViewController\n    let appIconChannel = FlutterMethodChannel(\n      name: \"com.example.dynamic_icon_example.get.number\", binaryMessenger: controller.binaryMessenger)\n\n    appIconChannel.setMethodCallHandler({\n      [weak self] (call: FlutterMethodCall, result: FlutterResult) -> Void in\n      if call.method == \"odd\" {\n       result(1)\n      } else if call.method == \"even\" {\n        result(2)\n      } else {\n       result(-1)\n        return\n      }\n    })\n\n    GeneratedPluginRegistrant.register(with: self)\n    return super.application(application, didFinishLaunchingWithOptions: launchOptions)\n  }\n}\n```\n\n위 코드를 설명하자면, 이 함수는 화면에서 선택한 홀수나 짝수에 따라 홀수나 짝수를 반환합니다. 이제 main.dart 파일로 돌아가서 코드를 작성할 수 있습니다. 소스 코드에서 모든 주석을 제거하고 \\_incrementCounter라는 함수를 찾습니다. 이 함수를 비동기식으로 만듭니다. 상태(State) 내부에 채널을 호출할 변수를 만들 수 있습니다. 다음과 같이 채널을 호출하는 변수를 생성합니다:\n\n```js\nclass _MyHomePageState extends State<MyHomePage> {\n  int _counter = 0;\n  final MethodChannel channel = const MethodChannel('com.example.dynamic_icon_example.get.number');\n```\n\n그리고 \\_incrementCounter 함수 내부에서 메소드를 호출할 것입니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n  Future<void> _incrementCounter() async {\n    final int number =\n        await channel.invokeMethod(_counter % 2 == 0 ? 'even' : 'odd');\n    print(number);\n    setState(() {\n      _counter++;\n    });\n  }\n```\n\n그리고 디버그 콘솔에서 값들을 확인할 수 있습니다:\n\n![이미지](/assets/img/2024-06-23-DynamicchangeAppIconFlutter_2.png)\n\n이제 앱 아이콘을 동적으로 변경하는 방법에 대해 이야기해보겠습니다. 먼저 Android 및 iOS 앱을 구성해야 합니다.\n\n<div class=\"content-ad\"></div>\n\nANDROID\n\n안녕하세요! 안드로이드 개발자 여러분!\n\nandroid/app/src/main 폴더 안의 AndroidManifest.xml 파일을 열어주세요. `activity` 태그를 찾은 후, 그 안에 다음 코드를 추가해주세요:\n\n```js\nandroid: enabled = \"false\";\n```\n\n이후, 각 아이콘 변형에 대해 activity-alias를 생성할 건데요. 각 activity-alias 코드는 다음과 같이 보일 거에요:\n\n<div class=\"content-ad\"></div>\n\n```js\n<activity-alias\n    android:name=\".launcherAlias.one\"\n    android:enabled=\"false\"\n    android:icon=\"@mipmap/icon_launch\"\n    android:label=\"One\"\n    android:targetActivity=\".MainActivity\"\n    android:exported=\"true\">\n    <intent-filter>\n        <action android:name=\"android.intent.action.MAIN\" />\n        <category android:name=\"android.intent.category.LAUNCHER\" />\n    </intent-filter>\n    <intent-filter>\n        <action android:name=\"android.intent.action.VIEW\" />\n        <category android:name=\"android.intent.category.DEFAULT\" />\n        <category android:name=\"android.intent.category.BROWSABLE\" />\n    </intent-filter>\n</activity-alias>\n\n<activity-alias\n    android:name=\".launcherAlias.two\"\n    android:enabled=\"false\"\n    android:icon=\"@mipmap/icon_launch\"\n    android:label=\"Two\"\n    android:targetActivity=\".MainActivity\"\n    android:exported=\"true\">\n    <intent-filter>\n        <action android:name=\"android.intent.action.MAIN\" />\n        <category android:name=\"android.intent.category.LAUNCHER\" />\n    </intent-filter>\n    <intent-filter>\n        <action android:name=\"android.intent.action.VIEW\" />\n        <category android:name=\"android.intent.category.DEFAULT\" />\n        <category android:name=\"android.intent.category.BROWSABLE\" />\n    </intent-filter>\n</activity-alias>\n\n<activity-alias\n    android:name=\".launcherAlias.default\"\n    android:enabled=\"true\"\n    android:icon=\"@mipmap/icon_launch\"\n    android:label=\"Dynamic\"\n    android:targetActivity=\".MainActivity\"\n    android:exported=\"true\">\n    <intent-filter>\n        <action android:name=\"android.intent.action.MAIN\" />\n        <category android:name=\"android.intent.category.LAUNCHER\" />\n    </intent-filter>\n    <intent-filter>\n        <action android:name=\"android.intent.action.VIEW\" />\n        <category android:name=\"android.intent.category.DEFAULT\" />\n        <category android:name=\"android.intent.category.BROWSABLE\" />\n    </intent-filter>\n</activity-alias>\n```\n\n2개의 추가 구성을 만들어 Android 앱 아이콘 및 앱 레이블을 변경할 것입니다. 아이콘만 변경하려면 각 activity-alias 정의에서 android:label 줄을 삭제하면 됩니다. 이제 이미지를 생성해야 합니다. 이미지를 생성하려면 이 사이트를 사용할 수 있습니다: AppIcon. 이제 각 activity-alias의 android:icon 속성을 mipmap 폴더 내의 이미지 이름과 일치하도록 변경하십시오. AndroidManifest.xml은 다음과 같아야 합니다:\n\n```js\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <application\n        android:label=\"Dynamic\"\n        android:name=\"${applicationName}\"\n        android:icon=\"@mipmap/ic_launcher\">\n        <activity\n            android:name=\".MainActivity\"\n            android:exported=\"true\"\n            android:enabled=\"false\"\n            android:launchMode=\"singleTop\"\n            android:theme=\"@style/LaunchTheme\"\n            android:configChanges=\"orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode\"\n            android:hardwareAccelerated=\"true\"\n            android:windowSoftInputMode=\"adjustResize\">\n            <!-- Specifies an Android theme to apply to this Activity as soon as\n                 the Android process has started. This theme is visible to the user\n                 while the Flutter UI initializes. After that, this theme continues\n                 to determine the Window background behind the Flutter UI. -->\n            <meta-data\n                android:name=\"io.flutter.embedding.android.NormalTheme\"\n                android:resource=\"@style/NormalTheme\"\n            />\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n        <!-- Don't delete the meta-data below.\n             This is used by the Flutter tool to generate GeneratedPluginRegistrant.java -->\n        <meta-data\n            android:name=\"flutterEmbedding\"\n            android:value=\"2\" />\n\n        <!-- 여기에 위의 activity-alias 코드를 붙여넣으세요 -->\n    </application>\n</manifest>\n\nMainActivity.kt 파일이 있는 폴더로 이동하면, 각 alias에 대한 이름으로 파일을 생성해야 합니다. \".launcherAlias.\" 이후의 마지막 이름만 사용하면 됩니다. 제 경우에는 파일 이름이 Default.kt, One.kt, Two.kt 여야 합니다. 각 파일에 아래 코드를 복사하여 붙여넣고 이름만 변경하시면 됩니다.\n```\n\n<div class=\"content-ad\"></div>\n\n```kotlin\npackage com.example.dynamic_icon_example.launcherAlias\n\nimport io.flutter.embedding.android.FlutterActivity\n// 각 alias의 이름을 변경합니다.\nclass Default: FlutterActivity() {\n}\n```\n\nMainActivity에서는 앱의 아이콘과 라벨을 변경하는 코드를 만들 것입니다. CHANNEL의 이름을 변경하여 아이콘 변경을 나타내는 의미 있는 이름으로 바꿔주세요. 예를 들어, \"app.com.get.change.icon\"과 같은 이름을 사용했습니다.\n\n다음은 사용할 주석이 달린 코드입니다:\n\n```kotlin\npackage com.example.dynamic_icon_example\n\nimport android.content.ComponentName\nimport android.content.pm.PackageManager\nimport androidx.annotation.NonNull\nimport io.flutter.embedding.android.FlutterFragmentActivity\nimport io.flutter.embedding.engine.FlutterEngine\nimport io.flutter.plugin.common.MethodChannel\nimport io.flutter.embedding.android.FlutterActivity\nimport io.flutter.plugins.GeneratedPluginRegistrant\n\nclass MainActivity: FlutterActivity() {\n\n    // 채널의 이름\n    private val CHANNEL = \"app.com.get.change.icon\"\n    var methodChannelResult: MethodChannel.Result? = null\n    // 초기 점을 제외한 모든 alias를 추가합니다.\n    val aliases = listOf(\"launcherAlias.Default\", \"launcherAlias.One\", \"launcherAlias.Two\")\n\n    @Override\n    override fun configureFlutterEngine(@NonNull flutterEngine: FlutterEngine) {\n        GeneratedPluginRegistrant.registerWith(flutterEngine)\n        super.configureFlutterEngine(flutterEngine)\n\n        MethodChannel(flutterEngine.dartExecutor, CHANNEL).setMethodCallHandler { call, result ->\n            try {\n                methodChannelResult = result\n                // 우리가 호출할 메소드\n                if (call.method.equals(\"changeIcon\")) {\n                    // 전달된 이름을 복구합니다\n                    val targetIcon = call.argument<String>(\"targetIcon\") as String\n                    // 변경을 수행할 함수를 호출합니다.\n                    // 여기서 이미 \"launcherAlias\"를 추가했습니다.\n                    setIcon(\"launcherAlias.$targetIcon\")\n                } else {\n                    result.success(-1)\n                }\n            } catch (e: Exception) {\n                print(e)\n            }\n        }\n    }\n\n    private fun setIcon(targetIcon: String) {\n        try {\n            // 사용할 패키지 이름을 포함하는 String을 작성합니다.\n            val packageManager: PackageManager = applicationContext!!.packageManager\n            val packageName = applicationContext!!.packageName\n            val className = StringBuilder()\n            className.append(packageName)\n            className.append(\".\")\n            className.append(targetIcon)\n\n            aliases.forEach { alias ->\n                // 모든 목록을 실행하고 설정할 것 외에는 모두 비활성화합니다.\n                val state =\n                    if (alias == targetIcon) PackageManager.COMPONENT_ENABLED_STATE_ENABLED\n                    else PackageManager.COMPONENT_ENABLED_STATE_DISABLED\n\n                // 새로운 아이콘과 라벨을 설정합니다.\n                packageManager.setComponentEnabledSetting(\n                    ComponentName(packageName, \"com.example.dynamic_icon_example.$alias\"),\n                    state,\n                    PackageManager.DONT_KILL_APP\n                )\n            }\n        } catch (e: Exception) {\n            print(e)\n        }\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n플러터 쪽에서 main.dart의 \\_incrementCounter 함수 내부에서:\n\n```js\n  Future<void> _incrementCounter() async {\n// 네이티브 메서드를 호출하여 아이콘을 변경할 예정\n// 아이콘의 최종 이름만 전달하면 \"launcherAlias\"는 kotlin 쪽에서 설정됨\n    final dynamic number =\n        await channel.invokeMethod('changeIcon', <String, dynamic>{'targetIcon': 'One'});\n    print(number);\n    setState(() {\n      _counter++;\n    });\n  }\n```\n\n이제 테스트할 수 있습니다.\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*eICX4eVobzz-tyLme9W4Hg.gif\" />\n\n<div class=\"content-ad\"></div>\n\n본글에 나온 코드는 앱이 아이콘을 변경할 때 종료되는 문제를 해결하는 코드입니다. MainActivity 폴더로 돌아가 \"SharedPref.kt\"라는 다른 파일을 만들어 아래 코드를 붙여넣으세요:\n\n```js\npackage com.example.dynamic_icon_example.helper\n\nimport android.content.Context\nimport android.content.Context.MODE_PRIVATE\nimport android.content.SharedPreferences\n\nopen class AppSharedPref {\n\n    companion object {\n        const val CONFIGURATION_PREF = \"configurationPreference\"\n\n        /*런처 아이콘*/\n        private const val KEY_LAUNCHER_IMAGE = \"launcherIcon\"\n        private const val KEY_LAUNCHER_COUNT = \"count\"\n        private const val KEY_LAUNCHER_SAVED_COUNT = \"savedCount\"\n\n        fun getSharedPreference(context: Context, preferenceFile: String): SharedPreferences {\n            return context.getSharedPreferences(preferenceFile, MODE_PRIVATE)\n        }\n\n        fun getSharedPreferenceEditor(\n            context: Context,\n            preferenceFile: String\n        ): SharedPreferences.Editor {\n            return context.getSharedPreferences(preferenceFile, MODE_PRIVATE).edit()\n        }\n\n        /* 설정 관련 함수 */\n\n        fun getLauncherIcon(context: Context): String? {\n            return getSharedPreference(context, CONFIGURATION_PREF)\n                .getString(KEY_LAUNCHER_IMAGE, \"launcherAlias.DefaultLauncherAlias\")\n        }\n\n        fun setLauncherIcon(context: Context, launcherIcon: String) {\n            getSharedPreferenceEditor(context, CONFIGURATION_PREF)\n                .putString(KEY_LAUNCHER_IMAGE, launcherIcon)\n                .apply()\n        }\n\n        fun getCount(context: Context): Int {\n            return getSharedPreference(context, CONFIGURATION_PREF).getInt(KEY_LAUNCHER_COUNT, 0)\n        }\n\n        fun setCount(context: Context, count: Int) {\n            getSharedPreferenceEditor(context, CONFIGURATION_PREF)\n                .putInt(KEY_LAUNCHER_COUNT, count)\n                .apply()\n        }\n\n        fun getSavedCount(context: Context): Int {\n            return getSharedPreference(context, CONFIGURATION_PREF)\n                .getInt(KEY_LAUNCHER_SAVED_COUNT, 0)\n        }\n\n        fun setSavedCount(context: Context, count: Int) {\n            getSharedPreferenceEditor(context, CONFIGURATION_PREF)\n                .putInt(KEY_LAUNCHER_SAVED_COUNT, count)\n                .apply()\n        }\n    }\n}\n```\n\n이 코드는 공유 설정을 사용하여 메모리에 아이콘 변경 정보를 저장합니다. 이제 MainActivity로 돌아가 일부 변경사항을 가해봅시다.\n\n```js\npackage com.example.dynamic_icon_example\n\nimport android.content.ComponentName\nimport android.content.pm.PackageManager\nimport androidx.annotation.NonNull\nimport io.flutter.embedding.android.FlutterFragmentActivity\nimport io.flutter.embedding.engine.FlutterEngine\nimport io.flutter.plugin.common.MethodChannel\nimport io.flutter.embedding.android.FlutterActivity\nimport io.flutter.plugins.GeneratedPluginRegistrant\nimport com.example.dynamic_icon_example.helper.AppSharedPref\n\nclass MainActivity: FlutterActivity() {\n\n    private val CHANNEL = \"app.com.get.change.icon\"\n    var methodChannelResult: MethodChannel.Result? = null\n    // initial dot을 뺀 모든 별칭을 추가하세요\n    val aliases = listOf(\"launcherAlias.Default\", \"launcherAlias.One\", \"launcherAlias.Two\")\n\n    @Override\n    override fun configureFlutterEngine(@NonNull flutterEngine: FlutterEngine) {\n        GeneratedPluginRegistrant.registerWith(flutterEngine)\n        super.configureFlutterEngine(flutterEngine)\n\n        MethodChannel(flutterEngine.dartExecutor, CHANNEL).setMethodCallHandler { call, result ->\n            try {\n                methodChannelResult = result\n                if (call.method.equals(\"changeIcon\")) {\n                    val targetIcon = call.argument<String>(\"targetIcon\") as String\n                    // 여기에서 정보를 저장하여 앱을 닫은 후 적용할 것입니다\n                    AppSharedPref.setLauncherIcon(this, \"launcherAlias.$targetIcon\")\n                    AppSharedPref.setCount(this, 0)\n                } else {\n                    result.success(-1)\n                }\n            } catch (e: Exception) {\n                print(e)\n            }\n        }\n    }\n\n    // 우리 앱이 종료될 때 아이콘 및 레이블 변경을 호출할 메소드입니다\n    override fun onDestroy() {\n        setIcon(AppSharedPref.getLauncherIcon(this).toString())\n        super.onDestroy()\n    }\n\n    private fun setIcon(targetIcon: String) {\n        try {\n            val packageManager: PackageManager = applicationContext!!.packageManager\n            val packageName = applicationContext!!.packageName\n            val className = StringBuilder()\n            className.append(packageName)\n            className.append(\".\")\n            className.append(targetIcon)\n\n            aliases.forEach { alias ->\n                val state =\n                    if (alias == targetIcon) PackageManager.COMPONENT_ENABLED_STATE_ENABLED\n                    else PackageManager.COMPONENT_ENABLED_STATE_DISABLED\n\n                packageManager.setComponentEnabledSetting(\n                    ComponentName(packageName, \"com.example.dynamic_icon_example.$alias\"),\n                    state,\n                    PackageManager.DONT_KILL_APP\n                )\n            }\n        } catch (e: Exception) {\n            print(e)\n        }\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n결과를 확인해봅시다:\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*yIABZsLhcIv84MjkGh1cWA.gif\" />\n\nIOS\n\niOS로 이동하여 Xcode로 열어주세요. Runner 디렉토리 내에 AlternativeIcons라는 폴더를 생성해주세요. 여기에 이미지를 저장하겠습니다.\n\n<div class=\"content-ad\"></div>\n\n![이미지_이름](/assets/img/2024-06-23-DynamicchangeAppIconFlutter_3.png)\n\n이제 Xcode의 Info.plist로 이동하여 \"Icon files (iOS 5)\"라는 매개변수를 Dictionary으로 추가하십시오. 이 매개변수 내에서 \"CFBundleAlternateIcons\"를 Dictionary로 추가하십시오. 그런 다음 사용하려는 각 새 이미지에 대해(예: \"Default\", \"One\", \"Two\") 새 항목을 만드십시오. 각 항목 내에서 \"CFBundleIconFiles\" 매개변수를 Array로 추가하십시오. 배열의 첫 번째 위치에는 이미지 이름을 @2x 또는 @3x 없이, .png 없이 사용하십시오.\n\n최종적으로 아래와 같이 보여야 합니다:\n\n![이미지_이름](/assets/img/2024-06-23-DynamicchangeAppIconFlutter_4.png)\n\n<div class=\"content-ad\"></div>\n\nAppDelegate.swift 파일에 함수를 만들어 봅시다.\n\n```js\nimport UIKit\nimport Flutter\n\n@UIApplicationMain\n@objc class AppDelegate: FlutterAppDelegate {\n  override func application(\n    _ application: UIApplication,\n    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?\n  ) -> Bool {\n\n    let controller: FlutterViewController = window?.rootViewController as! FlutterViewController\n    //우리 채널 이름이 업데이트됐어요\n    let appIconChannel = FlutterMethodChannel(\n      name: \"app.com.get.change.icon\", binaryMessenger: controller.binaryMessenger)\n\n    appIconChannel.setMethodCallHandler({\n      [weak self] (call: FlutterMethodCall, result: FlutterResult) -> Void in\n      if call.method == \"changeIcon\" {\n        // 변경을 수행하는 함수\n       self?.changeAppIcon(call: call, result: result)\n      } else {\n       result(-1)\n        return\n      }\n    })\n\n    GeneratedPluginRegistrant.register(with: self)\n    return super.application(application, didFinishLaunchingWithOptions: launchOptions)\n  }\n\n  private func changeAppIcon(call: FlutterMethodCall, result: FlutterResult) {\n    // 10.3 이상에서만 작동\n    if #available(iOS 10.3, *) {\n      guard UIApplication.shared.supportsAlternateIcons else {\n        result(false)\n        return\n      }\n      // 전달된 이름 복원\n      guard let args = call.arguments as? [String : Any] else {return}\n      let arguments: String = args[\"targetIcon\"] as! String\n\n      var iconName: String?\n\n      // 현재 아이콘의 이름 확인\n      if let currentIconName = UIApplication.shared.alternateIconName {\n        iconName = currentIconName\n      } else {\n        iconName = \"Normal\"\n      }\n      // 두 번 변경하지 않도록하는 조건 설정\n      if iconName == arguments {\n        result(false)\n        return\n      }\n      // 새 아이콘 적용\n      UIApplication.shared.setAlternateIconName(arguments)\n      result(true)\n\n    } else {\n      result(false)\n    }\n  }\n\n  private func getIcon(call: FlutterMethodCall, result: FlutterResult) {\n    result(UIApplication.shared.alternateIconName)\n  }\n}\n```\n\n작동 방식을 확인해 봅시다. 앱 아이콘을 \"Default\"로 변경해 보겠습니다:\n\n<img src=\"/assets/img/2024-06-23-DynamicchangeAppIconFlutter_5.png\" />\n\n<div class=\"content-ad\"></div>\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*siJRg9-s1ba9LwJfuvvscQ.gif)\n\n여기에서 소스 코드를 찾을 수 있습니다.\n\n이 글이 도움이 되었기를 바랍니다. 읽어 주셔서 감사합니다!\n","ogImage":{"url":"/assets/img/2024-06-23-DynamicchangeAppIconFlutter_0.png"},"coverImage":"/assets/img/2024-06-23-DynamicchangeAppIconFlutter_0.png","tag":["Tech"],"readingTime":22},{"title":"VSCode를 사용하여 Android Studio 대신 Windows 환경에서 Flutter 프로그래밍하는 방법","description":"","date":"2024-06-23 14:50","slug":"2024-06-23-FlutterprogrammingforandroidwithVSCodeinsteadofusingAndroidStudioinWindows","content":"\n\n<img src=\"/assets/img/2024-06-23-FlutterprogrammingforandroidwithVSCodeinsteadofusingAndroidStudioinWindows_0.png\" />\n\n# 윈도우에서 VSCode로 새 Flutter 프로젝트를 만드는 단계별 지침서\n\n## 단계 1: VSCode 설치하기\n\nVSCode를 공식 링크(https://code.visualstudio.com/download)에서 다운로드하고 설치하세요.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-23-FlutterprogrammingforandroidwithVSCodeinsteadofusingAndroidStudioinWindows_1.png\" />\n\n## 단계 2: Flutter 확장 프로그램 설치\n\n비주얼 스튜디오 코드용 Flutter 확장 프로그램을 설치하세요. 이를 위해 비주얼 스튜디오 코드에서 Extension Marketplace를 열고 \"Flutter\"를 검색한 다음 Flutter 확장 프로그램을 설치하기 위해 \"설치\"를 클릭하세요.\n\n## 단계 3: Java 11 SDK 설치\n\n<div class=\"content-ad\"></div>\n\n아래 링크에서 Java 11 SDK를 다운로드하고 설치해주세요. https://www.oracle.com/in/java/technologies/javase/jdk11-archive-downloads.html\n\n![image](/assets/img/2024-06-23-FlutterprogrammingforandroidwithVSCodeinsteadofusingAndroidStudioinWindows_2.png)\n\n- 시스템 변수 아래에 새로운 변수를 생성해주세요.\n\n이름: JAVA_HOME, 값: C:\\Program Files\\Java\\jdk-11.0.12\n\n<div class=\"content-ad\"></div>\n\n```js\nJAVA_HOME=C:\\Program Files\\Java\\jdk-11.0.12\n```\n\n![Image](/assets/img/2024-06-23-FlutterprogrammingforandroidwithVSCodeinsteadofusingAndroidStudioinWindows_3.png)\n\n2. PATH에 %JAVA_HOME%\\bin 추가\n\n```js\n%JAVA_HOME%\\bin\n```\n\n<div class=\"content-ad\"></div>\n\n## 단계 4: 명령 줄 도구를 사용하여 Android SDK 설치하기\n\n공식 링크인 https://developer.android.com/studio 에서 명령 줄 도구를 사용하여 Android SDK를 다운로드하세요.\n\n![이미지](/assets/img/2024-06-23-FlutterprogrammingforandroidwithVSCodeinsteadofusingAndroidStudioinWindows_4.png)\n\n- C:\\Android\\ 안에 android-sdk라는 이름의 폴더를 생성하세요.\n- 다운로드한 zip 파일을 C:\\Android\\android-sdk\\cmdline-tools\\latest\\ 경로에 압축 해제하세요. 참고: 경로는 동일해야 합니다.\n- 시스템 변수 아래에 새 변수를 만드세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nANDROID_HOME=C:\\Android\\android-sdk\nANDROID_SDK_ROOT=C:\\Android\\android-sdk\n```\n\n`ANDROID_HOME`의 이름과 값은 `C:\\Android\\android-sdk`입니다.\n\n![이미지](/assets/img/2024-06-23-FlutterprogrammingforandroidwithVSCodeinsteadofusingAndroidStudioinWindows_5.png)\n\n`ANDROID_SDK_ROOT`의 이름과 값은 `C:\\Android\\android-sdk`입니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Image 1](/assets/img/2024-06-23-FlutterprogrammingforandroidwithVSCodeinsteadofusingAndroidStudioinWindows_6.png)\n\n4. Variable After added like this.\n\n![Image 2](/assets/img/2024-06-23-FlutterprogrammingforandroidwithVSCodeinsteadofusingAndroidStudioinWindows_7.png)\n\n4. Add C:\\Android\\android-sdk\\cmdline-tools\\latest\\bin to PATH\n\n\n<div class=\"content-ad\"></div>\n\n```js\n%ANDROID_HOME%\\cmdline-tools\\latest\\bin\n```\n\n5. cmd sdkmanager — update 명령을 사용하여 SDK 관리자 업데이트\n\n```js\nsdkmanager --update\n```\n\n6. 다음 명령을 사용하여 시스템 이미지, 플랫폼, 플랫폼 도구, 에뮬레이터 및 빌드 도구 다운로드하기\n\n<div class=\"content-ad\"></div>\n\n```js\nsdkmanager emulator platform-tools\nsdkmanager \"system-images;android-29;google_apis;x86\"\nsdkmanager \"platforms;android-29\"\nsdkmanager \"build-tools;29.0.2\"\n```\n\n7. 그리고 최종적으로 다음 경로들이 시스템 변수 아래 PATH에 추가됩니다\n\n![image](/assets/img/2024-06-23-FlutterprogrammingforandroidwithVSCodeinsteadofusingAndroidStudioinWindows_8.png)\n\n## 단계 5: Flutter SDK 설치\n\n<div class=\"content-ad\"></div>\n\n공식 링크인 https://docs.flutter.dev/get-started/install/windows 에서 플러터의 최신 버전을 다운로드 받을 수 있어요.\n\n![이미지](/assets/img/2024-06-23-FlutterprogrammingforandroidwithVSCodeinsteadofusingAndroidStudioinWindows_9.png)\n\n- C:\\ 안에 Android란 이름의 폴더를 만들어주세요.\n- 다운로드한 zip 파일을 C:\\Android\\flutter 경로에 압축 해제해주세요.\n- C:\\Android\\flutter\\bin를 PATH에 추가해주세요\n\n```js\nC:\\Android\\flutter\\bin\n```\n\n<div class=\"content-ad\"></div>\n\n4. 프로젝트가 저장된 드라이브에 Pubcache를위한 폴더를 만듭니다. D:\\Program Data\\.pubcache 및 PATH에 추가합니다.\n\n```js\nD:\\Program Data\\.pubcache\n```\n\n## 단계 6: Flutter가 작동하는지 확인합니다.\n\ncmd를 사용하여 flutter doctor -v를 실행하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nflutter doctor -v\n```\n\n<img src=\"/assets/img/2024-06-23-FlutterprogrammingforandroidwithVSCodeinsteadofusingAndroidStudioinWindows_10.png\" />\n\n## Step 7: Create new flutter project\n\nCreate a new flutter project using cmd `flutter create projectname`\n\n<div class=\"content-ad\"></div>\n\n이미지를 참고해주세요!\n\n```js\nflutter create testpro\ncd testpro\ncode .\n```\n\nVSCode에서 폴더를 열기 위해 코드를 실행하세요.\n\n## 단계 8: 에뮬레이터 시작하기\n\n<div class=\"content-ad\"></div>\n\n에뮬레이터를 시작하기 위한 전제 조건입니다.\n\n- 가상화가 활성화되어 있어야 합니다.\n\n![이미지](/assets/img/2024-06-23-FlutterprogrammingforandroidwithVSCodeinsteadofusingAndroidStudioinWindows_12.png)\n\n3. Windows 10 Home에서 Hyper-v를 설치하고 활성화하려면 Windows Hypervisor 플랫폼 확인란을 선택하세요.\n\n<div class=\"content-ad\"></div>\n\n\n![image](https://www.example.com/assets/img/2024-06-23-FlutterprogrammingforandroidwithVSCodeinsteadofusingAndroidStudioinWindows_13.png)\n\n4. 새로운 Android 가상 장치를 만들고 디바이스를 실행하려면 키 Ctrl+Shift+P를 눌러 명령 팔레트를 열고 select device를 입력하세요.\n\n![image](https://www.example.com/assets/img/2024-06-23-FlutterprogrammingforandroidwithVSCodeinsteadofusingAndroidStudioinWindows_14.png)\n\nAndroid 에뮬레이터를 만들어보세요.\n\n\n<div class=\"content-ad\"></div>\n\n## 단계 9: VSCode에서 프로젝트 디버그 모드 실행\n\n디버그 모드로 플러터 프로젝트를 실행하려면 메뉴에서 Run-` Start Debugging을 선택하거나 F5 키를 누르세요.\n\n![이미지](/assets/img/2024-06-23-FlutterprogrammingforandroidwithVSCodeinsteadofusingAndroidStudioinWindows_15.png)\n\n## 단계 10: 터미널에서 실행\n\n<div class=\"content-ad\"></div>\n\n터미널을 열려면 Ctrl + ` 키를 누르세요. 터미널에서 cmd flutter run을 입력하여 실행을 시작하세요.\n\n```js\nflutter run\n```\n\n## 단계 11: 프로덕션용 빌드\n\n터미널을 열려면 Ctrl + ` 키를 눌러주세요. 빌드 후 플레이스토어에 배포하려면 .abb 파일을 얻으려면 터미널에서 cmd flutter build appbundle을 입력하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\r\n플러터 앱 번들을 빌드하려면 다음 명령어를 실행하세요.\r\n```","ogImage":{"url":"/assets/img/2024-06-23-FlutterprogrammingforandroidwithVSCodeinsteadofusingAndroidStudioinWindows_0.png"},"coverImage":"/assets/img/2024-06-23-FlutterprogrammingforandroidwithVSCodeinsteadofusingAndroidStudioinWindows_0.png","tag":["Tech"],"readingTime":6},{"title":"해커톤 네트워킹 앱 HackMate 매치, 코드로 완성하는 최고의 네트워킹 방법","description":"","date":"2024-06-23 14:47","slug":"2024-06-23-HackMateSwipeMatchCodeTheUltimateHackathonNetworkingApp","content":"\n\n틴더에서 완벽한 매치를 찾지 못하고 좌우로 스크롤하는 것에 지쳤나요? 만약 다가오는 해커톤을 위한 완벽한 팀 멤버를 찾을 수 있는 틴더의 매칭 기능을 사용할 수 있다면 어떨까요? 많은 해커톤 참가자들이 상호 보완적인 기술과 공유된 관심사를 가진 팀 멤버를 찾는 데 어려움을 겪고 있고, 검색과 네트워킹에 많은 시간을 투자하면서 종종 좌절감을 느끼곤 합니다.\n\n![해커톤 네트워킹 솔루션](https://miro.medium.com/v2/resize:fit:408/1*uOwUApY0uYxdn4ZIuYBFDA.gif)\n\n# 해커톤 네트워킹을 위한 해크메이트 소개\n\n마이 솔루션인 해크메이트는 해커톤 참가자들을 공통된 관심사와 목표를 가진 유사 마인드의 개인들과 매칭시키는 앱을 구축하는 것입니다. 두 사용자가 서로 우측으로 스와이프하면, 앱 내에서 서로의 프로젝트 아이디어와 목표에 대해 토론할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n주최자들은 해커톤 소통을 위해 별도의 디스코드 서버를 설정하는 수고를 덜게 됩니다. 내 앱은 내장된 그룹 생성 기능을 제공하여 이 과정을 간단하게 만듭니다. 해커톤에 등록하는 즉시 참가자들은 앱 내 전용 그룹에 자동으로 추가됩니다. 이 그룹은 해커톤 관련 모든 소통을 위한 중앙 허브로 작용하여 참가자들이 외부 플랫폼에 가입할 필요가 없게 합니다. 게다가, 해커톤이 끝나면 그룹이 자동으로 삭제되어 수동 정리 작업이 필요 없게 되며 앱 내에서 효율적으로 해커톤 관련 소통을 관리할 수 있습니다.\n\n<img src=\"/assets/img/2024-06-23-HackMateSwipeMatchCodeTheUltimateHackathonNetworkingApp_0.png\" />\n\n# 문제 해결: 팀원 구성과 효과적인 소통 보장\n\n# 팀원 구성\n\n<div class=\"content-ad\"></div>\n\n기대하는 많은 참가자들이 해커톤에서 적합한 팀원을 찾는 데 상당한 어려움을 겪습니다. 해커톤 등록을 지원하는 다양한 웹사이트들이 있지만, 이러한 플랫폼들은 종종 개인들을 효과적으로 연결하고 통합된 팀을 형성하지 못합니다. 결과적으로 많은 재능 있는 개인들은 호환되는 팀원이 없어 해커톤에 참여할 수 없게 됩니다. LinkedIn과 같은 인기 있는 네트워킹 플랫폼조차도 이 문제를 해결하지 못했습니다. LinkedIn은 다양한 산업 분야에서 전문 네트워킹에 초점을 맞추고 있으며 거대한 사용자 기반을 제공하지만, 해커톤 협업을 찾는 구체적인 개인들을 특별히 유인하지 못할 수 있습니다. LinkedIn의 검색 및 필터링 옵션은 해커톤에 특화된 기준에 맞춰 최적화되어 있지 않습니다.\n\n# 효과적인 소통\n\n해커톤 소통을 위해 별도의 Discord 서버를 만드는 것은 도전과 비효율성을 초래할 수 있습니다. 참가자들이 다른 플랫폼에 가입하고 탐색하는 데 추가적인 노력이 필요하고 이는 혼란과 조각난 소통 경험을 초래할 수 있습니다. 또한 업데이트를 놓치고 참여도가 감소할 수 있습니다. 별도의 Discord 서버를 관리하면 참가자들이 모두 서버에 가입하고 관련 채널에 접근할 수 있도록 보장해야 하는 주최자들에게 복잡함이 추가됩니다. 해커톤 후 그룹을 수동으로 삭제하는 데 추가적인 노력이 필요합니다. 저의 앱은 이러한 장애물을 제거하여 내장된 그룹 기능을 제공하고 참가자의 가입과 그룹 삭제를 자동화하여 소통을 간소화하고 해커톤 주최자와 참가자들에게 협업을 강화합니다.\n\n# HackMate 작동 방식\n\n<div class=\"content-ad\"></div>\n\n- **Preferences:** 내 앱은 사용자가 팀원 위치와 기술을 지정할 수 있도록 합니다.\n- **매칭:** 스와이프 기능을 사용하여 앱은 사용자들을 선호도에 기반하여 매칭하고 연결을 설정합니다.\n- **앱 내 채팅:** 매칭이 이루어지면 사용자들은 앱 내에서 프로젝트 아이디어와 목표에 대해 토론할 수 있는 채팅을 시작할 수 있습니다.\n- **팀 생성:** 사용자들이 협업을 결정하면 앱 내에서 팀을 만들 수 있습니다.\n- **조직:** 팀 리더는 팀원들에게 태그와 역할을 할당하여 조직을 더 잘 유지할 수 있습니다.\n- **통합된 커뮤니케이션:** 별도의 디스코드 서버에 가입할 필요가 없습니다. 내 앱은 주관자의 그룹과 통신을 관리하기 위해 통합되어 있습니다.\n- **자동화된 그룹 관리:** 해커톤에 등록하자마자 사용자는 앱에 생성된 그룹에 자동으로 포함됩니다. 해커톤 통신을 위해 생성된 그룹은 해커톤이 종료되면 자동으로 삭제되어 깔끔하고 조직적인 경험을 제공합니다.\n\n![이미지1](/assets/img/2024-06-23-HackMateSwipeMatchCodeTheUltimateHackathonNetworkingApp_1.png)\n\n![이미지2](/assets/img/2024-06-23-HackMateSwipeMatchCodeTheUltimateHackathonNetworkingApp_2.png)\n\n![이미지3](/assets/img/2024-06-23-HackMateSwipeMatchCodeTheUltimateHackathonNetworkingApp_3.png)\n\n<div class=\"content-ad\"></div>\n\n\n![Image 1](/assets/img/2024-06-23-HackMateSwipeMatchCodeTheUltimateHackathonNetworkingApp_4.png)\n\n![Image 2](/assets/img/2024-06-23-HackMateSwipeMatchCodeTheUltimateHackathonNetworkingApp_5)\n\n# Tech Stack\n\n- Backend: Appwrite Cloud\n\n\n<div class=\"content-ad\"></div>\n\n- 인증\n- 데이터베이스\n- 저장 공간\n- 기능\n- 실시간 API\n\n## 프론트엔드: 플러터\n\n- flutter_bloc 상태 관리\n- 캐싱 전략을 위한 Hydrated Bloc\n- 고급 라우팅 기능을 위한 Auto Routes\n- build_runner를 사용한 자동 코드 생성\n\n## 프로젝트 아키텍처\n\n<div class=\"content-ad\"></div>\n\n프로젝트는 청결 아키텍처에서 제시된 원칙에 깊게 의존합니다. 이 아키텍처는 관심사 분리를 쉽게 위해 기능을 서브모듈로 나누는 데 크게 의존합니다. 각 기능은 데이터 및 프레젠테이션 레이어로 구분되며, cubits/blocs은 데이터와 프레젠테이션 사이의 미들웨어 역할을 합니다.\n\n![이미지](/assets/img/2024-06-23-HackMateSwipeMatchCodeTheUltimateHackathonNetworkingApp_6.png)\n\n# 원칙과 패턴\n\n- DRY (Don’t Repeat Yourself): 이 패턴은 프로젝트 전체에 재사용 가능한 구성 요소를 생성하는 데 따르며, 시간이 흘러도 개발 속도를 높입니다.\n- 다중 환경: 앱이 아직 제작 중이며 공개 출시를 하지 않을 예정이므로 샌드박스 환경을 사용하고 있습니다. 로그인 화면에서 앱 이름을 길게 누르면 환경을 변경할 수 있습니다.\n- Dart Linting 규칙: 이 앱은 프로젝트 전반에 걸쳐 Dart Linting 규칙을 사용하며, analysis_options.yaml을 통해 일반적인 규칙을 따릅니다. dart_code_metrics 패키지를 사용하여 고급 Linting 규칙을 적용합니다.\n- 예외 처리: 앱에는 모든 예외를 잡는 Appwrite 예외 처리도 포함되어 있습니다. 앱 예외를 위한 중앙 위치는 Sentry, Firebase Crashlytics 등의 에러 보고 플러그인과 간편한 구성을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n# 오픈 소스 라이브러리들\n\n프로젝트는 여러 가지 오픈 소스 라이브러리에 의존하며, 이러한 라이브러리들은 실전에서 검증되었으며 보일러플레이트를 제거하는 데 도움이 됩니다:\n\n- djangoflow_app by Apexive.com\n- djangoflow_app_links by Apexive.com\n- progress_builder by Apexive.com\n- pin_code_fields by Saiful Islam Adar\n- smooth_page_indicator by codeness.ly\n\n# 인증 및 데이터베이스\n\n<div class=\"content-ad\"></div>\n\n# 인증\n\n- 구글, 전화 인증\n- 사용자 설문 조사를 위한 환경 설정 관리\n\n# 데이터베이스\n\n저는 dev라는 데이터베이스를 생성하고 ID를 hackmate-dev로 지정했습니다. 이 구조는 name-env 규칙을 따르기 때문에 앱 상태에서 사전 정의된 앱 이름과 환경을 가져와 앱에서 쉽게 구성할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 컬렉션\n\n- user: 사용자 데이터, 매치, 싫어요, 좋아요, 매치 요청, teamId를 저장하는 데 사용됩니다.\n- hackathons: 해커톤 관련 데이터를 저장하는 데 사용됩니다. upcoming_date 필드를 통해 예정된 해커톤을 지원합니다.\n- chat: 이벤트 기반 기능을 통해 두 사용자 간의 채팅 컬렉션을 만드는 데 사용됩니다.\n- banners: 상단에있는 앱 배너를 사용자 정의하는 데 사용됩니다. active 필드를 false로 설정하여 배너를 비활성화 할 수 있습니다.\n- teams: 사용자가 만든 앱의 팀 및 팀 구성원 (ID 및 역할 데이터)을 저장합니다.\n- team_vacancy: 앱에서 관리자가 생성할 수있는 팀 공석 게시물과 관련된 데이터를 저장합니다.\n\n# 보안\n\n나는 보안에 큰 중점을 두었으며 그래서 모든 컬렉션에 적절한 데이터 액세스 규칙이 있습니다. 두 사용자 간의 채팅을 위해 Appwrite의 문서 보안 규칙을 사용하여 채팅하는 두 사용자에게만 액세스 권한을 부여했습니다.\n\n<div class=\"content-ad\"></div>\n\n# 저장소 및 기능\n\n# 저장소\n\n팀 및 사용자 이미지를 저장하기 위해 저장소를 사용했어요. dev라는 버킷을 만들고 ID를 hackmate-dev로 지정했어요. 이 구조는 위에서 언급한 장점을 위해 데이터베이스 구조와 유사했어요.\n\n# 기능\n\n<div class=\"content-ad\"></div>\n\n클라우드 함수는 두 사용자 간에 동적 채팅 컬렉션을 생성하는 데 내 응용 프로그램에서 유용했습니다. GitHub의 functions/appwrite/chat/functions/createChatCollection 디렉토리에서 해당 코드를 찾을 수 있습니다. 이를 위해 Dart 런타임과 Appwrite 관리자 SDK를 사용했습니다. 이벤트 databases.*.collections.chat.documents.*.create는 채팅 컬렉션에 만들어지는 문서를 청취하고 두 사용자 간의 메시지를 저장하기 위한 지정된 스키마로 새 컬렉션을 만드는 함수를 트리거하는 데 사용되었습니다.\n\n## 버전 관리\n\n로컬 및 원격 저장소 관리를 위해 Git과 GitHub를 사용했습니다. 개발 라이프사이클 전체에서 Git의 다양한 기능인 add, stash, commit, 브랜치, 풀, 푸시 등을 사용했습니다. 또한 커밋 전에 코드 품질과 형식을 확인하기 위해 사용자 지정 Git 후크를 설계했습니다. 해당 후크는 scripts/git/ 디렉토리 아래에서 찾을 수 있습니다.\n\n## 직면한 도전들\n\n<div class=\"content-ad\"></div>\n\n프론트엔드에서 컬렉션을 생성할 수 없는 문제로 채팅 컬렉션을 동적으로 생성해야 하는 상황에서 꽤 난처했어요. Appwrite의 함수 문서를 차분히 살펴본 후, 이벤트 기반 함수를 사용하기로 결정했어요. 또 다른 어려운 측면은 채팅 기능을 실시간으로 만드는 것이었지만, Appwrite Cloud의 실시간 기능으로 쉽게 처리했어요.\n\n# 해결 방법\n\n이 프로젝트에서 대부분의 기능을 위해 Appwrite를 사용한 후, 실시간 기능에 중요한 단점을 발견했어요. 구체적으로, 클라우드 콘솔을 통해 실시간 구독을 설정하면 종종 연결이 끊기며 기능이 가끔 작동하지 않는 문제가 있어요. 자세한 내용은 Appwrite 공식 저장소의 이 문제를 참조해주세요: 이슈 #8037. 따라서, 직접 Appwrite 도로플릿을 배포하거나 다른 BaaS 솔루션으로 전환해야 할 것 같아요.\n\nGithub 저장소: https://github.com/Photon3009/Hackmate\n앱 다운로드 링크: https://github.com/Photon3009/Hackmate/releases/tag/v1.0.0\n\n<div class=\"content-ad\"></div>\n\n질문이나 제안이 있으시면 언제든지 연락해주세요! LinkedIn에서 저와 연결하거나 Twitter에서 팔로우해주세요. \n\n좋은 코딩 하세요:)","ogImage":{"url":"/assets/img/2024-06-23-HackMateSwipeMatchCodeTheUltimateHackathonNetworkingApp_0.png"},"coverImage":"/assets/img/2024-06-23-HackMateSwipeMatchCodeTheUltimateHackathonNetworkingApp_0.png","tag":["Tech"],"readingTime":7},{"title":"GitHub Actions로 Flutter 빌드 자동화 단계별 가이드","description":"","date":"2024-06-23 14:45","slug":"2024-06-23-AutomatingFlutterBuildswithGitHubActionsAStep-by-StepGuide","content":"\n\n![이미지](/assets/img/2024-06-23-AutomatingFlutterBuildswithGitHubActionsAStep-by-StepGuide_0.png)\n\n안녕하세요! 이 기사에서는 GitHub Actions를 활용하여 Flutter 앱의 빌드 및 릴리스 프로세스를 자동화하는 방법을 알아볼 거에요. 이 방법을 통해 연속적인 통합/배포(CI/CD) 파이프라인을 유지할 수 있어 개발에 집중할 수 있게 해주죠. GitHub Actions가 빌드와 애플리케이션 릴리스를 처리하는 동안 무거운 작업을 자동으로 처리해줍니다.\n\n# 소개\n\n자동화는 현대 소프트웨어 개발의 중요한 구성 요소로, 개발자가 반복 작업을 간소화하고 인적 오류를 줄일 수 있게 해줍니다. Flutter 개발자들에게는 빌드 및 릴리스 프로세스를 자동화하면 생산성을 크게 향상시키고 일관된 배포를 보장할 수 있습니다. GitHub Actions는 GitHub 저장소에서 직접 워크플로를 자동화할 수 있는 강력한 플랫폼을 제공합니다. 이 기사에서는 Android 및 iOS 플랫폼용 Flutter 앱의 빌드 및 릴리스를 처리하며 버전 관리 및 keystore 관리까지 다루는 GitHub Actions 워크플로를 생성해볼 거에요.\n\n<div class=\"content-ad\"></div>\n\n# 워크플로우 설정하기\n\n이전에 언급했듯이 Github Actions와 함께 작업할 것이므로, 먼저 프로젝트를 위한 Github Repo를 생성해야 합니다. 프로젝트의 이름을 flutterGitHubAction으로 지정합시다.\n\n![이미지 1](/assets/img/2024-06-23-AutomatingFlutterBuildswithGitHubActionsAStep-by-StepGuide_1.png)\n\n![이미지 2](/assets/img/2024-06-23-AutomatingFlutterBuildswithGitHubActionsAStep-by-StepGuide_2.png)\n\n<div class=\"content-ad\"></div>\n\n```js\n$ git init\n$ git add .\n$ git commit -m \"init app\"\n$ git remote add origin https://github.com/colonal/flutterGitHubAction.git\n$ git push -u origin master\n```\n\n![image](/assets/img/2024-06-23-AutomatingFlutterBuildswithGitHubActionsAStep-by-StepGuide_3.png)\n\n![image](/assets/img/2024-06-23-AutomatingFlutterBuildswithGitHubActionsAStep-by-StepGuide_4.png)\n\n이제 사랑하는 VSCode로 돌아가서 작업을 시작해봅시다.\n\n<div class=\"content-ad\"></div>\n\n- 프로젝트의 루트 폴더에 \" .github \"라는 새 디렉토리를 만듭니다.\n- 새로 만든 디렉토리 아래에 또 다른 새 디렉토리를 만들고 \" workflows \"라고 이름 짓습니다.\n- 마지막으로 workflows 디렉토리 안에 \" main.yml \"이라는 새 파일을 만듭니다.\n\n![이미지](/assets/img/2024-06-23-AutomatingFlutterBuildswithGitHubActionsAStep-by-StepGuide_5.png)\n\n- 이제 필요한 workflow를 작성해 봅시다.\n\n```js\nname: \"Build & Release\"   # 필요에 맞게 이름을 지정하세요\n```\n\n<div class=\"content-ad\"></div>\n\n- 이것은 GitHub Actions에서 실행하려는 workflow의 이름입니다.\n\n```js\non:\n  pull_request:\n    branches:\n      - dev\n      - test\n  push:\n    branches:\n      - dev\n      - test \n```\n\n- 이 작업을 트리거하고 싶은 경우들이며, 여기에서는 2가지 경우 [pull_request 및 push]에 대해 설정했으며, 청취하고 트리거할 브랜치를 지정했습니다. 여기에서는 [dev, test] 브랜치로 설정했습니다.\n- 이것은 즉, 우리의 작업이 dev 또는 test 브랜치로 뭔가를 푸시하거나 dev 또는 test 브랜치에서 PR을 할 때마다 트리거될 것을 의미합니다.\n\n```js\njobs:  # 어떤 작업이 필요한지 알려주는 부분\n  build:      # 작성될 이름과 머신을 지정\n    name: Build & Release  # 빌드 이름을 원하시는 대로 지정할 수 있습니다\n    runs-on: macos-latest # 여기에서 우리는 ios 빌드를 얻기 위해 macos-latest를 선택했습니다\n```\n\n<div class=\"content-ad\"></div>\n\n이제 우리가 거쳐가길 원하는 단계를 구체적으로 지정해야 해요(위에 보여진 대로):\n\n![Step Image](/assets/img/2024-06-23-AutomatingFlutterBuildswithGitHubActionsAStep-by-StepGuide_6.png)\n\n# 1. 저장소 체크아웃\n\n```yaml\n- name: Checkout Repository\n  uses: actions/checkout@v3\n```\n\n<div class=\"content-ad\"></div>\n\n설명: 여기서는 checkout이라는 미리 만들어 둔 작업을 사용하여 저장소 코드를 체크아웃하여 워크플로가 액세스할 수 있게 합니다. 이 작업과 많은 다른 작업은 GitHub Actions marketplace에서 찾을 수 있습니다. 각 작업에 이름을 지정하는 것은 필수는 아니지만 명확성을 위해 유용합니다.\n\n## 2. Java 설정\n\n```yaml\n- name: Set Up Java\n  uses: actions/setup-java@v3.12.0\n  with:\n    distribution: 'oracle'\n    java-version: '17'\n```\n\n설명: 이 단계는 setup-java 작업을 사용하여 필요한 Java 환경을 설정합니다. 'Oracle'를 배포로, '17'을 Java 버전으로 지정합니다. 이는 Android 앱을 빌드하는 데 필요합니다. 모든 사용 가능한 배포본을 여기에서 찾을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 3. 플러터 설정하기\n\n```js\n- name: 플러터 설정\n  uses: subosito/flutter-action@v2\n  with:\n    flutter-version: '3.22.2'\n    channel: 'stable'\n```\n\n설명: 이 단계에서는 subosito/flutter-action을 사용하여 지정된 버전과 채널로 플러터 환경을 설정합니다. 이렇게 하면 빌드 프로세스 중에 올바른 버전의 플러터를 사용할 수 있습니다.\n\n# 4. 종속성 설치하기\n\n<div class=\"content-ad\"></div>\n\n\n- name: 의존성 설치\n  run: flutter pub get\n\n\n설명: 이 단계는 플러터 프로젝트에 필요한 종속성을 설치하기 위해 flutter pub get을 실행합니다. 이것은 로컬에서 명령을 실행하는 것과 동일하며, pubspec.yaml 파일에서 지정된 모든 종속성을 해결하는 데 중요합니다.\n\n# 5. 키스토어 설정\n\nAndroid 앱에 서명하려면 키스토어 파일 및 관련 속성을 안전하게 처리해야 합니다. 저장소에 직접 keystore.jks 파일을 추가하는 대신 (보안에 취약합니다), 해당 파일을 base64 문자열로 변환하여 GitHub 저장소에서 비밀로 저장합니다. 또한 필요한 다른 키스토어 속성을 비밀로 저장합니다. 아래는 자세한 단계입니다:\n\n\n<div class=\"content-ad\"></div>\n\n## 단계별 안내:\n\n- 키스토어 파일을 Base64로 변환하세요. 다음 명령을 사용하여 keystore.jks 파일을 base64 문자열로 변환하세요:\n\n```js\nbase64 -w 0 keystore.jks > keystore.jks.base64\n```\n\n- keystore.jks.base64 파일의 내용을 복사하세요.\n- GitHub 리포지토리에 시크릿 추가하기. 리포지토리 설정으로 이동하여 \"Actions\"에서 \"Secrets and variables\"로 이동한 후 다음 시크릿을 추가하세요:\n\n<div class=\"content-ad\"></div>\n\n- KEYSTORE_BASE64: keystore.jks.base64의 내용입니다.\n- KEYSTORE_PASSWORD: 키스토어의 비밀번호입니다.\n- KEY_ALIAS: 키에 대한 별칭입니다.\n- KEY_PASSWORD: 키 별칭의 비밀번호입니다.\n\n![image](/assets/img/2024-06-23-AutomatingFlutterBuildswithGitHubActionsAStep-by-StepGuide_7.png)\n\n## GitHub Actions Workflow 단계:\n\n- Keystore 디코딩\n\n<div class=\"content-ad\"></div>\n\n```yaml\n- name: 키스토어 디코드\n  run: |\n    echo \"${ secrets.KEYSTORE_BASE64 }\" | base64 --decode > android/app/keystore.jks\n```\n\n설명: 이 단계는 GitHub 저장소에 저장된 시크릿을 사용하여 base64로 인코딩된 키스토어를 디코딩합니다. 디코딩된 키스토어는 android/app/keystore.jks에 저장됩니다. Android 앱을 서명하는 데 필요합니다.\n\n2. key.properties 파일 생성하기\n\n```yaml\n- name: key.properties 파일 생성\n  run: |\n    echo \"storePassword=${ secrets.KEYSTORE_PASSWORD }\" > android/key.properties\n    echo \"keyPassword=${ secrets.KEY_PASSWORD }\" >> android/key.properties\n    echo \"keyAlias=${ secrets.KEY_ALIAS }\" >> android/key.properties\n    echo \"storeFile=keystore.jks\" >> android/key.properties\n```\n\n<div class=\"content-ad\"></div>\n\n설명: 이 단계에서는 애플리케이션을 서명하는 데 필요한 속성을 갖는 key.properties 파일이 생성됩니다. 이러한 속성은 GitHub 저장소에 저장된 비밀 정보를 사용하여 채워집니다.\n\n# 6. APK 빌드\n\n```js\n- name: APK 빌드\n  run: flutter build apk --release\n```\n\n설명: 이 단계에서는 flutter build apk --release 명령어를 사용하여 Flutter 애플리케이션의 APK를 릴리스 모드로 빌드합니다.\n\n<div class=\"content-ad\"></div>\n\n# 7. 앱 번들 빌드\n\n```yaml\n- name: 앱 번들 빌드 실행\n  run: flutter build appbundle\n```\n\n설명: 이 단계는 flutter build appbundle 명령어를 사용하여 Flutter 애플리케이션의 Android 앱 번들(AAB)을 빌드합니다.\n\n# 8. IPA 빌드(iOS 빌드)\n\n<div class=\"content-ad\"></div>\n\n```yaml\n- 이름: IPA 빌드\n  실행: flutter build ipa --no-codesign\n```\n\n설명: 이 단계는 flutter build ipa --no-codesign 명령을 사용하여 코드 서명 없이 iOS 애플리케이션을 위한 IPA 파일을 빌드합니다. --no-codesign 플래그를 사용하면 로컬 개발을 위해 유효한 Apple 개발자 계정이 필요하지 않고 IPA를 빌드할 수 있습니다.\n\n# 9. 아카이브와 IPA 압축\n\n```yaml\n- 이름: 아카이브 및 IPA 압축\n  실행: |\n    cd build\n    tar -czf ios_build.tar.gz ios\n```\n\n<div class=\"content-ad\"></div>\n\n# 10. 아티팩트 업로드\n\n```js\n- name: 아티팩트 업로드\n  uses: actions/upload-artifact@v2\n  with:\n    name: 릴리즈\n    path: |\n      build/app/outputs/flutter-apk/app-release.apk\n      build/app/outputs/bundle/release/app-release.aab\n      build/ios_build.tar.gz\n```\n\n설명: 이 단계는 iOS 빌드 디렉토리를 tar.gz 파일로 압축하여 저장 및 전송을 쉽게합니다. 이 단계는 upload-artifact 작업을 사용하여 빌드 아티팩트 (APK, AAB 및 압축된 iOS 빌드)를 업로드하여 나중에 다운로드할 수 있게 합니다. 이를 통해 빌드 출력물을 GitHub Actions 실행 페이지에서 액세스할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 11. 버전 추출\n\n```js\n- name: pubspec.yaml에서 버전 추출\n  id: extract_version\n  run: |\n    version=$(grep '^version: ' pubspec.yaml | cut -d ' ' -f 2 | tr -d '\\r')\n    echo \"VERSION=$version\" >> $GITHUB_ENV\n```\n\n설명: 이 단계는 pubspec.yaml 파일에서 버전 번호를 추출하고 환경 변수로 설정합니다. grep 명령은 버전 라인을 검색하여 버전 번호를 추출하고 이를 VERSION 환경 변수에 저장합니다.\n\n# 12. 태그의 존재 여부 확인\n\n<div class=\"content-ad\"></div>\n\n```yaml\n- name: 태그 여부 확인\n  id: check_tag\n  run: |\n    if git rev-parse \"v${ env.VERSION }\" >/dev/null 2>&1; then\n      echo \"TAG_EXISTS=true\" >> $GITHUB_ENV\n    else\n      echo \"TAG_EXISTS=false\" >> $GITHUB_ENV\n    fi\n```\n\n설명: 이 단계는 저장소에 버전 태그가 이미 존재하는지 확인합니다. 태그가 있으면 TAG_EXISTS 환경 변수를 true로 설정하고, 그렇지 않으면 false로 설정합니다.\n\n# 13. 태그 수정하기 (태그가 존재하는 경우)\n\n```yaml\n- name: 태그 수정\n  if: env.TAG_EXISTS == 'true'\n  id: modify_tag\n  run: |\n    new_version=\"${ env.VERSION }-build-${ github.run_number }\"\n    echo \"VERSION=$new_version\" >> $GITHUB_ENV\n```\n\n<div class=\"content-ad\"></div>\n\n설명: 이 단계에서는 이미 있는 태그인 경우, 버전 태그를 수정하여 버전 번호에 -build-`run_number`를 추가하여 고유 식별자가 포함되도록 합니다. 이렇게 하면 태그가 고유하게 유지되고 충돌을 피할 수 있습니다.\n\n# 14. 릴리스 생성\n\n```yaml\n- name: 릴리스 생성\n  uses: ncipollo/release-action@v1\n  with:\n    artifacts: \"build/app/outputs/flutter-apk/app-release.apk,build/app/outputs/bundle/release/app-release.aab,build/ios_build.tar.gz\"\n    tag: v${ env.VERSION }\n    token: ${ secrets.TOKEN }\n```\n\n설명: 이 단계에서는 ncipollo/release-action을 사용하여 지정된 아티팩트로 GitHub 릴리스를 생성합니다. (필요한 경우 수정된) 버전을 태그로 사용하고 GitHub 시크릿에 저장된 토큰을 인증에 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n# 마법을 볼 준비가 되셨나요?\n\n```js\n$ get add .\n$ git commit -m \"test github actions\" \n$ git push -u origin dev\n```\n\n- 변경 사항을 dev 브랜치에 푸시하고 작동하는지 확인해 보세요.\n- 레포지토리의 Actions 탭으로 이동해서 확인해 보세요.\n\n![이미지](/assets/img/2024-06-23-AutomatingFlutterBuildswithGitHubActionsAStep-by-StepGuide_8.png)\n\n<div class=\"content-ad\"></div>\n\n# 완성된 Workflow 코드\n\n중요한 메모: 들여쓰기가 중요하니 주의하세요\n\n```js\nname: \"Build\"\n\non:\n  pull_request:\n    branches:\n      - dev\n      - test\n  push:\n    branches:\n      - dev\n      - test\n\njobs:  \n  build:      \n    name: Build & Release \n    runs-on: macos-latest \n\n    steps:\n        #1 저장소 체크아웃\n      - name: 저장소 체크아웃\n        uses: actions/checkout@v3\n\n        #2 Java 설정\n      - name: Java 설정\n        uses: actions/setup-java@v3.12.0\n        with:\n          distribution: 'oracle'\n          java-version: '17'\n\n        #3 Flutter 설정\n      - name: Flutter 설정\n        uses: subosito/flutter-action@v2\n        with:\n          flutter-version: '3.22.2'\n          channel: 'stable'\n\n        #4 종속성 설치\n      - name: 종속성 설치\n        run: flutter pub get\n\n        #5 Keystore 설정\n      - name: Keystore 디코딩\n        run: |\n          echo \"${ secrets.KEYSTORE_BASE64 }\" | base64 --decode > android/app/keystore.jks\n          \n      - name: key.properties 생성\n        run: |\n          echo \"storePassword=${ secrets.KEYSTORE_PASSWORD }\" > android/key.properties\n          echo \"keyPassword=${ secrets.KEY_PASSWORD }\" >> android/key.properties\n          echo \"keyAlias=${ secrets.KEY_ALIAS }\" >> android/key.properties\n          echo \"storeFile=keystore.jks\" >> android/key.properties\n        \n       #6 APK 빌드\n      - name: APK 빌드\n        run: flutter build apk --release\n\n        #7 App Bundle (aab) 빌드\n      - name: App Bundle 빌드\n        run: flutter build appbundle\n\n        #8 IPA 빌드 (iOS 빌드)\n      - name: IPA 빌드\n        run: flutter build ipa --no-codesign\n\n      - name: 아카이브 및 IPA 압축\n        run: |\n          cd build\n          tar -czf ios_build.tar.gz ios\n\n        #9 아티팩트 업로드\n      - name: 아티팩트 업로드\n        uses: actions/upload-artifact@v2\n        with:\n          name: 릴리스\n          path: |\n            build/app/outputs/flutter-apk/app-release.apk\n            build/app/outputs/bundle/release/app-release.aab\n            build/ios_build.tar.gz\n\n        #10 버전 추출\n      - name: pubspec.yaml에서 버전 추출\n        id: extract_version\n        run: |\n          version=$(grep '^version: ' pubspec.yaml | cut -d ' ' -f 2 | tr -d '\\r')\n          echo \"VERSION=$version\" >> $GITHUB_ENV\n\n        #11 태그 확인\n      - name: 태그 확인\n        id: check_tag\n        run: |\n          if git rev-parse \"v${ env.VERSION }\" >/dev/null 2>&1; then\n            echo \"TAG_EXISTS=true\" >> $GITHUB_ENV\n          else\n            echo \"TAG_EXISTS=false\" >> $GITHUB_ENV\n          fi\n\n        #12 태그 수정\n      - name: 태그 수정\n        if: env.TAG_EXISTS == 'true'\n        id: modify_tag\n        run: |\n          new_version=\"${ env.VERSION }-build-${ github.run_number }\"\n          echo \"VERSION=$new_version\" >> $GITHUB_ENV\n        \n        #13 릴리스 생성\n      - name: 릴리스 생성\n        uses: ncipollo/release-action@v1\n        with:\n          artifacts: \"build/app/outputs/flutter-apk/app-release.apk,build/app/outputs/bundle/release/app-release.aab,build/ios_build.tar.gz\"\n          tag: v${ env.VERSION }\n          token: ${ secrets.TOKEN }\n```\n\n위 단계를 따라 완성된 Workflow 코드를 사용하면 Flutter 빌드 및 릴리스 프로세스를 자동화하여 CI/CD 파이프라인에서 일관성과 효율성을 확보할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 이제 첫 CI/CD 워크플로를 만들었어요, 축하드려요 🥳🥳","ogImage":{"url":"/assets/img/2024-06-23-AutomatingFlutterBuildswithGitHubActionsAStep-by-StepGuide_0.png"},"coverImage":"/assets/img/2024-06-23-AutomatingFlutterBuildswithGitHubActionsAStep-by-StepGuide_0.png","tag":["Tech"],"readingTime":12},{"title":"반응형 웹 애플리케이션 개발하는 방법","description":"","date":"2024-06-22 16:00","slug":"2024-06-22-HowtoDevelopResponsiveWebApplication","content":"\n\n휴대전화는 온라인 쇼핑, 기사 읽기 등의 작업을 수행하는 데 노트북과 컴퓨터를 대체하기 시작했습니다. 데스크탑에 로그인해서 인터넷에 접속하던 시대는 사라졌어요. 대신, 현대적인 방식은 모바일 폰을 통해 웹을 탐색하는 것이에요.\n\n그래서 반응형 웹사이트를 개발하는 것이 중요해요. 웹사이트를 방문하는 모든 사용자에게 콘텐츠를 제공하기 위해서는 모바일폰이나 다른 장치를 통해 웹사이트에 방문하는 사용자에게 콘텐츠를 제공하는 것이 필요해요.\n\n반응형 웹 앱이 유행 중이에요. 웹사이트나 웹 앱이 모든 화면에서 완벽하게 기능하고 멋있게 보이도록 하는 디자인 접근 방법이에요. 이를 위해 유동적인 레이아웃과 미디어 쿼리를 사용할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n그래서 의문이 생깁니다. 반응형 웹 앱을 개발하는 방법은 무엇일까요? 걱정 마세요. 이 글은 반응형 웹 앱을 구축하는 방법에 대한 완벽한 가이드입니다. 자세히 알아봅시다.\n\n# 단계별 가이드: 반응형 웹 앱 개발 방법\n\n반응형 디자인의 필요성을 이해한 후 이제 반응형 웹 앱을 만드는 방법을 이해해 보겠습니다:\n\n## 1. Viewport 메타 태그 사용하기\n\n<div class=\"content-ad\"></div>\n\n반응형 웹 앱을 개발하기 위한 주요 단계는 웹 사이트를 설정하는 것입니다. 웹 사이트는 다양한 기기에서 볼 수 있습니다. 개발자들은 HTML 문서의 헤드 섹션에 뷰포트 메타 태그를 작성합니다. 이 태그는 브라우저에게 웹 페이지를 어떻게 표시해야 하는지 알려줍니다. 화면 크기, 방향, 그리고 로드된 기기의 해상도에 따라 조정합니다.\n\n뷰포트 메타 태그에는 두 가지 다른 부분이 있습니다. 높이와 너비, 그리고 스케일 값이 있습니다. 높이와 너비는 모바일 브라우저에게 특정 장치에서 페이지를 로드하는 데 얼마나 커야 하는지 알려줍니다. 예를 들어, 페이지가 500픽셀 너비여야 한다면 \"width=500\"으로 설정하세요.\n\n헤드 섹션에 뷰포트 메타 태그를 설정하는 예시입니다:\n\n## 2. 미디어 쿼리 사용하기\n\n<div class=\"content-ad\"></div>\n\n미디어 쿼리를 사용하면 모바일 브라우저가 기기의 화면 크기에 따라 웹 페이지를 어떻게 표시해야 하는지 알 수 있습니다. 예를 들어, 휴대폰과 데스크톱에서 웹 앱을 사용할 때 너비와 높이가 변경됩니다. CSS 파일에 추가된 간단한 코드 라인은 화면 크기에 따라 너비를 변경하는 예시입니다:\n\n```css\n@media only screen and (max-width:320px) {\n.header {\nwidth: 100%;\n}\n}\n```\n\n뷰포트 메타 태그를 사용하면 웹 페이지의 기본 크기를 설정할 수 있습니다. 그러나 다양한 기기에서 나타나는 방식을 변경하는 데 도움을 줄 수는 없습니다. 그것이 바로 미디어 쿼리가 나오는 곳입니다. 미디어 쿼리는 특정 화면 크기, 해상도 및 방향을 대상으로 하는 CSS 규칙입니다.\n\n```css\n@media only screen and (max-width:320px) {\n.header {\nwidth: 100%;\n}\n}\n```\n\n<div class=\"content-ad\"></div>\n\n미디어 쿼리를 사용하면 화면 크기 및 방향에 따라 HTML 문서의 레이아웃을 사용자 정의할 수 있어요. 예를 들어, 모바일 전화기용 스타일 세트나 태블릿, 데스크탑 등 다른 기기용 세트가 있다면, CSS에 미디어 쿼리를 추가하여 각 스타일 세트를 언제 적용할지 지정할 수 있어요.\n\n## 3. 유동 레이아웃을 사용하여 반응형 추가\n\n반응형 웹사이트는 유동 레이아웃 기술을 사용하여 자동으로 크기를 조절하고 다양한 화면 방향 및 크기에 맞추도록 만들어져요. 픽셀과 같은 고정 값 대신 em이나 백분율과 같은 상대 단위를 사용하여 프로젝트 요구에 따라 크기를 늘리거나 줄일 수 있어요.\n\n이것은 굉장히 중요해요! 왜냐하면 이렇게 함으로써 여러분의 사이트는 모든 기기 화면에 잘 어울리고 잘 보일 거예요. 그래서 시각적으로 매력적이고 다양한 화면 크기에 적합한 것에 집중할 수 있어요. 결국 돈과 시간을 절약할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n## 4. 반응형 이미지\n\n반응형 이미지 추가하기는 RWA를 구축하는 중요한 부분입니다. 이러한 이미지는 웹사이트를 보여주는 기기에 따라 다양한 크기의 이미지를 표시하여 화면 크기에 관계없이 항상 적합하게 보이도록 합니다. 제품 이미지와 같은 용도로 특히 유용하며, 보통 웹사이트에서 다양한 크기로 사용되는 경우가 많습니다.\n\n반응형 이미지를 사용하여 반응형 사이트를 구축하면 이미지가 다양한 화면 크기에 맞게 자동으로 크기를 조절합니다. 이러한 이미지는 picturefill 또는 srcset이라고도 불리며, 브라우저의 너비를 확인하고 같은 이미지의 다른 버전을 표시하는 방식으로 작동합니다. 따라서 누군가가 스마트폰을 사용하여 웹사이트를 둘러볼 때 무거운 이미지를 불러오는 데 더 많은 시간이 걸릴 수 있습니다.\n\n## 5. 모바일 서브도메인\n\n<div class=\"content-ad\"></div>\n\n모바일 서브도메인을 사용하는 것은 정말 좋은 아이디어에요, 특히 웹사이트의 다양한 모바일 버전을 개발할 때 더욱 유용해요. 이를 위해 2개의 서브도메인을 만들거나 Cloudflare 같은 도구(무료)를 사용하여 다른 서버 호스팅을 설정할 수 있어요.\n\n하지만, 이것은 다른 웹사이트를 개발해야 한다는 의미는 아니에요. 스마트폰 기기에서 더 좋은 사용자 경험을 제공하고 싶다면 노력하는 것이 가치가 있어요.\n\n## 6. 여러 화면 크기에서 웹사이트 테스트하기\n\n웹사이트가 다양한 화면 크기에서 어떻게 동작하는지 테스트하는 다양한 방법이 있어요. 가장 간단한 방법은 브라우저를 열어서 원하는 크기로 크기를 조정하고, 마지막으로 페이지를 새로고침하는 것이에요.\n\n<div class=\"content-ad\"></div>\n\n사람들이 인터넷에 접속할 때 점점 더 태블릿과 스마트폰을 사용하기 때문에 웹사이트가 사용자 친화적인지 확인해야 합니다. Google의 모바일 친화성 테스트를 사용하여 사이트가 다양한 화면 크기에서 어떻게 보이는지 알 수 있습니다. 웹사이트에 문제가 있고 모바일 친화적이지 않다면, 업데이트하는 과정을 살펴보아야 합니다.\n\n# 최종 판단\n\n이 기사가 반응형 디자인이 무엇인지, 반응형 웹 앱을 개발하는 방법, 그리고 궁극적으로 앱을 사용자 친화적으로 만드는 데 어떻게 도움이 되었는지 아마 조금이라도 도움이 되었길 바라겠습니다. 반응형 사이트를 만드는 데 자신감이 생기실 것입니다.\n\n전문가들은 상기한 단계를 사용하여 웹사이트를 더 사용자 친화적이고 성능이 우수한 것으로 만듭니다. 초보자들은 반응형 사이트를 구축하는 것이 어려운 작업일 수 있습니다. 그러나 이 프로세스에 집중하면 결실을 맺을 것입니다. 또한, 확장 가능한 JS와 CSS를 이해하면 웹사이트를 만들 때 모든 사용자에게 접근 가능한 것으로 만들어 진정으로 사용자들에게 도달하는 웹사이트를 만드는 것이 쉬워질 것입니다.\n\n<div class=\"content-ad\"></div>\n\n이를 통해 반응형 웹 앱을 만들기 위해 따라야 할 기본 단계를 이해했기를 희망합니다. 향후 업데이트에 대비해 즐겨찾기에 추가해 두세요. 그동안 즐거운 독서 시간 보내세요!","ogImage":{"url":"/assets/img/2024-06-22-HowtoDevelopResponsiveWebApplication_0.png"},"coverImage":"/assets/img/2024-06-22-HowtoDevelopResponsiveWebApplication_0.png","tag":["Tech"],"readingTime":4}],"page":"4","totalPageCount":29,"totalPageGroupCount":2,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}