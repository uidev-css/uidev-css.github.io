{"pageProps":{"posts":[{"title":"플러터와 다트에서 코드 난독화 신비로운 코드 이해하기","description":"","date":"2024-06-21 20:49","slug":"2024-06-21-ObfuscationinFlutterandDartMysteriouscodes","content":"\n\n![image](/assets/img/2024-06-21-ObfuscationinFlutterandDartMysteriouscodes_0.png)\n\n안녕하세요, 이 글에서는 플러터와 다트 코드 난독화, 플러터의 중요한 주제 중 하나를 배우게 됩니다.\n\n먼저, 난독화가 무엇인지 알아보겠습니다.\n\n난독화는 코드를 사람이 해독할 수 없도록 만드는 과정입니다. 이는 역공학 공격을 어렵게 만들어서 애플리케이션의 보안을 높이기 위해 사용됩니다. 플러터와 다트는 난독화를 위한 일부 내장 도구와 방법을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n# 왜 난독화를 사용해야 하나요?\n\n- 보안: 코드를 알아보기 어렵게 만들어 악의적 사용자가 코드를 이해하고 남용하는 것을 어렵게 합니다.\n- 지적 재산권: 코드를 보호하여 지적 재산권을 안전하게 지킵니다.\n- 용량 감소: 어떤 경우에는 난독화가 코드의 크기를 줄이는 데 도움이 될 수도 있습니다.\n\n시작해봅시다! 🥷🏻\n\n- 플러터 프로젝트를 만들어보세요.\n\n<div class=\"content-ad\"></div>\n\n\n```js\nflutter create my_app\ncd my_app\n```\n\n2. 프로젝트 구조화\n\n난독화를 활성화하려면 flutter 빌드 명령에 몇 가지 추가 매개변수를 추가해야 합니다. Android 및 iOS 모두를 위해 난독화하는 방법을 살펴보겠습니다.\n\nAndroid용으로는;\n\n\n<div class=\"content-ad\"></div>\n\n- android/app/build.gradle 파일을 열어주세요.\n- buildTypes 섹션에서 릴리스 구성을 다음과 같이 업데이트해주세요:\n\n```js\nandroid {\n    ...\n    buildTypes {\n        release {\n            ...\n            minifyEnabled true\n            shrinkResources true\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n}\n```\n\n- Proguard 규칙을 지정하려면 android/app/proguard-rules.pro 파일을 생성하고 다음 줄을 추가해주세요:\n\n```js\n# Flutter 난독화\n-ignorewarnings\n-keep class io.flutter.app.** { *; }\n-keep class io.flutter.plugin.** { *; }\n-keep class io.flutter.util.** { *; }\n-keep class io.flutter.view.** { *; }\n-keep class io.flutter.embedding.** { *; }\n-keep class io.flutter.embedding.engine.** { *; }\n-keep class io.flutter.embedding.android.** { *; }\n-keep class io.flutter.embedding.engine.plugins.** { *; }\n-keep class io.flutter.plugin.common.** { *; }\n-keep class io.flutter.plugin.platform.** { *; }\n```\n\n<div class=\"content-ad\"></div>\n\niOS에서는 다음을 수행하실 수 있습니다:\n\n- Open theios/Runner.xcodeproj 파일을 엽니다.\n- 빌드 설정 섹션에서 'Other Swift Flags' 설정을 찾아서 -D DART_OBFUSCATION을 추가합니다.\n\n3. 난독화된 애플리케이션 컴파일\n\n다음 명령어를 사용하여 Android 및 iOS용 난독화된 빌드를 생성합니다:\n\n<div class=\"content-ad\"></div>\n\n안드로이드:\n\n```js\nflutter build apk --release --obfuscate --split-debug-info=./build_info\n```\n\niOS:\n\n```js\nflutter build ios --release --obfuscate --split-debug-info=./build_info\n```\n\n<div class=\"content-ad\"></div>\n\n이 명령어들은 난독화된 코드의 디버그 정보 파일을 지정된 디렉토리에 넣습니다. 이 파일들은 디버깅 및 충돌 보고서 해결에 중요합니다.\n\n4. 애플리케이션 파일 검토\n\n난독화 프로세스의 결과물인 APK 또는 IPA 파일을 열어 코드가 숨겨져 있는지 확인할 수 있습니다. Android APK 파일을 검토하기 위해서는 apktool 또는 유사한 도구를 사용할 수 있습니다. iOS IPA 파일은 class-dump 또는 otool과 같은 도구를 사용할 수 있습니다.\n\n- Android APK 파일 검토:\napktool을 사용하여 APK 파일을 디컴파일합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\napktool d my_app.apk -o output_dir\n```\n\n- iOS IPA 파일을 조사해보세요:\nIPA 파일을 열고 Payload 디렉토리에서 응용 프로그램 파일을 추출하세요. class-dump나 otool을 사용하여 응용 프로그램 파일을 조사하세요.\n\n```js\nclass-dump -H MyApp -o output_dir\n```\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\n위의 단계를 따라 코드를 난독화하여 응용 프로그램의 안전성을 높일 수 있습니다. 이를 정기적으로 수행함으로써 응용 프로그램의 보안을 지속적으로 보호할 수 있습니다.\n\n독자 여러분, 읽어주셔서 감사합니다!\n새로운 기사에서 뵙겠습니다 💙\n\n제 계정을 여기에서 확인하고 질문을 하실 수 있습니다 ✨\n\n트위터에서 플러터 커뮤니티를 팔로우해보세요:\nhttps://www.twitter.com/FlutterComm","ogImage":{"url":"/assets/img/2024-06-21-ObfuscationinFlutterandDartMysteriouscodes_0.png"},"coverImage":"/assets/img/2024-06-21-ObfuscationinFlutterandDartMysteriouscodes_0.png","tag":["Tech"],"readingTime":3},{"title":"ThemeExtension으로 Flutter 맞춤 테마 만들기  템플릿 제공","description":"","date":"2024-06-21 20:46","slug":"2024-06-21-FlutterCustomThemewithThemeExtensionTemplates","content":"\n<img src=\"/assets/img/2024-06-21-FlutterCustomThemewithThemeExtensionTemplates_0.png\" />\n\n이 글에서는 ThemeExtensions를 사용하여 Flutter에서 사용자 정의 테마를 만드는 과정을 안내해 드리겠습니다. Color 및 TextStyle 확장을 위한 템플릿을 제공해 드릴 것이며, 내장 ColorScheme 및 TextTheme을 사용하지 않는 것을 권장하는 이유도 설명해 드리겠습니다(대부분의 경우 99%는 Material 사양을 따르지 않기 때문입니다).\n\n빠른 이동:\n\n- 문제점\n- 사용자 정의 색상 추가 방법\n- 밝은 모드와 어두운 모드 구현 방법\n- 사용자 정의 텍스트 스타일 추가 방법\n- Text 위젯에 대한 기본 TextStyle\n- 마무리(추가 링크)\n\n<div class=\"content-ad\"></div>\n\n## 문제\n\n새로운 Flutter 프로젝트를 시작할 때마다 앱에 재사용 가능한 스타일을 정의해야 합니다. 보통, 디자인 시스템에 기반한 스타일을 정의하며, 그것은 대개(사실은 절대로) Material입니다. TextStyle 토큰들(headlineLarge, bodyMedium, ...)은 Material 명명 규칙을 따르지 않습니다; 디자인 항목들은 팔레트(빨간색, 회색, ...)에서 색상을 사용하고, 색상 체계(accent, primary, background, ...)에서는 사용하지 않습니다. 이 모든 것을 살펴보고 Flutter 앱에 어떻게 적용해야 할지 모를 때가 있습니다.\n\n먼저, ThemeData를 확장하거나 고유한 사용자 정의 테마 클래스를 작성할 수 있다고 생각할 수 있지만, 그렇게 하지 마십시오. 이 기사에서 보여드리는 Flutter 앱에 자연스럽게 통합되는 훨씬 더 나은 방법이 있습니다(ThemeExtension). 하지만 먼저, 왜 내장된 Material ColorScheme 및 TextTheme에 디자인을 통합하기를 추천하지 않는지 살펴보겠습니다.\n\n## ColorScheme 및 TextTheme가 디자인에 적합하지 않은 이유\n\n<div class=\"content-ad\"></div>\n\n플러터는 전역 앱 테마를 설정하기 위해 ThemeData 클래스를 제공합니다. 이 클래스에는 여러 내장 위젯을 위한 많은 속성이 포함되어 있지만, 주요 속성은 ColorScheme과 TextTheme이라고 할 수 있어요. 이것들은 \"괜찮은\"데요, 하지만 여러분의 디자인이 머티리얼 사양을 따르는 경우에만 해당합니다. 그렇지 않으면 대부분의 경우, 디자인 시스템은 서로 다른 이름 및 색상 및 텍스트 스타일 토큰 수를 가지게 될 거에요.\n\n어쩌면 일부 색상 및 텍스트 스타일 토큰이 일치할 수도 있지만, 나머지는 일치하지 않을 수 있어요. 일부 토큰을 매핑해 볼 수도 있겠죠 (디자인: h1 - 코드: headlineLarge), 그리고 다른 토큰을 별도의 위치에 넣어 볼 수도 있어요 (ThemeExtension 또는 다른 곳). 하지만 이것은 좋은 해결책이 될 수 없어요. 이것은 이해하기 어려운 토큰 이름 매핑과 유지 및 수정이 어려운 앱 테마의 분산 선언으로 이어질 거에요. 왜 굳이 사용자 지정 디자인 시스템을 머티리얼에 넣으려고 하나요?\n\n그래서 나는 모든 사용자 지정 스타일을 완전히 제어할 수 있는 사용자 정의 ThemeExtension(s)에 넣으라고 권장해요. 혜택:\n\n- 필요한 속성을 추가, 이름 변경, 삭제할 수 있어요.\n- 머티리얼 사양이나 플러터 업데이트에 의존하지 않아요.\n- 모든 관련된 스타일이 1곳에 모이며 ColorScheme과 ExtraColorScheme 사이로 흩어지지 않아요.\n\n<div class=\"content-ad\"></div>\n\n게다가 GitHub Copilot 또는 제가 제공할 템플릿을 사용하면 매우 쉽게 작성할 수 있습니다.\n\n내가 여전히 Theme과 ThemeData를 사용하고 직접 클래스를 만들지 말 것을 추천하는 이유는 Flutter가 이미 이러한 클래스를 사용하여 필요한 모든 것을 갖추고 있기 때문입니다. UI 부분을 위한 테마 재정의, 내장 위젯의 기본 스타일링, 기본 텍스트 스타일 설정, 라이트 및 다크 모드 전환 지원 등이 모두 포함되어 있습니다. 이미 존재하는 것(ThemeExtensions)을 확장하는 것이 더 쉬울 때에는 직접 클래스를 작성할 필요가 없습니다.\n\n# Flutter에서 ThemeExtension을 사용하여 사용자 정의 색상 추가하는 방법\n\nFlutter 앱에 사용자 정의 색상을 추가하려면 3단계만 거치면 됩니다:\n\n<div class=\"content-ad\"></div>\n\n- 사용자 정의 색상 정의\n- 색상을 위한 ThemeExtension 생성\n- Light 및 Dark 모드를 위한 확장 기능 초기화\n\n## 단계 1: AppPalette\n\nAppPalette는 디자인 시스템에서 사용되는 색상 코드를 정의하는 클래스입니다. 복잡한 것은 아니며, 단순히 정적 속성을 가진 클래스일 뿐입니다:\n\n```js\nabstract class AppPalette {\n  // 빨강\n  static const red = Colors.red;\n  static const imperialRed = Color(0xFFE54B4B);\n\n  // 흰색\n  static const seashell = Color(0xFFF7EBE8);\n\n  // 회색\n  static const grey = _GreyColors();\n}\n\n/// 팔레트에서 색상을 그룹화하는 대체 방법.\n///\n/// 단점은 이러한 값들이 상수가 아니기 때문에\n/// 생성자 기본 값으로 사용할 수 없다는 것입니다.\n///\n/// 사용 예: `AppPalette.grey.grey50`.\nclass _GreyColors {\n  const _GreyColors();\n\n  final grey50 = const Color(0xFFFAFAFA);\n  final grey100 = const Color(0xFFF5F5F5);\n}\n```\n\n<div class=\"content-ad\"></div>\n\n노트:\n\n- AppPalette는 추상입니다. 왜냐하면 우리는 이를 실체화할 필요가 없기 때문입니다.\n- \\_GreyColors는 비공개입니다. 직접 액세스하는 것이 아니라 AppPalette를 통해서만 액세스를 허용합니다.\n\n## 단계 2: AppColorsExtension + 템플릿\n\n여기서는 테마 익스텐션을 정의하고 copyWith() 및 lerp() 메소드를 구현해야 합니다. 이 예제에서는 주요 및 배경 속성만 있는데도 간단한 작업에 대해 너무 많은 코드처럼 보일 수 있지만, 코드 생성 없이는 이를 해결할 방법이 없습니다. (링크는 엔딩 섹션에 있음).\n\n<div class=\"content-ad\"></div>\n\n```js\nclass AppColorsExtension extends ThemeExtension<AppColorsExtension> {\n  AppColorsExtension({\n    required this.primary,\n    required this.background,\n  });\n\n  final Color primary;\n  final Color background;\n\n  @override\n  ThemeExtension<AppColorsExtension> copyWith({\n    Color? primary,\n    Color? background,\n  }) {\n    return AppColorsExtension(\n      primary: primary ?? this.primary,\n      background: background ?? this.background,\n    );\n  }\n\n  @override\n  ThemeExtension<AppColorsExtension> lerp(\n    covariant ThemeExtension<AppColorsExtension>? other,\n    double t,\n  ) {\n    if (other is! AppColorsExtension) {\n      return this;\n    }\n\n    return AppColorsExtension(\n      primary: Color.lerp(primary, other.primary, t)!,\n      background: Color.lerp(background, other.background, t)!,\n    );\n  }\n}\n```\n\n참고:\n\n- lerp()는 다른 ThemeExtension 개체와 선형 보간을 수행하고 테마를 변경할 때 애니메이션을 만듭니다.\n\n전체 확장 템플릿 링크는 여기에 있습니다. 현재 내장 ColorScheme과 모든 속성이 동일하지만 필요에 맞게 추가, 이름 바꾸기 및 삭제할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n🔗 AppColorsExtension 템플릿\n\n## 단계 3: 밝은 모드와 어두운 모드\n\n이 단계는 다음 섹션에서 진행될 예정이에요 😅\n\n참고로, Chopper 요청에 HTTP Authorization 헤더를 추가하고 401 Unauthorized 응답일 때 재시도하는 방법에 대한 제 다른 글도 확인해보시기를 추천해요.\n\n<div class=\"content-ad\"></div>\n\n이제 다시 플러터 테마링으로 돌아왔어요! 🙂\n\n# 플러터에서 라이트 모드와 다크 모드를 구현하는 방법\n\n다시 한 번, 3가지 간단한 단계만 따르면 돼요:\n\n- 라이트와 다크 테마 데이터를 정의하세요.\n- MaterialApp에 그 데이터들을 전달하세요.\n- MaterialApp에 올바른 ThemeMode를 전달하세요.\n\n<div class=\"content-ad\"></div>\n\n## 단계 1: App 테마\n\n이 클래스는 ThemeExtensions와 테마 모드를 프로그래밍적으로 전환할 수 있는 기능을 가진 라이트 및 다크 모드용 Flutter ThemeData 게터를 포함하고 있습니다. 우선 게터를 구현해봅시다.\n\n```js\nclass AppTheme {\n  //\n  // 라이트 테마\n  //\n\n  static final light = ThemeData.light().copyWith(\n    extensions: [\n      _lightAppColors,\n    ],\n  );\n\n  static final _lightAppColors = AppColorsExtension(\n    primary: const Color(0xff6200ee),\n    onPrimary: Colors.white,\n    secondary: const Color(0xff03dac6),\n    onSecondary: Colors.black,\n    error: const Color(0xffb00020),\n    onError: Colors.white,\n    background: Colors.white,\n    onBackground: Colors.black,\n    surface: Colors.white,\n    onSurface: Colors.black,\n  );\n\n  //\n  // 다크 테마\n  //\n\n  static final dark = ThemeData.dark().copyWith(\n    extensions: [\n      _darkAppColors,\n    ],\n  );\n\n  static final _darkAppColors = AppColorsExtension(\n    primary: const Color(0xffbb86fc),\n    onPrimary: Colors.black,\n    secondary: const Color(0xff03dac6),\n    onSecondary: Colors.black,\n    error: const Color(0xffcf6679),\n    onError: Colors.black,\n    background: const Color(0xff121212),\n    onBackground: Colors.white,\n    surface: const Color(0xff121212),\n    onSurface: Colors.white,\n  );\n}\n```\n\n참고:\n\n<div class=\"content-ad\"></div>\n\n- 여기서는 템플릿에서 AppColorsExtension의 전체 버전을 사용했습니다.\n\n❗중요. 공식 문서에서는 다음과 같이 확장을 액세스합니다: Theme.of(context).extension`MyColors`()! 하지만 이것은 너무 길고 사용하기 어려울 수 있습니다. Dart 확장 메서드의 강력함을 활용하는 좋은 솔루션이 없다는 것이 안타깝습니다.\n\n```js\nextension AppThemeExtension on ThemeData {\n  /// 사용 예시: Theme.of(context).appColors;\n  AppColorsExtension get appColors =>\n      extension<AppColorsExtension>() ?? AppTheme._lightAppColors;\n}\n```\n\n참고:\n\n<div class=\"content-ad\"></div>\n\n- 만약 이 확장 기능이 AppTheme.\\_lightAppColors에 액세스해야 한다면 AppTheme과 같은 파일에 작성되어야 합니다.\n\n❗또 하나의 개선점입니다. 매번 Theme.of(context)를 작성하는 것이 너무 길 수 있으므로 BuildContext에 다른 확장 메소드를 추가하는 것을 선호합니다:\n\n```js\nextension ThemeGetter on BuildContext {\n  // 사용 예: `context.theme`\n  ThemeData get theme => Theme.of(this);\n}\n```\n\n최종 사용 방법은 다음과 같습니다: context.theme.appColors. 멋지죠? ✨ 추가로 유용한 확장 기능은 'Flutter에서 누락된 확장 기능'에 대한 제 논문에서 찾아볼 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n## 단계 2-3: 플러터에서 라이트 모드와 다크 모드 전환하는 방법\n\n플러터에서 라이트 모드와 다크 모드를 전환하려면 MaterialApp에서 theme 및 darkTheme 속성을 지정해야 합니다. 또한 앱의 현재 테마 모드를 결정하는 themeMode 속성도 제공해야 합니다. ThemeMode은 3가지 옵션을 가지고 있는 enum입니다:\n\n- ThemeMode.light\n- ThemeMode.dark\n- ThemeMode.system\n\n상태 관리를 위해 저는 ChangeNotifier를 사용했습니다. 더 복잡한 것을 사용할 필요가 없어서입니다. 나중에 BuildContext 없이 ThemeMode를 변경해야 할 경우 get_it 또는 사용하는 다른 패키지에 이 클래스를 등록할 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nclass AppTheme with ChangeNotifier {\n  ThemeMode _themeMode = ThemeMode.system;\n\n  ThemeMode get themeMode => _themeMode;\n\n  set themeMode(ThemeMode themeMode) {\n    _themeMode = themeMode;\n    notifyListeners();\n  }\n\n  ...\n}\n```\n\n이제 MaterialApp에 넣어 봅시다:\n\n```js\nvoid main() {\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return ChangeNotifierProvider(\n      // 1. MaterialApp 위에 AppTheme를 제공하여\n      // 모든 페이지에서 사용할 수 있습니다.\n      create: (_) => AppTheme(),\n      builder: (context, _) => MaterialApp(\n        title: 'Flutter Demo',\n        // 2. 라이트 테마를 제공합니다.\n        theme: AppTheme.light,\n        // 3. 다크 테마를 제공합니다.\n        darkTheme: AppTheme.dark,\n        // 4. AppTheme 변경 사항 (ThemeMode)을 감시합니다.\n        themeMode: context.watch<AppTheme>().themeMode,\n        debugShowCheckedModeBanner: false,\n        home: const MyHomePage(title: 'Flutter Demo Home Page'),\n      ),\n    );\n  }\n}\n```\n\n참고:\n\n<div class=\"content-ad\"></div>\n\n- ChangeNotifierProvider은 provider 패키지에서 제공됩니다. 이미 알고 계실 거라 믿어요 😅\n\n테마모드를 업데이트해보세요:\n\n```js\nvoid darkMode() {\n  context.read<AppTheme>().themeMode = ThemeMode.dark;\n}\n```\n\n축하합니다 🎉 ThemeExtension을 사용하여 사용자 정의 앱 테마를 만드셨군요. 이제는 커스텀 텍스트 스타일도 추가해볼까요?\n\n<div class=\"content-ad\"></div>\n\n# 플러터에서 ThemeExtension을 사용하여 사용자 지정 텍스트 스타일 추가하는 방법\n\n텍스트 스타일은 라이트 모드와 다크 모드 사이에 변경되지 않기 때문에 대부분의 경우, 테마 확장을 생성할 필요가 없고 간단한 const TextStyle 선언이 충분합니다. 그러나 두 가지 방법을 모두 보여드리겠습니다. 두 단계만으로 완성됩니다.\n\n## 단계 1: AppTypography\n\n이 클래스는 AppPalette와 동일한 용도로 사용되며 코드에서 디자인의 스타일을 정의합니다.\n\n<div class=\"content-ad\"></div>\n\n추상 클래스 AppTypography {\n고정된 body1 = TextStyle(\nfontSize: 16,\nfontWeight: FontWeight.normal,\n);\n\n고정된 h1 = TextStyle(\nfontSize: 96,\nfontWeight: FontWeight.w300,\n);\n}\n\n참고:\n\n- 만일 색상을 추가 클래스와 함께 그룹화하는 두 번째 방법이 마음에 들었다면, 이곳에서도 사용할 수 있습니다.\n\n이제 이러한 스타일을 다음과 같이 사용할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nstyle: AppTypography.h1.copyWith(color: context.theme.appColors.error)\n```\n\n## 플러터에서 Text 위젯을 위한 기본 TextStyle\n\nText 위젯을 위한 기본 TextStyle을 설정하려면 TextTheme에서 bodyMedium을 설정해야 합니다. 다음은 예제입니다:\n\n```js\nstatic final light = () {\n    final defaultTheme = ThemeData.light();\n\n    return defaultTheme.copyWith(\n      textTheme: defaultTheme.textTheme.copyWith(\n        // 참고: Text 위젯을 위한 기본 텍스트 스타일\n        bodyMedium: AppTypography.body1.copyWith(color: Colors.black),\n      ),\n      extensions: [\n        _lightAppColors,\n      ],\n    );\n  }();\n```\n\n<div class=\"content-ad\"></div>\n\n## 단계 2: AppTextThemeExtension + 템플릿\n\n텍스트 스타일을 위한 ThemeExtension을 생성하려면 색상과 같은 방법을 따라야합니다.\n\n```js\nclass AppTextTheme extends ThemeExtension<AppTextTheme> {\n  const AppTextTheme({\n    required this.body1,\n    required this.h1,\n  });\n\n  final TextStyle body1;\n  final TextStyle h1;\n\n  @override\n    ThemeExtension<AppTextTheme> copyWith({\n    TextStyle? body1,\n    TextStyle? h1,\n  }) {\n    return AppTextTheme(\n      body1: body1 ?? this.body1,\n      h1: h1 ?? this.h1,\n    );\n  }\n\n  @override\n  ThemeExtension<AppTextTheme> lerp(\n    covariant ThemeExtension<AppTextTheme>? other,\n    double t,\n  ) {\n    if (other is! AppTextTheme) {\n      return this;\n    }\n\n    return AppTextTheme(\n      body1: TextStyle.lerp(body1, other.body1, t)!,\n      h1: TextStyle.lerp(h1, other.h1, t)!,\n    );\n  }\n}\n```\n\n위는 간단한 예제이지만, 여기에서는 내장된 TextTheme과 동일한 모든 (사용되지 않는) 속성을 갖춘 전체 템플릿을 제공합니다. 필요한 대로 추가, 이름 변경, 삭제할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n🔗 AppTextThemeExtension 템플릿\n\n친구야! Light와 Dark ThemeData에 이 확장 프로그램을 추가하지 않도록 잊지 마세요:\n\n```js\nclass AppTheme with ChangeNotifier {\n\n  ...\n\n  static final light = () {\n    final defaultTheme = ThemeData.light();\n\n    return defaultTheme.copyWith(\n      textTheme: defaultTheme.textTheme.copyWith(\n        // 참고: Text 위젯에 대한 기본 텍스트 스타일입니다.\n        bodyMedium: AppTypography.body1.copyWith(color: Colors.black),\n      ),\n      extensions: [\n        _lightAppColors,\n        // 1. 여기\n        _lightTextTheme,\n      ],\n    );\n  }();\n\n  static final _lightAppColors = ...;\n\n  // 2. 여기\n  static final _lightTextTheme = AppTextThemeExtension(\n    body1: AppTypography.body1.copyWith(color: _lightAppColors.onBackground),\n    h1: AppTypography.h1.copyWith(color: Colors.black),\n  );\n\n  ...\n\n}\n\nextension AppThemeExtension on ThemeData {\n  AppColorsExtension get appColors =>\n      extension<AppColorsExtension>() ?? AppTheme._lightAppColors;\n\n  // 3. 그리고 여기\n  AppTextThemeExtension get appTextTheme =>\n      extension<AppTextThemeExtension>() ?? AppTheme._lightTextTheme;\n}\n```\n\n🎉 다시 한 번 축하드려요! 이제는 TextStyles에 대한 ThemeExtension이 생겼어요. 아래 전체 소스 코드를 확인해보세요.\n\n<div class=\"content-ad\"></div>\n\n# 마무리\n\n## 소스 코드\n\n템플릿:\n\n- 🔗 AppColorsExtension\n- 🔗 AppTextThemeExtension\n\n<div class=\"content-ad\"></div>\n\n풀 앱 예시:\n\n## 확장 가능한 부분\n\n- get_it이나 다른 패키지에 AppTheme을 등록하여 BuildContext 없이 액세스할 수 있습니다.\n- 선택한 ThemeMode를 shared_preferences에 저장합니다.\n\n## Flutter ThemeExtension 생성기\n\n<div class=\"content-ad\"></div>\n\n그 패키지는 ThemeExtension을 생성하는 것을 볼 수 있었지만, 나는 항상 최소한의 생성이 좋다고 생각해서 사용해보지는 않았어. 게다가, GitHub Copilot을 사용하면 필요한 보일러플레이트 코드를 쉽게 작성할 수 있어.\n\n## 더 많은 자료\n\n- 테마 문서.\n- ThemeExtension 문서.\n- DefaultTextStyle.merge() — 사용자 정의 위젯에서 기본 TextStyle을 처리하는 데 도움이 됨.\n\n읽어주셔서 감사합니다. 안녕 👋\n","ogImage":{"url":"/assets/img/2024-06-21-FlutterCustomThemewithThemeExtensionTemplates_0.png"},"coverImage":"/assets/img/2024-06-21-FlutterCustomThemewithThemeExtensionTemplates_0.png","tag":["Tech"],"readingTime":13},{"title":"안드로이드와 코틀린을 사용하여 모바일 애플리케이션에서 NFC 태그를 스캔하고 읽는 방법","description":"","date":"2024-06-21 20:44","slug":"2024-06-21-HowtoScanandReadNFCtagsinMobileapplicationusingAndroidKotlin","content":"\n\n\n![image](/assets/img/2024-06-21-HowtoScanandReadNFCtagsinMobileapplicationusingAndroidKotlin_0.png)\n\n- NFC 기술 소개\n- 안드로이드 기기에서 NFC 태그 스캔 기능 활성화\n- 안드로이드 프로젝트에 구현하는 기술 가이드 단계별 안내\n- 테스트\n- 결론\n\nNFC(Near Field Communication)는 두 기기가 짧은 거리를 통해 무선으로 데이터를 교환할 수 있는 기술입니다.\n\nNFC는 특히 모바일 기기에서 점점 인기를 끌고 있으며, 스마트폰과의 상호 작용 방식을 혁신적으로 바꿔놓았습니다. 또한, 접촉식 결제, 티켓 발권 및 출입 제어 등 다양한 애플리케이션에 사용될 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n이 가이드에서는 NFC의 세계에 심취하고 Android 및 Kotlin을 사용하여 모바일 애플리케이션에서 NFC 태그를 스캔하는 방법을 알아보겠습니다. 초보자든 숙련된 개발자든 상관없이, 이 포괄적인 자습서는 NFC의 기능을 앱 개발 프로젝트에서 활용하기 위한 지식과 도구를 제공할 것입니다.\n\n- 안드로이드 기기에서 NFC 태그를 활성화하려면 시스템 설정 -` 연결된 장치 -` 연결 기본값 -` NFC -` NFC 스위치를 켜십시오.\n- 그러나 NFC 설정으로 이동하는 경로는 모바일 브랜드에 따라 다를 수 있습니다. 그럴 경우 시스템 설정의 검색 바에서 NFC를 간단히 검색하십시오.\n\n![이미지](/assets/img/2024-06-21-HowtoScanandReadNFCtagsinMobileapplicationusingAndroidKotlin_1.png)\n\n본 자습서에서는 Kotlin을 사용하여 Android 모바일 앱에서 NFC 태그를 스캔하는 방법에 대해 단계별로 안내하겠습니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-21-HowtoScanandReadNFCtagsinMobileapplicationusingAndroidKotlin_2.png\" />\n\n안드로이드 앱에서 NFC를 사용하려면 AndroidManifest.xml 파일에 NFC 권한을 추가해야 합니다. 프로젝트의 AndroidManifest.xml 파일을 열고 아래와 같이 다음 줄을 추가하세요.\n\n```javascript\n<uses-permission android:name=\"android.permission.NFC\"/>\n```\n\nNFC 태그를 읽으려면 NFC 어댑터 클래스의 인스턴스를 생성해야 합니다.\n\n<div class=\"content-ad\"></div>\n\ngetSystemService() 메소드를 사용하여 이 작업을 수행할 수 있습니다. 아래 코드를 Activity의 onCreate() 메소드에 추가해보세요.\n\n```kotlin\nprivate lateinit var nfcAdapter: NfcAdapter\n\noverride fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    setContentView(R.layout.activity_main)\n    \n    // 기본 NFC 어댑터 가져오기\n    nfcAdapter = NfcAdapter.getDefaultAdapter(this)\n}\n```\n\nNFC 인텐트 필터는 앱이 읽을 수 있는 NFC 태그의 종류를 지정하는 방법입니다. 아래 코드를 Activity에 추가하여 NFC 인텐트 필터를 생성할 수 있습니다.\n\n```kotlin\nprivate fun createNFCIntentFilter(): Array<IntentFilter> {\n    val intentFilter = IntentFilter(NfcAdapter.ACTION_NDEF_DISCOVERED)\n    try {\n        intentFilter.addDataType(\"*/*\")\n    } catch (e: IntentFilter.MalformedMimeTypeException) {\n        throw RuntimeException(\"MIME 유형 추가에 실패하였습니다.\", e)\n    }\n    return arrayOf(intentFilter)\n}\n```\n\n<div class=\"content-ad\"></div>\n\nNFC 태그가 감지되면 Android 시스템은 앱에 NFC 인텐트를 보냅니다.\n\nNFC 인텐트를 처리하려면 Activity의 onNewIntent() 메소드를 오버라이드해야 합니다. 아래는 예시 코드 조각입니다.\n\n```js\noverride fun onNewIntent(intent: Intent) {\n    super.onNewIntent(intent)\n}\n```\n\n앱이 화면에 표시될 때 NFC 인텐트를 받기 위해 foreground dispatch를 활성화해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n이것은 당신의 앱이 NFC 인텐트를 먼저 받고, 처리할지 다른 앱으로 전달할지를 결정할 수 있음을 의미합니다.\n\nForeground 디스패치를 활성화하려면, 액티비티의 onResume() 메서드를 재정의하고 enableForegroundDispatch()를 호출해야 합니다. 마찬가지로, onPause() 메서드를 재정의하고 액티비티가 전경에 없을 때 foreground 디스패치를 비활성화하기 위해 disableForegroundDispatch()를 호출해야 합니다.\n\n다음은 foreground 디스패치를 활성화하고 비활성화하는 방법의 예시입니다:\n\n```js\noverride fun onResume() {\n    super.onResume()\n    val nfcAdapter = NfcAdapter.getDefaultAdapter(this)\n    val pendingIntent = PendingIntent.getActivity(\n        this, 0, Intent(this, javaClass).addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP), 0\n    )\n    val intentFilters = arrayOf<IntentFilter>(\n        IntentFilter(NfcAdapter.ACTION_NDEF_DISCOVERED),\n        IntentFilter(NfcAdapter.ACTION_TAG_DISCOVERED),\n        IntentFilter(NfcAdapter.ACTION_TECH_DISCOVERED)\n    )\n    nfcAdapter.enableForegroundDispatch(this, pendingIntent, intentFilters, null)\n}\n\noverride fun onPause() {\n    super.onPause()\n    val nfcAdapter = NfcAdapter.getDefaultAdapter(this)\n    nfcAdapter.disableForegroundDispatch(this)\n}\n```\n\n<div class=\"content-ad\"></div>\n\nonResume() 메서드에서는 기본 NfcAdapter를 가져와서 활동을위한 PendingIntent를 만듭니다. 또한 수신하려는 NFC 인텐트를 지정하는 IntentFilters 배열을 만듭니다. 그런 다음 NfcAdapter 인스턴스에 대해 enableForegroundDispatch()를 호출하고 PendingIntent 및 IntentFilters를 전달합니다.\n\nonPause() 메서드에서는 NfcAdapter 인스턴스에서 disableForegroundDispatch()를 호출하여 전경 디스패치를 비활성화합니다.\n\n전경 디스패치를 활성화 한 후에는 활동이 onNewIntent() 메서드에서 NFC 인텐트를 수신합니다. 그런 다음 NFC 태그 정보를 추출하고 적절히 처리할 수 있습니다.\n\n```js\noverride fun onNewIntent(intent: Intent?) {\n    super.onNewIntent(intent)\n    if (intent?.action == NfcAdapter.ACTION_TAG_DISCOVERED) {\n        val tag = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {\n            intent.getParcelableExtra(NfcAdapter.EXTRA_TAG, Tag::class.java)\n        } else {\n            intent.getParcelableExtra(NfcAdapter.EXTRA_TAG)\n        }\n        tag?.id?.let {\n            val tagValue = it.toHexString()\n            Toast.makeText(this, \"NFC tag detected: $tagValue\", Toast.LENGTH_SHORT).show()\n        }\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 예제에서는 NFC 인텐트가 ACTION_TAG_DISCOVERED인지 확인하여 NFC 태그가 감지되었는지 확인합니다. 그런 다음 getParcelableExtra() 메서드를 사용하여 인텐트에서 태그 객체를 추출하고 toHexString() 확장 함수를 사용하여 태그 ID를 16진수 문자열로 변환합니다. 마지막으로, 태그 ID와 함께 토스트 메시지를 표시합니다.\n\ntoHexString()이라는 확장 함수를 만들어 Tag ID를 16진수 문자열로 변환했습니다.\n\n```kotlin\nfun ByteArray.toHexString(): String {\n    val hexChars = \"0123456789ABCDEF\"\n    val result = StringBuilder(size * 2)\n\n    map { byte ->\n        val value = byte.toInt()\n        val hexChar1 = hexChars[value shr 4 and 0x0F]\n        val hexChar2 = hexChars[value and 0x0F]\n        result.append(hexChar1)\n        result.append(hexChar2)\n    }\n\n    return result.toString()\n}\n```\n\n이제 NFC 스캔 기능을 구현했으니, 실제 장치에서 테스트해보는 시간입니다. 장치에서 NFC가 활성화되어 있고 근처에 NFC 태그가 있는지 확인하세요. 앱을 실행하고 NFC 태그를 장치에 가까이 가져가보세요. 태그 ID가 표시된 토스트 메시지가 나타날 것입니다.\n\n<div class=\"content-ad\"></div>\n\n축하합니다! 안드로이드 앱에 NFC 스캔 기능을 성공적으로 구현하셨다고 가정합니다.\n\n![NFC scanning](/assets/img/2024-06-21-HowtoScanandReadNFCtagsinMobileapplicationusingAndroidKotlin_3.png)\n\n이 블로그 포스트를 여기까지 읽어 주셔서 감사합니다. 이제 NFC 스캔 기능을 성공적으로 달성하셨다고 생각합니다. 그러나 의문 사항이 있으면 언제든지 알려주세요. 언제든지 도와드릴 수 있어 기뻐요.\n\n저는 글을 쓰는 만큼 여러분이 읽는 것을 즐길 수 있기를 바랍니다.\n이 튜토리얼이 누군가에게 도움이 될 것으로 생각하시나요? 망설이지 말고 공유해주세요. 이가 도움이 되기를 바라며, 50번까지 클랩 버튼을 눌러 주세요. 감사합니다.","ogImage":{"url":"/assets/img/2024-06-21-HowtoScanandReadNFCtagsinMobileapplicationusingAndroidKotlin_0.png"},"coverImage":"/assets/img/2024-06-21-HowtoScanandReadNFCtagsinMobileapplicationusingAndroidKotlin_0.png","tag":["Tech"],"readingTime":6},{"title":"Your project requires a newer version of the Kotlin Gradle plugin 오류 해결 방법","description":"","date":"2024-06-21 20:43","slug":"2024-06-21-SolutionforYourprojectrequiresanewerversionoftheKotlinGradlepluginerror","content":"\n\n안녕하세요 여러분,\n\n이것은 제 첫 번째 미디엄 이야기입니다. 저는 저와 비슷한 사람들이 쉽게 이용 가능한 해결책을 찾지 못할 수도 있는 문제를 겪을 수 있을 것이라고 생각하기 때문에 이것을 쓰게 되었습니다.\n\n저는 현재 플러터 앱을 개발하고 있으며 ARCore Flutter 플러그인을 활용하고 있습니다. 그러나 제 프로그램 실행 중 다음과 같은 오류를 만났습니다:\n\n“Module was compiled with an incompatible version of Kotlin. The binary version of its metadata is 1.9.0, expected version is 1.7.0.”\n\n<div class=\"content-ad\"></div>\n\n정확한 버전 번호는 다를 수 있지만, Kotlin과의 호환성 문제가 문제의 핵심이었습니다. 처음에는 모듈에 대한 호환되지 않는 Kotlin 버전이 무엇인지 확신이 없었습니다. 그러나 몇 시간 동안의 연구 끝에 Kotlin Gradle 버전을 수동으로 업데이트해야 한다는 것을 알게 되었습니다.\n\n내가 발견한 해결책 중 많은 것들이 이전 버전의 Android Studio Bumblebee에 관한 것이었고, gradle 파일을 수정하는 방법에 대한 지침을 제공했습니다. 이러한 해결책들은 일반적으로 android/build.gradle의 buildscript 섹션을 수정하는 것을 제안했습니다. 아래는 추천 사항에서 일반적인 buildscript 섹션의 일부분입니다:\n\n```js\nbuildscript {\n    ext.kotlin_version = '1.3.50'\n    repositories {\n        google()\n        jcenter()\n    }\n\n    dependencies {\n        classpath 'com.android.tools.build:gradle:4.0.1'\n        classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\"\n    }\n}\n```\n\n그러나 조만간 이 buildscript 구성이 Bumblebee 업데이트 이전에 존재했음을 깨달았습니다. 더 최근의 해결책들은 여전히 파일의 처음이나 다른 곳에 buildscript 블록을 수동으로 추가하는 것을 권장했습니다. 안타깝게도, 이러한 제안들 중 어느 것도 내 문제를 해결해 주지 못했습니다.\n\n<div class=\"content-ad\"></div>\n\n1) android/settings.gradle 파일로 이동해주세요.\n\n2) 다음과 비슷한 섹션을 만날 것입니다:\n\n```js\npluginManagement {\n    def flutterSdkPath = {\n        def properties = new Properties()\n        file(\"local.properties\").withInputStream { properties.load(it) }\n        def flutterSdkPath = properties.getProperty(\"flutter.sdk\")\n        assert flutterSdkPath != null, \"local.properties에 flutter.sdk가 설정되지 않았습니다\"\n        return flutterSdkPath\n    }\n    settings.ext.flutterSdkPath = flutterSdkPath()\n\n    includeBuild(\"${settings.ext.flutterSdkPath}/packages/flutter_tools/gradle\")\n\n    repositories {\n        google()\n        mavenCentral()\n        gradlePluginPortal()\n    }\n}\n\nplugins {\n    id \"dev.flutter.flutter-plugin-loader\" version \"1.0.0\"\n    id \"com.android.application\" version \"7.3.0\" apply false\n    id \"org.jetbrains.kotlin.android\" version \"1.7.10\" apply false\n}\n\ninclude \":app\"\n```\n\n3) plugins 섹션 아래에서 문제를 일으키는 id \"org.jetbrains.kotlin.android\" version \"1.7.10\" apply false 줄을 찾아보세요.\n\n<div class=\"content-ad\"></div>\n\n여기서 Kotlin 버전을 변경하세요. 저의 경우에는 1.9.0으로 업데이트했고, 문제가 해결되었어요.\n\n이 해결책이 동일한 오류를 겪는 다른 사람들에게 도움이 되기를 바랍니다. 즐거운 하루 되세요!","ogImage":{"url":"/assets/img/2024-06-21-SolutionforYourprojectrequiresanewerversionoftheKotlinGradlepluginerror_0.png"},"coverImage":"/assets/img/2024-06-21-SolutionforYourprojectrequiresanewerversionoftheKotlinGradlepluginerror_0.png","tag":["Tech"],"readingTime":3},{"title":"외부 패키지 없이 Flutter에서 Google Autocomplete Places API 통합하기 종합 가이드","description":"","date":"2024-06-21 20:41","slug":"2024-06-21-IntegratingGoogleAutocompletePlacesAPIinFlutterWithoutExternalPackagesAComprehensiveGuide","content":"\n![image](/assets/img/2024-06-21-IntegratingGoogleAutocompletePlacesAPIinFlutterWithoutExternalPackagesAComprehensiveGuide_0.png)\n\n소스 코드: [https://github.com/axiftaj/Flutter-Google-Map-Tutorials/tree/main](https://github.com/axiftaj/Flutter-Google-Map-Tutorials/tree/main)\n\nGoogle Autocomplete Places API는 위치 제안 및 예측을 심층적으로 통합할 수 있는 강력한 솔루션을 제공합니다. 이 기능을 통합하는 데 사용할 수 있는 패키지는 있지만 기본 API 호출을 이해하면 개발자가 더 많은 제어와 사용자 정의 기능을 갖게 됩니다. 이 안내서에서는 외부 패키지에 의존하지 않고 Flutter에서 Google Autocomplete Places API를 직접 구현하는 과정을 탐색해 보겠습니다.\n\n필수 사항: 계속하기 전에 다음 사전 요구 사항이 충족되었는지 확인하세요:\n\n<div class=\"content-ad\"></div>\n\n- 플러터 SDK가 설치되어 있어야 합니다\n- 안드로이드 스튜디오 또는 VS CODE\n- 결제가 활성화된 Google Cloud Platform (GCP) 계정 및 Places API가 활성화되어 있어야 합니다\n\n단계 1: Google Cloud Platform 프로젝트 설정\n\n- Google Cloud Platform 콘솔로 이동: https://console.cloud.google.com/\n- 스크린샷에 표시된 대로 새 프로젝트를 만들거나 기존 프로젝트를 선택하세요\n\n![image](/assets/img/2024-06-21-IntegratingGoogleAutocompletePlacesAPIinFlutterWithoutExternalPackagesAComprehensiveGuide_1.png)\n\n<div class=\"content-ad\"></div>\n\n3. 프로젝트용 Google Places API를 활성화하세요. API 라이브러리로 이동하여 \"Places API\"를 검색하고 활성화하세요.\n\n왼쪽 상단 모서리에 있는 햄버거 아이콘을 클릭하고 API 및 서비스 라이브러리를 선택한 후, 우측 하단 구석에 있는 Place API를 클릭하세요.\n\n![이미지](/assets/img/2024-06-21-IntegratingGoogleAutocompletePlacesAPIinFlutterWithoutExternalPackagesAComprehensiveGuide_2.png)\n\n활성화될 때와 같이 보일 것입니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-21-IntegratingGoogleAutocompletePlacesAPIinFlutterWithoutExternalPackagesAComprehensiveGuide_3.png\" />\n\n4. “Credentials” 탭으로 이동하여 API 자격 증명을 생성하세요. “Create Credentials”를 선택하고 “API Key”를 선택한 후 지침에 따라 API 키를 생성하세요.\n\n상단 좌측 구석의 햄버거 아이콘을 클릭한 후 API 및 서비스 “Credentials”를 선택하고 CREATE CREDENTIALS를 클릭한 후 API Key를 선택하세요. 이렇게 하면 API 키가 생성되며, 이를 다른 사람과 공유하지 마세요.\n\n<img src=\"/assets/img/2024-06-21-IntegratingGoogleAutocompletePlacesAPIinFlutterWithoutExternalPackagesAComprehensiveGuide_4.png\" />\n\n<div class=\"content-ad\"></div>\n\n## 플러터 프로젝트를 생성하고 다음 패키지들을 추가해봐요\n\n```js\nuuid: ^4.3.3\nhttp:\n```\n\nuuid 패키지는 세션을 관리하는 데 사용될 거에요(세션이 무엇인지는 마지막에 설명할게요)\n\n코드 설명:\n\n<div class=\"content-ad\"></div>\n\n먼저 사용자로부터 입력을 받기 위해 Text Field를 사용하는 컨트롤러를 만들었습니다. 그리고 uuid 인스턴스를 초기화하였는데, 이는 새로운 세션을 생성하는 데 도움이 됩니다. 그리고 initState() 메서드에서는 컨트롤러의 변경사항을 감지하고 사용자가 무언가를 입력할 때 getSuggestion(\\_controller.text) 함수를 호출합니다.\n\n\\_placeList에는 API 호출이 성공했을 때 화면에 자동완성 추천을 저장합니다.\n\n```js\nfinal _controller = TextEditingController();\nvar uuid = const Uuid();\nString _sessionToken = '1234567890';\nList<dynamic> _placeList = [];\n\n@override\nvoid initState() {\n  super.initState();\n  _controller.addListener(() {\n    _onChanged();\n  });\n}\n\n_onChanged() {\n  if (_sessionToken == null) {\n    setState(() {\n      _sessionToken = uuid.v4();\n    });\n  }\n  getSuggestion(_controller.text);\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 함수에서는 http 패키지를 사용하여 입력 요청을 Google 서버로 보냅니다. 성공적으로 처리되면 해당 데이터를 배열에 저장하고 화면을 새로 고침하여 보여줍니다.\n\nAPI 키는 안전한 저장소에 보관하거나 다른 좋은 방법을 따라 오용되지 않도록 합니다.\n\n```js\nvoid getSuggestion(String input) async {\n\n\n  const String PLACES_API_KEY = \"\";\n\n  try{\n    String baseURL = 'https://maps.googleapis.com/maps/api/place/autocomplete/json';\n    String request = '$baseURL?input=$input&key=$PLACES_API_KEY&sessiontoken=$_sessionToken';\n    var response = await http.get(Uri.parse(request));\n    var data = json.decode(response.body);\n    if (kDebugMode) {\n      print('mydata');\n      print(data);\n    }\n    if (response.statusCode == 200) {\n      setState(() {\n        _placeList = json.decode(response.body)['predictions'];\n      });\n    } else {\n      throw Exception('Failed to load predictions');\n    }\n  }catch(e){\n    print(e);\n  }\n\n}\n```\n\n전체 소스 코드:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport 'dart:convert';\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\nimport 'package:uuid/uuid.dart';\nimport 'package:http/http.dart' as http;\n\nclass GoogleMapSearchPlacesApi extends StatefulWidget {\n  const GoogleMapSearchPlacesApi({Key? key}) : super(key: key);\n\n\n  @override\n  _GoogleMapSearchPlacesApiState createState() => _GoogleMapSearchPlacesApiState();\n}\n\nclass _GoogleMapSearchPlacesApiState extends State<GoogleMapSearchPlacesApi> {\n\n\n  final _controller =  TextEditingController();\n  var uuid =  const Uuid();\n  String _sessionToken = '1234567890';\n  List<dynamic> _placeList = [];\n\n  @override\n  void initState() {\n    super.initState();\n    _controller.addListener(() {\n      _onChanged();\n    });\n  }\n\n  _onChanged() {\n    if (_sessionToken == null) {\n      setState(() {\n        _sessionToken = uuid.v4();\n      });\n    }\n    getSuggestion(_controller.text);\n  }\n\n  void getSuggestion(String input) async {\n\n\n    const String PLACES_API_KEY = \"your api key\";\n\n    try{\n      String baseURL = 'https://maps.googleapis.com/maps/api/place/autocomplete/json';\n      String request = '$baseURL?input=$input&key=$PLACES_API_KEY&sessiontoken=$_sessionToken';\n      var response = await http.get(Uri.parse(request));\n      var data = json.decode(response.body);\n      if (kDebugMode) {\n        print('mydata');\n        print(data);\n      }\n      if (response.statusCode == 200) {\n        setState(() {\n          _placeList = json.decode(response.body)['predictions'];\n        });\n      } else {\n        throw Exception('Failed to load predictions');\n      }\n    }catch(e){\n      print(e);\n    }\n\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        elevation: 0,\n        title: const Text('Search places Api' ,),\n      ),\n      body: Column(\n        mainAxisAlignment: MainAxisAlignment.start,\n        children: <Widget>[\n          Align(\n            alignment: Alignment.topCenter,\n            child: TextField(\n              controller: _controller,\n              decoration: InputDecoration(\n                hintText: \"Search your location here\",\n                focusColor: Colors.white,\n                floatingLabelBehavior: FloatingLabelBehavior.never,\n                prefixIcon: const Icon(Icons.map),\n                suffixIcon: IconButton(\n                  icon: const Icon(Icons.cancel), onPressed: () {\n                  _controller.clear() ;\n                },\n                ),\n              ),\n            ),\n          ),\n          Expanded(\n            child: ListView.builder(\n              physics: NeverScrollableScrollPhysics(),\n              shrinkWrap: true,\n              itemCount: _placeList.length,\n              itemBuilder: (context, index) {\n                return GestureDetector(\n                  onTap: () async {\n\n                  },\n                  child: ListTile(\n                    title: Text(_placeList[index][\"description\"]),\n                  ),\n                );\n              },\n            ),\n          )\n        ],\n      ),\n    );\n  }\n }\n```\n\n세션 토큰에 대해 자세히 알아보고 사용한 이유에 대해 이해하십시오.\n\n감사합니다. 여러분이 무언가 좋은 것을 배웠기를 바랍니다.\n\n이 블로그가 도움이 되었다면 좋아요와 공유를 부탁드립니다.\n","ogImage":{"url":"/assets/img/2024-06-21-IntegratingGoogleAutocompletePlacesAPIinFlutterWithoutExternalPackagesAComprehensiveGuide_0.png"},"coverImage":"/assets/img/2024-06-21-IntegratingGoogleAutocompletePlacesAPIinFlutterWithoutExternalPackagesAComprehensiveGuide_0.png","tag":["Tech"],"readingTime":7},{"title":"Flutter에서 GoRouter의 ShellRoute로 중첩 네비게이션 구현 방법","description":"","date":"2024-06-21 20:39","slug":"2024-06-21-UsingGoRoutersShellRouteinFlutterforNestedNavigation","content":"\n\n안녕하세요 개발자 여러분!\n\n최근 go_router와 그 새로운 기능인 ShellRoute를 사용하여 영속하는 하단 내비게이션 바를 갖춘 중첩된 내비게이션 기능을 개발했는데, 예상대로 잘 작동합니다.\n\n여러분, 제가 보스같이 해내는 걸 한번 보여드릴게요. (Valorant의 Pheonix 대사입니다.)\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*qQvZYaN08kuIFrN6dQEskg.gif\" />\n\n<div class=\"content-ad\"></div>\n\n# 1. 소개:\n\n## GoRouter\n\ngo_router은 Flutter 앱 개발을 위한 패키지로, 앱 내에서 네비게이션을 처리하는 강력하고 유연한 방법을 제공합니다. 이 패키지는 라우터 시스템을 제공하여 앱 내에서 라우트를 정의하고 특정 위젯에 매핑할 수 있습니다. 그 중요한 기능 중 하나는 ShellRoute인데, 이는 앱 내에서 다양한 화면 또는 탭 간에 전환할 수 있는 지속적인 하단 네비게이션 바를 제공합니다.\n\n## ShellRoute\n\n<div class=\"content-ad\"></div>\n\ngo_router의 ShellRoute 기능을 사용하면 부모 경로를 만들어 하단 네비게이션 바를 추가할 수 있어요. 그리고 각 탭이나 스크린으로 표시되는 다양한 하위 경로를 표시할 수 있습니다. 이 기능은 go_router v7.0.0에서 소개되었어요. 이를 통해 여러 화면을 왔다갔다 할 필요 없이 앱의 다른 섹션이나 기능 사이를 쉽게 이동할 수 있습니다. ShellRoute는 또한 각 화면의 상태를 유지하면서 다른 탭이나 스크린 간에 쉽게 전환할 수 있게 해줍니다.\n\n전반적으로 go_router 패키지와 ShellRoute 기능은 Flutter 앱에서 네비게이션을 처리하는 강력하고 유연한 방법을 제공해주며, 앱의 다른 섹션이나 기능 사이를 전환하는 사용자 친화적이고 직관적인 방법을 제공합니다.\n\n## 지속적인 하단 네비게이션 바의 중요성\n\n잘 디자인된 지속적인 하단 네비게이션 바는 사용자 경험을 크게 향상시키고 앱을 더 사용자 친화적으로 만들 수 있어요. 사용자가 앱의 다양한 섹션과 기능을 쉽게 탐색할 수 있도록 도와주어 참여도와 유지율을 향상시킬 수 있습니다. 게다가 지속적인 하단 네비게이션 바는 앱에 더 깔끔하고 전문적인 느낌을 줄 수 있어서 전반적인 브랜드 이미지를 개선할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n요약하면, Flutter 앱에서 지속적인 하단 탐색 바는 쉬운 네비게이션을 제공하고 사용자 경험을 향상시키는 중요한 디자인 요소입니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:800/1*n6GetP4BlzpIwFIHJezhng.gif)\n\n# 2. 준비물:\n\n- PC에 최신 Flutter SDK가 설치되어 있는지 확인하세요\n- 다음 명령어를 실행하여 새 Flutter 프로젝트를 생성하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\n플러터 create go_router_demo\n```\n\n3. 프로젝트에 go_router를 추가하려면 다음 명령을 실행하세요:\n\n```js\nflutter pub add go_router\n```\n\n# 3. 하단 네비게이션 바 스캐폴드:\n\n<div class=\"content-ad\"></div>\n\n부모 화면을 만들어서 하단 네비게이션 바를 유지할 거에요. 이 화면은 자식 위젯을 인자로 받을 거에요. 이 자식 위젯을 이용해서 앱의 자식 경로를 표시하고, 하단 네비게이션 바를 모든 자식 경로에 계속 유지할 거에요.\n\n```js\n  int currentIndex = 0;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: widget.child,\n      bottomNavigationBar: BottomNavigationBar(\n        onTap: changeTab,\n        backgroundColor: const Color(0xffe0b9f6),\n        currentIndex: currentIndex,\n        items: const [\n          BottomNavigationBarItem(icon: Icon(Icons.home), label: 'Home'),\n          BottomNavigationBarItem(icon: Icon(Icons.chat), label: 'Chat'),\n        ],\n      ),\n    );\n  }\n```\n\nchangeTab 함수는 홈 및 채팅 탭 간에 이동하는 것을 다룰 거에요.\n\n```js\nvoid changeTab(int index) {\n    switch(index){\n      case 0:  \n        context.go('/');\n        break;\n      case 1:  \n        context.go('/chat');\n        break;\n      default:\n        context.go('/');\n        break;\n    }\n    setState(() {\n      currentIndex = index;\n    });\n  }\n```\n\n<div class=\"content-ad\"></div>\n\n\n![image](https://miro.medium.com/v2/resize:fit:492/1*OsfeWqkayJSX0KYe-74j3Q.gif)\n\n# 4. 라우터 설정하기:\n\n여기서 모든 마법이 일어납니다.\n\n이 가이드를 위해 4개의 페이지를 만들었습니다:\n\n\n<div class=\"content-ad\"></div>\n\n- 홈\n- 채팅\n- 설정\n- 서비스 약관\n\n이러한 페이지에 중첩된 내비게이션을 가지려면 각 수준의 중첩에 대해 별도의 내비게이션 키가 필요합니다. 우리의 경우, 2개의 내비게이터 키를 생성할 것입니다:\n\n```js\nfinal _rootNavigatorKey = GlobalKey<NavigatorState>();\nfinal _shellNavigatorKey = GlobalKey<NavigatorState>();\n```\n\n_rootNavigatorKey는 부모 내비게이션 스택에 사용되고, _shellNavigatorKey는 ShellRoute와 함께 중첩된 내비게이션에 사용될 것입니다.\n\n<div class=\"content-ad\"></div>\n\n_rootNavigatorKey은 지속적인 BottomNavigationBar를 갖지 말아야 하는 모든 루트에 도움이 될 것이고, _shellNavigatorKey는 BottomNavigationBar가 있는 모든 루트에 사용될 것입니다.\n\n그럼, 이 우리의 원귀적인 목적을 위해 다음과 같은 루트들을 생성해보도록 하겠습니다:\n\n```js\nfinal router = GoRouter(\n  navigatorKey: _rootNavigatorKey,\n  routes: [\n    ShellRoute(\n      navigatorKey: _shellNavigatorKey,\n      builder: (context, state, child) =>\n          BottomNavigationBarScaffold(child: child),\n      routes: [\n        GoRoute(\n          path: '/',\n          parentNavigatorKey: _shellNavigatorKey,\n          builder: (context, state) => const HomePage(),\n        ),\n        GoRoute(\n          path: '/chat',\n          parentNavigatorKey: _shellNavigatorKey,\n          builder: (context, state) => const ChatPage(),\n        ),\n        GoRoute(\n          path: '/settings',\n          parentNavigatorKey: _shellNavigatorKey,\n          builder: (context, state) => const SettingsPage(),\n          routes: [\n            GoRoute(\n              path: 'terms-of-services',\n              parentNavigatorKey: _rootNavigatorKey,\n              builder: (context, state) => const TermsOfServicesPage(),\n            ),\n          ],\n        ),\n      ],\n    )\n  ],\n);\n```\n\n저는 다음과 같은 계층구조로 페이지들을 생성했습니다:\n\n<div class=\"content-ad\"></div>\n\n\n-> 하단 내비게이션 바 스캐폴드\n   -> 홈\n   -> 채팅\n   -> 설정\n      -> 서비스 약관\n\n\n서비스 약관을 제외한 모든 경로는 _shellNavigatorKey를 부모 네비게이터 키로 사용합니다. 이는 서비스 약관 페이지를 제외한 모든 경로가 하단 내비게이션 바 스캐폴드 내에서 탐색되도록 하고, 서비스 약관 페이지는 하단 내비게이션 바 없이 부모 네비게이션 스택에서 완전히 새로운 페이지로 열립니다.\n\n# 5. 경로 간 탐색:\n\n모두 완료되었습니다. 프로젝트에 중첩 네비게이션을 성공적으로 구현했습니다. 우후!! \n\n\n<div class=\"content-ad\"></div>\n\n\n![image](https://miro.medium.com/v2/resize:fit:480/1*-lKavvf7-diWZdV-9TCDcg.gif)\n\n이제 할 일은 go_router에서 제공하는 context.go() 메소드를 사용하여 화면 간을 이동하기만 하면 됩니다. 방금 설정한 라우터가 모든 작업을 대신 처리해 줄 거에요. 멋지죠?!\n\n참고:\n\n\n<div class=\"content-ad\"></div>\n\n# 결론:\n\n요약하면, go_router 패키지와 ShellRoute 기능은 플러터 앱에서 지속적인 하단 네비게이션 바를 구현하는 강력한 솔루션을 제공합니다. 위에 설명된 단계를 따라서 앱의 네비게이션 경험을 향상시키고 전체 사용자 인터페이스를 개선할 수 있습니다. 즐거운 코딩 하세요!\n\n참고: 이 문서에서 제공된 코드 조각들은 예시를 위한 것이며, 특정 앱 구조와 디자인에 맞게 사용자 정의가 필요할 수 있습니다.\n\n참고: 제는 정기적으로 댓글을 확인하며, 궁금한 점이 있거나 해결하기 어려운 문제에 대한 가이드를 작성해 달라면 아래 댓글을 남겨주시면 반드시 도와드리겠습니다!\n\n<div class=\"content-ad\"></div>\n\n![Image](https://miro.medium.com/v2/resize:fit:500/1*FX70ARrhtMfCV40g0ttlAQ.gif)\n\n다음 글에서 뵙겠습니다, 마아살라마!","ogImage":{"url":"/assets/img/2024-06-21-UsingGoRoutersShellRouteinFlutterforNestedNavigation_0.png"},"coverImage":"/assets/img/2024-06-21-UsingGoRoutersShellRouteinFlutterforNestedNavigation_0.png","tag":["Tech"],"readingTime":6},{"title":"Flutter에서 Shared Preferences 사용하기 데모 앱과 함께하는 가이드","description":"","date":"2024-06-21 20:38","slug":"2024-06-21-SharedPreferencesinFlutterAGuidewithaDemonstrativeApp","content":"\n![image](/assets/img/2024-06-21-SharedPreferencesinFlutterAGuidewithaDemonstrativeApp_0.png)\n\n모바일 앱 개발에서의 공유 환경은 사용자 기기에 키-값 쌍의 작은 데이터를 저장할 수 있게 해주는데요. 이 데이터는 영구적이며 앱이 종료된 후에도 접근할 수 있습니다. Flutter에서는 shared_preferences 패키지를 사용하여 공유 환경을 쉽게 관리할 수 있어요.\n\n이 글에서는 Flutter에서의 공유 환경 기본을 살펴보고, 사용 방법을 보여줄 간단한 앱을 만들어볼 거에요.\n\nshared_preferences 시작하기\n\n<div class=\"content-ad\"></div>\n\n\"shared_preferences\" 패키지를 쉽게 추가할 수 있습니다. Flutter 프로젝트에 다음 줄을 pubspec.yaml 파일에 추가하세요:\n\n```yaml\ndependencies:\n  shared_preferences: ^0.5.12+4\n```\n\n의존성을 추가했으면 Dart 파일에서 가져와 초기화할 수 있습니다:\n\n```js\nimport 'package:shared_preferences/shared_preferences.dart';\n\nSharedPreferences prefs;\n\n// 공유 설정 초기화\nprefs = await SharedPreferences.getInstance();\n```\n\n<div class=\"content-ad\"></div>\n\n이제 공유 설정을 초기화했으니, 공유 설정에서 데이터를 저장하고 검색하는 방법을 알아보겠습니다.\n\n공유 설정에 데이터 저장\n\n공유 설정에 데이터를 저장하는 것은 간단하며 아래와 같이 수행할 수 있습니다:\n\n```js\n// 문자열 값을 저장\nprefs.setString(\"키\", \"값\");\n\n// 정수 값을 저장\nprefs.setInt(\"키\", 42);\n\n// 실수 값을 저장\nprefs.setDouble(\"키\", 3.14);\n\n// 부울 값을 저장\nprefs.setBool(\"키\", true);\n```\n\n<div class=\"content-ad\"></div>\n\n공유 프리퍼런스에서 데이터를 검색하는 것은 데이터를 저장하는 것만큼 쉽습니다:\n\n```js\n// 문자열 값 검색\nString stringValue = prefs.getString('key');\n\n// 정수 값 검색\nint intValue = prefs.getInt('key');\n\n// 배정밀도 부동 소수점 값 검색\ndouble doubleValue = prefs.getDouble('key');\n\n// 부울 값 검색\nbool boolValue = prefs.getBool('key');\n```\n\n시연용 앱\n\n<div class=\"content-ad\"></div>\n\n이번에는 Flutter에서의 공유 환경 설정(shared preferences)의 기본적인 이해를 한 것 같네요. 이제 이를 활용한 간단한 앱을 만들어보겠습니다.\n\n이 앱에서는 사용자 이름을 입력하는 TextField와 사용자 이름을 기억할지 여부를 나타내는 SwitchListTile이 있습니다. 스위치가 켜져 있고(true), \"저장\" 버튼이 눌리면 입력된 사용자 이름과 스위치 상태가 공유 환경 설정에 저장됩니다. 앱을 다음에 열면, 이전에 저장된 값이 공유 환경 설정에서 로드되어 Text에 표시되며, Switch는 여전히 true로 설정될 것입니다.\n\n다음은 우리의 데모 앱 코드입니다:\n\n```js\nimport 'package:flutter/material.dart';\nimport 'package:shared_preferences/shared_preferences.dart';\n\nvoid main() => runApp(MyApp());\n\nclass MyApp extends StatefulWidget {\n  @override\n  _MyAppState createState() => _MyAppState();\n}\n\nclass _MyAppState extends State<MyApp> {\n  // 공유 환경 설정 데이터를 저장하는 변수들\n  String _username;\n  bool _rememberMe;\n\n  @override\n  void initState() {\n    super.initState();\n    _loadPreferences();\n  }\n\n  // 공유 환경 설정 데이터를 로드하는 메서드\n  void _loadPreferences() async {\n    final prefs = await SharedPreferences.getInstance();\n    setState(() {\n      _username = prefs.getString('username') ?? '';\n      _rememberMe = prefs.getBool('rememberMe') ?? false;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text('Shared Preferences Demo'),\n        ),\n        body: Padding(\n          padding: const EdgeInsets.all(16.0),\n          child: Column(\n            children: <Widget>[\n              TextField(\n                decoration: InputDecoration(\n                  labelText: 'Username',\n                  hintText: 'Enter your username',\n                ),\n                onChanged: (value) {\n                  setState(() {\n                    _username = value;\n                  });\n                },\n              ),\n              CheckboxListTile(\n                title: Text('Remember me'),\n                value: _rememberMe,\n                onChanged: (value) {\n                  setState(() {\n                    _rememberMe = value;\n                  });\n                },\n              ),\n              RaisedButton(\n                child: Text('Save'),\n                onPressed: () async {\n                  final prefs = await SharedPreferences.getInstance();\n                  prefs.setString('username', _username);\n                  prefs.setBool('rememberMe', _rememberMe);\n                },\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 마크다운 형식으로 변경하세요.\n\n<div class=\"content-ad\"></div>\n\n다음 앱에서 사용하시고 로컬 저장소의 아름다움을 즐기세요!!!\n\n만약 유용하다고 느끼신다면, 좋아요를 남겨주세요\n\n소스 코드: github\n","ogImage":{"url":"/assets/img/2024-06-21-SharedPreferencesinFlutterAGuidewithaDemonstrativeApp_0.png"},"coverImage":"/assets/img/2024-06-21-SharedPreferencesinFlutterAGuidewithaDemonstrativeApp_0.png","tag":["Tech"],"readingTime":4},{"title":"완벽한 Flutter 가이드 다크 모드, 동적 테마 및 테마 전환 구현하는 방법","description":"","date":"2024-06-21 20:35","slug":"2024-06-21-CompleteFlutterGuideHowtoImplementDarkModeDynamicThemingandThemeSwitching","content":"\n# 소개\n\n요즘 플러터 개발을 공부하고 있어요. 테마 전환은 사용자 경험을 향상시키는 중요한 방법이자, 플러터 학습에서 무시할 수 없는 주제입니다. 이 글에서는 플러터에서 테마 전환을 구현하는 방법을 자세히 설명하겠습니다.\n\n# 주요 내용\n\n이 글은 주로 다음 주제를 다룹니다:\n\n<div class=\"content-ad\"></div>\n\n- 왜 앱이 테마 전환을 지원해야 하는지\n- 플러터에서 테마를 설정하는 방법\n- 플러터에서 주간 및 야간 모드 전환하는 방법\n- 플러터에서 동적으로 색상 테마를 변경하는 방법\n- Provider를 사용하여 동적 테마 전환 구현하는 방법\n\n# 왜 앱이 테마 전환을 지원해야 하는지\n\n- 사용자 경험 향상: 각 사용자는 각각의 미적 취향을 가지고 있습니다. 테마 전환이 더 많은 사용자의 시각적 취향을 충족시킬 수 있습니다.\n- 맞춤화된 경험: 테마 전환은 앱의 맞춤 특성을 나타내고 사용자가 테마를 사용자 정의하여 경험을 개인화할 수 있게 합니다.\n- 접근성 지원: 고대비 테마로 전환하는 것은 시각 장애가 있는 사용자들에게 접근성을 향상시킬 수 있습니다.\n\n# 플러터에서 테마를 설정하는 방법\n\n<div class=\"content-ad\"></div>\n\n플러터에서 테마를 설정하는 것은 매우 간단합니다. 단순히 테마 매개변수를 구성하면 됩니다. 테마를 설정하지 않아도 기본 테마를 사용할 수 있어요. 예를 들면:\n\n![image](/assets/img/2024-06-21-CompleteFlutterGuideHowtoImplementDarkModeDynamicThemingandThemeSwitching_0.png)\n\n다크 모드를 사용하고 싶다면, darkTheme: ThemeData.dark()를 추가하세요.\n\n```js\nclass MainApp extends StatelessWidget {\n  const MainApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(\n          colorScheme: ColorScheme.fromSwatch(primarySwatch: Colors.green)),\n      darkTheme: ThemeData.dark(),\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text(\"AppBar\"),\n        ),\n        body: const Center(\n          child: Text('Hello World!'),\n        ),\n      ),\n    );\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n앱은 시스템 설정에 따라 자동으로 테마 모드를 변경합니다. 테마 모드를 수동으로 지정하려면 코드에서 themeMode: ThemeMode.light로 설정할 수 있습니다. 이렇게 하면 앱의 테마 모드가 라이트 모드로 강제 지정됩니다.\n\n# Material 3 설정 방법\n\nMaterial 3를 설정하는 것은 더 간단합니다. useMaterial3: true를 지정하기만 하면 됩니다.\n\n```js\nclass MainApp extends StatelessWidget {\n  const MainApp({super.key});\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData.light(useMaterial3: true,),\n      darkTheme: ThemeData.dark(),\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text(\"AppBar\"),\n        ),\n        body: const Center(\n          child: Text('Hello World!'),\n        ),\n      ),\n    );\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\nMaterial 3은 애플리케이션의 전체 색상 테마를 단일 시드 색상에서 설정할 수 있습니다. 테마 생성자에서 colorSchemeSeed 매개변수를 설정하여 Flutter가이 항목에서 앱의 각 위젯에 대한 조화로운 색상 테마를 생성합니다.\n예를 들어, 아래 색상 테마는 colorSchemeSeed를 사용하여 생성됩니다: const Color.fromARGB(86, 80, 14, 171)\n\n```js\nclass MainApp extends StatelessWidget {\n  const MainApp({Key key});\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(\n        useMaterial3: true,\n        colorSchemeSeed: const Color.fromRGBO(86, 80, 14, 171),\n      ),\n      darkTheme: ThemeData(\n        useMaterial3: true,\n        brightness: Brightness.dark,\n        colorSchemeSeed: const Color.fromRGBO(86, 80, 14, 171),\n      ),\n      themeMode: ThemeMode.dark,\n      home: const HomePage(),\n    );\n  }\n}\n```\n\n![image1](/assets/img/2024-06-21-CompleteFlutterGuideHowtoImplementDarkModeDynamicThemingandThemeSwitching_1.png)\n\n![image2](/assets/img/2024-06-21-CompleteFlutterGuideHowtoImplementDarkModeDynamicThemingandThemeSwitching_2.png)\n\n<div class=\"content-ad\"></div>\n\n# 플러터에서 주간 모드와 야간 모드 전환하는 방법\n\n어플리케이션에서 주간 모드와 야간 모드는 앱의 디스플레이 스타일을 의미합니다. 주간 모드는 일반적으로 밝은 색상과 높은 대비를 사용하며, 야간 모드는 어두운 배경과 낮은 대비를 사용합니다.\n\n주간 모드는 밝은 환경에서 앱을 사용할 때 주로 사용됩니다. 밝은 색상과 높은 대비가 사용자가 콘텐츠를 더 쉽게 볼 수 있도록 도와줍니다. 야간 모드는 어두운 환경에서 앱을 사용할 때 주로 사용됩니다. 어두운 배경과 낮은 대비는 시력 피로를 줄일 수 있습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:844/1*2zyd9D-e4c6Z35u_2xPpeg.gif)\n\n<div class=\"content-ad\"></div>\n\n플러터에서는 낮과 밤 모드 사이를 동적으로 전환하는 것이 매우 간단합니다. 테마 모드를 저장할 중간 변수를 추가하기만 하면 됩니다.\n\n모드 전환을 구현하는 단계는 다음과 같습니다:\n\n- 낮과 밤을 위한 두 가지 테마 세트를 정의합니다.\n- 현재 테마 모드를 저장할 ThemeMode 변수를 추가합니다.\n- 이 변수를 light/dark로 설정하여 테마 모드를 전환합니다.\n- 전환 후 인터페이스가 새로운 테마를 적용하기 위해 자동으로 다시 빌드됩니다.\n\n구체적인 코드는 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nclass _MainAppState extends State<MainApp> {\n  ThemeMode themeMode = ThemeMode.system;\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(\n        useMaterial3: true,\n      ),\n      darkTheme: ThemeData(\n        useMaterial3: true,\n        brightness: Brightness.dark,\n      ),\n      themeMode: themeMode,  // MaterialApp이 테마 모드 변수를 읽어서 테마를 전환합니다.\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text(\"AppBar\"),\n        ),\n        body: Column(\n          children: [\n            Row(\n              children: [\n                TextButton(\n                    onPressed: () {\n                      setState(() {\n                        themeMode = ThemeMode.light;\n                      });\n                    },\n                    child: const Text(\"라이트\")),\n                TextButton(\n                    onPressed: () {\n                      setState(() {\n                        themeMode = ThemeMode.dark;\n                      });\n                    },\n                    child: const Text(\"다크\")),\n              ],\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n```\n\n이 코드는 라이트 테마와 다크 테마를 갖춘 간단한 Flutter 앱을 정의합니다. 먼저 ThemeMode 변수 themeMode를 정의하고 ThemeMode.system으로 초기화합니다. 이는 앱이 일반적으로 안드로이드에서 라이트 테마, iOS에서 다크 테마를 사용하는 시스템의 기본 테마를 사용함을 의미합니다.\n\n다음으로, 라이트 테마와 다크 테마가 정의됩니다. 라이트 테마는 ThemeData 클래스를 사용합니다. useMaterial3 속성은 새로운 Material 3 디자인 언어를 사용하기 위해 true로 설정됩니다. colorSchemeSeed 속성은 해당 테마의 기본 색상으로 사용될 특정 색상으로 설정됩니다.\n\n다크 테마는 비슷한 방식으로 정의되지만 brightness 속성이 Brightness.dark로 설정됩니다.\n\n<div class=\"content-ad\"></div>\n\n마지막으로, MaterialApp 위젯이 앱을 생성하는 데 사용됩니다. theme 속성은 밝은 테마로 설정되고, themeMode 속성은 themeMode 변수로 설정됩니다. 이것은 앱이 밝은 테마로 시작하지만 사용자가 해당 버튼을 탭하여 테마를 어둡게 변경할 수 있음을 의미합니다.\n\nScaffold 위젯은 앱의 기본 레이아웃을 만드는 데 사용됩니다. appBar 속성은 앱 바를 만들고, backgroundColor은 현재 테마의 기본 컨테이너 색상으로 설정됩니다. body 속성은 이 경우 간단한 목록과 두 개의 버튼으로 구성된 앱의 주요 콘텐츠를 만드는 데 사용됩니다.\n\n두 버튼은 테마를 변경하는 데 사용됩니다. 사용자가 \"light\" 버튼을 탭하면 themeMode 변수가 ThemeMode.light로 설정되어 앱이 밝은 테마로 변경됩니다. 사용자가 \"dark\" 버튼을 탭하면 themeMode이 ThemeMode.dark로 설정되어 어두운 테마로 변경됩니다.\n\n# 플러터에서 동적으로 색상 테마 변경하는 방법\n\n<div class=\"content-ad\"></div>\n\n# 색 테마 설정하는 방법\n\n플러터 앱의 색 테마를 구성하는 두 가지 방법이 있습니다:\n\n- 토큰을 사용하여 테마 색상 설정\n- 사용자 정의 색 구성표를 사용\n\n# 테마 색상 설정을 위한 토큰 사용\n\n<div class=\"content-ad\"></div>\n\n플러터의 머티리얼 디자인에서 \"토큰\"은 디자인 시스템과 관련된 개념으로, 특히 구글의 \"Material You\" 시스템에서 중요한 역할을 합니다. 이 시스템에서 토큰은 앱의 모양과 느낌을 정의하는 데 사용되는 매개변수 집합입니다. 이는 색상, 글꼴, 모양 및 기타 요소를 포함하여 앱에서 일관된 시각적 경험을 만들어내는 데 사용됩니다.\n\n토큰은 특정 시각적 스타일을 나타내는 변수 또는 식별자로 생각할 수 있는 추상적인 개념입니다. 예를 들어, 색상 토큰은 테마의 주요 색상을 나타낼 수 있고, 글꼴 토큰은 앱에서 사용하는 헤드라인 글꼴을 나타낼 수 있습니다. 이를 통해 앱의 시각적 스타일이 머티리얼 디자인 요구 사항을 준수하고, 여러 페이지와 구성 요소 간에 일관된 스타일이 유지되도록 도와줍니다.\n\n플러터에서는 ThemeData를 사용하여 이러한 토큰을 설정할 수 있습니다. 예를 들어, ThemeData의 primaryColor 및 accentColor 속성을 사용하여 앱의 주요 색상 및 강조 색상을 설정할 수 있습니다. 마찬가지로, textTheme을 사용하여 앱 전체에 걸쳐 글꼴 스타일을 설정할 수 있습니다.\n\n머티리얼 3의 경우, 전체 앱에서 재사용할 수 있는 색상 토큰을 설정하는 아래 접근 방식을 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nThemeData(\n        useMaterial3: true,\n        colorSchemeSeed: const Color.fromRGBO(86, 80, 14, 171),\n      )\n```\n\n# 사용자 정의 색 구성표 사용하기\n\nFlutter에서 Material 스타일 색 구성표를 사용자 정의하는 방법은 다음과 같습니다:\n\n- colors.dart 파일을 생성하고 내부에 색 변수를 정의합니다. 예시:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport 'package:flutter/material.dart';\nconst lightColorScheme = ColorScheme(\n  brightness: Brightness.light,\n  primary: Color(0xFF96416A),\n  onPrimary: Color(0xFFFFFFFF),\n  primaryContainer: Color(0xFFFFD8E6),\n  onPrimaryContainer: Color(0xFF3D0024),\n  secondary: Color(0xFF735761),\n  ...\n);\nconst darkColorScheme = ColorScheme(\n  brightness: Brightness.dark,\n  primary: Color(0xFFFFB0D0),\n  onPrimary: Color(0xFF5C113B),\n  primaryContainer: Color(0xFF792952),\n  onPrimaryContainer: Color(0xFFFFD8E6),\n  secondary: Color(0xFFE1BDCA),\n  onSecondary: Color(0xFF412A33),\n  ...\n);\n```\n\n- 이러한 사용자 정의 색상을 테마에서 참조하십시오:\n\n```js\nclass MyApp extends StatelessWidget {\n  const MyApp({Key? key}) : super(key: key);\n// 이 위젯은 애플리케이션의 루트입니다.\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(useMaterial3: true, colorScheme: lightColorScheme),\n      darkTheme: ThemeData(useMaterial3: true, colorScheme: darkColorScheme),\n      home: const Home(),\n    );\n  }\n}\n```\n\n- 테마를 적용하려는 페이지에 colors.dart를 가져와서 Theme.of(context)를 통해 테마 설정 구성 스타일을 가져옵니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n최종 defaultColorScheme = Theme.of(context).colorScheme;\nappBar: AppBar(\n        title: const Text(\"AppBar\"),\n        backgroundColor: defaultColorScheme.primaryContainer,\n      ),\n```\n\n4, 여러 테마를 만들 수도 있습니다. 테마를 전환할 때 다른 ThemeData 객체를 전달하세요:\n\n```js\nMaterialApp(\n  theme: lightTheme,\n  darkTheme: darkTheme,\n)\n```\n\n5 테마에서 글꼴, 모양, 그림자 등을 포함한 다른 스타일을 사용자 정의할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이렇게 하면 Material 소스 코드에 깊이 파지 않고 색상과 시각적 효과를 자유롭게 결합하여 사용자 정의된 브랜드 전용 테마를 구현할 수 있어요.\n\n![Image](https://miro.medium.com/v2/resize:fit:1400/1*ekAvAGKVuYuCQb0WEbnxlA.gif)\n\n# 테마 색상을 동적으로 변경하는 방법\n\n![Image](https://miro.medium.com/v2/resize:fit:800/1*JQFs1GLX1gGM8T3roPhRmQ.gif)\n\n<div class=\"content-ad\"></div>\n\n앱에서 테마 색상을 동적으로 전환할 수 있는 다양한 방법이 있습니다. 오늘은 주로 권장되는 방법인 Provider를 사용하는 방법을 소개하겠습니다.\n\nProvider를 사용하면 테마의 중앙 상태 관리가 가능해져 테마를 동적으로 변경할 수 있습니다.\n\n- 상태 관리를 담당하는 ThemeProvider 클래스를 만듭니다.\n- 루트 페이지에 ThemeProvider를 설정합니다.\n- 페이지에서 Consumer를 통해 인스턴스를 얻습니다.\n- 테마 구성을 수정하기 위해 set 메서드를 호출합니다.\n- 테마 변경이 인터페이스 업데이트를 트리거합니다.\n\n# 1. 테마 프로바이더 생성\n\n<div class=\"content-ad\"></div>\n\n우선 ThemeProvider 클래스를 만들어서 테마 상태를 저장합니다:\n\n```js\n// theme_provider.dart\nimport 'package:flutter/material.dart';\nimport 'color_schemes.g.dart';\n\nclass ThemeProvider with ChangeNotifier {\n  late ThemeMode _themeMode = ThemeMode.system;\n  late ColorScheme _darkScheme = darkColorScheme;\n  late ColorScheme _lightScheme = lightColorScheme;\n\n  ThemeMode get themeMode => _themeMode;\n\n  void setThemeMode(ThemeMode value) {\n    _themeMode = value;\n    notifyListeners();\n  }\n\n  ColorScheme get darkScheme => _darkScheme;\n\n  void setDarkScheme(ColorScheme value) {\n    _darkScheme = value;\n    notifyListeners();\n  }\n\n  ColorScheme get lightScheme => _lightScheme;\n\n  void setLightScheme(ColorScheme value) {\n    _lightScheme = value;\n    notifyListeners();\n  }\n}\n```\n\n이 코드는 앱의 밝은 테마와 어두운 테마를 동적으로 수정할 수 있는 ThemeProvider를 구현합니다.\n\n# 2. ThemeProvider 제공\n\n<div class=\"content-ad\"></div>\n\n루트 페이지에 다음 ThemeProvider를 제공하십시오:\n\n```js\nWidget build(BuildContext context) {\n    return ChangeNotifierProvider(\n        create: (context) => ThemeProvider(),\n        child:\n            Consumer<ThemeProvider>(builder: (context, themeProvider, child) {\n          return MaterialApp(\n            theme: ThemeData(\n                useMaterial3: true, colorScheme: themeProvider.lightScheme),\n            darkTheme: ThemeData(\n                useMaterial3: true, colorScheme: themeProvider.darkScheme),\n            themeMode: themeProvider.themeMode,\n            home: const HomePage(),\n          );\n        }));\n  }\n```\n\n이 구현 방식은 다음 이점을 가지고 있습니다:\n\n- MaterialApp에서 ThemeProvider의 인스턴스를 Consumer를 통해 얻습니다.\n- LightTheme 및 DarkTheme의 색상 체계는 ThemeProvider의 lightScheme 및 darkScheme를 직접 참조합니다.\n- 테마 모드(themeMode)도 ThemeProvider의 themeMode 상태를 직접 참조합니다.\n- ThemeProvider의 상태가 변경되면 notifyListeners를 통해 동적으로 재구성하기 위해 Consumer를 트리거하여 테마를 전환합니다.\n- 홈 페이지나 다른 페이지에서는 context를 통해 ThemeProvider 인스턴스를 가져와서 테마 모드와 테마 색상을 변경하기 위해 setter 메서드를 호출할 수 있습니다.\n- Provider를 사용하여 테마 데이터와 상태를 추출함으로써 UI 레이어에서 간단하게 재사용하여 느슨하게 결합된 동적 테마 전환을 달성합니다.\n- ThemeProvider는 테마 상태 관리를 담당하며, UI 레이어는 디스플레이를 담당합니다. 책임의 분리는 디자인 원칙을 따릅니다.\n\n<div class=\"content-ad\"></div>\n\n# 3. 테마 공급자 가져오기\n\n필요한 페이지에서 공급자 인스턴스를 가져옵니다:\n\n```js\nfinal themeProvider = Provider.of<ThemeProvider>(context);\n```\n\n# 4. 테마 변경\n\n<div class=\"content-ad\"></div>\n\n테마 색상을 변경하려면 setLightScheme 및 setDarkScheme를 호출하세요:\n\n```js\nthemeProvider.setLightScheme(lightColorScheme);\nthemeProvider.setDarkScheme(darkColorScheme);\n```\n\n이를 통해 공급자를 통해 서로 다른 페이지 간에 테마 구성을 공유하고 수정할 수 있습니다. 공급자를 사용하여 테마를 관리하면 중복 코드가 없어지며 반응형 테마 구성이 가능해집니다. Flutter에서 동적 테마를 구현하는 유연하고 간결한 방법입니다.\n\n```yaml\ndev_dependencies:\n  flutter_test:\n    sdk: flutter\n  flutter_lints: ^2.0.0\n  provider: ^6.0.5\n```\n\n<div class=\"content-ad\"></div>\n\n# 요약\n\n플러터는 강력한 테마 사용자 정의 기능을 제공하여 테마 시스템을 통해 다양한 방식으로 테마를 자유롭게 전환하여 앱 경험과 접근성을 향상시킬 수 있습니다. 플러터의 테마 기구를 숙달하는 것은 고품질 앱을 개발하는 중요한 부분입니다.\n\n위 내용은 플러터에서 테마 전환을 구현하는 전반적인 소개를 제공합니다. 다른 질문이 있으면 토론을 위해 언제든 댓글을 남겨주세요.\n\n예를 들어, 테마 전환 버튼은 ThemeProvider의 세터를 호출하여 테마 모드를 전환할 수 있습니다. 다른 구성 요소는 스타일을 수정하기 위해 Provider를 통해 ThemeProvider 인스턴스를 얻을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nProvider가 테마 상태를 반응적으로 관리하면, 테마가 변경될 때 위젯들이 자동으로 다시 빌드됩니다. 이는 앱 전체 테마 업데이트를 수동으로 처리할 필요 없이 동적 런타임 테마 적용을 가능케 합니다. 전반적으로, Flutter는 사용자 경험을 즐겁게 만들기 위해 테마를 사용자 정의하고 동적으로 전환하기 쉽습니다.\n\n# 참고 링크들\n\n- [Material Theming Builder](https://m3.material.io/theme-builder#/custom)\n- [Flutter Theming](https://juejin.cn/post/7078583859536723975)\n- [Official Flutter documentation on theming](https://flutter.dev/docs/cookbook/design/themes)\n- [Provider를 이용한 동적 테마 적용 튜토리얼](https://flutter.dev/docs/cookbook/design/themes/dynamic)\n- [간단한 앱 예제를 이용한 동적 테마 비디오 튜토리얼](https://www.youtube.com/watch?v=-G75u5uoFFE)\n- [Provider 상태 관리 패키지 Pub 페이지](https://pub.dev/packages/provider)\n- [Flutter에서 테마 사용 가이드](https://flutter.dev/docs/cookbook/design/themes)\n- [공식 Material Design 시스템 테마 자료](https://material.io/design/material-theming)\n- [Flutter 웹에서 테마 전환하기](https://webmasters.googleblog.com/2021/07/theme-switching-in-flutter-web.html)\n- [Flutter 테마 전환 가이드](https://gusibi-blog.vercel.app/article/flutter-theme-switching-guide)\n","ogImage":{"url":"/assets/img/2024-06-21-CompleteFlutterGuideHowtoImplementDarkModeDynamicThemingandThemeSwitching_0.png"},"coverImage":"/assets/img/2024-06-21-CompleteFlutterGuideHowtoImplementDarkModeDynamicThemingandThemeSwitching_0.png","tag":["Tech"],"readingTime":14},{"title":"Dart에서 CC Rest Api로 REST API 호출 간단하게 하는 방법","description":"","date":"2024-06-21 20:34","slug":"2024-06-21-SimplifyYourRESTAPICallswithCCRestApiinDart","content":"\n# 안녕하세요, Dart 애호가 여러분!\n\nDart 애플리케이션에서 REST API 호출의 복잡성에 지치셨나요? HTTP 요청과 응답을 처리하는 더 체계적이고 간편한 방법이 있으면 좋겠다고 생각하시나요? 걱정하지 마세요! 여러분의 REST API 상호작용을 보다 조직적이고 관리하기 쉬운 클래스 구조로 변환하여 여러분의 삶을 더 편하게 만들어주는 Dart 패키지, CC Rest Api를 소개해 드리게 되어 매우 기쁩니다.\n\n본 문서에서는 CC Rest Api에 대해 알아야 할 모든 것을 초기화부터 모듈 생성과 사용까지 친절하게 안내해 드리겠습니다. 함께 알아보시죠!\n\n# CC Rest Api를 선택해야 하는 이유?\n\n<div class=\"content-ad\"></div>\n\n세부 사항에 들어가기 전에 CC Rest Api를 사용하고 싶어 하는 이유에 대해 이야기해 보겠습니다. 이 패키지를 개발하는 가장 큰 목표는 전통적인 방법 기반의 API 상호 작용을 클래스 기반 구조로 전환하는 것입니다. 이렇게 함으로써 코드를 단순화하는 것뿐만 아니라 복잡성을 줄여 유지 및 확장하기 쉽게 만듭니다.\n\nCC Rest Api는 현재 GET, POST 및 DELETE 작업을 지원하며 API 통신에 필요한 가장 일반적인 기능을 다룹니다.\n\n# 시작하기\n\n# 설치\n\n<div class=\"content-ad\"></div>\n\n먼저, CC Rest Api를 프로젝트에 추가해 봅시다. 간단히 pub.dev를 통해 추가할 수 있어요. 다음 줄을 pubspec.yaml 파일에 추가해 주세요:\n\n```yaml\ndependencies:\n  cc_rest_api: ^1.0.0\n```\n\n그리고 flutter pub get을 실행하여 패키지를 설치해 주세요.\n\n# 초기화\n\n<div class=\"content-ad\"></div>\n\nCC Rest API를 사용하기 전에 REST API 구성 및 로깅 옵션으로 초기화해야 합니다. 아래는 설정하는 예시입니다:\n\n```js\nimport 'package:cc_rest_api/cc_rest_api.dart';\n\nvoid main() {\n  CCRestApi.init(\n    restOptions: CCRestOptions(\n      baseUrl: \"httpbin.org\",\n      defaultHeaders: {\n        \"Access-Control-Allow-Origin\": \"*\",\n        \"Accept\": \"*\",\n        \"Content-Type\": \"application/json\",\n      },\n    ),\n    loggingOptions: CCRestLogging(\n      logEnabled: true,\n      onRequest: (handler) => print(\"Request: $handler\"),\n      onResponse: (handler) => print(\"Response: $handler\"),\n      onError: (handler) => print(\"Error: $handler\"),\n    ),\n    modules: [\n      GetUser(const CCApiConfig(\"user/get\", RequestType.GET, NetworkType.HTTPS)),\n      // 다른 모듈을 여기에 추가할 수 있습니다\n    ],\n  );\n}\n```\n\n이 예시에서는 기본 URL, 기본 헤더 및 로깅 옵션을 설정하고 있습니다. 로깅은 디버깅에 매우 유용하며 각 요청 및 응답의 세부 정보를 콘솔에서 직접 확인할 수 있습니다.\n\n# 모듈 생성하기\n\n<div class=\"content-ad\"></div>\n\nCC Rest Api의 진정한 힘은 모듈화된 접근 방식에서 나옵니다. 각 API 작업은 자체 모듈에 캡슐화될 수 있어 관리와 재사용이 쉬워집니다.\n\n모듈을 만드는 방법은 다음과 같습니다:\n\n```js\nclass GetUser extends CCApiModule {\n  GetUser(CCApiConfig config) : super(config);\n\n  @override\n  Future<Map<String, dynamic>> request() async {\n    return await super.request();\n  }\n\n  @override\n  response(dynamic data) {\n    // 받은 데이터에 대한 처리 로직을 여기에 추가할 수 있습니다\n  }\n}\n```\n\n또는, 요청 메서드를 사용자 정의할 필요가 없다면 더 간단하게 유지할 수도 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nclass GetUser extends CCApiModule {\n  GetUser(CCApiConfig config): super(config);\n\n  @override\n  response(dynamic data) {\n    // 여기에 받은 데이터를 처리하는 논리를 넣을 수 있습니다.\n  }\n}\n```\n\n# 모듈 사용하기\n\n모듈을 설정한 후에 API 요청을 하는 것은 매우 간단합니다. GetUser 모듈을 사용하는 예시를 보여드리겠습니다:\n\n```js\nimport 'package:cc_rest_api/cc_rest_api.dart'; // 패키지 import\n\nvoid main() {\n  GetUser getUser = CCRestApi.getModule<GetUser>();\n  getUser.setHeaders({\n    \"Authorization\": \"Bearer your_access_token\",\n  });\n  getUser.setParameters({\n    \"param1\": \"value1\",\n    \"param2\": \"value2\",\n  });\n  getUser.setBody({\n    \"firebaseToken\": \"testFT\",\n    \"user_id\": \"test\",\n  });\n\n  getUser.request(); // 요청을 트리거합니다. 응답 값을 반환할 수 있습니다.\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 예제에서는 GetUser 모듈의 인스턴스를 만들고, 필요한대로 헤더, 매개변수 및 본문을 설정합니다. 그런 다음 request() 메서드를 호출하여 API 호출을 트리거합니다. 쉽죠?\n\n# 결론\n\nCC Rest Api는 REST API 상호작용을 처리하는 구조화된 유연한 방법을 제공하여 Dart 개발자로서 여러분의 삶을 더 나은 방향으로 만들도록 고안되었습니다. 이 패키지를 사용하여 코드 복잡성을 줄이고 유지 관리성을 향상시키며, 앱에 멋진 기능을 더 많이 구축하는 데 집중할 수 있습니다.\n\n이 기사가 CC Rest Api를 시작하는 방법에 대한 명확한 이해를 제공했기를 바랍니다. 한번 시도해보고 여러분에게 어떻게 작용하는지 알려주세요! 질문이나 피드백이 있으면 아래 댓글을 자유롭게 남겨주세요. 즐거운 코딩되세요!\n","ogImage":{"url":"/assets/img/2024-06-21-SimplifyYourRESTAPICallswithCCRestApiinDart_0.png"},"coverImage":"/assets/img/2024-06-21-SimplifyYourRESTAPICallswithCCRestApiinDart_0.png","tag":["Tech"],"readingTime":4},{"title":"효과적인 Dart 2024년 최신 다트 관용구 작성하기","description":"","date":"2024-06-21 20:32","slug":"2024-06-21-EffectiveDartWritingIdiomaticDartCode","content":"\n# 깨끗하고 효율적이며 관용적인 다트 코드 작성하는 방법\n\n유지보수가 간편하고 성능이 우수한 애플리케이션을 만들기 위해 깨끗하고 효율적이며 관용적인 다트 코드를 작성하는 것은 중요합니다. 다트는 플러터 애플리케이션 등을 만드는 데 사용되는 다재다능한 언어로, 올바르게 활용하면 코드 품질을 크게 향상시킬 수 있습니다. 이 안내서는 가장 좋은 관행, 고급 언어 기능 및 피해야 할 일반적인 함정을 다루어 관용적인 다트 코드를 작성하는 데 도움이 됩니다.\n\n![이미지](/assets/img/2024-06-21-EffectiveDartWritingIdiomaticDartCode_0.png)\n\n# 1. 널 안전성 활용하기\n\n<div class=\"content-ad\"></div>\n\n# 널 안전성이란 무엇인가요?\n\n널 안전성이란 Dart의 특성으로, 모든 유형을 기본적으로 null이 아닌 값으로 만들어 널 오류를 피하도록 도와줍니다. 변수를 명시적으로 nullable하게 표시해야 합니다. ? 구문을 사용합니다.\n\n# 예시\n\n```js\nString? name;\nname = 'Dart';\n```\n\n<div class=\"content-ad\"></div>\n\n# 2. Final 및 Const 사용 선호\n\n# Final 및 Const를 사용해야 하는 경우\n\n- Final: 한 번 초기화된 후에 변경되지 않는 변수에 대해 final을 사용합니다.\n- Const: 컴파일 시간 상수에 대해 const를 사용합니다.\n\n# 예제\n\n<div class=\"content-ad\"></div>\n\n```kotlin\nval greeting: String = \"Hello\"\nconst val pi: Double = 3.14159\n```\n\n# 3. Collection if 및 Spread 연산자 사용하기\n\n# 리스트 생성 향상\n\nDart의 collection if와 spread 연산자(`...`와 `...?`)를 사용하면 더 유연하고 가독성이 좋은 리스트 생성이 가능합니다.\n\n<div class=\"content-ad\"></div>\n\n# 예제\n\n```js\nvar isLoggedIn = true;\nvar items = [\"홈\", isLoggedIn ? \"프로필\" : \"\", \"설정\"];\n\nvar extraItems = [\"도움말\", \"로그아웃\"];\nvar allItems = [\"홈\", ...extraItems, \"설정\"];\n```\n\n# 4. 확장에 대해 긍정적으로 생각하세요\n\n# 기능 확장\n\n<div class=\"content-ad\"></div>\n\nDart의 확장은 소스 코드를 수정하지 않고 기존 라이브러리와 클래스에 기능을 추가할 수 있도록 해줍니다.\n\n# 예시\n\n```js\nextension StringExtension on String {\n  String get reversed {\n    return split('').reversed.join('');\n  }\n}\n\nvoid main() {\n  print('hello'.reversed); // prints 'olleh'\n}\n```\n\n# 5. 믹스인의 힘을 활용하세요\n\n<div class=\"content-ad\"></div>\n\n# 코드 재사용\n\n믹스인은 클래스의 코드를 여러 클래스 계층 구조에서 재사용하는 방법으로, 여러 원본에서 메서드와 속성을 섞어 사용할 수 있도록합니다.\n\n# 예시\n\n```js\nmixin Fly {\n  void fly() => print('날기');\n}\n\nmixin Swim {\n  void swim() => print('수영');\n}\n\nclass Duck with Fly, Swim {}\n\nvoid main() {\n  var duck = Duck();\n  duck.fly();\n  duck.swim();\n}\n```\n\n<div class=\"content-ad\"></div>\n\n# 6. 함수 유형에 대한 Typedef 활용\n\n# 함수 시그니처 간단히하기\n\nTypedef를 사용하면 함수 시그니처를 간단히할 수 있고 코드 가독성을 향상시킬 수 있습니다.\n\n# 예제\n\n<div class=\"content-ad\"></div>\n\n```js\ntypedef IntBinaryOperation = int Function(int, int);\n\nint add(int a, int b) => a + b;\nint subtract(int a, int b) => a - b;\n\nvoid main() {\n  IntBinaryOperation operation;\n\n  operation = add;\n  print(operation(3, 4)); // 7 출력\n\n  operation = subtract;\n  print(operation(3, 4)); // -1 출력\n}\n```\n\n# 7. 효과적인 Dart 가이드라인을 따르세요\n\n# 코드 일관성\n\nGoogle의 효과적인 Dart 가이드라인은 일관성 있는 Dart 코드를 작성하기 위한 포괄적인 권장 사항을 제공합니다. 이 가이드라인은 네이밍 규칙부터 문서화와 디자인 원칙까지 모든 것을 다룹니다.\n\n<div class=\"content-ad\"></div>\n\n# 예시\n\n- 네이밍: 변수, 매개변수 및 함수 이름에는 카멜케이스를 사용하십시오. 클래스 이름에는 UpperCamelCase를 사용하십시오.\n- 문서화: 공개 API에 대한 명확하고 간결한 문서를 제공하기 위해 ///를 사용하십시오.\n\n```js\n/// 이 함수는 두 숫자를 더합니다.\nint add(int a, int b) => a + b;\n```\n\n# 8. 오류를 공손하게 처리하기\n\n<div class=\"content-ad\"></div>\n\n# 예외 처리 사용하기\n\nDart는 예외를 사용하여 견고한 오류 처리 메커니즘을 제공합니다. 항상 예외를 잡고 정상적으로 처리하세요.\n\n# 예시\n\n```js\ntry {\n  var result = riskyOperation();\n  print(result);\n} catch (e) {\n  print('오류가 발생했습니다: $e');\n}\n\nint riskyOperation() {\n  throw Exception('문제가 발생했습니다');\n}\n```\n\n<div class=\"content-ad\"></div>\n\n# 9. async 및 await을 사용하여 성능 최적화\n\n# 비동기 프로그래밍\n\nDart의 async 및 await 키워드는 비동기 프로그래밍을 간단하고 코드를 더 읽기 쉽고 유지보수하기 쉽게 만듭니다.\n\n# 예시\n\n<div class=\"content-ad\"></div>\n\n```js\nFuture<void> fetchData() async {\n  var data = await fetchDataFromServer();\n  print(data);\n}\n\nFuture<String> fetchDataFromServer() async {\n  // 네트워크 지연을 시뮬레이션합니다.\n  await Future.delayed(Duration(seconds: 2));\n  return '데이터 가져오기 완료';\n}\n```\n\n# 10. 흔한 함정 피하기\n\n# 흔한 문제점\n\n- 사용되지 않는 Imports: 코드를 깨끗하게 유지하기 위해 사용되지 않는 imports를 제거합니다.\n- Dynamic 남용: 타입 체크를 우회하고 런타임 오류를 유발할 수 있기 때문에, 꼭 필요한 경우를 제외하고 dynamic 사용을 피하세요.\n\n<div class=\"content-ad\"></div>\n\n# 예시\n\n```js\n// 이렇게 피하세요\ndynamic foo = 'bar';\n\n// 이렇게 선호하세요\nString foo = 'bar';\n```\n\n# 결론\n\n다트 언어의 강력한 기능을 활용하고 최상의 관행을 준수하며 흔히 하는 실수를 피함으로써 관용적인 다트 코드를 작성할 수 있습니다. 널 안전성, final 및 const, 확장(extensions), mixin, 그리고 기타 고급 언어 기능을 활용하여 깔끔하고 효율적이며 유지보수가 용이한 다트 코드를 작성할 수 있습니다. 이러한 지침을 따르고 지속적으로 코딩 관행을 개선하여 더 효과적인 다트 개발자가 되세요. 즐거운 코딩하세요!\n","ogImage":{"url":"/assets/img/2024-06-21-EffectiveDartWritingIdiomaticDartCode_0.png"},"coverImage":"/assets/img/2024-06-21-EffectiveDartWritingIdiomaticDartCode_0.png","tag":["Tech"],"readingTime":4}],"page":"18","totalPageCount":29,"totalPageGroupCount":2,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}