{"pageProps":{"posts":[{"title":"ASPNET Minimal API를 사용하여 단축 URL 앱 만들기 ","description":"","date":"2024-06-19 08:17","slug":"2024-06-19-BuildaShortenedURLAppUsingASPNETMinimalAPI","content":"\n\n오늘날의 디지털 세상에서 URL 단축 서비스는 긴 웹 주소를 관리하고 공유하기 쉽게 만들기 위해 필수적입니다. 이러한 서비스는 URL의 가독성을 향상시키는 것뿐만 아니라 마케터와 개발자들을 위한 추적 기능과 분석을 제공합니다. 자신만의 URL 단축 서비스를 구축하고 싶다면, ASP.NET Minimal API를 사용하면 간소화되고 효율적인 방법으로 이를 달성할 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-BuildaShortenedURLAppUsingASPNETMinimalAPI_0.png)\n\n본 안내서는 ASP.NET Minimal API를 사용하여 URL 단축 애플리케이션을 만드는 과정을 안내합니다. 프로젝트 설정부터 URL을 단축하고 리다이렉트하는 엔드포인트를 만드는 방법까지 모두 다룰 것이며, 최소 API의 단순함과 성능 장점을 활용할 것입니다.\n\n경험 많은 ASP.NET 개발자이거나 막 시작한 분이든, 본 튜토리얼을 통해 견고하고 확장 가능한 URL 단축 서비스를 구축하는 데 필요한 지식을 습득할 수 있습니다. 지금 바로 시작해봅시다! 🚀\n\n<div class=\"content-ad\"></div>\n\n아래는 Markdown 형식으로 표로 변경한 내용입니다.\n\n![이미지](/assets/img/2024-06-19-BuildaShortenedURLAppUsingASPNETMinimalAPI_1.png)\n\nASP.NET Minimal API를 이용하여 URL 단축 애플리케이션을 만드는 작업은 몇 가지 중요한 단계로 이루어져 있습니다: 프로젝트 설정, 서비스 생성, URL을 단축하고 리디렉션하기 위한 엔드포인트 생성, URL 매핑 관리 등이 있습니다.\n\n다음은 단계별 가이드입니다:\n\n## Step 1: 새 ASP.NET Minimal API 프로젝트 만들기\n\n<div class=\"content-ad\"></div>\n\n먼저 .NET CLI를 사용하여 새 ASP.NET Minimal API 프로젝트를 만들어 보세요:\n\n```js\ndotnet new web -o ShortenedUrlAPIApp\ncd ShortenedUrlAPIApp\n```\n\n<img src=\"/assets/img/2024-06-19-BuildaShortenedURLAppUsingASPNETMinimalAPI_2.png\" />\n\n# 단계 2: URL 매핑 모델 정의하기\n\n<div class=\"content-ad\"></div>\n\n간단한 모델을 만들어서 원본 URL과 그에 대한 단축판을 저장하는 클래스를 추가하세요. `ShortenedUrl.cs`라는 새 클래스 파일을 만들어주세요:\n\n```csharp\npublic class ShortenedUrl\n{\n    public Guid Id { get; set; }\n    public string LongUrl { get; set; } = string.Empty;\n    public string ShortUrl { get; set; } = string.Empty;\n    public string Code { get; set; } = string.Empty;\n    public DateTime CreatedOnUtc { get; set; }\n}\n```\n\n# 단계 3: Entity Framework ORM 설정\n\nURL 매핑 데이터를 관리하기 위해 MSSQL 데이터베이스와 함께 Entity Framework를 사용할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-BuildaShortenedURLAppUsingASPNETMinimalAPI_3.png\" />\n\nMSSQL Database Connection: appsettings.json\n\n```json\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft.AspNetCore\": \"Warning\"\n    }\n  },\n  \"AllowedHosts\": \"*\",\n  \"ConnectionStrings\": {\n    \"connMSSQLNoCred\": \"Server=DESKTOP-HLGBAEE\\\\MSSQLSERVER2017;Database=ShortenedUrlAPIApp;Trusted_Connection=True;MultipleActiveResultSets=true;TrustServerCertificate=true\",\n    \"connMSSQL\": \"Server=DESKTOP-99Q87I2\\\\MSSQLSERVER2017;Database=ShortenedUrlAPIApp;User ID=sa;Password=dev123456;MultipleActiveResultSets=true;TrustServerCertificate=true\"\n  }\n}\n```\n\n### Step 4: Create Services to Generate Unique Codes\n\n<div class=\"content-ad\"></div>\n\n단축된 URL에 대한 고유 코드를 생성하는 서비스를 추가하는 것은 각 단축된 URL이 고유하다는 것을 보장하기 위한 중요한 단계입니다. 이 서비스는 문자열을 무작위로 생성하고 데이터베이스에 이미 존재하는지 확인합니다. 이미 존재한다면 고유한 코드가 발견될 때까지 새로운 코드를 생성합니다.\n\n![image](/assets/img/2024-06-19-BuildaShortenedURLAppUsingASPNETMinimalAPI_4.png)\n\n# 단계 5: 엔드포인트 구성\n\nProgram.cs 파일을 열고 URL을 단축하고 원본 URL로 리디렉션하기 위한 엔드포인트를 설정하세요.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-BuildaShortenedURLAppUsingASPNETMinimalAPI_5.png\" />\n\n# 단계 6: 애플리케이션 실행\n\n.NET CLI를 사용하여 애플리케이션을 실행하세요:\n\n```js\ndotnet run\n```\n\n<div class=\"content-ad\"></div>\n\n\n![2024-06-19-BuildaShortenedURLAppUsingASPNETMinimalAPI_6](/assets/img/2024-06-19-BuildaShortenedURLAppUsingASPNETMinimalAPI_6.png)\n\n![2024-06-19-BuildaShortenedURLAppUsingASPNETMinimalAPI_7](/assets/img/2024-06-19-BuildaShortenedURLAppUsingASPNETMinimalAPI_7.png)\n\n![2024-06-19-BuildaShortenedURLAppUsingASPNETMinimalAPI_8](/assets/img/2024-06-19-BuildaShortenedURLAppUsingASPNETMinimalAPI_8.png)\n\nASP.NET Minimal API를 사용하여 URL 단축기를 만드는 것은 현대의 웹 개발 도구의 강력함과 효율성을 보여줍니다. 최소한의 부가 코드와 간단한 구성으로 ASP.NET Minimal API를 사용하면 신속하게 기능적이고 확장 가능한 애플리케이션을 생성할 수 있습니다. 이 튜토리얼에서는 프로젝트 설정, 필요한 모델 정의, 엔드포인트 생성 및 MSSQL 데이터베이스에서 URL 매핑 처리하는 것을 안내했습니다.\n\n\n<div class=\"content-ad\"></div>\n\nASP.NET Minimal API를 활용하면 마이크로서비스 및 소규모 애플리케이션에 이상적인 가벼운 프레임워크의 혜택을 누릴 수 있어요. 이 기초를 바탕으로, 영구 저장소, 사용자 정의 URL 슬러그, 자세한 분석과 같은 기능을 손쉽게 추가할 수 있어요. 여기에서 다루는 기술과 개념은 다른 많은 웹 개발 프로젝트에도 적용할 수 있어요.\n\n이제 ASP.NET Minimal API의 기능을 보여주는 완전히 기능적인 URL 단축 서비스가 준비되었어요. 계속해서 실험하고 최적화하며, 이 프로젝트를 특정 요구에 맞춰 발전시켜 보세요.\n\n코딩 즐기세요! 🚀\n\n👋 .NET 어플리케이션 모음\n🚀 내 유튜브 채널\n💻 내 깃허브\n👉 전체 프로젝트","ogImage":{"url":"/assets/img/2024-06-19-BuildaShortenedURLAppUsingASPNETMinimalAPI_0.png"},"coverImage":"/assets/img/2024-06-19-BuildaShortenedURLAppUsingASPNETMinimalAPI_0.png","tag":["Tech"],"readingTime":5},{"title":"플러터에서 앱 아이콘 변경하기 단계별 안내","description":"","date":"2024-06-19 08:16","slug":"2024-06-19-ChangingAppIconinFlutterAStep-by-StepGuide","content":"\n\n<img src=\"/assets/img/2024-06-19-ChangingAppIconinFlutterAStep-by-StepGuide_0.png\" />\n\n## 소개:\n\n플러터 애플리케이션에서 앱 아이콘을 변경하면 사용자 정의가 더해져 전반적인 사용자 경험을 향상시킬 수 있습니다. 이 안내서에서는 플러터에서 표준 방법을 사용하여 앱 아이콘을 변경하는 과정을 안내해 드리겠습니다. 앱 아이콘을 변경하는 데 필요한 단계, 루트 폴더 구조를 탐색하는 방법, 이미지 크기 사양을 만드는 방법 및 따르면 좋은 모베르 그대로를 다룰 것입니다. 또한 무료로 앱 아이콘을 쉽게 생성할 수 있는 웹 사이트 링크를 제공할 것입니다.\n\n단계 1: 루트 폴더 구조로 이동하기\n\n<div class=\"content-ad\"></div>\n\n앱 아이콘을 변경하려면 Flutter 프로젝트의 루트 폴더 구조로 이동해야 합니다. 거기에는 기본 앱 아이콘을 대체할 필요한 파일이 들어 있습니다.\n\n![앱 아이콘 변경 이미지](/assets/img/2024-06-19-ChangingAppIconinFlutterAStep-by-StepGuide_1.png)\n\n단계 2: 기본 앱 아이콘 이미지 바꾸기\n\n루트 폴더 구조에서 android 및 ios 디렉터리를 찾으세요. 이 디렉터리 안에는 각각 res 및 Assets.xcassets라는 하위 디렉터리가 있습니다. 이 디렉터리에는 앱 아이콘 이미지 파일이 들어 있습니다. 기본 앱 아이콘 이미지 파일을 사용자 정의 앱 아이콘 이미지로 바꿉니다. 각 플랫폼의 이미지 크기 사양을 준수해야 합니다.\n\n<div class=\"content-ad\"></div>\n\nStep 3: 이미지 크기 사양\n\n모든 기기에서 앱 아이콘이 잘 보이도록 이미지 크기 사양을 준수하는 것이 중요합니다. 다음은 권장되는 이미지 크기입니다:\n\nAndroid: 앱 아이콘 이미지는 다음과 같은 여러 크기로 제공되어야 합니다:\n\n- mipmap-mdpi: 48x48 픽셀\n- mipmap-hdpi: 72x72 픽셀\n- mipmap-xhdpi: 96x96 픽셀\n- mipmap-xxhdpi: 144x144 픽셀\n- mipmap-xxxhdpi: 192x192 픽셀\n- mipmap-xxxxhdpi: 512x512 픽셀\n\n<div class=\"content-ad\"></div>\n\niOS: 앱 아이콘 이미지는 다양한 크기로 제공되어야 합니다:\n\n- 20x20 픽셀\n- 29x29 픽셀\n- 40x40 픽셀\n- 60x60 픽셀\n- 76x76 픽셀\n- 83.5x83.5 픽셀\n- 1024x1024 픽셀 및 특정 기기 및 상황에 따라 추가 크기가 필요할 수 있습니다.\n\n이러한 크기는 다양한 화면 밀도와 해상도를 커버하여 앱 아이콘이 다른 디스플레이 특성을 갖는 장치에서 선명하게 나타나도록 합니다.\n\n단계 4: 모범 사례\n\n<div class=\"content-ad\"></div>\n\n- 앱 아이콘을 위해 간단하고 인식하기 쉬운 디자인을 사용해보세요.\n- 각기 다른 기기와 화면 해상도에서 앱 아이콘을 테스트하여 좋아 보이도록 해주세요.\n- 작은 화면에서 보이지 않을 수도 있는 텍스트나 복잡한 디테일을 피해주세요.\n\n## 단계 5: 온라인 도구를 사용하여 아이콘 생성하기\n\n여러 온라인 도구를 사용하여 무료로 앱 아이콘을 생성할 수 있습니다. 이러한 도구들은 일반적으로 다양한 플랫폼을 위한 템플릿을 제공하며 자동으로 각 플랫폼의 요구 사항에 맞게 앱 아이콘 이미지의 크기를 조정합니다. 인기있는 도구로는 Canva, App 아이콘 생성기 및 IconGenerator.net이 있습니다.\n\n## 결론:\n\n<div class=\"content-ad\"></div>\n\n플러터 애플리케이션에서 앱 아이콘을 변경하는 것은 기본 앱 아이콘 이미지 파일을 사용자 정의 이미지로 교체하는 간단한 과정입니다. 이 안내서에 나와 있는 단계를 따르고 최상의 방법을 준수하면 시각적으로 매력적인 앱 아이콘을 만들어 사용자 경험을 향상시킬 수 있습니다. 또한 온라인 도구를 사용하여 앱 아이콘을 생성하면 시간을 절약하고 다양한 플랫폼과의 호환성을 확보할 수 있습니다.\n\n참고:\n\n- Canva: 링크\n- App Icon Generator: 링크\n- IconGenerator.net: 링크\n\n이러한 단계와 권장 사항을 따라 플러터 애플리케이션에서 앱 아이콘을 쉽게 변경하고 독특한 아이덴티티를 부여할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 내 작업:\n\n우리의 멋진 배경 화면 컬렉션으로 당신의 기기 화면을 변화시키세요. 지금 Your YSoFilmy를 다운로드하여 시각적 경험을 체험해보세요.\n\n## 협업을 환영합니다:\n\n사용자 경험을 우선시하고 깨끗한 코드 관행을 유지하는 헌신적인 플러터 개발자를 찾고 계신가요? 흥미로운 협업을 합니다. 제 전체 프로필을 살펴보시고 토론을 위해 LinkedIn에서 저와 연락하세요.","ogImage":{"url":"/assets/img/2024-06-19-ChangingAppIconinFlutterAStep-by-StepGuide_0.png"},"coverImage":"/assets/img/2024-06-19-ChangingAppIconinFlutterAStep-by-StepGuide_0.png","tag":["Tech"],"readingTime":3},{"title":"플러터 위젯 테스팅 초보자 가이드","description":"","date":"2024-06-19 08:15","slug":"2024-06-19-ABeginnersGuidetoFlutterWidgetTesting","content":"\n플러터를 사용해오신 분이라면, 앱이 완벽하고 원활한 사용자 경험을 제공하는 것이 얼마나 중요한지 알고 계실 것입니다. 위젯 테스팅은 이를 달성하는 데 가장 좋은 방법 중 하나입니다. 이 블로그 포스트에서는 플러터 위젯 테스팅의 기본 사항을 다루고 유용한 예제를 제공하여 여러분을 도와드리겠습니다.\n\n![이미지](/assets/img/2024-06-19-ABeginnersGuidetoFlutterWidgetTesting_0.png)\n\n# 위젯 테스팅이란?\n\n사용자 인터페이스(UI) 구성 요소가 의도한 대로 작동하는지 확인하는 테스팅 방법입니다. 이는 통합 테스팅과 단위 테스팅 사이에 위치하여 사용자 인터페이스와 상호 작용하는 방식을 확인할 수 있도록 합니다. 이를 통해 UI가 다양한 시나리오에서 올바르게 작동하고 오류를 조기에 발견하는 데 도움이 됩니다.\n\n<div class=\"content-ad\"></div>\n\n# 위젯 테스트하는 이유\n\n- 버그 조기 발견: 제품 출시 전에 문제를 식별할 수 있습니다.\n- 자신 있게 리팩터링: 코드베이스를 수정할 때 이미 존재하는 기능에 영향을 미칠 걱정 없이 변경할 수 있습니다.\n- UI 테스트 자동화: 시간이 오래 걸리는 UI 검사를 자동화하여 시간을 절약할 수 있습니다.\n\n# 플러터 프로젝트의 테스트 예제\n\n위젯 테스트에 들어가기 전에, 플러터 프로젝트가 준비되었는지 확인해봅시다.\n\n<div class=\"content-ad\"></div>\n\n의존성 확인: pubspec.yaml 파일을 열어 다음 의존성이 있는지 확인하십시오:\n\n```yaml\ndev_dependencies:\n  flutter_test:\n    sdk: flutter\n```\n\n# 첫 번째 위젯 테스트 작성\n\n위젯에 대한 기본 테스트를 작성해 봅시다. 사용자가 할 일 목록 앱(TodoApp)을 가정하고 사용자가 목록에 작업을 추가할 수 있는 앱이라고 합시다.\n\n<div class=\"content-ad\"></div>\n\n# 단계 1: 위젯 생성하기\n\n먼저 테스트용 데모 위젯을 생성해보세요. 이 경우에는 TodoApp 위젯입니다.\n\n```js\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(const TodoApp());\n}\n\nclass TodoApp extends StatelessWidget {\n  const TodoApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const MaterialApp(\n      home: TodoScreen(),\n    );\n  }\n}\n\nclass TodoScreen extends StatefulWidget {\n  const TodoScreen({super.key});\n\n  @override\n  TodoScreenState createState() => TodoScreenState();\n}\n\nclass TodoScreenState extends State<TodoScreen> {\n  final List<String> _todos = [];\n  final TextEditingController _controller = TextEditingController();\n\n  void _addTodo() {\n    setState(() {\n      _todos.add(_controller.text);\n      _controller.clear();\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Todo App')),\n      body: Column(\n        children: <Widget>[\n          Padding(\n            padding: const EdgeInsets.all(8.0),\n            child: TextField(\n              controller: _controller,\n              decoration: const InputDecoration(\n                labelText: 'Enter a task',\n              ),\n            ),\n          ),\n          ElevatedButton(\n            onPressed: _addTodo,\n            child: const Text('Add Task'),\n          ),\n          Expanded(\n            child: ListView.builder(\n              itemCount: _todos.length,\n              itemBuilder: (context, index) {\n                return ListTile(\n                  title: Text(_todos[index]),\n                );\n              },\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n# 단계 2: 샘플 테스트 작성하기\n\n<div class=\"content-ad\"></div>\n\n다음의 테스트 코드를 추가하여 test 디렉토리에 todo_test.dart 파일을 생성해주세요:\n\n```js\n// 파일 구조에 맞게 import 수정해주세요.\nimport 'package:flutter/material.dart';\nimport 'package:flutter_test/flutter_test.dart';\nimport 'package:widget_testing/main.dart';\n\nvoid main() {\n  testWidgets('할 일 목록 테스트', (WidgetTester tester) async {\n    // 데모 앱을 빌드하고 프레임을 트리거합니다.\n    await tester.pumpWidget(const TodoApp());\n\n    // 앱이 빈 목록으로 시작하는지 확인합니다.\n    expect(find.byType(ListTile), findsNothing);\n\n    // 텍스트 필드에 할 일을 입력합니다.\n    await tester.enterText(find.byType(TextField), '우유 사기');\n    await tester.tap(find.text('할 일 추가'));\n    await tester.pump();\n\n    // 할 일이 추가되었는지 확인합니다.\n    expect(find.text('우유 사기'), findsOneWidget);\n    expect(find.byType(ListTile), findsOneWidget);\n  });\n}\n```\n\n# 단계 3: 테스트 실행\n\n다음 명령어로 테스트를 실행해주세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nflutter test\n```\n\n위 명령어를 실행하면 테스트가 성공했음을 나타내는 출력이 표시됩니다.\n\n# 테스트 코드 이해\n\n테스트 코드를 살펴보겠습니다:\n\n<div class=\"content-ad\"></div>\n\n- 위젯 빌드: await tester.pumpWidget(TodoApp());을 사용하여 TodoApp 위젯을 빌드하고 프레임을 트리거합니다.\n- 초기 상태 확인: expect(find.byType(ListTile), findsNothing);을 사용하여 목록이 처음에 비어 있는지 확인합니다.\n- 사용자 상호작용 시뮬레이션: await tester.enterText(find.byType(TextField), `Learn Flutter`);을 사용하여 텍스트 필드에 텍스트를 입력하는 것을 시뮬레이션합니다. await tester.tap(find.text(`Add Task`));을 사용하여 `Add Task` 버튼을 탭하는 것을 시뮬레이션합니다.\n- 위젯 다시 빌드: await tester.pump();을 사용하여 업데이트된 상태로 위젯을 다시 빌드하는 또 다른 프레임을 트리거합니다.\n- 최종 상태 확인: 작업이 목록에 추가되었는지 확인합니다.\n\n# 고급 위젯 테스트\n\n# 비동기 작업 테스트\n\n위젯에 비동기 작업(예: 네트워크 요청)이 포함되어 있는 경우 pumpAndSettle을 사용하여 모든 애니메이션 및 예약된 프레임이 완료될 때까지 기다릴 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nawait tester.pumpAndSettle();\n```\n\n# 위젯 찾기\n\n다양한 방법을 사용하여 위젯을 찾을 수 있습니다:\n\n- find.byType(Type): 타입으로 위젯 찾기.\n- find.byKey(ValueKey): Key로 위젯 찾기.\n- find.text(String): 특정 텍스트를 포함한 위젯 찾기.\n\n<div class=\"content-ad\"></div>\n\n# 모의 의존성\n\n외부 종속성에 의존하는 위젯의 동작을 흉내 내기 위해 모의 객체를 사용하세요. 모의 객체를 생성하기 위해 mockito와 같은 패키지를 활용할 수 있습니다.\n\n# 결론\n\nFlutter 테스트 도구상 가장 유용한 도구 중 하나는 위젯 테스트입니다. 사용자 인터페이스(UI)가 의도한 대로 작동하는지 확인하고, 오류를 초기에 발견하며, 위젯 테스트를 작성하여 자신감을 가지고 코드를 리팩터링할 수 있습니다. 먼저 사용자 인터페이스(UI)의 필수 구성 요소에 대한 테스트를 작성한 후, 더 복잡한 상호 작용으로 넘어가세요.\n\n<div class=\"content-ad\"></div>\n\n화이팅해서 테스트를 진행해보세요🧪! 문제가 있으시면 댓글란에 자유롭게 질문해주시고, 이 게시물이 마음에 드시면 👏좋아요를 눌러주시고 더 많은 훌륭한 컨텐츠를 받아보세요!\n","ogImage":{"url":"/assets/img/2024-06-19-ABeginnersGuidetoFlutterWidgetTesting_0.png"},"coverImage":"/assets/img/2024-06-19-ABeginnersGuidetoFlutterWidgetTesting_0.png","tag":["Tech"],"readingTime":5},{"title":"플러터 Go 라우터 필수 가이드","description":"","date":"2024-06-19 08:13","slug":"2024-06-19-FlutterGoRouterTheCrucialGuide","content":"\n![FlutterGoRouter](/assets/img/2024-06-19-FlutterGoRouterTheCrucialGuide_0.png)\n\nGo_router은 Flutter에서 라우팅을 위한 서드 파티 패키지로, 기본 플러터 라우팅 옵션보다 더 유연하고 사용하기 쉬운 솔루션을 제공하기 위해 만들어졌습니다. 라우트가 어떻게 정의되고 관리되는지에 대해 더 많은 제어를 원하는 경우 유용할 수 있습니다. 또한 웹에 대한 좋은 지원을 제공하기 때문에 애플리케이션에 좋은 선택일 수 있습니다.\n\nURL 패턴을 정의하고, URL을 사용하여 탐색하며, 딥 링크를 처리하고, 기타 여러 네비게이션 관련 시나리오를 다룰 수 있습니다.\n\n# 특징\n\n<div class=\"content-ad\"></div>\n\n고 라우터(GoRouter)는 네비게이션을 간단하게 만들기 위한 다양한 기능을 제공합니다:\n\n- Navigator API와의 하위 호환성\n- Material 및 Cupertino 앱을 지원\n- StatefulShellRoute를 사용하여 중첩된 탭 탐색 지원\n- 목적지에 대한 여러 화면 표시 (하위 라우트)\n- 템플릿 구문을 사용하여 경로 및 쿼리 매개변수 구문 분석\n- 리디렉션 지원 — 사용자를 다른 URL로 리디렉션할 수 있으며,예를 들어 사용자가 인증되지 않은 경우에는 로그인 페이지로 이동할 수 있습니다.\n\n# 시작하기\n\n시작하려면 pubspec.yaml에 go_router를 추가하세요. 이 문서에서는 ^13.2.0을 사용하겠습니다.\n\n<div class=\"content-ad\"></div>\n\n```yaml\ndependencies:\n  go_router: ^13.2.0\n```\n\n# 라우트 구성\n\n이제 그렇게 한 다음에 GoRouter 구성을 앱에 추가해 봅시다:\n\n```js\nimport 'package:go_router/go_router.dart';\n\n// GoRouter 구성\nfinal _router = GoRouter(\n  initialLocation: '/',\n  routes: [\n    GoRoute(\n      name: 'home', // 선택사항, 라우트에 이름 추가. 경로 대신 이름으로 이동 가능\n      path: '/',\n      builder: (context, state) => HomeScreen(),\n    ),\n    GoRoute(\n      name: 'shope',\n      path: '/shope',\n      builder: (context, state) => ShopeScreen(),\n    ),\n  ],\n);\n```\n\n<div class=\"content-ad\"></div>\n\n그럼 MaterialApp.router 또는 CupertinoApp.router 생성자를 사용하고 routerConfig 매개변수를 GoRouter 구성 객체로 설정할 수 있어요:\n\n```js\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp.router(\n      routerConfig: _router,\n    );\n  }\n}\n```\n\n이것으로 준비 끝이에요 🙂 go_router를 사용해보세요 !!!\n\n# 매개변수\n\n<div class=\"content-ad\"></div>\n\n경로 매개변수를 지정하려면 경로 세그먼트 앞에 콜론(:) 문자를 붙이고 고유한 이름(:userId와 같은)을 따라야 합니다. 빌더 콜백에 제공된 GoRouterState 객체를 통해 매개변수 값을 액세스할 수 있습니다:\n\n```js\nGoRoute(\n  path: '/fruits/:id',\n  builder: (context, state) {\n     final id = state.pathParameters[\"id\"]! // URL에서 \"id\" 매개변수 가져오기\n     return FruitsPage(id: id);\n  },\n),\n```\n\n# 하위 루트 추가\n\n일치하는 경로는 네비게이터에서 여러 화면이 표시되는 결과를 가져올 수 있습니다. 이는 push()를 호출한 것과 동일한 효과이며, 새 화면이 이전 화면 위에 표시되고 AppBar 위젯에 인앱 뒤로 가기 버튼이 제공됩니다.\n\n<div class=\"content-ad\"></div>\n\n다음과 같이 부모 라우트와 그 자식 라우트를 추가해 보세요:\n\n```js\nGoRoute(\n  path: '/fruits',\n  builder: (context, state) {\n    return FruitsPage();\n  },\n  routes: <RouteBase>[ // 자식 라우트 추가\n    GoRoute(\n      path: 'fruits-details', // 참고: 라우터의 부모에 \"/\" 문자를 명시할 필요가 없습니다.\n      builder: (context, state) {\n        return FruitDetailsPage();\n      },\n    ),\n  ],\n)\n```\n\n# 화면 간 이동\n\ngo_router를 사용하여 목적지 간에 이동하는 다양한 방법이 있습니다.\n\n<div class=\"content-ad\"></div>\n\n새 화면으로 이동하려면 URL과 함께 context.go()를 호출하십시오:\n\n```js\nbuild(BuildContext context) {\n  return TextButton(\n    onPressed: () => context.go('/fruits/fruit-detail'),\n  );\n}\n```\n\nURL 대신 이름을 사용하여 탐색할 수도 있습니다. context.goNamed()를 호출하면 됩니다.\n\n```js\nbuild(BuildContext context) {\n  return TextButton(\n    // 라우트에 \"name\"을 추가하지 않으면 오류가 발생할 수 있습니다\n    onPressed: () => context.goNamed('fruit-detail'),\n  );\n}\n```\n\n<div class=\"content-ad\"></div>\n\nURI에 경로 매개변수를 포함하여 만들려면 Uri 클래스를 사용할 수 있어요:\n\n```js\ncontext.go(\n  Uri(\n    path: '/fruit-detail',\n    pathParameters: {'id': '10'},\n  ).toString(),\n);\n```\n\ncontext.pop()을 사용하면 현재 화면에서 뒤로 이동할 수 있어요.\n\n# 중첩된 탭 탐색\n\n<div class=\"content-ad\"></div>\n\n일부 앱은 화면의 하위 섹션에 목적지를 표시합니다. 예를 들어, 화면 간을 이동할 때 항상 화면 상에 남아 있는 BottomNavigationBar와 같은 경우입니다.\n\nStatefulShellRoute를 사용하여 중첩된 탐색을 설정했습니다.\n\n이 StatefulShellRoute 클래스는 루트 네비게이터와 다른 네비게이터에 하위 루트를 배치합니다. 그러나 이 루트 클래스는 각 중첩 분기에 대해 별도의 네비게이터를 생성하므로 (즉, 병렬 탐색 트리), 상태가 있는 중첩된 네비게이션을 구축할 수 있습니다.\n\n예를 들어 BottomNavigationBar를 구현하는 경우, 각 탭에 대한 지속적인 네비게이션 상태가 있는 UI를 구현하는 것이 편리합니다.\n\n<div class=\"content-ad\"></div>\n\n상태 유지 쉘 라우트는 상태 유지 브랜치를 나타내는 각각의 StatefulShellBranch 항목 목록을 지정하여 생성됩니다. StatefulShellBranch는 브랜치를 위한 루트 라우트와 네비게이터 키 (GlobalKey) 및 선택적 초기 위치를 제공합니다.\n\n구현 방법을 살펴보겠습니다 🙂\n\n먼저 라우터를 만들어 시작합니다. StatefulShellRoute.indexedStack()을 라우트에 추가할 것이며, 이 클래스는 중첩된 내비게이션을 생성하는 역할을 맡게 됩니다.\n\nStatefulShellRoute.indexedStack()은 중첩된 네비게이터에 IndexedStack을 사용하는 StatefulShellRoute를 생성합니다.\n\n<div class=\"content-ad\"></div>\n\n이 생성자는 분기 네비게이터를 나타내는 위젯을 관리하는 컨테이너(navigatorContainerBuilder)에 대한 IndexedStack 기반 구현을 제공합니다.\n\n```js\n// `root` 및 `section` 네비게이터를 위한 키 생성하여 불필요한 재구성을 피합니다\nfinal _rootNavigatorKey = GlobalKey<NavigatorState>();\nfinal _sectionNavigatorKey = GlobalKey<NavigatorState>();\n\n\nfinal router = GoRouter(\n  navigatorKey: _rootNavigatorKey,\n  initialLocation: '/home',\n  routes: <RouteBase>[\n    StatefulShellRoute.indexedStack(\n      builder: (context, state, navigationShell) {\n        // 커스텀 쉘(예: BottomNavigationBar)을 구현하는 위젯을 반환합니다.\n        // 다른 분기로 상태를 유지하면서 이동할 수 있도록 [StatefulNavigationShell]이 전달됩니다.\n        return ScaffoldWithNavbar(navigationShell);\n      },\n      branches: [\n        // 1번 탭을 위한 루트 분기\n        StatefulShellBranch(\n          navigatorKey: _sectionNavigatorKey,\n          // 이 분기의 루트 추가\n          // 가능한 경우 하위 루트가 있는 각 루트(예: feed/uuid/details)를 추가합니다\n          routes: <RouteBase>[\n            GoRoute(\n              path: '/shope',\n              builder: (context, state) => const ShopePage(),\n              routes: <RouteBase>[\n                GoRoute(\n                  path: 'detail',\n                  builder: (context, state) => const FeedDetailsPage(),\n                )\n              ],\n            ),\n          ],\n        ),\n\n        // 2번 탭을 위한 루트 분기\n        StatefulShellBranch(routes: <RouteBase>[\n          // 이 분기의 루트 추가\n          // 가능한 경우 하위 루트가 있는 각 루트(예: shope/uuid/details)를 추가합니다\n          GoRoute(\n            path: '/home',\n            builder: (context, state) => const HomePage(),\n          ),\n        ])\n      ],\n    ),\n  ],\n);\n```\n\n우리의 루트에 StatefulShellRoute.indexedStack()를 추가했습니다. 이것은 우리의 분기를 생성하고 사용자 정의 쉘(이 경우 BottomNavigationBar)을 반환합니다.\n\n- 빌더: (context, state, navigationShell)에서는 사용자 정의 쉘인 Scaffold with BottomNavigationBar를 반환하며, 이 페이지로 이동할 때 navigationShell을 전달해야 합니다(예: Shope == Home).\n- branches:[]에서는 StatefulShellBranch(분기) 목록을 제공합니다. 이전에 생성한 \\_sectionNavigatorKey를 첫 번째 분기에 navigatorKey 속성으로 전달하지만, 다른 분기에는 기본 키가 사용됩니다. 또한 해당 분기에 대한 지원 루트 목록인 RouteBase 목록을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n우리의 빌더가 커스텀 쉘을 반환하는 것을 확인할 수 있습니다. 이 쉘에는 BottomNavigationBar가 포함되어 있어요. 그러니 이제 그것을 만들어 봅시다. 👇🏿\n\n```js\nimport 'package:flutter/material.dart';\nimport 'package:go_router/go_router.dart';\n\nclass ScaffoldWithNavbar extends StatelessWidget {\n  const ScaffoldWithNavbar(this.navigationShell, {super.key});\n\n  /// 브랜치 네비게이터를 위한 네비게이션 쉘 및 컨테이너입니다.\n  final StatefulNavigationShell navigationShell;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: navigationShell,\n      bottomNavigationBar: BottomNavigationBar(\n        currentIndex: navigationShell.currentIndex,\n        items: const [\n          BottomNavigationBarItem(icon: Icon(Icons.shop), label: 'Shope'),\n          BottomNavigationBarItem(icon: Icon(Icons.home), label: 'Home'),\n        ],\n        onTap: _onTap,\n      ),\n    );\n  }\n\n  void _onTap(index) {\n    navigationShell.goBranch(\n      index,\n      // 바텀 네비게이션 바를 사용할 때 일반적인 패턴은 현재 활성화된 아이템을 탭했을 때 초기 위치로 이동하는 것을 지원하는 것입니다. 이 예제에서는 goBranch의 initialLocation 매개변수를 사용하여 이 동작을 지원하는 방법을 보여줍니다.\n      initialLocation: index == navigationShell.currentIndex,\n    );\n  }\n}\n```\n\n기본적으로 BottomNavigationBar가 있는 Scaffold를 반환하며, 본문은 라우터에서 얻은 navigationShell이 될 것입니다.\n\n또한 `_onTap(index)`가 있습니다. 여기서는 `navigationShell.goBranch(index)`를 사용하여 브랜치 간에 전환할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n그럼 이제 여러분의 프로젝트에 이를 구현할 준비가 끝났어요 🥳🎉\n\n자세한 예시는 아래의 저장소를 확인해주세요 👇🏿\n\n# Guards\n\n특정 경로를 보호하기 위해, 예를 들어 인증되지 않은 사용자로부터, GoRouter를 통해 전역 리디렉션이 설정될 수 있습니다. 가장 일반적인 예는 /login이 아닌 모든 경로를 보호하는 리디렉트 설정이며, 사용자가 인증되지 않은 경우 /login으로 리디렉트됩니다.\n\n<div class=\"content-ad\"></div>\n\n리다이렉션은 GoRouterRedirect 유형의 콜백입니다. 일부 응용 프로그램 상태에 따라서 들어오는 위치를 변경하려면 GoRouter 또는 GoRoute 생성자에 콜백을 추가하세요:\n\n```js\nGoRouter(\n  redirect: (BuildContext context, GoRouterState state) {\n    final isAuthenticated = // 사용자가 인증되었는지 확인하는 논리를 여기에 작성하세요\n    if (!isAuthenticated) {\n      return '/login';\n    } else {\n      return null; // 리디렉트 없이 의도한 경로를 표시하려면 \"null\"을 반환하세요\n    }\n  },\n  ...\n```\n\n- GoRouter 생성자에서 리다이렉트를 정의할 수 있습니다. 모든 탐색 이벤트보다 먼저 호출됩니다.\n- GoRoute 생성자에서 리다이렉트를 정의할 수 있습니다. 탐색 이벤트가 경로를 표시하기 직전에 호출됩니다.\n\n# 전환 애니메이션\n\n<div class=\"content-ad\"></div>\n\nGoRouter를 사용하면 각 GoRoute에 대한 전환 애니메이션을 사용자 정의할 수 있어요. 사용자 정의 전환 애니메이션을 구성하려면 GoRoute 생성자에 pageBuilder 매개변수를 제공하세요:\n\n```js\nGoRoute(\n  path: '/fruit-details',\n  pageBuilder: (context, state) {\n    return CustomTransitionPage(\n      key: state.pageKey,\n      child: FruitDetailsScreen(),\n      transitionsBuilder: (context, animation, secondaryAnimation, child) {\n        // 애니메이션의 값에 따라 화면의 불투명도를 변경합니다.\n        return FadeTransition(\n          opacity: CurveTween(curve: Curves.easeInOutCirc).animate(animation),\n          child: child,\n        );\n      },\n    );\n  },\n),\n```\n\n전체 예제는 전환 애니메이션 샘플을 참조하세요.\n\n# 에러 처리 (404 페이지)\n\n<div class=\"content-ad\"></div>\n\n기본적으로, go_router는 MaterialApp 및 CupertinoApp용 기본 오류 화면과 사용되지 않는 경우의 기본 오류 화면이 함께 제공됩니다. 또한 errorBuilder 매개변수를 사용하여 기본 오류 화면을 대체할 수도 있습니다:\n\n```js\nGoRouter(\n  /* ... */\n  errorBuilder: (context, state) => ErrorPage(state.error),\n);\n```\n\n# 이전에 이동하기 전에 !!\n\ngo_router에는 아직도 좋은 기능이 있습니다. GoRouter에 NavigatorObserver를 추가하여 Navigator의 동작을 관찰하고 route가 푸시, 팝 또는 대체될 때마다 알림을 받습니다. 이를 위해 NavigatorObserver를 확장하는 클래스를 만들어 보겠습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nclass MyNavigatorObserver extends NavigatorObserver {\n  @override\n  void didPush(Route<dynamic> route, Route<dynamic>? previousRoute) {\n    log('did push route');\n  }\n\n  @override\n  void didPop(Route<dynamic> route, Route<dynamic>? previousRoute) {\n    log('did pop route');\n  }\n```\n\n이제 MyNavigatorObserver를 GoRouter에 추가해 봅시다.\n\n```js\nGoRouter(\n  ...\n  observers: [ // 내비게이터 옵저버 추가\n    MyNavigatorObserver(),\n  ],\n...\n)\n```\n\n이벤트가 발생하면 내비게이터에 알림이 전달됩니다.\n","ogImage":{"url":"/assets/img/2024-06-19-FlutterGoRouterTheCrucialGuide_0.png"},"coverImage":"/assets/img/2024-06-19-FlutterGoRouterTheCrucialGuide_0.png","tag":["Tech"],"readingTime":10},{"title":"애플리케이션 개발자가 되는 방법 포괄적인 안내","description":"","date":"2024-06-19 08:12","slug":"2024-06-19-HowtoBecomeanApplicationDeveloperAComprehensiveGuide","content":"\n\n<img src=\"/assets/img/2024-06-19-HowtoBecomeanApplicationDeveloperAComprehensiveGuide_0.png\" />\n\n요즘의 디지털 시대에 있어서 애플리케이션 개발자들은 기술과의 상호작용을 어떻게 형성하는지에 결정적인 역할을 합니다. 일상에서 저희를 연결해주는 모바일 앱부터 삶을 간편하게 해주는 웹 애플리케이션까지, 애플리케이션 개발자의 작업은 우리 주변에 있습니다. 혁신적이고 사용자 친화적인 애플리케이션에 대한 수요가 증가함에 따라, 애플리케이션 개발자로의 진로는 유망한 경로입니다. 이 블로그에서는 이 흥미진진한 여정을 시작하는 단계를 안내해 드리겠습니다.\n\n시작해 봅시다!\n\n## 애플리케이션 개발자의 역할을 이해하기\n\n<div class=\"content-ad\"></div>\n\n응용 프로그램 개발자는 소프트웨어 응용 프로그램을 설계, 구축 및 유지 보수하는 업무를 담당합니다. 이러한 전문가들은 휴대 전화 앱, 웹 앱, 데스크톱 프로그램 등 다양한 유형의 응용 프로그램에 작업합니다. 응용 프로그램 개발자의 주요 목표는 사용자 요구 사항을 충족하는 직관적이고 신뢰할 수 있는 응용 프로그램을 만드는 것입니다. 그들은 디자이너, 프로젝트 매니저 및 다른 개발자와 협력하여 아이디어를 현실화합니다.\n\n## 학습 경로\n\n응용 프로그램 개발자로서 여정을 시작하는 것은 종종 견고한 교육 기반으로 출발합니다. 많은 개발자들은 컴퓨터 과학, 소프트웨어 공학 또는 관련 분야에서 학위를 취득합니다. 이러한 프로그램은 프로그래밍, 알고리즘 및 소프트웨어 디자인에 필수적인 지식을 제공합니다. 그러나 공식적인 교육만이 유일한 방법은 아닙니다. 코딩 부트캠프와 온라인 코스는 집중적인 교육을 제공하고 필요한 기술을 빠르게 습득할 수 있는 빠른 길이 될 수 있습니다. Coursera, Udacity, edX와 같은 플랫폼은 응용 프로그램 개발에 대한 우수한 강좌를 제공합니다.\n\n## 필수 기술 및 기술들\n\n<div class=\"content-ad\"></div>\n\n어플리케이션 개발자로 성공하기 위해서는 다양한 기술 습득이 필요합니다. 주요 프로그래밍 언어로는 Java, Swift, Kotlin, JavaScript, Python 등이 있습니다. 이 언어들은 각각 다른 종류의 어플리케이션 개발에 사용됩니다. 예를 들어, Swift와 Kotlin은 각각 iOS 및 Android 앱 개발에 필수적입니다. React Native, Flutter, Angular 같은 프레임워크와 라이브러리에 익숙해지면 매우 유익할 수 있습니다. 또한, Android Studio, Xcode, Visual Studio Code, Git과 같은 개발 도구와 환경에 능숙해지는 것이 중요합니다. 기술적인 능력 외에도 문제 해결, 커뮤니케이션, 팀워크와 같은 소프트 스킬도 중요합니다.\n\n## 포트폴리오 구축\n\n강력한 포트폴리오는 여러분의 기술과 프로젝트를 잠재적인 고용주나 클라이언트에게 자랑할 수 있는 창구입니다. 다양한 종류의 어플리케이션을 개발하는 능력을 보여주는 다양한 프로젝트를 포함하십시오. 개인 프로젝트, 오픈 소스 프로젝트에 기여하거나 프리랜서로 일하는 것이 모두 포트폴리오를 빛나게 할 수 있습니다. GitHub 나 GitLab과 같은 플랫폼에 프로젝트를 호스팅하면 다른 사람이 여러분의 코드를 보고 여러분의 능력을 이해할 수 있습니다.\n\n## 실무 경험 쌓기\n\n<div class=\"content-ad\"></div>\n\n어플리케이션 개발 분야에서 경험은 매우 중요해요. 인턴십과 입문 단계의 포지션은 실전 경험과 실무 프로젝트에 노출될 수 있는 기회를 제공해줘요. 프리랜싱이나 오픈 소스 프로젝트에 참여하는 것도 경험을 쌓는 좋은 방법이에요. 네트워킹도 중요한데요, 산업 행사, 밋업, 그리고 컨퍼런스에 참석해서 분야 내 전문가들과 소통해보는 걸 고려해보세요.\n\n## 자격증과 계속적인 학습\n\n자격증은 신뢰성을 높여주고 고용주에게 전문성을 증명해줄 수 있어요. Certified Scrum Developer나 AWS Certified Developer 같은 자격증을 취득하는 것을 고려해보세요. 기술 산업은 항상 변화하고 있기 때문에 계속된 학습이 중요해요. 최신 기술과 산업 동향을 따라가기 위해 테크 블로그를 팔로우하거나 포럼에 가입하고 웨비나에 참여해보세요. 계속된 학습은 여러분의 기술을 발전시키고 업데이트된 상태로 유지할 수 있게 해줄 거예요.\n\n## 취업과 커리어 성장\n\n<div class=\"content-ad\"></div>\n\n취직 준비를 마치고 싶다면, 인상적인 이력서와 LinkedIn 프로필을 작성해보세요. 여러분의 기술, 프로젝트, 그리고 관련 경험을 강조해주세요. 취업 포털을 활용하고, 네트워크를 활용하며, 취업 박람회에 참석하여 기회를 찾아보세요. 애플리케이션 개발 분야에서의 경력 성장은 명확한 목표 설정, 멘토십을 찾는 것, 그리고 추가 교육을 고려하는 것이 중요합니다. 경험이 쌓이면 더 도전적인 프로젝트를 맡고 경력을 쌓아나갈 수 있는 기회를 가질 것입니다.\n\n## 결론\n\n애플리케이션 개발자가 되는 것은 창의력과 혁신을 위한 다양한 기회를 제공하는 보람 있는 여정입니다. 이 안내서에 소개된 단계를 따라가면 성공을 향한 길에 서게 될 것입니다. 기억해두세요, 가장 중요한 것은 계속 배우고, 호기심을 갖고, 끊임없이 발전하는 것입니다. 애플리케이션 개발 분야는 방대하고 가능성이 가득한 분야입니다. 오늘 첫걸음을 내딛어서 내일의 애플리케이션을 만들기 시작해보세요.\n\n이 가이드가 여러분이 애플리케이션 개발자가 되는 여정에서 영감을 받을 수 있기를 바랍니다. 계속해서 기술을 향상시키고 혁신하며, 계속해서 배우세요! 더 많은 팁과 테크 트렌드에 대한 업데이트를 위해서 저의 블로그를 팔로우해주세요.\n\n<div class=\"content-ad\"></div>\n\n\n![2024-06-19-HowtoBecomeanApplicationDeveloperAComprehensiveGuide_1.png](/assets/img/2024-06-19-HowtoBecomeanApplicationDeveloperAComprehensiveGuide_1.png)\n","ogImage":{"url":"/assets/img/2024-06-19-HowtoBecomeanApplicationDeveloperAComprehensiveGuide_0.png"},"coverImage":"/assets/img/2024-06-19-HowtoBecomeanApplicationDeveloperAComprehensiveGuide_0.png","tag":["Tech"],"readingTime":4},{"title":"Dart 35에서 코드 생성 대신 매크로를 직접 만들어 봅시다","description":"","date":"2024-06-19 08:10","slug":"2024-06-19-CreatingyourownmacroinsteadofcodegenerationinDart35","content":"\nDart 3.5에는 주요한 새로운 기능인 매크로가 추가되었습니다. 이는 컴파일 시간에 메모리 내에서 완전히 발생하는 코드 생성으로 임시 파일이 필요하지 않습니다. 하지만 그 이상의 기능을 제공합니다.\n\n현재 이는 베타 상태이고, Dart 팀은 불안정한 동안 너무 많은 내용을 공유하지 않도록 주의하고 있습니다. 그들의 공개 로드맵은 다음과 같습니다:\n\n- 현재 @JsonCodable 매크로 하나만 있어서 json_serializable 패키지를 대체하고 그 부담을 크게 줄입니다. 이를 통해 이 기능에 익숙해질 수 있습니다.\n- 이 단일 매크로는 2024년 어느 때에는 안정화될 것입니다.\n- 자체 매크로를 작성하는 것은 2025년 초에 가능해질 것입니다.\n\n하지만 지금 자체 매크로를 만들어보려고 하면 어떻게 될까요? 그들의 말투로 보면 활성화된 매크로의 화이트리스트와 같은 장애물이 있을 것 같았지만, 전혀 그렇지 않았습니다!\n\n<div class=\"content-ad\"></div>\n\n자, 이제 나만의 매크로를 만들고 게시할 수 있다. 기다릴 필요 없어, 2025년까지 기다릴 필요 없어. 실험에는 제약이 없지만, 뭔가가 고장 날 수 있으니 운영에 사용하면 안 돼.\n\n그러니 지금 몇 개의 나만의 매크로를 만들어봐! 다트 팀의 \"hello-world\" 매크로를 복제하고, 우리만의 \"hello-world\" 매크로를 작성하며, 커맨드 라인 인자 파서를 만들기 위한 내 매크로로 깊이 들어가보자.\n\n# 실험 설정\n\n<div class=\"content-ad\"></div>\n\n## 다트 3.5\n\nDart 3.5 베타 버전으로 전환하려면 공식 안내를 참고하세요: [https://dart.dev/language/macros#set-up-the-experiment](https://dart.dev/language/macros#set-up-the-experiment)\n\n저는 방금 ZIP 파일을 다운로드하여 별도의 경로에 압축 해제했어요.\n\n## VSCode\n\n<div class=\"content-ad\"></div>\n\n최근 안정 버전의 Dart 플러그인을 사용하셔야 합니다. 이를 통해 매크로로 생성된 코드를 확인할 수 있습니다.\n\n## pubspec.yaml\n\n예제 매크로를 사용하려면 적어도 Dart 3.5.0-154 버전 이상이 필요합니다. 아래와 같이 pubspec.yaml 파일을 생성해주세요:\n\n```yaml\nname: macro_client\nenvironment:\n  sdk: ^3.5.0-154\n\ndependencies:\n  json: ^0.20.2\n```\n\n<div class=\"content-ad\"></div>\n\n## analysis_options.yaml\n\n코드를 작성하는 도중에 만약 이 기능을 실험 중이라고 말하지 않는다면, 분석 도구가 경고를 표시할 것입니다. 아래의 analysis_options.yaml 파일을 생성해 주세요:\n\n```yaml\nanalyzer:\n  enable-experiment:\n    - macros\n```\n\n## 코드 작성하기\n\n<div class=\"content-ad\"></div>\n\n다트 팀이 제공하는 예제를 사용해보세요:\n\n```js\nimport 'package:json/json.dart';\n\n@JsonCodable() // 매크로 주석.\nclass User {\n  final int? age;\n  final String name;\n  final String username;\n}\n\nvoid main() {\n  // 임의의 JSON이 주어진 경우:\n  final userJson = {\n    'age': 5,\n    'name': 'Roger',\n    'username': 'roger1337',\n  };\n\n  // 생성된 멤버 사용:\n  final user = User.fromJson(userJson);\n  print(user);\n  print(user.toJson());\n}\n```\n\n터미널에서 실험적 플래그와 함께 실행해보세요:\n\n```bash\ndart run --enable-experiment=macros lib/main.dart\n```\n\n<div class=\"content-ad\"></div>\n\n시도해보세요. settings.json에서 Markdown 형식의 표 태그를 수정할 수 있습니다:\n\n![image1](/assets/img/2024-06-19-CreatingyourownmacroinsteadofcodegenerationinDart35_0.png)\n\n다음과 같이 수정해보세요:\n\n![image2](/assets/img/2024-06-19-CreatingyourownmacroinsteadofcodegenerationinDart35_1.png)\n\n<div class=\"content-ad\"></div>\n\n요렇게 변경하면 작동하고 다음 내용이 출력됩니다:\n\n```js\n'User'의 인스턴스\n{age: 5, name: Roger, username: roger1337}\n```\n\n클래스는 단 6줄뿐입니다:\n\n```js\n@JsonCodable()\nclass User {\n  final int? age;\n  final String name;\n  final String username;\n}\n```\n\n<div class=\"content-ad\"></div>\n\n동일한 클래스를 json_serializable로 나타내면 16줄이 됩니다:\n\n```js\n@JsonSerializable()\nclass User {\n  const Commit({\n    required this.age,\n    required this.name,\n    required this.username,\n  });\n\n  final int? age;\n  final String name;\n  final String username;\n\n  factory User.fromJson(Map<String, dynamic> map) => _$UserFromJson(map);\n\n  Map<String, dynamic> toJson() => _$UserToJson(this);\n}\n```\n\n## 생성된 코드 보기\n\nVSCode에서 @JsonCodable 매크로를 사용하면 \"Augmentation으로 이동\" 링크가 표시됩니다. 클릭하면 생성된 코드가 표시됩니다:\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-CreatingyourownmacroinsteadofcodegenerationinDart35_2.png\" />\n\n지난 코드 생성과는 달리, 이번 버전은 실제 파일이 아닌 메모리에 있어요. 편집할 수 없어요. 원본 main.dart에서 무언가를 변경하면 생성된 코드가 업데이트되어 별도로 생성기를 실행할 필요가 없어요.\n\n만약 VSCode를 사용할 수 없다면, 동일한 코드를 보는 데 사용할 수 있는 내 도구를 확인해보세요.\n\n## 작동 방식: augmentation\n\n<div class=\"content-ad\"></div>\n\n여기 무슨 일이 벌어지고 있는 거죠? 이 코드는 augmentation이라는 새로운 Dart 기능을 사용하고 있어요. 이 기능은 원본 블록 외부에서 멤버를 추가하거나 본체를 교체함으로써 클래스나 함수를 변경하는 능력을 말해요.\n\n이 기능은 매크로와 독립적이며, 가장 간단한 사용 방법은 다음과 같아요:\n\n```js\nclass Cat {\n  final String name; // \"Uninitialized\" error unless we have a constructor.\n}\n\naugment class Cat {\n  Cat(this.name); //    Resolves the error.\n}\n```\n\n이 augmentation은 원본 클래스와 별도의 파일에 있을 수 있어요. 매크로가 실제로 하는 것은 이와 같은 augmentation이 있는 파일을 생성하는 것이에요. 예전 코드 생성과의 실제 실용적인 차이는 이제 이것이 메모리에 있고 .g.dart 물리적인 파일에 있지 않다는 점이에요.\n\n<div class=\"content-ad\"></div>\n\n만약 Dart 팀이 json_serializable 패키지를 augmentation을 사용하도록 업그레이드한다면, 당신의 코드는 생성자가 생성될 수 있기 때문에 매크로로 생성된 것과 같이 짧을 수 있고, toJson과 fromJson을 위한 보일러플레이트 포워더가 필요하지 않을 수도 있습니다.\n\n늘 무시받았던 진짜 강력한 기능, augmentation을 찬양해 보세요. 매크로는 컴파일러에서 구현하기 훨씬 어렵지만 여기서는 보조적입니다.\n\n# 나만의 hello-world 매크로 만들기\n\n이 코드를 가진 hello.dart 파일로 hello-world 매크로를 만듭니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport 'dart:async';\n\nimport 'package:macros/macros.dart';\n\nfinal _dartCore = Uri.parse('dart:core');\n\nmacro class Hello implements ClassDeclarationsMacro {\n  const Hello();\n\n  @override\n  Future<void> buildDeclarationsForClass(\n    ClassDeclaration clazz,\n    MemberDeclarationBuilder builder,\n  ) async {\n    final fields = await builder.fieldsOf(clazz);\n    final fieldsString = fields.map((f) => f.identifier.name).join(', ');\n\n    final print = await builder.resolveIdentifier(_dartCore, 'print');\n\n    builder.declareInType(\n      DeclarationCode.fromParts([\n        'void hello() {',\n        print,\n        '(\"Hello! I am ${clazz.identifier.name}. I have $fieldsString.\");}',\n      ]),\n    );\n  }\n}\n```\n\n이 매크로는 적용한 클래스에 hello라는 메서드를 만듭니다. 이 메서드는 클래스 이름과 갖고 있는 필드의 이름을 출력합니다.\n\n이 매크로는 macro 수정자를 가진 클래스로 구현되었습니다. ClassDeclarationsMacro를 구현합니다. 이것은 컴파일러에게 해당 매크로가 클래스에 적용될 수 있고 선언을 업데이트할 시간이 되었을 때 실행될 수 있다고 알려줍니다. 매크로가 다양한 코드 엔티티에 적용되어 코드 생성의 다양한 단계에서 실행될 수 있도록 할 수 있는 많은 인터페이스가 있습니다. 제가 명령줄 인수 구문 분석 매크로에 도달하면 해당 내용에 대해 이야기하겠습니다.\n\n이 인터페이스에는 구현해야 하는 buildDeclarationsForClass라는 메서드가 있으며 적절한 시점에 호출됩니다. 이 메서드에 전달되는 매개변수는:\n\n<div class=\"content-ad\"></div>\n\n- 적용된 클래스에 대한 정보에 액세스하기 위한 클래스 선언입니다.\n- 주어진 클래스를 조사하고 코드를 추가하는 메서드가 있는 빌더 객체입니다.\n\n우리는 빌더를 사용하여 클래스의 필드를 가져옵니다.\n\n실제 코드 생성은 쉽습니다. 빌더에는 증가시키는 클래스에 코드를 추가하기 위한 declareInType 메서드가 있습니다. 가장 간단한 코드는 문자열일 수 있지만 문자열로 print 함수를 호출할 수는 없는 것이 어려운 부분입니다.\n\n이전에 본 JsonCodable 매크로에서의 예시 확장을 살펴보면 dart:core가 접두사와 함께 가져온 것을 발견할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport 'dart:core' as prefix0;\n```\n\n이것은 자동으로 수행되어, 코드가 print와 같은 핵심적인 내용과 충돌하지 않도록합니다. 접두사는 동적이며 미리 알 수 없으므로 생성된 코드에서 단순히 print(something)을 작성할 수 없습니다. 이것이 우리가 식별자 print를 핵심 라이브러리에서 해결하고 나서 일부로부터 생성된 코드를 빌드하는 이유입니다:\n\n```js\nfinal print = await builder.resolveIdentifier(_dartCore, 'print');\n\nbuilder.declareInType(\n  DeclarationCode.fromParts([\n    'void hello() {',\n    print,\n    '(\"Hello! I am ${clazz.identifier.name}. I have $fieldsString.\");}',\n  ]),\n);\n```\n\n일부는 마지막에 함께 붙이는 문자열과 식별자 참조의 조합일 수 있습니다. 이 과정에서 모든 식별자는 필요한 접두사와 함께 앞에 붙입니다.\n\n<div class=\"content-ad\"></div>\n\n```kotlin\nimport 'hello.dart';\n\n@Hello()\nclass User {\n  const User({\n    required this.age,\n    required this.name,\n    required this.username,\n  });\n\n  final int? age;\n  final String name;\n  final String username;\n}\n\nfun main() {\n  val user = User(age = 5, name = 'Roger', username = 'roger1337')\n  user.hello()\n}\n```\n\n[\"Augmentation\" 페이지로 이동](/assets/img/2024-06-19-CreatingyourownmacroinsteadofcodegenerationinDart35_3.png)\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 Markdown 형식으로 변경해주세요.\n\n<div class=\"content-ad\"></div>\n\n```js\n안녕! 저는 사용자입니다. 제 나이, 이름, 사용자명이 있어요.\n```\n\n# 진짜 유용한 매크로\n\n더 배우기 위해 따라할 수 있는 두 가지 실제 세계 매크로가 있습니다:\n\n## JsonCodable\n\n<div class=\"content-ad\"></div>\n\n다트 팀이 우리에게 학습하기 위해 출시한 패키지 마크로입니다. 코드를 꼼꼼히 읽는 것을 강력히 추천합니다. 거의 모든 것을 배운 곳이기도 해요.\n\n## Args\n\n이것은 내가 만든 패키지 마크로입니다.\n\n터미널에서 실행되는 앱을 만드는 경우, 명령행 인수와 그들의 구문 분석에 익숙할 것입니다. 보통은 이를 위해 표준 args 패키지를 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport 'package:args/args.dart';\n\nvoid main(List<String> argv) {\n  final parser = ArgParser();\n  parser.addOption('name');\n  final results = parser.parse(argv);\n  print('Hello, ' + results.option('name'));\n}\n```\n\n다음과 같이 실행할 수 있습니다.\n\n```js\ndart run main.dart --name=Alexey\n```\n\n그리고 확인할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n안녕, Alexey;\n```\n\n문제는 많은 명령줄 옵션이 있는 경우 복잡해진다는 것이죠. 옵션들을 잊어버릴 수 있고, 옵션이 존재하고 특정 타입인지에 대한 컴파일 타임 보장이 없습니다. 옵션의 이름을 쉽게 변경할 수 없으며, 이 코드는 문자열 리터럴로 옵션의 이름을 다루기 때문에 어렵습니다.\n\n그래서 저의 Args 매크로는 원하는 옵션들을 정의한 데이터 클래스로부터 파서를 생성하며, 옵션을 읽을 때 컴파일 타임 유형 안전성을 제공합니다:\n\n```js\nimport 'package:args_macro/args_macro.dart';\n\n@Args()\nclass HelloArgs {\n  String name;\n  int count = 1;\n}\n\nvoid main(List<String> argv) {\n  final parser = HelloArgsParser(); // 생성된 클래스.\n  final HelloArgs args = parser.parse(argv);\n\n  for (int n = 0; n < args.count; n++)\n    print('안녕, ${args.name}!');\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 기능에 대해 자세히 알아보겠습니다. 이 기사의 두 번째 부분에서 제작과정을 소개하겠습니다. 기사가 공개되면 읽어보세요!\n\n- 내 텔레그램 채널: ainkin_com\n- 트위터: https://x.com/AlexeyInkin\n- 링크드인: https://www.linkedin.com/in/alexey-inkin/\n","ogImage":{"url":"/assets/img/2024-06-19-CreatingyourownmacroinsteadofcodegenerationinDart35_0.png"},"coverImage":"/assets/img/2024-06-19-CreatingyourownmacroinsteadofcodegenerationinDart35_0.png","tag":["Tech"],"readingTime":9},{"title":"2024년 기준으로 한 단계씩 따라 하는 플러터 웹뷰 예제","description":"","date":"2024-06-19 08:09","slug":"2024-06-19-FlutterWebviewExampleStepbyStepin2024","content":"\n이 블로그에서는 2024년에 단계별로 플러터 웹뷰 예제를 통합하는 방법을 탐색할 것입니다. 이 코드를 안드로이드 스튜디오에서 쉽게 사용할 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-FlutterWebviewExampleStepbyStepin2024_0.png)\n\n# 2024년 플러터 웹뷰 예제 단계별 통합 방법\n\n## 단계 1: “pubspec.yaml” 파일에 웹뷰 종속성 추가하기\n\n<div class=\"content-ad\"></div>\n\n\"스튜디오\"로 이동 - \"프로젝트\" 폴더 열기 - \"pubspec.yaml\" 파일 열기 - \"pubspec.yaml\" 파일에 \"webview_flutter: ^4.8.0\" 추가\n\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n\n  # The following adds the Cupertino Icons font to your application.\n  # Use with the CupertinoIcons class for iOS style icons.\n  cupertino_icons: ^1.0.2\n  webview_flutter: ^4.8.0\n```\n\n## 단계 2: “AndroidManifest.xml” 파일에서 인터넷 연결 권한 추가\n\n\"스튜디오\"로 이동 - \"프로젝트\" 폴더 열기 - \"android\" 폴더 열기 - \"app\" 폴더 열기 - \"src\" 폴더 열기 - \"main\" 폴더 열기 - \"AndroidManifest.xml\" 파일 열기 - 아래 인터넷 권한을 \"AndroidManifest.xml\" 파일에 추가\n\n<div class=\"content-ad\"></div>\n\n```js\n<uses-permission android:name=\"android.permission.INTERNET\" />\n```\n\n## 단계 3 : Lib 폴더에 \"WebViewContainer.dart\" 파일을 생성하세요\n\n\"Studio\"로 이동 - ` \"프로젝트\" 폴더 열기 -` \"lib\" 폴더 열기 -` \"WebViewContainer.dart\" 파일 만들기\n\n```js\nimport 'package:flutter/material.dart';\nimport 'package:webview_flutter/webview_flutter.dart';\n\nclass WebViewContainer extends StatefulWidget {\n  const WebViewContainer({Key key});\n\n  @override\n  State<WebViewContainer> createState() => _WebViewContainerState();\n}\n\nclass _WebViewContainerState extends State<WebViewContainer> {\n  final controller = WebViewController()\n    ..setJavaScriptMode(JavaScriptMode.unrestricted)\n    ..loadRequest(Uri.parse(\"https://www.oversimplifiedcoding.com\"));\n\n  @override\n  Widget build(BuildContext context) {\n    return SafeArea(child: WebView(\n      controller: controller,\n    ));\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## 단계 4: Lib 폴더에 \"main.dart\" 파일을 생성하세요\n\n\"스튜디오\"에 가서 -` \"프로젝트\" 폴더 열기 -` \"lib\" 폴더 열기 -` \"main.dart\" 파일을 생성하세요\n\n```js\nimport 'package:flutter/material.dart';\nimport 'package:my_test_app/WebViewContainer.dart';\n\nvoid main() {\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Flutter Demo',\n      debugShowCheckedModeBanner: false,\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n        textTheme: TextTheme(\n          headlineLarge: TextStyle(\n              color: Colors.white, fontSize: 25, fontFamily: 'MainFont'),\n          headlineMedium: TextStyle(color: Colors.black, fontSize: 20),\n          titleMedium: TextStyle(color: Colors.red, fontSize: 16),\n        ),\n        useMaterial3: true,\n      ),\n      home: const WebViewContainer(),\n    );\n  }\n}\n```\n\n## 참고\n\n<div class=\"content-ad\"></div>\n\n여기는 2024년에 하나씩 따라 할 수 있는 완전한 Flutter 웹뷰 예제 튜토리얼 비디오 참조 정보입니다. 손쉽게 배우고 코드에서 사용할 수 있습니다.\n\n자세히 보기: Jetpack Compose에서 Mvvm Dagger Hilt를 사용한 로그인 API 호출\n\n## 결론\n\n이 블로그에서는 2024년에 하나씩 따라 할 수 있는 Flutter 웹뷰 예제를 만드는 방법을 안내했습니다. 이 코드를 쉽게 사용하고 필요에 맞게 수정할 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-19-FlutterWebviewExampleStepbyStepin2024_0.png"},"coverImage":"/assets/img/2024-06-19-FlutterWebviewExampleStepbyStepin2024_0.png","tag":["Tech"],"readingTime":3},{"title":"API 통합 및 상태 관리를 위한 Flutter BLoC 라이브러리","description":"","date":"2024-06-19 08:08","slug":"2024-06-19-APIIntegrationandStateManagementwithFlutterBLoCLibrary","content":"\nFlutter Bloc 라이브러리는 잘 정의된 아키텍처를 통해 응용 프로그램 상태를 효과적으로 관리하는 방법을 제공합니다.\n\n![image](/assets/img/2024-06-19-APIIntegrationandStateManagementwithFlutterBLoCLibrary_0.png)\n\nFlutter Bloc Library를 사용하면 다양한 응용 프로그램 상태를 명시적으로 관리할 수 있습니다.\n\n이전에 작성한 기사에서 Flutter Bloc 아키텍처 및 이벤트 및 상태 이해에 대해 설명했습니다. setState를 사용하여 상태 관리의 기본 개념을 이미 알고 계시다면, 이 기사를 참고하시면 이해하기 쉬울 것입니다.\n\n<div class=\"content-ad\"></div>\n\n통합 데이터 소스: 전자 상거래 또는 쇼핑 웹사이트용 가짜 상점 REST API 테스트 API는 네트워크 데이터 소스로 사용됩니다.\n\n더미 JSON URL: https://dummyjson.com/products\n\n본 문서에서는 하나의 엔드포인트(GET: 모든 제품 가져 오기: https://dummyjson.com/products)가 통합될 것입니다\n\n![이미지](/assets/img/2024-06-19-APIIntegrationandStateManagementwithFlutterBLoCLibrary_1.png)\n\n<div class=\"content-ad\"></div>\n\n이 엔드포인트를 통합하기 위해서는 Flutter BLoC 아키텍처를 구현하여 응용 프로그램을 세 개의 계층으로 분리해야 합니다.\n\n- 데이터: 데이터 제공자, 도메인 (저장소, 모델)\n- 비즈니스 로직: 비즈니스 로직 계층의 책임은 프리젠테이션 계층에서 발생하는 이벤트에 새로운 상태로 응답하는 것입니다. 이 계층은 응용 프로그램 상태를 구축하는 데 필요한 데이터를 검색하기 위해 하나 이상의 저장소에 의존할 수 있습니다.\n- 프리젠테이션: 프리젠테이션 계층의 책임은 하나 이상의 블록 상태에 기반하여 자신을 렌더링하는 방법을 결정하는 것입니다. 또한 사용자 상호 작용 및 응용 프로그램 라이프사이클 이벤트를 처리해야 합니다.\n\n이 3개의 계층 중에서 어떤 계층부터 시작해야 할까요?\n\n그래, 데이터 계층부터 시작하겠습니다. 왜냐하면 데이터 계층에서 비즈니스 로직으로 순차적인 통신이 이루어지고, 비즈니스 로직에서 프리젠테이션으로 이어지기 때문이죠.\n\n<div class=\"content-ad\"></div>\n\n특수한 경우에는 네트워크 및 데이터 시뮬레이션에 더 적합한 방법을 따를 수 있습니다.\n\n데이터 레이어 구현으로 넘어가기 전에 필요한 종속성을 추가해 봅시다:\n\n![Dependency](/assets/img/2024-06-19-APIIntegrationandStateManagementwithFlutterBLoCLibrary_2.png)\n\nHTTP: HTTP 요청을 만들기 위한 구성 가능한 미래 기반 라이브러리입니다.\n\n<div class=\"content-ad\"></div>\n\n플러터 Bloc: 빠르고 반응성 있는 모바일 애플리케이션을 구축하기 위해 bloc과 함께 작동하는 강력한 플러터 위젯\n\nEquatable: == 및 hashCode를 명시적으로 재정의할 필요 없이 값을 기반으로 한 등가성을 구현하는 데 도움이 되는 Dart 패키지입니다. Flutter Bloc에서는 동일한 상태가 발생하는 경우 상태 재구성을 방지하거나 결정하는 데 도움이 됩니다.\n\nIntl: 숫자 형식 지정에 사용됩니다.\n\n실행: `flutter pub get` 명령을 실행하여 종속성을 프로젝트에 추가하세요.\n\n<div class=\"content-ad\"></div>\n\n# 1. 데이터 레이어\n\n데이터 제공자: 데이터 제공자는 원시 데이터, 즉 HTTP 요청의 원시 응답을 받습니다.\n\n대규모 애플리케이션을 구축할 때 모든 HTTP 메서드를 포함하는 단일 데이터 제공자를 사용할 수 있습니다. 이는 모든 원시 데이터가 HTTP 응답임을 고려한 것입니다.\n\n데이터 제공자는 HTTP 메서드(PUT, GET, POST, DELETE)와 리포지토리에 의해 관리되는 다른 원시 데이터 소스(예: 로컬 저장소)를 포함할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 구현의 예는 데이터를 가져 오기 때문에 HTTP Get 요청만 수행됩니다.\n\nHTTP 요청은 try-catch 블록 내에 있어 이 요청에서 발생할 수 있는 모든 예외를 잡아내고 해당 예외를 다시 던집니다. 이 예외는 데이터 제공자 클래스에서 처리되지 않고 리포지토리로 던져집니다.\n\n모델\n\n모델은 데이터 구조를 결정하는 데 도움이 되는 클래스입니다. 모델은 데이터베이스나 HTTP 응답을 반영하도록 작성될 수 있으며 이 경우 제품 JSON 응답을 얻는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n이 모델에는 데이터 제공자로부터 JSON 형식의 HTTP 응답을 특정 모델(Dart 객체)로 디코딩하는 데이터 역직렬화 방법도 포함됩니다.\n\n데이터를 전송할 때(e.g. POST, PUT, PATCH 요청 등)는 인코딩된 json이 필요한 경우 요청 본문을 인코딩하기 위한 직렬화 방법을 추가할 수 있습니다.\n\n저장소\n\n저장소는 도메인으로서 우리의 데이터 계층을 추상화하고 블록 계층과의 통신을 용이하게 합니다. 이를 통해 우리 코드베이스의 나머지 부분은 특정 데이터 제공자가 아닌 저장소 계층에서 노출된 함수에만 의존하게 됩니다.\n\n<div class=\"content-ad\"></div>\n\n`getProducts` 메서드는 List of Product (List`Product`)을 데이터 타입으로 반환하는 비동기 메서드입니다. Product는 product_model.dart에서 생성된 모델입니다. (Line: 6)\n\n(Line: 5) 데이터 공급 업체는 get products 엔드포인트(“https://dummyjson.com/products”)를 파싱하는 getRequest 메서드를 호출하기 위해 인스턴스화됩니다.\n\n데이터 공급 업체는 응답 본문, 응답 상태 코드 등에 액세스할 수 있는 raw HTPP 응답을 반환합니다. 상태 코드 200은 요청이 성공적이고 제품이 반환되었음을 나타내며, 요청이 성공적이지 않으면 예외(“Error loading product”)가 던져져 Bloc Layer에서 처리됩니다 (Line: 15).\n\n또한 레포지토리에서 getRequest는 예외를 블록 레이어에서 처리하도록 다시 던지기 위한 try-catch 블록 내에 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 2. BLOC\n\nBLOC 레이어를 관리할 때, 우리는 이벤트 및 상태를 생성합니다. 이것이 응용 프로그램 상태를 우아하게 관리하는 Flutter Bloc의 핵심 부분입니다.\n\n선호하는 IDE에서 Flutter Bloc 확장 프로그램을 사용하면 bloc을 더 빨리 생성할 수 있습니다. (이벤트, 상태, bloc을 포함하는) 보일러플레이트입니다.\n\nBloc 확장 프로그램 사용하기\n\n<div class=\"content-ad\"></div>\n\n- Bloc을 extension에 설치하세요.\n- Bloc 디렉토리를 만드세요.\n- 이 디렉토리를 마우스 오른쪽 클릭하고 New `Bloc Class`를 선택하세요.\n- 이름을 product으로 지정하면 \\_bloc, \\_event, \\_state가 클래스 이름에 추가됩니다. 또한 equatable를 확장할 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-APIIntegrationandStateManagementwithFlutterBLoCLibrary_3.png)\n\n세 개의 bloc 파일(클래스)을 살펴봅시다. 먼저 고려해야 할 것은 product state 입니다.\n\nproduct_state\n\n<div class=\"content-ad\"></div>\n\n제품 상태는 원격 데이터 소스에서 제품을 가져오는 동안 애플리케이션이 있을 수있는 상태를 정의합니다.\n\n- 제품 초기 상태: 이름 그대로 어떠한 프로세스도 시작되기 전에 애플리케이션의 초기 상태입니다.\n\n```js\nclass ProductInitial extends ProductState {}\n```\n\n- 제품 로딩 상태: 원격 데이터 소스에서 제품을 가져오기 위한 요청이 시작됐을 때, 애플리케이션은 제품 로딩 상태를 나타내며, 이 상태는 Flutter Bloc 위젯을 통해 확인할 수 있습니다. 이 상태는 BlocListener, BlocConsumer, BlocBuilder를 통해 듣을 수 있으며, 사용자에게 요청 프로세스가 진행 중임을 보여줄 수 있도록 애플리케이션을 로딩 상태로 설정할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nclass ProductLoadingState extends ProductState {}\n```\n\n- Product Loaded State: 제품이 원격 데이터 소스에서 로드되어 화면에 표시될 수 있는 상태입니다.\n- ProductLoadedState에는 생성자에서 제품 목록(List<Product> products)이 필요하며, 이는 이 상태가 가져온 제품을 화면에 표시하기 위해 발생시킵니다. (라인 13)\n\n```js\nclass ProductLoadedState extends ProductState {\n  const ProductLoadedState({required this.products});\n  final List<Product> products;\n  @override\n  List<Object> get props => [products];\n}\n```\n\n- Product Empty State: 명시적이고 표현 계층에 로직을 줄이기 위해 상품 조회가 성공했지만 제품 데이터가 비어 있는 상태를 관리합니다. (라인 20)\n- Product Loading Failed State: 제품을 로드하는 중에 오류가 발생한 상태입니다. 이 오류는 HTTP 오류이거나 예외일 수 있습니다. 사용자 경험을 향상시키기 위해 페이지에 친절한 메시지를 표시하여 오류의 원인 또는 요청이 완료되지 않은 이유를 설명하는 것이 좋습니다. 이로 인해 ProductLoadingFailedState는 생성자에서 오류 메시지를 요구합니다. (라인 22)\n\n<div class=\"content-ad\"></div>\n\n플러터 Bloc을 사용할 때 애플리케이션에서 모든 것은 이벤트와 상태에 기반합니다. 단일 이벤트 초기화는 애플리케이션의 여러 상태와 관련될 수 있습니다.\n\n이 시나리오에서 단일 이벤트인 GetProductEvent를 선언합니다. 이 단일 이벤트의 초기화는 다양한 애플리케이션 상태(ProductLoadingState, ProductLoadedState, ProductEmptyState, ProductLoadingFailedState)를 발생시킬 수 있습니다.\n\n```js\npart of 'product_bloc.dart';\n\nabstract class ProductEvent extends Equatable {\n  const ProductEvent();\n  // TODO: implement props\n  @override\n  List<Object?> get props => [];\n}\n\nclass GetProductEvent extends ProductEvent {}\n```\n\n그 다음, 이벤트를 상태로 매핑합니다. 이전 Bloc 클래스에서 최근 업데이트 이전에 사용된 용어로 (mapEventToState)를 사용하여 이벤트를 상태로 기본적으로 매핑하는 것이 매우 좋다고 생각합니다.\n\n<div class=\"content-ad\"></div>\n\n이벤트와 상태 간의 매핑이 구현되어 있습니다. Bloc은 새로운 상태를 발생시킬 수 있는 Emitter를 사용합니다.\n\n아래 Bloc은 단순히 이벤트의 초기화를 보여줍니다. Emitter는 Product State를 확장하여 다른 상태를 발생시킬 수 있습니다. 이 경우 GetProductEvent에서 Emitter`ProductState`를 사용합니다.\n\nBloc은 저장소로부터 디코딩된 응답과 통신하며, 저장소는 원시 데이터를 제공하는 데이터 제공자와 통신합니다.\n\nProductRepository는 BlocProvider 래퍼를 통해 프레젠테이션 레이어(위젯)에 주입되거나 제공될 것입니다. 그러나 먼저 Bloc에 집중해 보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n이 블록 파일은 이벤트를 상태에 매핑하는 것을 관리합니다:\n\n- getProducts()는 제품 목록을 반환합니다 (17번 라인)\n- getProducts()가 성공적으로 반환되면 제품이 비어 있는지 확인합니다 (18번 라인)\n- 제품이 비어 있다면 ProductEmptyState를 발생시키고, 그렇지 않으면 제품 데이터로 getProducts()가 성공적입니다.\n- ProductLoadedState를 발생시키면 반환된 제품이 ProductLoadedState에 의해 발생합니다 (21번 라인)\n- 우리는 여기서 try-catch 메서드를 사용하는데, 예외는 handleExceptionWithMessage() 메서드로 처리됩니다. 이 함수는 예외를 캡처하고 친숙한 메시지를 반환하여 관리합니다. FormatException, SocketException, NetworkImageLoadException의 스택 추적을 사용자에게 보여주고 싶지 않을 것입니다.\n\n예외 처리기\n\n참고: 예외를 관리하는 더 많은 방법이 있습니다. 본 문서는 주로 예외 처리에 중점을 둔 것이 아니지만, 이 방법을 사용하여 Kosher!를 반복할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport 'dart:async';\nimport 'dart:io';\n\nString handleExceptionWithMessage(dynamic error) {\n  if (error is SocketException) {\n    return \"인터넷에 연결되지 않은 것 같습니다.\";\n  } else if (error is TimeoutException) {\n    return \"요청 시간이 초과되었습니다. 안정적인 인터넷 연결이 있는지 확인해주세요.\";\n  } else {\n    return \"오류가 발생했습니다. 다시 시도해주세요.\";\n  }\n}\n```\n\nhandleExceptionWithMessage() 함수는 발생한 예외에 대한 설명을 반환합니다. 이 경우에는 두 가지 종류의 예외 유형(SocketException; 인터넷 연결이 없을 때 발생, TimeoutException; HTTP 요청의 설정된 시간 초과할 때 발생)만 확인합니다.\n\n# 3. 프레젠테이션\n\n데이터와 블록 레이어가 준비되어 있으며, 프레젠테이션에는 데이터를 표시하는 위젯이 포함되어 있습니다.\n\n<div class=\"content-ad\"></div>\n\nBloc 이벤트 또는 상태에 액세스하기 전에는 애플리케이션에 이 Bloc을 제공해야 합니다.\n\nBlocProvider 및 Repository Provider를 사용한 의존성 주입(DI)\n\nBlocProvider는 Flutter 위젯으로, BlocProvider.of` T`(context)를 통해 자식 위젯에 bloc을 제공합니다. 이는 의존성 주입(DI) 위젯으로 사용되어 서브트리 내에서 여러 위젯에 대해 단일 bloc 인스턴스를 제공할 수 있도록 합니다.\n\n대부분의 경우 BlocProvider는 서브트리의 나머지 부분에서 사용할 새로운 bloc을 생성하는 데 사용되어야 합니다. 이 경우 BlocProvider는 bloc을 생성하는 것에 대한 책임이 있으므로 자동으로 그것을 닫아 줄 것입니다. (출처: Flutter Bloc 문서)\n\n<div class=\"content-ad\"></div>\n\n이 Bloc을 main.dart의 최상위 부모 위젯 (MaterialApp)에 제공합니다.\n\nBloc 이벤트를 초기화하고 상태를 관리합니다\n\n제품을 표시하는 페이지가 생성되었을 때 (initState) 이 페이지의 초기화에서 Bloc 이벤트 (GetProductEvent)를 호출하거나 추가합니다.\n\n```js\n@override\nvoid initState() {\n  context.read<ProductBloc>().add(GetProductEvent());\n  super.initState();\n}\n```\n\n<div class=\"content-ad\"></div>\n\nGetProductEvent이 호출될 때, BlocBuilder는 상태를 통해 생성되는 위젯(제품 로딩 위젯, 제품 로딩 오류 위젯 등)을 관리할 수 있는 Bloc 위젯으로 추가됩니다.\n\n만세! 위 예제를 통해 Flutter Bloc을 사용한 API 통합 및 상태 관리의 기본 개념이 설명되었습니다.\n\n이 예제의 전체 프로젝트 코드는 GitHub에서 확인할 수 있습니다: https://github.com/waleajepe/flutter_bloc_api\n\n이 개념을 더 잘 이해하기 위해 Flutter Bloc 라이브러리 팀 (Very Good Ventures 팀)이 제공하는 더 많은 예제를 읽고 확인하는 것이 좋습니다: https://bloclibrary.dev/getting-started/\n\n<div class=\"content-ad\"></div>\n\n만약 이 기사가 도움이 되었다면 👏 몇 개 클랩(claps)도 부탁드려요. 댓글 섹션에 기여와 수정 사항을 남겨주셔도 됩니다. 건배! 👊😊\n","ogImage":{"url":"/assets/img/2024-06-19-APIIntegrationandStateManagementwithFlutterBLoCLibrary_0.png"},"coverImage":"/assets/img/2024-06-19-APIIntegrationandStateManagementwithFlutterBLoCLibrary_0.png","tag":["Tech"],"readingTime":9},{"title":"플러터플로우 Low-Code 앱 개발을 위한 빠른 프로토타이핑 좋은 점, 나쁜 점 및 플로우","description":"","date":"2024-06-19 08:06","slug":"2024-06-19-FlutterFlowRapidPrototypingforLow-CodeAppDevelopmentTheGoodtheBadandtheFlow","content":"\n\n플러터플로우는 로우코드 앱 개발 분야에서 중요한 역할을 하는 기업으로 떠오르고 있어요. 와이컴비네이터의 지원을 받은 플러터플로우는 구글 클라우드와 협력하여 1,250,000명 이상의 사용자로 이루어진 활발한 커뮤니티를 자랑해요. 그런데 무엇이 이렇게 매력적으로 만드는 걸까요? 그리고 여러분의 프로젝트에 정말로 적합한 도구일까요? 함께 알아봐요.\n\n![이미지](/assets/img/2024-06-19-FlutterFlowRapidPrototypingforLow-CodeAppDevelopmentTheGoodtheBadandtheFlow_0.png)\n\n# 플러터플로우란 무엇인가요?\n\n플러터플로우는 플러터(Flutter)를 활용한 비주얼 앱 빌더로, 구글의 오픈소스 UI 소프트웨어 개발 키트입니다. 이를 통해 광범위한 코딩 지식 없이도 모바일 및 웹용 고품질의 크로스 플랫폼 앱을 만들 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n# 개발 가속화를 위한 핵심 기능\n\nFlutterFlow는 앱 개발 프로세스를 간소화하기 위해 설계된 다양한 기능을 제공합니다:\n\n- 테마 설정 및 드래그 앤 드롭 UI: FlutterFlow의 디자인 시스템을 활용해 앱에 일관되고 반응형 비주얼 스타일을 생성할 수 있습니다. 몇 번의 클릭으로 색상, 글꼴 및 위젯 테마를 정의하고 다크 모드를 구현할 수 있습니다. 맞춤형 테마로 시각적으로 매력적인 인터페이스를 구축하기 쉽습니다. 미리 제작된 UI 구성 요소(버튼, 텍스트 필드, 이미지 등)를 앱 캔버스에 직접 끌어다 놓아 크기, 색상, 정렬 등의 속성을 시각적 편집기를 통해 조정할 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-FlutterFlowRapidPrototypingforLow-CodeAppDevelopmentTheGoodtheBadandtheFlow_1.png)\n\n<div class=\"content-ad\"></div>\n\n- 액션 플로우 편집기: 이 플로우차트 형식의 시스템은 단순한 UI 디자인을 넘어서며 복잡한 앱 동작을 정의하는 데 활용할 수 있습니다. 화면 간 이동, 사용자 입력 처리, 애니메이션 트리거 등을 코드를 작성하지 않고도 정의할 수 있습니다. 액션은 시각적 다이어그램으로 연결되어 있어 기본 프로그래밍 지식만 갖춘 사람들도 직관적으로 작업할 수 있습니다.\n\n![image](/assets/img/2024-06-19-FlutterFlowRapidPrototypingforLow-CodeAppDevelopmentTheGoodtheBadandtheFlow_2.png)\n\n- 맞춤화: 내장되지 않은 기능도 플러터플로우를 통해 상당히 맞춤화할 수 있습니다. 고유한 UI 요소를 추가하거나 서드파티 라이브러리와 통합하기 위해 사용자 정의 위젯을 생성할 수 있습니다. 사용자 정의 함수를 사용하여 특정 로직을 처리할 JavaScript 스니펫을 작성할 수 있습니다. 사용자 정의 액션은 기본적으로 액션 플로우 편집기 내에서 재사용 가능한 로직으로 작동하는 함수로, 패키지화된 로직을 만들 수 있습니다.\n- AI 기반 생성: 플러터플로우는 개발 가속화를 위해 두 가지 다른 방식으로 AI를 활용합니다: 1. 페이지 및 구성 요소 생성: 필요한 페이지 또는 구성 요소의 유형을 설명하면(예: \"이미지 캐러셀과 '장바구니에 추가' 버튼이 있는 제품 세부정보 페이지\"), AI가 코드 제안이나 완전한 레이아웃을 생성해줍니다. 아이디어 프로토타입을 신속히 만들거나 디자인 장벽을 극복하는 데 특히 유용합니다. 2. 코딩 코파일럿: 이 AI 기반 어시스턴트는 사용자 정의 기능과 액션을 작성하는 데 도움을 줍니다. 원하는 기능을 자연어로 설명하면 코파일럿이 코드 스니펫이나 완전한 함수를 제안해줍니다. 의도를 이해하고 지능적인 제안을 해주는 코딩 파트너가 있는 것처럼 동작합니다.\n\n# 백엔드 통합: Firebase 대 Supabase\n\n<div class=\"content-ad\"></div>\n\nFlutterFlow은 Firebase와 Supabase와의 완벽한 통합을 제공하여 강력한 백엔드 서비스를 선택할 수 있도록 합니다.\n\n- Firebase: 구글이 후원하는 이 플랫폼은 실시간 데이터베이스, 인증, 클라우드 함수, 저장소 및 호스팅으로 유명합니다. FlutterFlow의 통합은 앱을 이러한 서비스에 연결하여 사용자 로그인, 파일, 이미지 및 비디오 업로드, 클라우드 기반 로직과 같은 기능을 쉽게 활성화할 수 있도록 합니다.\n\n![image](/assets/img/2024-06-19-FlutterFlowRapidPrototypingforLow-CodeAppDevelopmentTheGoodtheBadandtheFlow_3.png)\n\n- Supabase: PostgreSQL을 기반으로 한 Firebase의 오픈 소스 대안을 제공합니다. 관계형 데이터베이스와 실시간 기능을 갖추며 인증, 저장소 및 엣지 함수를 제공합니다. FlutterFlow의 통합은 Firebase보다 성숙도가 낮지만 SQL 데이터베이스를 선호하거나 더 많은 유연성을 원하는 사용자에게는 좋은 선택지입니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Image](/assets/img/2024-06-19-FlutterFlowRapidPrototypingforLow-CodeAppDevelopmentTheGoodtheBadandtheFlow_4.png)\n\n# 광범위한 통합\n\nFlutterFlow는 다음과 같은 기능을 위한 사용 준비 완료 통합 라이브러리를 제공합니다:\n\n- Google Maps: 상호 작용하는 지도 및 위치 기반 서비스를 앱에 포함시킵니다.\n- 푸시 알림: 대상 메시지를 사용자 장치로 전송합니다.\n- OneSignal: 이메일 및 SMS를 보낼 수 있는 강력한 플랫폼.\n- Mux Livestream: 앱에 라이브 스트리밍 기능을 추가합니다.\n- Gemini AI: 챗봇 및 이미지 인식과 같은 AI 기능을 추가합니다.\n- API 통합 및 클라우드 함수: 외부 서비스 또는 사용자 정의 백엔드 로직과 통합합니다.\n\n\n<div class=\"content-ad\"></div>\n\n# 발행, 분석 및 수익화\n\nFlutterFlow은 Play Store와 App Store와의 직접 통합을 통해 앱 게시를 간단하게 합니다. Google Analytics와 Firebase 충돌 보고를 사용하여 사용자의 행동을 추적하고, AdMob, Stripe 또는 RevenueCat으로 수익을 창출할 수 있습니다.\n\n# 내 평가: 장단점\n\n장점:\n\n<div class=\"content-ad\"></div>\n\n- 빠른 프로토타입 및 개발.\n- MVP 및 간단한 앱에 탁월함.\n- 포괄적인 기본 기능 및 통합.\n- 플러터 라이브러리의 사용자 정의 및 활용 가능.\n- 지원하는 커뮤니티가 활발함.\n\n단점:\n\n- 브랜치 병합이 어려울 수 있음 (지속적으로 개선 중).\n- 고객 지원 시간은 영업일과 미국 시간대에 고정되어 있음.\n- 클라우드 기능 버그 해결이 어려울 수 있음.\n- 코드는 내보낼 수 있지만 다시 가져올 수는 없음.\n- 생성된 코드는 FlutterFlow 외부에서 편집할 수 없지만 FlutterFlow 외부에서 사용자 정의 코드를 테스트하고 다시 FlutterFlow로 복사할 수 있음.\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\n플러터플로우는 깊은 코딩 지식 없이 빠르게 기능이 있는 앱을 만들고 싶은 개인 및 소규모 팀에게 훌륭한 도구입니다. 그러나 코드베이스 브랜치 및 병합, 플러터 상태 관리 및 사용자 지정 코드 유지보수와 관련된 부분에서는 기능이 제한될 수 있어서, 요구 사항이 복잡한 대규모 팀이나 프로젝트에는 맞지 않을 수 있습니다.\n\n아이디어를 검증하거나 비교적 간단한 앱을 만들고자 하는 경우에는 플러터플로우를 살펴볼 가치가 있습니다. 그러나 규모 확장이나 코드베이스에 세밀한 제어가 필요한 경우에는 플러터를 직접 사용하는 것을 고려해보세요.\n\n플러터 애플리케이션을 만들고 싶은 창업자이신가요?\n\ncto@ctoforstartups.com으로 연락주시거나 여기에 메시지를 남기시면 저희가 연락드리겠습니다. 앱 아이디어를 실현하는 방법에 대해 함께 논의해봐요!","ogImage":{"url":"/assets/img/2024-06-19-FlutterFlowRapidPrototypingforLow-CodeAppDevelopmentTheGoodtheBadandtheFlow_0.png"},"coverImage":"/assets/img/2024-06-19-FlutterFlowRapidPrototypingforLow-CodeAppDevelopmentTheGoodtheBadandtheFlow_0.png","tag":["Tech"],"readingTime":5},{"title":"플러터를 배워야 하는 이유","description":"","date":"2024-06-19 08:05","slug":"2024-06-19-WhyYouShouldLearnFlutter","content":"\n\n그 '플러터가 죽고 있는가?' 글을 또 읽었어요. 거의 우스워요. 왜 그렇게 많은 사람들이 이에 대해 포스팅하는지 이해가 안 가네요.\n\n아마도 플러터가 너무 쉽다는 심금을 닫고 있는 믿음 때문인가요? \"플러터가 진짜일 리가 없어. 너무 간단하니까. 꿈꾸고 있는 거예요, 그렇죠?\"\n\n저는 플러터가 사라질 위험이 있는 것 같지 않아요. 저번 포스트에서 주장했던 것처럼 많은 사람들이 사용하고 있고, 구글도 포함되어 있으니까요. 그래서 '플러터가 죽고 있는가'라는 글을 또 보면 실로 우습다는 생각이 들어요. 하지만 읽었던 글 중에서 정확히 동의하진 않는 부분이 있어요.\n\n그 댓글이 진짜 짜증나요. 곰곰이 생각해 보니 언어를 배우는 이유는 다양한데 'XYZ 언어는 배우지 마세요'라고 말하는 건 단순해서 어떤 맥락도 고려하지 않고 이야기하는 안 좋은 조언이에요.\n\n<div class=\"content-ad\"></div>\n\n언어를 배우는 가장 중요한 이유는 취업이라고 생각해요. 그리고 언어를 배우는 이유가 단지 취업 때문이라면, 그렇죠, 플러터를 배우지 않아도 돼요. 사실 여기서도 그렇게 언급했어요.\n\n플러터는 아직 너무 새로운 기술이라서 많은 사람들이 사용하고 있지 않아요. 앞으로 플러터 포지션의 잠재력을 볼 수는 있지만, 지금은 수요가 충분하지 않아요.\n\n다만 저는 개인적으로 취업을 위해 언어를 배우는 건 강력한 이유라고 보지 않아요. 취업을 목적으로 임의의 언어를 배우는 게 좋지 않아요. 채용 공고를 보고, 충분히 많이 Go를 언급하는 채용 공고를 보면 Go를 배우게 되고요. 충분히 많이 C#을 언급하는 채용 공고를 보면 C#을 배우게 되는 거죠. 실제로 Flutter를 언급하는 채용 공고를 몇 개 보았어요. 하지만 다른 프로그래밍 언어들보다는 훨씬 적었어요. 그동안 오랜 시간 동안 사용되어온 다른 프로그래밍 언어들만큼 많지 않았어요.\n\n또한, 저는 Go 프로그래밍 여정에서 Go에 대해 왜 이렇게 많은 어리석은 일을 하는지 궁금해했어요. 그 결론은 2007년에 발명되었기 때문에, 현대 프로그래밍 아이디어가 많이 나오기 전이었기 때문이에요. 그저 시대 문제일 뿐이에요. Dart는 2017년에 출시된 Flutter 이후에야 인기를 얻었기 때문에, 그저 시간 문제일 뿐이에요. 더 기다리세요. 10년 후면 누구나 플러터 개발자를 찾을 거예요.\n\n<div class=\"content-ad\"></div>\n\n프로그래밍 언어에 동기부여를 받는 가장 좋은 방법 중 하나는 사이드 프로젝트를 진행하는 것입니다. 많은 프로그래머가 사이드 프로젝트를 갖고 있지 않다는 것을 알고 있습니다. 사이드 프로젝트가 없어도 전혀 괜찮아요. 하지만 많은 프로그래머들이 사이드 프로젝트를 가지고 있죠. 자신이 더 잘할 수 있는 부분을 발견하고 스스로 해결해나가는 것이 쉬운 방법이기 때문입니다. 제가 개발한 RSS 리더 Stratum(iOS, Android)와 언어 학습 앱 Litany(iOS, Android) 역시 그런 아이디어에서 출발되었습니다.\n\n사이드 프로젝트를 진행해보고 싶다면 Flutter를 강력히 고려해보세요. 왜냐하면 Flutter에는 여러 가지 이유가 있기 때문이에요. 일단, 이 프레임워크는 믿을만하고 직관적입니다. 또한, Windows, Mac, Linux, Android, iOS, 웹에 대해 빌드할 수 있습니다. 그리고 제가 이전 글에서 언급한 대로 Dart와 Flutter에 대한 풍부한 문서가 있습니다. 하지만 아마도 가장 중요한 점은 Flutter를 구동하는 언어인 Dart가 사용하기 아주 쉽다는 점입니다.\n\nDart는 C 스타일의 객체 지향 언어입니다. 멋진 언어죠. COOL이란 말은 원래 C#의 이름이었지만 마이크로소프트가 상표 문제로 결정하지 않았습니다. 하지만 이러한 분류인 'C 스타일 객체 지향 언어'라는 용어를 좋아합니다. 이는 모두 객체 지향적인 C 스타일의 언어들이라는 것을 잘 알려주거든요.\n\n한 가지 COOL 언어를 알고 있다면 다른 언어를 쉽게 배우실 수 있습니다. 특히 비슷한 언어일수록 더욱 쉽게 배우실 수 있습니다. 그리고 Dart는 자바나 C#과 매우 유사합니다.\n\n<div class=\"content-ad\"></div>\n\n사실, 플러터를 사용하기 전에 Unity(C#을 사용)에서 프로그래밍을 하고 있었는데, C#과 Dart가 얼마나 비슷한지 놀랐습니다. 가장 큰 차이점은 Dart가 조금 더 간결하다는 것입니다. 그래서 public 또는 private는 없고 언더스코어로 처리됩니다. 그리고 factory 생성자와 foo(this.x, this.y)와 같은 생성자가 있습니다.\n\n저는 null 안전성이 도입되기 전에 Dart를 사용하기 시작했지만, null 안전성은 몇 가지를 변경했습니다. 많이는 아닙니다. 다른 C 스타일 객체지향 언어를 알고 있다면 Dart를 매우 빠르게 익힐 수 있습니다. 아마도 하루만에도 가능할 정도로 간단합니다.\n\nFlutter를 배우지 않겠다고 말했던 것을 되돌릴 수도 있을 것 같습니다. 일자리가 매우 적다는 것을 고려해야 하기 때문입니다. 또한 언어를 실제로 배우는 난이도도 고려해야 합니다.\n\n많은 언어는 매우 지루한 프로젝트를 중심으로 돌아가기 때문에 쉽게 익히기가 어려울 수 있습니다. 그러나 Flutter를 사용하면 앱을 만들 수 있습니다. 그리고 굉장히 쉽게 만들 수도 있습니다. 그리고 그 앱은 이제 Windows, Mac, Linux, iOS, Android, 웹에서도 실행할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n플러터는 매년 더욱 인기를 끌 것입니다. 결국 플러터 관련 직업이 많이 나올 것이라고 생각해요.\n\n그래서 원래 글이 전부 틀린 것은 아닐 수도 있어요. '놀기만 하고 싶다면 그렇게 해도 괜찮을 거야' 라는 말이 맞았군요. 그렇다면, 진지하게 배우고 싶지 않다면 '언어를 배운다'는게 무슨 뜻인가요? 진지하게 공부하고 싶다면 면접 질문들을 많이 읽어보세요.\n\n저는 그 글의 말대로 '진지한 전문 개발자'는 아니에요. 언어를 배우는 것을 즐기는 것을 더 좋아해요. 플러터는 재미있어요. 그리고 정말 멋진 것을 만들어낼 수 있어요.\n\n그겼 초보자에게는 자바스크립트와 비슷합니다. 다만, 플러터는 언어 자체가 좋다는 것이 다릅니다. 자바스크립트를 사용하면 물론 웹을 만들 수 있고, Electron으로 데스크톱 앱을 만들 수 있고, React Native로 모바일 앱을 만들 수 있어요. 하지만 플러터를 사용하면 세 가지를 한 번에 간단한 코드베이스로 만들 수 있어요. 이것과 유사한 기술이 없어요. 그래서 플러터를 배워야 하는 이유죠.","ogImage":{"url":"/assets/img/2024-06-19-WhyYouShouldLearnFlutter_0.png"},"coverImage":"/assets/img/2024-06-19-WhyYouShouldLearnFlutter_0.png","tag":["Tech"],"readingTime":4}],"page":"26","totalPageCount":29,"totalPageGroupCount":2,"lastPageGroup":9,"currentPageGroup":1},"__N_SSG":true}