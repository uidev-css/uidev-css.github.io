{"pageProps":{"posts":[{"title":"Flutter 애니메이션 종합 가이드","description":"","date":"2024-06-21 22:15","slug":"2024-06-21-FlutterAnimationsComprehensiveGuide","content":"\n\n이 기사에서는 플러터 애니메이션에 대해 자세히 설명하고 여러 예제와 함께 다루어보겠습니다. 이 기사를 끝까지 읽으면 다양한 복잡성을 갖는 애니메이션을 플러터 앱에 추가할 수 있을 것입니다. 또한 플러터에서 제공하는 다양한 접근 방법 중에서 여러분의 애니메이션 목표에 가장 적합한 것을 알게 될 것입니다. 그럼 바로 시작해 봅시다!\n\n![Flutter Animations](/assets/img/2024-06-21-FlutterAnimationsComprehensiveGuide_0.png)\n\n## 목차:\n\n- 소개\n- 암시적 애니메이션 - AnimatedFoo 위젯\n- 암시적 애니메이션 - TweenAnimationBuilder 위젯\n- 명시적 애니메이션 - FooTransition 위젯\n- AnimationController\n- 명시적 애니메이션 - AnimatedBuilder 위젯\n- 명시적 애니메이션 - AnimatedWidget 클래스\n- 올바른 애니메이션 접근 방법 선택하기\n- 서드파티 패키지를 사용한 애니메이션\n\n<div class=\"content-ad\"></div>\n\n## TL;DR\n\n이 튜토리얼에서 모든 애니메이션의 코드를 DartPad에서 볼 수 있어요. 코드를 손대면서 실험해보세요.\n\n최근에는 이 튜토리얼을 요약한 트위터 스레드도 올렸어요. 한 번 확인해보세요.\n\n# 소개\n\n<div class=\"content-ad\"></div>\n\n플러터 앱에서 애니메이션은 기본적으로 두 가지 유형으로 볼 수 있어요: 그리기 기반 애니메이션과 코드 기반 애니메이션이에요. 그리기 기반 애니메이션은 애니메이션된 그래픽, 벡터, 캐릭터 또는 \"그려진\" 모든 것을 말해요. 한편, 코드 기반 애니메이션은 위젯 레이아웃 및 스타일(리스트, 색상, 텍스트 등)에 중점을 두었어요. 이 글의 끝에는 그리기 기반 애니메이션에 대해 간략히 다뤄볼 거에요. 그러나 그들은 보통 3rd party 프레임워크/패키지를 사용하여 달성되므로, 우리는 코드 기반 애니메이션에보다 초점을 맞출 거예요. 코드 기반 애니메이션은 제한적이라는 의미가 아니라, 그 반대로 플러터 애니메이션을 통해 완전히 멋진, 창의적이고 매우 복잡한 애니메이션을 만들 수 있어요. 3rd party 패키지가 필요하지 않아요!\n\n플러터의 코드 기반 애니메이션에는 암시적 애니메이션 및 명시적 애니메이션이 두 가지 유형이 있어요. 이러한 유형 각각에서 준비된 위젯을 사용하거나 직접 위젯을 만들 수 있어요. 각 유형에 대해 몇 가지 예제와 함께 더 자세히 알아보겠어요.\n\n# 1. 암시적 애니메이션\n\n맨 위로 이동하기 👆🏼\n\n<div class=\"content-ad\"></div>\n\n가장 간단하고 사용하기 쉬운 애니메이션입니다. 값만 변경하면 애니메이션이 트리거되고, Flutter가 모든 것을 자동으로 처리해줍니다.\n\n## 1.1 준비된 위젯으로 암묵적 애니메이션\n\n이들은 AnimatedFoo 위젯이라고 불립니다. 여기서 Foo는 애니메이션 속성을 나타냅니다. 대부분은 이미 알고 사용하는 위젯의 애니메이션 버전입니다. 예를 들어 Container/AnimatedContainer, Padding/AnimatedPadding, Positioned/AnimatedPositioned 등이 있습니다.\n\n예를 들어, 다음 애니메이션을 확인해보세요:\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"https://miro.medium.com/v2/resize:fit:930/1*cjoraoQHodaUhNx7z2n1aA.gif\" />\n\n이 애니메이션은 AnimatedContainer, AnimatedPositioned 및 AnimatedDefaultTextStyle 위젯만을 사용하여 구현되었습니다. 지속 시간 값을 지정하고 변경 가능한 변수를 제공하면 끝입니다!\n\n```js\nAnimatedPositioned(\n  top: selectedItemIndex * itemHeight,\n  left: 0,\n  right: 0,\n  duration: const Duration(milliseconds: 200),\n  curve: Curves.easeInOut,\n  child: //...\n),\n//...\nAnimatedContainer(\n  duration: const Duration(milliseconds: 200),\n  curve: Curves.easeInOut,\n  decoration: BoxDecoration(\n    color: selectedItemIndex == i ? yellow : pink,\n    border: Border.all(\n      color: selectedItemIndex == i\n          ? Colors.white\n          : Colors.transparent,\n      width: 2,\n    ),\n  ),\n  child: AnimatedDefaultTextStyle(\n    duration: const Duration(milliseconds: 200),\n    style: TextStyle(\n      color: selectedItemIndex == i\n          ? Colors.black\n          : Colors.white,\n    ),\n    child: const Text('Featured!'),\n  ),\n),\n```\n\n그리고 간단히 각 목록 항목은 아래와 같은 onTap 메서드가 있는 InkWell 위젯으로 래핑되어 있습니다:\n\n\n<div class=\"content-ad\"></div>\n\n```js\nonTap: () => setState(() => selectedItemIndex = i),\n```\n\n이렇게 하면 애니메이션을 트리거할 수 있어요!\n\n여기 사용 가능한 AnimatedFoo 위젯 전체 목록이 있어요.\n\n따라서 우리는 AnimatedFoo 위젯을 투명도, 패딩, 정렬, 위치와 같은 속성용으로 가지고 있어요. 하지만 다른 속성을 애니메이션화하고 싶을 때 어떡하나요? 그럼 여전히 쉽고 빠르게 사용하고 싶어요.\n\n<div class=\"content-ad\"></div>\n\n## 1.2. TweenAnimationBuilder를 사용한 암시적 애니메이션\n\n화면 맨 위로 이동 👆🏼\n\nTweenAnimationBuilder를 사용하면 Tween 클래스를 사용하여 모든 위젯의 속성을 암시적으로 애니메이트할 수 있습니다. Tween 클래스의 이름은 \"Between\"에서 따왔습니다. 기본적으로 애니메이트해야 할 시작 및 끝 값을 제공합니다. 그리고 TweenAnimationBuilder 위젯의 빌더는 애니메이션 값으로 제공되며 이 값을 해당 빌더에서 반환하는 위젯의 어떤 속성에 적용할 수 있습니다.\n\n다음은 예시 애니메이션입니다:\n\n<div class=\"content-ad\"></div>\n\n아래는 해당 코드입니다:\n\n```js\nTweenAnimationBuilder(\n  duration: const Duration(milliseconds: 200),\n  tween: Tween<double>(begin: 0.01, end: _sliderValue),\n  child: Container(\n    decoration: BoxDecoration(\n      //...\n    ),\n    child: Slider(\n      value: _sliderValue,\n      min: 0.01,\n      onChanged: (value) {\n        setState(() => _sliderValue = value);\n      },\n    ),\n  ),\n  builder: (BuildContext context, double? value, Widget? child) {\n    return ClipRect(\n      child: BackdropFilter(\n        filter: ImageFilter.blur(\n          sigmaX: 40 * (value ?? 0.01),\n          sigmaY: 40 * (value ?? 0.01),\n        ),\n        child: child,\n      ),\n    );\n  },\n);\n```\n\n_sliderValue 변수는 0.01에서 1로 변경됩니다. 따라서 각 값의 변경마다 애니메이션이 트리거되며 BackdropFilter 위젯의 sigmaX 및 sigmaY 속성을 위한 새 값으로 다시 빌더 함수가 재구성됩니다. (0 값을 주면 BackdropFilter 위젯이 웹에서 오류를 발생시키기 때문에 0.01을 사용했습니다.)\n\n<div class=\"content-ad\"></div>\n\nTweenAnimationBuilder의 child 매개변수를 사용하여 더 나은 성능을 위해 빌더를 활용하고 있어요. 이 child는 애니메이션이 트리거될 때마다 다시 빌드하는 대신 한 번만 다시 빌드되어요.\n\n좋아요, 쉬운 내용은 끝났습니다. 이제 본격적인 내용을 시작해볼까요?\n\n# 2. 명시적 애니메이션\n\n맨 위로 돌아가기 👆🏼\n\n<div class=\"content-ad\"></div>\n\n암시적 애니메이션에서 AnimatedFoo 또는 TweenAnimationBuilder 위젯 내부의 값만 변경하면 애니메이션이 트리거되었던 것을 기억하시나요? 그러나 명시적 애니메이션은 \"명시적으로\" 애니메이트할 때까지 애니메이션을 트리거하지 않습니다. 애니메이션을 시작하고 어떻게 애니메이트할지 및 AnimationController를 사용하여 애니메이션을 \"제어\"하는 방법을 알려주어야 합니다.\n\n명시적 애니메이션 역시 암시적 애니메이션과 유사하게 사용하기 쉬운 위젯과 사용자 정의 수준이 추가된 위젯이 준비되어 있어 자유롭게 사용할 수 있습니다!\n\n그런데, AnimationController가 무엇인지 궁금하시죠? 이를 사용하는 명시적 애니메이션 위젯에 대해 알아보기 전에 먼저 AnimationController에 대해 학습해 보겠습니다.\n\n## AnimationController\n\n<div class=\"content-ad\"></div>\n\n위로 이동 👆🏼\n\n```js\nAnimationController({\n  double? value,\n  this.duration,\n  this.reverseDuration,\n  this.debugLabel,\n  this.lowerBound = 0.0,\n  this.upperBound = 1.0,\n  this.animationBehavior = AnimationBehavior.normal,\n  required TickerProvider vsync,\n})\n```\n\n이전에 언급했듯이 AnimationController를 사용하면 애니메이션을 \"제어\"할 수 있습니다. 그를 위해서는 vsync 값이 TickerProvider 유형이 필요합니다. Ticker는 기본적으로 Flutter의 프레임 렌더링을 추적하고 컨트롤러가 해당 티커를 따라가서 지정된 기간 내에 '애니메이션'할 수 있도록 허용하며, 기본적으로 0과 1인 lowerBound 및 upperBound 값 사이에서 선형으로 값들을 생성합니다.\n\n결과적으로, AnimationController를 사용하면 다음을 할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n- forward()을 호출하여 애니메이션을 앞으로 재생합니다.\n- reverse()를 호출하여 애니메이션을 역방향으로 재생합니다.\n- stop()을 호출하여 애니메이션을 멈춥니다.\n- repeat()을 호출하여 애니메이션을 가시 상태인 한 계속 반복합니다.\n- reset()을 호출하여 애니메이션을 lowerBound로 재설정합니다.\n- 값을 설정합니다.\n- isAnimating, isCompleted, isDismissed 등과 같이 애니메이션의 상태를 알아내기 위해 다양한 get 함수에 액세스합니다.\n\n자, 이 멋진 놈을 사용하여 실제 작업을 확인해 보겠습니다 🎬\n\n## 2.1. 준비된 위젯을 사용한 명시적 애니메이션\n\n맨 위로 이동 👆🏼\n\n<div class=\"content-ad\"></div>\n\n그들은 FooTransition 위젯이라고 불립니다. 이 때 Foo는 위젯의 애니메이션 속성입니다. 일부는 당신이 사용하는 일반 위젯의 애니메이션 가능한 위젯들입니다. 예를 들어, AlignTransition, PositionedTransition가 있습니다.\n\n이 애니메이션을 확인해보세요:\n\n![animation](https://miro.medium.com/v2/resize:fit:1400/1*GYCKdoQEUQeblnBoyoEHjQ.gif)\n\n이것은 AlignTransition 및 RotationTransition 위젯을 사용하여 달성되었습니다.\n\n<div class=\"content-ad\"></div>\n\n코드 분석:\n\n- 10번 줄 및 17번 줄: AnimationController를 초기화하고 정의합니다.\n- AnimationController의 vsync 값 (19번 줄)은 SingleTickerProviderStateMixin(9번 줄)에서 가져온 값입니다. 이 mixin은 우리에게 이야기한 TickerProvider를 제공합니다. 또한 위젯이 보이는 상태일 때만 애니메이션이 실행되도록 보장합니다.\n- 11번 줄 및 22번 줄: AlignTransition 위젯의 Animation을 초기화하고 정의합니다 (51번 줄). AlignmentGeometry 유형의 Tween을 사용하여 애니메이션을 정의합니다. 결국, 애니메이션은 Alignment.centerLeft에서 Alignment.centerRight로 애니메이션될 것임을 알려주고 Tween의 animate 메서드를 호출하여 이 애니메이션을 AnimationController와 연결한 후 AlignmentGeometry 유형의 Animation을 반환합니다. 이렇게 하면 AnimationController의 하한 및 상한이 아니라 Tween의 시작 및 종료 값 사이에서 애니메이션이 작동합니다.\n\n- 12번 줄 및 32번 줄: RotationTransition 위젯의 회전 속성(turns)의 애니메이션을 초기화하고 정의합니다 (53번 줄). 따라서 0부터 2까지의 시작 및 종료 값이 있으므로, 애니메이션이 끝나면 위젯은 두 번 회전할 것입니다.\n- 20번 줄: AnimationController에 반복을 호출하여 애니메이션이 계속되도록 만듭니다. 그리고 reverse를 true로 설정하면 애니메이션이 순방향으로 시작하여 반대로, 다시 순방향으로, ... 이렇게 반복됩니다.\n- 42번 줄: 위젯의 상태가 dispose되는 시점에 AnimationController를 폐기(dispose)합니다. 메모리 누수를 방지하기 위해 AnimationController를 dispose하는 것은 항상 중요합니다!\n\n하지만 걱정하지 마세요. 조금의 연습으로 매우 쉬워지고 익숙해질 것입니다!\n\n<div class=\"content-ad\"></div>\n\n가능한 모든 FooTransition 위젯 목록입니다:\n\n암시적 애니메이션에서 AnimatedFoo 위젯이 애니메이션 목적에 충분하지 않을 때 어떻게 했는지 기억하나요? AnimatedFoo 위젯으로 처리되지 않은 속성을 애니메이션화하기 위해 TweenAnimationBuilder를 사용했습니다. 비슷하게, 명시적 애니메이션에서는 AnimatedBuilder 위젯을 사용하여 어떤 위젯 속성을 애니메이션화할 수 있습니다. 또는 더 나아가서 직접 FooTransition을 만들기 위해 AnimatedWidget 클래스를 사용할 수도 있습니다!\n\n## 2.2 AnimatedBuilder 위젯을 사용한 명시적 애니메이션\n\n맨 위로 이동 👆🏼\n\n<div class=\"content-ad\"></div>\n\n다음 애니메이션을 확인해보세요:\n\n![Animation](https://miro.medium.com/v2/resize:fit:1400/1*whGvEQM5o0b4W0hZIkgu_A.gif)\n\nGradientTransition 위젯이 없죠? 그럼 어떻게 만들었을까요? AnimatedBuilder 위젯을 이용했어요! 여기에 코드가 있어요:\n\n우리는 AnimationController를 초기화하고 정의했고 이를 AnimatedBuilder 위젯의 애니메이션 값으로 사용했어요. 이제 AnimatedBuilder는 컨트롤러의 값이 변경될 때마다 \"다시 빌드(build)\"되고 빌더를 호출하여 업데이트된 _controller.value 값을 가진 새 위젯을 반환해요. 이로써 그라데이션이 애니메이션 되게 만들었어요.\n\n<div class=\"content-ad\"></div>\n\n물론, AnimationController의 lowerBound 및 upperBound 값 이외의 것을 원한다면, 자체 Animation을 만들고 AnimationController에 연결한 다음 AnimatedBuilder 위젯에 전달할 수 있습니다.\n\n```dart\n_animation = Tween<double>(begin: 0, end: 0.5).animate(_controller);\n//...\nAnimatedBuilder(\n  animation: _animation,\n  builder: (context, child) {\n     //... 값 사용하기: _animation.value\n  }\n)\n```\n\n또한 AnimatedBuilder 위젯의 child 매개변수를 사용하여 성능을 향상시킬 수 있습니다. 이렇게 하면 매번 애니메이션 값이 변경될 때마다 다시 구축되지 않습니다.\n\n아직 따라오고 있나요? 조금만 더 힘내세요! 거의 끝났습니다!\n\n<div class=\"content-ad\"></div>\n\n이제 한 걸음 더 나아가서 AnimatedWidget 클래스를 사용하여 우리만의 FooTransition 위젯을 만들어보겠습니다!\n\n## 2.3 AnimatedWidget 클래스를 사용한 명시적 애니메이션\n\n맨 위로 이동 👆🏼\n\n아주 비밀스러운 비밀을 하나 알려줄게요. 어떤 FooTransition 위젯의 소스 코드로 가 보세요, 무엇을 보게 될까요?\n\n<div class=\"content-ad\"></div>\n\n\n![Image 1](/assets/img/2024-06-21-FlutterAnimationsComprehensiveGuide_1.png)\n\n😱 It extends an AnimatedWidget class, and from what we see, the Animation type parameter (in this case turns) is passed as a listenable to the super class:\n\n![Image 2](/assets/img/2024-06-21-FlutterAnimationsComprehensiveGuide_2.png)\n\nAnd the AnimatedWidget is basically a StatefulWidget! So we can do the exact same!\n\n\n<div class=\"content-ad\"></div>\n\n우리만의 GradientTransition 위젯을 만들어봅시다:\n\n```js\nclass GradientTransition extends AnimatedWidget {\n  final Animation<double> stop;\n\n  const GradientTransition({\n    Key? key,\n    required this.stop,\n  }) : super(key: key, listenable: stop);\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      height: 100,\n      decoration: BoxDecoration(\n        gradient: LinearGradient(\n          colors: const [purple, pink, yellow],\n          stops: [0, stop.value, 1],\n        ),\n      ),\n    );\n  }\n}\n```\n\n그리고 사용하기 위해서는 AnimationController를 그대로 전달하면 됩니다:\n\n```js\nGradientTransition(stop: _controller),\n```  \n\n<div class=\"content-ad\"></div>\n\n그게 다야!\n\n여기까지 버텨내 왔다면, 매우 간단한 것부터 매우 복잡한 것까지 다양한 플러터 애니메이션을 만들기에 충분한 지식을 가지고 있습니다. 필요한 건 조금의 연습뿐이며, 하늘이 한계입니다!\n\n# 적절한 애니메이션 접근 방식 선택\n\n맨 위로 이동 👆🏼\n\n<div class=\"content-ad\"></div>\n\n하지만 잠시만 기다려봐요. 위에서 다룬 여러 방법 중에서 어떤 애니메이션을 선택해야 하는지 어떻게 알 수 있을까요? 플러터(Flutter) 팀의 멋진 분들이 도와주기 위해 비디오와 의사결정 트리를 만들었어요. 제가 최대한 요약해 드릴게요.\n\n## 1. 그림 기반 vs. 코드 기반\n\n첫 번째 선택은 그림 기반 및 코드 기반 애니메이션 사이에서 이루어질 거예요. 이를 위해 자신에게 물어보세요. 만약 당신의 애니메이션이 그림처럼 더 비스무런가요(그림 기반 사용, 3rd party 패키지 사용, 곧 설명할 거예요) 아니면 레이아웃, 위젯, 위젯 스타일, 색상, 테두리, 텍스트 등과 관련이 있는가요(코드 기반 사용, 위에서 설명한 것)?\n\n## 2. 암시적(Implicit) vs. 명시적(Explicit)\n\n<div class=\"content-ad\"></div>\n\n다음 선택은 암시적 및 명시적 애니메이션 중 하나가 될 것입니다. 선택을 하는 데 고려해야 할 여러 기준이 있습니다:\n\n- 무한히 반복되는 애니메이션\n- 연속되지 않는 애니메이션: 애니메이션이 시작 지점으로 돌아가지 않음\n- 여러 위젯이 함께 애니메이션화되는 경우\n\n만약 애니메이션이 위의 기준 중 하나라도 가지고 있다면, 명시적 애니메이션을 사용해야 합니다.\n\n## 3. 내장 위젯 대 사용자 정의 위젯\n\n<div class=\"content-ad\"></div>\n\n마지막 선택 사항은 내장 위젯(AnimatedFoo 및 FooTransition 위젯)과 사용자 지정 위젯(TweenAnimationBuilder 및 AnimatedBuilder/AnimatedWidget) 사이에서 합니다. 이것은 이 목록을 보고 원하는 속성을 애니메이션화하기 위해 이미 내장된 위젯이 있는지 여부를 고려하는 것만큼 간단합니다. 해당 내장 위젯을 사용하거나 (그렇지 않으면 직접 생성)\n\n# 3rd Party 패키지를 사용한 애니메이션\n\n하지만 앱에서 그림을 기반으로 한 애니메이션을 사용하고 싶다면 어떨까요? 여기서는 코딩이 절약되었네요 🫢, 또한 플러터는 여기에서도 놀라울 정도로 좋습니다! Rive 및 Lottie와 같은 훌륭한 패키지들이 있어서 3rd party 애니메이션을 원활하게 통합하고 앱에 추가할 수 있습니다. 제공되는 애니메이션을 그래픽 디자이너/모션 그래픽 디자이너와 함께 사용하거나 커뮤니티에서 만든 애니메이션을 다운로드/구매하여 빠르고 쉽게 앱에 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n3rd party 패키지를 사용하여 Flutter에서 애니메이션을 만드는 데 관한 전용 기사를 작성할 예정이에요. 지금 당장 유용한 링크 몇 개를 공유해 드릴게요:\n\n- 사용 준비가 된 멋진 애니메이션을 볼 수 있는 Rive 커뮤니티 쇼케이스\n- Rive Flutter 패키지\n- 무료 LottieFiles 애니메이션\n- LottieFiles Flutter 패키지\n\n여기까지가 제 글이에요! 이 기사를 읽어 주셔서 감사합니다. 이것이 Flutter 앱에 애니메이션을 추가하고 싶을 때 여러분의 정보원이 되었으면 좋겠어요. 그럼 여러분도 애니메이션을 넣을 때 즐겁게 시도해 보세요!\n\nhttps://twitter.com/FlutterComm","ogImage":{"url":"/assets/img/2024-06-21-FlutterAnimationsComprehensiveGuide_0.png"},"coverImage":"/assets/img/2024-06-21-FlutterAnimationsComprehensiveGuide_0.png","tag":["Tech"],"readingTime":12},{"title":"Flutter에서 Bloc을 사용한 상태 관리 마스터하기 종합 가이드","description":"","date":"2024-06-21 22:13","slug":"2024-06-21-MasteringStateManagementinFlutterwithBlocAComprehensiveGuide","content":"\n\n소개\n\n상태 관리는 견고하고 유지보수가 용이한 플러터 애플리케이션을 구축하는 중요한 측면입니다. 플러터는 다양한 상태 관리 옵션을 제공하며, 상태를 관리하는 가장 인기 있는 강력한 라이브러리 중 하나인 flutter_bloc 패키지가 있습니다. 이 포괄적인 가이드에서는 Bloc를 사용한 상태 관리의 기본 개념을 탐색하고 시작하는 데 도움이 되는 자세한 예제를 제공합니다.\n\n![마스터링 플러터 Bloc를 이용한 상태 관리: 포괄적인 가이드](/assets/img/2024-06-21-MasteringStateManagementinFlutterwithBlocAComprehensiveGuide_0.png)\n\n# 플러터 Bloc이란 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\nflutter_bloc은 Flutter 애플리케이션의 상태를 관리하기 위해 BLoC (Business Logic Component) 패턴을 활용하는 라이브러리입니다. 이는 데이터 및 이벤트의 흐름을 처리하는 구조화된 방법을 제공하여 코드베이스를 더 조직화하고 유지보수하기 쉽게 만들어줍니다. Bloc은 프리젠테이션 레이어를 비즈니스 로직에서 분리함으로써 깨끗하고 확장 가능한 아키텍처를 장려합니다.\n\n# Flutter 프로젝트 설정하기\n\n예제에 들어가기 전에 새로운 Flutter 프로젝트를 설정하고 flutter_bloc 패키지를 종속성으로 추가해 봅시다. 이를 위해 다음 단계를 따라주세요:\n\n- 다음 명령어를 사용하여 새로운 Flutter 프로젝트를 생성합니다:\n\n<div class=\"content-ad\"></div>\n\n\n```js\nflutter create my_bloc_app\n```\n\n2. 즐겨 사용하는 코드 편집기에서 프로젝트를 엽니다.\n\n3. pubspec.yaml 파일에 flutter_bloc를 추가하세요:\n\n```js\ndependencies:\n  flutter:\n    sdk: flutter\n  flutter_bloc: ^7.0.0\n```\n\n<div class=\"content-ad\"></div>\n\n4. 의존성을 가져와 설치하려면 `flutter pub get`을 실행하세요.\n\n# 카운터 앱 예제\n\n이제 Bloc을 사용하여 카운터의 상태를 관리하는 간단한 Flutter 앱을 만들어 보겠습니다. 이 예제에서는 Bloc을 설정하는 방법, 이벤트와 상태를 만드는 방법 및 BlocProvider를 만드는 방법을 보여줍니다.\n\n# 1. Bloc 만들기\n\n<div class=\"content-ad\"></div>\n\n프로젝트에서 Bloc을 위한 새 Dart 파일을 만드세요. counter_bloc.dart라고 이름 짓겠어요.\n\n```dart\nimport 'package:flutter_bloc/flutter_bloc.dart';\n\n// 이벤트\nabstract class CounterEvent {}\n\nclass IncrementEvent extends CounterEvent {}\n\nclass DecrementEvent extends CounterEvent {}\n\n// 상태\nabstract class CounterState {}\n\nclass InitialState extends CounterState {}\n\nclass UpdatedState extends CounterState {\n  final int count;\n\n  UpdatedState(this.count);\n}\n\n// Bloc\nclass CounterBloc extends Bloc<CounterEvent, CounterState> {\n  CounterBloc() : super(InitialState());\n\n  @override\n  Stream<CounterState> mapEventToState(CounterEvent event) async* {\n    if (event is IncrementEvent) {\n      yield UpdatedState(state is UpdatedState ? (state as UpdatedState).count + 1 : 1);\n    } else if (event is DecrementEvent) {\n      yield UpdatedState(state is UpdatedState ? (state as UpdatedState).count - 1 : -1);\n    }\n  }\n}\n```\n\n# 2. UI 만들기\n\n이제 카운터 앱을 위한 간단한 UI를 만들어보세요. main.dart 파일에서 만들어보세요.\n\n<div class=\"content-ad\"></div>\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_bloc/flutter_bloc.dart';\nimport 'counter_bloc.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: BlocProvider(\n        create: (context) => CounterBloc(),\n        child: MyHomePage(),\n      ),\n    );\n  }\n}\n\nclass MyHomePage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    final CounterBloc counterBloc = BlocProvider.of<CounterBloc>(context);\n\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Flutter Bloc Counter'),\n      ),\n      body: BlocBuilder<CounterBloc, CounterState>(\n        builder: (context, state) {\n          if (state is UpdatedState) {\n            return Center(\n              child: Column(\n                mainAxisAlignment: MainAxisAlignment.center,\n                children: <Widget>[\n                  Text(\n                    'Counter Value:',\n                    style: TextStyle(fontSize: 20),\n                  ),\n                  Text(\n                    '${state.count}',\n                    style: TextStyle(fontSize: 50),\n                  ),\n                  Row(\n                    mainAxisAlignment: MainAxisAlignment.center,\n                    children: <Widget>[\n                      FloatingActionButton(\n                        onPressed: () => counterBloc.add(IncrementEvent()),\n                        child: Icon(Icons.add),\n                      ),\n                      SizedBox(width: 20),\n                      FloatingActionButton(\n                        onPressed: () => counterBloc.add(DecrementEvent()),\n                        child: Icon(Icons.remove),\n                      ),\n                    ],\n                  ),\n                ],\n              ),\n            );\n          } else {\n            return Center(\n              child: CircularProgressIndicator(),\n            );\n          }\n        },\n      ),\n    );\n  }\n}\n```\n\n# 3. 앱 실행하기\n\n이제 다음을 실행하여 Flutter 앱을 실행할 수 있습니다:\n\n```dart\nflutter run\n```\n\n<div class=\"content-ad\"></div>\n\n간단한 카운터 앱이 표시되어야 합니다. '증가' 및 '감소' 버튼이 있습니다. 앱의 상태는 CounterBloc을 사용하여 관리되며, UI는 상태 변경에 따라 업데이트됩니다.\n\n# 결론\n\n이 가이드에서는 flutter_bloc 패키지를 사용하여 Flutter에서 상태 관리의 기본을 탐구했습니다. Bloc를 설정하는 방법, 이벤트 및 상태를 생성하는 방법, 및 UI와 Bloc을 통합하는 방법을 보여주기 위해 간단한 카운터 앱을 만들었습니다.\n\nFlutter Bloc은 Flutter 애플리케이션에서 상태를 관리하는 강력한 도구이며, 프로젝트가 성장함에 따라 더 복잡한 시나리오에도 적용할 수 있습니다. BLoC 패턴을 따르고 비즈니스 로직을 UI와 분리함으로써 유지 관리 가능하고 확장 가능한 Flutter 앱을 구축할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 안내서가 플러터 Bloc을 시작하고 플러터 프로젝트에서 더 복잡한 상태 관리를 위한 기초를 제공하는 데 도움이 되기를 바랍니다. 즐거운 코딩 되세요!","ogImage":{"url":"/assets/img/2024-06-21-MasteringStateManagementinFlutterwithBlocAComprehensiveGuide_0.png"},"coverImage":"/assets/img/2024-06-21-MasteringStateManagementinFlutterwithBlocAComprehensiveGuide_0.png","tag":["Tech"],"readingTime":5},{"title":"Flutter 앱에 런처 아이콘 추가하는 단계별 가이드","description":"","date":"2024-06-21 22:12","slug":"2024-06-21-AStep-by-StepGuidetoAddingLauncherIconstoYourFlutterApp","content":"\n\n소개: 모바일 앱 개발 세계에서 시각적으로 매력적이고 인식하기 쉬운 런처 아이콘을 만드는 것은 사용자에게 지속적으로 영향을 줄 수 있는 중요한 요소입니다. 플러터(Flutter)는 구글의 네이티브 컴파일된 애플리케이션을 구축하는 UI 툴킷으로, 앱에 런처 아이콘을 추가하는 간단한 프로세스를 제공합니다.\n\n이 가이드에서는 당신의 플러터 앱이 설치되는 순간부터 돋보이도록 보장하기 위한 단계별 프로세스를 안내해 드리겠습니다.\n\n![아이콘 디자인 준비](/assets/img/2024-06-21-AStep-by-StepGuidetoAddingLauncherIconstoYourFlutterApp_0.png)\n\n## 단계 1: 아이콘 디자인 준비\n\n<div class=\"content-ad\"></div>\n\n기술적인 세부 정보에 들어가기 전에 잘 디자인된 런처 아이콘이 있는지 확인해주세요. Flutter에서 런처 아이콘의 권장 크기는 512x512 픽셀입니다. 아이콘이 앱의 본질을 명확하고 간결하게 시각적으로 나타내도록 해주세요.\n\n# 단계 2: 필요한 이미지 자산 생성\n\nFlutter는 런처 아이콘을 포함한 자산을 관리하기 위해 pubspec.yaml이라는 구성 파일을 사용합니다. 시작하려면 pubspec.yaml 파일에 다음 줄을 추가해주세요:\n\n```yaml\n\n<div class=\"content-ad\"></div>\n\nflutter:\n  assets:\n    - assets/\n\n프로젝트 디렉토리 내 \"assets\" 폴더에 아이콘 이미지를 넣어주세요.\n\n# 단계 3: Flutter Launcher Icons 패키지 설치\n\n다양한 플랫폼용 런처 아이콘을 생성하는 과정을 간소화하기 위해 \"flutter_launcher_icons\" 패키지를 사용할 수 있습니다. 다음 의존성을 pubspec.yaml 파일에 추가해주세요:\n\n<div class=\"content-ad\"></div>\n\nYAML\n\n```\ndev_dependencies:\n  flutter_launcher_icons: ^0.13.1\n\n\n터미널에서 `flutter pub get`을 실행하여 패키지를 가져오세요.\n\n# 단계 4: 런처 아이콘 구성하기\n\n<div class=\"content-ad\"></div>\n\n패키지를 설치한 후에는 `pubspec.yaml` 파일에 다음 줄을 추가하여 구성해야 합니다:\n\n```yaml\nflutter_icons:\n  android: true\n  ios: true\n  image_path: \"assets/icon/icon.png\"\n```\n\n\"assets/icon/icon.png\"을 사용자의 아이콘 이미지 경로로 변경해주세요.\n\n<div class=\"content-ad\"></div>\n\n# 단계 5: 플러터 런처 아이콘 명령 실행\n\n이제 필요한 파일을 생성하고 새 런처 아이콘으로 앱을 업데이트할 명령을 실행할 시간입니다. 터미널에서 다음 명령을 실행하세요:\n\n```bash\nflutter pub run flutter_launcher_icons:main\n```\n\n<div class=\"content-ad\"></div>\n\n이 명령어는 Android 및 iOS용 필요한 아이콘 파일을 생성합니다.\n\n# 단계 6: 앱 실행하기\n\n새로 생성된 런처 아이콘을 사용하여 Flutter 앱을 Android 및 iOS 기기 또는 에뮬레이터에서 실행하여 변경 사항이 적용되는지 확인하세요.\n\nFlutter 앱에 사용자 정의 런처 아이콘을 추가하는 것은 간단하면서도 효과적인 방법으로 세련되고 전문적인 사용자 경험을 제공할 수 있습니다. 이 단계를 따르고 디자인 세부 사항에 주의를 기울이면 앱에 대한 기억에 남는 첫인상을 만들어낼 수 있습니다. 런처 아이콘을 사용자 정의하는 것은 앱의 미적인 면을 개선할 뿐만 아니라, 모바일 애플리케이션의 경쟁적인 세계에서 강력한 브랜드 아이덴티티를 구축하는 데 도움이 됩니다.\n\n<div class=\"content-ad\"></div>\n\n제 트위터 팔로우해주세요 - https://twitter.com/Nikhilsomansah","ogImage":{"url":"/assets/img/2024-06-21-AStep-by-StepGuidetoAddingLauncherIconstoYourFlutterApp_0.png"},"coverImage":"/assets/img/2024-06-21-AStep-by-StepGuidetoAddingLauncherIconstoYourFlutterApp_0.png","tag":["Tech"],"readingTime":2},{"title":"플러터 앱 효율성 향상 여러 Futures를 동시에 처리하는 방법","description":"","date":"2024-06-21 22:10","slug":"2024-06-21-ImproveFlutterAppEfficiencyHandlingMultipleFuturesatOnce","content":"\n\n<img src=\"/assets/img/2024-06-21-ImproveFlutterAppEfficiencyHandlingMultipleFuturesatOnce_0.png\" />\n\n## 소개\n\nFlutter에서 여러 비동기 작업을 동시에 처리하면 앱의 성능과 응답성을 크게 향상시킬 수 있습니다. 로컬 저장소에서 사용자 이름과 이메일을 동시에 가져와야 한다고 상상해보세요. 전통적으로는 한 작업이 완료될 때까지 다음 작업을 시작하지 못할 수 있지만, 이를 더 효율적으로 수행할 수 있는 방법이 있습니다. 이 글에서는 Future.wait를 사용하여 두 개의 미래 함수를 동시에 호출하는 방법을 살펴보고 전통적인 방법과 성능상의 장점을 비교해보겠습니다.\n\n## 전통적인 방법\n\n<div class=\"content-ad\"></div>\n\n전통적인 방식부터 시작해봅시다. 이 방법에서는 각 비동기 작업을 순차적으로 실행합니다.\n\n```js\nvoid fetchUserData() async {\n  LocalStorage localStorage = LocalStorage();\n  try {\n    final username = await localStorage.fetchUserName();\n    final userEmail = await localStorage.fetchUserEmail();\n    print(\"Username: $username, Email: $userEmail\");\n  } catch (error) {\n    print(\"Error: $error\");\n  }\n}\n```\n\n## 더 나은 방법: Future.wait 사용하기\n\n전통적인 방법에서 두 번째 작업은 첫 번째 작업이 완료될 때까지 기다리므로 소중한 시간이 낭비될 수 있습니다. 대신, Future.wait를 사용하여 두 작업을 동시에 실행하여 프로세스를 크게 가속화할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 예시 코드\n\n```js\nvoid fetchUserData() async {\n  LocalStorage localStorage = LocalStorage();\n  final usernameFuture = localStorage.fetchUserName();\n  final userEmailFuture = localStorage.fetchUserEmail();\n\n  try {\n    final results = await Future.wait([usernameFuture, userEmailFuture]);\n    final username = results[0];\n    final userEmail = results[1];\n    print(\"사용자 이름: $username, 이메일: $userEmail\");\n  } catch (error) {\n    print(\"오류 발생: $error\");\n  }\n}\n```\n\n## 작동 방식\n\n- Futures 시작: 두 futures (usernameFuture와 userEmailFuture)를 동시에 시작합니다.\n- 완료 대기: Future.wait는 두 futures의 완료를 기다리고 그 결과를 리스트로 반환합니다.\n- 결과 처리: 두 작업이 완료되면 결과를 함께 처리합니다.\n\n<div class=\"content-ad\"></div>\n\n## 성능 비교\n\n전통적인 방법\n\n전통적인 방법에서 총 소요 시간은 두 작업의 합계입니다.\n\n- 사용자 이름 가져오기 (예: 2초)\n- 사용자 이메일 가져오기 (예: 2초)\n\n<div class=\"content-ad\"></div>\n\n총 소요 시간: 4초\n\nFuture.wait 사용하기\n\nFuture.wait 메서드를 사용하면 두 작업이 동시에 실행됩니다.\n\n- 사용자 이름 가져오기 (예: 2초)\n- 사용자 이메일 가져오기 (예: 2초)\n\n<div class=\"content-ad\"></div>\n\n총 시간: 2초 (둘 중 늦게 완료되는 시간)\n\n## 속도 차이\n\nFuture.wait 사용하면 두 작업이 완료되는 시간을 절반으로 줄일 수 있어서 성능 상의 혜택이 명확히 나타납니다. 이 방법은 여러 개의 독립적인 비동기 작업을 처리할 때 특히 유용합니다.\n\n## 결론\n\n<div class=\"content-ad\"></div>\n\n플러터에서 Future.wait를 사용하여 동시에 여러 미래 함수를 호출하는 것은 앱 성능을 크게 향상시킬 수 있는 강력한 기술입니다. 비동기 작업을 동시에 실행함으로써 전체 소요 시간을 줄일 수 있어 앱을 더 반응적이고 효율적으로 만들 수 있습니다. 이 방법은 단순할 뿐만 아니라 매우 효과적이며, 플러터에서 여러 비동기 작업을 처리하는 데 가장 좋은 방법 중 하나입니다.\n\n## 추가 팁\n\n- 에러 처리: Future.wait를 사용할 때 강력한 에러 처리를 보장하십시오. 단일 실패가 전체 작업에 영향을 줄 수 있습니다.\n- 확장성: 이 방법은 두 개 이상의 미래에 대해 잘 확장되며, 여러 동시 작업에 대한 성능이 더욱 향상됩니다.\n\nFuture.wait를 도입함으로써 플러터 앱의 성능을 향상시켜 사용자 경험을 더 부드럽고 빠르게 제공할 수 있습니다. 다음에 여러 미래를 처리해야 할 때 Future.wait를 사용해보고 성능 차이를 확인해보세요!\n\n<div class=\"content-ad\"></div>\n\n친절한 톤으로 번역하면 다음과 같습니다.\n\n유저 경험을 우선시하고 깔끔한 코드 관행을 유지하는 전문 Flutter 개발자를 찾고 계신가요? 흥미로운 협업을 위해 여기 있습니다. 제 전체 프로필을 확인하고 LinkedIn에서 저와 소통해보세요.\n\n제 블로그가 도움이 되었기를 바라요! 궁금한 점이나 피드백이 있으시면 아래에 댓글을 남겨주세요.","ogImage":{"url":"/assets/img/2024-06-21-ImproveFlutterAppEfficiencyHandlingMultipleFuturesatOnce_0.png"},"coverImage":"/assets/img/2024-06-21-ImproveFlutterAppEfficiencyHandlingMultipleFuturesatOnce_0.png","tag":["Tech"],"readingTime":3},{"title":"Dio 패키지로 Flutter에서 HTTP 요청 마스터하기 완벽 가이드","description":"","date":"2024-06-21 22:09","slug":"2024-06-21-MasteringHTTPRequestsinFlutterwithDioPackage","content":"\n\n<img src=\"/assets/img/2024-06-21-MasteringHTTPRequestsinFlutterwithDioPackage_0.png\" />\n\n# 소개\n\nDio는 Dart용 HTTP 클라이언트로, API와 HTTP 요청을 처리하는 것이 쉽도록 도와줍니다. Dart HttpClient를 기반으로 만들어졌으며, 더 강력하고 유연한 기능이 추가되어 있습니다.\n\n이 튜토리얼에서는 Dio를 Flutter 애플리케이션에서 사용하는 방법을 살펴보고, 몇 가지 기능을 살펴볼 것입니다.\n\n<div class=\"content-ad\"></div>\n\n# 단계 1: Dio 설치하기\n\nFlutter 애플리케이션에서 Dio를 사용하려면 해당 패키지를 프로젝트에 추가해야 합니다. 이를 위해 다음 줄을 pubspec.yaml 파일에 추가할 수 있습니다:\n\n```js\ndependencies:\n  dio: ^5.4.0\n```\n\n패키지를 프로젝트에 추가한 후에는 flutter pub get 명령을 실행하여 설치할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 단계 2: Dio를 사용하여 HTTP 요청하기\n\nDio 패키지는 HTTP 요청을 쉽게 만들 수 있는 API를 제공합니다. 예를 들어 GET 요청을 하려면 dio.get() 메서드를 사용할 수 있습니다. 다음은 JSONPlaceholder API에 GET 요청을 하는 예시입니다:\n\n```js\nimport 'package:dio/dio.dart';\n\n...\nfinal dio = Dio();\nfinal response = await dio.get('https://jsonplaceholder.typicode.com/todos/1');\nprint(response.data);\n...\n```\n\n위의 코드에서는 Dio 클래스의 인스턴스를 생성하여 JSONPlaceholder API에 GET 요청을 보내고 있습니다. 그리고 응답은 콘솔에 출력됩니다.\n\n<div class=\"content-ad\"></div>\n\nHTTP 요청을 더 많은 유형으로도 보낼 수 있어요. 예를 들어 POST, PUT, DELETE 등이죠. POST 요청을 보내는 방법을 보여드릴게요!\n\n```js\nimport 'package:dio/dio.dart';\n\n...\nfinal dio = Dio();\nfinal response = await dio.post('https://jsonplaceholder.typicode.com/posts',\n  data: {\n    'title': 'My post',\n    'body': 'This is my post content',\n    'userId': 1,\n  },\n);\nprint(response.data);\n...\n```\n\n위 코드에서는 dio.post() 메서드를 사용하여 JSONPlaceholder API로 POST 요청을 보냈어요. 요청과 함께 보내는 데이터는 우리가 만들고자 하는 게시물의 제목, 본문, 그리고 사용자 ID가 들어있는 JSON 객체에요.\n\n# Step 3: Interceptors\n\n<div class=\"content-ad\"></div>\n\nDio는 인터셉터또한 제공합니다. 이는 요청이 보내거나 받기 전에 요청과 응답을 수정할 수 있도록 해줍니다. 인터셉터는 요청에 헤더를 추가하거나 오류를 처리하거나 네트워크 트래픽을 로깅하는 등 다양한 목적으로 사용될 수 있습니다.\n\n다음은 Dio 인스턴스에 인터셉터를 추가하는 예시입니다:\n\n```dart\nimport 'package:dio/dio.dart';\n\n...\n\nfinal dio = Dio();\ndio.interceptors.add(\n  InterceptorsWrapper(\n    onRequest: (options, handler) {\n      // 요청에 커스텀 헤더 추가\n      options.headers['Authorization'] = 'Bearer my_token';\n      return handler.next(options);\n    },\n  ),\n);\nfinal response = await dio.get('https://jsonplaceholder.typicode.com/todos/1');\nprint(response.data);\n...\n```\n\n위 코드에서는 Dio 인스턴스에 인터셉터를 추가하여 모든 요청에 사용자 정의 Authorization 헤더를 추가했습니다. onRequest 콜백은 요청을 보내기 전에 호출되고, onResponse 콜백은 응답을 받은 후에 호출됩니다. onError 콜백은 오류가 발생할 경우 호출됩니다.\n\n<div class=\"content-ad\"></div>\n\n# 단계 4: 취소\n\nDio는 더 이상 필요하지 않은 요청을 취소할 수 있게 하는 취소 토큰도 제공합니다. 이 기능은 요청이 너무 오래 걸리거나 더 이상 관련이 없는 요청을 중단해야 하는 상황에서 유용할 수 있습니다.\n\n다음은 취소 토큰을 사용하는 예시입니다:\n\n```js\nimport 'package:dio/dio.dart';\n\n...\nfinal dio = Dio();\nfinal cancelToken = CancelToken();\nfinal response = await dio.get('https://jsonplaceholder.typicode.com/todos/1',\n  cancelToken: cancelToken,\n);\nprint(response.data);\n// 요청 취소\ncancelToken.cancel('요청이 취소되었습니다');\n...\n```\n\n<div class=\"content-ad\"></div>\n\n위의 코드에서는 CancelToken을 생성하고 dio.get() 메서드에 전달합니다. 요청을 취소하기로 결정하면 CancelToken 객체의 cancel() 메서드를 호출할 수 있습니다.\n\n단계 5: 오류 처리\n\nDio는 HTTP 요청 시 발생할 수 있는 오류를 처리하는 편리한 방법을 제공합니다. dio.on 메서드를 사용하여 오류 핸들러를 등록하여 오류가 발생할 때마다 호출되도록 할 수 있습니다.\n\n다음은 오류 처리하는 방법의 예시입니다:\n\n<div class=\"content-ad\"></div>\n\n```dart\nimport 'package:dio/dio.dart';\n\n...\nfinal dio = Dio();\ndio.on(DioError, (error, handler) {\n  print('Request failed with error: ${error.message}');\n  return handler.next(error);\n});\nfinal response = await dio.get('https://jsonplaceholder.typicode.com/todos/999');\nprint(response.data);\n...\n```\n\n위의 코드에서는 DioError가 발생할 때마다 호출되는 오류 핸들러를 등록합니다. 오류 메시지가 콘솔에 출력되고 오류가 다음 오류 핸들러로 전달됩니다.\n\n# 결론\n\n이 튜토리얼에서는 Dio 패키지를 살펴보고 Flutter 애플리케이션에서 HTTP 요청을 하는 방법을 살펴보았습니다. HTTP 요청을 만드는 기본 사항, 인터셉터 사용, 요청 취소 및 오류 처리에 대해 다루었습니다.\n\n\n<div class=\"content-ad\"></div>\n\nDio는 Dart에서 API를 다루기 쉽게 만들어주는 강력하고 유연한 패키지입니다. 많은 기능과 옵션을 제공하여 HTTP 요청을 사용자 정의하고 오류를 효과적으로 처리할 수 있습니다. 이 튜토리얼이 도움이 되었기를 바라며, 여러분의 프로젝트에서 Dio를 더 탐험하도록 장려합니다.","ogImage":{"url":"/assets/img/2024-06-21-MasteringHTTPRequestsinFlutterwithDioPackage_0.png"},"coverImage":"/assets/img/2024-06-21-MasteringHTTPRequestsinFlutterwithDioPackage_0.png","tag":["Tech"],"readingTime":4},{"title":"Dio로 Flutter에서 에러 핸들링 마스터하는 방법","description":"","date":"2024-06-21 22:06","slug":"2024-06-21-MasteringErrorHandlinginFlutterwithDio","content":"\n\n에러 처리를 설명하며 예외를 설명하는 가장 좋은 방법\n\n![마스터링 플러터에서 Dio를 사용한 에러 처리](/assets/img/2024-06-21-MasteringErrorHandlinginFlutterwithDio_0.png)\n\n소개:\n모바일 앱 개발에서 에러를 우아하게 처리하는 것은 부드럽고 사용자 친화적인 경험을 제공하는 데 중요합니다. 플러터(Flutter)를 사용할 때 Dio는 강력한 HTTP 클라이언트 라이브러리로 네트워크 요청 중 에러를 처리하는 강력한 메커니즘을 제공합니다. 이 글에서는 Dio를 사용하여 플러터에서 에러를 효과적으로 처리하는 방법을 살펴보겠습니다. 이를 통해 앱이 신뢰성 있고 사용자 친화적인 상태를 유지할 수 있습니다.\n\n1. Dio 소개:\nDio는 플러터 애플리케이션에서 HTTP 요청을 간단히 만들어주는 다양한 기능을 제공하는 다재다능한 패키지입니다. 취소, 인터셉터, 요청/응답 변환 및 에러 처리와 같은 기능을 제공합니다. 에러 처리는 네트워크 통신의 중요한 측면으로, 인터넷 연결 없음, 서버 에러 등과 같은 시나리오를 처리하도록 앱을 도와줍니다.\n\n<div class=\"content-ad\"></div>\n\n2. Dio Configuration 및 인스턴스 생성:\n에러 처리에 들어가기 전에 Dio 설정을 위해 적절한 구성으로 인스턴스를 만들어보겠습니다. 타임아웃, 기본 URL 및 다른 설정을 정의하여 Dio를 앱에 맞게 사용할 수 있습니다.\n\n3. Interceptors를 사용한 전역 에러 처리:\n\n```js\nconst String APPLICATION_JSON = \"application/json\";\nconst String CONTENT_TYPE = \"content-type\";\nconst String ACCEPT = \"accept\";\nconst String AUTHORIZATION = \"authorization\";\nconst String DEFAULT_LANGUAGE = \"en\";\nconst String TOKEN = \"token\";\nconst String BASE_URL = \"https://api.example.com\";\n\nclass DioFactory {\n\n  Future<Dio> getDio() async {\n    Dio dio = Dio();\n\n    Map<String, String> headers = {\n      CONTENT_TYPE: APPLICATION_JSON,\n      ACCEPT: APPLICATION_JSON,\n      AUTHORIZATION: TOKEN,\n      DEFAULT_LANGUAGE: DEFAULT_LANGUAGE\n    };\n\n    dio.options = BaseOptions(\n        baseUrl: BASE_URL,\n        headers: headers,\n        receiveTimeout: Constants.apiTimeOut,\n        sendTimeout: Constants.apiTimeOut,\n    );\n\n    if (!kReleaseMode) {\n      dio.interceptors.add(PrettyDioLogger(\n        requestHeader: true,\n        requestBody: true,\n        responseHeader: true,\n      ));\n    }\n\n    return dio;\n  }\n}\n```\n\n3. DataSource enum:\n다양한 데이터 소스를 정의하는 열거형입니다. 각각이 특정 유형의 실패와 연관되며 오류 유형을 실패 응답과 매핑하는 데 사용됩니다.\n\n```js\nenum DataSource {\n  SUCCESS,\n  NO_CONTENT,\n  BAD_REQUEST,\n  FORBIDDEN,\n  UNAUTORISED,\n  NOT_FOUND,\n  INTERNAL_SERVER_ERROR,\n  CONNECT_TIMEOUT,\n  CANCEL,\n  RECIEVE_TIMEOUT,\n  SEND_TIMEOUT,\n  CACHE_ERROR,\n  NO_INTERNET_CONNECTION,\n  DEFAULT\n}\n```\n\n<div class=\"content-ad\"></div>\n\n4. DataSourceExtension:\n이 확장은 DataSource 열거형을 위한 getFailure라는 메서드를 추가합니다. 이 메서드는 열거형의 값에 따라 Failure 객체를 반환합니다.\n\n```js\nextension DataSourceExtension on DataSource {\n  Failure getFailure() {\n    var mContext = navigatorKey!.currentState!.context;\n    switch (this) {\n      case DataSource.SUCCESS:\n        return Failure(ResponseCode.SUCCESS, ResponseMessage.SUCCESS.tr(mContext));\n      case DataSource.NO_CONTENT:\n        return Failure(ResponseCode.NO_CONTENT, ResponseMessage.NO_CONTENT.tr(mContext));\n      case DataSource.BAD_REQUEST:\n        return Failure(ResponseCode.BAD_REQUEST, ResponseMessage.BAD_REQUEST.tr(mContext));\n      case DataSource.FORBIDDEN:\n        return Failure(ResponseCode.FORBIDDEN, ResponseMessage.FORBIDDEN.tr(mContext));\n      case DataSource.UNAUTORISED:\n        return Failure(ResponseCode.UNAUTORISED, ResponseMessage.UNAUTORISED.tr(mContext));\n      case DataSource.NOT_FOUND:\n        return Failure(ResponseCode.NOT_FOUND, ResponseMessage.NOT_FOUND.tr(mContext));\n      case DataSource.INTERNAL_SERVER_ERROR:\n        return Failure(ResponseCode.INTERNAL_SERVER_ERROR,\n            ResponseMessage.INTERNAL_SERVER_ERROR.tr(mContext));\n      case DataSource.CONNECT_TIMEOUT:\n        return Failure(\n            ResponseCode.CONNECT_TIMEOUT, ResponseMessage.CONNECT_TIMEOUT.tr(mContext));\n      case DataSource.CANCEL:\n        return Failure(ResponseCode.CANCEL, ResponseMessage.CANCEL.tr(mContext));\n      case DataSource.RECIEVE_TIMEOUT:\n        return Failure(\n            ResponseCode.RECIEVE_TIMEOUT, ResponseMessage.RECIEVE_TIMEOUT.tr(mContext));\n      case DataSource.SEND_TIMEOUT:\n        return Failure(ResponseCode.SEND_TIMEOUT, ResponseMessage.SEND_TIMEOUT.tr(mContext));\n      case DataSource.CACHE_ERROR:\n        return Failure(ResponseCode.CACHE_ERROR, ResponseMessage.CACHE_ERROR.tr(mContext));\n      case DataSource.NO_INTERNET_CONNECTION:\n        return Failure(ResponseCode.NO_INTERNET_CONNECTION,\n            ResponseMessage.NO_INTERNET_CONNECTION.tr(mContext));\n      case DataSource.DEFAULT:\n        return Failure(ResponseCode.DEFAULT, ResponseMessage.DEFAULT.tr(mContext));\n    }\n  }\n}\n```\n\n5. ResponseCode 클래스:\n이 클래스는 표준 HTTP 상태 코드와 로컬 상태 코드에 대한 사용자 지정 상태 코드를 나타내는 정적 정수 상수를 정의합니다.\n\n```js\nclass ResponseCode {\n  static const int SUCCESS = 200; // 성공 및 데이터 포함\n  static const int NO_CONTENT = 201; // 성공하지만 데이터가 없음 (내용 없음)\n  static const int BAD_REQUEST = 400; // 실패, API가 요청을 거부함\n  static const int UNAUTORISED = 401; // 실패, 사용자가 인가되지 않음\n  static const int FORBIDDEN = 403; // 실패, API가 요청을 거부함\n  static const int INTERNAL_SERVER_ERROR = 500; // 실패, 서버 측에서 오류 발생\n  static const int NOT_FOUND = 404; // 실패, 찾을 수 없음\n\n  // 로컬 상태 코드\n  static const int CONNECT_TIMEOUT = -1;\n  static const int CANCEL = -2;\n  static const int RECIEVE_TIMEOUT = -3;\n  static const int SEND_TIMEOUT = -4;\n  static const int CACHE_ERROR = -5;\n  static const int NO_INTERNET_CONNECTION = -6;\n  static const int DEFAULT = -7;\n}\n```\n\n<div class=\"content-ad\"></div>\n\n6. ResponseMessage 클래스:\n이 클래스는 다른 HTTP 상태 코드에 대한 응답 메시지를 나타내는 정적 문자열 상수를 정의합니다. 이러한 메시지는 국제화(로컬라이제이션)되어야 합니다.\n\n```js\nclass ResponseMessage {\n  static const String SUCCESS = AppStrings.success; // 데이터가 포함된 성공\n  static const String NO_CONTENT = AppStrings.success; // 데이터가 없는 성공 (내용 없음)\n  static const String BAD_REQUEST = AppStrings.strBadRequestError; // 실패, API가 요청을 거부함\n  static const String UNAUTORISED = AppStrings.strUnauthorizedError; // 실패, 사용자가 권한이 없음\n  static const String FORBIDDEN = AppStrings.strForbiddenError; // 실패, API가 요청을 거부함\n  static const String INTERNAL_SERVER_ERROR = AppStrings.strInternalServerError; // 실패, 서버 측에서 충돌 발생\n  static const String NOT_FOUND = AppStrings.strNotFoundError; // 실패, 서버 측에서 충돌 발생\n\n  // 지역 상태 코드\n  static const String CONNECT_TIMEOUT = AppStrings.strTimeoutError;\n  static const String CANCEL = AppStrings.strDefaultError;\n  static const String RECIEVE_TIMEOUT = AppStrings.strTimeoutError;\n  static const String SEND_TIMEOUT = AppStrings.strTimeoutError;\n  static const String CACHE_ERROR = AppStrings.strCacheError;\n  static const String NO_INTERNET_CONNECTION = AppStrings.strNoInternetError;\n  static const String DEFAULT = AppStrings.strDefaultError;\n}\n```\n\n7. HandleError 함수:\n이 비공개 함수는 DioException을 매개변수로 사용하여 Failure 객체를 반환합니다. DioException의 유형에 따라 switch 문을 사용하여 DataSource 열거형에서 정의된 일련의 값에 따라 다른 유형의 DioException을 해당하는 Failure 값으로 매핑합니다.\n\n```js\nFailure _handleError(DioException error) {\n  switch (error.type) {\n    case DioExceptionType.connectionTimeout:\n      return DataSource.CONNECT_TIMEOUT.getFailure();\n    case DioExceptionType.sendTimeout:\n      return DataSource.SEND_TIMEOUT.getFailure();\n    case DioExceptionType.receiveTimeout:\n      return DataSource.RECIEVE_TIMEOUT.getFailure();\n    case DioExceptionType.badResponse:\n      if (error.response != null &&\n          error.response?.statusCode != null &&\n          error.response?.statusMessage != null) {\n        return Failure(error.response?.statusCode ?? 0,\n            error.response?.statusMessage ?? \"\");\n      } else {\n        return DataSource.DEFAULT.getFailure();\n      }\n    case DioExceptionType.cancel:\n      return DataSource.CANCEL.getFailure();\n    default:\n      return DataSource.DEFAULT.getFailure();\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n7. ErrorHandler 클래스:\n이 클래스는 Exception 인터페이스를 구현하며, 예외 처리를 위한 것으로 의도되었음을 나타냅니다.\n즉시 초기화되지 않는 타입이 Failure인 late 필드인 failure이 있습니다.\nErrorHandler 클래스에는 동적 오류 매개변수를 사용하는 handle이라는 생성자가 있습니다. 이 생성자는 오류의 타입에 따라 _handleError 함수를 호출하여 다양한 종류의 예외를 처리합니다.\n만약 오류가 DioException 타입이라면, _handleError 함수를 호출하여 실패를 결정합니다.\n만약 오류가 DioException이 아니라면, DataSource에서 가져온 기본 값으로 실패를 설정합니다.\n\n```js\nclass ErrorHandler implements Exception {\n  late Failure failure;\n\n  ErrorHandler.handle(dynamic error) {\n    if (error is DioException) {\n      // dio error so its an error from response of the API or from dio itself\n      failure = _handleError(error);\n    } else {\n      // default error\n      failure = DataSource.DEFAULT.getFailure();\n    }\n  }\n}\n```\n\n8. 특정 요청에서 오류 처리:\n전역 오류 처리가 중요하긴 하지만, 요청마다 오류를 처리할 수도 있습니다. Dio 요청 주변에 try-catch 블록을 사용하여 오류를 캡쳐하고 적절히 응답할 수 있습니다.\n\n```js\nFuture<Either<Failure, ResponseDto>> getResponse(RequestDto requestDto) async {\n    if (await _networkInfo.isConnected) {\n      try {\n        ...\n        .\n        .\n        return Right(response);\n      } catch (error) {\n        return Left(ErrorHandler.handle(error).failure);\n      }\n    } else {\n      return Left(DataSource.NO_INTERNET_CONNECTION.getFailure());\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n9. 사용자 친화적인 오류 메시지 표시:\n긍정적인 사용자 경험을 보장하기 위해 기술적인 오류 메시지를 사용자 친화적인 메시지로 변환하십시오. 오류 코드를 사용자가 어떻게 진행해야 하는지 안내하는 인간이 읽을 수 있는 메시지로 매핑하기 위해 도우미 함수를 사용할 수 있습니다.\n\n```js\n///영어 메시지\n\"success\": \"성공\",\n\"bad_request_error\": \"잘못된 요청. 나중에 다시 시도해주세요\",\n\"no_content\": \"콘텐츠 없이 성공\",\n\"forbidden_error\": \"금지된 요청. 나중에 다시 시도해주세요\",\n\"unauthorized_error\": \"사용자 권한이 없습니다. 나중에 다시 시도해주세요\",\n\"not_found_error\": \"URL을 찾을 수 없습니다. 나중에 다시 시도해주세요\",\n\"conflict_error\": \"충돌이 발생했습니다. 나중에 다시 시도해주세요\",\n\"internal_server_error\": \"문제가 발생했습니다. 나중에 다시 시도해주세요\",\n\"unknown_error\": \"문제가 발생했습니다. 나중에 다시 시도해주세요\",\n\"timeout_error\": \"시간이 초과되었습니다. 나중에 다시 시도해주세요\",\n\"default_error\": \"문제가 발생했습니다. 나중에 다시 시도해주세요\",\n\"cache_error\": \"캐시 오류가 발생했습니다. 나중에 다시 시도해주세요\",\n\"no_internet_error\": \"인터넷 연결을 확인해주세요\"\n\n//아랍어 메시지\n\"success\": \"تم بنجاح\",\n\"bad_request_error\": \"طلب غير صالح. حاول مرة أخرى لاحقًا\",\n\"no_content\": \"콘텐츠 없이 성공\",\n\"forbidden_error\": \"طلب محظور. حاول مرة أخرى لاحقًا\",\n\"unauthorized_error\": \"사용자 권한이 없습니다. 나중에 다시 시도해주세요\",\n\"not_found_error\": \"URL을 찾을 수 없습니다. 나중에 다시 시도해주세요\",\n\"conflict_error\": \"충돌이 발생했습니다. 나중에 다시 시도해주세요\",\n\"internal_server_error\": \"문제가 발생했습니다. 나중에 다시 시도해주세요\",\n\"unknown_error\": \"문제가 발생했습니다. 나중에 다시 시도해주세요\",\n\"timeout_error\": \"시간이 초과되었습니다. 나중에 다시 시도해주세요\",\n\"default_error\": \"문제가 발생했습니다. 나중에 다시 시도해주세요\",\n\"cache_error\": \"캐시 오류가 발생했습니다. 나중에 다시 시도해주세요\",\n\"no_internet_error\": \"인터넷 연결을 확인해주세요\"\n```\n\n10. 결론:\n효율적인 오류 처리는 견고하고 신뢰할 수 있는 Flutter 앱을 제공하는 데 중요합니다. Dio의 포괄적인 오류 처리 메커니즘과 사용자 친화적인 오류 메시지는 어려운 네트워크 상황에서도 사용자가 정보를 알 수 있도록 보장합니다. 이러한 전략을 구현하여 앱의 신뢰성을 높이고 전반적인 사용자 경험을 향상시킬 수 있습니다.\n\n# Github 예시","ogImage":{"url":"/assets/img/2024-06-21-MasteringErrorHandlinginFlutterwithDio_0.png"},"coverImage":"/assets/img/2024-06-21-MasteringErrorHandlinginFlutterwithDio_0.png","tag":["Tech"],"readingTime":11},{"title":"플러터 오류 처리 완벽 가이드 기법 및 코드 예제","description":"","date":"2024-06-21 22:02","slug":"2024-06-21-CompleteGuidetoFlutterErrorHandlingTechniquesandCodeExamples","content":"\n\n에러 처리는 모바일 앱을 개발할 때 필수적입니다. 뜻밖의 문제가 발생해도 플러터 앱이 원활하게 실행되고 사용자 친화적이도록 보장합니다. 이 깊이 있는 책은 플러터에서 다양한 에러 처리 메커니즘을 탐색하면서 실수를 효율적이고 공손하게 처리하는 데 필요한 모범 사례와 코드 샘플을 다룰 것입니다. 이 글을 다 읽은 시점에는 플러터의 에러 처리에 대한 탄탄한 이해를 갖추어 신뢰할 수 있는 앱을 만들 준비가 될 것입니다. 지금 시작해 봅시다!\n\n## 1️. 플러터에서 에러 인식하기\n\n어떤 프로그래밍 언어나 프레임워크를 사용하더라도, 플러터를 이용해 개발할 때는 실수가 발생할 수 있습니다. 신뢰할 수 있고 안정적인 프로그램을 만들려면 이러한 문제에 대한 철저한 이해가 필요합니다. 플러터 앱에서 발생할 수 있는 다양한 오류 카테고리를 살펴보겠습니다:\n\n- 예외(Exception)는 Dart에서 코드를 실행하는 중에 발생하는 실패를 나타내는 객체들입니다. 예외는 특수한 상황(예: 0으로 나누기 시도, null 참조 액세스, 허용되지 않는 객체에서 메서드 호출 등)이 발생할 때 Dart가 예외를 throw합니다. 예외가 적절하게 catch되거나 처리되지 않으면 프로그램이 종료될 수 있습니다.\n- 에러(Error)도 예외와 달리 심각한 문제를 가리키는 객체 클래스를 포함하고 있습니다. 이러한 에러는 프로그램 동작이 불안정하거나 충돌을 일으킬 수 있는 심각한 문제를 지적하는 경우가 많습니다. OutOfMemoryError 및 StackOverflowError가 흔한 에러 중 하나입니다. 프로그램이 충돌하고 예측할 수 없는 동작을 방지하기 위해 에러는 치명적으로 간주되고 catch되지 않은 채로 남겨둬야 합니다.\n- 널 참조 에러(Null Reference Error)는 프로그래밍 중 가장 흔한 실수 중 하나인 널 포인터 예외로 알려져 있습니다. 이는 null인 객체나 임의의 인스턴스를 참조하지 않는 객체에 대해 속성이나 메서드를 사용하려고 시도할 때 발생합니다. Dart에서 가능한 null 객체에 대한 속성에 안전하게 액세스하거나 메서드를 호출하려면 널에 대한 안전한 연산자(?.)를 사용하여 널 참조 문제를 피할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nString? name; // 널 가능 변수\nprint(name?.length); // 널 참조 오류를 피하기 위해 ?. 사용\n```\n\n4. 단언 실패: 플러터에서는 개발 중 특정 조건을 확인하는 데 단언을 사용할 수 있습니다. 단언문이 false로 평가되면 단언 실패가 발생합니다. 일반적으로 디버깅에 사용되며, 제품 빌드에서 효율성을 향상시키기 위해 단언을 비활성화할 수 있습니다.\n\n```js\nassert(someCondition, \"someCondition이 false일 경우에 표시될 내용\");\n```\n\n5. 비동기 오류: 플러터 앱에서는 네트워크 쿼리를 보내거나 데이터베이스에서 데이터를 검색하는 등 비동기 활동을 많이 사용합니다. 비동기 작업 중에 발생한 오류로 인한 처리되지 않는 예외는 예기치 않은 애플리케이션 동작이나 충돌을 일으킬 수 있습니다. 비동기 실패를 처리하기 위해 try-catch 블록이나 Future API를 사용할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\ntry {\n  var result = await someAsyncOperation();\n  // 결과 사용\n} catch (e) {\n  // 비동기 오류 처리\n}\n```\n\n## 2. 오류 처리의 중요성은 무엇인가요?\n\n오류 관리는 Flutter 앱 개발의 중요한 구성 요소이며 다음과 같은 이유로 매우 중요합니다:\n\n- 사용자 경험 향상: 프로그램 실행 중 문제가 발생할 때 사용자는 예기치 않은 충돌이나 동작을 경험할 수 있습니다. 오류 관리는 이러한 문제를 처리하고 사용자에게 유용한 오류 메시지를 제공하여 사용자가 무엇이 잘못되었는지 및 어떻게 해결할 수 있는지에 대해 알려줍니다. 오류 메시지와 처리가 올바르게 이루어지고 사용자에게 잘 알려져 있다면 사용자는 만족스럽고 사용자 친화적인 경험을 얻게 됩니다.\n- 애플리케이션이 충돌하지 않도록 유지: 처리되지 않은 오류와 예외는 애플리케이션 충돌을 유발할 수 있어 사용자를 좌절시키고 데이터 손실의 가능성이 있습니다. 좋은 오류 처리를 구현함으로써 애플리케이션이 갑자기 중단되는 것을 피할 수 있고 복구 또는 대비 방법을 제공할 수 있습니다.\n- 앱 안정성 유지: 견고한 오류 처리로 Flutter 앱의 전반적인 안정성이 향상됩니다. 예상치 못한 문제를 예측하고 부드럽게 해결함으로써 카스케이드 실패를 피할 수 있고 어려운 상황에서도 앱이 작동하도록 할 수 있습니다.\n- 디버깅이 간편해집니다: 개발 및 테스트 단계에서 문제를 식별하고 진단하는 것을 용이하게 하는 오류 처리를 통해 디버깅이 쉬워집니다. 예외가 발생할 때 잘 설계된 오류 처리는 근본 원인을 식별하는 데 도움을 주어 결함을 해결하고 응용 프로그램의 신뢰도를 높일 수 있습니다.\n- 실패로부터의 원만한 복구: 일부 오류는 복구 가능하거나 대체 계획을 사용할 수 있을 수도 있습니다. 예를 들어, 네트워크 요청이 실패할 경우 오류 처리를 통해 재시도 메커니즘을 시작하거나 캐시된 데이터 소스로 전환할 수 있습니다. 올바른 오류 처리는 일시적 실패로부터 회복할 가능성을 높이고 사용자 경험을 향상시킬 수 있습니다.\n- 로깅 및 오류 보고: 오류를 정확하게 처리하면 사용 중에 오류와 예외가 발생했을 때 기록 방법을 구축할 수 있습니다. 이러한 로그는 오류 보고 기술에 의해 수집 및 집계될 수 있어 사용자에게 가장 중요한 문제에 대한 통찰력 있는 정보를 제공합니다. 이 데이터를 활용하여 앱 업그레이드에 어떤 개선 사항과 문제 해결 사항을 포함할지 결정할 수 있습니다.\n- Null 안전성과 안정성: 이제 Flutter가 null 안전성을 갖추었으므로 null 참조를 적절하게 처리하는 것이 더욱 중요해졌습니다. null-aware 연산자를 사용하고 권장되는 null 안전 절차를 준수한다면 코드는 더 예측 가능하고 안정적일 것입니다.\n- 보안 및 규정 준수: 일부 애플리케이션에서 보안 및 개인 정보 보호 법률을 준수하는 것은 효과적인 오류 처리가 필요합니다. 예를 들어, 민감한 데이터 오류를 잘못 처리하면 데이터 침해나 보안 결함이 발생할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 3. Try-Catch 기본 오류 처리\n\nTry-catch 블록은 Dart에서 사용되는 주요 오류 처리 전략 중 하나입니다. 이러한 구성 요소는 예외를 관리하고 충돌을 방지하며 문제가 발생할 경우 대체 옵션을 제공하는 프로그래머에게 기능을 제공합니다.\n\nTry-Catch 블록의 구조 \"try\"와 \"catch\" 블록은 try-catch 블록의 두 가지 주요 구성 요소입니다. 예외를 던질 수 있는 코드는 try 블록에 포함됩니다. try 블록 내에서 예외가 발생하면 catch 블록이 처리합니다.\n\n\"try\" 블록: 예외가 발생할 수 있는 코드는 \"try\" 블록에 배치되어야 합니다. 잠재적으로 오류가 발생할 수 있는 코드에 대해 보호 컨테이너 역할을 합니다.\n\n<div class=\"content-ad\"></div>\n\n“catch” 블록: try 블록 내에서 예외가 발생하면 catch 블록이 작동됩니다. 이는 예외를 인식하고 부드럽게 관리할 수 있게 합니다. 문제를 해결하기 위해 추가 조치를 취하거나 사용자에게 유용한 오류 메시지를 제공할 수 있습니다.\n\n예시: 0으로 나누기 예외 처리 방법: 나누기 함수가 있는 상황을 살펴보겠습니다. 분모가 0인 경우(0으로 나누기 예외가 발생할 수 있는 경우)를 try-catch 블록으로 처리합니다.\n\n```js\nvoid divideNumbers(int numerator, int denominator) {\n  try {\n    double result = numerator / denominator;\n    print('나눗셈 결과: $result');\n  } catch (e) {\n    print('에러: $e');\n    print('나눗셈을 수행할 수 없습니다.');\n  }\n}\n```\n\n```js\nvoid main() {\n  int num1 = 10;\n  int num2 = 0;\n\n  divideNumbers(num1, num2);\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 예시에서, num2를 0으로 설정하면 catch 블록이 0으로 나누기 예외를 잡을 것입니다. 앱이 충돌하는 대신, catch 블록이 오류 메시지를 표시하여 사용자 경험에 방해가 되지 않도록 합니다.\n\nTry-catch 블록을 사용하면 Flutter 개발자가 오류를 우아하게 처리하고 사용자 경험을 개선하며 앱 충돌을 방지하여 앱의 안정성과 사용성을 향상시킬 수 있습니다.\n\n## 4. 비동기 오류 다루기\n\n코드의 신뢰성을 유지하기 위해, Flutter 앱 개발 중 비동기 프로세스의 실패를 해결하는 것이 중요합니다. 데이터베이스나 API에서 데이터를 읽는 등의 비동기 작업은 오류를 관리하는 데 특별한 문제를 제공합니다. Flutter에서 일반적인 비동기 구조인 Futures와 Streams를 사용하여 비동기 작업에서 발생하는 오류를 어떻게 관리하는지 살펴보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n비동기 오류 관리 이해하기: 전통적인 try-catch 오류 관리는 비동기 활동에 대해 문제가 있습니다. 왜냐하면 이러한 활동은 주 프로그램 흐름과 독립적으로 실행되기 때문입니다. 효율적인 오류 관리를 위해 Futures 및 Streams가 제공하는 메커니즘을 활용하여 오류를 처리하고 적절한 구성 요소로 전파합니다.\n\nFuture 오류 처리: Futures는 즉시 접근할 수 없는 단일 값을 나타냅니다. 미래는 비동기 작업이 값이나 오류로 끝날 때 종료됩니다. .catchError() 함수를 사용하여 Future가 실행되는 동안 발생하는 오류를 감지하고 응답합니다.\n\nStream 오류 처리: Streams는 시간이 지남에 따라 연속적으로 데이터를 방출하는 비동기 이벤트의 모음입니다. .listen() 함수를 사용하여 스트림 작업 시 이벤트를 구독할 수 있습니다. .onError() 함수를 사용하여 스트림의 수명 동안 발생하는 잘못을 처리하고 대응할 수 있습니다.\n\nFuture와 Stream 오류 처리 예시:\n더 나아가서 오류 처리를 실제로 수행하기 위해 Future와 Stream 작업을 사용해보겠습니다:\n\n<div class=\"content-ad\"></div>\n\n```dart\nFuture<int> fetchUserData() async {\n  await Future.delayed(Duration(seconds: 2)); // 비동기 작업을 시뮬레이션하는 부분\n  // 아래 코드 주석 처리를 해제하면 에러가 발생합니다\n  // throw Exception('사용자 데이터를 가져오는 중 에러 발생');\n  return 42; // 성공적인 응답을 시뮬레이션하는 부분\n}\n\nvoid main() {\n  // Future에서 에러 처리하기\n  fetchUserData()\n      .then((value) => print('사용자 데이터: $value'))\n      .catchError((error) => print('사용자 데이터를 가져오는 중 에러 발생: $error'));\n\n  // Stream에서 에러 처리하기\n  Stream<int>.periodic(Duration(seconds: 1), (count) => count)\n      .map((count) {\n        // 아래 코드 주석 처리를 해제하면 에러가 발생합니다\n        // if (count == 2) throw Exception('스트림에서 에러 발생');\n        return count;\n      })\n      .listen(\n        (data) => print('스트림 데이터: $data'),\n        onError: (error) => print('스트림에서 에러 발생: $error'),\n      );\n}\n```\n\n`fetchUserData()` 함수는 이 예제에서 Future를 사용하여 비동기 작업을 시뮬레이션합니다. 예외를 발생시키는 부분을 주석 처리를 해제하면 `.catchError()` 함수가 에러를 처리하고 에러 메시지를 제공합니다.\n\nStream 예제에서 `.onError()` 함수는 스트림 수명 중 발생할 수 있는 오류를 처리하는 데 사용됩니다.\n\n## 5. 전역 오류 처리에 ErrorWidgets 사용하기\n\n\n<div class=\"content-ad\"></div>\n\n프로그램 어디에서든 발생할 수 있는 처리되지 않은 예외와 결함을 감지하는 시스템을 설정하는 것을 전역 오류 처리라고 합니다. 이러한 오류는 사용자 정의 ErrorWidgets를 사용하여 가로채고 처리할 수 있으며, 앱 충돌을 방지하고 긍정적인 사용자 경험을 보장할 수 있습니다.\n\nErrorWidgets 및 FlutterError: Flutter에서는 처리되지 않은 예외가 발생할 때 프레임워크가 FlutterError.onError 메서드를 호출합니다. ErrorWidgets를 사용하여 이 방법을 사용자 정의하고 고유한 오류 처리 논리를 제공할 수 있습니다. ErrorWidgets는 사용자에게 오류를 경고하는 위젯입니다.\n\n전역 오류 처리 구현: 전역 오류 처리를 구성하는 방법을 보여주기 위해 사용자 정의 ErrorWidget를 사용합시다:\n\n```dart\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Global Error Handling',\n      home: ErrorHandlerWidget(\n        child: MyHomePage(),\n      ),\n    );\n  }\n}\n\n// 나머지 코드 생략\n```\n\n<div class=\"content-ad\"></div>\n\n이 예제에서는 두 개의 페이지(MyHomePage와 SecondPage)를 가진 간단한 Flutter 앱을 만듭니다. ErrorHandlerWidget은 전체 앱을 감싸고 ErrorWidgetBuilder는 오류를 처리하고 사용자 친화적인 오류 화면을 표시하는 데 사용됩니다.\n\n앱을 실행하면 홈페이지에 버튼이 표시되며, 주석 처리된 예외를 던지는 코드 라인의 주석을 해제하여 오류를 발생시킬 수 있습니다. 전역 오류 처리 로직은 ErrorHandlerWidget에서 오류를 잡아 오류 화면에 표시합니다.\n\nErrorWidgets를 사용하여 전역 오류 처리를 함으로써, Flutter 앱에서 예기치 않은 오류가 발생해도 일관되고 부드러운 사용자 경험을 제공할 수 있습니다. 또한 onError에서 오류 처리 로직을 사용하여 로깅을 수행하거나 서버로 오류를 보고하여 추가 분석을 수행할 수 있습니다.\n\n## 6. 플랫폼 별 오류 처리하기\n\n<div class=\"content-ad\"></div>\n\n플러터 앱이 작동할 수 있는 플랫폼에는 Android, iOS, 웹, 데스크톱 등이 포함됩니다. 각 플랫폼마다 다양한 문제가 발생할 수 있거나 다르게 작동할 수 있습니다. 사용자에게 일관된 사용자 친화적인 경험을 제공하기 위해 플랫폼별 오류를 공손하게 처리해야 합니다.\n\n현재 플랫폼 찾기: Flutter에서 현재 플랫폼을 찾기 위해 dart:io 라이브러리의 Platform 클래스를 사용할 수 있습니다. 이 클래스를 사용하면 플랫폼을 결정하여 에러 메시지를 사용자 정의할 수 있습니다.\n\n예시: 플랫폼별 오류 처리 예제를 사용하여 해당 문제를 어떻게 처리하고 해당 오류 메시지를 표시하는지 보여드리겠습니다:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'dart:io' show Platform;\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: '플랫폼별 오류 처리',\n      home: MyHomePage(),\n    );\n  }\n}\n\nclass MyHomePage extends StatelessWidget {\n  void handlePlatformError(BuildContext context) {\n    String errorMessage;\n    if (Platform.isAndroid) {\n      errorMessage = '이 기능은 Android에서 사용할 수 없습니다.';\n    } else if (Platform.isIOS) {\n      errorMessage = '이 기능은 iOS에서 사용할 수 없습니다.';\n    } else if (Platform.isMacOS) {\n      errorMessage = '이 기능은 macOS에서 사용할 수 없습니다.';\n    } else if (Platform.isWindows) {\n      errorMessage = '이 기능은 Windows에서 사용할 수 없습니다.';\n    } else if (Platform.isLinux) {\n      errorMessage = '이 기능은 Linux에서 사용할 수 없습니다.';\n    } else if (Platform.isFuchsia) {\n      errorMessage = '이 기능은 Fuchsia에서 사용할 수 없습니다.';\n    } else {\n      errorMessage = '이 기능은 해당 플랫폼에서 지원되지 않습니다.';\n    }\n\n    showDialog(\n      context: context,\n      builder: (context) => AlertDialog(\n        title: Text('에러'),\n        content: Text(errorMessage),\n        actions: [\n          TextButton(\n            onPressed: () => Navigator.pop(context),\n            child: Text('확인'),\n          ),\n        ],\n      ),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('플랫폼별 오류 처리')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () => handlePlatformError(context),\n          child: Text('플랫폼 오류 보기'),\n        ),\n      ),\n    );\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 그림에서는 버튼을 포함한 간단한 Flutter 애플리케이션을 빌드하며, 해당 버튼을 누르면 플랫폼별 오류가 발생합니다. handlePlatformError 메서드는 Platform.isX 속성을 사용하여 현재 플랫폼을 확인하고, 그에 따라 알림 대화상자에 적절한 오류 메시지를 표시합니다.\n\n앱을 시작하고 해당 버튼을 클릭하면 현재 플랫폼에 특정한 오류 메시지가 표시되는 \"Show Platform Error\" 버튼이 있습니다. 예를 들어 Android 에뮬레이터를 사용하면 \"This feature is not available on Android.\"라는 오류 메시지가 나타납니다.\n\n플랫폼별 문제를 처리하고 관련 오류 메시지를 제공함으로써 Flutter 앱이 여러 플랫폼에서 일관되고 사용자 친화적인 경험을 제공할 수 있습니다.\n\n## 7. 네트워크 오류 처리하기\n\n<div class=\"content-ad\"></div>\n\nFlutter 앱을 개발하거나 네트워크 오류를 처리하는 것은 사용자에게 원활한 경험을 제공하는 데 중요합니다. 사용자가 연결 문제나 서버 오작동을 경험할 때 적절한 피드백을 제공하는 것이 중요합니다.\n\n예시 1: 네트워크 이용 불가 처리:\n네트워크 이용 불가를 식별하고 사용자에게 \"인터넷 연결 없음\"임을 알리는 방법을 보여드립니다:\n\n```js\nimport 'package:flutter/material.dart';\nimport 'package:connectivity/connectivity';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: '네트워크 오류 처리',\n      home: MyHomePage(),\n    );\n  }\n}\n\nclass MyHomePage extends StatelessWidget {\n  Future<void> checkInternetConnection(BuildContext context) async {\n    var connectivityResult = await Connectivity().checkConnectivity();\n    if (connectivityResult == ConnectivityResult.none) {\n      // \"인터넷 연결 없음\" 메시지 표시\n      showDialog(\n        context: context,\n        builder: (context) => AlertDialog(\n          title: Text('인터넷 연결 없음'),\n          content: Text('인터넷 연결 상태를 확인하고 다시 시도해주세요.'),\n          actions: [\n            TextButton(\n              onPressed: () => Navigator.pop(context),\n              child: Text('확인'),\n            ),\n          ],\n        ),\n      );\n    } else {\n      // 네트워크 요청 실행\n      // ...\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('네트워크 오류 처리')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () => checkInternetConnection(context),\n          child: Text('인터넷 연결 확인'),\n        ),\n      ),\n    );\n  }\n}\n```\n\n이 예시에서는 connectivity 패키지를 사용하여 인터넷 연결 상태를 확인합니다. 연결이 불안정한 경우(ConnectivityResult.none), \"인터넷 연결 없음\" 메시지가 있는 AlertDialog를 표시합니다. 인터넷 연결 가능한 경우 네트워크 요청을 필요에 따라 실행할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n예제 2: 서버 오류 처리:\n이제는 404 Not Found 또는 500 Internal Server Error와 같은 서버 오류를 다루는 방법을 설명하고, 사용자에게 적절한 오류 메시지를 보여줍시다.\n\n```js\nimport 'package:flutter/material.dart';\nimport 'package:http/http.dart' as http;\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: '서버 오류 처리',\n      home: MyHomePage(),\n    );\n  }\n}\n\nclass MyHomePage extends StatelessWidget {\n  Future<void> fetchData() async {\n    try {\n      // 네트워크 요청 수행\n      final response = await http.get(Uri.parse('https://example.com/api/data'));\n\n      if (response.statusCode == 200) {\n        // 성공적인 응답 처리\n        // ...\n      } else {\n        // 서버 오류 처리 및 적절한 메시지 표시\n        showDialog(\n          context: context,\n          builder: (context) => AlertDialog(\n            title: Text('서버 오류'),\n            content: Text('서버로부터 데이터를 가져오는 중 오류가 발생했습니다.'),\n            actions: [\n              TextButton(\n                onPressed: () => Navigator.pop(context),\n                child: Text('확인'),\n              ),\n            ],\n          ),\n        );\n      }\n    } catch (e) {\n      // 네트워크 문제와 같은 다른 오류 처리\n      print('오류: $e');\n      showDialog(\n        context: context,\n        builder: (context) => AlertDialog(\n          title: Text('오류'),\n          content: Text('오류가 발생했습니다. 나중에 다시 시도해주세요.'),\n          actions: [\n            TextButton(\n              onPressed: () => Navigator.pop(context),\n              child: Text('확인'),\n            ),\n          ],\n        ),\n      );\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('서버 오류 처리')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () => fetchData(),\n          child: Text('데이터 가져오기'),\n        ),\n      ),\n    );\n  }\n}\n```\n\n이 예제에서는 http 패키지를 사용하여 가짜 API 엔드포인트에 네트워크 요청을 보냅니다. 서버가 성공적인 응답을 위해 200 상태 코드를 보내면 성공적인 데이터를 처리합니다. 대신, 서버가 오류를 반환할 경우 (200 이외의 상태 코드), AlertDialog에 해당하는 오류 메시지를 표시합니다.\n\n네트워크 요청 관련 오류(네트워크 문제 등)가 발생할 때는 일반적인 \"오류가 발생했습니다\" 메시지가 표시됩니다. 메시지: \"나중에 다시 시도해주세요.\"\n\n<div class=\"content-ad\"></div>\n\n## 8. 보고 및 오류 기록\n\n프로그램 내에서 발생하는 오류, 예외, 충돌을 기록하는 것을 오류 기록이라고 합니다. 이 데이터는 문제를 식별하고 이용자들에게 어떤 영향을 미치는지 이해하는 데 유용합니다. 반면에 오류 보고는 오류 데이터를 서버나 클라우드 플랫폼으로 전송하여 개발자가 평가할 수 있도록 분석하고 모아 놓는 것을 의미합니다.\n\n예시: Firebase Crashlytics와 오류 기록 통합 예제: 이 예시에서는 Flutter 앱 내에서 실패를 기록하고 보고하는 방법을 알려드리겠습니다.\n\n- Flutter에서 Firebase 프로젝트 생성:\n\n<div class=\"content-ad\"></div>\n\n- Flutter 앱에 Firebase SDK를 사용하여 새 Firebase 프로젝트를 생성 및 포함하려면 공식 Firebase 가이드에 따르십시오.\n\n2. Crashlytics Firebase 플러그인 추가:\n\n- pubspec.yaml 파일에 firebase_crashlytics 플러그인을 추가하세요:\n\n```js\ndependencies:\n  flutter:\n    sdk: flutter\n  firebase_core: \n  firebase_crashlytics:\n```\n\n<div class=\"content-ad\"></div>\n\n3. Firebase Crashlytics를 초기화합니다:\n\n- 앱의 진입점인(main.dart와 같은 파일)에서 Firebase Crashlytics를 초기화합니다:\n\n```js\nimport 'package:flutter/material.dart';\nimport 'package:firebase_core/firebase_core.dart';\nimport 'package:firebase_crashlytics/firebase_crashlytics.dart';\n\nvoid main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n  await Firebase.initializeApp();\n  FirebaseCrashlytics.instance.setCrashlyticsCollectionEnabled(true);\n  runApp(MyApp());\n}\n```\n\n4. 에러 로깅 구현:\n\n<div class=\"content-ad\"></div>\n\n- 에러를 기록하려면 FirebaseCrashlytics.instance.recordError()를 사용하세요:\n\n```js\ntry {\n  // 예외를 발생시킬 수 있는 코드\n} catch (e, stackTrace) {\n  // Firebase Crashlytics를 사용하여 에러 기록\n  FirebaseCrashlytics.instance.recordError(e, stackTrace);\n}\n```\n\n5. 크래시 보고서 보기:\n\n- Firebase 콘솔에서 크래시 보고서를 자동으로 받을 수 있습니다. 이를 보려면 Firebase 콘솔의 \"Crashlytics\" 섹션을 방문하세요.\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-21-CompleteGuidetoFlutterErrorHandlingTechniquesandCodeExamples_0.png)\n\n## 9. 개별화된 오류 처리 기술\n\n사용자 정의 오류 처리는 특정 앱에 고유한 잘못된 상황을 대응하거나 사용자에게 특수화된 피드백을 제공하기 위해 오류 처리 알고리즘을 수정하는 것을 의미합니다. 이는 특정 도메인에 독점적인 오류 처리, 고유한 오류 패널 표시 또는 특정 오류 보고 시스템과 상호 작용을 포함할 수 있습니다.\n\n예를 들어 쇼핑 앱의 사용자 정의 오류 처리:\n예를 들어 쇼핑 앱에서 사용자 정의 오류 처리를 다루는 예시로, 장바구니 관련 문제를 처리하고 고객에게 적절한 메시지를 보여줍니다.\n\n<div class=\"content-ad\"></div>\n\n```js\r\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: '사용자 정의 오류 처리',\n      home: MyShoppingPage(),\n    );\n  }\n}\n\nclass MyShoppingPage extends StatefulWidget {\n  @override\n  _MyShoppingPageState createState() => _MyShoppingPageState();\n}\n\nclass _MyShoppingPageState extends State<MyShoppingPage> {\n  List<String> cartItems = ['Item A', 'Item B', 'Item C'];\n\n  void addToCart(String item) {\n    setState(() {\n      cartItems.add(item);\n    });\n  }\n\n  void removeFromCart(String item) {\n    if (!cartItems.contains(item)) {\n      // 카트에 아이템이 없는 경우에 대한 사용자 정의 처리\n      showDialog(\n        context: context,\n        builder: (context) => AlertDialog(\n          title: Text('오류'),\n          content: Text('카트에 해당 항목을 찾을 수 없습니다.'),\n          actions: [\n            TextButton(\n              onPressed: () => Navigator.pop(context),\n              child: Text('확인'),\n            ),\n          ],\n        ),\n      );\n    } else {\n      setState(() {\n        cartItems.remove(item);\n      });\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('사용자 정의 오류 처리')),\n      body: ListView.builder(\n        itemCount: cartItems.length,\n        itemBuilder: (context, index) {\n          return ListTile(\n            title: Text(cartItems[index]),\n            trailing: IconButton(\n              icon: Icon(Icons.delete),\n              onPressed: () => removeFromCart(cartItems[index]),\n            ),\n          );\n        },\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          // 카트에 없는 항목으로 오류를 시뮬레이션\n          removeFromCart('Item D');\n        },\n        child: Icon(Icons.remove),\n      ),\n    );\n  }\n}\r\n```\n\n이 경우에는 사용자가 장바구니에서 상품을 추가하고 삭제할 수 있는 쇼핑 애플리케이션을 개발했습니다. removeFromCart 함수는 이제 자체 개발한 고유한 오류 처리 방법을 사용합니다. 사용자가 카트에 없는 항목을 삭제하려고 시도할 때 매번 '카트에서 항목을 찾을 수 없습니다.' 라는 고유한 오류 메시지를 AlertDialog를 통해 표시합니다.\n\n이 소매 앱의 사용자 정의 오류 처리는 앱 업계에 특유한 특정 사용 사례를 고려합니다. 사용자 경험을 향상시키고 특별한 경우를 처리하기 위해 앱의 요구에 따라 다양한 맞춤형 오류 처리 알고리즘을 구축할 수 있습니다.\n\n## 10. Flutter에서 오류 처리를 위한 최상의 실천법\n\n<div class=\"content-ad\"></div>\n\nFlutter 앱이 안정적이고 신뢰도가 높으며 좋은 사용자 경험을 제공하기 위해서는 오류 관리가 중요합니다. 다음 권장 사항을 따라 Flutter 앱의 문제를 효과적으로 관리할 수 있습니다:\n\n- 사용자 친화적인 오류 메시지: 문제가 발생했을 때 사용자에게 간결하고 유익한 오류 메시지를 표시하세요. 이해하기 어려울 수 있는 기술적 정보를 가리고, 사용자들에게 앞으로 어떻게 진행해야 하는지 또는 문제를 해결하기 위해 무엇을 할 수 있는지 유용한 안내를 제공하세요.\n- 예외에 대해 Try-catch 블록 사용: Try-catch 블록을 사용하여 예외를 캡처하고 우아하게 처리할 수 있는 코드에 적용하세요. 이렇게 함으로써 앱 충돌을 피하고 문제를 적절하게 처리할 수 있습니다.\n- 비동기 오류 처리에 Futures와 Streams 사용: 비동기 작업을 수행할 때 오류 처리 방식에 주의를 기울이세요. Futures는 .catchError()를 사용하고 Streams는 onError()를 사용하여 실패를 적절히 처리해야 합니다.\n- 전역 오류 처리 구현: 모든 화면에서 일관되게 오류와 처리되지 않은 예외를 잡는 기술을 만드세요. 이렇게 하면 사용자 경험이 원활해지고 문제 해결에 도움이 됩니다.\n- 오류 기록 사용: 모니터링 및 문제 해결 목적으로 오류 세부 정보를 기록하세요. Firebase Crashlytics와 같은 도구를 사용하여 로깅 및 오류 보고를 통해 제품에서 주요 문제를 확인하세요.\n- 특정 상황을 위한 사용자 정의 오류 처리 작성: 앱의 요구 사항에 맞게 오류 처리를 사용자 정의하세요. 앱별 시나리오나 특정 상황에 대한 사용자 정의 오류 메시지 및 처리 로직을 제공하세요.\n- 네트워크 연결 문제 및 서버 문제 식별: 네트워크 중단이나 서버 문제를 포함한 네트워크 관련 문제를 우아하게 처리하세요. 사용자에게 연결 문제를 알리고 관련 오류 메시지를 제공해야 합니다.\n- 기능 미구현에 대한 우아한 저하 처리: 특정 기능이 플랫폼별 기능이나 외부 서비스에 의존할 경우 기능을 부드럽게 처리하세요. 외부 상황으로 인해 기능이 사용 불가능하거나 사용자의 현재 플랫폼에서 지원되지 않는 경우 사용자에게 알립니다.\n- 제품에서 강제 충돌 방지: 강제 충돌은 테스트와 디버깅에 유용할 수 있지만 실제 제품 사용을 위한 빌드에서는 제외하세요. 강제 충돌은 사용자 경험을 파괴하고 부정적인 피드백을 얻을 수 있습니다.\n- 오류 상황 테스트: 다양한 오류 상황에서 오류 처리 논리가 의도된 대로 작동하는지 전체적으로 테스트하세요. 앱이 실패에 공손하게 응답하는지 테스트하여 사용자 경험을 향상시키세요.\n\n오류 관리는 지속적인 과정이며 사용자 피드백과 앱 분석을 기반으로 오류 처리 기술을 개선하면 사용자의 앱 경험을 향상시킬 수 있습니다.\n\n## 11. Unit 테스트를 사용하여 오류 시나리오 테스트하기\n\n<div class=\"content-ad\"></div>\n\n작은 코드 단위, 예를 들어 함수나 메소드 같은 것들은 유닛 테스트를 사용하여 작동 여부를 확인합니다. 여러 오류 상황을 재현하는 테스트 케이스를 개발하고, 에러 처리 로직이 적절하게 반응하는지 확인하는 유닛 테스트를 작성할 때 도움이 될 겁니다.\n\n예시: 에러 처리를 위한 유닛 테스트:\n다양한 에러 시나리오를 테스트하고 에러 처리 동작을 평가하기 위해 테스트 패키지를 사용하여 유닛 테스트를 만드는 방법을 설명해 드리겠습니다:\n\n```js\nimport 'package:flutter_test/flutter_test.dart';\n\n// 테스트할 함수: 나눗셈 함수\ndouble divideNumbers(int numerator, int denominator) {\n  if (denominator == 0) {\n    throw Exception('Division by zero is not allowed.');\n  }\n  return numerator / denominator;\n}\n\nvoid main() {\n  // 테스트 케이스 1: 성공적인 나눗셈 테스트\n  test('Test successful division', () {\n    expect(divideNumbers(10, 2), equals(5));\n  });\n\n  // 테스트 케이스 2: 0으로 나누는 경우 테스트\n  test('Test division by zero', () {\n    try {\n      divideNumbers(10, 0);\n      // 아래 줄에 도달하지 않아야 합니다.\n      fail('Expected an exception to be thrown.');\n    } catch (e) {\n      expect(e, isA<Exception>());\n      expect(e.toString(), contains('Division by zero is not allowed.'));\n    }\n  });\n\n  // 테스트 케이스 3: 음수로 나누는 경우 테스트\n  test('Test division with negative numbers', () {\n    expect(divideNumbers(-10, 2), equals(-5));\n  });\n}\n```\n\n우리의 경우 숫자를 나누는 divideNumbers라는 함수가 있습니다. 세 가지 유닛 테스트가 다양한 상황을 다루도록 작성되었습니다.\n\n<div class=\"content-ad\"></div>\n\n- 테스트 케이스 1: 예상 결과에 대해 생산적인 나눗셈을 테스트합니다.\n- 테스트 케이스 2: 분모가 0인 경우를 테스트하며, 예외가 발생하고 필요한 오류 메시지와 함께 던져져야 합니다.\n- 테스트 케이스 3: 음수로 나눗셈이 테스트됩니다.\n\n여러 상황을 적절히 처리하고 의도한 대로 예외를 던지는지 확인하기 위해 이 유닛 테스트를 실행할 수 있습니다.\n\n코드 품질을 유지하고 소프트웨어가 다양한 오류 케이스에 효과적으로 대응할 수 있도록 하는 데 유단히 중요한 것은 오류 처리를 위한 유닛 테스트를 작성하는 것입니다. 코드베이스를 수정할 때 오류를 쉽게 발견할 수 있으므로 개발 중 발생하는 오류를 쉽게 발견할 수 있는 안전망 역할도 합니다.\n\n## 결론\n\n<div class=\"content-ad\"></div>\n\nFlutter에서 강력한 오류 처리의 가치를 강조하고 사용자 경험을 향상시키는 방법에 대해 마무리하면서 알려드릴 거에요. 좋은 오류 처리 기술을 사용하고 모범 사례를 준수하면 안정적이고 사용자 친화적인 Flutter 앱을 만들 수 있어요.\n\n코딩을 즐기세요!!!…\n\n저와 소통해요","ogImage":{"url":"/assets/img/2024-06-21-CompleteGuidetoFlutterErrorHandlingTechniquesandCodeExamples_0.png"},"coverImage":"/assets/img/2024-06-21-CompleteGuidetoFlutterErrorHandlingTechniquesandCodeExamples_0.png","tag":["Tech"],"readingTime":22},{"title":"Flutter의 Expanded vs Flexible 위젯 사용법 - 차이를 알아보자","description":"","date":"2024-06-21 21:58","slug":"2024-06-21-FluttersExpandedvsFlexibleWidgetsDemystifyingTheirUsage","content":"\n\n플러터 레이아웃 내에서 공간을 효율적으로 관리하는 것은 시각적으로 매력적이고 반응이 뛰어난 사용자 인터페이스를 만드는 데 필수적인 요소입니다. 우리 플러터 개발자로서는 종종 사용 가능한 공간을 다양한 위젯과 구성 요소 사이에 분배하는 도전에 직면하곤 합니다. 이럴 때 공간 할당을 어떻게 제어하는지 이해하는 것이 원하는 디자인과 사용자 경험을 달성하는 데 중요합니다.\n\n플러터 세계에서 두 가지 강력한 위젯이 우리를 돕습니다: 확장 위젯(Expanded widget)과 유연한 위젯(Flexible widget). 이러한 도구들은 사용 가능한 공간의 분배를 정밀하게 제어할 수 있는 수단을 제공하여 UI 구성 요소가 의도한 대로 표시되도록 보장합니다.\n\n이 글에서는 확장 위젯과 유연한 위젯의 세세한 차이를 파헤치고, 각각을 언제 사용해야 하는지를 도와드릴 것입니다. 이 탐구를 마치면, 이 위젯들을 효과적으로 활용하여 동적이고 반응성 있는 플러터 레이아웃을 만드는 방법에 대해 명확하게 이해하게 될 것입니다.\n\n# 확장 위젯 이해하기\n\n<div class=\"content-ad\"></div>\n\nExpanded 위젯은 Flutter에서 행과 열 내에서 공간을 관리하는 데 중요한 요소입니다. 주요 역할은 자식 위젯이 행 또는 열의 주축을 따라 가능한 한 많은 공간을 차지할 수 있도록 하는 것입니다. 다시 말하면, Expanded 위젯은 자식이 부모 위젯 내의 남은 공간을 채우도록 확장하는 역할을 합니다.\n\nColumns와 Rows에서 Expanded가 작동하는 방식\n\nColumn이나 Row 내에서 사용될 때, Expanded 위젯은 레이아웃 과정 중에 작용합니다. 주축을 따라 사용 가능한 공간을 검사하고 해당 공간을 자식 위젯에게 flex 팩터를 기준으로 할당합니다. Flex 팩터는 다른 flex 팩터를 갖는 다른 자식들에 비해 자식 위젯이 차지해야 할 공간을 결정합니다.\n\n간단히 설명하면 다음과 같습니다:\n- Column이나 Row의 주축을 따라 사용 가능한 전체 공간이 결정됩니다.\n- 각각의 Expanded 위젯을 갖는 자식은 flex 팩터에 따라 이 공간의 일부를 할당받습니다.\n- 남은 공간이 있다면, Expanded 위젯 없는 자식들 사이에 분배됩니다.\n\n<div class=\"content-ad\"></div>\n\n확장 위젯을 사용한 예시\n\n이 예시에서는 세 개의 자식을 가진 열이 있습니다. 중간 자식은 확장 위젯을 사용하여 가능한 수직 공간을 모두 채우도록 보장하고, 다른 자식들은 원래 높이를 유지합니다.\n\n확장 위젯 사용 시기\n\n확장 위젯은 다음 시나리오에서 특히 유용합니다:\n1. 동등한 분배: 특정 자식에게 행이나 열 내에서 가능한 공간을 동등하게 분배하고 싶을 때.\n2. 반응형 레이아웃: 반응형 레이아웃을 구축할 때, 확장을 사용하면 위젯이 화면 크기에 따라 적절하게 확장 또는 축소될 수 있습니다.\n3. 유동적 UI: 콘텐츠나 가능한 공간에 따라 크기를 동적으로 조정해야 하는 특정 위젯을 사용하여 유동적인 사용자 인터페이스를 만드는 경우.\n\n<div class=\"content-ad\"></div>\n\n확장 위젯이 작동하는 방식과 적절한 사용 사례를 이해하면 Flutter 레이아웃을 유연하게 만들고 시각적으로 매력적으로 만들 수 있습니다.\n\n# 유연한 위젯 이해\n\nFlexible 위젯은 확장 위젯과 유사한 목적을 가진 Flutter 레이아웃에서 또 다른 가치 있는 도구입니다. 그러나 보다 유연성과 공간 분배를 제어하는 능력을 제공합니다. 주요 목적은 행과 열 내에서 사용 가능한 공간을 자식 위젯에 할당하는 방식을 제어하는 것입니다.\n\n유연 위젯이 Flex 팩터와 함께 작동하는 방법\n\n<div class=\"content-ad\"></div>\n\n유연한 위젯은 각 자식에게 유연한 요인을 할당함으로써 작동합니다. 이 유연한 요인은 다른 유연한 요인을 갖는 다른 자식과 비교하여 각 자식이 차지해야 할 공간을 결정합니다. 더 높은 유연한 요인은 해당 자식이 사용 가능한 공간의 더 많은 부분을 받게 됨을 의미합니다.\n\n다음은 유연 위젯이 유연한 요인과 함께 작동하는 방식입니다:\n- 행 또는 열의 주요 축을 따라 사용 가능한 총 공간이 계산됩니다.\n- 유연한 위젯을 갖는 각 자식에게 유연한 요인에 기반한 공간이 할당됩니다.\n- 남은 공간이 있는 경우 각 자식에 대해 해당하는 유연한 요인에 비례하여 나누어져 나머지 공간이 배분됩니다.\n\n유연 위젯을 사용하는 예시\n\n이 예시에서는 서로 다른 유연한 요인을 가진 세 개의 자식을 포함한 행이 있습니다. 유연한 위젯으로 래핑된 각 자식은 다른 자식보다 더 많은 공간을 차지하는 3의 유연한 요인을 가진 자식이 있으며, 따라서 공간이 비례적으로 분배됩니다.\n\n<div class=\"content-ad\"></div>\n\n유연한 위젯을 사용하는 시점\n\n특정 상황에서 Expanded 위젯 대신 유연한 위젯을 선호하는 경우가 있습니다:\n1. 세밀한 제어: 서로 다른 플렉스 팩터를 가진 자식 요소들 사이에서 공간 분배에 더 정확한 제어가 필요한 경우. 유연한 위젯을 사용하면 공간 배분의 정확한 비율을 지정할 수 있습니다.\n2. 동적 레이아웃: 다양한 조건이나 사용자 상호작용에 따라 공간 분배가 조정되는 동적 레이아웃을 만들고 싶을 때.\n3. 혼합 레이아웃: 균일하게 확장되어야 하는 위젯과 비례적으로 확장되어야 하는 다른 위젯이 혼합된 경우, 유연한 위젯은 유연한 선택지입니다.\n\n요약하면, 유연한 위젯은 각 자식 요소마다 개별적인 플렉스 팩터를 설정하여 공간 분배를 보다 세밀하게 제어할 수 있게 해줍니다. 플러터 레이아웃에 정확하고 유연한 제어가 필요한 경우 특히 유용하며, 특정 상황에서 Expanded 위젯에 대한 강력한 대안이 됩니다.\n\n# 주요 차이점\n\n<div class=\"content-ad\"></div>\n\n남은 공간 다루기:\n\n확장 위젯:\n- 확장 위젯은 가진 모든 자식들 사이에 남은 공간을 균등하게 분배합니다.\n- 각 자식이 남은 공간의 동일한 비율을 받도록 보장하며, 그들의 유연성 요소에 관계없이 동등한 비율을 부여합니다.\n\n유연 위젯:\n- 유연 위젯은 자식들의 유연성 요소에 따라 남은 공간을 분배합니다.\n- 더 높은 유연성 요소를 가진 자식은 사용 가능한 공간의 더 많은 부분을 받고, 유연성 요소가 낮은 자식은 더 적은 공간을 받습니다.\n\n사용 사례:\n\n<div class=\"content-ad\"></div>\n\n확장 가능한 위젯:\n- 자식들 사이에 남은 공간을 고르게 분배하고 싶을 때 사용합니다.\n- 반응형 레이아웃을 만들 때 요소를 균일하게 조정해야 하는 상황에 적합합니다.\n\n유연한 위젯:\n- 서로 다른 유연성 요소를 갖는 자식들 사이에서 공간을 정밀하게 제어해야 할 때 사용합니다.\n- 다양한 조건에 적응하거나 균일하고 비례적인 분배를 필요로 하는 혼합 레이아웃에 이상적입니다.\n\n성능 고려사항:\n\n성능 면에서, 확장 가능한(Expanded)과 유연한(Flexible) 위젯은 효율적이며 앱의 성능에 큰 영향을 미치지 않습니다. 그러나 이러한 위젯을 분별적으로 사용하는 것이 중요합니다. 이러한 위젯을 과도하게 사용하면 복잡한 레이아웃이 되어 관리하고 디버깅하기 어려울 수 있습니다. 코드 작성 시 항상 간결함과 유지보수성을 지향해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n요약하자면, Expanded와 Flexible의 주요 차이점은 남은 공간 처리 방식과 제공하는 제어 수준에 있습니다. 두 가지 중 어떤 것을 선택할지는 구체적인 레이아웃 요구 사항에 따라 달라지며, 동등 분배(Expanded) 또는 정확한 비례 제어(Flexible)가 필요한지에 따라 다릅니다. 이러한 차이를 이해하면 Flutter 레이아웃을 설계하고 성능을 최적화하는데 도움이 됩니다.\n\n# Expanded를 사용해야 하는 경우\n\nExpanded 위젯은 Flutter 레이아웃에서 균일한 공간 분배가 필요한 다양한 시나리오에 특히 적합한 유용한 도구입니다. 다음은 Expanded 사용이 권장되는 몇 가지 구체적인 사용 사례와 실제 예시입니다:\n\n1. Row 내의 동일한 크기의 버튼들\n\n<div class=\"content-ad\"></div>\n\n예시: 화면 하단에 내비게이션 버튼 행이 있는 앱을 고려해보세요. 각 버튼에 Expanded 위젯을 사용하면 사용 가능한 수평 공간의 동일한 부분을 차지하여 시각적으로 일관된 사용자 친화적 레이아웃이 생성됩니다.\n\n2. 유연한 폼 필드\n\n예시: 등록 폼에서 Expanded 위젯을 사용하여 입력 필드가 화면 크기나 방향에 관계없이 사용 가능한 너비를 균일하게 채우도록 할 수 있습니다. 이렇게 하면 깔끔하고 일관된 폼 레이아웃이 만들어집니다.\n\n이러한 시나리오에서 Expanded 위젯을 사용하면 자식 요소 간 공간을 동일하게 분배하여 시각적으로 매력적이고 반응형인 플러터 레이아웃을 달성하는 간단하고 효과적인 방법을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n# Flexible 사용 시기\n\nFlexible 위젯은 서로 다른 flex 팩터를 가진 자식 요소들 사이의 공간 할당을 정밀하게 제어해야 할 때 다재다능한 선택지입니다. 다음은 Flexible 사용 시 Expanded와 비교했을 때 더 나은 선택인 경우를 구체적으로 설명한 예시입니다:\n\n1. 행 내 비율적 크기 조정\n\n예시: 음악 플레이어 앱을 고려해보겠습니다. 여러 재생 제어 요소를 행에 표시합니다. 재생 버튼을 이전 및 다음 버튼보다 크게 만들고 싶을 때가 있습니다. 서로 다른 flex 팩터를 사용하여, Flexible를 사용하여 이 비균일한 공간 분배를 달성할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Image 1](/assets/img/2024-06-21-FluttersExpandedvsFlexibleWidgetsDemystifyingTheirUsage_0.png)\n\n2. Dynamic Layouts\n\nExample: Imagine a weather app where you display weather information for different cities. You want the temperature widget to expand or shrink based on the length of the city name, providing a balanced and visually pleasing layout. Flexible, with its flex factor, allows you to achieve this dynamic behavior.\n\n![Image 2](/assets/img/2024-06-21-FluttersExpandedvsFlexibleWidgetsDemystifyingTheirUsage_1.png)\n\n\n<div class=\"content-ad\"></div>\n\n3. 혼합 레이아웃\n\n예시: 전자 상거래 앱의 제품 목록에서 제품 이미지의 크기를 동일하게 유지하고 제품 설명은 콘텐츠에 따라 너비가 다양하게 달라져야 할 때가 있습니다. 이미지에 대해서는 Expanded를, 설명에 대해서는 Flexible를 사용하여 이러한 혼합 레이아웃을 구현할 수 있습니다.\n\n![이미지](/assets/img/2024-06-21-FluttersExpandedvsFlexibleWidgetsDemystifyingTheirUsage_2.png)\n\n이러한 상황에서 Flexible 위젯은 다른 플렉스 요소를 가진 자식들 간의 공간 분배에 대한 정밀한 제어를 제공하여 뛰어납니다. 비례 크기 조정, 동적 레이아웃 또는 두 가지를 혼합할 필요가 있을 때, 요구 사항을 충족하지 못하는 경우에는 Flexible이 더 나은 선택입니다. 이를 통해 적응 가능하고 시각적으로 매력적인 Flutter 레이아웃을 만들 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# Best Practices\n\nFlutter 레이아웃에서 Expanded 및 Flexible 위젯을 사용할 때 효과적이고 효율적인 사용을 보장하기 위해 가이드 라인을 따르는 것이 중요합니다. 여기 몇 가지 주요 권장 사항이 있습니다:\n\n1. 성능 최적화:\n\n   - 위젯 깊이 제한: Expanded 또는 Flexible 위젯을 지나치게 사용하면 깊은 위젯 트리가 생성되어 성능에 영향을 줄 수 있습니다. 가능하다면 이러한 위젯을 적게 사용하여 위젯 트리를 얕게 유지하십시오.\n   - 앱 프로파일링: Flutter의 내장 성능 프로파일링 도구를 사용하여 레이아웃 및 렌더링 병목 현상을 식별하십시오. 이를 통해 성능을 개선할 수 있는 UI를 최적화할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n2. 콘텐츠에 유의하세요:\n\n- 적합한 콘텐츠 확인: 확장 가능 또는 유연한 위젯 내의 콘텐츠가 다양한 공간에 적응할 수 있는지 확인하세요. 예를 들어, 유연한 위젯에 긴 텍스트가 적절하게 처리되지 않으면 오버플로우할 수 있습니다.\n- 최소 및 최대 크기 고려: 과도한 확장 또는 수축을 방지하기 위해 위젯의 최소 및 최대 크기를 설정하기 위해 `Container`, `ConstrainedBox`, 또는 `IntrinsicWidth/Height` 위젯을 사용하세요.\n\n3. MainAxisAlignment와 CrossAxisAlignment 사용하기:\n\n- MainAxisAlignment와 CrossAxisAlignment 활용: 행과 열의 `mainAxisAlignment`와 `crossAxisAlignment` 속성을 활용하여 위젯의 정렬을 미세 조정하세요. 이를 통해 사용 가능한 공간 내에서 위젯의 위치를 조절할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n4. 다양한 기기에서 테스트하기:\n\n- 다양한 화면 크기에서 테스트: 다양한 화면 크기와 방향에서 레이아웃을 테스트하여 다양한 기기에 잘 적응되는지 확인합니다.\n- 에뮬레이터 및 실제 기기 사용: 에뮬레이터와 실제 기기는 다르게 작동할 수 있습니다. 둘 다 테스트하여 레이아웃 문제를 식별하고 해결하는 데 도움이 됩니다.\n\n5. 접근성 고려사항:\n\n- 접근성 확보: 레이아웃을 디자인할 때 접근성을 염두에 두세요. 앱을 스크린 리더로 테스트하여 모든 사용자가 접근할 수 있도록 보장하고, 특히 Flex 위젯을 사용할 때의 접근성을 확인하세요.\n\n<div class=\"content-ad\"></div>\n\n6. 레이아웃 설명서 작성하기:\n\n- 복잡한 레이아웃에 주석 추가하기: 레이아웃이 복잡해지면 특정 확장 또는 유연한 위젯의 목적과 의도를 설명하는 주석을 추가하는 것을 고려해보세요. 이는 코드를 작성 중인 여러분과 다른 개발자들에게 매우 도움이 될 수 있습니다.\n\n7. 경험을 통해 배우기:\n\n- 실습과 실험: Expanded 및 Flexible 위젯을 능숙하게 사용하는 가장 좋은 방법은 실습하고 실험해보는 것입니다. 다양한 레이아웃을 시도하고 결과로부터 배우세요.\n\n<div class=\"content-ad\"></div>\n\n이러한 모범 사례를 따르면 가독성이 좋고 성능이 우수한 플러터 레이아웃을 유지하면서 Expanded 및 Flexible 위젯을 효과적으로 사용할 수 있습니다. Expanded와 Flexible 중 어떤 것을 선택해야 하는지는 구체적인 레이아웃 요구 사항을 기반으로 결정되어야 하며, 이러한 위젯의 세부 사항을 이해하면 정보에 기반한 결정을 내릴 수 있을 것입니다.\n\n# 결론\n\n![이미지](/assets/img/2024-06-21-FluttersExpandedvsFlexibleWidgetsDemystifyingTheirUsage_3.png)\n\n본 문서에서는 Flutter 레이아웃의 맥락에서 Expanded 및 Flexible라는 두 가지 중요한 위젯을 탐색했습니다. 이 위젯들 간의 주요 차이점과 공간 분배에서의 역할을 강조했으며, 이를 효과적으로 사용하기 위한 예시를 제공했습니다. 또한 한 위젯이 다른 것보다 적합한 시나리오를 논의하고 가독성이 좋고 성능이 우수한 레이아웃을 유지하기 위한 모범 사례를 강조했습니다.\n\n<div class=\"content-ad\"></div>\n\n​Expanded와 Flexible를 언제 사용해야 하는지 이해하는 것은 유연하고 반응형이며 시각적으로 매력적인 Flutter 레이아웃을 만드는 데 중요합니다. 여기 주요 사항을 요약해 드리겠습니다:\n\n- Expanded 대 Flexible: Expanded는 자식들 사이에 공간을 동등하게 분배하는 반면, Flexible은 유연한 flex 요소에 따른 정확한 비율 제어를 허용합니다.\n- 사용 사례: Expanded는 공간의 동등 분배가 필요한 시나리오에 이상적이며, Flexible은 다양한 flex 요소를 통해 공간 할당을 제어해야 하는 상황에서 뛰어납니다.\n- 최상의 실천 사항: 가독성 유지, 성능 최적화, 콘텐츠 고려, 접근성 염두에 둔다면 Expanded와 Flexible 위젯을 다룰 때 꼭 지켜야 할 최선의 실천 사항이 됩니다.\n\n마지막으로, Flutter 프로젝트에서 Expanded와 Flexible 위젯을 함께 실험하고 실습할 것을 권장합니다. 능숙함은 실무 경험을 통해 오게 되므로, 다양한 레이아웃에서 이 위젯들의 능력을 탐험하는 데 주저하지 마십시오. 이들의 사용법을 능숙히 다루어 Flutter 애플리케이션에서 다재다능하고 동적인 사용자 인터페이스를 만들어보세요.","ogImage":{"url":"/assets/img/2024-06-21-FluttersExpandedvsFlexibleWidgetsDemystifyingTheirUsage_0.png"},"coverImage":"/assets/img/2024-06-21-FluttersExpandedvsFlexibleWidgetsDemystifyingTheirUsage_0.png","tag":["Tech"],"readingTime":9},{"title":"예제와 함께 배우는 Flutter ValueNotifier 활용 방법","description":"","date":"2024-06-21 21:57","slug":"2024-06-21-FlutterValueNotifierwithExamples","content":"\n\n<img src=\"/assets/img/2024-06-21-FlutterValueNotifierwithExamples_0.png\" />\n\n소개\nFlutter는 크로스 플랫폼 모바일 애플리케이션을 개발하기 위한 강력한 프레임워크입니다. 그 중요한 기능 중 하나는 애플리케이션의 상태를 관리하고 업데이트하기 위해 ValueNotifier를 사용할 수 있는 기능입니다. 이 블로그 포스트에서는 ValueNotifier의 기본 개념을 탐색하고 예제와 함께 사용하는 방법을 알아보겠습니다.\n\nValueNotifier란?\n\nValueNotifier는 Flutter에서 값을 저장하고 그 값이 변경될 때 청취자에게 알릴 수 있는 간단한 클래스입니다. 이는 다른 상태 관리 솔루션인 BLoC나 Provider와 같은 Flutter에서 사용 가능한 가벼운 대안입니다.\n\n<div class=\"content-ad\"></div>\n\n예시 1: 카운터 앱\n간단한 카운터 앱의 예시로 시작해보겠습니다. 화면에 카운터를 표시하고 사용자가 버튼을 탭할 때마다 증가시키는 앱을 만들어봅시다. 이를 위해 ValueNotifier를 사용하는 방법을 살펴보겠습니다:\n\n```js\nclass Counter {\n  final ValueNotifier<int> count = ValueNotifier<int>(0);\n\n  void incrementCount() {\n    count.value++;\n  }\n}\n\nclass CounterApp extends StatefulWidget {\n  @override\n  _CounterAppState createState() => _CounterAppState();\n}\n\nclass _CounterAppState extends State<CounterApp> {\n  final Counter counter = Counter();\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('카운터 앱'),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            Text(\n              '카운트:',\n            ),\n            ValueListenableBuilder<int>(\n              valueListenable: counter.count,\n              builder: (BuildContext context, int value, child) {\n                return Text(\n                  '$value',\n                  style: Theme.of(context).textTheme.headline4,\n                );\n              },\n            ),\n          ],\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          setState(() {\n            counter.incrementCount();\n          });\n        },\n        tooltip: '증가',\n        child: Icon(Icons.add),\n      ),\n    );\n  }\n}\n```\n\n이 예시에서는 Count 클래스를 정의하고 그 안에 count라는 ValueNotifier를 포함시킵니다. 그런 다음 ValueListenableBuilder를 사용하여 count 값의 변경 사항을 감시하고 버튼이 눌릴 때 UI를 업데이트합니다.\n\n예시 2: 폼 유효성 검사\nValueNotifier는 폼 유효성 검사에도 사용할 수 있습니다. 이 예시에서는 이메일과 패스워드 두 가지 필드로 구성된 폼의 유효성을 검사하려 합니다. 두 필드가 모두 입력되어야 폼이 유효합니다.\n\n<div class=\"content-ad\"></div>\n\n```dart\nclass LoginModel {\n  final ValueNotifier<String> email = ValueNotifier<String>('');\n  final ValueNotifier<String> password = ValueNotifier<String>('');\n\n  // 이메일과 비밀번호가 비어있지 않은지 확인\n  bool get isValid => email.value.isNotEmpty && password.value.isNotEmpty;\n}\n\nclass LoginForm extends StatefulWidget {\n  @override\n  _LoginFormState createState() => _LoginFormState();\n}\n\nclass _LoginFormState extends State<LoginForm> {\n  final LoginModel model = LoginModel();\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: SafeArea(\n        child: Column(\n          children: <Widget>[\n            TextField(\n              onChanged: (String value) {\n                setState(() {\n                  model.email.value = value;\n                });\n              },\n              decoration: const InputDecoration(hintText: 'Email'),\n            ),\n            TextField(\n              onChanged: (String value) {\n                setState(() {\n                  model.password.value = value;\n                });\n              },\n              decoration: const InputDecoration(hintText: 'Password'),\n            ),\n            ValueListenableBuilder<bool>(\n              valueListenable: ValueNotifier<bool>(model.isValid),\n              builder: (BuildContext context, bool isValid, child) {\n                return ElevatedButton(\n                  onPressed: () {\n                    if (isValid) {\n                      // 무언가를 수행\n                      print(\"Valid\");\n                    } else {\n                      print(\"Invalid\");\n                    }\n                  },\n                  child: const Text('Login'),\n                );\n              },\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n```\n\n이 예제에서는 이메일과 비밀번호를 나타내는 두 개의 ValueNotifier가 포함된 LoginModel 클래스를 정의합니다. 그런 다음 ValueListenableBuilder를 사용하여 isValid 값의 변경 사항을 청취하고 로그인 버튼을 활성화/비활성화합니다.\n\n예제 3: ValueNotifier로 UI 업데이트하기\n\nValueNotifier를 사용하여 상태가 변경될 때 UI를 업데이트할 수도 있습니다. 이 예제에서는 항목 목록을 표시하고 사용자가 스와이프하여 항목을 삭제할 수 있도록합니다.\n\n<div class=\"content-ad\"></div>\n\n```dart\nclass Item {\n  final ValueNotifier<String> name;\n\n  Item(String name) : name = ValueNotifier<String>(name);\n}\n\nclass ItemList extends StatefulWidget {\n  @override\n  _ItemListState createState() => _ItemListState();\n}\n\nclass _ItemListState extends State<ItemList> {\n  final List<Item> items = [\n    Item('아이템 1'),\n    Item('아이템 2'),\n    Item('아이템 3'),\n  ];\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: SafeArea(\n        child: ListView.builder(\n          itemCount: items.length,\n          itemBuilder: (BuildContext context, int index) {\n            final Item item = items[index];\n\n            return Dismissible(\n              key: Key(item.name.value),\n              onDismissed: (DismissDirection direction) {\n                setState(() {\n                  items.removeAt(index);\n                });\n              },\n              child: ListTile(\n                title: ValueListenableBuilder<String>(\n                  valueListenable: item.name,\n                  builder: (BuildContext context, String value, child) {\n                    return Text(value);\n                  },\n                ),\n              ),\n            );\n          },\n        ),\n      ),\n    );\n  }\n}\n```\n\n이 예시에서는 항목 이름에 대한 ValueNotifier`String`을 포함하는 Item 클래스를 정의합니다. 그런 다음 ValueListenableBuilder를 사용하여 이름 값의 변경을 감시하고 항목이 삭제되도록 스와이프될 때 UI를 업데이트합니다.\n\n결론\n\nValueNotifier는 Flutter에서 다양한 용도로 사용할 수 있는 다재다능한 클래스로, 애플리케이션 상태 관리, 폼 유효성 검사 및 UI 업데이트를 포함한 여러 목적에 사용할 수 있습니다. ValueNotifier를 사용하여 개발자는 애플리케이션에서 상태를 관리하는 간단하고 효율적인 해결책을 만들 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-21-FlutterValueNotifierwithExamples_1.png)\n\n만약 내 미디엄 기사를 즐기신다면, 이 주제에 대한 연구와 학습을 지원하기 위해 커피 한 잔 사 주시면 감사하겠습니다.","ogImage":{"url":"/assets/img/2024-06-21-FlutterValueNotifierwithExamples_0.png"},"coverImage":"/assets/img/2024-06-21-FlutterValueNotifierwithExamples_0.png","tag":["Tech"],"readingTime":6},{"title":"클린 아키텍처 기반의 Flutter 폴더 구조 이렇게 해보세요","description":"","date":"2024-06-21 21:54","slug":"2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo","content":"\n\n## 폴더 구조\n\n![Folder Structure](/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_0.png)\n\n폴더와 파일을 정리하는 일은 고통스럽습니다. 특히 수천 개의 파일을 관리해야 하는 대규모 프로젝트에서는 더욱 그렇습니다.\n\n파일은 수백 줄을 포함해서는 안 됩니다. 정신 건강을 위해 높은 결합도를 가질 필요가 없고 단일 책임 원칙을 준수하려고 노력해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n고품질의 코드를 작성하면 파일 크기가 작아지고 파일 수가 늘어납니다. 여기서 문제가 발생합니다. 이 모든 파일을 효율적으로 어떻게 정리해야 할까요?\n\n# Clean Architecture으로 작업하기\n\n\"Clean architecture\"의 개념은 넓고 모호하지만, \"저는 이 프로젝트에 Clean Arch를 사용하고 있어요\"라고 말할 때, 나는 명확히 Flutterando의 아키텍처 제안을 말하는 것입니다!\n\n## 제안서 간단히 살펴보기\n\n<div class=\"content-ad\"></div>\n\n코드를 4개의 계층으로 분리할 것입니다: Presenter, Domain, Infra, External.\n\n![이미지](/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_1.png)\n\n- Presenter — UI 구성 요소입니다. 실제로 위젯이거나 위젯의 컨트롤러인 모든 것이 여기에 속합니다.\n- Domain — 앱의 핵심입니다. 모든 엔티티 및 비즈니스 로직이 이 곳에 보관됩니다.\n- Infra — 외부 레이어에서 오는 데이터를 모델, 저장소 및 서비스를 통해 도메인 레이어를 지원합니다.\n- External — 타사 라이브러리, 센서, SO, 저장소 및 앱의 다른 외부 종속성의 기능을 래핑하는 클래스입니다.\n\n강건한 해결책은 없지만, 저는 대부분의 상황에서 잘 작동하는 깔끔한 아키텍처를 선호합니다. 플러터 앱에서 깔끔한 아키텍처를 개선하기 위해 기술하는 몇 가지 관행을 추가한 이 글을 참고해 주세요.\n\n<div class=\"content-ad\"></div>\n\n메모:\n\n이 아키텍처 제안에 익숙하지 않은 분들에게는 \"entity\", \"controller\" 등과 같은 구체적인 용어의 의미를 알기 어려울 수 있습니다.\n\n이 글 전체를 통해 더 자세한 설명을 볼 수 있지만, 제안 내용을 설명하는 것이 목표가 아닙니다. 공식 문서를 읽을 필요는 없습니다.\n\n## Clean arch + Modular arch = 행복한 개발자 😀\n\n<div class=\"content-ad\"></div>\n\n모듈화 아키텍처는 관련 콘텐츠를 \"모듈\"이라고 불리는 한 곳에 모으는 것을 목표로 합니다.\n\n각 모듈은 시스템의 중요한 책임을 나타내며 모든 모듈은 다른 모듈과 통신하는 규제를 갖습니다.\n\n이는 결합도를 줄이고 다른 팀과 전문가들이 동일한 소스 코드로 작업하는 데 도움이 되는 시스템으로 볼 수 있습니다.\n\n![image](/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_2.png)\n\n<div class=\"content-ad\"></div>\n\n플러터에서 모듈 구조를 만들려면 Angular 프레임워크의 모듈 시스템을 기반으로 한 flutter_modular 패키지를 사용할 수 있어요.\n\n이 패키지는 앱을 모듈로 분할하며, 각각의 모듈은 페이지와 종속성을 가지고 있어요. 사용자가 모듈을 빠져나오면, 해당 모듈의 모든 종속성이 폐기됩니다.\n\n또한, 이 패키지는 의존성 주입 및 시스템 내비게이션을 위한 도구도 함께 제공돼요.\n\n# 루트 구조\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_3.png\" />\n\npubspec.yaml 파일과 함께 작업해야 할 디렉토리는 lib, assets, test 이렇게 3개가 있습니다.\n\n여기에 새로운 내용은 없습니다! 아마 이미 사용하고 있을 것입니다. lib와 test는 플러터 프로젝트를 생성할 때 자동으로 생성되는 폴더이며, asset 폴더 사용이 플러터 팀에 의해 권장됩니다.\n\n하지만 새로 온 사람들을 위해 그들의 사용법을 정의해야 할 것입니다. 그 이후에는 우리의 관심을 lib 폴더에만 집중할 것입니다.\n\n\n<div class=\"content-ad\"></div>\n\n## 에셋 폴더\n\n이미지, 글꼴, 아이콘, 비디오 등과 같은 모든 코드가 아닌 파일을 보관하는 곳입니다. 앱에서 사용되는 모든 자원이 여기에 포함될 수 있습니다. 여기에는 에셋의 공식적인 정의가 있습니다:\n\n## 라이브러리 폴더\n\n여기에는 당신의 Dart 파일이 위치합니다! 코드를 여기에 넣어주세요. =)\n\n<div class=\"content-ad\"></div>\n\n## 테스트 폴더\n\n여러분의 테스트 파일은 여기에 있습니다. 이 구조는 lib 폴더와 동일합니다.\n\n예를 들어, lib/modules/register/presenters/widgets에 있는 위젯 user_register_form.dart에 대한 테스트를 예로 들어보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n아래와 같이 만들어야 합니다.\n\ntest/modules/register/presenters/widgets/user_register_form_test.dart.\n\n# 라이브러리 구조\n\n![라이브러리 구조](/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_4.png)\n\n<div class=\"content-ad\"></div>\n\n## 메인 폴더\n\n![이미지](/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_5.png)\n\n이 폴더에는 각 Flavor의 주요 기능을 실행하는 파일이 포함되어 있습니다.\n\n또한 모든 Flavor의 일반 명령을 실행하는 common_main.dart 파일도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n플레이버를 사용하지 않는 경우, 이 폴더와 해당 내용을 닥스트 파일만 사용할 수 있도록 전환할 수 있습니다.\n\n## i18n 폴더\n\n![이미지](/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_6.png)\n\n잠깐! JSON 파일인가요? assets 폴더에 있어야 하는 게 아닌가요? 네! 그렇습니다! 이것이 제 죄약입니다. JSON 파일을 넣어야 하는 올바른 위치는 assets 폴더입니다. 하지만 localization 패키지는 lib 파일에 유지해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n물론이에요, 이건 패키지에서 강요하는 대로 하는 거예요. 그러나 의존성을 변경하고 easy_localization 패키지 등을 사용한다면 lib의 i18n 폴더를 제거해야 해요.\n\n그렇다고 해도, 난 여전히 localization 라이브러리를 선호해요. 사용하기 쉽고 열린 이슈도 적거든요.\n\neasy_localization 패키지 매니저는 더 이상 패키지를 활발하게 유지하지 않겠다고 이미 말했어요. 그래서 사용에 대해 경고하는 신호를 보냈어요.\n\n## Core 폴더\n\n<div class=\"content-ad\"></div>\n\n\n![Folder structure for Flutter with clean architecture](/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_7.png)\n\n다음은 Clean Architecture 레이어로 표현할 수 없는 모든 공유 로직을 배치하는 폴더입니다. 예를 들어, 정규식 문자열, 믹스인 및 유틸리티 클래스의 클래스입니다.\n\n- Configs: 시스템에 필요한 초기 구성을 저장합니다. 예를 들어, firebase 초기 구성.\n- Constants: 라우트 이름 및 정규식과 같은 앱 설정 문자열.\n- Extensions: Dart 확장 기능.\n- Mixins: Dart 믹스인.\n- Utils: 통화 포매터 또는 날짜 유틸리티와 같은 유틸리티 클래스.\n- Validator: 필드, 전화 번호, 문서 등을 유효성 검사하는 클래스입니다.\n\n다시 말씀드리지만, 이것은 저의 개인 경험입니다. 일반적으로 이러한 폴더들로 충분히 필요한 모든 클래스를 보관할 수 있습니다. 프로젝트에 따라 utils의 남용을 피하기 위해 다른 폴더를 생성하기도 합니다.\n\n\n<div class=\"content-ad\"></div>\n\n## 모듈 폴더\n\n![모듈 폴더 구성](/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_8.png)\n\n앱 모든 모듈을 포함하는 폴더입니다. 각 모듈 내에서는 앱의 각 페이지에 대한 필요한 클린 코드 레이어를 생성합니다.\n\n주 모듈과 루트 위젯도 모듈 폴더 내에서 생성됩니다.\n\n<div class=\"content-ad\"></div>\n\n각 레이어에는 특정 유형의 클래스가 저장되어 있습니다. 이들은 다음과 같습니다:\n\n- 프리젠터:\n위젯 — 시각적 컴포넌트 클래스.\n컨트롤러 — 위젯의 상태 관리 클래스.\r\n- 도메인:\n엔티티 — 데이터를 저장하는 클래스.\n유스케이스 — 비즈니스 논리 클래스.\r\n- 인프라:\n모델 — 데이터를 변환하기 위해 엔티티를 확장하는 클래스.\n데이터 소스 — 외부 API와 연결하는 클래스 (HTTP 드라이버 사용).\n서비스 — 외부 API와 연결하지 않는 클래스 (HTTP 드라이버를 사용하지 않음).\r\n- 외부:\n드라이버 — 외부 라이브러리나 시스템 기능을 격리하는 클래스.\n\n외부 레이어에는 클래스 유형이 하나뿐이므로 드라이버 폴더를 직접 만들겠습니다.\n\n# 모듈 구조\n\n<div class=\"content-ad\"></div>\n\n모듈 구조의 세부 사항을 분석하기 위한 예시를 살펴보겠습니다. 저는 권한 모듈을 선택했는데, 이는 로그인 및 사용자 등록 양식과 같이 인증되지 않은 사용자가 액세스할 수 있는 모든 화면을 나타냅니다.\n\n![Folder Structure](/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_9.png)\n\n각 모듈 폴더 내에서는 해당 모듈에서 사용하는 네비게이션 경로와 의존성을 설명하는 동일한 이름의 모듈 파일이 있을 것입니다.\n\n저는 모듈을 페이지로 분리하는 것을 좋아합니다. 이 경우 사용자는 로그인, 등록 및 비밀번호 복구 3개의 페이지에 액세스할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_10.png\" />\n\n로그인 폴더 내부에는 로그인 페이지에 필요한 클린 아키텍처 레이어가 포함되어 있습니다.\n\n## 프리젠터\n\n모듈은 페이지로 나뉘기 때문에, 프리젠터 폴더의 루트에는 로그인 페이지 위젯과 컨트롤러가 나타납니다.\n\n<div class=\"content-ad\"></div>\n\n다른 위젯은 \"위젯\" 폴더와 같은 다른 폴더에 있습니다. 필요할 때 위젯을 편의에 맞게 정리해보세요.\n\n그리고 \"dialogs\" 폴더가 있습니다. 또한 페이지를 구성하는 데 PageView 위젯이 필요한 경우 \"views\" 폴더가 있을 수 있습니다.\n\n위젯과 컨트롤러는 자신의 폴더가 없는 유일한 클래스 유형입니다. 높은 상관 관계 때문에 항상 함께 있어야 합니다.\n\n## 도메인\n\n<div class=\"content-ad\"></div>\n\n로그인 기능을 위해 사용자 이름과 비밀번호를 저장하는 AuthEntity 클래스가 있습니다.\n\nUsecase에서는 모든 비즈니스 로직을 실행합니다. 그렇다면 로그인 기능을 위한 가능한 비즈니스 로직은 무엇일까요?\n\n만약 없다면, 단지 데이터 소스를 호출하기 위해 도메인이 필요합니다. 비즈니스 로직이 없다고 해서 아키텍처 규칙을 어기는 것은 변명이 되지 않습니다.\n\n하지만... 사용자가 앱을 닫은 후에도 인증된 상태를 유지하나요? 그렇다면, 로컬에 인증 토큰을 저장해야 하는데, 이것도 비즈니스 로직입니다.\n\n<div class=\"content-ad\"></div>\n\n사용자가 로그인할 때 분석 데이터를 보내야 하나요? 이것도 비즈니스 로직입니다.\n\n## 인프라\n\nauth_datasource.dart 및 auth_datasource_impl.dart 파일을 메모해 두었나요?\n\nDatasources, Services, 및 Drivers를 위한 인터페이스가 작성되었습니다. 코드가 있는 위치는 `name`_`layer`_impl.dart 파일입니다. 인터페이스 사용은 결합도를 줄이고 Mock 클래스로 테스트를 구축하는 데 도움이 됩니다.\n\n<div class=\"content-ad\"></div>\n\n만약 파일의 유형이 데이터 소스인 경우 이미 API를 쿼리한다는 것을 알고 계실 겁니다.\n\n도메인은 데이터 소스에 AuthEntity를 제공하며, 이는 API 형식을 위해 값을 변환하기 위해 AuthModel을 사용합니다.\n\n## Driver (External)\n\n우리가 API를 호출하면서 HTTP 클라이언트를 위한 드라이버 폴더가 없는 이유는 무엇일까요? 그것이 공유 모듈에 있기 때문이죠!\n\n<div class=\"content-ad\"></div>\n\n## 공유 모듈\n\n![이미지](/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_11.png)\n\n페이지를 보관하는 모듈 외에도 공유 모듈을 가지고 있습니다.\n\n이 모듈에는 모듈 간에 공유되는 모든 유형의 클래스를 넣을 것입니다. 가장 좋은 예는 HTTP 클라이언트 드라이버입니다.\n\n<div class=\"content-ad\"></div>\n\n이것은 버튼, 텍스트 필드, 스위치 등과 같은 테마 위젯을 공유하는 모듈입니다.\n\n# 내 폴더 구조 만족스러운가요?\n\n![image](/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_12.png)\n\n아니요! 왜 그래야 하나요?\n\n<div class=\"content-ad\"></div>\n\n그 죄악스러운 i18n 폴더, 언젠가는 로컬라이제이션 패키지가 고쳐줄 거에요!\n\n제가 작업 중인 현재 모듈이나 공유 모듈에 원하는 드라이버가 있는지 항상 확신할 수 없네요.\n\nutils 폴더를 봤나요? 유틸리티 클래스의 정확한 정의가 뭔지 아시나요? 제가 프로그래밍한 이유는 제게 유틸리티가 있기 때문이죠. 그저 제대로된 이름을 생각해내지 못해서 그것뿐인 거예요.\n\n이론적으로, 필드 유효성 검증은 비즈니스 로직에 의해 정의되지만, TextField 위젯에 설정해야 합니다. 아마도 입력 유효성 검증은 공유 모듈 내부의 도메인에 있어야 할 것 같아요. 하지만, 그것들은 일반 유틸리티 함수이기 때문에 코어 폴더에 있어요.\n\n<div class=\"content-ad\"></div>\n\n머리 아프다! 그래도 과거의 나보다는 나아진 것 같아. 앞으로도 계속 나아졌으면 좋겠다.\n\n그럼, 내가 도울 수 있을까 생각해봐. 나는 같은 문제를 겪는 개발자들을 지원하고 피드백을 얻기 위해 이 지식과 생각을 공유했어.\n\nFlutter 앱을 위한 파일 구조에 대한 더 나은 또는 알려지지 않은 솔루션이 있는지 알고 있니?\n\n내 생각과 프로그래밍 팁을 더 읽고 싶다면, 내 글을 확인하고 앞으로 올 컨텐츠를 팔로우하거나 구독해줘.","ogImage":{"url":"/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_0.png"},"coverImage":"/assets/img/2024-06-21-FolderstructureforFlutterwithcleanarchitectureHowIdo_0.png","tag":["Tech"],"readingTime":8}],"page":"6","totalPageCount":21,"totalPageGroupCount":2,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}