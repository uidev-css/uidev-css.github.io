{"pageProps":{"posts":[{"title":"코드 플로우 - 60초 랩으로 배우는 Flutter 패키지 ","description":"","date":"2024-06-21 23:46","slug":"2024-06-21-CodeFlow1My60SecondRapAboutFlutterPackages","content":"\n\n## \"만약 내가 모든 것을 했다고 말했다면, 난 허풍을 떨었던 거야. 왜냐하면 난 바퀴를 다시 발명하지 않고 그냥 패키지를 가져오는 거야.\"\n\n![image](/assets/img/2024-06-21-CodeFlow1My60SecondRapAboutFlutterPackages_0.png)\n\n안녕하세요 여러분, 다시 한 번 코드 플로우로 들어주셔서 감사합니다. 오늘은 플러터 패키지에 대해 이야기하려고 해요.\n\n플러터 패키지는 플러터 애플리케이션에 특정 기능을 제공하는 재사용 가능한 코드 조각들이에요.\n\n<div class=\"content-ad\"></div>\n\n이러한 패키지는 UI 구성 요소, 네트워크 요청 처리를위한 라이브러리, 상태 관리 솔루션 및 데이터베이스 통합 도구 등을 포괄할 수 있습니다.\n\n이들은 플러터 생태계의 중요한 부분으로, 개발자가 앱에 기능을 쉽게 통합할 수 있도록 합니다.\n\npub.dev에서 직접 다운로드하거나 다른 사람들에게 유용할 수 있는 아이디어가 있으면 직접 만들어도 됩니다.\n\n![image](https://miro.medium.com/v2/resize:fit:1200/1*kU3a8x7UWXy3ahGYmoMT4g.gif)\n\n<div class=\"content-ad\"></div>\n\n## 더 알아보고 싶으신가요? 이 코드 플로우의 일부분을 듣고...\n\n## ...또는 YouTube에서 전체 비디오를 시청해보세요.\n\n## 만약 도움이 되었다면 박수를 쳐 주시고 댓글을 남겨주시면 감사하겠습니다!","ogImage":{"url":"/assets/img/2024-06-21-CodeFlow1My60SecondRapAboutFlutterPackages_0.png"},"coverImage":"/assets/img/2024-06-21-CodeFlow1My60SecondRapAboutFlutterPackages_0.png","tag":["Tech"],"readingTime":1},{"title":"Airclap  모든 기기에 파일 전송하기","description":"","date":"2024-06-21 23:44","slug":"2024-06-21-AirclapSendanyfiletoanydevice","content":"\n\n\n![Airclap](/assets/img/2024-06-21-AirclapSendanyfiletoanydevice_0.png)\n\n소프트웨어 개발자로서 여러 기기 간에 파일과 텍스트를 자주 전송해야 합니다. Airdrop이 이 문제를 우아하게 해결해 주었지만, Apple 기기에만 제한되어 있고 대용량 파일 전송에 어려움을 겪기도 합니다. 더욱이, Windows, Android, Linux 등 Apple 이외의 기기로의 파일 전송을 지원하지 않습니다.\n\n유사한 소프트웨어 솔루션들을 여러 가지 시도해 보았지만, 많은 것들이 파일을 제대로 전송하지 못하거나 지나치게 복잡하거나 불필요한 기능이 많거나 구식한 디자인을 가지고 있습니다. 이러한 옵션들이 모두 만족스럽지 못해서, 나는 나만의 솔루션을 개발하기로 결심했습니다: 아름답게 디자인된, 사용하기 쉬운 응용 프로그램, 크로스 플랫폼 지원.\n\n몇 달간의 열심히 일한 끝에, 드디어 여기 Airclap이 나왔습니다!\n\n\n<div class=\"content-ad\"></div>\n\n특징\n\n- 세련된 미니멀한 디자인으로 매우 간단한 상호작용\n- 다운로드 및 사용이 영구적으로 무료\n- 한 단계로 파일 전송 완료\n- iOS, macOS, Android, Windows, 자동차 시스템(Android), Linux(개발 중), TV(계획 중)을 지원\n- 일반 파일 형식 식별을 통해 모든 파일 유형 전송\n- 온라인/오프라인 실시간 장치 상태 업데이트, 오프라인 전송 및 온라인 수신\n- 지속적으로 추가되는 20개 이상 언어 지원\n- 안전한 데이터 전송을 위해 AES 암호화 사용\n- 커스터마이징된 SSDP 발견 프로토콜 및 P2P 안전 전송 프로토콜을 활용하여 다중 링크 전송 기술을 통해 안전하고 안정적인 고속 전송 보장\n- 인터넷 연결이 필요 없으며 로컬 네트워크만 사용하며 귀하의 정보를 수집하지 않음\n- 파일 무결성 보장 및 파일 압축 없음\n\n사용 방법\n\n파일 공유 — 즉시 한 단계 전송\n\n<div class=\"content-ad\"></div>\n\niOS 및 Android에서는 다른 기기로 텍스트/파일을 한 단계로 전송하려면 시스템의 \"공유\" 기능을 사용하면 됩니다. (이 기능에 대한 데스크탑 지원은 곧 제공될 예정입니다)\n\nCommand/Control + C/V 단축키\n\n드래그하여 보내기\n\nAirclap 내에서 선택하여 보내기\n\n<div class=\"content-ad\"></div>\n\n개인 핫스팟 전송\n\n휴대폰이나 다른 장치에서 개인 핫스팟을 활성화하고 다른 장치를 핫스팟에 연결하여 비디오 파일을 쉽게 전송할 수 있습니다. 이를 통해 자동차 시스템에서 비디오를 내보내는 등 파일을 손쉽게 전송할 수 있습니다.\n\n![AirclapSendanyfiletoanydevice_1](/assets/img/2024-06-21-AirclapSendanyfiletoanydevice_1.png)\n\n사용 사례\n\n<div class=\"content-ad\"></div>\n\n- 개발자를 위한 기능: 테스트 장치 또는 개발용 기계 간에 파일과 텍스트를 손쉽게 전송하세요.\n- 콘텐츠 제작자를 위한 기능: 미디어 파일을 빠르게 컴퓨터로 전송하여 편집한 후 핸드폰으로 미리보기하세요.\n- 교육자를 위한 기능: 학생들과 동료들에게 교육 자료를 안전하고 효율적으로 공유하세요.\n- 오피스 직원을 위한 기능: 문서와 발표 자료를 동료들과 편리하게 공유하세요.\n- 비디오 편집자를 위한 기능: 여러 기기를 통해 비디오를 시행착오 없이 편집하고 미리보기하세요.\n- 자동차 시스템을 위한 기능: 안드로이드 기반 자동차 시스템에서 운전 영상 파일을 빠르게 내보내세요.\n- 그 외 더 많은 상황들…\n\n간단히 말하면, 두 대 이상의 핸드폰 또는 컴퓨터를 소유하고 있다면 Airclap이 필수입니다. 케이블에서 해방되어 다른 기기 간 파일을 쉽게 전송하고 수신할 수 있습니다. 한 번 사용하시면 Airclap의 편리함과 강력함을 경험하게 될 것이라고 믿습니다.\n\n다운로드 방법\n\n- 지원하는 기기: Android, iOS, macOS, Windows (Windows 10 이상), Linux (개발 중…)\n- Airclap 다운로드\n\n<div class=\"content-ad\"></div>\n\n결론\n\n- 이 소프트웨어는 제 모든 요구 사항을 충족합니다: 안전하고 안정적이며 시각적으로 매력적이며 간단하고 빠르며 멀티 플랫폼을 지원합니다. 단순함을 유지하면서 최적화하고 개선할 것입니다.\n- 현재 85개국의 사용자들이 Airclap을 사용하고 있어서 놀라고 설레입니다.\n- 문제가 발생하거나 아이디어가 있으면 Discord에 가입하여 함께 논의하거나 X(트위터)에 메시지를 남기실 수 있습니다.\n\nAirclap을 자유롭게 사용해 보시고 모든 기기 간의 파일 전송의 편리함을 즐기세요.","ogImage":{"url":"/assets/img/2024-06-21-AirclapSendanyfiletoanydevice_0.png"},"coverImage":"/assets/img/2024-06-21-AirclapSendanyfiletoanydevice_0.png","tag":["Tech"],"readingTime":3},{"title":"Flutter에서 Provider로 상태 관리 이해하기","description":"","date":"2024-06-21 23:43","slug":"2024-06-21-UnderstandingstatemanagementwithProviderinFlutter","content":"\n\n<img src=\"/assets/img/2024-06-21-UnderstandingstatemanagementwithProviderinFlutter_0.png\" />\n\n플러터에서 \"provider\"는 애플리케이션 내에서 상태 관리와 데이터 공유에 사용되는 인기 있는 패키지입니다. Provider를 사용하면 애플리케이션의 다양한 구성 요소(위젯) 간에 데이터를 공유하고 업데이트할 수 있습니다. 이를 통해 상태 관리를 간단히 처리하고 전통적인 상태 관리 기술을 사용하지 않고 위젯 트리에서 데이터 변경을 추적하고 업데이트할 수 있습니다.\n\nProvider 개념을 이해하기 위해 몇 가지 주요 개념을 살펴보겠습니다:\n\n- Provider: Provider는 데이터 소스를 제공하고 애플리케이션 내에서 데이터에 액세스할 수 있도록 지원하는 패키지입니다. 데이터 프로바이더를 생성할 때 일반적으로 ChangeNotifier 클래스를 사용합니다. 이 클래스는 가변 상태를 나타내며 그 내부 데이터가 변경될 때 청취자들에게 알립니다.\n- Consumer: Consumer 위젯은 데이터 프로바이더의 값을 액세스하고 해당 변경 사항을 추적하는 데 사용됩니다. 데이터 프로바이더의 위젯 트리 내에 있으며 관련 데이터에 기초하여 스스로 다시 구축됩니다. 다시 말하면 데이터가 변경될 때 자동으로 업데이트됩니다.\n- Provider.of(): 이 메소드를 사용하면 위젯 트리 내에서 가장 가까운 데이터 프로바이더에 액세스할 수 있습니다. 이를 통해 관련 데이터를 검색하고 업데이트를 추적할 수 있습니다.\n- ChangeNotifier: 이 클래스는 데이터 프로바이더의 기반이 됩니다. ChangeNotifier 클래스를 확장한 클래스를 생성함으로써 가변 상태를 나타낼 수 있습니다. 데이터가 변경될 때 notifyListeners() 메소드를 호출하여 청취자에게 알릴 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이제 제공자 개념을 사용하여 데이터 공유를 구현하는 방법을 살펴보겠습니다:\n\n- 먼저 데이터 제공자 클래스를 만들고 ChangeNotifier 클래스에서 확장합니다.\n\n```dart\nimport 'package:flutter/foundation.dart';\n\nclass CounterProvider with ChangeNotifier {\n  int _count = 0;\n\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n```\n\n다음으로, 응용 프로그램 위젯 트리의 최상위에 MultiProvider를 생성하고 생성한 데이터 제공자를 추가합니다.\n\n<div class=\"content-ad\"></div>\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nvoid main() {\n  runApp(\n    MultiProvider(\n      providers: [\n        ChangeNotifierProvider(create: (_) => CounterProvider()),\n      ],\n      child: MyApp(),\n    ),\n  );\n}\n```\n\n이제 Consumer 위젯을 사용하여 모든 위젯에서 데이터에 액세스할 수 있습니다.\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nclass MyWidget extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Consumer<CounterProvider>(\n      builder: (context, counterProvider, child) {\n        return Text(\n          'Count: ${counterProvider.count}',\n          style: TextStyle(fontSize: 24),\n        );\n      },\n    );\n  }\n}\n```\n\n위의 예에서는 CounterProvider 클래스 내의 count 변수에 액세스하여 업데이트가 발생할 때마다 위젯을 자동으로 다시 빌드합니다.\n\n\n<div class=\"content-ad\"></div>\n\nProvider 패키지를 사용하면 Flutter 애플리케이션에서 데이터 공유를 쉽게 구현할 수 있어요. 위젯 간 데이터 통신과 업데이트가 간단해지며, 애플리케이션 전체 성능이 향상될 거예요.\n\n우선, pubspec.yaml 파일에 provider 패키지를 추가했는지 확인해주세요.\n\n그런 다음, 다음 코드를 main.dart 파일로 사용할 수 있어요:\n\n```js\nimport 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\n// 단계 1: 데이터 제공자 클래스 생성\nclass CounterProvider with ChangeNotifier {\n  int _count = 0;\n\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners();\n  }\n}\n\nvoid main() {\n  runApp(\n    // 단계 2: 앱을 MultiProvider로 래핑\n    MultiProvider(\n      providers: [\n        ChangeNotifierProvider(create: (_) => CounterProvider()),\n      ],\n      child: MyApp(),\n    ),\n  );\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Provider Example',\n      theme: ThemeData(primarySwatch: Colors.blue),\n      home: HomePage(),\n    );\n  }\n}\n\nclass HomePage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    // 단계 3: Consumer 위젯을 사용하여 데이터에 액세스\n    return Consumer<CounterProvider>(\n      builder: (context, counterProvider, child) {\n        return Scaffold(\n          appBar: AppBar(\n            title: Text('Counter App'),\n          ),\n          body: Center(\n            child: Column(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: [\n                Text(\n                  'Count:',\n                  style: TextStyle(fontSize: 24),\n                ),\n                Text(\n                  '${counterProvider.count}',\n                  style: TextStyle(fontSize: 48, fontWeight: FontWeight.bold),\n                ),\n              ],\n            ),\n          ),\n          floatingActionButton: FloatingActionButton(\n            onPressed: () {\n              // 단계 4: 상태 업데이트 트리거\n              counterProvider.increment();\n            },\n            child: Icon(Icons.add),\n          ),\n        );\n      },\n    );\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 예시에서는 ChangeNotifier를 확장하는 CounterProvider 클래스를 생성합니다. 이 클래스는 카운트 변수를 관리하고 증가시키는 메서드를 제공합니다. HomePage 위젯은 Consumer 위젯을 사용하여 카운트 값을 액세스하고 화면에 표시합니다. FloatingActionButton을 누르면 프로바이더의 increment 메서드가 트리거되어 카운트를 업데이트하고 UI를 다시 빌드하도록 알립니다.\n\n이 앱을 실행하면 카운트가 표시된 화면이 표시되며 FloatingActionButton을 탭할 때마다 카운트가 증가하고 화면에 변경 내용이 반영됩니다.\n\n이것은 플러터 앱에서 상태 관리를 위해 provider 패키지를 사용하는 방법의 기본 예시입니다. 이 개념을 확장하여 더 복잡한 데이터를 관리하고 응용 프로그램 전체에서 상태 변경을 처리할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-21-UnderstandingstatemanagementwithProviderinFlutter_0.png"},"coverImage":"/assets/img/2024-06-21-UnderstandingstatemanagementwithProviderinFlutter_0.png","tag":["Tech"],"readingTime":5},{"title":"Flutter 검색바 궁극의 가이드","description":"","date":"2024-06-21 23:41","slug":"2024-06-21-FlutterSearchBarAnUltimateGuide","content":"\n\n# 소개\n\n모바일 앱 개발 분야에서 잘 설계된 검색 기능은 편의성뿐만 아니라 사용자 참여 및 접근성을 크게 향상시키는 중요한 구성 요소입니다. 특히 방대한 데이터를 다루는 애플리케이션의 경우에는 이러한 요소가 더욱 중요합니다. 모바일 개발자들 사이에서 인기를 끌고 있는 Flutter는 네이티브 컴파일된 애플리케이션을 구축하기 위한 훌륭한 프레임워크로 두드러집니다. 이 글에서는 Flutter에서 다양한 검색 위젯을 디자인하는 여정을 시작해 CustomSearchDelegate와 같은 범용 위젯을 생성하는 방법을 살펴보겠습니다. 우리는 검색을 구현하기 위해 showSearch 메서드를 활용할 것입니다. 먼저 기본 검색 바를 만들고, 이후에는 임의의 프로젝트에서 사용할 수 있는 방식으로 커스터마이징할 것입니다.\n\n결과물은 이렇게 보일 것입니다.\n\n# showSearch:\n\n<div class=\"content-ad\"></div>\n\nShowSearch은 플러터의 머티리얼 라이브러리에 있는 메소드입니다. 따라서 위젯 트리 어디에서나 접근할 수 있습니다.\n\n```js\nFuture<T?> showSearch<T>({\n  required BuildContext context,\n  required SearchDelegate<T> delegate,\n  String? query = '',\n  bool useRootNavigator = false,\n})\n```\n\n이 메소드는 BuildContext와 SearchDelegate를 필요로 합니다. SearchDelegate는 T 타입의 파라미터를 받는 추상 클래스입니다.\n\n예시:\n\n<div class=\"content-ad\"></div>\n\n```js\n showSearch(context: context, delegate: CustomSearchDelegate());\n```\n\n따라서 검색 기능을 구현하려면 SearchDelegate를 확장하는 클래스를 만들면 됩니다. 그것이 어떻게 이루어지는지 살펴봅시다.\n\n```js\nclass CustomSearchDelegate extends SearchDelegate {\n  @override\n  List<Widget>? buildActions(BuildContext context) {\n    // 할 일: buildActions 구현\n    throw UnimplementedError();\n  }\n\n  @override\n  Widget? buildLeading(BuildContext context) {\n    // 할 일: buildLeading 구현\n    throw UnimplementedError();\n  }\n\n  @override\n  Widget buildResults(BuildContext context) {\n    // 할 일: buildResults 구현\n    throw UnimplementedError();\n  }\n\n  @override\n  Widget buildSuggestions(BuildContext context) {\n    // 할 일: buildSuggestions 구현\n    throw UnimplementedError();\n  }\n\n}\n```\n\nSearchDelegate는 4개의 메소드를 구현하도록 요구합니다.\n\n\n<div class=\"content-ad\"></div>\n\n- buildActions: 검색 쿼리를 지우는 작업과 같은 액션을 관리합니다. AppBar의 action 매개변수와 유사합니다.\n- buildLeading: 일반적으로 네비게이션을 위한 뒤로가기 버튼이 포함됩니다.\n- buildResults: 검색 결과를 표시합니다.\n- buildSuggestions: 사용자가 쿼리를 입력하는 동안 제안을 제공합니다.\n\n이 델리게이트를 사용하여 기본 검색을 구현해봅시다.\n\n```js\nclass CustomSearchDelegate extends SearchDelegate {\n  List<String> searchables = List.generate(100, (index) => '아이템 ${index + 1}');\n\n  @override\n  List<Widget>? buildActions(BuildContext context) {\n    return [\n      IconButton(\n        onPressed: () {\n          query = '';\n        },\n        icon: const Icon(Icons.clear),\n      ),\n    ];\n  }\n\n  @override\n  Widget? buildLeading(BuildContext context) {\n    return IconButton(\n      onPressed: () {\n        close(context, []);\n      },\n      icon: Icon(\n        Platform.isAndroid ? Icons.arrow_back : Icons.arrow_back_ios,\n        size: 22,\n      ),\n    );\n  }\n\n  @override\n  Widget buildResults(BuildContext context) {\n    return SuggestionOrResultWidget(searchables: searchables, query: query);\n  }\n\n  @override\n  Widget buildSuggestions(BuildContext context) {\n    return SuggestionOrResultWidget(searchables: searchables, query: query);\n  }\n}\n```\n\n```js\nclass SuggestionOrResultWidget extends StatelessWidget {\n  const SuggestionOrResultWidget({\n    key,\n    required this.searchables,\n    required this.query,\n  });\n\n  final List<String> searchables;\n  final String query;\n\n  @override\n  Widget build(BuildContext context) {\n    final List<String> suggestions = query.isEmpty\n        ? searchables\n        : searchables.where((element) => element.toLowerCase().contains(query.toLowerCase())).toList();\n\n    if (suggestions.isEmpty) return const NoResultWidget();\n\n    return ListView.separated(\n      itemBuilder: (context, index) => ListTile(\n        title: Text(suggestions[index]),\n      ),\n      separatorBuilder: (context, index) => const Divider(),\n      itemCount: suggestions.length,\n    );\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n```js\nclass NoResultWidget extends StatelessWidget {\n  const NoResultWidget({Key key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const Center(\n      child: Text('No Result Found'),\n    );\n  }\n}\n```\n\n결과는 다음과 같이 나타납니다\n\n<img src=\"https://miro.medium.com/v2/resize:fit:752/1*06CrNqmR7P5yqvzpGdtdXw.gif\" />\n\n# 검색 페이지 앱바의 ThemeData 사용자 정의하기\n\n\n<div class=\"content-ad\"></div>\n\n하나 주목할 점은 검색 페이지를 표시할 때 앱의 테마와 동일하지 않다는 것입니다. 이는 특히 AppBar의 색상에서 확인할 수 있습니다. 아래 코드는 검색 페이지의 AppBar에 앱의 ThemeData를 직접 전달합니다.\n\n```js\nclass CustomSearchDelegate extends SearchDelegate {\n  List<String> searchables = List.generate(100, (index) => 'Item ${index + 1}');\n\n  @override\n  ThemeData appBarTheme(BuildContext context) {\n    return ThemeData(\n      // 앱바 테마를 사용자 정의합니다.\n      appBarTheme: const AppBarTheme(\n        backgroundColor: Colors.blue,\n        foregroundColor: Colors.white,\n      ),\n      // 입력 장식 테마를 사용자 정의합니다.\n      inputDecorationTheme: const InputDecorationTheme(\n        isDense: true,\n        isCollapsed: true,\n        contentPadding: EdgeInsets.only(left: 12, top: 6, bottom: 6),\n        enabledBorder: OutlineInputBorder(\n            borderSide: BorderSide(\n          color: Colors.white,\n        )),\n        focusedBorder: OutlineInputBorder(\n            borderSide: BorderSide(\n          color: Colors.white,\n        )),\n        border: OutlineInputBorder(\n          borderSide: BorderSide(\n            color: Colors.white,\n          ),\n        ),\n      ),\n    );\n  }\r\n```\n\n<img src=\"/assets/img/2024-06-21-FlutterSearchBarAnUltimateGuide_0.png\" />\n\n# 일반적인 검색 위젯 만들기:\n\n<div class=\"content-ad\"></div>\n\n더 고급 구현으로 나아가기 위해 CustomSearchDelegate를 자세히 살펴봅시다. 이 일반적인 위젯은 여러 데이터 유형에서 재사용성과 적응성을 가장합니다.\n\n```js\n/// 어디서나 사용할 수 있는 제네릭 검색 대리자입니다\nclass CustomSearchDelegate<T> extends SearchDelegate<List<T>> {\n  CustomSearchDelegate({\n    required this.searchables,\n    required this.suggestionOrResult,\n    required this.itemMatcher,\n    this.onTap,\n  });\n  \n  // 검색 대상 항목\n  final List<T> searchables;\n  \n  // 제안 또는 결과를 가져올 때 표시해야 하는 위젯입니다.\n  // 제안과 결과에 대해 별도의 위젯을 사용하려면 suggestionWidget 및 resultWidget을 추가하여 \n  // 다른 방식으로 빌드할 수 있습니다.\n  final Widget Function(List<T>, String) suggestionOrResult;\n\n  // 일치 실행에 대한 쿼리\n  final bool Function(T item, String query) itemMatcher;\n\n  // 항목이 탭될 때의 콜백\n  final ValueChanged<T>? onTap;\n\n  @override\n  List<Widget>? buildActions(BuildContext context) {\n    return [\n      IconButton(\n        onPressed: () {\n          query = '';\n        },\n        icon: const Icon(Icons.clear),\n      ),\n    ];\n  }\n\n  @override\n  Widget buildLeading(BuildContext context) {\n    return IconButton(\n      onPressed: () {\n        close(context, []);\n      },\n      icon: Icon(\n        Platform.isAndroid ? Icons.arrow_back : Icons.arrow_back_ios,\n        size: 22,\n      ),\n    );\n  }\n\n  @override\n  Widget buildResults(BuildContext context) {\n    return _buildSuggestionOrResult();\n  }\n\n  @override\n  Widget buildSuggestions(BuildContext context) {\n    if (searchables.isEmpty) return const SizedBox();\n    return _buildSuggestionOrResult();\n  }\n\n  Widget _buildSuggestionOrResult() {\n    final List<T> suggestionList =\n        query.isEmpty ? searchables : searchables.where((item) => itemMatcher(item, query)).toList();\n\n    if (suggestionList.isEmpty) {\n      return NoResultFoundWidget();\n    }\n\n    return suggestionOrResult(suggestionList, query);\n  }\n\n}\n```\n\n다음과 같이 이 일반 대리자를 사용할 수 있습니다:\n```js\nshowSearch(\n  context: context,\n  delegate: CustomSearchDelegate<List<String>>(\n    searchables: searchables,\n    suggestionOrResult: (List<String> suggestions, String query) => ListWidget(\n      suggestionsList: searchables,\n      query: query,\n    ),\n    itemMatcher: (String item, String query) => item.toLowerCase().contains(query.toLowerCase()),\n  ),\n)\n```\n\n<div class=\"content-ad\"></div>\n\n# 보너스:\n\n만일 입력된 글자를 제시 목록에서 강조하고 결과로 스크롤하고 싶다면 다음 위젯을 사용할 수 있습니다.\n\n```js\nclass ListWidget extends StatefulWidget {\n  const ListWidget({\n    super.key,\n    required this.suggestionsList,\n    required this.query,\n  });\n\n  final List<String> suggestionsList;\n  final String query;\n\n  @override\n  State<ListWidget> createState() => _ListWidgetState();\n}\n\nclass _ListWidgetState extends State<ListWidget> {\n  late List<String> filteredList;\n  final ScrollController scrollController = ScrollController();\n\n  @override\n  void initState() {\n    super.initState();\n    filterList();\n  }\n\n  @override\n  void didUpdateWidget(ListWidget oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    if (widget.query != oldWidget.query) {\n      filterList();\n    }\n  }\n\n  void filterList() {\n    filteredList =\n        widget.suggestionsList.where((item) => item.toLowerCase().contains(widget.query.toLowerCase())).toList();\n\n    if (filteredList.isNotEmpty) {\n      if (filteredList.isNotEmpty) {\n        WidgetsBinding.instance.addPostFrameCallback((_) => scrollToFirstMatch());\n      }\n    }\n  }\n\n  void scrollToFirstMatch() {\n    int index = widget.suggestionsList.indexOf(filteredList.first);\n    if (index != -1 && scrollController.hasClients) {\n      scrollController.animateTo(\n        index * 32.0, // 각 항목의 높이가 32로 가정\n        duration: const Duration(milliseconds: 100),\n        curve: Curves.easeInOut,\n      );\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return ListView.separated(\n      controller: scrollController,\n      itemCount: filteredList.length,\n      itemBuilder: (context, index) {\n        final String suggestionText = filteredList[index];\n        return ListTile(\n          title: RichText(\n            text: highlightMatch(suggestionText, widget.query),\n          ),\n          onTap: () {\n            // 여기에 탭 기능을 추가하세요\n          },\n        );\n      },\n      separatorBuilder: (context, index) => const Divider(),\n    );\n  }\n\n  TextSpan highlightMatch(String text, String query) {\n    if (query.isEmpty || !text.toLowerCase().contains(query.toLowerCase())) {\n      return TextSpan(\n        text: text,\n        style: const TextStyle(color: Colors.black),\n      );\n    }\n\n    List<TextSpan> spans = [];\n    int start = 0;\n    int indexOfHighlight = text.toLowerCase().indexOf(query.toLowerCase());\n\n    while (indexOfHighlight != -1) {\n      spans.add(TextSpan(\n        text: text.substring(start, indexOfHighlight),\n        style: const TextStyle(color: Colors.black),\n      ));\n      spans.add(TextSpan(\n        text: text.substring(indexOfHighlight, indexOfHighlight + query.length),\n        style: const TextStyle(backgroundColor: Colors.yellow, color: Colors.black),\n      ));\n\n      start = indexOfHighlight + query.length;\n      indexOfHighlight = text.toLowerCase().indexOf(query.toLowerCase(), start);\n    }\n\n    spans.add(TextSpan(\n      text: text.substring(start),\n      style: const TextStyle(color: Colors.black),\n    ));\n    return TextSpan(children: spans);\n  }\n}\n```\n\n<img src=\"https://miro.medium.com/v2/resize:fit:468/1*8xf8nCjiihJQ-XUSlLe5MA.gif\" />\n\n<div class=\"content-ad\"></div>\n\n# 결론:\n\n모바일 앱 디자인에서 효과적인 검색 기능은 사용자 만족도와 참여도에 중요한 요소입니다. 이 CustomSearchDelegate은 플러터 앱에서 사용자 정의 및 다양한 검색 기능을 만들기 위한 템플릿을 제공합니다.\n\n독서해 주셔서 감사합니다. 즐거운 코딩 하세요 :)\n\n# Stackademic\n\n<div class=\"content-ad\"></div>\n\n끝까지 읽어주셔서 감사합니다. 떠나시기 전에:\n\n- 작가를 격려하고 팔로우해 주세요! 👏\n- 트위터(X), 링크드인, 그리고 유튜브에서 저희를 팔로우해 주세요.\n- 전세계에서 무료 프로그래밍 교육을 민주화하고 있는 Stackademic.com을 방문해보세요.","ogImage":{"url":"/assets/img/2024-06-21-FlutterSearchBarAnUltimateGuide_0.png"},"coverImage":"/assets/img/2024-06-21-FlutterSearchBarAnUltimateGuide_0.png","tag":["Tech"],"readingTime":11},{"title":"Flutter에서 권한 요청 처리하는 방법","description":"","date":"2024-06-21 23:39","slug":"2024-06-21-HowtohandlepermissionrequestsinFlutter","content":"\n\n\n![Screenshot](/assets/img/2024-06-21-HowtohandlepermissionrequestsinFlutter_0.png)\n\nFlutter에서 권한 요청 처리하는 방법— 이 강의에서는 Flutter에서 안드로이드와 IOS에서 권한을 요청하고 확인하는 방법을 살펴볼 것입니다.\n\n## 패키지\n\n- 권한 핸들러 (permission_handler)\n\n\n<div class=\"content-ad\"></div>\n\n## 설치\n\n플러터 패키지를 설치하는 과정은 매우 간단합니다. pubspec.yaml 파일을 열고 해당 패키지를 의존성 블록 섹션에 추가하면 됩니다.\n\n```js\ndependencies:\n  permission_handler:\n```\n\n팁: caret 버전을 사용하여 패키지 버전을 특정 주 버전으로 제한할 수 있습니다. 예를 들어, permission_handler: ^11.0.0는 버전 11로 제한되지만 주 버전 업데이트와 보안 패치를 모두 받게 됩니다.\n\n<div class=\"content-ad\"></div>\n\n## 권한\n\n먼저, 앱이 필요로하는 권한을 결정해야 합니다. 앱은 필요한 권한을 공개적으로 선언해야 합니다. 인터넷과 같은 민감하지 않은 권한은 자동으로 허용됩니다. 그 외의 민감한 권한인 위치, 연락처 등은 사용 전 사용자 승인이 필요합니다.\n\n## iOS 권한\n\niOS에서는 필요한 권한과 그 이유를 함께 기재하는 정보 속성 목록 파일(info.plist)에 권한을 추가함으로써 이를 처리할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n<key>NSPhotoLibraryUsageDescription</key>\n<string>이 앱은 사용자 갤러리에 이미지를 저장해야 합니다</string>\r\n```\n\n플러터의 경우, 프로젝트의 루트 디렉토리인 iOS/Runner 폴더의 info.plist에 해당합니다. info.plist에 대해 더 알아보려면 여기를 참고하세요.\n\n모든 권한 목록은 여기에서 찾을 수 있으며 iOS에서 권한을 요청하는 가이드라인은 여기에서 확인할 수 있습니다.\n\n## Android 권한요청\n\n<div class=\"content-ad\"></div>\n\n안드로이드에서는 `uses-permission` 태그를 android manifest에 추가하여 동일한 결과를 얻을 수 있습니다. 이 파일은 android/src/main/AndroidManifest.xml 디렉토리에 있습니다.\n\n```js\n<manifest ...>\n    <uses-permission android:name=\"android.permission.SEND_SMS\"/>\n    <application ...>\n        ...\n    </application>\n</manifest>\n```\n\n여기서 안드로이드에서 권한에 대해 더 알아보고 최선의 방법을 알아볼 수 있습니다.\n\n## 권한 요청하기\n\n<div class=\"content-ad\"></div>\n\n사용 권한을 요청하려면 먼저 패키지를 가져와야 합니다:\n\n```js\nimport 'package:permission_handler/permission_handler.dart';\n```\n\n그리고요, 연락처 권한을 요청하려면 다음과 같이 할 수 있어요. 한 번에 필요한 여러 권한을 요청할 수 있는 권한 목록을 전달합니다.\n\n## 사용 방법\n\n<div class=\"content-ad\"></div>\n\n다양한 권한들이 있어요. 권한의 상태를 확인할 수 있는데, 그 상태는 허용됨(granted), 거부됨(denied), 제한(restricted), 영구적으로 거부됨(permanentlyDenied), 제한된(limited), 또는 임시적인(provisional) 상태 중 하나일 거예요.\n\n```js\nvar status = await Permission.camera.status;\nif (status.isDenied) {\n  // 아직 권한을 요청하지 않았거나 권한이 이전에 거부되었지만 영구적으로 거부되지는 않았어요.\n}\n\n// 권한 상태에 대해 직접 물어볼 수도 있어요.\nif (await Permission.location.isRestricted) {\n  // OS가 접근을 제한했어요. 예를 들어, 부모용 제어 설정 때문일 수도 있어요.\n}\n```\n\n요청하려는 권한에 request()를 호출해주세요. 이미 이전에 허용된 경우, 아무 일도 일어나지 않아요.\nrequest()는 권한의 새로운 상태를 반환할 거예요.\n\n```js\nif (await Permission.contacts.request().isGranted) {\n  // 권한이 이미 허용되었거나 사용자가 방금 허용한 경우일 수 있어요.\n}\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n// 한 번에 여러 권한을 요청할 수 있습니다.\nMap<Permission, PermissionStatus> statuses = await [\n  Permission.location,\n  Permission.storage,\n].request();\nprint(statuses[Permission.location]);\n```\n\n일부 권한, 예를 들어 위치나 가속도 센서 권한과 같은 것들은 활성화 또는 비활성화할 수 있는 관련 서비스가 있습니다.\n\n```js\nif (await Permission.locationWhenInUse.serviceStatus.isEnabled) {\n  // 위치 사용\n}\n```\n\n앱 설정도 열 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n만약 (await Permission.speech.isPermanentlyDenied) {\n  // 사용자가 앱의 이 권한 요청 대화상자를 다시 보지 않기로 선택했습니다.\n  // 권한 상태를 변경하는 유일한 방법은 사용자가 시스템 설정에서 직접 활성화하는 것입니다.\n  openAppSettings();\n}\n```\n\nAndroid에서 권한을 사용하는 근거를 표시할 수 있습니다:\n\n```js\nbool isShown = await Permission.contacts.shouldShowRequestRationale;\n```\n\n일부 권한은 사용자에게 요청된 권한을 허용하거나 거부할 것을 요청하는 대화상자를 표시하지 않을 수 있습니다.\n이는 앱에 대한 OS 설정이 해당 권한에 대한 권한을 나타내는 경우입니다.\n설정의 상태가 권한을 허용할지 거부할지를 결정합니다.\n","ogImage":{"url":"/assets/img/2024-06-21-HowtohandlepermissionrequestsinFlutter_0.png"},"coverImage":"/assets/img/2024-06-21-HowtohandlepermissionrequestsinFlutter_0.png","tag":["Tech"],"readingTime":4},{"title":"Flutter로 처음부터 앱 작성 시 고려할 사항 7가지","description":"","date":"2024-06-21 23:37","slug":"2024-06-21-FlutterconsiderationsforwritinganAppfromthescratch","content":"\n\n## 앱을 작성할 때 고려해야 할 주제\n\n![image](/assets/img/2024-06-21-FlutterconsiderationsforwritinganAppfromthescratch_0.png)\n\n앱을 작성한 지 여러 해가 지났습니다. 다양한 앱 템플릿을 구축했고, 다양한 패키지를 사용했습니다. 많은 변화가 있었지만 고려 사항은 동일한 비율로 변하지는 않았습니다. 몇 가지 패턴을 감지했습니다.\n\n이 게시물에서는 내 생각을 체계적으로 정리하고, 처음부터 앱을 시작할 때 주의해야 할 사항 목록을 작성했습니다.\n\n<div class=\"content-ad\"></div>\n\n- 귀하의 요구에 맞는 상태 관리 시스템을 선택하세요.\n- 개발을 시작하기 전에 응용 프로그램의 아키텍처를 정의하세요.\n- 미래에 쉽게 변경할 수 있도록 서드 파티 라이브러리를 래핑하세요.\n- 처음부터 다국어 지원에 대비하세요.\n- 응용 프로그램에 맞는 내비게이션 스키마를 선택하세요.\n- 오류를 효과적으로 처리하여 원활한 사용자 경험을 보장하세요.\n- 응용 프로그램을 활기차게 만들기 위해 뷰 레이아웃을 작성하세요.\n- 로컬 데이터를 영구히 보관하고 필요에 따라 데이터 스키마를 업그레이드하는 방법을 정의하세요.\n- 개발, 스테이징 및 프로덕션을 위한 다른 환경을 정의하세요.\n- 문제를 쉽게 추적하고 수정할 수 있는 로그 메커니즘과 정책을 정의하세요.\n\n# 상태 관리 선택\n\n이것은 꼭 해야 할 일 중에 첫 번째라고 생각해요. 상태 관리는 귀하가 할 가장 중요한 결정입니다. 앱을 작성하는 방식을 결정하며, 클래스를 구성하는 방법을 결정합니다. 따라서 상태 관리를 선택하는 것은 중요합니다. 선택하지 않을 수 없습니다. 상태 관리는 Flutter 앱의 핵심이 되므로 중요합니다. 저는 BLoC 패턴을 좋아합니다만, 여러 옵션이 있습니다:\n\n- Bloc\n- Provider\n- GetX\n- Riverpod\n- 기타\n\n<div class=\"content-ad\"></div>\n\n제가 작성한 상태 관리에 관한 글을 확인해보세요:\n\n# 아키텍처 정의\n\n아키텍처는 코드를 구성합니다. 당신의 코드를 전문적으로 만들 뿐만 아니라 전문적으로 보이게 할 수 있습니다. 좋은 아키텍처는 재사용 가능하고 확장 가능하며 쉽게 유지 관리할 수 있는 코드를 제공해야 합니다. 현재 트렌드인 깔끔한 아키텍처를 선택할지라도, 응용 프로그램에 가장 적합한 것을 선택하되, SOLID 원칙을 무시하지 말아야 합니다.\n\n이에 대해 이야기한 글을 작성했습니다:\n\n<div class=\"content-ad\"></div>\n\n# 외부 라이브러리 래핑하기\n\n이거 좋아요. 이 방법은 외부 라이브러리를 자신의 코드에서 분리하는 쉬운 방법이에요.\n\n이렇게 하는 대신에:\n\n```js\nThirdPartyLibrary.doSomething();\n```\n\n<div class=\"content-ad\"></div>\n\n여기 변경하세요:\n\n\nMyWrapperOfThirdPartyLibrary.doSomething();\n\n...\n\nclass MyWrapperOfThirdPary{\n  public void doSomething(){\n    ThirdPartyLibrary.doSomething();  \n  }\n}\n\n\n# 멀티 언어를 지원할 앱을 준비하세요\n\n이것은 여러 언어로 확장 가능한 앱으로 변화시키기 위해 시간을 소모하면서 낮은 노력으로 자원을 투자할 수 있는 한 가지 방법입니다.\n\n<div class=\"content-ad\"></div>\n\n# 네비게이션 스키마 선택\n\n네비게이션 흐름을 먼저 정의해야 합니다. 네비게이션은 앱을 조직하는 데 사용되며, 이를 해결하는 여러 패키지를 활용해야 합니다.\n\n저는 다양한 방식을 사용해왔지만, 최근 앱에서는 Go Router를 선택했습니다. 이는 깔끔하고 쉽습니다.\n\n# 에러 처리하기\n\n<div class=\"content-ad\"></div>\n\n에러를 어떻게 처리할지 정의해야 합니다. 에러는 발생할 수 있으며, 방치해서는 안 됩니다.\n\n저는 앱에서 에러를 처리하는 데 데코레이터를 정의했습니다:\n\n# 뷰를 위한 레이아웃 만들기\n\n뷰를 범주별이나 유형별로 구성하면 재사용성이 향상됩니다. 각 유형의 페이지를 위한 템플릿이나 레이아웃을 만들고 여러 뷰에서 사용할 수 있습니다. 이렇게 하면 변경 사항을 구현하기가 더 쉬워집니다.\n\n<div class=\"content-ad\"></div>\n\n레이아웃에 관한 내 게시물을 확인해보세요:\n\n# 로컬 데이터를 유지하는 방법 정의\n\n요즘에는 로컬 데이터를 관리하는 것이 매우 유용합니다. 사용자에게 오프라인 사용 가능성을 제공해야 하는 방법입니다. Shared Preferences와 같이 간단할 수도 있고, 데이터베이스와 같이 더 복잡할 수도 있습니다.\n\n데이터베이스를 사용해야 하는 경우에는 해당 로컬 데이터베이스의 스키마를 업그레이드하는 메커니즘을 정의해야 합니다. 상상할 수 있겠지만, 이미 이에 대해 글을 썼습니다:\n\n<div class=\"content-ad\"></div>\n\n# 다양한 환경을 정의하세요: 개발, 스테이징, 프로덕션\n\n앱을 개발할 때 유용하고 필수적입니다. 환경을 청결하게 관리할 수 있어야 합니다. 몇 가지 변수를 변경하면 스테이징 또는 프로덕션으로 전환할 수 있습니다.\n\n물론, 이에 대해 이야기한 포스트가 있습니다!\n\n# 로그 메커니즘 및 정책을 정의하세요\n\n<div class=\"content-ad\"></div>\n\n앱에 로그를 갖는 것이 매우 중요해요. 문제가 발생하고 문제가 있을 거에요. 이를 감지할 준비를 해야 해요. 처음부터 메커니즘을 정의하면 쉬울 거에요.\n\n여러 접근 방식과 앱 메시지를 로깅하는 다양한 패키지를 찾을 수 있어요.\n\n저는 그에 대해 이야기한 게시물이 있어요.\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\n- 신선한 공기를 마시고 생각해보세요.\n- 미친 듯이 앱 작성을 시작하지 마세요.\n- 핵심 주제에 대해 생각하고 어떻게 관리할지 정의해보세요.\n\n읽어주셔서 감사합니다. 좋았다면 박수를 쳐주세요!\n\n![이미지](/assets/img/2024-06-21-FlutterconsiderationsforwritinganAppfromthescratch_1.png)\n\n아래에 의견을 남겨주세요.\n\n<div class=\"content-ad\"></div>\n\n# Stackademic 🎓\n\n끝까지 읽어 주셔서 감사합니다. 떠나시기 전에:\n\n- 클로밍하고 작가를 팔로우해주시면 감사하겠습니다! 👏\n- 다음 사이트도 팔로우해주세요: X | LinkedIn | YouTube | Discord\n- 다른 플랫폼도 방문해보세요: In Plain English | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠를 다루는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요.\n- Stackademic.com에서 더 많은 콘텐츠를 만나보세요.","ogImage":{"url":"/assets/img/2024-06-21-FlutterconsiderationsforwritinganAppfromthescratch_0.png"},"coverImage":"/assets/img/2024-06-21-FlutterconsiderationsforwritinganAppfromthescratch_0.png","tag":["Tech"],"readingTime":4},{"title":"Firebase로 Flutter 웹 앱 호스팅하기 단계별 가이드","description":"","date":"2024-06-21 23:36","slug":"2024-06-21-HostingaFlutterWebApponFirebaseAStep-by-StepGuide","content":"\n\n<img src=\"/assets/img/2024-06-21-HostingaFlutterWebApponFirebaseAStep-by-StepGuide_0.png\" />\n\nFlutter은 개발자가 크로스 플랫폼 애플리케이션을 만드는 방식을 혁신했습니다. 이는 모바일 및 웹 플랫폼 모두에 대해 원활한 경험을 제공합니다. 웹 개발자들에게는 다양한 호스팅 옵션을 고려할 때 플러터 웹 앱을 호스팅하는 것이 어려울 수 있습니다. 그 중에서도 Firebase는 견고하고 개발자 친화적인 선택지로 빛을 발합니다. 이 글에서는 Firebase에서 플러터 웹 앱을 호스팅하기 위한 단계를 안내하겠습니다. 이를 통해 원활하고 성공적인 배포를 보장합니다.\n\n# 단계 1: 플러터 웹 앱 설정하기\n\nFirebase로 진입하기 전에 플러터 웹 앱이 배포 준비가 되어 있는지 확인하세요. 즉, 앱을 철저히 테스트하여 버그가 없고 최상의 성능을 발휘하는지 확인해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n- 앱 개발하기: 먼저 플러터 웹 앱을 만들어 보세요. 플러터가 처음이라면 시작하는 데 도움이 되는 다양한 리소스가 있습니다.\n- 앱 테스트하기: 앱이 예상대로 원활하게 실행되는지 확인하세요. 플러터는 이 프로세스를 돕는 테스트 도구를 제공합니다.\n\n# 단계 2: Firebase 도구 설치하기\n\nFirebase 도구는 Firebase 프로젝트를 배포하고 관리하는 데 도움이 되는 명령줄 도구입니다.\n\n- Node.js 설치: Firebase 도구는 Node.js를 필요로 합니다. nodejs.org에서 다운로드하여 설치하세요.\n- Firebase 도구 설치: 명령 프롬프트 또는 터미널을 열고 npm install -g firebase-tools를 실행하세요. 이 명령은 Firebase 명령줄 도구를 전역적으로 설치합니다.\n\n<div class=\"content-ad\"></div>\n\n# 단계 3: Firebase 프로젝트 만들기\n\n- Firebase 콘솔로 이동: Firebase 콘솔로 이동합니다.\n- 새 프로젝트 만들기: 화면 안내에 따라 새 Firebase 프로젝트를 만듭니다. 이 프로젝트는 당신의 Flutter 웹 앱을 위한 홈이 될 것입니다.\n\n# 단계 4: Firebase 및 Flutter 설정\n\nFirebase 프로젝트를 만든 후에, Flutter 앱과 연결해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n- 프로젝트에서 Firebase를 초기화하세요: 프로젝트 디렉토리에서 firebase init를 실행하세요.\n- Hosting 선택: 안내를 받으면 'Hosting' 옵션을 선택하거나 아래의 두 호스팅 옵션 중 선택하세요:\n\n![이미지](/assets/img/2024-06-21-HostingaFlutterWebApponFirebaseAStep-by-StepGuide_1.png)\n\n- 기존 프로젝트 사용 또는 새 프로젝트를 만들려면 새로 만들어지는 새 프로젝트를 선택하고 나머지 지침을 따르세요.\n- 방금 Firebase 콘솔에서 만든 프로젝트를 지정하세요.\n- 그런 다음 다음과 같이 진행하세요:\n\n![이미지](/assets/img/2024-06-21-HostingaFlutterWebApponFirebaseAStep-by-StepGuide_2.png)\n\n<div class=\"content-ad\"></div>\n\n- 그런 다음 `Set up automatic builds and deploys with GitHub?`이라는 옵션을 보고 만일 당신이 Github에 코드를 푸시할 때 자동으로 웹사이트를 재배포하고 싶다면 Y를 입력하고, 그렇지 않다면 N을 입력하세요.\n\n# 단계 5: Flutter 웹 앱 빌드하기\n\n배포하기 전에, Flutter 웹 앱의 릴리스 버전을 빌드해야 합니다.\n\n- 빌드 명령 실행: 터미널에서 flutter build web 명령을 실행하세요. 이 명령은 앱을 배포 가능한 웹 형식으로 컴파일합니다.\n\n<div class=\"content-ad\"></div>\n\n# 단계 6: Firebase로 배포하기\n\n앱을 구축하고 Firebase를 구성했으면 배포할 준비가 되었습니다.\n\n- 앱을 배포하세요: 프로젝트 디렉토리에서 firebase deploy를 실행하십시오. 이 명령은 구축된 앱을 Firebase Hosting에 업로드합니다.\n- 앱에 액세스하기: 배포가 완료되면 Firebase가 웹 앱에 액세스할 수 있는 URL을 제공합니다.\n\n# 단계 7: 앱 관리 및 업데이트하기\n\n<div class=\"content-ad\"></div>\n\n파이어베이스는 앱 사후 배포를 관리하기 위한 다양한 도구를 제공합니다.\n\n- 성능 모니터링: 파이어베이스의 분석 도구를 사용하여 사용자 참여 및 앱 성능을 추적합니다.\n- 앱 업데이트: 간단히 flutter build web로 앱을 다시 빌드하고 firebase deploy를 실행하여 업데이트할 수 있습니다.\n\n# 결론\n\n파이어베이스를 사용하면 Flutter 웹 앱을 호스팅하는 것이 직관적인 프로세스로 개발자들에게 다양한 기회를 제공합니다. 파이어베이스를 통해 앱을 호스팅할 뿐만 아니라 분석, 데이터베이스 관리 등의 기타 기능도 활용할 수 있습니다. 이러한 단계를 따라 Flutter 웹 앱을 파이어베이스에 호스팅하여 전세계 사용자가 액세스할 수 있도록 준비시킬 수 있습니다. 즐거운 코딩하세요!\n\n<div class=\"content-ad\"></div>\n\nyawarosman.com","ogImage":{"url":"/assets/img/2024-06-21-HostingaFlutterWebApponFirebaseAStep-by-StepGuide_0.png"},"coverImage":"/assets/img/2024-06-21-HostingaFlutterWebApponFirebaseAStep-by-StepGuide_0.png","tag":["Tech"],"readingTime":3},{"title":"DropdownMenu  검색 가능한 드롭다운 Flutter 폼을 향상시키는 방법","description":"","date":"2024-06-21 23:34","slug":"2024-06-21-DropdownMenuAsearchabledropdownSuperchargeyourFlutterforms","content":"\n\n세 번째 파티 제약을 작별하고! 플러터에서 검색 가능한 드롭다운을 만들어보세요. 검색과 스타일이 적용된 여러분만의 드롭다운.\n\n플러터 DropdownMenu 마스터하기 - 아름답고 강력한 메뉴에 대한 안내\n\n![DropdownMenu](/assets/img/2024-06-21-DropdownMenuAsearchabledropdownSuperchargeyourFlutterforms_0.png)\n\n우리가 목표로 하고 있는 것은 아래와 같아요 👇🏻\n\n<div class=\"content-ad\"></div>\n\n아래는 마크다운 형식으로 변경한 코드입니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:530/1*7fLEf7WBv-qxlUx5vDYMPQ.gif)\n\n### 준비되셨나요? 코드 작성을 시작해봅시다!\n\n- 드롭다운 메뉴에 표시하고 싶은 항목 목록을 준비해봅시다. 이것은 문자열, 객체 또는 위젯의 리스트일 수 있습니다.\n\n```dart\nclass MenuItem {\n  final int id;\n  final String label;\n  final IconData icon;\n\n  MenuItem(this.id, this.label, this.icon);\n}\n\nList<MenuItem> menuItems = [\n  MenuItem(1, '홈', Icons.home),\n  MenuItem(2, '프로필', Icons.person),\n  MenuItem(3, '설정', Icons.settings),\n  MenuItem(4, '즐겨찾기', Icons.favorite),\n  MenuItem(5, '알림', Icons.notifications),\n];\n```\n\n<div class=\"content-ad\"></div>\n\n여기 검색 가능한 DropdownMenu의 코드입니다.\n\n```js\nDropdownMenu<MenuItem>(\n                initialSelection: menuItems.first,\n                controller: menuController,\n                width: width,\n                hintText: \"메뉴 선택\",\n                requestFocusOnTap: true,\n                enableFilter: true,\n                label: const Text('메뉴 선택'),\n                onSelected: (MenuItem? menu) {\n                  selectedMenu = menu;\n                },\n                dropdownMenuEntries:\n                    menuItems.map<DropdownMenuEntry<MenuItem>>((MenuItem menu) {\n                  return DropdownMenuEntry<MenuItem>(\n                      value: menu,\n                      label: menu.label,\n                      leadingIcon: Icon(menu.icon));\n                }).toList(),\n              ),\n```\n\n요령있죠! DropdownMenuEntry는 각 메뉴 항목의 이름표처럼 동작하여 프로그램에 누구인지 알려주고 사용자에게 어떤 동작을 하는지 보여줍니다.\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 Markdown 형식으로 변경해 주세요.\n\n<div class=\"content-ad\"></div>\n\n장점:\n\n- 내장: 추가 패키지가 필요하지 않으며, 플러터에서 쉽게 사용할 수 있습니다.\n- 사용하기 쉬움: 간단한 드롭다운 메뉴에 대한 기본 구현이 있습니다.\n- 사용자 정의 옵션: 메뉴 스타일, 초기 선택 및 필터링 동작을 제어할 수 있습니다.\n- 기본적인 요구에 적합: 기능이 제한된 간단한 드롭다운 메뉴에 적합합니다.\n\n단점:\n\n- 검색 기능이 제한적: 내장 필터링이 기본적이며, 레이블의 처음만 일치하는 것만 지원합니다.\n- 사용자 정의 제한: 개별 목록 항목을 사용자 정의하거나 복잡한 검색 로직을 구현할 수 없습니다.\n- 고급 기능 없음: 자동 완성, 제안 또는 다중 선택과 같은 기능이 없습니다.\n\n그래서, 여기가 함정입니다.\n\n<div class=\"content-ad\"></div>\n\n단순한 드롭다운 및 기본 필터링이 필요하다면, 내장된 DropdownMenu를 사용하세요! 고급 검색, 화려한 사용자 정의 또는 추가 기능이 필요하다면 강력한 dropdown_search 패키지를 선택하세요. 쉽죠!\n\n도움이 되었으면 좋겠네요!\n\n모한쿠마르\n\n중요한 질문이 있고 제가 놓치기를 원치 않으시면, mohan.smk23@gmail.com 으로 이메일 보내주세요.\n\n<div class=\"content-ad\"></div>\n\n플러터에 대한 더 많은 콘텐츠를 보고 싶나요? 커피 한 잔 사주시면 글쓰기 열정에 불을 지킬 수 있어요!\n\n![이미지](/assets/img/2024-06-21-DropdownMenuAsearchabledropdownSuperchargeyourFlutterforms_1.png)\n\n다른 내용도 확인해보세요!","ogImage":{"url":"/assets/img/2024-06-21-DropdownMenuAsearchabledropdownSuperchargeyourFlutterforms_0.png"},"coverImage":"/assets/img/2024-06-21-DropdownMenuAsearchabledropdownSuperchargeyourFlutterforms_0.png","tag":["Tech"],"readingTime":3},{"title":"Flutter 백그라운드 작업 앱 성능 향상 방법","description":"","date":"2024-06-21 23:32","slug":"2024-06-21-FlutterBackgroundTasksImprovingAppPerformance","content":"\n\n요즘의 빠르게 변화하는 디지턈 세계에서 사용자들은 모바일 어플리케이션이 효율적이고 반응성이 있기를 원합니다. 개발자들은 이러한 요구를 충족시키기 위해 어플리케이션의 성능을 향상시키기 위한 다양한 전략을 사용해야 합니다. 그 중 하나는 백그라운드 작업을 실행하는 것인데, 이를 통해 Flutter 어플리케이션이 사용자 경험을 방해하지 않으면서 고통스러운 작업을 처리할 수 있습니다. 이 블로그 글에서 Flutter의 백그라운드 작업과 중요성을 살펴보고, 구현하는 방법을 보여줄 코딩 예제를 제공해보겠습니다.\n\n## 백그라운드 작업이 중요한 이유\n\n사용자 경험이 원활하고 끊김없이 유지되려면 백그라운드 프로세스가 필수적입니다. 이를 통해 프로그래머들은 동기화, 데이터 수집, 처리와 같이 자원 집약적인 작업을 주 UI 스레드를 방해하지 않고 백그라운드에서 처리할 수 있습니다. 이러한 작업들은 백그라운드 프로세스로 이동되어 어플리케이션이 반응적으로 유지되고 사용자들에게 원활한 경험을 제공합니다.\n\n## Flutter 백그라운드 작업 구현\n\n<div class=\"content-ad\"></div>\n\n플러터는 배경 작업을 효과적으로 수행하기 위한 다양한 도구와 모듈을 제공합니다. 자주 사용되는 두 가지 방법을 살펴봅시다:\n\nIsolate를 기반으로 하는 배경 작업:\n\n메인 UI 스레드와 병렬로 작동하는 경량 별도 실행 스레드인 아이솔레이트는 배경 작업을 메인 스레드에 간섭하지 않고 수행할 수 있도록 합니다. 다음은 아이솔레이트가 배경 작업에 사용되는 예시입니다:\n\n```js\nimport 'dart:async';\nimport 'dart:isolate';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatefulWidget {\n  @override\n  _MyAppState createState() => _MyAppState();\n}\n\nclass _MyAppState extends State<MyApp> {\n  ReceivePort _port = ReceivePort();\n\n  @override\n  void initState() {\n    super.initState();\n    _startBackgroundTask();\n  }\n\n  void _startBackgroundTask() async {\n    await Isolate.spawn(_backgroundTask, _port.sendPort);\n    _port.listen((message) {\n      // 배경 작업 완료 처리\n      print('배경 작업 완료: $message');\n    });\n  }\n\n  static void _backgroundTask(SendPort sendPort) {\n    // 시간이 많이 소요되는 작업 수행\n    // ...\n\n    // 결과를 메인 UI 아이솔레이트로 전송\n    sendPort.send('작업 성공적으로 완료!');\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text('플러터의 배경 작업'),\n        ),\n        body: Center(\n          child: Text('배경 작업 실행 중...'),\n        ),\n      ),\n    );\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n플러터의 배경 작업 가져오기:\n\n앱이 닫혀 있거나 사용 중이 아닌 경우에도, 개발자는 플러터 배경 작업 가져오기 플러그인을 사용하여 주기적인 배경 작업을 계획할 수 있습니다. 이는 데이터 동기화나 앱 컨텐츠 업데이트와 같은 상황에서 유용합니다. 플러터 배경 작업 가져오기 패키지를 사용하는 예제는 다음과 같습니다:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_background_fetch/flutter_background_fetch.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text('플러터에서 배경 작업 실행'),\n        ),\n        body: Center(\n          child: Text('배경 작업 실행 중...'),\n        ),\n      ),\n    );\n  }\n}\n\nvoid backgroundFetchHeadlessTask(String taskId) async {\n  // 여기에서 시간이 오래 걸리는 작업을 수행합니다\n  // ...\n\n  FlutterBackgroundFetch.finish(taskId);\n}\n\nvoid initBackgroundFetch() {\n  FlutterBackgroundFetch.configure(\n    minimumFetchInterval: 15,\n    stopOnTerminate: false,\n    startOnBoot: true,\n    enableHeadless: true,\n    requiresBatteryNotLow: false,\n    requiresCharging: false,\n    requiresStorageNotLow: false,\n    requiresDeviceIdle: false,\n    requiredNetworkType: NetworkType.NONE,\n  );\n  FlutterBackgroundFetch.registerHeadlessTask(backgroundFetchHeadlessTask);\n}\n```\n\n플랫폼 채널:\n\n<div class=\"content-ad\"></div>\n\n플랫폼 채널을 통해 Flutter는 네이티브 플랫폼 코드와 통신할 수 있습니다. 코틀린 또는 스위프트로 플랫폼별 코드를 작성하면 백그라운드 작업을 수행할 수 있는 플랫폼 채널을 사용할 수 있습니다. 필요한 작업은 그런 다음 네이티브 코드에서 백그라운드에서 수행될 수 있고, Flutter 앱에서 결과를 얻을 수 있습니다. 이 접근 방식으로 유연성과 플랫폼별 API에 접근할 수 있습니다.\n\n배경 작업을 실행하여 플랫폼별 코드를 사용하여 기기의 현재 위치를 획득하는 활동을 실행하려고 상상해보세요. 이렇게 플랫폼 채널이 사용되는 방법을 설명하기 위한 것입니다.\n\nFlutter 앱에서 플랫폼별 코드를 실행하는 메서드를 만들어보세요:\n\n```js\nimport 'package:flutter/services.dart';\n\nFuture<String> getCurrentLocation() async {\n  const platform = MethodChannel('your_channel_name');\n  try {\n    final String result = await platform.invokeMethod('getCurrentLocation');\n    return result;\n  } catch (e) {\n    return 'Failed to get location: $e';\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n플랫폼별 언어로 위치 검색 기능을 구현해보세요:\n\n```js\nclass MainActivity : FlutterActivity() {\n    private val CHANNEL = \"your_channel_name\"\n\n    override fun configureFlutterEngine(flutterEngine: FlutterEngine) {\n        super.configureFlutterEngine(flutterEngine)\n        MethodChannel(flutterEngine.dartExecutor.binaryMessenger, CHANNEL).setMethodCallHandler { call, result ->\n            if (call.method == \"getCurrentLocation\") {\n                // 백그라운드에서 위치를 검색합니다\n                val location = getLocation()\n                result.success(location)\n            } else {\n                result.notImplemented()\n            }\n        }\n    }\n\n    private fun getLocation(): String {\n        // 안드로이드 특화 API를 사용하여 위치를 가져옵니다\n        // ...\n        return \"위도: 20.5937, 경도: 78.9629\"\n    }\n}\n```\n\n```js\nimport UIKit\nimport Flutter\n\n@UIApplicationMain\n@objc class AppDelegate: FlutterAppDelegate {\n    let CHANNEL = \"your_channel_name\"\n\n    override func application(\n        _ application: UIApplication,\n        didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?\n    ) -> Bool {\n        let controller = window?.rootViewController as! FlutterViewController\n        let channel = FlutterMethodChannel(name: CHANNEL, binaryMessenger: controller.binaryMessenger)\n        channel.setMethodCallHandler { [weak self] call, result in\n            if call.method == \"getCurrentLocation\" {\n                // 백그라운드에서 위치를 검색합니다\n                let location = self?.getLocation() ?? \"\"\n                result(location)\n            } else {\n                result(FlutterMethodNotImplemented)\n            }\n        }\n\n        GeneratedPluginRegistrant.register(with: self)\n        return super.application(application, didFinishLaunchingWithOptions: launchOptions)\n    }\n\n    private func getLocation() -> String {\n        // iOS 특화 API를 사용하여 위치를 가져옵니다\n        // ...\n        return \"위도: 123.456, 경도: 78.901\"\n    }\n}\n```\n\nWorkManager(안드로이드) 및 BackgroundFetch(iOS)에서 사용하세요.\n\n<div class=\"content-ad\"></div>\n\n주어진 플랫폼에서 백그라운드 작업을 보다 효과적으로 처리하기 위해 WorkManager(안드로이드)와 BackgroundFetch(iOS)와 같은 플랫폼별 라이브러리를 사용할 수 있습니다. 이러한 라이브러리에는 작업 스케줄링, 반복 및 네트워크 의존 프로세스 관리, 그리고 작업이 완료되었을 때 Flutter 앱에 콜백을 제공하는 기능이 포함되어 있습니다.\n\n만약 이 방법을 보여주기 위해 서버에서 데이터를 정기적으로 다운로드하는 백그라운드 활동을 예약하려고 한다면 다음과 같이 할 수 있습니다.\n\nWorkManager를 사용하기 위해 android/app/build.gradle 파일에 필요한 종속성을 추가하세요:\n\n```js\ndependencies {\n    def work_version = \"2.6.0\"\n\n    implementation \"androidx.work:work-runtime:$work_version\"\n}\n```\n\n<div class=\"content-ad\"></div>\n\n워커 클래스를 만들어 백그라운드 작업을 설명해 보겠습니다:\n\n```js\n// 플러터 측\nimport 'package:flutter_background_fetch/flutter_background_fetch.dart';\n\nvoid initBackgroundFetch() {\n  FlutterBackgroundFetch.configure(\n    minimumFetchInterval: 15,\n    stopOnTerminate: false,\n    startOnBoot: true,\n    enableHeadless: true,\n    requiresBatteryNotLow: false,\n    requiresCharging: false,\n    requiresStorageNotLow: false,\n    requiresDeviceIdle: false,\n    requiredNetworkType: NetworkType.NONE,\n  );\n  FlutterBackgroundFetch.registerHeadlessTask(backgroundFetchHeadlessTask);\n}\n\nvoid backgroundFetchHeadlessTask(String taskId) async {\n  // 여기서 시간이 많이 소요되는 작업(예: 데이터 가져오기)을 수행합니다\n  // ...\n\n  FlutterBackgroundFetch.finish(taskId);\n}\n```\n\nBackgroundFetch를 사용하려면 pubspec.yaml 파일에 다음 종속성을 추가하세요:\n\n```js\ndependencies:\n  background_fetch: ^0.9.0\n```\n\n<div class=\"content-ad\"></div>\n\n다음 백그라운드 작업을 구현해보세요:\n\n```js\n// 플러터 측\nimport 'package:flutter/material.dart';\nimport 'package:background_fetch/background_fetch.dart';\n\nvoid main() {\n  runApp(MyApp());\n  initBackgroundFetch();\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text('Flutter에서 백그라운드 작업'),\n        ),\n        body: Center(\n          child: Text('백그라운드 작업 실행 중...'),\n        ),\n      ),\n    );\n  }\n}\n\nvoid initBackgroundFetch() {\n  BackgroundFetch.configure(\n    BackgroundFetchConfig(\n      minimumFetchInterval: 15,\n      stopOnTerminate: false,\n      startOnBoot: true,\n      enableHeadless: true,\n    ),\n    (String taskId) async {\n      // 여기서 시간이 많이 소요되는 작업(예: 데이터 가져오기) 수행하기\n      // ...\n\n      BackgroundFetch.finish(taskId);\n    },\n  );\n}\n```\n\n## 타이머:\n\n항상 번거로운 백그라운드 작업을 실행할 필요는 없을 수 있습니다. 대신 플러터 프로그램에 내장된 타이머를 활용할 수도 있습니다. Dart 프로그래밍 언어에는 백그라운드 작업을 계획하고 수행할 수 있는 Timer 클래스가 함께 제공되며, 플랫폼별 추가 기능이 필요하지 않은 프로젝트에 적합합니다.\n\n<div class=\"content-ad\"></div>\n\n이 예시를 위해, 플러터 앱에서 매 시간마다 공지를 표시하고 싶다고 가정해 봅시다.\n\n```js\nimport 'dart:async';\nimport 'package:flutter/material.dart';\nimport 'package:flutter_local_notifications/flutter_local_notifications.dart';\n\nvoid main() {\n  runApp(MyApp());\n  scheduleNotifications();\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text('플러터에서 백그라운드 작업하기'),\n        ),\n        body: Center(\n          child: Text('백그라운드 작업 실행 중...'),\n        ),\n      ),\n    );\n  }\n}\n\nvoid scheduleNotifications() {\n  Timer.periodic(Duration(hours: 1), (Timer timer) {\n    showNotification();\n  });\n}\n\nvoid showNotification() {\n  FlutterLocalNotificationsPlugin flutterLocalNotificationsPlugin =\n      FlutterLocalNotificationsPlugin();\n  // 플러그인 설정 초기화\n  // ...\n\n  flutterLocalNotificationsPlugin.show(\n    0,\n    '매 시간 알림',\n    '매 시간 트리거되는 알림입니다.',\n    NotificationDetails(\n      android: AndroidNotificationDetails(\n        '채널 ID',\n        '채널 이름',\n        '채널 설명',\n      ),\n      iOS: IOSNotificationDetails(),\n    ),\n  );\n}\n```\n\n## Firebase Cloud Messaging (FCM):\n\nFirebase Cloud Messaging (FCM)은 서버 이벤트에 의해 유발된 경보를 보내거나 활동을 수행하는 백그라운드 활동에 도움이 될 수 있습니다. 플러터 앱이 열리지 않거나 사용되지 않아도 FCM을 통해 서버에서 메시지를 전송할 수 있습니다. 이 신호에 응답하고 필요한 백그라운드 작업을 수행할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 예제를 기준으로 FCM 알림을 수신할 때마다 백그라운드 프로세스를 실행하려고 한다고 가정해 봅시다.\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:firebase_messaging/firebase_messaging.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text('Flutter에서 백그라운드 작업'),\n        ),\n        body: Center(\n          child: Text('백그라운드 작업 실행 중...'),\n        ),\n      ),\n    );\n  }\n}\n\nvoid initFirebaseMessaging() {\n  FirebaseMessaging messaging = FirebaseMessaging.instance;\n  messaging.configure(\n    onMessage: (message) {\n      // 메시지를 수신할 때 백그라운드 작업 수행\n      // ...\n      return;\n    },\n    onResume: (message) {\n      // 앱이 백그라운드에서 다시 활성화될 때 백그라운드 작업 수행\n      // ...\n      return;\n    },\n    onLaunch: (message) {\n      // 앱이 종료된 상태에서 다시 실행될 때 백그라운드 작업 수행\n      // ...\n      return;\n    },\n  );\n}\n```\n\n## 결론:\n\nFlutter 애플리케이션의 효율성을 향상시키는 중요한 구성 요소 중 하나는 백그라운드 활동입니다. 시간이 오래 걸리는 작업을 백그라운드에서 실행함으로써 원활한 사용자 경험을 제공하고 UI가 느려지는 것을 방지할 수 있습니다. 이 블로그 글에서는 아이솔레이트와 Flutter Background Fetch 패키지의 사용법을 살펴보았습니다. 이러한 전략을 Flutter 애플리케이션에 구현하여 앱의 속도를 향상시키고 우수한 사용자 경험을 제공할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n앱 기능과 효율성을 균형 있게 유지하기 위해 백그라운드 작업을 구현할 때 장치 자원, 배터리 수명 및 네트워크 이용량과 같은 요소를 고려하는 것이 중요합니다.\n\n## 코딩 즐기세요!!!…","ogImage":{"url":"/assets/img/2024-06-21-FlutterBackgroundTasksImprovingAppPerformance_0.png"},"coverImage":"/assets/img/2024-06-21-FlutterBackgroundTasksImprovingAppPerformance_0.png","tag":["Tech"],"readingTime":11},{"title":"Robot 패턴을 사용한 Flutter 통합 테스트 작성법  이제껏 경험하지 못한 방법","description":"","date":"2024-06-21 23:30","slug":"2024-06-21-HowtowriteintegrationtestsinFlutterlikenootherusingtheRobotPattern","content":"\n\n플러터에서 통합 테스트를 작성하고 싶다면, 더 이상 찾을 필요가 없어요! 전문가처럼 로봇 패턴을 사용하여 통합 테스트를 작성하는 방법을 정확히 보여드릴 거예요.\n\n튜토리얼을 비디오 형식으로 따라가시길 원하신다면, 이 비디오를 확인해주세요.\n\n바로 시작해봅시다!\n\n통합 테스트를 작성하기 위해서는 먼저 무엇이 통합 테스트인지 배워야 해요.\n\n<div class=\"content-ad\"></div>\n\n통합 테스트는 소프트웨어의 다른 모듈을 그룹으로 테스트하는 데 사용됩니다. 이러한 테스트는 종단 간 (End to End, E2E) 테스트로도 알려져 있습니다.\n\n우리의 경우, 앱의 두 모듈을 그룹으로 테스트할 것입니다. 로그인 모듈과 홈 모듈입니다.\n\n이것을 코드 따라하기 튜토리얼로 만들기로 했기 때문에, 여기에 템플릿을 업로드했습니다: [링크](https://github.com/Coffiie/personal_projects/tree/develop/code_along/robot_testing_flutter_gh)\n\n프로젝트를 클론하고 저와 함께 단계별로 통합 테스트를 구현해보세요!\n\n<div class=\"content-ad\"></div>\n\n만약 Medium에서 50명의 팔로워를 얻으면, GitHub에서 이를 위한 통합 플로우와 소스 코드를 모두 공개할 거에요!\n\n그러기 전에 시작하기 전에, 테스트를 작성할 앱과 테스트를 구현할 패턴에 대해 살펴봐요.\n\n저희 앱은 \"1234\" 앱이에요. 이 마법의 숫자로 홈페이지에 접속할 수 있어요.\n\n하지만 잘못된 자격 증명을 입력하면, 화면 하단에 \"잘못된 자격 증명\" 메시지가 표시되는 스낵 바가 나타나요.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-21-HowtowriteintegrationtestsinFlutterlikenootherusingtheRobotPattern_0.png)\n\n로봇 패턴은 일반 사용자가 하는 것과 같은 동작을 로봇을 통해 수행하여 통합 테스트를 작성하는 방법입니다.\n\n이는 우리가 테스트하는 내용에 집중하도록 하며 어떻게 테스트하는지보다는 무엇을 테스트하는지에 중점을 두도록 합니다. 또한 코드를 더 읽기 쉽고 재사용 가능하도록 만듭니다.\n\n이제 통합 테스트, 앱 및 로봇 패턴에 대한 일반적인 이해가 생겼으므로 통합 테스트 작성을 시작할 수 있습니다!\n\n\n<div class=\"content-ad\"></div>\n\n## 단계 1: 통합 테스트 패키지 가져오기\n\n![이미지](/assets/img/2024-06-21-HowtowriteintegrationtestsinFlutterlikenootherusingtheRobotPattern_1.png)\n\n## 단계 2: 로그인 로봇 생성\n\nFlutter 프로젝트의 루트에 integration_test라는 폴더를 만든 다음 그 폴더 안에 robots라는 폴더를 만드세요.\n\n<div class=\"content-ad\"></div>\n\n우리의 모든 통합 테스트 플로우는 integration_test 폴더의 하위로 이동하게 될 것이고, 우리의 로봇들은 robots 폴더의 하위로 이동하게 될 거에요.\n\n이제 robots 디렉토리 안에 robot을 만들어보고 login_robot.dart라고 이름 짓도록 해요.\n\n이 파일 안에는 LoginRobot 클래스를 구현할 거고, 이 클래스는 테스트 프레임워크와 상호 작용하며 사용자가 하는 동일한 작업을 수행하여 로그인 화면을 테스트할 것입니다.\n\n그래서 이제 우리는 이렇게 클래스에 WidgetTester 의존성을 추가할 수 있어요:\n\n<div class=\"content-ad\"></div>\n\n\n![Image 1](/assets/img/2024-06-21-HowtowriteintegrationtestsinFlutterlikenootherusingtheRobotPattern_2.png)\n\n## Step 3: 분석 로그인 페이지\n\n소스 코드를 살펴보면, WidgetKeys 클래스에 할당된 여러 위젯을 볼 수 있습니다. 이러한 키는 테스트 프레임워크에서 위젯을 식별하는 데 유용하며, 테스트에서 위젯을 찾을 때 유리합니다.\n\n![Image 2](/assets/img/2024-06-21-HowtowriteintegrationtestsinFlutterlikenootherusingtheRobotPattern_3.png)\n\n\n<div class=\"content-ad\"></div>\n\n## 단계 4: 로그인 로봇 구현\n\nLoginRobot 클래스에 다음 메서드를 추가합니다.\n\n![이미지](/assets/img/2024-06-21-HowtowriteintegrationtestsinFlutterlikenootherusingtheRobotPattern_4.png)\n\n- verify(): 로그인 화면에 존재하는지 테스트합니다.\n- enterPassword, enterUsername 및 tapLoginButton은 실명있는 메서드입니다.\n- verifyError(): 잘못된 자격 증명을 입력했을 때 나타나는 스낵 바를 테스트하는 데 사용됩니다.\n\n<div class=\"content-ad\"></div>\n\n## 단계 5: 인증되지 않은 플로우 생성\n\n이 앱에는 2가지 주요 플로우가 있습니다.\n\n하나는 인증되지 않은 플로우이며, 여기서 사용자는 로그인할 수 없으며 잘못된 자격 증명을 입력한 사용자에게 스낵 바가 표시됩니다.\n\n다른 플로우는 올바른 자격 증명으로 인증하고 홈 화면으로 이동할 수 있는 플로우입니다.\n\n<div class=\"content-ad\"></div>\n\n이번 튜토리얼은 간단하게 유지하기 위해 인증되지 않은 흐름에만 초점을 맞추겠습니다.\n\n구현을 시작하려면 integration_test 폴더에 e2e_unauth_test.dart라는 파일을 만들어주세요.\n\n먼저 main() 메서드를 생성해주세요. 그런 다음 IntegrationTestWidgetsFlutterBinding.ensureInitialized()를 호출하여 통합 테스트 프레임워크가 준비되었는지 확인해주세요.\n\n이 작업이 완료되면 LoginRobot 메서드를 호출하여 테스트 흐름을 신속하게 구현할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-21-HowtowriteintegrationtestsinFlutterlikenootherusingtheRobotPattern_5.png)\n\n3번째 줄에 import를 주목하세요. 라인 14에서 Myapp 생성자를 직관적으로 호출하여 개발한 실제 앱을 펌핑할 수 있습니다.\n\n## 단계 6: 테스트 실행\n\n타다! 실행 옵션을 누름으로써 테스트를 실행하고 통과하는 것을 관찰할 수 있습니다! \n앱을 더 견고하게 만들어줄 코드를 성공적으로 작성하였습니다!\n\n\n<div class=\"content-ad\"></div>\n\n## 명심해야 할 몇 가지 사항\n\n- 통합 테스트는 소프트웨어의 다른 모듈을 그룹으로 테스트하는 데 사용됩니다. 또한 엔드 투 엔드 (E2E) 테스트로도 알려져 있습니다.\n- 로봇 패턴에서는 각 화면에 대한 로봇을 작성하고 위젯 테스터를 사용하여 사용자가 하는 것과 유사한 테스트를 작성합니다.\n- 로봇을 구현한 후에는 모든 구현이 로봇 내부에 추상화되어 있으므로 특정 작업을 실행해야 할 때마다 그들의 메소드를 호출하기만 하면 복잡한 흐름을 쉽게 만들 수 있습니다.\n\n## 재미있는 활동\n\n인증된 흐름을 구현해야 할 마지막 흐름이 남아 있습니다. 이를 만들고 완료되면 LinkedIn에서 DM(Direct Message)을 보내주세요. 당신의 솔루션을 보는 것을 기대할게요! :)\n\n<div class=\"content-ad\"></div>\n\n# 만약 튜토리얼이 마음에 드셨다면...\n\n저를 여기와 제 소셜 미디어 계정에서 팔로우해주세요!\n\n팔로우하기:\n\nYoutube: [링크](https://www.youtube.com/channel/UCD2BEqL0wC7leFKm4i9_aRg)\nLinkedIn: [링크](https://www.linkedin.com/in/rawahamuhammad/)\nGithub: [링크](https://github.com/coffiie)\nMedium: Rawaha Muhammad\n\n<div class=\"content-ad\"></div>\n\n런타임 스니펫(Runtime Snippets)을 따라하세요 (조각처럼 작은 플러터/다트 튜토리얼)\n\nYoutube: https://www.youtube.com/channel/UCD2BEqL0wC7leFKm4i9_aRg\nLinkedIn: https://www.linkedin.com/company/100042850\nTwitter: https://twitter.com/runtimesnippets","ogImage":{"url":"/assets/img/2024-06-21-HowtowriteintegrationtestsinFlutterlikenootherusingtheRobotPattern_0.png"},"coverImage":"/assets/img/2024-06-21-HowtowriteintegrationtestsinFlutterlikenootherusingtheRobotPattern_0.png","tag":["Tech"],"readingTime":5}],"page":"2","totalPageCount":21,"totalPageGroupCount":2,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}