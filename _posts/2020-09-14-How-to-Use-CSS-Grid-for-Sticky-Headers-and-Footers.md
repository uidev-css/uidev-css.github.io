---
layout: post
title: "고정 헤더 및 바닥글에 CSS 그리드를 사용하는 방법"
author: 'CSS Dev'
thumbnail: https://res.cloudinary.com/css-tricks/image/fetch/w_1200,q_auto,f_auto/https://css-tricks.com/wp-content/uploads/2020/08/sticky-head-footer.png
tags: GRID,STICKY FOOTER
---


CSS Grid는 그 어느 때보다 쉽게 레이아웃을 만들 수 있도록 설계된 속성 모음입니다. 다른 것과 마찬가지로, 학습 곡선이 약간 있지만, Grid는 일단 익숙해지면 함께 일하는 것이 솔직히 즐겁습니다. 그것이 빛나는 한 영역은 머리말과 바닥글을 다루는 것입니다. 조금만 생각을 가다듬으면 고정된 것처럼 행동하는 머리말과 발바닥을 떼어낼 수도 있고 끈적끈적한 대접(자세: 끈적끈적한 게 아니라, 내용이 부족해도 화면 바닥을 끌어안고 더 많은 콘텐츠로 밀어내는 그런 식의 바닥글)을 할 수도 있다.

이것이 현대 레이아웃에 대한 관심을 더욱 불러일으키길 바라며, 만약 그렇다면, Rachel Andrew의 책 The New CSS Layout을 충분히 추천할 수 없을 것입니다: 그것은 주요한 현대 레이아웃 기법, 그리드 및 플렉스박스 모두를 다루고 있습니다.

### 우리가 만드는 것

헤더, 기본 컨텐츠 및 바닥글로 구성된 상당히 고전적인 HTML 레이아웃을 구현해 보겠습니다.

필요에 따라 기본 콘텐츠가 스크롤되는 뷰포트 맨 아래에 유지되는 진정한 고정 바닥글을 만든 다음, 나중에 메인 콘텐츠가 작지만 필요에 따라 아래로 밀리는 기존의 고정 바닥글이 되도록 바닥글을 업데이트합니다. 또한 그리드에 대한 노출을 넓히기 위해 메인 콘텐츠 홀더를 설계하여 뷰포트의 전체 너비에 걸쳐 있거나 가운데에 잘 가운데 있는 스트립을 차지하도록 하자.

고정된 바닥글은 약간 비정상적입니다. 바닥글은 일반적으로 뷰포트 하단에서 시작하도록 설계되었으며, 필요에 따라 주요 내용에 의해 아래로 밀립니다. 그러나 지속적인 바닥글이 전례가 없는 것은 아니다. Charles Schwab은 그들의 홈페이지에서 그것을 한다. 어느 쪽이든 구현은 재미있을 것입니다!

하지만 다음으로 넘어가기 전에, 찰스 슈워브 사이트에 구현된 고정된 바닥글을 살펴보시기 바랍니다. 놀랄 것도 없이, 이것은 하드 코딩된 크기를 의미하는 고정 위치 지정을 사용합니다. 사실, DevTools를 열면 바로 알 수 있습니다.

```css
body #qq0 {
  border-top: 4px solid #133568;
  background-color: #eee;
  left: 0;
  right: 0;
  bottom: 0;
  height: 40px!important;
} 

```

그뿐만 아니라 하드코딩된 패딩(<footer> 요소의 아래 15px 포함), 여백(footer>의 20px 포함), 줄 바꿈(break)을 설정하여 주요 내용이 고정 바닥글 뒤에 숨겨지지 않도록 하는 균형도 있다.

![image](https://i2.wp.com/css-tricks.com/wp-content/uploads/2020/08/sticky-footer-inspect.png?resize=1024%2C631&ssl=1)

이런 제약 없이 이 일을 해내도록 합시다.

### 기본 스타일

이제 최소한의 UI를 스케치하여 시작하도록 하고, 목표에 맞게 그리드를 개선해 봅시다. 아래에는 코드 샌드박스가 있고, 그 다음 단계에는 코드 샌드박스가 추가되어 최종 결과를 얻을 수 있습니다.

먼저 준비 작업을 해 봅시다. 뷰포트의 전체 높이를 사용할 수 있으므로 그리드를 추가할 때 바닥글을 바닥에 놓기가 쉽습니다(그리고 거기에 보관). 문서의 <본문> 안에 app이라는 ID가 있는 요소는 오직 하나뿐인데, > header, >main, > footer 등의 요소를 담고 있다.

```css
body {
  margin: 0; /* prevents scrollbars */
}
 
#app {
  height: 100vh;
}
```

그런 다음 머리글, 주 섹션 및 바닥글 섹션과 모두 사용할 그리드를 설정하겠습니다. 분명히 말하면, 이것은 우리가 원하는 대로 정문에서 바로 나올 수 없을 것이다. 단지 우리가 시작할 수 있게 하기 위해서죠. 기지를 건설하기 위해서요.

```css
body {
  margin: 0;
}
 
#app {
  height: 100vh;
  
  /* grid container settings */
  display: grid;
  grid-template-columns: 1fr;
  grid-template-rows: auto 1fr auto;
  grid-template-areas: 
    'header'
    'main'
    'footer';
}
 
#app > header {
  grid-area: header;
}
 
#app > main {
  grid-area: main;
  padding: 15px 5px 10px 5px;
}
 
#app > footer {
  grid-area: footer;
}
```

우리는 폭이 `1fr`인 간단한 1열 레이아웃을 만들었습니다. 이 `1fr`이 처음 사용 중이라면 기본적으로 `남은 공간을 차지하라`는 뜻으로, 이 경우 그리드 컨테이너의 전체 폭인 `#app`을 의미합니다.

또한 세 개의 행도 정의했습니다.

```css
#app {
  /* etc. */
  grid-template-rows: auto 1fr auto;
  /* etc. */
}
```

첫 번째 행과 세 번째 행은 각각 머리글과 바닥글이 되며, 크기가 자동이므로 필요한 만큼 공간을 차지하게 됩니다. 다시 말해, 하드 코딩된 크기가 필요하지 않습니다! 이것은 매우 중요한 세부 사항이며 CSS 그리드를 사용함으로써 얻는 이익의 완벽한 예이다.

가운데 줄은 내용을 담는 자리입니다. 우리는 `1fr`의 크기를 할당했는데, 이것은 이것이 나머지 두 줄에서 남은 공간을 모두 차지한다는 것을 의미합니다. 우리가 왜 `자동`으로 만들지 않는지 궁금하다면, 그것은 전체 그리드가 뷰포트의 전체 높이에 걸쳐 있기 때문에 우리는 사용하지 않는 공간을 늘리고 메우기 위해 하나의 섹션이 필요하기 때문이다. 고정 높이, 여백, 패딩 또는 심지어 줄 바꿈도 없으며, 어떤 지점에서도 필요하지 않습니다! - 물건을 제자리에 밀어 넣습니다. 그리드와 함께 일할 때 좋은 삶이다!

### 콘텐츠 한 번 해볼까요?

샌드박스에서는 리액트를 사용하여 데모를 만들었지만, 리액트에 대한 게시물이 아니므로, 자세한 내용은 작업하지 않습니다. 리액트는 이 게시물에 있는 CSS 그리드 작업과 전혀 관련이 없습니다. 다른 마크업 사이를 쉽게 이동할 수 있는 방법으로만 사용하고 있습니다. 리액트가 싫다면, 괜찮습니다. 이 게시물에서는 무시해도 좋겠군요.

우리는 각각 예상되는 ➡헤더, ➡메인, ➡퍼(footer) 요소를 만드는 ➡헤더, ➡퍼(footer) 요소를 가지고 있다. 그리고 물론 이 모든 것은 우리의 `#app` 컨테이너 안에 들어 있다. 그렇다, 이론적으로, #app은 의미론적으로 말하면 "<기사>" 요소여야 하지만, 나에게는 항상 이상하게 보였다. 나는 단지 이 세부 사항들을 전달하고 싶었을 뿐이야. 그래서 우리는 모두 앞으로 나아갈 때 같은 입장이야.

실제 콘텐츠의 경우 헤더에서 탐색할 수 있는 청구 및 설정 섹션이 있습니다. 그들은 둘 다 가짜, 정적인 내용을 만들고, 단지 우리의 레이아웃을 실제로 보여주기 위한 것이다. Settings(설정) 섹션은 페이지의 중앙 스트립에 삽입된 내용이며, Billing(청구)은 전체 페이지에 걸쳐 있습니다.

지금까지 우리가 가지고 있는 샌드박스입니다.

청구 섹션은 보기 좋지만 설정 섹션은 바닥글을 화면 밖으로 밀어냅니다. 뿐만 아니라, 스크롤을 하면 페이지 전체가 스크롤되어 헤더를 잃게 됩니다. 경우에 따라서는 바람직할 수 있지만, 머리글과 바닥글이 모두 계속 보이기를 원하므로 수정해 보겠습니다.

### 고정 머리글, 고정 바닥글

처음에 그리드를 설치할 때 뷰포트의 전체 높이인 100vh의 높이를 제공했습니다. 그런 다음 머리글과 바닥글에 대한 행을 자동 높이로 할당하고 나머지 공간을 차지하기 위해 메인 높이를 1fr로 지정합니다. 불행하게도, 콘텐츠가 사용 가능한 공간을 초과할 경우 뷰포트 경계를 넘어 확장되어 바닥글이 아래로 밀리고 보이지 않게 됩니다.

여기서의 해결책은 사소한 것인데, `오버플로우: 오토`를 추가하면 우리의 `메인` 요소가 스크롤되고 `헤더`와 `풋더` 요소는 그대로 유지된다는 점이다.

```css
#app > main {
  grid-area: main;
  overflow: auto;
  padding: 15px 5px 10px 5px;
}
```

여기에 이 기능을 사용할 수 있는 업데이트된 데모가 있습니다.

### 조정 가능한 폭 주단면

우리는 우리의 `메인` 요소가 뷰포트의 전체 너비에 걸쳐 있거나 600px 공간에 집중되기를 원한다. 여러분은 `main`을 600px의 고정 너비로 만들 수 있다고 생각할지도 모릅니다. 어느 한쪽에 자동차 여백이 있다. 하지만 이것은 그리드에 관한 게시물이기 때문에, 달 그리드를 사용하자. (나중에 보듯이, 고정된 폭은 어쨌든 작동하지 않을 것이다.)

우리의 중심적인 600px 요소를 달성하기 위해, 우리는 실제로 `main` 요소를 그리드 컨테이너로 만들 것이다. 맞아, 격자 안에 있는 격자! 중첩 그리드는 완전히 합법적인 접근 방식이며, 하위 그리드가 브라우저 간에 공식적으로 지원될 경우 미래에는 더욱 쉬워질 것이다. 이 시나리오에서 우리는 1fr 600px 1fr의 세 개의 열 트랙을 가진 그리드를 만들 것이며, 간단히 말해서 600px의 중간에 나머지 공간은 측면에 균등하게 분할될 것이다.

```css
#app > main {
  display: grid;
  grid-template-rows: 1fr;
  grid-template-columns: 1fr 600px 1fr;
}
```

이제 콘텐츠를 그리드에 배치해 보겠습니다. 우리의 다른 모듈들은 모두 `섹션` 아이로 렌더링된다. 컨텐츠가 전체 그리드 너비에 걸쳐 있는 `.full` 클래스가 없는 한 기본적으로 컨텐츠가 중간 섹션을 차지한다고 가정합시다. 여기서는 명명된 영역을 사용하지 않고 대신 `[row-start] / [col-start] / [row-end] / [col-end]` 형식의 정확한 그리드 좌표를 지정합니다.

```css
#app > section {
  grid-area: 1 / 2 / 1 / 3;
}
 
#app > section.full {
  grid-area: 1 / 1 / 1 / 4
}
```

컬럼이 3개뿐이라는 점에서 콜엔드 값 4를 보면 놀랄 수도 있다. 그 이유는 열 및 행 값이 열 및 행 그리드 선이기 때문입니다. 세 개의 격자 기둥을 그리려면 네 개의 격자선이 필요합니다.

![image](https://i0.wp.com/css-tricks.com/wp-content/uploads/2020/08/grid-lines-example.jpg?resize=864%2C446&ssl=1)

우리의 <섹션>은 항상 첫 번째 줄에 있을 것이다. 기본적으로 이 구간은 풀 클래스가 없는 한 중간 기둥인 2번부터 3번 기둥까지이며, 이 경우 1번 기둥부터 4번 기둥까지 3번 기둥에 걸쳐 있다.

이 코드로 업데이트된 데모입니다. 코드 샌드박스 레이아웃에 따라 보기 좋을 수도 있지만 여전히 문제가 있습니다. 디스플레이를 600px 미만으로 축소하면 내용이 갑자기 잘립니다. 우리는 사실 600px 너비를 중간에 고정시키는 것을 원하지 않는다. 우리는 최대 600px의 너비를 원합니다. 그리드는 우리에게 단지 `minmax() 함수`라는 도구만을 가지고 있는 것으로 밝혀졌다. 최소 폭과 최대 너비를 지정하면 그리드가 해당 범위에 해당하는 값을 계산합니다. 그것이 우리가 콘텐트가 그리드에서 흘러나오는 것을 막는 방법입니다.

600px 값을 minmax(0, 600px)로 바꾸기만 하면 된다.

```css
main {
  display: grid;
  grid-template-rows: 1fr;
  grid-template-columns: 1fr minmax(0, 600px) 1fr;
}
```

완성된 코드에 대한 데모입니다.

### 한 가지 더 접근 방식: 기존의 고정 바닥글

앞서 우리는 바닥글이 화면 밖으로 밀려나는 것을 막기로 하고, 【메인】 요소의 overflow(오버플로) 속성을 auto(자동)로 설정했다.

하지만, 우리가 잠깐 언급했듯이, 그것은 바람직한 효과일 수 있습니다. 사실, 이것은 성가신 문제를 해결하고 내용이 매우 짧을 때 뷰포트의 하단 가장자리에 바닥글을 배치하는 고전적인 "sticky" 바닥글에 가깝습니다.

![image](https://i0.wp.com/css-tricks.com/wp-content/uploads/2020/08/Screen-Shot-2020-08-24-at-10.12.13-AM.png?resize=1024%2C606&ssl=1)

어떻게 하면 기존의 모든 작업을 유지하면서도 바닥글이 아래로 밀리게 할 수 있을까요? 영구적인 보기에서 바닥으로 고정되지 않고요.

현재 당사의 컨텐츠는 다음과 같은 HTML 구조를 가진 그리드에 있습니다.

```html
<div id="app">
  <header />
  <main>
    <section />
  </main>
  <footer />
</div>
```

…여기서 `main`은 `#app` 그리드 컨테이너 내에 중첩된 그리드 컨테이너로, `섹션` 태그에 들어가는 모듈 내용을 배치하기 위해 사용하는 1개의 행과 3개의 열이 포함되어 있습니다.

이것으로 바꾸자:

```html
<div id="app">
  <header />
  <main>
    <section />
    <footer />
  </main>
</div>
```

…그리고 `<메인> 요소 그리드에 `<메인>`을 통합한다. 먼저 상위 `#app` 그리드를 업데이트하여 그리드가 세 행이 아닌 두 행으로 구성되도록 하겠습니다.

```css
#app {
  /* same as before */
 
  grid-template-columns: 1fr;
  grid-template-rows: auto 1fr;
  grid-template-areas: 
    'header'
    'main';
}
```

머리말과 머리말, 그리고 다른 모든것들을 위해 두줄만요. 이제 `메인` 요소 내부의 그리드를 업데이트해 보겠습니다.

```css
#app > main {
  display: grid;
  grid-template-rows: 1fr auto;
  grid-template-columns: 1fr minmax(0, 600px) 1fr;
}
```

우리는 새로운 자동 크기 행을 도입했다. 이는 이제 콘텐츠에 대해 1fr 행이 생겼다는 것을 의미하며, 이 행은 바닥글에 대한 `섹션`과 `자동` 행을 포함한다.

이제 우리는 `#app`에 직접 있는 것이 아니라 `footer`를 이 그리드 안에 위치시킨다.

```css
#app > footer {
  grid-area: 2 / 1 / 3 / 4;
}
```

`<main>`은 스크롤이 있는 요소이고 이 요소에는 이제 바닥글이 있기 때문에 우리가 원하는 끈적끈적한 바닥글이 완성되었습니다! 이렇게 하면 `메인`에 뷰포트를 초과하는 콘텐츠가 있으면 전체가 스크롤되고 스크롤되는 콘텐츠는 우리가 예상한 대로 화면 맨 아래에 있는 바닥글을 포함합니다.

여기 업데이트된 데모입니다. 가능한 경우 바닥글은 화면 하단에 위치하며, 그렇지 않으면 필요에 따라 스크롤됩니다.

나는 여기 저기서 패딩의 사소한 조정과 같은 몇 가지 다른 작은 변화들을 만들었다; <main>의 패딩은 더 이상 엣지 있게 되지 않기 때문에 우리는 <main>의 좌우 패딩을 가질 수 없다.

또한 `섹션` 요소를 최종 편집하는 동안 마지막 순간에 조정했습니다. 즉, 우리가 폭 내용을 조정할 수 있도록 했습니다. 구체적으로 디스플레이는 플렉스로, 폭은 100%로, 직계열은 오버플로우: 오토로 설정했다. 저는 이 작업을 통해 `섹션` 요소의 콘텐츠가 그리드 열 경계를 초과하는 경우 그 자체 내에서 수평으로 스크롤할 수 있지만 수직 스크롤은 허용하지 않도록 했습니다.

이러한 변화가 없다면, 우리가 한 작업은 앞에서 다룬 고정 바닥글 접근 방식에 해당할 것입니다. 섹션(section)을 플렉스 컨테이너로 만들면 즉시 자식(내용이 포함된 <div)>가 사용 가능한 수직 공간을 모두 차지하게 된다. 물론 하위 div를 `overflow: auto`로 설정하면 스크롤이 가능합니다. 제가 왜 이 구간의 `오버플로우-x`를 `자동`으로, `오버플로우-y`를 `보이는` 것으로만 설정하지 않았는지 궁금하다면, 그건 불가능한 것으로 판명되었다.

### 이별의 생각

우리는 이 포스트에서 혁명적인 일을 한 적도 없고, CSS Grid 이전에는 이루지 못한 것도 없습니다. 우리의 고정 폭<메인> 컨테이너는 최대 폭 600px의 블록 요소와 좌우의 자동 여백이 될 수 있었다. 고정 바닥글은 `위치: 고정`으로 만들 수 있습니다(주요 내용이 겹치지 않도록 하기만 하면 됩니다). 그리고 물론, 전통적인 "스티커 바닥글"을 얻을 수 있는 다양한 방법들이 있다.

하지만 CSS Grid는 이 모든 것을 수행할 수 있는 단일의 균일한 레이아웃 메커니즘을 제공합니다. 그리고 함께 일하는 것은 정말 재미있습니다. 사실 바닥글을 고정식 바닥글에서 끈적임으로 옮긴다는 생각은 처음에 내가 계획한 것도 아니었다. 없는 게 좀 가벼운 것 같아서 막판에 집어 넣었어요. 기본적으로 격자선을 이리저리 움직이게 하는 것은 사소한 일이었습니다. 레고 블록을 조립하는 것과 다르지 않습니다. 다시 말하지만, 이러한 UI는 사소한 것이었습니다. 더 야심찬 디자인으로 그리드가 얼마나 밝게 빛날지 상상해 보세요!