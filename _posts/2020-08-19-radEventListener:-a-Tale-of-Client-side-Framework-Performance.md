---
layout: post
title: "RadEvent Listener: 클라이언트측 프레임워크 성능 이야기"
author: 'CSS Dev'
thumbnail: https://res.cloudinary.com/css-tricks/image/fetch/w_1200,q_auto,f_auto/https://css-tricks.com/wp-content/uploads/2020/08/react-hydration.devtools.png
tags: PERFORMANCE,REACT,STATE MANAGEMENT
---


리액션은 대중적이고, 꽤 많은 비판을 받을 만큼 인기가 있다. 그러나 React에 대한 이러한 비판은 완전히 부당한 것은 아닙니다. React and ReactDOM은 총 120KiB의 미니어처 자바스크립트이며, 이는 확실히 느린 시작 시간에 기여한다. React에서 클라이언트 측 렌더링이 전적으로 의존하면, 이는 왜곡됩니다. 서버에서 구성 요소를 렌더링하고 클라이언트에서 수분을 공급해도 구성 요소 수화 비용이 계산적으로 많이 들기 때문에 여전히 전환됩니다.

리액션은 복잡한 상태 관리가 필요한 애플리케이션에 대해서는 확실히 제 역할을 하지만, 제 전문 경험상 리액션은 대부분의 시나리오에 속하지 않습니다. 장치에 반응 속도가 느리고 속도가 빠를 때처럼 약간의 반응도 문제가 될 수 있는 경우, 이를 사용하는 것은 저가 하드웨어를 가진 사람을 효과적으로 배제하는 의도적인 선택이다.

리액트에게 원한을 품고 있는 것처럼 들린다면, 저는 리액트 컴포넌트화 모델을 정말 좋아한다는 것을 고백해야 합니다. 코드를 보다 쉽게 구성할 수 있습니다. JSX가 좋은 것 같아요. 서버 렌더링도 멋집니다. 요즘은 "네트워크를 통해 HTML을 전송"이라고 하지만요.

그러나 서버의 React 구성 요소(또는 원하는 대로 Preact)를 즐겁게 사용하더라도 클라이언트에서 언제 사용하는 것이 적합한지 파악하는 것은 어렵습니다. 다음은 사용자에게 가장 적합한 방식으로 이 과제를 해결하려고 노력한 React 성능에 대한 제 연구 결과입니다.

### 장면 설정

최근에 저는 byline이라는 RSS 피드 앱 사이드 프로젝트를 조금씩 하고 있습니다.fyi. 이 앱은 뒷면과 앞면 양쪽에 자바스크립트를 사용한다. 클라이언트측 프레임워크가 끔찍한 것은 아니라고 생각하지만, 일상 업무와 연구에서 접하게 되는 클라이언트측 프레임워크 구현에 대해 다음과 같은 두 가지를 자주 관찰했습니다.

- 프레임워크는 웹 플랫폼인 추상적인 것들에 대한 더 깊은 이해를 억제할 수 있는 잠재력을 가지고 있다. 프레임워크가 의존하는 하위 수준 API 중 적어도 일부를 알지 못하면 프레임워크에서 어떤 프로젝트가 이득을 얻고 어떤 프로젝트가 없는 것이 더 나은지 알 수 없습니다.
- 프레임워크가 항상 좋은 사용자 경험을 위한 명확한 경로를 제공하는 것은 아닙니다.

제 첫 번째 요지의 타당성을 논할 수는 있겠지만, 두 번째 요점은 반박하기가 점점 어려워지고 있습니다. 조금 전에 팀 캐들렉이 HTTPrchive에 대해 웹 프레임워크 성능에 대해 조사를 했고 React가 정확히 뛰어난 연주자가 아니라는 결론을 내렸던 것을 기억하실 수 있을 것입니다.

그래도 리액션에 대해 가장 잘 알고 있는 것을 서버에 사용하면서 클라이언트에 미치는 악영향을 완화할 수 있는지 알고 싶었습니다. 나에게 있어서, 내 코드를 구성하는 데 도움이 되는 프레임워크를 동시에 사용하고자 하는 것은 이치에 맞지만, 그 프레임워크가 사용자 경험에 미치는 부정적인 영향을 제한하기도 한다. 따라서 내 앱에 가장 적합한 접근 방식을 확인하기 위한 간단한 실험이 필요했습니다.

### 실험

마크업 제공에 대한 부담은 사용자의 기기가 아닌 웹 앱의 서버에 의해 가정되어야 한다고 생각하여 서버에서 사용하는 모든 구성 요소를 반드시 렌더링합니다. 그러나 전환 가능한 모바일 내비게이션이 작동하려면 RSS 피드 앱에 JavaScript가 필요했습니다.

![image](https://i2.wp.com/css-tricks.com/wp-content/uploads/2020/08/mobile-nav-states.png?resize=1024%2C893&ssl=1)

이 시나리오는 내가 단순 상태라고 부르는 것을 적절하게 설명한다. 내 경험에 의하면, 단순한 상태의 대표적인 예는 선형 A와 B의 상호작용이다. 우리는 무언가를 켜고 껐습니다. 명랑하지만 간단합니다.

불행히도, 저는 종종 단순한 상태를 관리하는 데 사용되는 상태 저장 리액션 구성 요소를 자주 보게 되는데, 이는 성능에 문제가 있는 절충안입니다. 비록 그것이 당장은 애매한 말일지라도, 계속 읽다 보면 알게 될 것이다. 그렇긴 하지만, 이것은 사소한 예시이지만, 카나리아이기도 합니다. 대부분의 개발자는 웹 사이트에서 단 한 가지에 대해 이러한 단순한 동작을 수행하기 위해 React에만 의존하지 않기를 바랍니다. 따라서 앞으로 보게 될 결과는 애플리케이션을 어떻게 설계하고, 런타임 성능과 관련하여 프레임워크 선택의 효과가 어떻게 확장될 수 있는지를 알려드리기 위한 것이라는 점을 이해하는 것이 중요합니다.

### 조건

내 RSS 피드 앱이 아직 개발 중입니다. 타사 코드가 포함되어 있지 않으므로 조용한 환경에서 쉽게 테스트할 수 있습니다. 내가 수행한 실험은 다음의 세 가지 구현에 걸쳐 모바일 탐색 토글 동작을 비교했다.

- 상태 저장 반응 구성 요소(`반응`).컴포넌트)가 서버에 렌더링되고 클라이언트에 수분이 공급됩니다.
- 상태 저장 Preact 구성 요소로, 클라이언트에서 서버 렌더링 및 수분 공급도 가능합니다.
- 수화물이 공급되지 않은 서버 렌더링 상태 비저장 Preact 구성 요소입니다. 대신 일반 올` 이벤트 수신기는 클라이언트에서 모바일 내비게이션 기능을 제공합니다.

이러한 각 시나리오는 4개의 서로 다른 환경에서 측정되었습니다.

- Chrome 83의 노키아 2 안드로이드 폰입니다.
- 2013년에 출시된 AASUS X550CC 노트북은 Chrome 83에서 Windows 10을 실행합니다.
- Safari 13의 구형 1세대 iPhone SE입니다.
- 새로운 2세대 iPhone SE도 Safari 13에 있습니다.

이러한 모바일 하드웨어의 범위는 Apple 측에서 다소 무겁더라도 광범위한 장치 기능에 걸쳐 성능을 보여 줄 것이라고 생각합니다.

### 무엇을 측정했는가?

각 환경의 구현에 대해 4가지를 측정하려고 했습니다.

- 시작 시간. React 및 Preact의 경우, 프레임워크 코드를 로드하는 데 걸리는 시간뿐만 아니라 구성 요소에 수분을 공급하는 데 걸리는 시간도 포함되었습니다. 이벤트 수신기 시나리오에서는 이벤트 수신기 코드 자체만 포함되었습니다.
- 수분 공급 시간. 반응 및 사전 조치 시나리오의 경우 시작 시간의 하위 집합입니다. MacOS의 Safari에서 원격 디버깅이 중단되는 문제 때문에 iOS 기기에서만 수화 시간을 측정할 수 없었습니다. 이벤트 청취자 구현에는 수화물 비용이 전혀 들지 않았다.
- 모바일 탐색 열기 시간. 이것은 오버헤드 프레임워크가 이벤트 핸들러를 추상화하는 데 얼마나 많은 것을 도입하는지, 그리고 이것이 프레임워크 없는 접근 방식과 어떻게 비교되는지 우리에게 통찰력을 준다.
- 모바일 내비게이션 종료 시간. 알고 보니, 이것은 메뉴를 여는 데 드는 비용보다 꽤 적은 금액이었다. 나는 궁극적으로 이 기사에 그 숫자들을 포함하지 않기로 결정했다.

이러한 동작의 측정에는 스크립팅 시간만 포함됩니다. 레이아웃, 페인트 및 합성 비용은 이러한 측정치에 추가되거나 외부에 추가될 수 있습니다. 이러한 활동이 주 스레드를 트리거하는 스크립트와 함께 경쟁한다는 점을 명심해야 한다.

### 절차

각 장치에서 세 가지 모바일 내비게이션 구현 각각을 테스트하기 위해 다음 절차를 따랐습니다.

- 나는 노키아 2에 대해 macOS에서 크롬에서 원격 디버깅을 사용했다. 아이폰의 경우 사파리의 원격 디버깅에 해당하는 것을 사용했습니다.
- 각 장치의 로컬 네트워크에서 실행 중인 RSS 피드 앱에 액세스하여 모바일 탐색 토글 코드를 실행할 수 있는 동일한 페이지로 이동했습니다. 이 때문에 네트워크 성능이 측정의 요인이 되지 않았습니다.
- CPU나 네트워크 조절이 적용되지 않은 상태에서 프로파일러에 녹음을 시작하고 페이지를 다시 로드했습니다.
- 페이지를 로드한 후 모바일 내비게이션을 열고 닫았습니다.
- 프로파일러를 중지하고 앞에 나열된 네 가지 동작에 각각 얼마나 많은 CPU 시간이 포함되었는지 기록했습니다.
- 나는 공연 시간표를 지웠다. 또한 Chrome에서 가비지 수집 버튼을 클릭하여 이전 세션 기록에서 내 앱의 코드로 연결된 메모리를 확보했습니다.

나는 각 장치마다 시나리오마다 이 절차를 10번 반복했다. 10회 반복하면 몇 개의 특이치를 볼 수 있을 만큼 충분한 데이터를 얻을 수 있을 것 같았지만, 결과를 검토하면서 결정하도록 하겠습니다. 검색 결과를 재생하지 않으려면 이 스프레드시트에서 결과를 보고 각 구현에 대한 모바일 탐색 코드뿐만 아니라 결론을 직접 작성할 수 있습니다.

### 결과

처음에는 이 정보를 그래프에 표시하고 싶었지만, 제가 측정하는 것이 복잡하기 때문에 시각화를 혼란스럽게 하지 않고 결과를 어떻게 제시해야 할지 확신이 서지 않았습니다. 따라서 각 테스트에서 발견한 결과의 범위를 효과적으로 보여주는 일련의 표에 최소, 최대, 중위수 및 평균 CPU 시간을 제시합니다.

노키아 2(Nokia 2)는 ARM Cortex-A7 프로세서를 탑재한 저가형 안드로이드 장치이다. 그것은 강국이 아니라 값싸고 쉽게 구할 수 있는 장치이다. 현재 전 세계 안드로이드 이용률은 40% 수준이며 안드로이드 기기 사양은 기기마다 크게 다르지만 보급형 안드로이드 기기는 드물지 않다. 이것은 빠른 네트워크 인프라에 대한 부와 근접성 중 하나로 인식되어야 하는 문제입니다.

시작 비용에 대한 수치가 어떻게 표시되는지 알아보겠습니다.

리액트를 구문 분석하고 컴파일하고 하나의 구성 요소에 수분을 공급하는데 평균 160ms가 넘는 시간이 소요된다고 생각합니다. 이 경우 시작 비용에는 모바일 내비게이션이 작동하는 데 필요한 스크립트를 브라우저가 평가하는 데 걸리는 시간이 포함됩니다. 리액트와 프리액트의 경우 수분 공급 시간도 포함되며, 두 경우 모두 시동 중에 가끔 경험하는 묘한 계곡 효과에 기여할 수 있다.

Pract는 Ract보다 시간이 73% 정도 적게 소요되어 훨씬 더 나은 요금으로, Pract가 10KiBans 압축에서 얼마나 작은지를 고려할 때 이치에 맞다. 그럼에도 불구하고 크롬의 프레임 예산은 60fps의 jank를 피하기 위해 약 10ms이다. Janky startup은 Janky 다른 것 만큼 나쁘고, First Input Delay를 계산할 때 요인이다. 하지만 모든 것을 고려해 볼 때, Preact는 상대적으로 좋은 성능을 발휘합니다.

addEventListener 구현에 대해서는 오버헤드가 없는 작은 스크립트의 구문 분석 및 컴파일 시간이 놀라울 정도로 매우 낮은 것으로 나타났다. 표본이 추출된 최대 시간인 12ms에서도, 당신은 거의 Janksburg Metrophan Area의 외곽 링에 있을 수 없습니다. 이제 수화물 비용만 살펴보겠습니다.

리액트의 경우, 여전히 이크스 피크 근처에 있습니다. 물론, 한 구성 요소에 대해 70ms의 중간 수화 시간은 그리 큰 문제가 되지 않지만, 한 페이지에 여러 구성 요소가 있을 때 수화 비용이 어떻게 확장되는지 생각해 보십시오. 내가 이 장치에서 테스트하는 반응 웹 사이트가 사용자 경험보다 더 인내력 시험처럼 느껴지는 것은 놀랄 일이 아니다.

프리액트의 수화 시간은 상당히 적은 편인데, 프레액트의 수화법 문서에는 "이벤트 청취자를 붙이고 구성 요소 트리를 세우면서 가장 큰 차이를 건너뛴다"는 내용이 담겨 있어 일리가 있다. 추가 이벤트 청취자 시나리오의 수화 시간은 보고되지 않습니다. 왜냐하면 수화물은 VDOM 프레임워크 밖의 것이 아니기 때문입니다. 다음으로, 모바일 내비게이션 열기까지 걸리는 시간을 살펴보겠습니다.

Retact는 이벤트 수신기 콜백을 실행하는 데 필요한 CPU 시간의 거의 7배를 직접 등록할 수 있는 이벤트 수신기보다 명령하기 때문에 이 수치가 좀 놀랍습니다. 리액트의 상태 관리 논리는 오버헤드가 필요하지만 단순하고 선형적인 상호 작용에 그만한 가치가 있는지 의심해야 하기 때문에 이는 타당하다.

반면, Preact는 이벤트 수신기 콜백을 실행하는 데 CPU 시간이 두 배만 걸릴 정도로 이벤트 수신기 오버헤드를 제한합니다.

모바일 내비게이션을 닫는 데 필요한 CPU 시간은 React의 평균 근사 시간인 16.5 ms에서 상당히 낮았고, Preact와 베어 이벤트 수신기는 각각 약 11 ms와 6 ms였다. 모바일 내비게이션 닫는 데 필요한 전체 표를 올리고 싶지만, 아직 검사해야 할 부분이 많이 남아 있어요. 그리고 아까 말씀드린 스프레드시트에서 직접 확인하실 수 있습니다.

iOS 결과로 넘어가기 전에 제가 다루고자 하는 한 가지 잠재적인 걸림돌은 원격 장치에서 세션을 기록할 때 Chrome DevTools에서 JavaScript 샘플이 비활성화되는 영향입니다. 초기 결과를 컴파일한 후, 전체 콜 스택 캡처에 대한 오버헤드가 결과를 왜곡하는 것이 아닌지 궁금하여 리액트 시나리오 샘플이 비활성화된 것을 다시 테스트했다. 밝혀진 바와 같이, 이 설정은 결과에 큰 영향을 미치지 않았습니다.

또한 호출 스택이 잘려서 구성 요소 수화 시간을 측정할 수 없었습니다. 샘플이 비활성화된 경우와 활성화된 경우 평균 시동 비용은 각각 160.74ms와 162.73ms였다. 각각의 중앙값은 157.81 ms와 147.76 ms였다. 나는 이것을 "잡음 속에" 있는 것으로 간주할 것이다.

오리지널 아이폰 SE는 훌륭한 폰이다. 그것의 나이에도 불구하고, 그것은 더 편안한 신체 크기 때문에 여전히 헌신적인 소유권을 누리고 있다. 애플 A9 프로세서와 함께 출시되었으며, 여전히 강력한 경쟁 제품 중 하나입니다. 시작 시간에 어땠는지 봅시다.

이는 노키아 2보다 크게 개선된 것으로, 저가형 안드로이드 기기와 상당한 마일리지를 가진 구형 애플 기기 사이의 차이를 잘 보여준다.

반응 성능은 여전히 좋지 않지만, Pract는 Chrome의 일반적인 프레임 예산 범위 내에서 제공합니다. 물론 듣는 사람만 해도 엄청나게 빨라 다른 활동을 위한 기본 예산에 많은 여유가 있다.

불행히도, 저는 Safari의 DevTools에서 호출 스택을 통과할 때마다 원격 디버깅 세션이 중단되기 때문에 iPhone에서 수화 시간을 측정할 수 없었습니다. 수화 시간이 전체 시동 비용의 부분집합이었다는 점을 고려하면, 노키아 2의 시험 결과가 어떤 지표가 될 경우 시동 시간의 절반 이상을 차지할 것으로 예상할 수 있다.

리액션은 여기서 괜찮지만, 프레액트는 이벤트 청취자들을 좀 더 효율적으로 다루는 것 같다. 이 오래된 아이폰에서도 베어이벤트 청취자들이 빠르게 번개를 치고 있다.

2020년 중반, 저는 새로운 아이폰 SE를 선택했습니다. 실제 크기는 아이폰8과 비슷하지만 프로세서는 아이폰11에 사용된 애플A13과 같다. 비교적 낮은 $400 USD 소매 가격 때문에 매우 빠릅니다. 그렇게 까다로운 프로세서를 감안하면, 어떻게 처리될까요?

어느 시점에서는 단일 프레임워크를 로드하고 하나의 구성 요소에 수분을 공급해야 하는 상대적으로 적은 워크로드의 경우 수익이 감소한다고 생각합니다. 2세대 iPhone SE는 1세대 모델보다 속도가 조금 빠른 경우도 있지만, 그렇게 쉽지는 않습니다. 저는 이 전화기가 이전 제품보다 더 크고 지속적인 작업 부하를 더 잘 처리할 것이라고 생각합니다.

조금 더 나은 반응 성능을 제공하지만 그 외에는 별 반응이 없습니다. 이상하게도 Preact는 1세대 제품보다 이 장치에서 모바일 탐색을 여는 데 평균적으로 더 오래 걸리는 것처럼 보이지만, 나는 그것을 상대적으로 작은 데이터 세트를 왜곡하는 특이치 탓으로 돌린다. 저는 1세대 아이폰 SE가 이것에 근거해서 더 빠른 장치라고 생각하지 않을 것입니다.

물론, 제가 가장 기대했던 결과는 다음과 같습니다. 2013년에 출시된 Windows 10과 Ivy Bridge i5가 탑재된 ASUS 노트북은 어떻게 이러한 기능을 처리할 수 있을까요?

이 장치가 7년 된 것이라고 생각하면 수치가 나쁘지 않습니다. Ivy Bridge i5는 그 당시 훌륭한 프로세서였으며, 모바일 기기 프로세서가 수동적으로 냉각되는 것이 아니라 능동적으로 냉각된다는 사실과 결합하면 모바일 기기만큼 열 조절 시나리오에 자주 부딪히지 않을 것입니다.

Pract는 여기서 잘 작동하며 Chrome의 프레임 예산 범위 내에서 유지되며 React보다 거의 3배 더 빠릅니다. 시작 시, 심지어는 Preact에서도 페이지에서 열 개의 구성 요소에 수분을 공급한다면 상황은 상당히 달라질 수 있습니다.

이와 같은 격리된 상호 작용에 대해서는 하이엔드 모바일 장치와 유사한 성능을 확인할 수 있습니다. 이렇게 오래된 노트북이 여전히 합리적으로 잘 유지된다는 것은 고무적인 일이다. 그렇긴 하지만, 이 노트북의 선풍기는 웹을 탐색할 때 자주 회전하기 때문에, 액티브 쿨링이 이 장치의 장점을 살릴 수 있을 것입니다. 이 장치의 i5가 수동 냉각되었다면 성능이 떨어질 수 있습니다.

### 승리를 위한 얕은 통화 스택

프레임워크를 전체적으로 회피하는 솔루션보다 Retact와 Pract를 시작하는 데 시간이 더 걸리는 이유는 미스테리가 아닙니다. 작업이 적을수록 처리 시간도 줄어듭니다.

저는 시작 시간이 중요하다고 생각하지만, 더 나은 개발자의 경험을 위해 어느 정도의 속도를 바꾸는 것은 불가피할 것입니다. 비록 저는 우리가 너무 자주 사용자 경험보다 개발자 경험으로 너무 많이 거래하는 경향이 있다고 강하게 주장합니다.

용들은 또한 우리가 틀에 짐을 싣고 난 후에 하는 일에 놓여 있습니다. 고객측 수분 공급은 제가 생각하기에 너무 자주 남용되는 것이고, 때때로 완전히 불필요할 수도 있습니다. React의 구성 요소에 수분을 공급할 때마다 다음과 같이 주 나사산을 던집니다.

![image](https://i2.wp.com/css-tricks.com/wp-content/uploads/2020/08/react-hydrate.png?resize=354%2C288&ssl=1)

노키아 2에서 모바일 내비게이션 구성 요소에 수분을 공급하기 위해 측정한 최소 시간은 약 67ms였습니다. 아래에 수화물 콜 스택이 있는 In Preact는 약 20ms의 시간이 소요됩니다.

![image](https://i0.wp.com/css-tricks.com/wp-content/uploads/2020/08/preact-hydrate.png?resize=422%2C305&ssl=1)

이 두 개의 콜 스택은 동일한 척도가 아니지만, Praact의 수화 논리는 단순합니다. 아마도 Praact의 설명서에서 언급했듯이 "대부분의 차이는 건너뛰기 때문"일 것입니다. 여기선 좀 덜 진행됐죠. 프레임 대신 이벤트 리스너 추가를 통해 메탈에 가까워지면 더욱 빨라질 수 있다.

![image](https://i0.wp.com/css-tricks.com/wp-content/uploads/2020/08/pasted-image-0.png?resize=425%2C152&ssl=1)

모든 상황이 이 방식을 요구하는 것은 아니지만 툴이 이벤트 수신자 추가, 쿼리 선택기, 클래스 목록, 속성 설정/ 속성 가져오기 등일 때 어떤 작업을 수행할 수 있는지 알면 놀랄 것이다.

이러한 방법 및 이와 유사한 방법은 프레임워크 자체가 의존하는 것입니다. 이 트릭은 프레임워크가 제공하는 기능 이외에 어떤 기능을 안전하게 제공할 수 있는지 평가하고, 프레임워크가 타당할 때 프레임워크에 의존하는 것입니다.

![image](https://i2.wp.com/css-tricks.com/wp-content/uploads/2020/08/pasted-image-0-1.png?resize=386%2C339&ssl=1)

클라이언트에서 API 데이터를 요청하고 해당 상황에서 UI의 복잡한 상태를 관리하기 위한 콜 스택이었다면, 이 비용이 더 적절할 것입니다. 하지만, 그렇지 않아요. 사용자가 버튼을 누르면 화면에 네비게이션이 나타납니다. 그것은 마치 삽이 그 일에 더 적합할 때 불도저를 사용하는 것과 같다.

적어도 중간 지점을 타격하십시오.

![image](https://i2.wp.com/css-tricks.com/wp-content/uploads/2020/08/pasted-image-0-2.png?resize=661%2C322&ssl=1)

Preact는 React와 동일한 작업을 수행하는 데 약 3분의 1의 시간이 소요되지만, 예산 장치에서는 기본 예산을 초과하는 경우가 많습니다. 즉, 레이아웃과 도색 작업이 긴 작업 영역을 입력하지 않고는 끝낼 시간이 부족할 수 있기 때문에 일부 장치에서 탐색을 여는 것은 느리게 애니메이션된다는 의미입니다.

![image](https://i1.wp.com/css-tricks.com/wp-content/uploads/2020/08/pasted-image-0-3.png?resize=564%2C84&ssl=1)

이 경우, 이벤트 청취자가 내게 필요했던 것입니다. 리액트보다 예산 장치에서 작업을 7배 더 빨리 처리할 수 있습니다.

### 결론

이건 리액트 히트곡이 아니라 우리가 어떻게 일을 하는지 생각해 달라는 탄원이에요. 복잡한 상호 작용이 많은 애플리케이션에서도 작업에 적합한 도구를 평가하면 이러한 성능 저하를 방지할 수 있습니다. React에 공평하게 말하자면, 이러한 함정은 많은 VDOM 프레임워크에 존재할 가능성이 높다. 왜냐하면 함정의 특성은 우리를 위해 모든 종류의 것을 관리하는 데 필요한 오버헤드를 더하기 때문이다.

Reactor Preact가 아닌 구성 요소화를 활용하고자 하는 작업을 수행 중인 경우에도 처음부터 모든 작업을 서버에 유지하는 것이 좋습니다. 이 접근 방식은 고객에게 기능을 확장하는 것이 적절한지, 적절한 시기 및 방법을 결정할 수 있음을 의미합니다.

내 RSS 피드 앱의 경우, 앱의 해당 페이지에 대한 진입점에 경량 이벤트 수신기 코드를 넣고, 자산 매니페스트를 사용하여 각 페이지가 작동하는 데 필요한 최소한의 스크립트를 배치하여 관리할 수 있습니다.

이제 React가 제공하는 것이 진정으로 필요한 앱이 있다고 가정해 보겠습니다. 많은 주와 복잡한 상호작용을 합니다. 여기 여러분이 좀 더 빨리 일을 진행시키기 위해 할 수 있는 몇 가지 것들이 있습니다.

- 상태 저장 구성 요소, 즉 `응답하라`를 확장하는 구성 요소를 모두 확인하십시오.Component `—그리고 상태 비저장 구성 요소로 리팩터링할 수 있는지 확인합니다. 구성 요소가 수명 주기 방법 또는 상태를 사용하지 않는 경우 상태 비저장 상태로 다시 지정할 수 있습니다.
- 그런 다음 가능하면 상태 비저장 구성 요소에 대한 JavaScript를 클라이언트에 보내지 말고 수분을 공급하지 마십시오. 구성 요소가 상태 비저장인 경우 서버에서만 렌더링하십시오. 서버 렌더링에는 자체적인 성능 저하가 있으므로 가능한 경우 구성 요소를 미리 렌더링하여 서버 응답 시간을 최소화합니다.
- 간단한 상호 작용성을 가진 상태 저장 구성 요소를 사용하는 경우 해당 구성 요소를 미리 렌더링/서버 렌더링하고 프레임워크 독립적인 이벤트 수신기로 상호 작용을 바꿉니다. 이렇게 하면 수분이 완전히 차단되고 사용자 상호 작용이 프레임워크의 상태 관리 논리를 거치지 않아도 됩니다.
- 클라이언트에서 상태 저장 구성 요소에 수분을 공급해야 하는 경우 페이지 맨 위에 있지 않은 구성 요소에 천천히 수분을 공급하십시오. 콜백을 트리거하는 교차로 관찰자는 이 작업에 매우 적합하며 페이지의 중요한 구성 요소에 더 많은 주 스레드의 시간을 제공합니다.
- 슬러시 수분이 많은 부품의 경우, `Request Idle Callback`을 사용하여 주 나사산 유휴 시간 동안 수화를 예약할 수 있는지 여부를 평가합니다.
- 가능한 경우 반응에서 사전 작용으로 전환하는 것을 고려합니다. 고객에게 반응하는 속도보다 얼마나 빨리 실행되는지 고려할 때, 이것이 가능한지 팀원들과 논의해 볼 가치가 있습니다. 최신 버전의 프랙트는 거의 1:1로 대부분의 것에 대한 리액트와 호환되며, 프랙트/컴퍼니는 이러한 전환을 완화시키는 데 큰 역할을 한다. 프레액트는 공연의 만병통치약은 아니지만, 당신이 필요한 곳에 더 가까이 다가갈 수 있게 해줍니다.
- 장치 메모리가 낮은 사용자에게 당신의 경험을 적응시키는 것을 고려해보세요. 네비게이터.device Memory(크롬 및 파생 브라우저에서 사용 가능)를 사용하면 메모리가 적은 장치에서 사용자의 사용자 환경을 변경할 수 있습니다. 만약 누군가가 그러한 장치를 가지고 있다면, 그것의 프로세서 또한 그렇게 빠르지 않을 가능성이 있다.

여러분이 이 정보를 가지고 무엇을 하기로 결정하든, 제 주장의 핵심은 이것입니다. 반응 또는 VDOM 라이브러리를 사용할 경우, 그 정보가 여러 장치에 미치는 영향을 조사하는 데 시간을 투자해야 한다는 것입니다. 저렴한 Android 기기를 구입하여 앱의 사용감을 확인하십시오. 이러한 경험을 하이엔드 장치와 비교해 보십시오.

무엇보다도, 앱에서 고급 기기를 구입할 수 없는 청중의 일부를 효과적으로 제외하는 경우에는 "최고의 사례"를 따르지 마십시오. 모든 것이 더 빠를 수 있도록 계속 추진하세요. 만약 우리의 일상적인 일이 어떤 징조라면, 이것은 앞으로 한동안 여러분을 바쁘게 할 노력이지만, 괜찮습니다. 웹을 더 빠르게 만들면 더 많은 장소에서 웹에 더 쉽게 접근할 수 있습니다. 웹에 더 쉽게 액세스할 수 있도록 하면 웹이 더 포괄적입니다. 그것이 우리 모두가 최선을 다해서 해야 할 정말 좋은 일입니다.

저는 에릭 베일리의 편집 피드백에 대해 감사를 표하고 싶습니다. 이 작품을 출판하려는 의지에 대해 CSS-Tricks의 직원들뿐만 아니라.