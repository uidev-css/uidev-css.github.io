---
layout: post
title: "상호 작용 미디어 특징 및 그 잠재력(잘못된 가정에 대한)"
author: 'CSS Dev'
thumbnail: https://res.cloudinary.com/css-tricks/image/fetch/w_1200,q_auto,f_auto/https://css-tricks.com/wp-content/uploads/2019/09/pointer-click.png
tags: FEATURE DETECTION,MEDIA QUERIES,POINTER-EVENTS,TOUCH,TOUCH EVENTS
---


이 문서는 2015년 dev.opera에 처음 게시된 기사를 업데이트하고 크게 확장한 버전입니다. 이 기사는 미디어 쿼리 레벨 4의 2015년 3월 24일 편집자 초안을 참조했으며, `아무러한:없음`이 브라우저에 의해 실제로 평가되는 방식에 대해 상당히 큰 오해를 하고 있다.

이후 사양이 업데이트되었으며(원문 발행 후 제출했던 설명 및 사례 포함), 이 업데이트 버전은 원본의 잘못된 정보를 제거하고 가장 최근의 작업 초안과 일치하는 설명을 제공합니다. 또한 JavaScript 터치/입력 감지와 관련된 추가 측면을 다룹니다.

미디어 쿼리 레벨 4 인터랙션 미디어 기능(포인트, 후버, 임의, 임의)은 특정 사용자 특성에 따라 사이트에서 다양한 스타일과 기능(윈도우.매치 미디어)을 구현할 수 있도록 하기 위한 것이다.s 입력 장치

사양이 아직 초안 단계에 있지만, 상호 작용 미디어 기능은 일반적으로 잘 지원되지만, 현재까지 다양한 브라우저 구현에서 여전히 몇 가지 문제와 불일치가 있다. 최근의 `포인터`/`허버`/`임의`/`임의` 테스트 결과를 참조하고 관련 브라우저 버그를 참조한다.

상호 작용 미디어 기능에 대해 인용되는 일반적인 사용 사례는 "사용자가 터치스크린 기기를 가지고 있는지 마우스/스타일러스를 사용하고 있는지에 따라 컨트롤을 더 크게/ 작게 만든다"와 "사용자가 호버 기반 상호 작용을 허용하는 입력을 가지고 있는 경우에만 CSS 드롭다운 메뉴를 사용한다"이다.

```css
@media (pointer: fine) {
  /* using a mouse or stylus - ok to use small buttons/controls */
}
@media (pointer: coarse) {
  /* using touch - make buttons and other "touch targets" bigger */
}
@media (hover: hover) {
  /* ok to use :hover-based menus */
}
@media (hover: none) {
  /* don't use :hover-based menus */
}
```

또한 개발자들이 표준 기반 "터치 감지"를 달성하기 위한 방법으로 이러한 새로운 상호 작용 미디어 기능을 사용하는 예도 있는데, 이는 장치가 거친 포인터를 가지고 있는 것으로 식별될 때 종종 터치 이벤트를 듣기 위한 것이다.

```js
if (window.matchMedia && window.matchMedia("(pointer:coarse)").matches) {
  /* if the pointer is coarse, listen to touch events */
  target.addEventListener("touchstart", ...);
  // ...
} else {
  /* otherwise, listen to mouse and keyboard events */
  // ...
}
```

그러나 이러한 접근 방식은 약간 순진하며, 이러한 상호 작용 미디어 쿼리가 우리에게 무엇을 알려주도록 설계되었는지에 대한 오해에서 비롯된다.

### 주요 입력 사항은 무엇입니까?

포인터나 후버의 한계 중 하나는 브라우저가 기본 포인터 입력으로 간주하는 특성만 노출한다는 점이다. 브라우저의 생각 및 사용자가 실제로 기본 입력으로 사용하고 있는 것은, 특히 기기 간의 선과 그들이 지원하는 입력 유형이 점점 더 모호해지고 있기 때문에 다를 수 있습니다.

![image](https://i1.wp.com/css-tricks.com/wp-content/uploads/2020/09/pTiq0qcg-2.jpeg?resize=2500%2C1794&ssl=1)

게이트 바로 밖에서, 인터랙션 미디어는 포인터 입력(마우스, 스타일러스, 터치스크린)만 포함한다는 점에 주목할 필요가 있다. 사용자의 기본 입력이 스위치 제어와 같은 키보드 또는 키보드와 유사한 인터페이스인지 여부를 탐지하는 어떠한 방법도 제공하지 않습니다. 이론적으로 키보드 사용자의 경우 브라우저가 포인터: none을 보고할 수 있어 사용자의 기본 입력이 포인터가 아님을 알 수 있다. 그러나 실제로는 어떤 브라우저도 사용자가 실제로 키보드 사용자임을 지정할 수 있는 방법을 제공하지 않는다. 따라서 어떤 상호 작용 미디어 기능 쿼리가 반환되는지에 관계없이 사이트나 앱이 키보드 사용자에게도 작동하는지 확인해야 합니다.

전통적으로 전화나 태블릿의 기본 입력은 터치스크린이라고 할 수 있다. 그러나 이러한 장치에서도 사용자는 페어링된 블루투스 마우스(안드로이드에서 수년 동안 사용할 수 있는 기능, 현재 iPadOS에서 지원되며 iOS에 확실히 착륙할 수 있음)와 같은 추가 입력을 기본 입력으로 사용할 수 있다.

이 경우 기기에는 명목상 포인터: 거칠기, 후버: 없음이 있지만 사용자는 실제로 홀버가 가능한 미세한 포인터 장치를 사용할 수 있다. 마찬가지로 사용자가 애플 펜슬과 같은 스타일러스를 가지고 있으면 기본 입력이 터치스크린으로 보고될 수 있지만 포인터: 거칠기가 아니라 미세한 포인터 정확도를 제공할 수 있는 입력을 갖게 되었다.

이러한 특정 시나리오에서 사이트가 하는 모든 작업이 버튼과 컨트롤을 더 크게 만들고 호버 기반 상호 작용을 피하는 것이라면 사용자에게는 큰 문제가 되지 않을 것이다. 미세하고 호버 기반 마우스 또는 미세하지만 호버 기능이 없는 스타일러스를 사용함에도 불구하고 그들은 거칠고 호버 기능이 없는 거친 스타일을 목표로 하는 스타일링과 기능을 얻을 것이다.e 터치스크린

사이트가 터치 이벤트만 듣는 것과 같이 좀 더 급격한 변화에 대해 `포인터: 거칠다`의 단서를 사용하는 경우 사용자에게 문제가 될 수 있다. 경험을 완전히 깨트릴 수 있는 잘못된 가정에 대한 단원을 참조하라.

그러나 Microsoft의 Surface와 같은 터치 스크린이 있는 "일반" 데스크톱 또는 랩톱의 반대 의견을 생각해 보십시오. 대부분의 경우 기본 입력은 트랙패드/마우스(`포인터:fine` 및 `hover:hover`)이지만 사용자는 포인터 정확도가 낮고 호버 기능이 없는 터치스크린을 사용할 수 있습니다. 그런 다음 스타일링과 기능이 트랙패드/마우스 특성에 의존하도록 특별히 맞춤화된 경우, 사용자는 거칠고 호버 기능이 없는 터치스크린을 사용하는 것이 문제가 있거나 불가능하다고 생각할 수 있다.

이 문제에 대한 비슷한 의견은 "좋은 점"을 참조하십시오.

원래 포인터와 후버의 문제는 다중 입력 시나리오를 고려하지 않고 브라우저에 의존해 단일 기본 입력을 올바르게 선택할 수 있다는 점이다. 여기서 `어느 포인터든`과 `어느 호버든`이 통한다.

### 모든 입력의 기능 테스트

기본 포인터 입력에만 초점을 맞추는 대신 임의 포인터와 임의 홀버는 사용 가능한 모든 포인터 입력의 결합된 기능을 보고한다.

서로 다른 (포인트 기반) 입력이 서로 다른 특성을 가질 수 있는 다중 입력 시나리오를 지원하기 위해, 서로 다른 입력 장치(포인터와 호버에 비해)가 서로 다른 경우, "임의 포인터"(그리고 이론적으로 "임의"이지만 나중에 볼 때 이 측면은 쓸모가 없다)에 대한 두 개 이상의 값이 일치할 수 있다.ch는 기본 포인터 입력)의 기능만 참조합니다. 현재 구현에서 이러한 미디어 기능은 일반적으로 다음과 같이 평가합니다.

![image](https://i2.wp.com/css-tricks.com/wp-content/uploads/2020/09/KGxcmwy4.png?resize=1620%2C1440&ssl=1)

더 크거나 더 작은 입력을 제공하거나 기본 포인터 입력의 특성만을 기반으로 호버 기반 기능을 활성화하려는 결정을 기반으로 하지 않고 상호 작용 미디어 기능에 대한 원래 사용 사례로 돌아가면 사용 가능한 포인터 입력의 특성에 따라 결정을 내릴 수 있다. 대략 번역하면 "1차 입력에 포인터: 거칠게"가 있으면 모든 컨트롤을 크게 한다거나 1차 입력에 홀버: 호버(hover: hover)가 있으면 CSS 메뉴만 제공한다"는 식의 미디어 질의를 할 수 있다. 사용자가 사용할 수 있는 포인터 입력은 호버 기능이 있습니다."

```css
@media (any-pointer: coarse) {
  /* at least one of the pointer inputs
    is coarse, best to make buttons and 
    other "touch targets" bigger (using 
    the query "defensively" to target 
    the least capable input) */
}
@media (any-hover: hover) {
  /* at least one of the inputs is 
     hover-capable, so it's at least 
     possible for users to trigger
     hover-based menus */
}
```

현재 임의 포인터와 임의 후버(사용자가 사용할 수 있는 모든 포인팅 장치의 기능 조합)가 정의되어 있기 때문에 임의 포인터: 없음은 사용할 수 없는 경우에만 참으로 평가되고, 더 중요한 것은 어떤 포인터 입력도 존재하지 않는 경우에만 참이 된다. 맴돌 수 있는 특히 후자의 경우 `임의: 없음` 쿼리를 사용하여 하나 이상의 포인터 입력만 호버링할 수 있는지 여부를 결정할 수 없습니다. 이 미디어 기능 쿼리를 사용하여 모든 입력을 호버링할 수 없는지 여부만 확인할 수 있습니다. 이 쿼리는 호버링 가능 여부만 확인할 수 있습니다. 임의: 호버(hover)는 잘못된 것으로 평가됩니다. 이로 인해 `임의: 없음` 쿼리는 본질적으로 중복된다.

만약 `아무 포인터: 거칠다`가 사실이라면, 터치스크린일 가능성이 높으며, 일반적으로 이러한 입력은 호버 기능이 없지만, 개념적으로 우리는 여기서 추측을 하고 있고, 호버 기능이 있는 거친 포인터가 있는 순간, 그 논리는 무너질 수 있다. (그리고 우리가 터치스크린을 볼 수 있다.호버로 그린, 삼성 갤럭시 노트나 마이크로소프트의 서피스 같은 일부 장치에는 디지타이저/화면에 닿지 않는 경우에도 호버 기능이 있는 스타일러스가 있으므로 앞으로 "호버 터치" 감지 방식은 문제 밖이 아닐 수 있습니다.

### 더 정확한 추측을 위한 쿼리 결합

`임의의 포인터`와 `임의의 호버`가 제공하는 정보는 물론 `포인터`와 `허버`와 결합될 수 있으며, 브라우저가 일차 입력이 무엇을 할 수 있는지를 결정하는 것은 다소 미묘한 평가를 할 수 있다.

```css
@media (pointer: coarse) and (any-pointer: fine) {
  /* the primary input is a touchscreen, but
     there is also a fine input (a mouse or 
     perhaps stylus) present. Make the design
     touch-first, mouse/stylus users can
     still use this just fine (though it may 
     feel a big clunky for them?) */
}
@media (pointer: fine) and (any-pointer: coarse) {
  /* the primary input is a mouse/stylus,
     but there is also a touchscreen 
     present. May be safest to make 
     controls big, just in case users do 
     actually use the touchscreen? */
}
@media (hover: none) and (any-hover: hover) {
  /* the primary input can't hover, but
     the user has at least one other
     input available that would let them
     hover. Do you trust that the primary
     input is in fact what the user is 
     more likely to use, and omit hover-
     based interactions? Or treat hover 
     as something optional — can be 
     used (e.g. to provide shortcuts) to 
     users that do use the mouse, but 
     don't rely on it? */
}
```

### 동적 변경

브라우저는 사용자 환경의 변화에 대응하여 미디어 쿼리를 다시 평가해야 합니다. 포인터, 홀버, 애니 포인터, 애니 홀버 인터랙션 미디어 기능이 어느 지점에서나 역동적으로 변할 수 있다는 의미다. 예를 들어 모바일/태블릿 장치에서 블루투스 마우스를 추가/제거하면 `임의 포인터` / `임의`에 변화가 발생합니다. 보다 극단적인 예로 Surface 태블릿을 들 수 있습니다. 여기서 장치의 "type cover"(키보드와 트랙패드가 포함된)를 추가/제거하면 기본 입력 자체가 변경됩니다(커버가 있을 때 `점퍼: 미세` / `허버: 호버`에서 `점퍼: 거친` / `허버: 없음`으로 변경됨).

![image](https://i1.wp.com/css-tricks.com/wp-content/uploads/2020/09/nMVZ9H7A.png?resize=1000%2C1332&ssl=1)

이러한 미디어 기능을 기반으로 사이트의 레이아웃/기능을 수정할 경우 페이지/사이트를 처음 로드할 때뿐만 아니라 입력이 변경될 때마다 사이트가 갑자기 "사용자 발밑"으로 변경될 수 있습니다.

### 미디어 쿼리가 충분하지 않을 수 있음 - 스크립팅 시 롤 온

상호 작용 미디어 기능의 근본적인 단점은 현재 사용 중인 입력 장치에 대해 반드시 아무 것도 알려주지 않는다는 것입니다. 이를 위해, 우리는 What Input?와 같은 특정 JavaScript 이벤트를 추적하는 솔루션에 대해 더 자세히 알아봐야 할 수도 있습니다. 그러나 이러한 솔루션은 이미 사이트와 상호 작용하기 시작한 후에만 사용자의 입력 정보에 대한 정보를 제공할 수 있습니다. 이 경우 레이아웃이나 기능을 크게 변경하기에는 너무 늦을 수 있습니다.

이러한 JavaScript 기반 접근 방식도 잘못된 결과를 쉽게 초래할 수 있습니다. 특히 모바일/태블릿 플랫폼이나 보조 기술이 관련된 상황에서 "가짜" 이벤트가 생성되는 경우가 흔합니다. 예를 들어 키보드와 화면 판독기를 사용하여 데스크톱에서 컨트롤을 활성화할 때 발생하는 일련의 이벤트를 살펴보면 가짜 마우스 이벤트가 트리거되는 것을 알 수 있다. 보조 기술은 역사적으로 많은 웹 콘텐츠가 마우스 사용자에게 작동하도록 코딩되어 있지만 키보드 사용자에게는 반드시 해당되지 않기 때문에 이러한 상호 작용을 일부 기능에 필요한 시뮬레이션으로 만들기 때문이다.

마찬가지로 iOS의 설정 → 내게 필요한 옵션 → 키보드에서 "전체 키보드 지원"을 활성화하면 데스크톱에서처럼 외부 블루투스 키보드를 사용하여 웹 콘텐츠를 탐색할 수 있습니다. 그러나 모바일/태블릿 장치와 페어링된 키보드/마우스의 이벤트 시퀀스를 살펴보면 포인터 이벤트, 터치 이벤트 및 폴백 마우스 이벤트가 생성됩니다. 이는 터치스크린 상호 작용과 동일한 시퀀스입니다.

![image](https://i1.wp.com/css-tricks.com/wp-content/uploads/2020/09/UKz9iEYw.png?resize=1500%2C1334&ssl=1)

이러한 모든 상황에서 What Input?과 같은 스크립트는 자체 오류 없이 현재 입력 유형을 잘못 식별합니다.

### 경험을 완전히 깨트릴 수 있는 잘못된 가정

다중 입력 장치의 복잡성을 설명했으므로, 우리가 흔히 사용하는 "터치 감지"의 형태와 같이 특정 유형의 이벤트만 듣는 접근 방식이 빠르게 무너지는 것은 지금쯤 분명해야 한다.

```js
if (window.matchMedia && window.matchMedia("(pointer: coarse)").matches) {
  /* if the pointer is coarse, listen to touch events */
  target.addEventListener("touchstart", ...);
  // ...
} else {
  /* otherwise, listen to mouse and keyboard events */
  target.addEventListener("click", ...);
  // ...
}
```

모바일 또는 외부 마우스가 있는 태블릿과 같은 추가 입력이 있는 "터치" 장치의 경우, 이 코드는 기본적으로 사용자가 터치 스크린 이외의 다른 것을 사용할 수 없도록 할 것이다. 주로 마우스 구동식이지만 Microsoft Surface와 같은 보조 터치스크린 인터페이스가 있는 장치에서는 사용자가 터치스크린을 사용할 수 없습니다.

이것을 "터치 또는 마우스/키보드"라고 생각하지 말고 "터치 및 마우스/키보드"의 경우인 경우가 많다는 것을 깨달으십시오. 성능상의 이유로 실제 터치스크린 장치가 있을 때만 터치 이벤트를 등록하려면 임의 포인터: 거칠기를 감지해 볼 수 있다. 그러나 우리는 마우스와 키보드의 다른 정기 이벤트 청취자들도 보유해야 한다.

```js
/* always, as a matter of course, listen to mouse and keyboard events */
target.addEventListener("click", ...);
 // ...

if (window.matchMedia && window.matchMedia("(any-pointer: coarse)").matches) {
  /* if there's a coarse pointer, *also* listen to touch events */
  target.addEventListener("touchstart", ...);
  // ...
}
```

또는 단일 통합 이벤트 모델에서 모든 유형의 포인터 입력을 다루며 상당히 잘 지원되는 포인터 이벤트를 사용함으로써 다양한 유형의 이벤트에 대한 이러한 전체 난제를 피할 수 있다.

### 사용자에게 명시적 선택권 부여

사용자가 사용하는 입력 유형에 대해 절대적인 결정을 내리지 못하는 것을 깔끔하게 피할 수 있는 한 가지 잠재적인 해결책은 What Input과 같은 미디어 쿼리와 도구에서 제공하는 정보를 사용하는 것이지, 다른 레이아웃/기능 간에 즉시 전환하는 것이 아니라, 특정 유형의 이벤트만 듣는 것이 될 수 있다. 그리고 잠재적으로 추가 입력 유형을 잠글 수 있습니다. 단, 이러한 입력 유형을 사용자에게 모드를 전환할 수 있는 명확한 방법을 제공하는 경우에 대한 신호로만 사용합니다.

예를 들어 Microsoft Office에서 "Touch" 모드와 "Mouse" 모드를 변경하는 방법을 참조하십시오. 터치 장치에서는 이 옵션이 응용 프로그램의 도구 모음에 기본적으로 표시되지만, 비터치 장치에서는 기본적으로 숨겨져 있습니다(터치 스크린의 유무에 관계없이 활성화할 수 있음).

![image](https://i0.wp.com/css-tricks.com/wp-content/uploads/2020/09/IJjfr9ug.png?resize=790%2C400&ssl=1)

사이트 또는 웹 응용 프로그램은 동일한 접근 방식을 취할 수 있으며 기본 입력에 따라 기본값을 설정할 수도 있지만 사용자가 모드를 명시적으로 변경할 수도 있습니다. 또한 What Input?과 유사한 접근 방식을 사용하여 터치 기반 입력의 첫 모습을 감지하고 사용자가 터치하기 쉬운 모드로 전환하려는 경우 사용자에게 경고/알림할 수 있습니다.

### 잘못된 가정에 대한 가능성 - 책임감 있게 쿼리

미디어 쿼리 레벨 4 상호 작용 미디어 기능을 사용하고 사용 가능한 기본 또는 추가 포인터 입력의 특성에 따라 사이트를 조정하는 것이 좋습니다. 그러나 이러한 미디어 기능이 실제로 말하는 것에 대해서는 잘못된 가정을 하지 마십시오. 유사한 기능 감지 방법과 마찬가지로 개발자는 정확히 무엇을 탐지하려고 하는지, 특정 탐지의 한계점에 대해 알아야 하며, 가장 중요한 것은 터치 감지 기사에서 설명한 문제와 유사한 방식으로 탐지하려는 이유를 고려해야 합니다.

➡과 ➡은 브라우저가 주요 기기 입력으로 결정하는 모든 기능에 대해 알려줍니다. `임의`와 `임의`는 연결된 모든 입력의 기능을 알려주고 기본 포인터 입력에 대한 정보와 결합하여 사용자의 특정 장치/장치에 대해 학습적인 추측을 할 수 있게 한다. 이러한 기능을 사용하여 레이아웃이나 제공하려는 상호 작용/기능 유형을 알릴 수 있습니다. 그러나 이러한 가정이 정확하지 않을 수 있습니다. 미디어 쿼리 자체는 반드시 결함이 있는 것은 아니다(대부분의 브라우저가 여전히 기이한 점을 가지고 있는 것처럼 보이고 버그가 잠재적인 문제를 더한다). 어떻게 쓰느냐에 따라 다르죠.

이것으로, 저는 입력 탐지의 함정으로부터 자신을 "지키기" 위한 제안을 함으로써 결론을 내리고자 합니다.