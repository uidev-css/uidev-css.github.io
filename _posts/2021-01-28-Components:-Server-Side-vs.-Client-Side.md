---
layout: post
title: "구성 요소 : 서버 측 대 클라이언트 측
 "
author: 'CSS Dev'
thumbnail: https://res.cloudinary.com/css-tricks/image/fetch/w_1200,q_auto,f_auto/https://css-tricks.com/wp-content/uploads/2021/01/s_B88F21F40E255B01805BDE26E3615C774E5A4E88B986EDD4271F833852A3D101_1610624153511_server-vs-client-comps-ssr-render.jpg
tags: CLIENT SIDE RENDERING,COMPON,SERVER SIDE RENDERING
---


2021 년 웹 사이트 구축?
 나는 당신이 구성 요소 중심의 접근 방식을 취할 것이라고 생각합니다.
 요즘은 모두 수다쟁이입니다.
 React와 Vue는 어디에나 있으며 (Angular는 여전히 존재합니까?) 다른 신흥 프레임 워크는 계속해서 주목을 받고 있습니다.
 

지난 10 년 동안 구성 요소를 사용하여 사이트를 체계적으로 구축하는 데 도움이되는 프레임 워크와 도구가 폭발적으로 증가했습니다.
 AngularJS와 같은 초기 프레임 워크는 웹 구성 요소의 일반적인 개념을 형성하는 데 도움이되었습니다.
 웹 구성 요소는 JavaScript로 작성되고 브라우저에서 작동하는 HTML 코드의 재사용 가능한 비트이기도합니다.
 클라이언트 측 구성 요소입니다.
 

그러나 더 일반적인 의미에서 구성 요소는 실제로 훨씬 더 오래되었습니다.
 사실, 그들은 웹의 초기 시절로 돌아갑니다.
 일반적으로 구성 요소라고 부르지는 않았지만 여전히 기능은 그대로 유지됩니다.
 서버 구성 요소는 재사용 가능한 코드 비트이지만 브라우저가보기 전에 HTML로 컴파일됩니다.
 그들은 서버 측 구성 요소이며 오늘날에도 여전히 매우 중요합니다.
 

"React, React, React"만 듣는 것처럼 보이는 세상에서도 두 가지 유형의 구성 요소는 여전히 관련성이 있으며 멋진 웹 사이트를 구축하는 데 도움이 될 수 있습니다.
 클라이언트와 서버 구성 요소가 서로 어떻게 다른지 살펴 보겠습니다.
 그것은 우리가 어디에서 왔는지에 대한 명확한 그림을 제공 할 것입니다.
 그러면 미래를 꿈꾸는 데 필요한 정보를 얻게 될 것입니다.
 

### 표현
 

아마도 클라이언트 측 구성 요소와 서버 측 구성 요소의 가장 큰 차이점은 그 구성 요소를 만드는 것입니다.
 그것이 그것들을 렌더링하는 책임이 있습니다.
 

서버 구성 요소는 다음과 같이 렌더링됩니다.
 - 서버.
 일반적으로 구성 요소라고하지 않습니다.
 사용되는 프레임 워크에 따라 부분, 포함, 스 니펫 또는 템플릿이라고도합니다.
 

서버 구성 요소에는 두 가지 유형이 있습니다.
 첫 번째는 클라이언트의 요청에 따라 실시간으로 구성 요소를 렌더링하는 고전적인 접근 방식입니다.
 여기를 보아라:
 

![image](https://i2.wp.com/css-tricks.com/wp-content/uploads/2021/01/s_B88F21F40E255B01805BDE26E3615C774E5A4E88B986EDD4271F833852A3D101_1610624153511_server-vs-client-comps-ssr-render.jpg?resize=910%2C613&ssl=1)

두 번째 맛은 Jamstack 접근 방식입니다.
 이 경우 전체 사이트는 빌드 프로세스 중에 컴파일되며 클라이언트에서 요청하면 정적 HTML을 이미 사용할 수 있습니다.
 여기를 보아라:
 

![image](https://i1.wp.com/css-tricks.com/wp-content/uploads/2021/01/s_B88F21F40E255B01805BDE26E3615C774E5A4E88B986EDD4271F833852A3D101_1610624183363_server-vs-client-comps-jamstack-render.jpg?resize=702%2C669&ssl=1)

두 경우 모두 클라이언트 (예 : 브라우저)는 구성 요소 간의 차이를 인식하지 못합니다.
 단순히 서버로부터 많은 HTML을받습니다.
 

반면에 클라이언트 구성 요소는 다음과 같이 렌더링됩니다. 사용자는 2 대 2이고 ROLL입니다!
 — 클라이언트.
 JavaScript로 작성되고 클라이언트 (브라우저)에서 렌더링됩니다.
 서버는 서버이고 모든 것을 알고 있기 때문에 클라이언트 구성 요소에 대해 알 수 있지만 구성 요소로 무엇이든 할 수 있는지 여부는 사용중인 프레임 워크에 따라 다릅니다.
 

서버 구성 요소와 마찬가지로 클라이언트 구성 요소에도 두 가지 유형이 있습니다.
 첫 번째는 Shadow DOM을 사용하는보다 공식적인 웹 구성 요소입니다.
 Shadow DOM은 스타일 및 기타 기능을 캡슐화하는 데 도움이됩니다 (이에 대해서는 나중에 자세히 설명하겠습니다).
 Polymer 및 Stencil과 같은 프레임 워크는 shadow DOM을 사용합니다.
 

React 및 Vue와 같이 널리 사용되는 프레임 워크는 DOM 조작 및 범위 지정을 자체적으로 처리하는 두 번째 구성 요소를 나타냅니다.
 

### 상호 작용
 

서버 구성 요소는 클라이언트로 전송 될 때 HTML 일 뿐이므로 프런트 엔드에서 상호 작용하려면 응용 프로그램에서 JavaScript 코드를 별도로로드해야합니다.
 

카운트 다운 타이머를 고려하십시오.
 표현은 HTML과 CSS에 의해 결정됩니다 (CSS 부분으로 돌아오겠습니다).
 그러나 그 일을 (수)하려면 JavaScript도 필요합니다.
 즉, 자바 스크립트를 가져 오는 것뿐만 아니라 자바 스크립트가 카운트 다운의 HTML 요소에 자신을 첨부 할 수있는 수단을 갖게됩니다. 이는 수동으로 수행하거나 다른 프레임 워크를 사용하여 수행해야합니다.
 

![image](https://i2.wp.com/css-tricks.com/wp-content/uploads/2021/01/s_B88F21F40E255B01805BDE26E3615C774E5A4E88B986EDD4271F833852A3D101_1610624228444_server-vs-client-comps-ssr-interactivity.jpg?resize=591%2C584&ssl=1)

불필요하게 지루하게 느껴질 수 있지만 (특히이 접근 방식을 강요받을만큼 충분히 오랫동안 주변에 있었다면) 이점이 있습니다.
 서버 측 코드는 한곳에 있고 기능은 다른 곳에는 존재하는 문제의 명확한 분리입니다.
 그리고 그것은 (이론적으로) 상호 작용에 필요한 코드 만 가져와 브라우저의 부담을 줄일 수 있습니다.
 

클라이언트 구성 요소를 사용하면 마크 업과 상호 작용이 종종 동일한 파일 또는 디렉터리에서 밀접하게 결합되는 경향이 있습니다.
 조직을 유지하는 데 부지런하지 않으면 빠르게 엉망이 될 수 있지만 클라이언트 구성 요소의 주요 이점 중 하나는 이미 클라이언트에 액세스 할 수 있다는 것입니다.
 또한 JavaScript로 작성 되었기 때문에 기능은 마크 업 (및 스타일)과 함께 제공 될 수 있습니다.
 

![image](https://i1.wp.com/css-tricks.com/wp-content/uploads/2021/01/s_B88F21F40E255B01805BDE26E3615C774E5A4E88B986EDD4271F833852A3D101_1610624263323_server-vs-client-comps-client-side-interactivity.jpg?resize=611%2C595&ssl=1)

### 공연
 

일대일 비교에서 서버 측 구성 요소는 더 나은 성능을 보이는 경향이 있습니다.
 브라우저가 수신하는 페이지에 프레젠테이션에 필요한 모든 것이 포함되어 있으면 해당 프레젠테이션을 사용자에게 훨씬 더 빠르게 전달할 수 있습니다.
 

![image](https://i0.wp.com/css-tricks.com/wp-content/uploads/2021/01/s_B88F21F40E255B01805BDE26E3615C774E5A4E88B986EDD4271F833852A3D101_1610624313076_server-vs-client-comps-ssr-perf.jpg?resize=667%2C364&ssl=1)

클라이언트 측 구성 요소에는 JavaScript가 필요하므로 브라우저는 구성 요소를 렌더링 할 수 있도록 추가 정보 (종종 별도의 파일)를 다운로드하거나 처리해야합니다.
 

![image](https://i1.wp.com/css-tricks.com/wp-content/uploads/2021/01/s_B88F21F40E255B01805BDE26E3615C774E5A4E88B986EDD4271F833852A3D101_1610624357393_server-vs-client-comps-client-perf.jpg?resize=697%2C557&ssl=1)

즉, 클라이언트 측 구성 요소는 종종 더 큰 프레임 워크의 컨텍스트 내에서 사용됩니다.
 React에는 Gatsby와 Next가 있고 Vue에는 Nuxt가 있습니다.
 이러한 프레임 워크에는 우수한 인앱 경험을 만들기위한 메커니즘이 있습니다.
 내 말은, 사이트에서 처음 방문하는 페이지를로드하는 데 속도가 느릴 수 있지만 이후보기를 매우 빠르게 제공하는 데 에너지를 집중할 수 있다는 것입니다. 종종 서버 측 렌더링 사이트가 콘텐츠를 제공 할 수있는 것보다 더 빠릅니다.
 

당신이 생각한다면 예,하지만 사전 렌더링은 어떻습니까?
 

네 말이 맞아.
 우리는 거기에 갈 것입니다.
 또한 더 이상 스포일러는 삼가 해주세요.
 나머지 우리는 함께 타고 있습니다.
 

### 언어
 

서버 구성 요소는 거의 모든 서버 측 언어로 작성할 수 있습니다.
 이를 통해 애플리케이션 로직과 동일한 언어로 템플릿을 작성할 수 있습니다.
 예를 들어 Ruby on Rails로 작성된 애플리케이션은 기본적으로 Ruby의 한 형태 인 ERB 템플릿을 사용합니다.
 따라서 Rails 앱은 구성 요소와 마찬가지로 애플리케이션 자체에 동일한 언어를 사용합니다.
 

클라이언트 구성 요소가 JavaScript로 작성된 이유는 웹 사이트에서 상호 작용을 위해 언어 브라우저가 구문 분석하기 때문입니다.
 그러나 JavaScript에는 서버 기반 런타임도 있으며 그중 가장 인기있는 것은 Node.js입니다.
 즉, 응용 프로그램이 Node (또는 유사)로 작성되는 한 클라이언트 구성 요소의 코드는 응용 프로그램과 동일한 언어로 작성 될 수 있습니다.
 

### 스타일링 (CSS)
 

스타일링 구성 요소와 관련하여 서버 측 구성 요소는 JavaScript에서 직면하는 것과 동일한 문제가 발생합니다.
 스타일은 일반적으로 구성 요소에서 분리되며 스타일을 페이지의 요소에 연결하려면 약간의 추가 노력이 필요합니다.
 

그러나이 프로세스를 덜 고통스럽게 만드는 Tailwind CSS와 같은 프레임 워크가 있습니다.
 

많은 클라이언트 측 구성 요소 라이브러리에는 즉시 CSS 지원 (또는 최소한 스타일링을위한 패턴)이 제공됩니다.
 이는 종종 마크 업 및 로직과 동일한 파일에 스타일을 포함하는 것을 의미하며, 이는 지저분해질 수 있습니다.
 그러나 일반적으로 약간의 노력으로 원하는대로 접근 방식을 조정할 수 있습니다.
 

### (하이브리드) 미래에 오신 것을 환영합니다
 

어떤 유형의 구성 요소도 그 자체로는 답이 아닙니다.
 서버 측 구성 요소는 스타일링 및 상호 작용에 추가적인 노력이 필요하므로 클라이언트 구성 요소의 제공 사항을 볼 때 불필요하다고 생각합니다.
 그러나 클라이언트 구성 요소는 프런트 엔드의 성능에서 벗어나는 경향이 있습니다.
 웹 사이트의 성공은 종종 사용자 참여에 달려 있기 때문에 성능 부족은 최종 결과를 손상시킬 수 있으며 클라이언트 구성 요소를 사용하고 싶지 않을 수 있습니다.
 

성능과 좋은 개발자 경험을 모두 요구하는 미래에는 어떤 의미가 있습니까?
 아마도 하이브리드 접근 방식입니다.
 

구성 요소는 서버 측에서 렌더링되어야합니다.
 그들은 단지 그렇습니다.
 이것이 우리가 성능을 최적화하는 방법이며 좋은 성능은 성공적인 웹 사이트의 속성이 될 것입니다.
 그러나 이제 React 및 Vue와 같은 프레임 워크를 사용하여 프런트 엔드 논리 및 상호 작용의 용이성을 확인 했으므로 이러한 프레임 워크는 여기에 있습니다 (적어도 잠시 동안).
 

그래서 우리는 어디로 가고 있습니까?
 

가까운 장래에 이러한 구성 요소가 세 가지 방식으로 결합되는 것을 보게 될 것입니다.
 

사전 렌더링에 대해 스포일러를 생각했을 때 기억하십니까?
 이제 그것에 대해 이야기합시다.
 

Gatsby, Next 및 Nuxt와 같은 프레임 워크는 React 및 Vue와 같은 구성 요소 프레임 워크 위에 구축 된 프런트 엔드 엔진 역할을합니다.
 도구를 결합하여 선호하는 프레임 워크를 사용하여 포괄적 인 프런트 엔드 환경을 구축합니다.
 이러한 기능 중 하나는 사전 렌더링입니다. 즉, 이러한 엔진은 사이트를 구축하는 동안 구성 요소를 검사 한 다음 페이지에 정적 HTML을 작성합니다.
 그러면 사용자가 해당 페이지를 볼 때 실제로 이미있는 것입니다.
 보기 위해 자바 스크립트가 필요하지 않습니다.
 

그러나 JavaScript는 수화라는 프로세스를 통해 작동합니다.
 페이지가로드되고 사용자가 모든 (정적) 콘텐츠를 본 후 JavaScript가 작동합니다.
 인터랙티브하게 만들기 위해 구성 요소를 인수합니다.
 이를 통해 서버의 일부 이점, 즉 성능 및 SEO와 함께 클라이언트 측 구성 요소 기반 웹 사이트를 구축 할 수 있습니다.
 

이러한 도구는 이러한 접근 방식으로 인해 매우 인기를 얻었으며 앞으로도 계속 발전 할 것으로 예상됩니다.
 

그것은 많은 복합어입니다.
 

지난 몇 년 동안 제가 많이 생각한 것은 다음과 같습니다. React (또는 Vue)가 서버 측 렌더링을 수행하지 않는 이유는 무엇입니까?
 도움을 줄 다른 프레임 워크 없이는 이해하거나 구현하기가 쉽지 않습니다.
 

한편으로는 단일 책임 원칙을 이해하고 있으며 이러한 구성 요소 프레임 워크는 클라이언트 측 구성 요소를 구축하는 방법 일뿐입니다.
 그러나 서버 측 렌더링을 Gatsby 및 Next와 같은 더 크고 복잡한 도구에 위임하는 것은 큰 실수처럼 느껴졌습니다.
 

글쎄요, React는 그렇게 움직이기 시작했습니다.
 Vue는 이미 있습니다.
 그리고 Svelte는 처음부터이 접근 방식을 우선 순위로 삼았습니다.
 

전통적으로 클라이언트 측에 초점을 맞춘 이러한 도구가 서버 측 렌더링을 해결하는 동안 우리는 훨씬 더 많은 개발을 보게 될 것이라고 생각합니다.
 앞으로 Svelte로부터 조금 더 많은 소식을 듣게 될 것입니다.이 점에서 게임보다 앞서있는 것 같습니다.
 

또한 Gatsby 및 Next와 같은 부피가 큰 도구에 대한 경쟁자가 더 많이 개발 될 수 있습니다.
 예를 들어, Netlify가 웹 사이트에서 무엇을하고 있는지 살펴보십시오.
 Vue 구성 요소를 가져와 서버에서 사용할 수 있도록 렌더링하는 Eleventy 프로젝트입니다.
 빠진 것은 수분 공급과 상호 작용 부분입니다.
 나는 그것이 아주 가까운 장래에 모일 것으로 기대합니다.
 

그럼에도 불구하고 우리는 서버 측 구성 요소의 지속적인 사용을 할인 할 수 없습니다.
 다른 두 가지 발전의 한 가지 부작용은 상호 작용이 약간만 필요할 때 불필요하다고 느낄 수있는 JavaScript 프레임 워크를 여전히 사용하고 있다는 것입니다.
 

서버 측 언어로 작성된 서버 측 구성 요소를보다 대화 형으로 만들기 위해 약간의 JavaScript를 추가하는 더 간단한 방법이 있어야합니다.
 

이 문제를 해결하는 것은 (거의) 서버 측 언어를 사용하여 클라이언트 구성 요소의 일부 이점을 서버로 가져 오는 수단 인 Hotwire를 방금 출시 한 Basecamp의 사람들의 접근 방식 인 것 같습니다.
 

이것이 바로 Hotwire 경쟁이 나타날 것이라는 의미인지 모르겠습니다.
 하지만 Hotwire가 주목을받을 것이라고 생각합니다.
 그리고 그것은 사람들을 Rails와 같은 풀 스택 모 놀리 식 프레임 워크로 다시 작업하게 할 수 있습니다.
 (개인적으로 저는 Rails가 JavaScript 중심의 세상에서 쓸모 없게 된 것이 아니라는 점이 마음에 듭니다. 경쟁이 치열할수록 웹은 더 좋아집니다.)
 

이 모든 부품 사업이 어디로 가고 있다고 생각하십니까?
 그것에 대해 이야기합시다.
 