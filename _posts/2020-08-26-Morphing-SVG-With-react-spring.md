---
layout: post
title: "반응 스프링을 이용한 모핑 SVG"
author: "CSS Dev"
thumbnail: "https://res.cloudinary.com/css-tricks/image/fetch/w_1200,q_auto,f_auto/https://css-tricks.com/wp-content/uploads/2020/08/react-spring-svg-morph.gif"
tags: ANIMATING REACT
---


나는 어렸을 때부터 모핑 효과에 흥미를 느껴왔다. 항상 제 관심을 사로잡는 형태 변환 애니메이션에 관한 것이 있습니다. 나는 모피를 처음 봤을 때 "와, 그들이 어떻게 그런 짓을 했을까?"하고 궁금해졌어. 그 이후, 저는 데모를 만들고 그 효과에 대한 기사를 썼습니다.

모핑을 지원하는 여러 애니메이션 라이브러리에 대해서는 여러 가지 옵션이 있습니다. 그들 중 많은 것들이 좋고 많은 특징들을 제공한다. 최근에 나는 리액트 스프링에 중독되었다. 리액트 스프링(React-spring)은 리액트를 기반으로 제작된 물리 지원 애니메이션 라이브러리이다. Adam Rack은 최근에 그것에 대한 멋진 개요를 게시했다. 라이브러리에는 SVG 모핑 등 많은 기능이 포함되어 있습니다. 사실, 리액션 스프링의 아름다움은 그것이 모피를 어떻게 지탱하는가에 있다. 그러면 SVG 경로 설명자를 정의하는 마크업에서 직접 수행할 수 있습니다. 이것은 장부상의 관점에서 보면 좋다. SVG 경로 설명자는 일반적으로 예상되는 위치입니다.

다음은 이 기사에서 살펴보고 있는 내용의 비디오입니다.

이것은 탑승 순서에서 모핑 효과입니다. 여기서는 배경 효과로 사용됩니다. 그것은 전경 애니메이션을 보완하기 위한 것입니다; 그 장면을 차지하기 보다는 조금 더 돋보이게 하기 위한 것입니다.

### SVG 문서 생성

우리가 가장 먼저 하고 싶은 것은 기본 모델을 만드는 것입니다. 보통, 일단 제가 하고 싶은 일을 명확하게 하고 나면, 저는 어떤 종류의 디자인을 만듭니다. 대부분의 탐색은 모델에서 시작하여 데모로 끝납니다. 대부분의 경우 벡터 편집기에서 SVG 문서를 만드는 것을 의미합니다. 저는 잉크스케이프를 사용하여 SVG를 그립니다.

SVG 문서를 작성할 때 정확한 비율을 사용합니다. 나는 정확하게 하는 것이 더 낫다는 것을 알았다. 나에게 있어서, 그것은 브라우저와 코드 편집기에서와 같이 벡터 편집기에서 같은 좌표계를 사용할 때 내가 만들고 싶은 것에 대한 나의 인식을 도와준다. 예를 들어 패딩을 포함하여 24px → 30px SVG 아이콘을 생성하려고 한다고 가정해 보겠습니다. 가장 좋은 방법은 정확히 같은 크기인 가로 24픽셀, 세로 30픽셀 크기의 SVG 문서를 사용하는 것입니다. 비율이 잘못된 것으로 판명되면 나중에 언제든지 조정할 수 있습니다. SVG는 그런 면에서 용서한다. 어떤 일을 하든 확장성이 뛰어납니다.

저희가 만들고 있는 SVG 문서는 가로 256픽셀, 세로 464픽셀입니다.

### 모형 그리기

모델을 생성할 때 노드를 어디에 배치하고 사용할 노드 수를 고려해야 합니다. 이건 중요해. 여기가 애니메이션의 토대가 되는 곳입니다. 모델링은 모핑에 대한 모든 것입니다. 하나의 노드가 다른 노드로 변환됩니다. 이러한 노드 모음은 노드 수가 동일해야 합니다. 둘째로, 이 세트들은 어떻게든 상관관계가 있을 것이다.

벡터 모양 사이의 관계가 신중하게 검토되지 않는다면 애니메이션은 완벽하지 않을 것이다. 각 노드와 모든 노드가 애니메이션에 영향을 미칩니다. 그들의 위치와 곡면성은 정확해야 한다. SVG 경로의 노드가 구성되는 방법에 대한 자세한 내용은 MDN의 베지어 곡선에 대한 설명을 참조하십시오.

둘째, 우리는 두 가지 모양을 모두 고려해야 합니다. 벡터 중 하나에 다른 벡터에서는 찾을 수 없는 부품이 포함될 수 있습니다. 또는 두 모델 간에 다른 차이가 있을 수 있습니다. 이러한 경우에는 특정 위치에 추가 노드를 삽입하는 것이 좋습니다. 가장 좋은 것은 전략을 짜는 것이다. 이 코너가 저쪽으로 가면, 이 직선이 커브 모양으로 부풀어 오르는 것처럼요.

저는 펜 하나를 조립해서 세트들이 서로 안 좋은 상관관계가 있을 때와 정확하게 디자인되었을 때 어떤 모습인지 설명하려고 합니다. 아래 예제에서는 왼쪽에 있는 모핑 효과에서 노드가 랜덤하게 배치됩니다. 1번과 2번을 구성하는 노드는 관계가 없다. 올바른 예에서는 노드 배치를 보다 신중하게 계획합니다. 이것은 좀 더 일관성 있는 경험으로 이어진다.

<div class="wp-block-cp-codepen-gutenberg-embed-block cp_embed_wrapper resizable" style="height: 300px;"><iframe id="cp_embed_GRoXPrP" src="//codepen.io/anon/embed/GRoXPrP?height=300&amp;theme-id=1&amp;slug-hash=GRoXPrP&amp;default-tab=result" height="300" scrolling="no" frameborder="0" allowfullscreen="" allowpaymentrequest="" name="CodePen Embed GRoXPrP" title="CodePen Embed GRoXPrP" class="cp_embed_iframe" style="width: 100%; overflow: hidden; height: 100%;">CodePen Embed Fallback</iframe><div class="win-size-grip" style="touch-action: none;"></div></div>

## 첫 번째 모델

선 도구는 우리가 첫 번째 벡터 모양을 그리기 위해 사용하는 것입니다. 우리가 만들고 있는 모델이 더 추상적이기 때문에, 조금 더 관대합니다. 우리는 여전히 배치와 곡면성에 대해 생각해야 하지만, 그것은 더 많은 게으름을 허용한다.

벡터 및 사이징의 경우 모핑에 사용할 모형을 만들 때도 마찬가지입니다. 이것은 반복적인 과정입니다. 처음만 안 맞으면 언제든 돌아가서 적응할 수 있어요. 애니메이션을 빛내기 위해서는 대개 한두 번의 반복이 필요하다. 완성된 모델은 다음과 같습니다.

![image](https://i2.wp.com/css-tricks.com/wp-content/uploads/2020/08/image-e1597160055974-1024x818.png?resize=512%2C409&ssl=1)

그 결과 8개의 노드가 있는 부드러운 추상 SVG 모양이 만들어집니다.

### 두 번째 및 세 번째 모델

첫 번째 모델이 완성되면 두 번째 모델(상태라고도 생각할 수 있음)을 그릴 때입니다. 이것이 첫 번째 세트가 변형될 모양입니다. 이것이 최종 상태, 즉 단일 모핑 효과일 수 있습니다. 아니면 열쇠틀 같은 걸음을 내딛는 것일 수도 있습니다. 지금 보고 있는 경우에는 세 가지 단계가 있습니다. 다시 말하지만, 각 모델은 이전 모델과 상관 관계가 있어야 합니다. 모형이 일치하는지 확인하는 한 가지 방법은 첫 번째 벡터의 복제로 두 번째 벡터를 만드는 것입니다. 이런 방식으로, 우리는 모델들이 동일한 수의 노드를 가지고 있고, 같은 모양과 느낌을 가지고 있다는 것을 안다.

편집자를 조심해라. 벡터 편집기는 일반적으로 파일 크기와 형식을 최적화합니다. 변경 사항을 저장할 때 모델이 호환되지 않을 수 있습니다. 파일을 저장한 후 SVG 코드를 검사하는 습관을 들이고 있습니다. 또한 경로 설명자 형식에 익숙한 경우에도 유용합니다. 당신이 익숙하지 않다면 그것은 좀 애매하다. 벡터 편집기의 기본 설정에서 최적화를 비활성화하는 것도 좋은 아이디어일 수 있다.

![image](https://i2.wp.com/css-tricks.com/wp-content/uploads/2020/08/image-1-e1597160080444-1024x818.png?resize=512%2C409&ssl=1)

세 번째 도형에 대해 위의 과정을 반복합니다. 모든 노드를 복사하고 재배치한 다음 세 번째 색상을 설정합니다.

### 조명, 카메라…액션!

모델이 만들어지면 대부분의 작업을 완료했습니다. 이제 애니메이션 부분을 살펴볼 시간입니다. 리액트 스프링은 애니메이션과 모핑에 사용할 수 있는 후크 세트가 함께 제공됩니다. 사용봄은 이 예에서 효과의 완벽한 후보이다. 이것은 우리가 만들고 있는 것과 같은 단일 애니메이션에 사용될 것입니다. 여기 `usse Spring` 훅으로 애니메이션을 시작하는 방법이 있다.

```jsx
const [{ x }, set] = useSpring(() => ({
  x: 0,
}));
```

위의 내용은 우리의 모핑 효과를 만들어낼 애니메이션 속성인 `x`를 제공한다. 이러한 애니메이션 속성의 좋은 점은 거의 모든 종류의 애니메이션을 만들 수 있도록 변경할 수 있다는 것입니다. 값이 꺼져 있으면 보간을 통해 변경할 수 있습니다.

두 번째 매개 변수인 `set` 함수를 사용하여 업데이트를 트리거할 수 있습니다. 아래는 그 용도를 보여주는 코드 조각입니다. 애니메이션 값 x를 반응 사용 제스처 라이브러리의 제스처 처리기 useDrag로 업데이트합니다. 리액트 스프링에서 애니메이션을 트리거할 수 있는 방법은 여러 가지가 있습니다.

```jsx
const bind = useDrag(
  ({ movement: [x] }) => {
    // ...
    set({ x });
  },
);
```

우리는 이제 우리의 모델, 경로 설명자를 마크업과 결합시키기 위해 모든 것을 준비했습니다. JSX 코드에 애니메이션 키워드를 추가하여 리액트 스프링의 애니메이션 시스템을 활성화한다. 이전에 인터폴레이트(interpolate)로 명명된 보간 호출 `to`를 사용하여 드래그 거리를 변형된 모양으로 변환한다. 출력 배열에는 이미 설명한 모델이 포함되어 있습니다. 이러한 기능을 사용하기 위해 SVG 파일에서 마크업으로 경로 설명자를 복사하기만 하면 됩니다. 세 개의 서로 다른 SVG 파일에서 복사한 세 개의 경로 요소에서 세 개의 서로 다른 설명자 d가 하나로 결합된다. 반응 스프링 애니메이션으로 구동되는 JSX 노드의 모습입니다.

```jsx
<svg ...>
  <animated.path
    d={x.to({
      range: [-400, -200, 0],
      output: [
        // First model
        "M 157.81292,131.16918 C 128.33979,127.45582 59.004493,121.76045 53.287478,168.06051 47.570462,214.36057 86.454799,213.14326 77.881699,234.66986 69.308599,256.19646 59.042495,268.13837 67.634107,288.98209 76.225718,309.82581 103.27857,320.05328 138.34249,312.55156 173.40641,305.04984 204.93111,298.87002 208.02612,279.75926 211.12113,260.6485 189.48716,257.88808 188.5557,229.54606 187.62424,201.20404 212.01456,174.45091 200.8528,155.7634 189.69104,137.07589 187.28605,134.88254 157.81292,131.16918 Z",
        // Second model
        "M 157.81292,131.16918 C 128.33979,127.45582 48.756902,138.1566 53.287478,168.06051 57.818054,197.96442 75.182448,197.77187 73.782662,224.42227 72.382877,251.07266 70.314846,257.89078 72.757903,278.7345 75.20096,299.57822 88.114636,303.32873 113.94876,307.60312 139.78288,311.87751 159.84171,314.24141 176.25858,295.13065 192.67546,276.01989 203.83379,256.86332 190.60522,228.5213 177.37665,200.17928 205.866,189.8223 211.10039,171.13479 216.33478,152.44728 187.28605,134.88254 157.81292,131.16918 Z",
        // Third model
        "M 157.81292,131.16918 C 128.33979,127.45582 86.672992,124.83473 71.733144,166.01099 56.793295,207.18725 69.033893,203.92043 80.955976,230.57083 92.87806,257.22123 55.968217,259.9403 59.436033,279.75926 62.90385,299.57822 94.985717,299.83924 132.0922,306.16316 169.19868,312.48708 186.48544,320.38997 198.80328,288.98209 211.12113,257.57422 199.73475,245.59097 195.72902,217.24895 191.72328,188.90693 209.96504,178.54995 215.19943,159.86244 220.43382,141.17493 187.28605,134.88254 157.81292,131.16918 Z",
      ],
    })}
  />
</svg>
```

표준 JSX `path` 요소와 현재 우리가 가지고 있는 요소 간의 차이를 살펴봅시다. 모핑 애니메이션을 구현하기 위해 다음과 같은 기능을 제공합니다.

- 애니메이션 키워드를 추가하여 반응 스프링을 사용하여 JSX `path` 요소를 애니메이션화했습니다.
- 설명자 `d`를 문자열에서 반응 스프링 보간으로 변경하였다.
- x 거리를 세 개의 경로 설명자 사이의 키프레임 애니메이션으로 변환합니다.

### 개발환경

SVG와 함께 일하기 위한 완벽한 개발 환경을 아직 찾지 못했습니다. 현재는 벡터 에디터, IDE, 브라우저를 오가고 있습니다. 약간의 복사와 약간의 중복이 수반된다. 완벽하지는 않지만, 효과가 있습니다. 저는 과거에 SVG를 구문 분석하는 스크립트를 사용하여 약간 실험한 적이 있습니다. 아직 모든 시나리오에 적용할 수 있는 것을 찾지 못했습니다. 아마 나만 잘못 이해한 것 같아. 그렇지 않다면 SVG를 통한 웹 개발이 좀 더 원활할 수 있다면 좋을 것입니다.

### 자, 갑니다!

마지막으로, 데모!

<div class="wp-block-cp-codepen-gutenberg-embed-block cp_embed_wrapper resizable" style="height: 550px;"><iframe id="cp_embed_NWxYBRq" src="//codepen.io/anon/embed/NWxYBRq?height=550&amp;theme-id=1&amp;slug-hash=NWxYBRq&amp;default-tab=result" height="550" scrolling="no" frameborder="0" allowfullscreen="" allowpaymentrequest="" name="CodePen Embed NWxYBRq" title="CodePen Embed NWxYBRq" class="cp_embed_iframe" style="width: 100%; overflow: hidden; height: 100%;">CodePen Embed Fallback</iframe><div class="win-size-grip" style="touch-action: none;"></div></div>

읽어주셔서 감사합니다!