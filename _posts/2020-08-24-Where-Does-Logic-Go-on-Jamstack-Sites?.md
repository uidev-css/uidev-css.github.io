---
layout: post
title: "Jamstack 사이트에서 논리는 어디로 갈까요?"
author: "CSS Dev"
thumbnail: https://res.cloudinary.com/css-tricks/image/fetch/w_1200,q_auto,f_auto/https://css-tricks.com/wp-content/uploads/2020/08/assembly-line.png
tags: JAMSTACK,MAINTENANCE
---

여기 제가 Jamstack 사이트를 짓기 시작했을 때 머리를 싸매야 했던 것이 있습니다. 논리를 내세울 수 있는 사이트에는 다음과 같은 다양한 단계가 있습니다.

내 말이 무슨 뜻인지 알 수 있도록 특별한 예를 보자. 음악 공연장을 위한 웹사이트를 만든다고 해보세요. 이 사이트에서 가장 중요한 부분은 이벤트 리스트이며, 일부는 과거, 일부는 이벤트 목록이다. 이러한 레이블 또는 매우 명확한 설계로 레이블을 지정하려고 합니다. 그것은 날짜를 기준으로 한 논리이다. 어떻게 하는 거야? 그 논리는 어디에 있는가?

잼스택에 관한 한 적어도 네 군데의 고려 대상이 있다.

### 옵션 1: HTML에 직접 쓰십시오.

말 그대로 앉아서 모든 이벤트를 나타내는 HTML 파일을 쓰십시오. 우리는 행사 날짜를 보고, 과거인지 미래인지 결정하며, 두 경우 모두 다른 내용을 쓸 것이다. 파일을 커밋하고 배포합니다.

```html
<h1>Upcoming Event: Bill's Banjo Night</h1>
<h1>Past Event: 70s Classics with Jill</h1>
```

이거면 완전히 효과가 있을 거야! 하지만 단점은 항상 HTML 파일을 업데이트해야 한다는 것입니다. Bill`s Banjo Night가 끝나면 코드 편집기를 열고 "Upcoming"을 "Past"로 변경하고 파일을 다시 업로드해야 합니다.

### 옵션 2: 빌드 시 구조화된 데이터 쓰기 및 논리 수행

모든 HTML을 손으로 쓰는 대신 마크다운 파일을 만들어 각 이벤트를 표현합니다. 날짜 및 제목과 같은 중요한 정보가 구조화된 데이터로 들어 있습니다. 그건 한 가지 선택일 뿐이에요. 요점은 우리가 이 데이터에 직접 접근할 수 있다는 것입니다. 머리 없는 CMS 같은 것일 수도 있습니다.

그런 다음 모든 Markdown 파일을 읽고(또는 CMS에서 정보를 끌어 내려) HTML 파일로 빌드하는 정적 사이트 생성기를 설정합니다. 분명한 것은 빌드 프로세스 중에 원하는 모든 논리를 실행할 수 있다는 것입니다. 환상적인 수학을 하고, API를 치고, 철자 검사를 해보세요. 하늘은 한계입니다.

음악 공연장 사이트의 경우 다음과 같은 Markdown 파일로 이벤트를 나타낼 수 있습니다.

```markdown
---
title: Bill's Banjo Night
date: 2020-09-02
---

The event description goes here!
```

그런 다음 빌드 프로세스 중에 다음과 같은 템플릿을 작성하여 약간의 논리를 실행합니다.

```html
{ if event.date > now }
<h1>Upcoming Event: {event.title}</h1>
{ else }
<h1>Past Event: {event.title}</h1>
{ endif }
```

이제 빌드 프로세스가 실행될 때마다 이벤트 날짜를 보고 과거인지 미래인지 판단하여 해당 정보를 기반으로 다른 HTML을 생성합니다. HTML을 수동으로 더 이상 변경할 수 없습니다!

이 접근 방식의 문제는 날짜 비교가 빌드 프로세스 동안 한 번만 수행된다는 것입니다. 위의 예에서 now 변수는 빌드가 실행되는 날짜와 시간을 나타냅니다. 빌드된 HTML 파일을 업로드한 후에는 빌드를 다시 실행할 때까지 변경되지 않습니다. 이는 일단 음악 공연장에서의 행사가 끝나면, 웹사이트가 그것을 반영하도록 하기 위해 빌드를 다시 운영해야 한다는 것을 의미합니다.

이제 재구축 작업을 자동화하여 하루에 한 번 또는 한 시간에 한 번이라도 수행할 수 있습니다. 말 그대로 CSS-Tricks 회의 사이트가 Zapier를 통해 하는 일입니다.

![image](https://i1.wp.com/css-tricks.com/wp-content/uploads/2020/08/YIheuQLw.png?resize=1024%2C677&ssl=1)

그러나 Netlifify와 같은 서비스를 사용하는 경우 빌드 시간을 단축할 수 있으며, 오래된 버전의 사이트를 가져오는 경우도 있을 수 있습니다.

### 옵션 3: 에지에서 논리 수행

에지 작업자는 요청이 들어올 때마다 CDN 수준에서 코드를 실행하는 방법입니다. 이 문서 작성 당시에는 이러한 문서를 광범위하게 사용할 수 없지만, 문서를 작성한 후에는 다음과 같이 날짜 비교를 작성할 수 있습니다.

```js
// THIS DOES NOT WORK
import eventsList from "./eventsList.json";
function onRequest(request) {
    const now = new Date();
    eventList.forEach(event => {
        if (event.date > now) {
            event.upcoming = true;
        }
    });
    const props = {
        events: events
    };
    request.respondWith(200, render(props), {});
}
```

렌더링() 함수는 처리된 이벤트 목록을 가져와서 HTML로 변환합니다. 아마도 미리 렌더링된 템플릿에 이 이벤트를 삽입하는 것이 좋습니다. 에지 작업자의 가장 큰 장점은 속도가 매우 빠르기 때문에 CDN의 성능 이점을 누리면서 논리 서버를 실행할 수 있다는 것입니다.

그리고 에지 작업자는 누군가가 웹 사이트를 요청할 때마다 실행되므로 최신 버전의 웹 사이트를 얻을 수 있습니다.

### 옵션 4: 런타임에 논리 실행

마지막으로, 예를 들어 데이터 속성 형태로 구조화된 데이터를 프런트 엔드로 직접 전달할 수 있습니다. 그런 다음 사용자의 장치에 필요한 모든 로직을 수행할 수 있는 JavaScript를 작성하고 DOM을 즉시 조작합니다.

음악 공연장 사이트의 경우 다음과 같은 템플릿을 작성할 수 있습니다.

```html
<h1 data-date="{event.date}">{event.title}</h1>
```

그런 다음 페이지가 로드된 후 JavaScript에서 날짜를 비교합니다.

```js
function processEvents() {
    const now = new Date();
    events.forEach(event => {
        const eventDate = new Date(event.getAttribute("data-date"));
        if (eventDate > now) {
            event.classList.add("upcoming");
        } else {
            event.classList.add("past");
        }
    });
}
```

지금 변수는 사용자 장치의 시간을 반영하기 때문에 이벤트 목록이 최신 상태로 유지될 수 있습니다. 사용자의 기기에서 이 코드를 실행시키기 때문에 사용자의 언어 또는 시간대에 따라 날짜가 표시되는 방식을 조정하는 등의 작업을 수행할 수도 있습니다.

그리고 라이프사이클의 이전 시점과는 달리, 런타임은 사용자가 웹 사이트를 열어 놓은 시간만큼 지속됩니다. 따라서 우리가 원한다면 몇 초마다 프로세스 이벤트()를 실행할 수 있고 페이지를 새로 고치지 않고도 목록이 완벽하게 최신 상태를 유지할 수 있을 것이다. 이것은 아마도 우리 음악 공연장의 웹사이트에는 불필요할 것이지만, 만약 우리가 건물 밖에 있는 광고판에 그 행사들을 전시하고 싶다면, 그것은 단지 유용하게 쓰일 수도 있다.

### 논리는 어디에 둘 것인가?

Jamstack의 핵심 개념 중 하나는 빌드 시간에 가능한 많은 작업을 수행하고 정적 HTML을 서비스한다는 것이지만, 여전히 로직을 어디에 둘 것인지 결정해야 합니다.

어디다 두실 건가요?

그것은 정말로 당신이 무엇을 하려고 하느냐에 달려 있다. 거의 변경하지 않는 사이트 부분은 편집 시 완료해도 전혀 문제가 없습니다. 여러분이 정보를 계속해서 바꾸는 것을 발견한다면, CMS로 정보를 옮기고 빌드 시간에 가져올 수 있는 좋은 시간이 될 것입니다. 시간에 민감하거나(여기서 사용한 이벤트 예와 같이), 사용자에 대한 정보에 의존하는 기능은 에지 또는 런타임에 라이프사이클을 더 내려가야 할 수 있습니다.
