---
layout: post
title: "리액션 서스펜스를 사용한 사전 캐슁 이미지"
author: 'CSS Dev'
thumbnail: https://res.cloudinary.com/css-tricks/image/fetch/w_1200,q_auto,f_auto/https://css-tricks.com/wp-content/uploads/2020/09/react-suspense.png
tags: PRELOAD,REACT,REACT SUSPENSE
---


서스펜스는 개발자가 구성 요소가 "준비"될 때까지 렌더링을 지연시킬 수 있도록 하여 훨씬 부드러운 사용자 환경을 제공할 수 있도록 하는 리액션의 흥미로운 기능입니다. 이러한 맥락에서 "준비"는 여러 가지를 의미할 수 있습니다. 예를 들어, 데이터 로드 유틸리티가 서스펜스에 연결될 수 있으므로 쿼리당 로드 상태를 수동으로 추적할 필요 없이 모든 데이터가 이동 중일 때 일관된 로드 상태를 표시할 수 있습니다. 데이터가 사용 가능하고 구성 요소가 "준비"되면 데이터가 렌더링됩니다. 이는 서스펜스와 가장 일반적으로 논의되는 주제이며, 이전에 작성한 적이 있습니다. 그러나 데이터 로드는 서스펜스가 사용자 환경을 개선할 수 있는 많은 사용 사례 중 단 한 가지에 불과합니다. 오늘 또 한 가지 말씀드리고 싶은 것은 이미지 프리로드입니다.

당신은 웹 앱을 만들거나 사용해 본 적이 있는가? 웹 앱은 화면에 착지한 후 이미지가 다운로드되고 렌더링될 때 당신의 위치가 흔들리고 점프를 하는 것이다. 우리는 그 내용을 리플로우라고 부르는데, 그것은 성가시기도 하고 불쾌하기도 하다. 서스펜스가 도움이 될 수 있어요. 내가 서스펜스가 렌더링하는 것을 멈출 때까지 기다리는 거라고 말했던 거 알아? 다행히도, 이러한 맥락에서 "준비"는 상당히 개방적이며, 우리의 목적상 "사전 로드된 필요한 이미지"가 포함될 수 있습니다. 어떻게 하는지 보자!

### 서스펜스에 대한 빠른 충돌 코스

자세한 내용을 살펴보기 전에 서스펜스의 작동 방식을 살펴보겠습니다. 그것은 크게 두 부분으로 되어 있다. 첫 번째는 구성 요소 서스펜션의 개념입니다. 즉, React는 구성 요소를 제공하려고 하지만 "준비"되지 않았습니다. 이 경우 구성 요소 트리의 가장 가까운 "폴백"이 렌더링됩니다. 잠시 후 폴백(대단히 간단함)을 검토하겠지만, 구성 요소가 리액션(React)에 준비되지 않았다고 말하는 방법은 약속을 던지는 것입니다. 리액션은 그 약속을 받아내고, 구성요소가 준비되지 않았다는 것을 깨닫고, 실패를 만회할 것입니다. 약속이 해결되면 리액션은 다시 렌더링을 시도합니다. 헹구고 씻고 반복합니다. 네, 저는 지금 너무 단순화시키고 있습니다. 하지만 이것이 서스펜스가 어떻게 작용하는지에 대한 요지입니다. 그리고 우리는 이 개념들 중 몇 가지를 확장해 나갈 것입니다.

서스펜스의 두 번째 부분은 "전환" 상태 업데이트의 도입이다. 즉, 상태를 설정하지만 상태 변경으로 인해 구성 요소가 일시 중단될 수 있으며 이러한 경우 폴백이 발생하지 않는다고 React에 말합니다. 대신 상태 업데이트가 준비될 때까지 현재 화면을 계속 보고자 합니다. 물론, React는 개발자에게 인라인 로딩 피드백을 제공할 수 있도록 "보류 중" 부울 표시기를 제공합니다.

### 몇 가지 이미지를 미리 로드해 두겠습니다!

먼저, 저는 이 기사의 마지막에 우리가 만드는 것에 대한 완전한 데모가 있다는 것을 주목하고 싶습니다. 코드로 들어가려면 지금 얼마든지 데모를 열어보세요. 여기에는 전환 상태 업데이트와 함께 서스펜스를 사용하여 이미지를 사전 로드하는 방법이 나와 있습니다. 이 포스트의 나머지 부분들은 그 코드를 차근차근 쌓아갈 것입니다. 그 이유는 무엇 때문인지 설명하면서 말이죠.

좋아, 가자!

모든 이미지가 사전 로드될 때까지 구성 요소를 일시 중단해야 합니다. 가능한 한 간단하게 하기 위해 src 속성을 받아 이미지를 미리 로드하고 예외 투척을 처리한 다음 모든 것이 준비되면 img를 렌더링하는 <Suspense Image> 구성 요소를 만들어 보자. 그러한 구성 요소는 우리가 원하는 이미지 표시에 어디든 `Suspense Image` 구성 요소를 매끄럽게 떨어뜨릴 수 있게 해 줄 것이며, Suspens는 모든 것이 준비될 때까지 그것을 붙잡고 있는 투덜대는 작업을 처리할 것이다.

먼저 코드를 미리 스케치하는 것으로 시작할 수 있습니다.

```jsx
const SuspenseImg = ({ src, ...rest }) => {
  // todo: preload and throw somehow
  return <img alt="" src={src} {...rest} />;
}; 
```

우리는 두 가지를 정리해야 합니다. (1) 이미지를 사전 로드하는 방법과 (2) 예외 투척을 묶는 방법. 첫 번째 부분은 꽤 간단하다. 우리는 모두 `=imgsrc="some-image.dism"을 통해 HTML의 이미지를 사용하는 데 익숙하지만 JavaScript의 `Image()` 개체를 사용하여 이미지를 즉시 생성할 수도 있으며, 이와 같이 생성한 이미지에는 이미지가 로드되면 로드된 후 콜백이 발생합니다. 다음과 같습니다.

```jsx
const img = new Image();
img.onload = () => {
  // image is loaded
}; 
```

하지만 그걸 어떻게 예외투구로 묶죠? 저와 같은 사람이라면 첫 번째 성향은 다음과 같을 것입니다.

```jsx
const SuspenseImg = ({ src, ...rest }) => {
  throw new Promise((resolve) => {
    const img = new Image();
    img.onload = () => {
      resolve();
    };
  });
  return <img alt="" src={src} {...rest} />;
}; 
```

물론 문제는 이것이 항상 약속을 던진다는 것이다. 리액션이 <Suspense Img> 인스턴스를 만들려고 할 때마다 새로운 약속이 만들어지고 즉시 던져질 것이다. 대신, 우리는 이미지가 로드될 때까지만 약속을 하고 싶습니다. 컴퓨터 과학의 모든 문제들은 (너무 많은 수의 간접적인 문제를 제외하고) 한 층의 간접적인 것을 추가함으로써 해결될 수 있다는 오래된 속담이 있습니다. 그러니 바로 그것만 하고 이미지 캐시를 구축합시다. src를 읽으면 캐시가 해당 이미지가 로드되었는지 확인하고 로드되지 않으면 프리로드가 시작되고 예외가 발생합니다. 그리고 이미지가 미리 로드되어 있으면 참으로 반환되고 Return을 통해 이미지를 렌더링할 수 있습니다.

당사의 `Suspense Image` 구성 요소는 다음과 같습니다.

```jsx
export const SuspenseImg = ({ src, ...rest }) => {
  imgCache.read(src);
  return <img src={src} {...rest} />;
};
```

NAT 캐시의 최소 버전은 다음과 같습니다.

```jsx
const imgCache = {
  __cache: {},
  read(src) {
    if (!this.__cache[src]) {
      this.__cache[src] = new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          this.__cache[src] = true;
          resolve(this.__cache[src]);
        };
        img.src = src;
      }).then((img) => {
        this.__cache[src] = true;
      });
    }
    if (this.__cache[src] instanceof Promise) {
      throw this.__cache[src];
    }
    return this.__cache[src];
  }
};
```

완벽하지는 않지만, 지금은 충분해요. 어서 쓰도록 합시다.

### 구현

아래에 완전히 작동하는 데모에 대한 링크가 있다는 것을 기억하십시오. 그래서 제가 어떤 특정한 단계에서 너무 빨리 움직인다면, 절망하지 마세요. 저희도 설명을 해드릴게요.

우리의 약점을 정의하는 것부터 시작합시다. 구성 요소 트리에 서스펜스 태그를 배치하여 폴백을 정의하고 폴백(fallback) 소품을 통해 폴백을 전달합니다. 일시 중단된 모든 구성 요소는 가장 가까운 서스펜스 태그를 위쪽으로 검색하고 폴백을 렌더링합니다(그러나 서스펜스 태그가 발견되지 않으면 오류가 발생합니다). 실제 앱은 다양한 모듈에 대한 특정 오류를 정의하여 전체적으로 많은 서스펜스 태그를 가질 수 있지만, 이 데모에서는 루트 앱을 감싸는 단일 태그만 있으면 됩니다.

```jsx
function App() {
  return (
    <Suspense fallback={<Loading />}>
      <ShowImages />
    </Suspense>
  );
}
```

<로딩> 구성 요소는 기본 스핀너이지만 실제 앱에서는 렌더링하려는 실제 구성 요소의 빈 셸을 렌더링하여 보다 원활한 환경을 제공할 수 있습니다.

이를 통해 `<이미지 표시> 구성 요소는 다음과 같이 이미지를 렌더링합니다.

```jsx
<FlowItems>
  {images.map(img => (
    <div key={img}>
      <SuspenseImg alt="" src={img} />
    </div>
  ))}
</FlowItems>
```

초기 부하에서, 우리의 로딩 스피너는 초기 이미지가 준비될 때까지 비틀거리는 리플로우 잼(reflow jankness) 없이 모두 한 번에 보여준다.

### 전환 상태 업데이트

일단 이미지가 제 위치에 오르면, 다음 번 배치의 이미지를 로드하면, 물론 로드된 후 화면에 기존 이미지가 표시되도록 하고 싶습니다. 우리는 이것을 `사용 전환` 후크로 한다. 그러면 `start Transition` 함수가 반환되고 `isPending` 부울이 반환됩니다. 이 부울은 상태 업데이트가 진행 중이지만 일시 중단되지 않았음을 나타냅니다(또는 상태 업데이트가 너무 오래 걸리는 경우에도 여전히 사실일 수 있음). 마지막으로 useTransition을 호출할 때는 react가 포기하고 폴백을 렌더링하기 전에 isPending 플래그가 true가 될 수 있는 최대 시간인 timeoutMs 값을 전달해야 합니다(참고로 timeoutMs 인수). transition 상태 업데이트가 필요할 때 오래 기다리기 때문에 timeoutMs 인수는 조만간 제거될 것입니다. 기존 컨텐츠 업데이트)

제 것은 다음과 같습니다.

```jsx
const [startTransition, isPending] = useTransition({ timeoutMs: 10000 });
```

실제 상황에서는 너무 길지만 특히 DevTools에서 의도적으로 네트워크 속도를 느리게 하여 실험하는 경우에는 이 데모에 적합한 예비 프로그램을 10초 동안 시청할 수 있습니다.

사용법은 이렇습니다. 더 많은 이미지를 로드하기 위해 버튼을 클릭하면 다음과 같은 코드가 나타납니다.

```jsx
startTransition(() => {
  setPage(p => p + 1);
});
```

이 상태 업데이트는 내 GraphQL 클라이언트 마이크로그래프ql-react를 사용하여 새로운 데이터 로드를 트리거할 것이며, 이는 서스펜스 호환이 가능하므로 쿼리가 실행 중일 때 우리에게 약속을 던질 것이다. 데이터가 다시 돌아오면 구성 요소는 이미지를 프리로드하는 동안 렌더링을 시도하고 다시 일시 중단합니다. 이 모든 것이 일어나고 있는 동안, 우리의 `isPending` 값은 `true`가 될 것이며, 이것은 우리가 기존의 콘텐츠 위에 로딩 스피너를 표시할 수 있게 할 것이다.

### 네트워크 폭포를 피하십시오.

이미지 프리로드가 진행되는 동안 Return이 렌더링을 차단하는 방법이 궁금할 수 있습니다. 위의 코드와 함께 다음을 수행합니다.

```js
{images.map(img => (
```

…에 제공된 `Suspense Image`와 함께 첫 번째 이미지인 Suspend(일시 중지)를 렌더링한 다음 목록을 다시 시도하고, 현재 캐쉬에 있는 첫 번째 이미지를 통과하여 두 번째 이미지, 세 번째 이미지, 네 번째 이미지에만 일시 중단합니다. 이전에 서스펜스에 대해 읽어 보신 적이 있다면 렌더링 전에 목록에 있는 모든 이미지를 수동으로 미리 로드해야 하는지 궁금하실 수 있습니다.

리액트가 서스펜스 세계에서 어떻게 사물을 만들어내는지에 대해 꽤 영리하기 때문에 걱정할 필요도 없고, 어색한 프리로드도 필요 없는 것으로 밝혀졌습니다. 리액트가 구성 요소 트리를 통과하면서 정지에 부딪혔을 때 멈추기만 하는 것이 아닙니다. 대신 구성 요소 트리를 통해 다른 모든 경로를 계속 렌더링합니다. 따라서 이미지 0을 렌더링하려고 할 때 일시 중단이 발생하지만 Retact는 이미지 1에서 N까지 계속 렌더링한 후 일시 중단됩니다.

전체 데모에서 "다음 이미지" 단추를 클릭하면 네트워크 탭을 볼 수 있습니다. 전체 이미지 버킷이 네트워크 목록에 즉시 나타나는 것을 보고, 하나씩 확인하고, 완료되면 결과가 화면에 나타나야 합니다. 이 효과를 실제로 확대하기 위해 네트워크 속도를 "빠른 3G"로 늦추는 것이 좋습니다.

재미를 위해, 우리는 React가 구성 요소 트리의 모든 경로를 통해 뛰어들어 구성 요소를 렌더링하기 전에 캐시에서 각 이미지를 수동으로 읽음으로써 서스펜스가 이미지 위로 떠오르도록 할 수 있다.

```js
images.forEach((img) => imgCache.read(img));
```

저는 이것을 설명하는 데모를 만들었습니다. 새 이미지 세트가 들어올 때 네트워크 탭을 보면 네트워크 목록에 순차적으로 추가된 이미지가 표시됩니다(네트워크 속도가 느려진 상태에서는 실행하지 않음).

### 늦게 일시 중단

서스펜스를 사용할 때 명심해야 할 코럴리어가 있습니다. 렌더링 시 가장 늦게 구성 요소 트리에서 최대한 낮게 일시 중단합니다. 정지된 여러 이미지를 렌더링하는 일종의 `이미지 리스트`가 있다면, 리액션이 개별적으로 도달할 수 있도록 각 이미지가 자체 구성 요소에서 정지되어 있는지 확인하고, 아무도 다른 이미지를 차단하지 않아 폭포수가 발생하도록 하십시오.

이 규칙의 데이터 로드 버전은 데이터가 실제로 필요한 구성 요소에 의해 가능한 한 늦게 로드되어야 한다는 것입니다. 즉, 단일 구성 요소에서 이와 같은 작업을 피해야 합니다.

```jsx
const { data1 } = useSuspenseQuery(QUERY1, vars1);
const { data2 } = useSuspenseQuery(QUERY2, vars2);
```

이를 피하고 싶은 이유는 쿼리 1이 일시 중단되고 쿼리 2가 일시 중단되어 폭팔을 일으키기 때문입니다. 이 문제를 피할 수 없는 경우에는 일시 중단 전에 두 가지 쿼리를 수동으로 미리 로드해야 합니다.

### 데모

여기 제가 약속한 데모입니다. 위에서 연결했던 것과 똑같아요.

개발 도구를 열어 놓고 실행할 경우, DevTools Network(DevTools 네트워크) 탭에서 "Disable Cache"(캐시 사용 안 함)라고 표시된 상자의 선택을 취소해야 합니다. 그렇지 않으면 전체 데모를 무시할 수 있습니다.

코드는 제가 아까 보여드린 것과 거의 동일합니다. 데모에서 한 가지 향상된 점은 캐시 읽기 방법에 다음과 같은 줄이 있다는 것입니다.

```jsx
setTimeout(() => resolve({}), 7000);
```

모든 이미지를 미리 로드하는 것은 좋지만, 실제 상황에서는 한 두 개의 Stragling한 이미지가 느리게 들어온다고 해서 렌더링 작업을 무한정 지연시키고 싶지는 않을 것입니다. 그래서 시간이 지나면, 이미지가 아직 준비되지 않았음에도 불구하고, 우리는 그냥 초록빛을 냅니다. 사용자는 한두 개의 이미지가 깜박이는 것을 볼 수 있지만, 정지된 소프트웨어의 좌절감을 견뎌내는 것보다는 낫다. 또한 7초는 과도할 수 있지만 이 데모에서는 사용자가 DevTools의 네트워크 속도를 느리게 하여 Suspension 기능을 보다 명확히 볼 수 있도록 지원할 수 있습니다.

데모에는 사전 캐시 이미지 확인란도 있습니다. 기본적으로 선택되어 있지만, 서스펜스 버전을 "정상 반응"(결과가 들어오는 동안 확인하지 않거나 전체 UI가 일시 중단되고 폴백을 렌더링할 수 있음)과 비교하려는 경우 이 태그를 선택 취소하여 `Suspense Image` 구성 요소를 일반 ol` `<img> 태그로 바꿀 수 있습니다.

마지막으로, 코드 샌드박스의 경우처럼 일부 상태는 때때로 동기화 상태가 좋지 않을 수 있으므로 상태가 이상하거나 고장나기 시작하면 새로 고침 버튼을 누르십시오.

### 이런저런 잡동사니들, 이것저것 자질구레한 것들

이 데모를 조립할 때 제가 실수로 만든 거대한 버그가 하나 있었습니다. 브라우저가 이미 다운로드한 이미지를 캐시하기 때문에 여러 번 실행해도 효과가 손실되는 것을 원치 않았습니다. 따라서 캐시 버스터를 사용하여 모든 URL을 수동으로 수정합니다.

```jsx
const [cacheBuster, setCacheBuster] = useState(INITIAL_TIME);
 
const { data } = useSuspenseQuery(GET_IMAGES_QUERY, { page });
const images = data.allBooks.Books.map(
  (b) => b.smallImage + `?cachebust=${cacheBuster}`
);
```

`INITICIAL_TIME`은 다음 행으로 모듈 수준(즉, 전역)에서 정의됩니다.

```jsx
const INITIAL_TIME = +new Date();
```

내가 대신 왜 이런 짓을 하지 않았는지 궁금하시겠죠?

```jsx
const [cacheBuster, setCacheBuster] = useState(+new Date());
```

...이것은 끔찍하고 끔찍한 일을 하기 때문입니다. 첫 번째 렌더에서는 이미지가 렌더링을 시도합니다. 캐시가 일시 중단을 일으키고 리액션이 렌더링을 취소하고 폴백을 표시합니다. 모든 약속이 해결되면 리액션은 이 초기 렌더링을 다시 시도하게 되며, 초기 `useState` 호출이 다시 실행되어 다음과 같은 상황이 발생합니다.

```jsx
const [cacheBuster, setCacheBuster] = useState(+new Date());
```

…이 새로운 초기 값으로 다시 실행되어 완전히 새로운 이미지 URL 집합을 생성하며, 이 URL은 무한대로 다시 중단됩니다. 구성 요소가 실행되지 않고 CodeSandbox 데모가 중단됩니다(디버그하기 불편함).

이것은 이 특별한 데모에 대한 독특한 요구조건에 의해 야기된 이상한 일회성 문제처럼 보일 수 있지만, 더 큰 교훈이 있습니다: 렌더링이란 부작용 없이 순수해야 한다는 것입니다. 리액션은 구성 요소를 여러 번 다시 렌더링할 수 있어야 하며, 동일한 초기 소품이 제공되면 동일한 상태가 반대쪽 끝에 나타나야 합니다.