---
layout: post
title: "미디어 쿼리 외: 최신 HTML 사용"
author: 'CSS Dev'
thumbnail: https://res.cloudinary.com/css-tricks/image/fetch/w_1200,q_auto,f_auto/https://css-tricks.com/wp-content/uploads/2020/08/clamp-website.jpg
tags: CLAMP,MAX,MIN,MINMAX,OBJECT-FIT,PICTURE,SRCSET
---


미디어 쿼리와 Flexbox나 그리드 같은 현대의 CSS 레이아웃을 사용하여 대응적인 웹사이트를 만드는 것 외에도, 우리가 대응적인 사이트를 만들기 위해 잘 할 수 있는 몇 가지 간과된 것들이 있다. 이 기사에서는 미디어 쿼리를 사용하든 사용하지 않든 자연스럽게 작동하는 반응형 이미지부터 상대적으로 새로운 CSS 기능에 이르기까지 준비된 여러 가지 도구(HTML 및 CSS를 중심으로 한 기술)에 대해 알아보겠습니다.

실제로 미디어 쿼리는 전체 접근 방식보다는 이러한 기능과 함께 사용될 때 더 많은 보완이 된다. 어떻게 되는지 봅시다.

### 응답성이 뛰어난 이미지

우리가 언제 `폭:100%`를 이미지 위에 던져놓고 그것을 하루라고 부를 수 있었는지 기억나니? 물론 여전히 효과가 있고 이미지를 흐리게 만들기도 하지만, 그에 수반되는 여러 단점이 있습니다. 그 중 가장 주목할 만한 단점은 다음과 같습니다.

- 초점이 흐려질 정도로 이미지가 찌그러질 수 있습니다.
- 소형 기기는 여전히 전체 크기의 이미지를 다운로드하게 됩니다.

웹에서 이미지를 사용할 때는 해상도와 크기에 맞게 최적화해야 합니다. 그 이유는 우리가 올바른 장치에 적합한 이미지 해상도를 가지고 있는지 확인하기 위해서입니다. 그래서 우리는 더 작은 화면을 위해 실제로 크고 무거운 이미지를 다운로드하지 않게 되고 결국 사이트의 성능을 떨어뜨릴 수 있습니다.

간단히 말해서, 우리는 더 큰 고해상도 이미지를 더 큰 화면으로 보내는 반면, 더 작은 저해상도 변형이 더 작은 화면으로 전송되어 성능과 사용자 경험을 모두 향상시키도록 하고 있다.

HTML은 우리가 추가하는 미디어 조회를 기반으로 렌더링될 정확한 이미지 리소스를 지정할 수 있는 `<그림>` 요소를 제공합니다. 앞에서 설명한 것처럼, 하나의 이미지(일반적으로 큰 고해상도 버전)를 모든 화면 크기로 전송하여 뷰포트 폭까지 확장하는 대신 특정 상황에서 사용할 이미지 세트를 지정한다.

```html
<picture>
  <source media="(max-width:1000px)" srcset="picture-lg.png">
  <source media="(max-width:600px)" srcset="picture-mid.png">
  <source media="(max-width:400px)" srcset="picture-sm.png">
  <img src="picture.png" alt="picture"">
</picture>
```

이 예에서 picture.png는 전체 크기의 이미지입니다. 여기서 우리는 다음 최대 이미지 버전인 `picture-lg.png`를 정의하고, 크기는 가장 작은 버전인 `picture-sm.png`까지 내림차순으로 감소한다. 우리는 여전히 이 접근법에서 미디어 쿼리를 사용하고 있지만, CSS에서 중단점을 정의하지 않고 반응하는 행동을 주도하는 것은 `<그림> 요소 그 자체이다.

미디어 쿼리가 적절하게 추가되어 사진 크기에 맞게 확장됩니다.

- 1000px 이상 뷰포트는 picture.png를 얻는다.
- 601px~999px인 뷰포트는 picture-lg.png를 받는다.
- 401px에서 600px 사이의 뷰포트는 picture-sm.png를 얻는다.
- 400px보다 작은 것은 picture-sm.png가 된다.

흥미롭게도, 각 이미지에 URL 뒤에 이미지 밀도(1x, 2x, 3x 등)로 레이블을 지정할 수도 있습니다. 이것은 서로 다른 이미지를 서로 비례하여 만든 경우 작동합니다. 이를 통해 브라우저는 뷰포트 크기 외에도 화면의 픽셀 밀도에 따라 다운로드할 버전을 결정할 수 있습니다. 하지만 다음과 같이 정의할 수 있는 이미지 수를 기록해 두십시오.

```html
<picture>
  <source media="(max-width:1000px)" srcset="picture-lg_1x.png 1x, picture-lg_2x.png 2x, picture-lg_3x.png 3x">
  <source media="(max-width:600px)" srcset="picture-mid_1x.png 1x, picture-mid_2x.png 2x, picture-mid_3x.png 3x">
  <source media="(max-width:400px)" srcset="picture-small_1x.png 1x, picture-small_2x.png 2x, picture-small_1x.png 3x">
  <img src="picture.png" alt="picture"">
</picture>
```

구체적으로 <그림> 요소 안에 내포된 두 개의 태그, 즉 <소스>와 <img>를 살펴보자.

브라우저는 미디어 쿼리가 현재 뷰포트 폭과 일치하는 첫 번째 `<` 요소를 찾은 다음 적절한 이미지를 표시합니다(srcset 속성에 지정됨). 초기 소스 태그가 일치하지 않을 경우 폴백 옵션으로 <img> 요소가 <그림> 요소의 마지막 하위 항목으로 필요합니다.

![image](https://i2.wp.com/css-tricks.com/wp-content/uploads/2020/08/picture-element-diagram.jpg?resize=571%2C296&ssl=1)

또한 이미지 밀도를 사용하여 `srcset` 특성을 사용하여 `<` 요소만으로 반응하는 이미지를 처리할 수 있다.

```html
<img
 srcset="
  flower4x.png 4x,
  flower3x.png 3x,
  flower2x.png 2x,
  flower1x.png 1x
 "
 src="flower-fallback.jpg"
>
```

우리가 할 수 있는 또 다른 일은 장치 자체의 화면 해상도(보통 인치 당 도트 또는 dpi로 측정)를 기반으로 CSS에 미디어 쿼리를 쓰는 것이다. 즉, 다음 대신 다음과 같은 이점이 있습니다.

```css
@media only screen and (max-width: 600px) {
  /* Style stuff */
}
```

이제 다음과 같은 이점을 누리게 되었습니다.

```css
@media only screen and (min-resolution: 192dpi) {
  /* Style stuff */
}
```

이 접근 방식을 통해 장치 자체의 화면 해상도를 기반으로 렌더링할 이미지를 지정할 수 있으며, 이는 고해상도 이미지를 처리할 때 유용할 수 있다. 기본적으로 이는 더 높은 해상도와 더 작은 버전을 지원하는 화면의 고품질 사진을 낮은 해상도로 표시할 수 있음을 의미한다. 주목해야 할 점은 모바일 기기에는 작은 화면이 있지만 대개 고해상도라는 점입니다. 즉, 어떤 이미지를 렌더링할지 결정할 때 해상도에만 의존하는 최상의 아이디어는 아닙니다. 그것은 큰 고해상도 이미지를 작은 화면에 제공하는 결과를 가져올 수 있습니다. 작은 화면 크기로 표시하고자 하는 버전이 아닐 수도 있습니다.

```css
body {
  background-image : picture-md.png; /* the default image */
}
 
@media only screen and (min-resolution: 192dpi) {
  body {
    background-image : picture-lg.png; /* higher resolution */
  }
}
```

<그림>이 우리에게 주는 것은 기본적으로 직접적인 이미지를 예술할 수 있는 능력이다. 그리고 이 아이디어에 따라, 우리는 `개체 위치`와 함께 사용할 때 이미지의 가로 세로 비율을 유지하면서 더 나은 초점을 위해 이미지를 자를 수 있는 `개체 적합` 속성과 같은 CSS 기능을 활용할 수 있다.

따라서 이미지의 초점을 변경하려면:

```css
@media only screen and (min-resolution: 192dpi) {
  body {
    background-image : picture-lg.png;
    object-fit: cover;
    object-position: 100% 150%; /* moves focus toward the middle-right */
  }
}
```

### CSS에서 최소 및 최대 값 설정

최소() 함수는 요소를 축소할 수 있는 절대 최소 크기를 지정합니다. 이 기능은 유체 유형이 읽기 쉬운 글꼴 크기 이하로 떨어지지 않도록 하는 것과 같이 텍스트 크기가 다양한 화면 크기에 걸쳐 적절하게 확장되도록 돕는 측면에서 매우 유용함을 입증한다.

```css
html {
  font-size: min(1rem, 22px); /* Stays between 16px and 22px */
}
```

min²는 두 개의 값을 받아들이며, 상대, 백분율, 고정 단위로 사용할 수 있습니다. 이 예에서는 브라우저에 클래스 `.box`가 있는 요소가 뷰포트 너비를 기준으로 가장 작은 45% 너비 또는 600px보다 낮게 유지되도록 하지 말라고 말합니다.

```css
.box {
  width : min(45%, 600px)
}
```

45%가 600px보다 작은 값으로 계산하면 브라우저는 45%를 너비로 사용합니다. 반대로 45%가 600px보다 큰 값으로 계산하면 요소의 너비에 600px가 사용됩니다.

max() 함수도 마찬가지다. 또한 두 개의 값을 허용하지만, 요소에 대한 가장 작은 크기를 지정하는 대신 얻을 수 있는 가장 큰 값을 정의하는 것입니다.

```css
.box {
  width : max(60%, 600px)
}
```

60%가 600px보다 큰 값으로 계산되는 경우 브라우저는 60%를 너비로 사용합니다. 플립 측면에서 60%가 600px보다 작은 값으로 계산하면 600px가 요소의 너비로 사용됩니다.

### 클램핑 값

우리 중 상당수는 얼마 전부터 클램프를 외쳐왔고, 실제로 모든 최신 브라우저(미안하지만 Internet Explorer)에서 폭넓은 지원을 받고 있다. `max`는 `min`과 `max` 기능의 조합으로, 세 가지 매개 변수를 받아들인다.

- 최소값,
- 선호 가치, 그리고
- 극댓값

예를 들어:

```css
.box {
  font-size : clamp(1rem, 40px, 4rem)
}
```

브라우저는 1rem의 계산된 값이 40px보다 클 때까지 글꼴을 1rem으로 설정합니다. 그리고 계산된 값이 40px 이상일 때? 네, 4rem이 되면 브라우저가 크기를 더 이상 늘리지 않습니다. 미디어 쿼리에 손을 대지 않고도 클램프()를 사용하여 요소를 유동적으로 만드는 방법을 확인할 수 있습니다.

### 응답성 유닛 작업

큰 표제나 하위 표제가 있는 페이지를 구축한 적이 있습니까? 그리고 데스크톱 화면에서 이 페이지가 얼마나 훌륭해 보이는지 감탄하면서 모바일 장치에서 확인하고 너무 큰 페이지임을 알아본 적이 있습니까? 저는 분명히 이 상황에 처해 왔고 이 섹션에서는 이러한 문제를 어떻게 처리할 것인지 설명하겠습니다.

CSS에서는 다양한 측정 단위를 사용하여 소자의 크기나 길이를 결정할 수 있으며 가장 많이 사용되는 측정 단위는 px, em, rem, %s, vh 등이다. 하지만 자주 사용하지 않는 장치가 몇 개 더 있습니다. 우리에게 관심 있는 것은 px는 절대 단위로 간주될 수 있고 나머지는 상대 단위로 간주될 수 있다는 점이다.

픽셀(px)은 고정되고 다른 요소의 측정에 따라 변경되지 않기 때문에 주로 절대 단위로 간주됩니다. 일부 다른 상대 단위가 사용하는 기준 단위 또는 루트 단위로 간주할 수 있습니다. 픽셀을 반응하는 동작에 사용하는 것은 수정되었기 때문에 문제에 부딪힐 수 있지만 크기를 조정해서는 안 되는 요소가 있으면 좋습니다.

%ta `em`, `rem`과 같은 상대 유닛은 주로 다양한 화면 크기에 걸쳐 확장할 수 있기 때문에 반응형 설계에 더 적합하다.

vw: 뷰포트의 너비에 상대적인 경우
vh : 뷰포트 높이 대비
`rem`: 루트(`<html>) 요소에 상대적입니다(기본 글꼴 크기는 보통 16px입니다).
`em`: 상위 요소에 상대적인 경우
`%`: 상위 요소에 대한 상대

다시 말해, 대부분의 브라우저의 기본 글꼴 크기는 `16px`이며 이것이 렘 단위가 계산된 값을 생성하기 위해 사용하는 것이다. 따라서 사용자가 브라우저의 글꼴 크기를 조정하면 페이지의 모든 내용이 루트 크기에 따라 적절하게 조정됩니다. 예를 들어 `16px`에서 루트 집합을 처리할 때 지정한 숫자는 기본 크기의 곱하기입니다. 예를 들어:

```html
.8rem = 12.8px (.8 * 16)
1rem = 16px (1 * 16)
2rem = 32px (2 * 16)
```

사용자나 사용자가 기본 크기를 변경하면 어떻게 됩니까? 앞서 말씀드린 대로, 이것들은 상대적인 단위이며 최종 크기 값은 새로운 기준 크기에서 기초할 것입니다. 이렇게 하면 글꼴 크기를 변경하고 그에 따라 전체 페이지의 크기를 늘리거나 줄이는 미디어 쿼리에서 유용합니다.

예를 들어 CSS 내에서 글꼴 크기를 `10px`로 변경하면 계산된 크기는 다음과 같이 됩니다.

```css
html {
  font-size : 10px;
}
```

```html
1rem = 10px (1 * 10)
2rem = 20px (2 * 10)
.5rem = 5px (.5 * 10)
```

참고: 이 값은 백분율 `%`에도 적용됩니다. 예를 들어:

```html
100% = 16px;
200% = 32px; 
50% = 8px;
```

그리고 렘과 em의 차이는 무엇인가? 이것은 유닛이 기본 요소로 사용하는 것입니다. rem은 루트(``<]) 요소의 글꼴 크기를 사용하여 값을 계산하는 반면, em 값을 선언하는 요소는 해당 요소를 포함하는 상위 요소의 글꼴 크기를 참조합니다. 지정된 상위 요소의 크기가 루트 요소와 다르면(예: 상위 요소는 18px이지만 루트 요소는 16px) `em`과 `rem`은 서로 다른 계산된 값으로 확인됩니다. 이를 통해 우리는 서로 다른 대응 컨텍스트에서 우리의 요소가 어떻게 반응하는지를 보다 세밀하게 제어할 수 있다.

vh는 뷰포트 높이 또는 화면 높이를 나타내는 약어입니다. `100vh`는 (기기에 따라) 뷰포트 높이의 100%를 나타냅니다. 같은 맥락에서 vw는 보기 가능한 화면 폭을 의미하는 뷰포트 폭, 100vw는 문자 그대로 뷰포트 폭의 100%를 나타낸다.

### 미디어 쿼리 이상으로 이동

보이지? 우리는 단지 응답성을 위한 추가적인 (그리고 가능한 더 효과적인) 방법을 제공하는, 매우 강력하고 상대적으로 새로운 HTML과 CSS 기능들을 살펴보았다. 이 새로운 기술들이 우리가 줄곧 해왔던 것을 대체한다는 것은 아닙니다. 그것들은 단지 우리의 개발자 도구 벨트의 더 많은 도구일 뿐인데, 이것은 요소들이 서로 다른 맥락에서 어떻게 작용하는지를 결정하는데 더 큰 통제력을 우리에게 준다. 글꼴 크기, 해상도, 너비, 초점 또는 여러 가지를 사용할 경우 사용자 환경을 이전보다 세밀하게 제어할 수 있습니다.

다음 번에 특정 장치에서 설계의 정확한 모양과 느낌을 보다 잘 제어하고 싶은 프로젝트를 진행하게 되면, 기본 HTML과 CSS가 어떤 도움을 줄 수 있는지 확인해 보십시오. 일이 얼마나 진행되었는지가 놀랍습니다.