---
layout: post
title: "60일 동안 손으로 코드화된 CSS로 좀비를 재애니메이션한 결과 얻은 교훈"
author: 'CSS Dev'
thumbnail: https://res.cloudinary.com/css-tricks/image/fetch/w_1200,q_auto,f_auto/https://css-tricks.com/wp-content/uploads/2020/09/IaUK1BDA.png
tags: CSS ANIMATION,SPRITES,SVG ANIMATION
---


주의: 앞으론 유머감각이 끔찍해 우리는 실용적인 것들에 대해 이야기 할 것입니다. 하지만 그 예들은 거의 다 좀비들과 우스꽝스러운 농담들을 포함합니다. 경고를 받았습니다.

제가 배운 교훈에 대해 이야기하면서 펜스 개인에게 연결하겠습니다. 하지만 프로젝트 전체를 파악하려면 언데드 애니메이션 연구소 60일을 확인해 보세요. 저는 이 프로젝트를 2020년 8월 1일에 끝내기 위해 이 프로젝트를 시작했습니다. 제가 쓴 CSS 애니메이션, 유머, 그리고 좀비라는 책의 출판과 동시에 말입니다. 왜냐하면 웹 기술을 휘두르지 않고 종말을 고하지 않으면 좀비가 세상을 파괴할 것이기 때문입니다. HTML 요소처럼 그 상처들을 말 위에 올려놓지 않는 것은 없다!

나는 그 프로젝트 내내 몇 가지 규칙을 가지고 있었다.

- 나는 모든 CSS를 손으로 코드화 할 것이다. (나는 마조히스트이다.)
- 사용자가 모든 애니메이션을 시작합니다. (이미 반쯤 지난 애니메이션은 정말 싫어요.)
- 나는 가능한 한 자바스크립트를 적게 사용하고 애니메이션에는 절대 사용하지 않을 것이다. (저는 자바스크립트를 딱 한 번 사용했는데, 그것은 마지막 애니메이션으로 오디오를 시작하는 것이었습니다. 저는 JavaScript에 반대하지 않습니다. 단지 여기서 하고 싶었던 일이 아닙니다.)

### 제1장: 80일은 긴 시간이다.

제목에 `육십일`이라고 적혀 있지 않나요? 네, 하지만 원래 목표는 80일을 하는 것이었고, 20일 미만의 애니메이션과 3일 평균 제작이 준비되는 날이 다가오자 깜짝 놀라 60일로 바꿨어요. 그래서 시작 날짜까지 20일을 더 보냈고, 해야 할 일이 20일 더 줄어들었다.

![image](https://i1.wp.com/css-tricks.com/wp-content/uploads/2020/09/C4dkeb3g.png?resize=1024%2C469&ssl=1)

그것은 제한된 시간, 아이디어, 그리고 훨씬 더 제한된 예술적 기술을 가지고 하는 많은 애니메이션입니다. 그리고 30일로 줄려고 생각했지만 그러지 않아서 다행이에요. 60일 동안 저는 CSS 애니메이션의 작동 방식, 더 나아가 CSS 자체의 작동 방식에 대해 더 깊이 연구해야 했습니다. 저는 또한 제 기술이 향상되면서 제가 했던 많은 후기 작품들이 가장 자랑스럽습니다. 그리고 저는 좀 더 혁신적이 되어야 했고, 어떻게 하면 흥미를 유발시킬 수 있을까에 대해 더 고민해야 했습니다. 쉬운 선택지를 다 써보시면 실제 작업도 하고 좋은 결과도 나오고요. (네, 6월 1일에 시작해서 8월 1일에 마지막 애니메이션을 하고 싶어서 62일 만에 끝났습니다.) 6월 3일부터는 그저 멀미가 나고 기분이 나빴다.)

그래서, 진짜 교훈 1: 스트레칭을 하세요.

### 제2장: 상호작용 애니메이션은 어렵고 반응하기 더 어렵다.

화면을 가로질러 다른 요소에 연결하거나 다른 요소의 이동을 시작하려는 경우 모든 표준 단위, 융통성 없는 단위 또는 유연한 단위를 사용해야 합니다.

애니메이션 중에 애니메이션 요소가 언제 어디에 있는지 결정하는 세 가지 변수(기간, 속도 및 거리)입니다. 애니메이션 기간은 애니메이션 속성에서 설정되며 화면 크기에 따라 변경할 수 없습니다. 애니메이션 타이밍 기능이 속도를 결정합니다. 화면 크기 역시 속도를 변경할 수 없습니다. 따라서 화면 크기에 따라 거리가 달라지면 특정 화면 폭과 높이를 제외한 모든 곳에서 타이밍이 꺼집니다.

탱크를 봐! 넓고 좁은 화면 크기로 애니메이션을 실행하십시오. 제가 타이밍을 가까이 두고 있는 동안 둘을 비교해 보면 마지막 좀비들이 떨어질 때 좀비들과 비교해서 탱크가 다른 곳에 있다는 것을 알 수 있습니다.

![image](https://i2.wp.com/css-tricks.com/wp-content/uploads/2020/09/kzM5P2Jq.jpeg?resize=1000%2C500&ssl=1)

이러한 타이밍 문제를 방지하려면 애니메이션이 가장 큰 모니터를 제외한 모든 모니터의 화면 너비(또는 높이)를 커버하도록 고정 장치와 2000 또는 5000픽셀 이상의 큰 숫자를 사용할 수 있습니다.

### 제3장: 반응성이 뛰어난 애니메이션을 원한다면 모든 것을 뷰포트 유닛에 넣으십시오.

단위 비율(예: 폭과 높이를 픽셀 단위로 설정하지만 뷰포트 단위를 사용하여 위치와 이동)을 절반으로 설정하면 예측할 수 없는 결과가 발생합니다. vw와 vh 둘 다 사용하지 말고 둘 중 어느 쪽이든 지배적인 방향이 될 것이다. vh와 vw 단위를 혼합하면 애니메이션이 "wunky"가 될 것입니다. 이 용어는 기술 용어라고 생각합니다.

Superly Zomborrific을 예로 들어보자. 픽셀, vw 및 vh 단위를 혼합합니다. `카메라`가 이어지면서 슈퍼 좀비가 위로 날아오르고 있다는 전제가 깔려 있다. 슈퍼 좀비는 카메라가 계속되면서 레지에 부딪혀 넘어지지만, 만약 당신의 화면이 충분히 높다면 당신은 그것을 이해할 수 없을 것이다.

![image](https://i0.wp.com/css-tricks.com/wp-content/uploads/2020/09/1DCHFcVp.png?resize=1200%2C600&ssl=1)

이것은 또한 만약 여러분이 위에서 들어올 무언가가 필요하다면 - "Nobody Here But Us Humans"에서처럼 - 여러분은 닌자 좀비가 대부분의 가로 세로 비율로 보이지 않도록 충분히 높이 설정해야 한다는 것을 의미합니다.

즉, SVG 요소 내에서 요소를 변환하는 경우 뷰포트 단위를 사용하면 안 됩니다. SVG 태그는 그들만의 비례적 우주이다. SVG "픽셀"은 SVG 요소 내에서 다른 모든 SVG 요소 하위와 비례하지만 뷰포트 단위는 비례하지 않는다. 따라서 SVG 요소 내에서 픽셀 단위로 변환하지만 다른 곳에서는 뷰포트 단위를 사용합니다.

### 제4장: SVG는 런타임에 끔찍하게 확장된다.

웁스 같은 애니메이션을 위해 좀비의 SVG 이미지를 그의 5배 크기까지 만들었지만, 그 때문에 가장자리가 흐릿해졌다. [스케일링 가능한 벡터 그래픽에 주먹을 휘두릅니다.]

```css
/* Original code resulting in fuzzy edges */
.zombie {
  transform: scale(1);
  width: 15vw;
}

.toggle-checkbox:checked ~ .zombie {
  animation: 5s ease-in-out 0s reverseshrinkydink forwards;
}

@keyframes reverseshrinkydink {
  0% {
    transform: scale(1);
  }
  100% {
    transform: scale(5);
  }
}
```

저는 그들의 치수를 애니메이션의 마지막에 적용되는 최종 차원으로 설정하고, 스케일 변환을 사용하여 애니메이션의 시작에 맞는 크기로 축소하는 법을 배웠습니다.

```css
/* Revised code */
.zombie {
  transform: scale(0.2);
  width: 75vw;
}

.toggle-checkbox:checked ~ .zombie {
  animation: 5s ease-in-out 0s reverseshrinkydink forwards;
}

@keyframes reverseshrinkydink {
  0% {
    transform: scale(0.2);
  }
  100% {
    transform: scale(1);
  }
}
```

간단히 말해, 수정된 코드는 이미지의 축소된 버전에서 전체 폭과 높이까지 이동합니다. 브라우저는 항상 1에서 렌더링되므로 가장자리가 1의 척도로 바삭바삭하고 깨끗해집니다. 그래서 저는 1에서 5로 스케일링을 하는 대신에 0.2에서 1로 스케일링을 했습니다.

![image](https://i1.wp.com/css-tricks.com/wp-content/uploads/2020/09/egErB-r0.png?resize=1200%2C600&ssl=1)

### 제5장: 축은 보편적인 진실이 아닙니다.

요소의 축은 페이지가 아니라 요소와 동기화 상태를 유지합니다. 번역X 앞에서 90도 회전하면 번역X의 방향이 수평에서 수직으로 바뀐다. 여기 우리 인간 말고는 아무도 없는 곳에서 2. 나는 180도 회전으로 좀비를 뒤집었다. 그러나 Y 값이 양수이면 닌자가 위쪽으로 이동하고, 음수이면 아래쪽으로 이동합니다(정상과 반대). 회전이 라인 하단의 변환에 어떤 영향을 미칠 수 있는지 주의하십시오.

![image](https://i1.wp.com/css-tricks.com/wp-content/uploads/2020/09/w49WgWy9.png?resize=1200%2C600&ssl=1)

### 제6장. 복잡한 애니메이션을 동심원소로 분리하여 쉽게 조정할 수 있습니다.

여러 방향으로 움직이는 복잡한 애니메이션을 만들고 래퍼 디브 또는 상위 요소를 추가하고 각 요소를 개별적으로 애니메이션으로 만들면 서로 충돌하는 변환이 줄어들어 사용자가 엉망이 되는 것을 방지할 수 있습니다.

예를 들어, Space Cadet에서 저는 세 가지 다른 변신을 했습니다. 첫 번째는 좀비-노우트가 위아래로 움직이는 것입니다. 두 번째는 화면을 가로지르는 움직임입니다. 세 번째는 회전입니다. 한 번의 변신으로 모든 것을 하려고 하지 않고 두 개의 랩핑 요소를 추가하고 각 요소에 대해 하나의 애니메이션을 만들었습니다(머리도 아꼈고… 적어도 일부는 절약했습니다). 이것은 가장 안쪽 요소에서 회전을 수행하고 부모 및 조부모의 축을 제자리에 두었기 때문에 지난 수업에서 논의된 축 문제를 피하는 데 도움이 되었습니다.

![image](https://i2.wp.com/css-tricks.com/wp-content/uploads/2020/09/10WdSmVq.png?resize=1024%2C725&ssl=1)

### 제7장: SVG와 CSS 변환은 동일합니다.

일부 경로와 그룹 및 기타 SVG 요소에는 이미 변환이 정의되어 있습니다. 최적화 알고리즘 또는 일러스트레이션 소프트웨어가 코드를 생성하는 방법일 수 있습니다. SVG의 경로, 그룹 또는 어떤 요소가 이미 SVG 변환을 가지고 있다면, 그 변환을 제거하면 종종 나머지 도면에 비해 이상한 위치나 크기로 요소가 재설정된다.

SVG와 CSS 변환이 같기 때문에, 당신이 사용하는 모든 CSS 변환은 SVG 변환을 대체하는데, 이것은 당신의 CSS 변환이 SVG에 설정된 위치나 크기가 아니라 이상한 위치나 크기에서 시작된다는 것을 의미한다.

변환을 SVG 요소에서 CSS로 복사하고 CSS에서 시작 위치로 설정할 수 있습니다(물론 먼저 CSS 구문으로 업데이트). 그런 다음 CSS 애니메이션에서 수정할 수 있습니다.

예를 들어, Uhhh, Yeah…에서 Undead Jumbergh의 오른쪽 상단 팔(#arm2 요소)은 원래 SVG 코드로 변환되었습니다.

```svg
<path id="arm2" fill="#91c1a3" fill-rule="nonzero" d="M0 171h9v9H0z" transform="translate(0 -343) scale(4 3.55)"/>
```

![image](https://i1.wp.com/css-tricks.com/wp-content/uploads/2020/09/WMWErIJu.png?resize=1200%2C600&ssl=1)

다음과 같이 CSS로 변환 이동:

```svg
<path id="arm2" fill="#91c1a3" fill-rule="nonzero" d="M0 171h9v9H0z"/>
```

```css
#arm2 {
  transform: translate(0, -343px) scale(4, 3.55);
}
```

…그런 다음 실수로 위치와 크기를 재설정하지 않는 애니메이션을 만들 수 있습니다.

```css
.toggle-checkbox:checked ~ .z #arm2 { 
  animation: 6s ease-in-out 0.15s arm2move forwards;
}

@keyframes arm2move {
  0%, 100% {
    transform: translate(0, -343px) scale(4, 3.55);
  }
  40%, 60% {
    transform: translate(0, -403px) scale(4, 3.55);
  }
  50% {
    transform: translate(0, -408px) scale(4, 3.55);
  }
} 
```

SVG 코드를 생성하는 도구가 행렬로 변환을 "간소화"하려고 할 때 이 프로세스는 더 어렵다. 매트릭스 변환을 CSS에 복사하여 재생성할 수 있지만 수행하기가 어렵습니다. 매트릭스 변환을 통해 원하는 방식으로 스케일링, 회전 또는 번역할 수 있다면 저보다 더 나은 개발자입니다.

또는 변환, 회전 및 배율을 사용하여 행렬 변환을 다시 만들 수 있지만 경로가 복잡할 경우 직선 재킷을 입지 않고도 적시에 행렬 변환을 다시 만들 수 있는 가능성은 낮습니다.

마지막이자 가장 쉬운 옵션은 요소를 그룹(<g>) 태그로 묶는 것입니다. 쉬운 CSS 접근을 위해 클래스나 ID를 추가하고 그룹 자체를 변환하여 마지막 수업에서 설명한 대로 변환을 분리한다.

### 제8장: SVG의 일부를 전환할 때 '변환 기원'을 사용하여 제정신 유지

CSS `transform-origin` 속성은 변환이 발생하는 지점을 이동합니다. 만약 여러분이 Clubbin` It에서처럼 팔을 회전시키려고 한다면, 여러분의 애니메이션은 어깨 중앙에서 팔을 회전시키면 더 자연스러워 보일 것입니다. 하지만 그 경로의 자연 변형 기원은 왼쪽 상단에 있습니다. 보다 부드럽고 자연스러운 느낌을 위해 `트랜스포밍 오리진`을 사용하여 이것을 고칩니다. 여러분도 알다시피, 정말 자연스러운 픽셀 아트 룩을…

![image](https://i0.wp.com/css-tricks.com/wp-content/uploads/2020/09/BW2hXAJ2.png?resize=1200%2C600&ssl=1)

기원을 변형하는 것은 무스타치오오프에서 했던 것처럼 스케일링할 때나 슈퍼 테이스티에서 공룡의 턱과 같은 입의 움직임을 회전할 때도 유용할 수 있다. 원점을 변경하지 않으면 변환은 SVG 요소의 왼쪽 상단 모서리에 있는 원점 점을 사용합니다.

### 제9장: 스프라이트 애니메이션은 반응성이 뛰어날 수 있습니다.

저는 이 프로젝트를 위해 많은 스프라이트 애니메이션을 만들었습니다(즉, 여러 개의 증분 프레임을 사용하고 캐릭터가 움직이는 것처럼 보일 정도로 빠르게 전환). 나는 하나의 넓은 파일로 영상을 만들어 하나의 프레임 크기의 요소에 배경 이미지로 추가했고, 배경 이미지를 이미지의 너비로 설정하기 위해 `배경 크기`를 사용했고, 오버플로우를 숨겼다. 그런 다음 배경위치(background-position)와 애니메이션 타이밍(step)(step)(단계)을 사용하여 영상을 살펴보았다.

프로젝트 전에는 항상 융통성 없는 이미지를 사용했습니다. 저는 반응성 있는 선물이 될 수 있도록 물건들을 좀 더 축소하고 싶지만, 저는 여러분이 그것을 완전히 유연한 폭으로 만들 수 있다고 생각하지 않았습니다. 그러나 SVG를 배경 이미지로 사용하는 경우 뷰포트 단위를 사용하여 화면 크기 변화에 따라 요소를 조정할 수 있습니다. 유일한 문제는 배경 위치입니다. 그러나 보기 포트 단위를 사용하면 동기화 상태를 유지합니다. 마지막으로 제 샌드위치와 단둘이서 확인해 보세요.

<div class="wp-block-cp-codepen-gutenberg-embed-block cp_embed_wrapper resizable" style="height: 450px;"><iframe id="cp_embed_dyGpBJx" src="//codepen.io/anon/embed/dyGpBJx?height=450&amp;theme-id=1&amp;slug-hash=dyGpBJx&amp;default-tab=result" height="450" scrolling="no" frameborder="0" allowfullscreen="" allowpaymentrequest="" name="CodePen Embed dyGpBJx" title="CodePen Embed dyGpBJx" class="cp_embed_iframe" style="width: 100%; overflow: hidden; height: 100%;">CodePen Embed Fallback</iframe><div class="win-size-grip" style="touch-action: none;"></div></div>

이 프로젝트를 통해 배운 것처럼, 단일 유형의 유닛을 사용하는 것이 거의 항상 좋은 방법입니다. 처음에는 스프라이트의 배경 크기를 백분율로 설정했습니다. 수학은 쉬웠고(`100% * (단계 수 + 1)`) 대부분의 경우 잘 작동했습니다. 그러나 더 긴 애니메이션에서는 정확한 프레임 추적이 해제되고 잘못된 스프라이트 프레임의 일부가 표시될 수 있습니다. 스프라이트에 프레임을 추가할수록 문제가 커집니다.

이것이 문제를 일으키는 정확한 이유는 잘 모르겠지만, 스프라이트 시트 길이에 걸쳐 발생하는 반올림 오류 때문이라고 생각합니다(프레임 수에 따라 시프트의 양이 증가함).

제 마지막 애니메이션 "좀비가 노래할 때까진 안돼"를 위해 저는 공룡이 그의 입을 열어 좀비 바이킹이 노래하는 모습을 보여주게 했습니다. (레이저가 배경에 발사되는 동안엔 물론 춤추는 것도 있었고, 아코디언도 연주하고, 대포에서 발사되는 좀비도 있었습니다.) 그래, 파티를 열 줄 알아. 바보 파티.

공룡과 바이킹은 내가 그 프로젝트를 위해 만든 가장 긴 스프라이트 애니메이션 중 하나였다. 하지만 제가 배경 크기를 설정하기 위해 퍼센트를 사용했을 때, 사파리의 특정 크기에서는 트랙킹이 꺼졌습니다. 애니메이션이 끝날 때쯤, 다른 틀에서 나온 공룡의 코의 일부가 오른쪽에 나타나고 왼쪽에 비슷한 부분이 없어지게 된다.

![image](https://i2.wp.com/css-tricks.com/wp-content/uploads/2020/09/rzuR5PCv.png?resize=1200%2C600&ssl=1)

크롬에서 잘 작동하는 것 같아서 진단하기가 너무 답답했고 사파리에서 조금 다른 화면 크기를 보고 프레임을 다시 보기 위해 고친 것 같아요. 그러나 "background size", "frame width", "background-position" 등의 일관된 단위를 사용한다면 모든 것이 정상적으로 작동합니다. 다시 한 번, 일관된 유닛을 사용하는 것으로 귀결됩니다!

### 제 10장: 사람들을 프로젝트에 초대합니다.

![image](https://i2.wp.com/css-tricks.com/wp-content/uploads/2020/09/IaUK1BDA.png?resize=1200%2C550&ssl=1)

저는 이 과정에서 많은 것을 배웠지만, 대부분의 경우 벽에 머리를 부딪쳤습니다(종종 벽이 깨지거나 머리가 깨질 때까지). 모르겠어요. 그렇게 하는 것도 한 가지 방법이지만, 비록 여러분이 냉철하더라도, 여러분은 여전히 두통을 앓게 될 것입니다. 다른 사람들을 여러분의 프로젝트에 초대하세요. 조언을 위해서든, 여러분이 놓친 명백한 사각지대를 지적하고, 피드백을 제공하거나, 프로젝트에 도움을 주거나, 단순히 범위가 어리석고 임의로 클 때 여러분이 계속하도록 격려하세요.

그래서 이 교훈을 실천에 옮기겠습니다. 어떻게 생각하세요? CSS 애니메이션으로 좀비 무리를 어떻게 막을 것인가? 어떤 바보 같고 자의적으로 큰 프로젝트를 맡아서 기지개를 켜실 건가요?